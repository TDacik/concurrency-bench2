// #anon_enum_EPGChannelMessageType_Event=0_EPGChannelMessageType_Detail=1_EPGChannelMessageType_Rating=2
// file ../include/epgchannel.h line 34
enum anonymous_19 { EPGChannelMessageType_Event=0, EPGChannelMessageType_Detail=1, EPGChannelMessageType_Rating=2 };

// #anon_enum_ServiceType_TV=0_ServiceType_Radio=1_ServiceType_Data=2_ServiceType_Unknown=3
// file ../include/services.h line 62
enum anonymous { ServiceType_TV=0, ServiceType_Radio=1, ServiceType_Data=2, ServiceType_Unknown=3 };

// tag-#anon#ST[*{ENtag-yaml_emitter_state_e#{U32}_U32_}_ENtag-yaml_emitter_state_e#{U32}_U32__'start'||*{ENtag-yaml_emitter_state_e#{U32}_U32_}_ENtag-yaml_emitter_state_e#{U32}_U32__'end'||*{ENtag-yaml_emitter_state_e#{U32}_U32_}_ENtag-yaml_emitter_state_e#{U32}_U32__'top'|]
// file /usr/include/yaml.h line 1616
struct anonymous_53;

// tag-#anon#ST[*{ENtag-yaml_parser_state_e#{U32}_U32_}_ENtag-yaml_parser_state_e#{U32}_U32__'start'||*{ENtag-yaml_parser_state_e#{U32}_U32_}_ENtag-yaml_parser_state_e#{U32}_U32__'end'||*{ENtag-yaml_parser_state_e#{U32}_U32_}_ENtag-yaml_parser_state_e#{U32}_U32__'top'|]
// file /usr/include/yaml.h line 1245
struct anonymous_61;

// tag-#anon#ST[*{S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32}_S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32_'set'||*{S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32}_S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32_'get'|]
// file properties.c line 53
struct anonymous_37;

// tag-#anon#ST[*{S32}_S32_'start'||*{S32}_S32_'end'||*{S32}_S32_'top'|]
// file /usr/include/yaml.h line 741
struct anonymous_33;

// tag-#anon#ST[*{SYM#tag-Multiplex_s#}_SYM#tag-Multiplex_s#_'multiplex'||S32'networkId'||U32'_pad0'|]
// file cache.c line 93
struct anonymous_2;

// tag-#anon#ST[*{SYM#tag-Multiplex_s#}_SYM#tag-Multiplex_s#_'multiplex'||S32'tsId'||U32'_pad0'|]
// file cache.c line 87
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'|]
// file cache.c line 155
struct anonymous_12;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{S8}_S8_'defaultAuthority'|]
// file cache.c line 141
struct anonymous_10;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{S8}_S8_'name'|]
// file cache.c line 111
struct anonymous_5;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{S8}_S8_'provider'|]
// file cache.c line 135
struct anonymous_9;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{SYM#tag-ProgramInfo_s#}_SYM#tag-ProgramInfo_s#_'info'|]
// file cache.c line 105
struct anonymous_4;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||B'ca'||U56'_pad0'|]
// file cache.c line 123
struct anonymous_7;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||EN#anon_enum_ServiceType_TV=0_ServiceType_Radio=1_ServiceType_Data=2_ServiceType_Unknown=3#{U32}_U32_'type'||U32'_pad0'|]
// file cache.c line 129
struct anonymous_8;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||S32'pmtPid'||U32'_pad0'|]
// file cache.c line 99
struct anonymous_3;

// tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||U16'source'||U48'_pad0'|]
// file cache.c line 117
struct anonymous_6;

// tag-#anon#ST[*{SYM#tag-yaml_alias_data_s#}_SYM#tag-yaml_alias_data_s#_'start'||*{SYM#tag-yaml_alias_data_s#}_SYM#tag-yaml_alias_data_s#_'end'||*{SYM#tag-yaml_alias_data_s#}_SYM#tag-yaml_alias_data_s#_'top'|]
// file /usr/include/yaml.h line 1287
struct anonymous_63;

// tag-#anon#ST[*{SYM#tag-yaml_event_s#}_SYM#tag-yaml_event_s#_'start'||*{SYM#tag-yaml_event_s#}_SYM#tag-yaml_event_s#_'end'||*{SYM#tag-yaml_event_s#}_SYM#tag-yaml_event_s#_'head'||*{SYM#tag-yaml_event_s#}_SYM#tag-yaml_event_s#_'tail'|]
// file /usr/include/yaml.h line 1629
struct anonymous_54;

// tag-#anon#ST[*{SYM#tag-yaml_mark_s#}_SYM#tag-yaml_mark_s#_'start'||*{SYM#tag-yaml_mark_s#}_SYM#tag-yaml_mark_s#_'end'||*{SYM#tag-yaml_mark_s#}_SYM#tag-yaml_mark_s#_'top'|]
// file /usr/include/yaml.h line 1258
struct anonymous_62;

// tag-#anon#ST[*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'start'||*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'end'||*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'top'|]
// file /usr/include/yaml.h line 756
struct anonymous_34;

// tag-#anon#ST[*{SYM#tag-yaml_node_s#}_SYM#tag-yaml_node_s#_'start'||*{SYM#tag-yaml_node_s#}_SYM#tag-yaml_node_s#_'end'||*{SYM#tag-yaml_node_s#}_SYM#tag-yaml_node_s#_'top'|]
// file /usr/include/yaml.h line 781
struct anonymous_16;

// tag-#anon#ST[*{SYM#tag-yaml_simple_key_s#}_SYM#tag-yaml_simple_key_s#_'start'||*{SYM#tag-yaml_simple_key_s#}_SYM#tag-yaml_simple_key_s#_'end'||*{SYM#tag-yaml_simple_key_s#}_SYM#tag-yaml_simple_key_s#_'top'|]
// file /usr/include/yaml.h line 1226
struct anonymous_60;

// tag-#anon#ST[*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'start'||*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'end'|]
// file /usr/include/yaml.h line 404
struct anonymous_17;

// tag-#anon#ST[*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'start'||*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'end'||*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'top'|]
// file /usr/include/yaml.h line 1268
struct anonymous_55;

// tag-#anon#ST[*{SYM#tag-yaml_token_s#}_SYM#tag-yaml_token_s#_'start'||*{SYM#tag-yaml_token_s#}_SYM#tag-yaml_token_s#_'end'||*{SYM#tag-yaml_token_s#}_SYM#tag-yaml_token_s#_'head'||*{SYM#tag-yaml_token_s#}_SYM#tag-yaml_token_s#_'tail'|]
// file /usr/include/yaml.h line 1192
struct anonymous_51;

// tag-#anon#ST[*{SYM#tag-yaml_version_directive_s#}_SYM#tag-yaml_version_directive_s#_'version_directive'||SYM#tag-#anon#ST[*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'start'||*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'end'|]#'tag_directives'||S32'implicit'||U32'_pad0'|]
// file /usr/include/yaml.h line 399
struct anonymous_44;

// tag-#anon#ST[*{U8}_U8_'anchor'|]
// file /usr/include/yaml.h line 422
struct anonymous_39;

// tag-#anon#ST[*{U8}_U8_'anchor'||*{U8}_U8_'tag'||*{U8}_U8_'value'||U64'length'||S32'plain_implicit'||S32'quoted_implicit'||ENtag-yaml_scalar_style_e#{U32}_U32_'style'||U32'_pad0'|]
// file /usr/include/yaml.h line 428
struct anonymous_40;

// tag-#anon#ST[*{U8}_U8_'anchor'||*{U8}_U8_'tag'||S32'implicit'||ENtag-yaml_mapping_style_e#{U32}_U32_'style'|]
// file /usr/include/yaml.h line 458
struct anonymous_42;

// tag-#anon#ST[*{U8}_U8_'anchor'||*{U8}_U8_'tag'||S32'implicit'||ENtag-yaml_sequence_style_e#{U32}_U32_'style'|]
// file /usr/include/yaml.h line 446
struct anonymous_41;

// tag-#anon#ST[*{U8}_U8_'anchor'||U64'anchor_length'||S32'alias'||U32'_pad0'|]
// file /usr/include/yaml.h line 1687
struct anonymous_56;

// tag-#anon#ST[*{U8}_U8_'buffer'||U64'size'||*{U64}_U64_'size_written'|]
// file /usr/include/yaml.h line 1555
struct anonymous_64;

// tag-#anon#ST[*{U8}_U8_'handle'||*{U8}_U8_'prefix'|]
// file /usr/include/yaml.h line 320
struct anonymous_68;

// tag-#anon#ST[*{U8}_U8_'handle'||*{U8}_U8_'suffix'|]
// file /usr/include/yaml.h line 294
struct anonymous_66;

// tag-#anon#ST[*{U8}_U8_'handle'||U64'handle_length'||*{U8}_U8_'suffix'||U64'suffix_length'|]
// file /usr/include/yaml.h line 1697
struct anonymous_57;

// tag-#anon#ST[*{U8}_U8_'start'||*{U8}_U8_'end'||*{U8}_U8_'pointer'||*{U8}_U8_'last'|]
// file /usr/include/yaml.h line 1138
struct anonymous_49;

// tag-#anon#ST[*{U8}_U8_'value'|]
// file /usr/include/yaml.h line 282
struct anonymous_65;

// tag-#anon#ST[*{U8}_U8_'value'||U64'length'||ENtag-yaml_scalar_style_e#{U32}_U32_'style'||U32'_pad0'|]
// file /usr/include/yaml.h line 302
struct anonymous_22;

// tag-#anon#ST[*{U8}_U8_'value'||U64'length'||S32'multiline'||S32'flow_plain_allowed'||S32'block_plain_allowed'||S32'single_quoted_allowed'||S32'block_allowed'||ENtag-yaml_scalar_style_e#{U32}_U32_'style'|]
// file /usr/include/yaml.h line 1709
struct anonymous_58;

// tag-#anon#ST[*{cU8}_cU8_'start'||*{cU8}_cU8_'end'||*{cU8}_cU8_'current'|]
// file /usr/include/yaml.h line 1121
struct anonymous_47;

// tag-#anon#ST[ARR32{U8}_U8_'data'||U32'len'||ARR3{U32}_U32_'reserved1'||*{V}_V_'reserved2'|]
// file /usr/include/linux/dvb/frontend.h line 469
struct anonymous_29;

// tag-#anon#ST[ENtag-yaml_encoding_e#{U32}_U32_'encoding'|]
// file /usr/include/yaml.h line 276
struct anonymous_43;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_26;

// tag-#anon#ST[S32'id'||S32'source'||S32'multiplexUID'||U32'_pad0'||*{S8}_S8_'name'|]
// file cache.c line 147
struct anonymous_11;

// tag-#anon#ST[S32'implicit'|]
// file /usr/include/yaml.h line 416
struct anonymous_45;

// tag-#anon#ST[S32'major'||S32'minor'|]
// file /usr/include/yaml.h line 312
struct anonymous_67;

// tag-#anon#ST[S32'references'||S32'anchor'||S32'serialized'|]
// file /usr/include/yaml.h line 1743
struct anonymous_59;

// tag-#anon#ST[SYM#tag-#anon#ST[*{S32}_S32_'start'||*{S32}_S32_'end'||*{S32}_S32_'top'|]#'items'||ENtag-yaml_sequence_style_e#{U32}_U32_'style'||U32'_pad0'|]
// file /usr/include/yaml.h line 739
struct anonymous_23;

// tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'start'||*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'end'||*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'top'|]#'pairs'||ENtag-yaml_mapping_style_e#{U32}_U32_'style'||U32'_pad0'|]
// file /usr/include/yaml.h line 754
struct anonymous_24;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_25;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_38;

// tag-#anon#UN[S32'integer'||F64'fp'||B'boolean'||*{S8}_S8_'string'||S8'ch'||U16'pid'|]
// file ../include/properties.h line 51
union anonymous_15;

// tag-#anon#UN[SYM#tag-#anon#ST[*{S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32}_S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32_'set'||*{S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32}_S32(*{V}_V_|*{SYM#tag-PropertyValue_s#}_SYM#tag-PropertyValue_s#_)->S32_'get'|]#'simple'|]
// file properties.c line 52
union anonymous_36;

// tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-Multiplex_s#}_SYM#tag-Multiplex_s#_'multiplex'||S32'tsId'||U32'_pad0'|]#'multiplexTSId'||SYM#tag-#anon#ST[*{SYM#tag-Multiplex_s#}_SYM#tag-Multiplex_s#_'multiplex'||S32'networkId'||U32'_pad0'|]#'multiplexNetworkId'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||S32'pmtPid'||U32'_pad0'|]#'servicePMTPID'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{SYM#tag-ProgramInfo_s#}_SYM#tag-ProgramInfo_s#_'info'|]#'servicePIDs'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{S8}_S8_'name'|]#'serviceName'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||U16'source'||U48'_pad0'|]#'serviceSource'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||B'ca'||U56'_pad0'|]#'serviceCA'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||EN#anon_enum_ServiceType_TV=0_ServiceType_Radio=1_ServiceType_Data=2_ServiceType_Unknown=3#{U32}_U32_'type'||U32'_pad0'|]#'serviceType'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{S8}_S8_'provider'|]#'serviceProvider'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'||*{S8}_S8_'defaultAuthority'|]#'serviceDefaultAuthority'||SYM#tag-#anon#ST[S32'id'||S32'source'||S32'multiplexUID'||U32'_pad0'||*{S8}_S8_'name'|]#'serviceAdd'||SYM#tag-#anon#ST[*{SYM#tag-Service_t#}_SYM#tag-Service_t#_'service'|]#'serviceDelete'|]
// file cache.c line 85
union anonymous_13;

// tag-#anon#UN[SYM#tag-#anon#ST[*{U8}_U8_'buffer'||U64'size'||*{U64}_U64_'size_written'|]#'string'||*{SYM#tag-_IO_FILE#}_SYM#tag-_IO_FILE#_'file'|]
// file /usr/include/yaml.h line 1553
union anonymous_52;

// tag-#anon#UN[SYM#tag-#anon#ST[*{U8}_U8_'value'||U64'length'||ENtag-yaml_scalar_style_e#{U32}_U32_'style'||U32'_pad0'|]#'scalar'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{S32}_S32_'start'||*{S32}_S32_'end'||*{S32}_S32_'top'|]#'items'||ENtag-yaml_sequence_style_e#{U32}_U32_'style'||U32'_pad0'|]#'sequence'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'start'||*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'end'||*{SYM#tag-yaml_node_pair_s#}_SYM#tag-yaml_node_pair_s#_'top'|]#'pairs'||ENtag-yaml_mapping_style_e#{U32}_U32_'style'||U32'_pad0'|]#'mapping'|]
// file /usr/include/yaml.h line 726
union anonymous_18;

// tag-#anon#UN[SYM#tag-#anon#ST[*{cU8}_cU8_'start'||*{cU8}_cU8_'end'||*{cU8}_cU8_'current'|]#'string'||*{SYM#tag-_IO_FILE#}_SYM#tag-_IO_FILE#_'file'|]
// file /usr/include/yaml.h line 1119
union anonymous_48;

// tag-#anon#UN[SYM#tag-#anon#ST[ENtag-yaml_encoding_e#{U32}_U32_'encoding'|]#'stream_start'||SYM#tag-#anon#ST[*{SYM#tag-yaml_version_directive_s#}_SYM#tag-yaml_version_directive_s#_'version_directive'||SYM#tag-#anon#ST[*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'start'||*{SYM#tag-yaml_tag_directive_s#}_SYM#tag-yaml_tag_directive_s#_'end'|]#'tag_directives'||S32'implicit'||U32'_pad0'|]#'document_start'||SYM#tag-#anon#ST[S32'implicit'|]#'document_end'||SYM#tag-#anon#ST[*{U8}_U8_'anchor'|]#'alias'||SYM#tag-#anon#ST[*{U8}_U8_'anchor'||*{U8}_U8_'tag'||*{U8}_U8_'value'||U64'length'||S32'plain_implicit'||S32'quoted_implicit'||ENtag-yaml_scalar_style_e#{U32}_U32_'style'||U32'_pad0'|]#'scalar'||SYM#tag-#anon#ST[*{U8}_U8_'anchor'||*{U8}_U8_'tag'||S32'implicit'||ENtag-yaml_sequence_style_e#{U32}_U32_'style'|]#'sequence_start'||SYM#tag-#anon#ST[*{U8}_U8_'anchor'||*{U8}_U8_'tag'||S32'implicit'||ENtag-yaml_mapping_style_e#{U32}_U32_'style'|]#'mapping_start'|]
// file /usr/include/yaml.h line 390
union anonymous_46;

// tag-#anon#UN[SYM#tag-#anon#ST[ENtag-yaml_encoding_e#{U32}_U32_'encoding'|]#'stream_start'||SYM#tag-#anon#ST[*{U8}_U8_'value'|]#'alias'||SYM#tag-#anon#ST[*{U8}_U8_'value'|]#'anchor'||SYM#tag-#anon#ST[*{U8}_U8_'handle'||*{U8}_U8_'suffix'|]#'tag'||SYM#tag-#anon#ST[*{U8}_U8_'value'||U64'length'||ENtag-yaml_scalar_style_e#{U32}_U32_'style'||U32'_pad0'|]#'scalar'||SYM#tag-#anon#ST[S32'major'||S32'minor'|]#'version_directive'||SYM#tag-#anon#ST[*{U8}_U8_'handle'||*{U8}_U8_'prefix'|]#'tag_directive'|]
// file /usr/include/yaml.h line 273
union anonymous_50;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_21;

// tag-#anon#UN[SYM#tag-EPGEvent_s#'event'||SYM#tag-EPGEventDetail_s#'detail'||SYM#tag-EPGEventRating_s#'rating'|]
// file ../include/epgchannel.h line 43
union anonymous_20;

// tag-#anon#UN[SYM#tag-PluginEventListenerDetails_s#'eventDetails'||SYM#tag-DeliveryMethodHandler_t#'dmHandler'||*{V(*{SYM#tag-dvbpsi_pmt_s#}_SYM#tag-dvbpsi_pmt_s#_)->V}_V(*{SYM#tag-dvbpsi_pmt_s#}_SYM#tag-dvbpsi_pmt_s#_)->V_'patCB'||*{V(*{SYM#tag-dvbpsi_pmt_s#}_SYM#tag-dvbpsi_pmt_s#_)->V}_V(*{SYM#tag-dvbpsi_pmt_s#}_SYM#tag-dvbpsi_pmt_s#_)->V_'pmtCB'||*{V(*{SYM#tag-dvbpsi_sdt_s#}_SYM#tag-dvbpsi_sdt_s#_)->V}_V(*{SYM#tag-dvbpsi_sdt_s#}_SYM#tag-dvbpsi_sdt_s#_)->V_'sdtCB'||*{V(*{SYM#tag-dvbpsi_nit_s#}_SYM#tag-dvbpsi_nit_s#_)->V}_V(*{SYM#tag-dvbpsi_nit_s#}_SYM#tag-dvbpsi_nit_s#_)->V_'nitCB'||*{V(*{SYM#tag-dvbpsi_tdt_tot_s#}_SYM#tag-dvbpsi_tdt_tot_s#_)->V}_V(*{SYM#tag-dvbpsi_tdt_tot_s#}_SYM#tag-dvbpsi_tdt_tot_s#_)->V_'tdtCB'||*{V(*{SYM#tag-dvbpsi_atsc_mgt_s#}_SYM#tag-dvbpsi_atsc_mgt_s#_)->V}_V(*{SYM#tag-dvbpsi_atsc_mgt_s#}_SYM#tag-dvbpsi_atsc_mgt_s#_)->V_'mgtCB'||*{V(*{SYM#tag-dvbpsi_atsc_stt_s#}_SYM#tag-dvbpsi_atsc_stt_s#_)->V}_V(*{SYM#tag-dvbpsi_atsc_stt_s#}_SYM#tag-dvbpsi_atsc_stt_s#_)->V_'sttCB'||*{V(*{SYM#tag-dvbpsi_atsc_vct_s#}_SYM#tag-dvbpsi_atsc_vct_s#_)->V}_V(*{SYM#tag-dvbpsi_atsc_vct_s#}_SYM#tag-dvbpsi_atsc_vct_s#_)->V_'vctCB'||*{V(*{SYM#tag-Multiplex_s#}_SYM#tag-Multiplex_s#_|*{SYM#tag-Service_t#}_SYM#tag-Service_t#_)->V}_V(*{SYM#tag-Multiplex_s#}_SYM#tag-Multiplex_s#_|*{SYM#tag-Service_t#}_SYM#tag-Service_t#_)->V_'channelChangeCB'||*{V(B)->V}_V(B)->V_'installCB'|]
// file ../include/plugin.h line 200
union anonymous_31;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_14;

// tag-#anon#UN[SYM#tag-dvb_qpsk_parameters#'qpsk'||SYM#tag-dvb_qam_parameters#'qam'||SYM#tag-dvb_ofdm_parameters#'ofdm'||SYM#tag-dvb_vsb_parameters#'vsb'|]
// file /usr/include/linux/dvb/frontend.h line 551
union anonymous_32;

// tag-#anon#UN[U32'data'||SYM#tag-dtv_fe_stats#'st'||SYM#tag-#anon#ST[ARR32{U8}_U8_'data'||U32'len'||ARR3{U32}_U32_'reserved1'||*{V}_V_'reserved2'|]#'buffer'|]
// file /usr/include/linux/dvb/frontend.h line 466
union anonymous_30;

// tag-#anon#UN[U32'nrofEntries'||*{V}_V_'__forceAlignment'|]
// file ../include/objects.h line 42
union anonymous_35;

// tag-#anon#UN[U64'uvalue'||S64'svalue'|]
// file /usr/include/linux/dvb/frontend.h line 449
union anonymous_28;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_27;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_0;

// tag-ATSCMultipleStrings_s
// file ../include/atsctext.h line 45
struct ATSCMultipleStrings_s;

// tag-ATSCString_s
// file ../include/atsctext.h line 36
struct ATSCString_s;

// tag-CS
// file standard/dvb/dvbtext.c line 40
enum CS { CS_UNKNOWN=0, ISO6937=1, ISO8859_5=2, ISO8859_6=3, ISO8859_7=4, ISO8859_8=5, ISO8859_9=6, ISO10646=7, CS_OTHER=8 };

// tag-CacheFlags
// file cache.c line 49
enum CacheFlags { CacheFlag_Clean=0, CacheFlag_Dirty_PMTPID=1, CacheFlag_Dirty_ProgramInfo=2, CacheFlag_Dirty_Name=4, CacheFlag_Dirty_Source=8, CacheFlag_Dirty_CA=16, CacheFlag_Dirty_Type=32, CacheFlag_Dirty_Provider=64, CacheFlag_Dirty_DefAuth=96, CacheFlag_Not_Seen_In_SDT=8192, CacheFlag_Not_Seen_In_PAT=16384, CacheFlag_Dirty_Added=32768 };

// tag-CacheUpdateMessage_s
// file cache.c line 82
struct CacheUpdateMessage_s;

// tag-CacheUpdateType
// file cache.c line 65
enum CacheUpdateType { CacheUpdate_Multiplex_TS_id=0, CacheUpdate_Multiplex_Network_id=1, CacheUpdate_Service_PMT_PID=2, CacheUpdate_Service_PIDs=3, CacheUpdate_Service_Name=4, CacheUpdate_Service_Source=5, CacheUpdate_Service_CA=6, CacheUpdate_Service_Type=7, CacheUpdate_Service_Provider=8, CacheUpdate_Service_Default_Auth=9, CacheUpdate_Service_Added=10, CacheUpdate_Service_Deleted=11 };

// tag-ClassType_e
// file objects.c line 54
enum ClassType_e { ClassType_Object=0, ClassType_Collection=1 };

// tag-Class_s
// file objects.c line 59
struct Class_s;

// tag-CommandContext_t
// file ../include/commands.h line 92
struct CommandContext_t;

// tag-Command_t
// file ../include/commands.h line 49
struct Command_t;

// tag-Connection_t
// file remoteintf.c line 59
struct Connection_t;

// tag-DVBAdapterPIDFilter_s
// file ../include/dvbadapter.h line 79
struct DVBAdapterPIDFilter_s;

// tag-DVBAdapter_s
// file ../include/dvbadapter.h line 119
struct DVBAdapter_s;

// tag-DVBDeliverySystem_e
// file ../include/dvbadapter.h line 85
enum DVBDeliverySystem_e { DELSYS_DVBS=0, DELSYS_DVBC=1, DELSYS_DVBT=2, DELSYS_ATSC=3, DELSYS_DVBS2=4, DELSYS_DVBT2=5, DELSYS_ISDBT=6, DELSYS_MAX_SUPPORTED=7 };

// tag-DVBFrontEndStatus_e
// file ../include/dvbadapter.h line 104
enum DVBFrontEndStatus_e { FESTATUS_HAS_SIGNAL=1, FESTATUS_HAS_CARRIER=2, FESTATUS_HAS_VITERBI=4, FESTATUS_HAS_SYNC=8, FESTATUS_HAS_LOCK=16, FESTATUS_TIMEDOUT=32, FESTATUS_REINIT=64 };

// tag-DVBSatelliteSettings_s
// file dvbadapter.c line 147
struct DVBSatelliteSettings_s;

// tag-DVBSupportedDeliverySys_s
// file ../include/dvbadapter.h line 98
struct DVBSupportedDeliverySys_s;

// tag-DeferredJob_s
// file threading/deferredproc.c line 38
struct DeferredJob_s;

// tag-DeliveryMethodHandler_t
// file ../include/deliverymethod.h line 128
struct DeliveryMethodHandler_t;

// tag-DeliveryMethodInstanceOps_t
// file ../include/deliverymethod.h line 60
struct DeliveryMethodInstanceOps_t;

// tag-DeliveryMethodInstance_t
// file ../include/deliverymethod.h line 49
struct DeliveryMethodInstance_t;

// tag-EPGChannelMessage_s
// file ../include/epgchannel.h line 40
struct EPGChannelMessage_s;

// tag-EPGEventDetail_s
// file ../include/epgtypes.h line 86
struct EPGEventDetail_s;

// tag-EPGEventRating_s
// file ../include/epgtypes.h line 77
struct EPGEventRating_s;

// tag-EPGEventRef_s
// file ../include/epgtypes.h line 58
struct EPGEventRef_s;

// tag-EPGEvent_s
// file ../include/epgtypes.h line 67
struct EPGEvent_s;

// tag-EPGServiceRef_s
// file ../include/epgtypes.h line 48
struct EPGServiceRef_s;

// tag-EventListenerDetails_s
// file events.c line 58
struct EventListenerDetails_s;

// tag-EventSource_s
// file ../include/events.h line 59
struct EventSource_s;

// tag-Event_s
// file ../include/events.h line 65
struct Event_s;

// tag-LNBInfo_s
// file ../include/lnb.h line 9
struct LNBInfo_s;

// tag-ListEntry_s
// file ../include/list.h line 37
struct ListEntry_s;

// tag-ListIterator_s
// file ../include/list.h line 57
struct ListIterator_s;

// tag-List_s
// file ../include/list.h line 47
struct List_s;

// tag-MessageQ_s
// file ../include/messageq.h line 37
struct MessageQ_s;

// tag-ModuleLevel_s
// file logging.c line 59
struct ModuleLevel_s;

// tag-MultiplexList_s
// file ../include/multiplexes.h line 57
struct MultiplexList_s;

// tag-Multiplex_s
// file ../include/multiplexes.h line 44
struct Multiplex_s;

// tag-MuxFrequencies_s
// file commands/cmd_scanning.c line 115
struct MuxFrequencies_s;

// tag-MuxFrequency_s
// file commands/cmd_scanning.c line 108
struct MuxFrequency_s;

// tag-NITProcessor_s
// file ../include/nitprocessor.h line 28
struct NITProcessor_s;

// tag-ObjectCollection_s
// file ../include/objects.h line 41
struct ObjectCollection_s;

// tag-Object_s
// file objects.c line 68
struct Object_s;

// tag-PATProcessor_s
// file ../include/patprocessor.h line 27
struct PATProcessor_s;

// tag-PMTProcessor_s
// file ../include/pmtprocessor.h line 28
struct PMTProcessor_s;

// tag-PMTReceived_t
// file commands/cmd_scanning.c line 67
struct PMTReceived_t;

// tag-PSIPProcessor_s
// file ../include/psipprocessor.h line 27
struct PSIPProcessor_s;

// tag-PluginEntry_t
// file pluginmgr.c line 44
struct PluginEntry_t;

// tag-PluginEventListenerDetails_s
// file ../include/plugin.h line 116
struct PluginEventListenerDetails_s;

// tag-PluginFeatureInfo_t
// file pluginmgr.c line 50
struct PluginFeatureInfo_t;

// tag-PluginFeature_t
// file ../include/plugin.h line 197
struct PluginFeature_t;

// tag-Plugin_t
// file ../include/plugin.h line 254
struct Plugin_t;

// tag-Polarisation_e
// file dvbadapter.c line 137
enum Polarisation_e { POL_HORIZONTAL=0, POL_VERTICAL=1 };

// tag-ProgramInfo_s
// file ../include/pids.h line 63
struct ProgramInfo_s;

// tag-PropertyInfo_s
// file ../include/properties.h line 61
struct PropertyInfo_s;

// tag-PropertyNode_s
// file properties.c line 44
struct PropertyNode_s;

// tag-PropertyPathElements_s
// file ../include/properties.h line 76
struct PropertyPathElements_s;

// tag-PropertyType_e
// file ../include/properties.h line 33
enum PropertyType_e { PropertyType_None=0, PropertyType_Int=1, PropertyType_Float=2, PropertyType_Boolean=3, PropertyType_String=4, PropertyType_Char=5, PropertyType_PID=6, PropertyType_IPAddress=7 };

// tag-PropertyValue_s
// file ../include/properties.h line 49
struct PropertyValue_s;

// tag-SDTProcessor_s
// file ../include/sdtprocessor.h line 26
struct SDTProcessor_s;

// tag-ScanEntry_s
// file commands/cmd_scanning.c line 91
struct ScanEntry_s;

// tag-ScanEvent_e
// file commands/cmd_scanning.c line 126
enum ScanEvent_e { ScanEvent_NoEvent=0, ScanEvent_StateEntered=1, ScanEvent_FELocked=2, ScanEvent_NextTuningParams=3, ScanEvent_PATReceived=4, ScanEvent_PMTsReceived=5, ScanEvent_SDTReceived=6, ScanEvent_Cancel=7, ScanEvent_TimerTick=8 };

// tag-ScanList_s
// file commands/cmd_scanning.c line 99
struct ScanList_s;

// tag-ScanState_e
// file commands/cmd_scanning.c line 139
enum ScanState_e { ScanState_Init=0, ScanState_NextMux=1, ScanState_WaitingForTables=2, ScanState_WaitingForNIT=3, ScanState_Stopping=4, ScanState_Stopped=5, ScanState_Canceling=6 };

// tag-ScanType_e
// file commands/cmd_scanning.c line 121
enum ScanType_e { ScanType_List=0, ScanType_Network=1 };

// tag-ServiceFilter_s
// file ../include/servicefilter.h line 45
struct ServiceFilter_s;

// tag-ServiceList_s
// file ../include/services.h line 94
struct ServiceList_s;

// tag-Service_t
// file ../include/services.h line 72
struct Service_t;

// tag-StreamInfoList_t
// file ../include/pids.h line 54
struct StreamInfoList_t;

// tag-StreamInfo_t
// file ../include/pids.h line 44
struct StreamInfo_t;

// tag-StringOutput_s
// file yamlutils.c line 41
struct StringOutput_s;

// tag-StringToParamMapping_s
// file dvbadapter.c line 198
struct StringToParamMapping_s;

// tag-TDTProcessor_s
// file ../include/tdtprocessor.h line 27
struct TDTProcessor_s;

// tag-TSFilterEventType_e
// file ../include/ts.h line 167
enum TSFilterEventType_e { TSFilterEventType_MuxChanged=0, TSFilterEventType_StructureChanged=1 };

// tag-TSFilterGroupStats_t
// file ../include/ts.h line 271
struct TSFilterGroupStats_t;

// tag-TSFilterGroupTypeStats_t
// file ../include/ts.h line 279
struct TSFilterGroupTypeStats_t;

// tag-TSFilterGroup_t
// file ../include/ts.h line 173
struct TSFilterGroup_t;

// tag-TSPacketFilter_t
// file ../include/ts.h line 178
struct TSPacketFilter_t;

// tag-TSPacket_t
// file ../include/ts.h line 57
struct TSPacket_t;

// tag-TSReaderStats_t
// file ../include/ts.h line 286
struct TSReaderStats_t;

// tag-TSReader_t
// file ../include/ts.h line 212
struct TSReader_t;

// tag-TSSectionFilterList_t
// file ../include/ts.h line 204
struct TSSectionFilterList_t;

// tag-TSSectionFilter_t
// file ../include/ts.h line 191
struct TSSectionFilter_t;

// tag-ThreadName_s
// file logging.c line 53
struct ThreadName_s;

// tag-TransponderEntry_s
// file commands/cmd_scanning.c line 74
struct TransponderEntry_s;

// tag-TuningParamDocs_s
// file commands/cmd_scanning.c line 85
struct TuningParamDocs_s;

// tag-YUStringSection_s
// file yamlutils.c line 36
struct YUStringSection_s;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-dmx_input
// file /usr/include/linux/dvb/dmx.h line 46
enum dmx_input { DMX_IN_FRONTEND=0, DMX_IN_DVR=1 };

// tag-dmx_output
// file /usr/include/linux/dvb/dmx.h line 33
enum dmx_output { DMX_OUT_DECODER=0, DMX_OUT_TAP=1, DMX_OUT_TS_TAP=2, DMX_OUT_TSDEMUX_TAP=3 };

// tag-dmx_pes_filter_params
// file /usr/include/linux/dvb/dmx.h line 110
struct dmx_pes_filter_params;

// tag-dmx_ts_pes
// file /usr/include/linux/dvb/dmx.h line 53
enum dmx_ts_pes { DMX_PES_AUDIO0=0, DMX_PES_VIDEO0=1, DMX_PES_TELETEXT0=2, DMX_PES_SUBTITLE0=3, DMX_PES_PCR0=4, DMX_PES_AUDIO1=5, DMX_PES_VIDEO1=6, DMX_PES_TELETEXT1=7, DMX_PES_SUBTITLE1=8, DMX_PES_PCR1=9, DMX_PES_AUDIO2=10, DMX_PES_VIDEO2=11, DMX_PES_TELETEXT2=12, DMX_PES_SUBTITLE2=13, DMX_PES_PCR2=14, DMX_PES_AUDIO3=15, DMX_PES_VIDEO3=16, DMX_PES_TELETEXT3=17, DMX_PES_SUBTITLE3=18, DMX_PES_PCR3=19, DMX_PES_OTHER=20 };

// tag-dtv_fe_stats
// file /usr/include/linux/dvb/frontend.h line 458
struct dtv_fe_stats;

// tag-dtv_properties
// file /usr/include/linux/dvb/frontend.h line 482
struct dtv_properties;

// tag-dtv_property
// file /usr/include/linux/dvb/frontend.h line 463
struct dtv_property;

// tag-dtv_stats
// file /usr/include/linux/dvb/frontend.h line 447
struct dtv_stats;

// tag-dvb_diseqc_master_cmd
// file /usr/include/linux/dvb/frontend.h line 91
struct dvb_diseqc_master_cmd;

// tag-dvb_frontend_event
// file /usr/include/linux/dvb/frontend.h line 559
struct dvb_frontend_event;

// tag-dvb_frontend_info
// file /usr/include/linux/dvb/frontend.h line 72
struct dvb_frontend_info;

// tag-dvb_frontend_parameters
// file /usr/include/linux/dvb/frontend.h line 547
struct dvb_frontend_parameters;

// tag-dvb_ofdm_parameters
// file /usr/include/linux/dvb/frontend.h line 537
struct dvb_ofdm_parameters;

// tag-dvb_qam_parameters
// file /usr/include/linux/dvb/frontend.h line 527
struct dvb_qam_parameters;

// tag-dvb_qpsk_parameters
// file /usr/include/linux/dvb/frontend.h line 522
struct dvb_qpsk_parameters;

// tag-dvb_vsb_parameters
// file /usr/include/linux/dvb/frontend.h line 533
struct dvb_vsb_parameters;

// tag-dvbpsi_atsc_mgt_s
// file ../include/dvbpsi/atsc/mgt.h line 64
struct dvbpsi_atsc_mgt_s;

// tag-dvbpsi_atsc_mgt_table_s
// file ../include/dvbpsi/atsc/mgt.h line 39
struct dvbpsi_atsc_mgt_table_s;

// tag-dvbpsi_atsc_stt_s
// file ../include/dvbpsi/atsc/stt.h line 41
struct dvbpsi_atsc_stt_s;

// tag-dvbpsi_atsc_vct_channel_s
// file ../include/dvbpsi/atsc/vct.h line 39
struct dvbpsi_atsc_vct_channel_s;

// tag-dvbpsi_atsc_vct_s
// file ../include/dvbpsi/atsc/vct.h line 79
struct dvbpsi_atsc_vct_s;

// tag-dvbpsi_decoder_s
// file ../include/dvbpsi/dvbpsi.h line 51
struct dvbpsi_decoder_s;

// tag-dvbpsi_default_authority_dr_s
// file ../include/dvbpsi/dr_73.h line 39
struct dvbpsi_default_authority_dr_s;

// tag-dvbpsi_descriptor_s
// file ../include/dvbpsi/descriptor.h line 54
struct dvbpsi_descriptor_s;

// tag-dvbpsi_frequency_list_dr_s
// file ../include/dvbpsi/dr_62.h line 39
struct dvbpsi_frequency_list_dr_s;

// tag-dvbpsi_nit_s
// file ../include/dvbpsi/nit.h line 70
struct dvbpsi_nit_s;

// tag-dvbpsi_nit_transport_s
// file ../include/dvbpsi/nit.h line 43
struct dvbpsi_nit_transport_s;

// tag-dvbpsi_pat_program_s
// file ../include/dvbpsi/pat.h line 58
struct dvbpsi_pat_program_s;

// tag-dvbpsi_pat_s
// file ../include/dvbpsi/pat.h line 83
struct dvbpsi_pat_s;

// tag-dvbpsi_pmt_es_s
// file ../include/dvbpsi/pmt.h line 58
struct dvbpsi_pmt_es_s;

// tag-dvbpsi_pmt_s
// file ../include/dvbpsi/pmt.h line 85
struct dvbpsi_pmt_s;

// tag-dvbpsi_psi_section_s
// file ../include/dvbpsi/dvbpsi.h line 78
struct dvbpsi_psi_section_s;

// tag-dvbpsi_sat_deliv_sys_dr_s
// file ../include/dvbpsi/dr_43.h line 57
struct dvbpsi_sat_deliv_sys_dr_s;

// tag-dvbpsi_sdt_s
// file ../include/dvbpsi/sdt.h line 92
struct dvbpsi_sdt_s;

// tag-dvbpsi_sdt_service_s
// file ../include/dvbpsi/sdt.h line 58
struct dvbpsi_sdt_service_s;

// tag-dvbpsi_service_dr_s
// file ../include/dvbpsi/dr_48.h line 58
struct dvbpsi_service_dr_s;

// tag-dvbpsi_tdt_tot_s
// file ../include/dvbpsi/tdttot.h line 44
struct dvbpsi_tdt_tot_s;

// tag-dvbpsi_terr_deliv_sys_dr_s
// file ../include/dvbpsi/dr_5a.h line 57
struct dvbpsi_terr_deliv_sys_dr_s;

// tag-ev_async
// file /usr/include/ev.h line 457
struct ev_async;

// tag-ev_io
// file /usr/include/ev.h line 317
struct ev_io;

// tag-ev_loop
// file /usr/include/ev.h line 172
struct ev_loop;

// tag-ev_timer
// file /usr/include/ev.h line 327
struct ev_timer;

// tag-ev_watcher
// file /usr/include/ev.h line 298
struct ev_watcher;

// tag-ev_watcher_list
// file /usr/include/ev.h line 304
struct ev_watcher_list;

// tag-ev_watcher_time
// file /usr/include/ev.h line 310
struct ev_watcher_time;

// tag-fe_bandwidth
// file /usr/include/linux/dvb/frontend.h line 494
enum fe_bandwidth { BANDWIDTH_8_MHZ=0, BANDWIDTH_7_MHZ=1, BANDWIDTH_6_MHZ=2, BANDWIDTH_AUTO=3, BANDWIDTH_5_MHZ=4, BANDWIDTH_10_MHZ=5, BANDWIDTH_1_712_MHZ=6 };

// tag-fe_caps
// file /usr/include/linux/dvb/frontend.h line 38
enum fe_caps { FE_IS_STUPID=0, FE_CAN_INVERSION_AUTO=1, FE_CAN_FEC_1_2=2, FE_CAN_FEC_2_3=4, FE_CAN_FEC_3_4=8, FE_CAN_FEC_4_5=16, FE_CAN_FEC_5_6=32, FE_CAN_FEC_6_7=64, FE_CAN_FEC_7_8=128, FE_CAN_FEC_8_9=256, FE_CAN_FEC_AUTO=512, FE_CAN_QPSK=1024, FE_CAN_QAM_16=2048, FE_CAN_QAM_32=4096, FE_CAN_QAM_64=8192, FE_CAN_QAM_128=16384, FE_CAN_QAM_256=32768, FE_CAN_QAM_AUTO=65536, FE_CAN_TRANSMISSION_MODE_AUTO=131072, FE_CAN_BANDWIDTH_AUTO=262144, FE_CAN_GUARD_INTERVAL_AUTO=524288, FE_CAN_HIERARCHY_AUTO=1048576, FE_CAN_8VSB=2097152, FE_CAN_16VSB=4194304, FE_HAS_EXTENDED_CAPS=8388608, FE_CAN_MULTISTREAM=67108864, FE_CAN_TURBO_FEC=134217728, FE_CAN_2G_MODULATION=268435456, FE_NEEDS_BENDING=536870912, FE_CAN_RECOVER=1073741824, FE_CAN_MUTE_TS=-2147483648 };

// tag-fe_code_rate
// file /usr/include/linux/dvb/frontend.h line 145
enum fe_code_rate { FEC_NONE=0, FEC_1_2=1, FEC_2_3=2, FEC_3_4=3, FEC_4_5=4, FEC_5_6=5, FEC_6_7=6, FEC_7_8=7, FEC_8_9=8, FEC_AUTO=9, FEC_3_5=10, FEC_9_10=11, FEC_2_5=12 };

// tag-fe_guard_interval
// file /usr/include/linux/dvb/frontend.h line 190
enum fe_guard_interval { GUARD_INTERVAL_1_32=0, GUARD_INTERVAL_1_16=1, GUARD_INTERVAL_1_8=2, GUARD_INTERVAL_1_4=3, GUARD_INTERVAL_AUTO=4, GUARD_INTERVAL_1_128=5, GUARD_INTERVAL_19_128=6, GUARD_INTERVAL_19_256=7, GUARD_INTERVAL_PN420=8, GUARD_INTERVAL_PN595=9, GUARD_INTERVAL_PN945=10 };

// tag-fe_hierarchy
// file /usr/include/linux/dvb/frontend.h line 204
enum fe_hierarchy { HIERARCHY_NONE=0, HIERARCHY_1=1, HIERARCHY_2=2, HIERARCHY_4=3, HIERARCHY_AUTO=4 };

// tag-fe_modulation
// file /usr/include/linux/dvb/frontend.h line 161
enum fe_modulation { QPSK=0, QAM_16=1, QAM_32=2, QAM_64=3, QAM_128=4, QAM_256=5, QAM_AUTO=6, VSB_8=7, VSB_16=8, PSK_8=9, APSK_16=10, APSK_32=11, DQPSK=12, QAM_4_NR=13 };

// tag-fe_spectral_inversion
// file /usr/include/linux/dvb/frontend.h line 139
enum fe_spectral_inversion { INVERSION_OFF=0, INVERSION_ON=1, INVERSION_AUTO=2 };

// tag-fe_status
// file /usr/include/linux/dvb/frontend.h line 129
enum fe_status { FE_HAS_SIGNAL=1, FE_HAS_CARRIER=2, FE_HAS_VITERBI=4, FE_HAS_SYNC=8, FE_HAS_LOCK=16, FE_TIMEDOUT=32, FE_REINIT=64 };

// tag-fe_transmit_mode
// file /usr/include/linux/dvb/frontend.h line 178
enum fe_transmit_mode { TRANSMISSION_MODE_2K=0, TRANSMISSION_MODE_8K=1, TRANSMISSION_MODE_AUTO=2, TRANSMISSION_MODE_4K=3, TRANSMISSION_MODE_1K=4, TRANSMISSION_MODE_16K=5, TRANSMISSION_MODE_32K=6, TRANSMISSION_MODE_C1=7, TRANSMISSION_MODE_C3780=8 };

// tag-fe_type
// file /usr/include/linux/dvb/frontend.h line 31
enum fe_type { FE_QPSK=0, FE_QAM=1, FE_OFDM=2, FE_ATSC=3 };

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lt__handle
// file /usr/include/ltdl.h line 50
struct lt__handle;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sqlite3
// file /usr/include/sqlite3.h line 232
struct sqlite3;

// tag-sqlite3_stmt
// file /usr/include/sqlite3.h line 3130
struct sqlite3_stmt;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-yaml_alias_data_s
// file /usr/include/yaml.h line 1065
struct yaml_alias_data_s;

// tag-yaml_break_e
// file /usr/include/yaml.h line 110
enum yaml_break_e { YAML_ANY_BREAK=0, YAML_CR_BREAK=1, YAML_LN_BREAK=2, YAML_CRLN_BREAK=3 };

// tag-yaml_document_s
// file /usr/include/yaml.h line 778
struct yaml_document_s;

// tag-yaml_emitter_s
// file /usr/include/yaml.h line 1525
struct yaml_emitter_s;

// tag-yaml_emitter_state_e
// file /usr/include/yaml.h line 1479
enum yaml_emitter_state_e { YAML_EMIT_STREAM_START_STATE=0, YAML_EMIT_FIRST_DOCUMENT_START_STATE=1, YAML_EMIT_DOCUMENT_START_STATE=2, YAML_EMIT_DOCUMENT_CONTENT_STATE=3, YAML_EMIT_DOCUMENT_END_STATE=4, YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE=5, YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE=6, YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE=7, YAML_EMIT_FLOW_MAPPING_KEY_STATE=8, YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE=9, YAML_EMIT_FLOW_MAPPING_VALUE_STATE=10, YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE=11, YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE=12, YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE=13, YAML_EMIT_BLOCK_MAPPING_KEY_STATE=14, YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE=15, YAML_EMIT_BLOCK_MAPPING_VALUE_STATE=16, YAML_EMIT_END_STATE=17 };

// tag-yaml_encoding_e
// file /usr/include/yaml.h line 97
enum yaml_encoding_e { YAML_ANY_ENCODING=0, YAML_UTF8_ENCODING=1, YAML_UTF16LE_ENCODING=2, YAML_UTF16BE_ENCODING=3 };

// tag-yaml_error_type_e
// file /usr/include/yaml.h line 122
enum yaml_error_type_e { YAML_NO_ERROR=0, YAML_MEMORY_ERROR=1, YAML_READER_ERROR=2, YAML_SCANNER_ERROR=3, YAML_PARSER_ERROR=4, YAML_COMPOSER_ERROR=5, YAML_WRITER_ERROR=6, YAML_EMITTER_ERROR=7 };

// tag-yaml_event_s
// file /usr/include/yaml.h line 384
struct yaml_event_s;

// tag-yaml_event_type_e
// file /usr/include/yaml.h line 353
enum yaml_event_type_e { YAML_NO_EVENT=0, YAML_STREAM_START_EVENT=1, YAML_STREAM_END_EVENT=2, YAML_DOCUMENT_START_EVENT=3, YAML_DOCUMENT_END_EVENT=4, YAML_ALIAS_EVENT=5, YAML_SCALAR_EVENT=6, YAML_SEQUENCE_START_EVENT=7, YAML_SEQUENCE_END_EVENT=8, YAML_MAPPING_START_EVENT=9, YAML_MAPPING_END_EVENT=10 };

// tag-yaml_mapping_style_e
// file /usr/include/yaml.h line 194
enum yaml_mapping_style_e { YAML_ANY_MAPPING_STYLE=0, YAML_BLOCK_MAPPING_STYLE=1, YAML_FLOW_MAPPING_STYLE=2 };

// tag-yaml_mark_s
// file /usr/include/yaml.h line 145
struct yaml_mark_s;

// tag-yaml_node_pair_s
// file /usr/include/yaml.h line 709
struct yaml_node_pair_s;

// tag-yaml_node_s
// file /usr/include/yaml.h line 703
struct yaml_node_s;

// tag-yaml_node_type_e
// file /usr/include/yaml.h line 690
enum yaml_node_type_e { YAML_NO_NODE=0, YAML_SCALAR_NODE=1, YAML_SEQUENCE_NODE=2, YAML_MAPPING_NODE=3 };

// tag-yaml_parser_s
// file /usr/include/yaml.h line 1081
struct yaml_parser_s;

// tag-yaml_parser_state_e
// file /usr/include/yaml.h line 1010
enum yaml_parser_state_e { YAML_PARSE_STREAM_START_STATE=0, YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE=1, YAML_PARSE_DOCUMENT_START_STATE=2, YAML_PARSE_DOCUMENT_CONTENT_STATE=3, YAML_PARSE_DOCUMENT_END_STATE=4, YAML_PARSE_BLOCK_NODE_STATE=5, YAML_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE=6, YAML_PARSE_FLOW_NODE_STATE=7, YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE=8, YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE=9, YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE=10, YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE=11, YAML_PARSE_BLOCK_MAPPING_KEY_STATE=12, YAML_PARSE_BLOCK_MAPPING_VALUE_STATE=13, YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE=14, YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE=15, YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE=16, YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE=17, YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE=18, YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE=19, YAML_PARSE_FLOW_MAPPING_KEY_STATE=20, YAML_PARSE_FLOW_MAPPING_VALUE_STATE=21, YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE=22, YAML_PARSE_END_STATE=23 };

// tag-yaml_scalar_style_e
// file /usr/include/yaml.h line 164
enum yaml_scalar_style_e { YAML_ANY_SCALAR_STYLE=0, YAML_PLAIN_SCALAR_STYLE=1, YAML_SINGLE_QUOTED_SCALAR_STYLE=2, YAML_DOUBLE_QUOTED_SCALAR_STYLE=3, YAML_LITERAL_SCALAR_STYLE=4, YAML_FOLDED_SCALAR_STYLE=5 };

// tag-yaml_sequence_style_e
// file /usr/include/yaml.h line 183
enum yaml_sequence_style_e { YAML_ANY_SEQUENCE_STYLE=0, YAML_BLOCK_SEQUENCE_STYLE=1, YAML_FLOW_SEQUENCE_STYLE=2 };

// tag-yaml_simple_key_s
// file /usr/include/yaml.h line 993
struct yaml_simple_key_s;

// tag-yaml_tag_directive_s
// file /usr/include/yaml.h line 89
struct yaml_tag_directive_s;

// tag-yaml_token_s
// file /usr/include/yaml.h line 267
struct yaml_token_s;

// tag-yaml_token_type_e
// file /usr/include/yaml.h line 213
enum yaml_token_type_e { YAML_NO_TOKEN=0, YAML_STREAM_START_TOKEN=1, YAML_STREAM_END_TOKEN=2, YAML_VERSION_DIRECTIVE_TOKEN=3, YAML_TAG_DIRECTIVE_TOKEN=4, YAML_DOCUMENT_START_TOKEN=5, YAML_DOCUMENT_END_TOKEN=6, YAML_BLOCK_SEQUENCE_START_TOKEN=7, YAML_BLOCK_MAPPING_START_TOKEN=8, YAML_BLOCK_END_TOKEN=9, YAML_FLOW_SEQUENCE_START_TOKEN=10, YAML_FLOW_SEQUENCE_END_TOKEN=11, YAML_FLOW_MAPPING_START_TOKEN=12, YAML_FLOW_MAPPING_END_TOKEN=13, YAML_BLOCK_ENTRY_TOKEN=14, YAML_FLOW_ENTRY_TOKEN=15, YAML_KEY_TOKEN=16, YAML_VALUE_TOKEN=17, YAML_ALIAS_TOKEN=18, YAML_ANCHOR_TOKEN=19, YAML_TAG_TOKEN=20, YAML_SCALAR_TOKEN=21 };

// tag-yaml_version_directive_s
// file /usr/include/yaml.h line 81
struct yaml_version_directive_s;

#ifndef NULL
#define NULL ((void*)0)
#endif

// ATSCMultipleStringsConvert
// file standard/atsc/atsctext.c line 367
struct ATSCMultipleStrings_s * ATSCMultipleStringsConvert(unsigned char *data, unsigned char len);
// ATSCMultipleStringsDeInit
// file ../include/atsctext.h line 71
void ATSCMultipleStringsDeInit(void);
// ATSCMultipleStringsDestructor
// file standard/atsc/atsctext.c line 419
static void ATSCMultipleStringsDestructor(struct ATSCMultipleStrings_s *strings);
// ATSCMultipleStringsInit
// file ../include/atsctext.h line 65
signed int ATSCMultipleStringsInit(void);
// ATSCStandardDeinit
// file ../include/standard/atsc.h line 31
signed int ATSCStandardDeinit(struct TSReader_t *reader);
// ATSCStandardInit
// file ../include/standard/atsc.h line 30
signed int ATSCStandardInit(struct TSReader_t *reader);
// AddConnection
// file remoteintf.c line 287
static void AddConnection(signed int socketfd, struct sockaddr_storage *clientAddress);
// AppendSegment
// file standard/atsc/atsctext.c line 429
static unsigned char * AppendSegment(unsigned char *segment, signed int *sbIndex, _Bool *supported);
// AttemptComplete
// file commands.c line 316
static char ** AttemptComplete(const char *text, signed int start, signed int end);
// BCDFixedPoint3_7ToDouble
// file commands/cmd_scanning.c line 1401
static double BCDFixedPoint3_7ToDouble(unsigned int bcd);
// CacheDeInit
// file ../include/cache.h line 54
void CacheDeInit();
// CacheInit
// file ../include/cache.h line 48
signed int CacheInit();
// CacheLoad
// file ../include/cache.h line 61
signed int CacheLoad(struct Multiplex_s *multiplex);
// CacheMultiplexGet
// file cache.c line 253
struct Multiplex_s * CacheMultiplexGet(void);
// CacheProcessUpdateMessage
// file cache.c line 844
static void CacheProcessUpdateMessage(void *ptr);
// CacheProgramInfoGet
// file ../include/cache.h line 120
struct ProgramInfo_s * CacheProgramInfoGet(struct Service_t *service);
// CacheServiceAdd
// file ../include/cache.h line 199
struct Service_t * CacheServiceAdd(signed int id, signed int source);
// CacheServiceDelete
// file ../include/cache.h line 217
void CacheServiceDelete(struct Service_t *service);
// CacheServiceFind
// file cache.c line 258
struct Service_t * CacheServiceFind(char *name);
// CacheServiceFindId
// file ../include/cache.h line 88
struct Service_t * CacheServiceFindId(signed int id);
// CacheServiceFindName
// file cache.c line 298
struct Service_t * CacheServiceFindName(char *name);
// CacheServiceSeen
// file ../include/cache.h line 211
_Bool CacheServiceSeen(struct Service_t *service, _Bool seen, _Bool pat);
// CacheServicesFree
// file cache.c line 823
static void CacheServicesFree(void);
// CacheServicesGet
// file ../include/cache.h line 105
struct Service_t ** CacheServicesGet(signed int *count);
// CacheServicesRelease
// file ../include/cache.h line 111
void CacheServicesRelease(void);
// CacheUpdateMultiplex
// file ../include/cache.h line 129
void CacheUpdateMultiplex(struct Multiplex_s *multiplex, signed int patversion, signed int tsid);
// CacheUpdateNetworkId
// file cache.c line 385
void CacheUpdateNetworkId(struct Multiplex_s *multiplex, signed int netid);
// CacheUpdateProgramInfo
// file ../include/cache.h line 192
void CacheUpdateProgramInfo(struct Service_t *service, struct ProgramInfo_s *info);
// CacheUpdateServiceConditionalAccess
// file cache.c line 595
void CacheUpdateServiceConditionalAccess(struct Service_t *service, _Bool ca);
// CacheUpdateServiceDefaultAuthority
// file cache.c line 525
void CacheUpdateServiceDefaultAuthority(struct Service_t *service, char *defaultAuthority);
// CacheUpdateServiceName
// file cache.c line 441
void CacheUpdateServiceName(struct Service_t *service, char *name);
// CacheUpdateServicePMTPID
// file ../include/cache.h line 143
void CacheUpdateServicePMTPID(struct Service_t *service, signed int pmtpid);
// CacheUpdateServiceProvider
// file cache.c line 483
void CacheUpdateServiceProvider(struct Service_t *service, char *provider);
// CacheUpdateServiceSource
// file cache.c line 567
void CacheUpdateServiceSource(struct Service_t *service, unsigned short int source);
// CacheUpdateServiceType
// file cache.c line 623
void CacheUpdateServiceType(struct Service_t *service, enum anonymous type);
// CacheWriteback
// file ../include/cache.h line 66
void CacheWriteback();
// CheckPMTsReceived
// file commands/cmd_scanning.c line 1147
static void CheckPMTsReceived(void);
// CommandAddSF
// file commands/cmd_servicefilter.c line 254
static void CommandAddSF(signed int argc, char **argv);
// CommandContextGet
// file commands.c line 171
struct CommandContext_t * CommandContextGet(void);
// CommandContextSet
// file commands.c line 166
static void CommandContextSet(struct CommandContext_t *context);
// CommandCurrent
// file commands/cmd_info.c line 472
static void CommandCurrent(signed int argc, char **argv);
// CommandDeInit
// file ../include/commands.h line 141
void CommandDeInit(void);
// CommandDumpTSReader
// file commands/cmd_info.c line 828
static void CommandDumpTSReader(signed int argc, char **argv);
// CommandEPGData
// file commands/cmd_epg.c line 79
static void CommandEPGData(signed int argc, char **argv);
// CommandExecute
// file commands.c line 284
_Bool CommandExecute(struct CommandContext_t *context, char *line);
// CommandExecuteConsole
// file ../include/commands.h line 174
_Bool CommandExecuteConsole(char *line);
// CommandFEParams
// file commands/cmd_info.c line 591
static void CommandFEParams(signed int argc, char **argv);
// CommandFEStatus
// file commands/cmd_info.c line 570
static void CommandFEStatus(signed int argc, char **argv);
// CommandGetMRL
// file commands/cmd_servicefilter.c line 246
static void CommandGetMRL(signed int argc, char **argv);
// CommandGetProperty
// file commands/cmd_info.c line 765
static void CommandGetProperty(signed int argc, char **argv);
// CommandGetSFAVSOnly
// file commands/cmd_servicefilter.c line 446
static void CommandGetSFAVSOnly(signed int argc, char **argv);
// CommandGetSFMRL
// file commands/cmd_servicefilter.c line 415
static void CommandGetSFMRL(signed int argc, char **argv);
// CommandGetSFService
// file commands/cmd_servicefilter.c line 378
static void CommandGetSFService(signed int argc, char **argv);
// CommandGets
// file commands.c line 188
char * CommandGets(char *buffer, signed int len);
// CommandHelp
// file commands.c line 592
static void CommandHelp(signed int argc, char **argv);
// CommandInit
// file ../include/commands.h line 136
signed int CommandInit(void);
// CommandInstallEPG
// file commands/cmd_epg.c line 66
void CommandInstallEPG(void);
// CommandInstallInfo
// file commands/cmd_info.c line 232
void CommandInstallInfo(void);
// CommandInstallScanning
// file commands/cmd_scanning.c line 315
void CommandInstallScanning(void);
// CommandInstallServiceFilter
// file commands/cmd_servicefilter.c line 200
void CommandInstallServiceFilter(void);
// CommandListLNBs
// file commands/cmd_info.c line 900
static void CommandListLNBs(signed int argc, char **argv);
// CommandListMuxes
// file commands/cmd_info.c line 443
static void CommandListMuxes(signed int argc, char **argv);
// CommandListPids
// file commands/cmd_info.c line 601
static void CommandListPids(signed int argc, char **argv);
// CommandListProperties
// file commands/cmd_info.c line 713
static void CommandListProperties(signed int argc, char **argv);
// CommandListSF
// file commands/cmd_servicefilter.c line 295
static void CommandListSF(signed int argc, char **argv);
// CommandListServices
// file commands/cmd_info.c line 246
static void CommandListServices(signed int argc, char **argv);
// CommandLoop
// file ../include/commands.h line 160
void CommandLoop(void);
// CommandMuxInfo
// file commands/cmd_info.c line 511
static void CommandMuxInfo(signed int argc, char **argv);
// CommandPrintf
// file commands.c line 176
signed int CommandPrintf(const char *fmt, ...);
// CommandProcessFile
// file ../include/commands.h line 167
signed int CommandProcessFile(char *file);
// CommandPropertyInfo
// file commands/cmd_info.c line 810
static void CommandPropertyInfo(signed int argc, char **argv);
// CommandQuit
// file commands.c line 577
static void CommandQuit(signed int argc, char **argv);
// CommandRegisterCommands
// file commands.c line 153
void CommandRegisterCommands(struct Command_t *commands);
// CommandRemoveSF
// file commands/cmd_servicefilter.c line 278
static void CommandRemoveSF(signed int argc, char **argv);
// CommandScan
// file commands/cmd_scanning.c line 438
static void CommandScan(signed int argc, char **argv);
// CommandScanCancel
// file commands/cmd_scanning.c line 519
static void CommandScanCancel(signed int argc, char **argv);
// CommandSelect
// file commands/cmd_servicefilter.c line 214
static void CommandSelect(signed int argc, char **argv);
// CommandServiceInfo
// file commands/cmd_info.c line 483
static void CommandServiceInfo(signed int argc, char **argv);
// CommandSetMRL
// file commands/cmd_servicefilter.c line 238
static void CommandSetMRL(signed int argc, char **argv);
// CommandSetProperty
// file commands/cmd_info.c line 801
static void CommandSetProperty(signed int argc, char **argv);
// CommandSetSFAVSOnly
// file commands/cmd_servicefilter.c line 425
static void CommandSetSFAVSOnly(signed int argc, char **argv);
// CommandSetSFMRL
// file commands/cmd_servicefilter.c line 395
static void CommandSetSFMRL(signed int argc, char **argv);
// CommandSetSFService
// file commands/cmd_servicefilter.c line 340
static void CommandSetSFService(signed int argc, char **argv);
// CommandStats
// file commands/cmd_info.c line 549
static void CommandStats(signed int argc, char **argv);
// CommandUnInstallEPG
// file commands/cmd_epg.c line 71
void CommandUnInstallEPG(void);
// CommandUnInstallInfo
// file commands/cmd_info.c line 238
void CommandUnInstallInfo(void);
// CommandUnInstallScanning
// file commands/cmd_scanning.c line 408
void CommandUnInstallScanning(void);
// CommandUnInstallServiceFilter
// file commands/cmd_servicefilter.c line 205
void CommandUnInstallServiceFilter(void);
// CommandUnRegisterCommands
// file commands.c line 160
void CommandUnRegisterCommands(struct Command_t *commands);
// CompleteCommand
// file commands.c line 331
static char * CompleteCommand(const char *text, signed int state);
// ConvertDTVPropertiesToYaml
// file dvbadapter.c line 1801
static void ConvertDTVPropertiesToYaml(enum DVBDeliverySystem_e delSys, struct dtv_properties *feparams, struct DVBSatelliteSettings_s *satSettings, struct yaml_document_s *doc);
// ConvertDVBServiceType
// file standard/dvb/sdtprocessor.c line 269
static enum anonymous ConvertDVBServiceType(signed int type);
// ConvertStringToBandwith
// file dvbadapter.c line 1695
static unsigned int ConvertStringToBandwith(const char *str, unsigned int defaultValue);
// ConvertStringToUInt32
// file dvbadapter.c line 1595
static unsigned int ConvertStringToUInt32(const char *str, unsigned int defaultValue);
// ConvertYamlNode
// file dvbadapter.c line 1606
static unsigned int ConvertYamlNode(struct yaml_document_s *document, const char *key, unsigned int (*convert)(const char *, unsigned int), unsigned int defaultValue);
// ConvertYamlNode::convert_object
//
unsigned int convert_object(const char *, unsigned int);
// ConvertYamlToDTVProperties
// file dvbadapter.c line 1717
static void ConvertYamlToDTVProperties(enum DVBDeliverySystem_e delSys, struct yaml_document_s *doc, struct DVBAdapter_s *adapter);
// DBaseCheckVersion
// file dbase.c line 151
static signed int DBaseCheckVersion();
// DBaseConnectionGet
// file ../include/dbase.h line 323
struct sqlite3 * DBaseConnectionGet(void);
// DBaseCount
// file ../include/dbase.h line 344
signed int DBaseCount(char *table, char *where);
// DBaseCreateTables
// file dbase.c line 193
static signed int DBaseCreateTables(void);
// DBaseDeInit
// file ../include/dbase.h line 317
void DBaseDeInit();
// DBaseInit
// file ../include/dbase.h line 311
signed int DBaseInit(signed int adapter);
// DBaseMetadataDelete
// file ../include/dbase.h line 399
signed int DBaseMetadataDelete(char *name);
// DBaseMetadataGet
// file ../include/dbase.h line 353
signed int DBaseMetadataGet(char *name, char **value);
// DBaseMetadataGetDouble
// file dbase.c line 331
signed int DBaseMetadataGetDouble(char *name, double *value);
// DBaseMetadataGetInt
// file ../include/dbase.h line 369
signed int DBaseMetadataGetInt(char *name, signed int *value);
// DBaseMetadataSet
// file ../include/dbase.h line 361
signed int DBaseMetadataSet(char *name, char *value);
// DBaseMetadataSetDouble
// file dbase.c line 351
signed int DBaseMetadataSetDouble(char *name, double value);
// DBaseMetadataSetInt
// file ../include/dbase.h line 376
signed int DBaseMetadataSetInt(char *name, signed int value);
// DBaseTransactionBegin
// file dbase.c line 112
signed int DBaseTransactionBegin(void);
// DBaseTransactionCommit
// file dbase.c line 118
signed int DBaseTransactionCommit(void);
// DVBCommandCallback
// file dvbadapter.c line 1269
static void DVBCommandCallback(struct ev_loop *loop, struct ev_io *w, signed int revents);
// DVBCommandSend
// file dvbadapter.c line 1261
static void DVBCommandSend(struct DVBAdapter_s *adapter, char cmd);
// DVBDVRGetFD
// file dvbadapter.c line 1256
signed int DVBDVRGetFD(struct DVBAdapter_s *adapter);
// DVBDemuxAllocateFilter
// file dvbadapter.c line 1094
signed int DVBDemuxAllocateFilter(struct DVBAdapter_s *adapter, unsigned short int pid);
// DVBDemuxGetAvailableFilters
// file dvbadapter.c line 1075
signed int DVBDemuxGetAvailableFilters(struct DVBAdapter_s *adapter);
// DVBDemuxGetMaxFilters
// file dvbadapter.c line 1070
signed int DVBDemuxGetMaxFilters(struct DVBAdapter_s *adapter);
// DVBDemuxIsHardwareRestricted
// file dvbadapter.c line 1089
_Bool DVBDemuxIsHardwareRestricted(struct DVBAdapter_s *adapter);
// DVBDemuxReleaseAllFilters
// file dvbadapter.c line 1182
signed int DVBDemuxReleaseAllFilters(struct DVBAdapter_s *adapter);
// DVBDemuxReleaseFilter
// file dvbadapter.c line 1161
signed int DVBDemuxReleaseFilter(struct DVBAdapter_s *adapter, unsigned short int pid);
// DVBDemuxSetBufferSize
// file dvbadapter.c line 1039
signed int DVBDemuxSetBufferSize(struct DVBAdapter_s *adapter, unsigned long int size);
// DVBDemuxStartAllFilters
// file dvbadapter.c line 1232
static void DVBDemuxStartAllFilters(struct DVBAdapter_s *adapter);
// DVBDemuxStartFilter
// file dvbadapter.c line 1200
static signed int DVBDemuxStartFilter(struct DVBAdapter_s *adapter, struct DVBAdapterPIDFilter_s *filter);
// DVBDemuxStopAllFilters
// file dvbadapter.c line 1244
static void DVBDemuxStopAllFilters(struct DVBAdapter_s *adapter);
// DVBDemuxStopFilter
// file dvbadapter.c line 1216
static signed int DVBDemuxStopFilter(struct DVBAdapter_s *adapter, struct DVBAdapterPIDFilter_s *filter);
// DVBDispose
// file dvbadapter.c line 643
void DVBDispose(struct DVBAdapter_s *adapter);
// DVBEventToString
// file dvbadapter.c line 1417
static signed int DVBEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload);
// DVBFrontEndDeliverySystemSupported
// file dvbadapter.c line 678
_Bool DVBFrontEndDeliverySystemSupported(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e system);
// DVBFrontEndGetDeliverySystems
// file dvbadapter.c line 673
struct DVBSupportedDeliverySys_s * DVBFrontEndGetDeliverySystems(struct DVBAdapter_s *adapter);
// DVBFrontEndIsLocked
// file dvbadapter.c line 1028
_Bool DVBFrontEndIsLocked(struct DVBAdapter_s *adapter);
// DVBFrontEndLNBInfoGet
// file dvbadapter.c line 893
void DVBFrontEndLNBInfoGet(struct DVBAdapter_s *adapter, struct LNBInfo_s *lnbInfo);
// DVBFrontEndLNBInfoSet
// file dvbadapter.c line 888
void DVBFrontEndLNBInfoSet(struct DVBAdapter_s *adapter, struct LNBInfo_s *lnbInfo);
// DVBFrontEndParameterSupported
// file dvbadapter.c line 741
_Bool DVBFrontEndParameterSupported(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e system, char *param, char *value);
// DVBFrontEndParametersGet
// file dvbadapter.c line 712
char * DVBFrontEndParametersGet(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e *system);
// DVBFrontEndSatelliteSetup
// file dvbadapter.c line 898
static signed int DVBFrontEndSatelliteSetup(struct DVBAdapter_s *adapter);
// DVBFrontEndSetActive
// file dvbadapter.c line 1033
signed int DVBFrontEndSetActive(struct DVBAdapter_s *adapter, _Bool active);
// DVBFrontEndStatus
// file dvbadapter.c line 960
signed int DVBFrontEndStatus(struct DVBAdapter_s *adapter, enum DVBFrontEndStatus_e *status, unsigned int *ber, unsigned int *strength, unsigned int *snr, unsigned int *ucblock);
// DVBFrontEndTune
// file dvbadapter.c line 691
signed int DVBFrontEndTune(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e system, char *params);
// DVBFrontendCallback
// file dvbadapter.c line 1363
static void DVBFrontendCallback(struct ev_loop *loop, struct ev_io *w, signed int revents);
// DVBInit
// file dvbadapter.c line 400
struct DVBAdapter_s * DVBInit(signed int adapter, _Bool hwRestricted, _Bool forceISDB);
// DVBPropertyActiveGet
// file dvbadapter.c line 1427
static signed int DVBPropertyActiveGet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyActiveSet
// file dvbadapter.c line 1434
static signed int DVBPropertyActiveSet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyDeliverySystemsGet
// file dvbadapter.c line 1440
static signed int DVBPropertyDeliverySystemsGet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBHighFreqGet
// file dvbadapter.c line 1483
static signed int DVBPropertyLNBHighFreqGet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBHighFreqSet
// file dvbadapter.c line 1461
static signed int DVBPropertyLNBHighFreqSet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBLowFreqGet
// file dvbadapter.c line 1489
static signed int DVBPropertyLNBLowFreqGet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBLowFreqSet
// file dvbadapter.c line 1468
static signed int DVBPropertyLNBLowFreqSet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBNameGet
// file dvbadapter.c line 1503
static signed int DVBPropertyLNBNameGet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBNameSet
// file dvbadapter.c line 1517
static signed int DVBPropertyLNBNameSet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBSharingGet
// file dvbadapter.c line 1531
static signed int DVBPropertyLNBSharingGet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBSharingSet
// file dvbadapter.c line 1538
static signed int DVBPropertyLNBSharingSet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBSwitchFreqGet
// file dvbadapter.c line 1495
static signed int DVBPropertyLNBSwitchFreqGet(void *userArg, struct PropertyValue_s *value);
// DVBPropertyLNBSwitchFreqSet
// file dvbadapter.c line 1475
static signed int DVBPropertyLNBSwitchFreqSet(void *userArg, struct PropertyValue_s *value);
// DVBStandardDeinit
// file ../include/standard/dvb.h line 31
signed int DVBStandardDeinit(struct TSReader_t *reader);
// DVBStandardInit
// file ../include/standard/dvb.h line 30
signed int DVBStandardInit(struct TSReader_t *reader);
// DVBTextToUTF8
// file ../include/dvbtext.h line 44
char * DVBTextToUTF8(char *toConvert, unsigned long int toConvertLen);
// DeInitDaemon
// file main.c line 853
static void DeInitDaemon(void);
// DeferredProcessingAddJob
// file ../include/deferredproc.h line 61
void DeferredProcessingAddJob(void (*processor)(void *), void *arg);
// DeferredProcessingAddJob::processor_object
//
void processor_object(void *);
// DeferredProcessingDeinit
// file ../include/deferredproc.h line 49
void DeferredProcessingDeinit(void);
// DeferredProcessingInit
// file ../include/deferredproc.h line 43
signed int DeferredProcessingInit(void);
// DeferredProcessingThread
// file threading/deferredproc.c line 99
static void * DeferredProcessingThread(void *arg);
// DeliveryMethodCreate
// file ../include/deliverymethod.h line 164
struct DeliveryMethodInstance_t * DeliveryMethodCreate(char *mrl);
// DeliveryMethodDestroy
// file ../include/deliverymethod.h line 178
void DeliveryMethodDestroy(struct DeliveryMethodInstance_t *instance);
// DeliveryMethodDestroyAll
// file ../include/deliverymethod.h line 188
void DeliveryMethodDestroyAll();
// DeliveryMethodGetMRL
// file ../include/deliverymethod.h line 171
char * DeliveryMethodGetMRL(struct DeliveryMethodInstance_t *instance);
// DeliveryMethodManagerDeInit
// file ../include/deliverymethod.h line 145
void DeliveryMethodManagerDeInit(void);
// DeliveryMethodManagerInit
// file ../include/deliverymethod.h line 139
signed int DeliveryMethodManagerInit(void);
// DeliveryMethodManagerRegister
// file deliverymethod.c line 97
void DeliveryMethodManagerRegister(struct DeliveryMethodHandler_t *handler);
// DeliveryMethodManagerUnRegister
// file deliverymethod.c line 102
void DeliveryMethodManagerUnRegister(struct DeliveryMethodHandler_t *handler);
// DeliveryMethodOutputBlock
// file deliverymethod.c line 182
void DeliveryMethodOutputBlock(struct DeliveryMethodInstance_t *instance, void *block, unsigned long int blockLen);
// DeliveryMethodOutputPacket
// file ../include/deliverymethod.h line 210
void DeliveryMethodOutputPacket(struct DeliveryMethodInstance_t *instance, struct TSPacket_t *packet);
// DeliveryMethodReserveHeaderSpace
// file ../include/deliverymethod.h line 195
void DeliveryMethodReserveHeaderSpace(struct DeliveryMethodInstance_t *instance, signed int nrofPackets);
// DeliveryMethodSetHeader
// file ../include/deliverymethod.h line 203
void DeliveryMethodSetHeader(struct DeliveryMethodInstance_t *instance, struct TSPacket_t *packets, signed int nrofPackets);
// DispatchersDeInit
// file ../include/dispatchers.h line 28
signed int DispatchersDeInit(void);
// DispatchersExitLoop
// file ../include/dispatchers.h line 30
void DispatchersExitLoop(void);
// DispatchersGetInput
// file ../include/dispatchers.h line 32
struct ev_loop * DispatchersGetInput(void);
// DispatchersGetNetwork
// file dispatchers.c line 115
struct ev_loop * DispatchersGetNetwork(void);
// DispatchersGetUserInput
// file dispatchers.c line 120
struct ev_loop * DispatchersGetUserInput(void);
// DispatchersInit
// file ../include/dispatchers.h line 27
signed int DispatchersInit(void);
// DispatchersStart
// file ../include/dispatchers.h line 29
void DispatchersStart(_Bool sync);
// DispatchersStop
// file ../include/dispatchers.h line 31
void DispatchersStop(void);
// DumpDescriptor
// file standard/atsc/psipprocessor.c line 355
static void DumpDescriptor(char *prefix, struct dvbpsi_descriptor_s *descriptor);
// EPGChannelDeInit
// file ../include/epgchannel.h line 60
signed int EPGChannelDeInit(void);
// EPGChannelInit
// file ../include/epgchannel.h line 54
signed int EPGChannelInit(void);
// EPGChannelMessageDestructor
// file epgchannel.c line 169
static void EPGChannelMessageDestructor(void *ptr);
// EPGChannelNewDetail
// file epgchannel.c line 136
signed int EPGChannelNewDetail(struct EPGEventRef_s *eventRef, char *lang, char *name, char *value);
// EPGChannelNewEvent
// file epgchannel.c line 103
signed int EPGChannelNewEvent(struct EPGEventRef_s *eventRef, struct tm *startTime, struct tm *endTime, _Bool ca);
// EPGChannelNewRating
// file epgchannel.c line 120
signed int EPGChannelNewRating(struct EPGEventRef_s *eventRef, char *system, char *rating);
// EPGChannelRegisterListener
// file ../include/epgchannel.h line 62
signed int EPGChannelRegisterListener(struct MessageQ_s *msgQ);
// EPGChannelSendMessage
// file epgchannel.c line 156
static void EPGChannelSendMessage(struct EPGChannelMessage_s *msg);
// EPGChannelUnregisterListener
// file ../include/epgchannel.h line 63
signed int EPGChannelUnregisterListener(struct MessageQ_s *msgQ);
// EPGEventDetailDestructor
// file epgtypes.c line 72
static void EPGEventDetailDestructor(void *arg);
// EPGEventRatingDestructor
// file epgtypes.c line 65
static void EPGEventRatingDestructor(void *arg);
// EPGTypesDeInit
// file ../include/epgtypes.h line 103
signed int EPGTypesDeInit(void);
// EPGTypesInit
// file ../include/epgtypes.h line 97
signed int EPGTypesInit(void);
// EventFree
// file events.c line 405
static void EventFree(struct Event_s *event);
// EventListenerDetailsFree
// file events.c line 416
static void EventListenerDetailsFree(struct EventListenerDetails_s *details);
// EventSourceFree
// file events.c line 397
static void EventSourceFree(struct EventSource_s *source);
// EventUnregisteredToString
// file events.c line 459
static signed int EventUnregisteredToString(struct yaml_document_s *document, struct Event_s *event, void *payload);
// EventsDeInit
// file ../include/events.h line 97
signed int EventsDeInit(void);
// EventsEventName
// file events.c line 355
char * EventsEventName(struct Event_s *event);
// EventsEventToString
// file events.c line 362
char * EventsEventToString(struct Event_s *event, void *payload);
// EventsFindEvent
// file ../include/events.h line 191
struct Event_s * EventsFindEvent(const char *name);
// EventsFindSource
// file events.c line 217
struct EventSource_s * EventsFindSource(const char *name);
// EventsFireEventListeners
// file ../include/events.h line 204
void EventsFireEventListeners(struct Event_s *event, void *payload);
// EventsInit
// file ../include/events.h line 90
signed int EventsInit(void);
// EventsRegisterEvent
// file ../include/events.h line 178
struct Event_s * EventsRegisterEvent(struct EventSource_s *source, char *name, signed int (*toString)(struct yaml_document_s *, struct Event_s *, void *));
// EventsRegisterEvent::toString_object
//
signed int toString_object(struct yaml_document_s *, struct Event_s *, void *);
// EventsRegisterEventListener
// file ../include/events.h line 212
void EventsRegisterEventListener(struct Event_s *event, void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsRegisterEventListener::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// EventsRegisterListener
// file events.c line 177
void EventsRegisterListener(void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsRegisterListener::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// EventsRegisterListenerByName
// file ../include/events.h line 108
void EventsRegisterListenerByName(const char *event, void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsRegisterListenerByName::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// EventsRegisterSource
// file ../include/events.h line 137
struct EventSource_s * EventsRegisterSource(char *name);
// EventsRegisterSourceListener
// file events.c line 236
void EventsRegisterSourceListener(struct EventSource_s *source, void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsRegisterSourceListener::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// EventsUnregisterEvent
// file ../include/events.h line 184
void EventsUnregisterEvent(struct Event_s *event);
// EventsUnregisterEventListener
// file ../include/events.h line 220
void EventsUnregisterEventListener(struct Event_s *event, void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsUnregisterEventListener::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// EventsUnregisterListener
// file events.c line 184
void EventsUnregisterListener(void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsUnregisterListener::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// EventsUnregisterListenerByName
// file ../include/events.h line 116
void EventsUnregisterListenerByName(const char *event, void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsUnregisterListenerByName::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// EventsUnregisterSource
// file ../include/events.h line 144
void EventsUnregisterSource(struct EventSource_s *source);
// EventsUnregisterSourceListener
// file events.c line 246
void EventsUnregisterSourceListener(struct EventSource_s *source, void (*listener)(void *, struct Event_s *, void *), void *arg);
// EventsUnregisterSourceListener::listener_object
//
void listener_object(void *, struct Event_s *, void *);
// FELockedEventListener
// file commands/cmd_scanning.c line 1428
static void FELockedEventListener(void *arg, struct Event_s *event, void *payload);
// FilterService
// file commands/cmd_info.c line 386
static _Bool FilterService(struct Service_t *service, unsigned int filterByType, unsigned int filterByAccess, char *provider);
// FindClass
// file objects.c line 451
static struct Class_s * FindClass(char *classname);
// FindCommand
// file commands.c line 426
static struct Command_t * FindCommand(struct Command_t *commands, char *command);
// FindMultiplexFrequency
// file commands/cmd_scanning.c line 1475
static struct Multiplex_s * FindMultiplexFrequency(struct MultiplexList_s *muxList, struct MuxFrequencies_s *muxFreqList, unsigned long int freq, signed int range, char *polarisation, signed int satNumber);
// FindPluginFeatureName
// file pluginmgr.c line 474
static char * FindPluginFeatureName(signed int type);
// FindTransponder
// file commands/cmd_scanning.c line 1384
static _Bool FindTransponder(signed int freq, char *polarisation);
// FireEventListeners
// file events.c line 448
static void FireEventListeners(struct List_s *listenerList, struct Event_s *event, void *payload);
// GetConnectionString
// file remoteintf.c line 467
static void GetConnectionString(struct sockaddr_storage *connAddr, char *output);
// GetPropertyTypeString
// file commands/cmd_info.c line 917
static char * GetPropertyTypeString(enum PropertyType_e type);
// GetStreamTypeString
// file commands/cmd_info.c line 671
static char * GetStreamTypeString(signed int type);
// HandleConnection
// file remoteintf.c line 337
static void HandleConnection(struct Connection_t *connection);
// HuffmanDecode
// file standard/atsc/atsctext.c line 538
static void HuffmanDecode(unsigned char *dest, unsigned char *src, signed int destLen, signed int srcLen, signed int comp);
// InformMultiplexChanged
// file ts.c line 1000
static void InformMultiplexChanged(struct TSReader_t *reader);
// InformTSStructureChanged
// file ts.c line 987
static void InformTSStructureChanged(struct TSReader_t *reader);
// InitDaemon
// file main.c line 779
static void InitDaemon(signed int adapter);
// InputDispatcher
// file dispatchers.c line 135
static void * InputDispatcher(void *arg);
// InputExit
// file dispatchers.c line 125
static void InputExit(struct ev_loop *loop, struct ev_io *w, signed int revents);
// InstallSysProperties
// file main.c line 575
static void InstallSysProperties(void);
// LNBDecode
// file ../include/lnb.h line 28
signed int LNBDecode(char *str, struct LNBInfo_s *lnb);
// LNBEnumerate
// file ../include/lnb.h line 21
struct LNBInfo_s * LNBEnumerate(signed int curno);
// LNBTransponderToIntermediateFreq
// file ../include/lnb.h line 39
unsigned long int LNBTransponderToIntermediateFreq(struct LNBInfo_s *info, unsigned long int freq, _Bool *tone);
// ListAdd
// file ../include/list.h line 157
_Bool ListAdd(struct List_s *list, void *data);
// ListCreate
// file ../include/list.h line 122
struct List_s * ListCreate();
// ListDump
// file list.c line 220
void ListDump(struct List_s *list);
// ListFree
// file ../include/list.h line 136
void ListFree(struct List_s *list, void (*destructor)(void *));
// ListFree::destructor_object
//
void destructor_object(void *);
// ListFreeObject
// file ../include/list.h line 149
void ListFreeObject(void *ptr);
// ListGet
// file list.c line 202
_Bool ListGet(struct List_s *list, signed int index, void **data);
// ListInsertAfterCurrent
// file list.c line 76
_Bool ListInsertAfterCurrent(struct ListIterator_s *iterator, void *data);
// ListInsertBeforeCurrent
// file list.c line 116
_Bool ListInsertBeforeCurrent(struct ListIterator_s *iterator, void *data);
// ListRemove
// file ../include/list.h line 174
_Bool ListRemove(struct List_s *list, void *data);
// ListRemoveCurrent
// file ../include/list.h line 205
void ListRemoveCurrent(struct ListIterator_s *iterator);
// ListReplace
// file list.c line 162
_Bool ListReplace(struct List_s *list, void *oldData, void *newData);
// LogGetModuleLevel
// file logging.c line 309
static signed int LogGetModuleLevel(const char *module, signed int level);
// LogGetThreadName
// file logging.c line 294
static char * LogGetThreadName(unsigned long int thread);
// LogImpl
// file logging.c line 258
static void LogImpl(signed int level, const char *module, const char *format, void **valist);
// LogLevelDec
// file logging.c line 154
void LogLevelDec(void);
// LogLevelGet
// file logging.c line 144
signed int LogLevelGet(void);
// LogLevelInc
// file logging.c line 149
void LogLevelInc(void);
// LogLevelIsEnabled
// file logging.c line 159
_Bool LogLevelIsEnabled(signed int level);
// LogLevelSet
// file logging.c line 139
void LogLevelSet(signed int level);
// LogLoadModuleLevels
// file ../include/logging.h line 126
void LogLoadModuleLevels(const char *path);
// LogModule
// file ../include/logging.h line 149
extern void LogModule(signed int level, const char *module, char *format, ...);
// LogRegisterThread
// file ../include/logging.h line 134
void LogRegisterThread(unsigned long int thread, const char *name);
// LogUnregisterThread
// file ../include/logging.h line 140
void LogUnregisterThread(unsigned long int thread);
// LoggingDeInit
// file ../include/logging.h line 91
void LoggingDeInit(void);
// LoggingInit
// file ../include/logging.h line 69
signed int LoggingInit(char *filename, signed int logLevel);
// LoggingInitCommon
// file logging.c line 249
static void LoggingInitCommon(signed int logLevel);
// LoggingInitFile
// file ../include/logging.h line 78
signed int LoggingInitFile(char *filepath, signed int logLevel);
// LoggingRedirectStdErrStdOut
// file ../include/logging.h line 85
void LoggingRedirectStdErrStdOut(void);
// MPEG2StandardDeinit
// file ../include/standard/mpeg2.h line 32
signed int MPEG2StandardDeinit(struct TSReader_t *reader);
// MPEG2StandardInit
// file ../include/standard/mpeg2.h line 31
signed int MPEG2StandardInit(struct TSReader_t *reader);
// MainDVBAdapterGet
// file main.c line 623
struct DVBAdapter_s * MainDVBAdapterGet(void);
// MainIsATSC
// file main.c line 664
_Bool MainIsATSC();
// MainIsDVB
// file main.c line 633
_Bool MainIsDVB();
// MainIsISDB
// file main.c line 684
_Bool MainIsISDB();
// MainServiceFilterGetPrimary
// file main.c line 628
struct ServiceFilter_s * MainServiceFilterGetPrimary(void);
// MainTSReaderGet
// file main.c line 618
struct TSReader_t * MainTSReaderGet(void);
// MapStringToValue
// file dvbadapter.c line 1572
static unsigned int MapStringToValue(struct StringToParamMapping_s *mapping, const char *str, unsigned int defaultValue);
// MapValueToString
// file dvbadapter.c line 1558
static char * MapValueToString(struct StringToParamMapping_s *mapping, unsigned int value, char *defaultValue);
// MapYamlNode
// file dvbadapter.c line 1585
static unsigned int MapYamlNode(struct yaml_document_s *document, const char *key, struct StringToParamMapping_s *mapping, unsigned int defaultValue);
// MessageQAvailable
// file threading/messageq.c line 110
signed int MessageQAvailable(struct MessageQ_s *msgQ);
// MessageQCreate
// file ../include/messageq.h line 43
struct MessageQ_s * MessageQCreate();
// MessageQDestroy
// file ../include/messageq.h line 49
void MessageQDestroy(struct MessageQ_s *msgQ);
// MessageQIsQuitSet
// file ../include/messageq.h line 108
_Bool MessageQIsQuitSet(struct MessageQ_s *msgQ);
// MessageQReceive
// file threading/messageq.c line 119
void * MessageQReceive(struct MessageQ_s *msgQ);
// MessageQReceiveTimed
// file ../include/messageq.h line 87
void * MessageQReceiveTimed(struct MessageQ_s *msgQ, unsigned long int timeout);
// MessageQResetQuit
// file threading/messageq.c line 176
void MessageQResetQuit(struct MessageQ_s *msgQ);
// MessageQSend
// file ../include/messageq.h line 60
void MessageQSend(struct MessageQ_s *msgQ, void *msg);
// MessageQSetQuit
// file threading/messageq.c line 168
void MessageQSetQuit(struct MessageQ_s *msgQ);
// MultiplexAdd
// file multiplexes.c line 196
signed int MultiplexAdd(enum DVBDeliverySystem_e delSys, char *tuningParams, struct Multiplex_s **mux);
// MultiplexDeInit
// file ../include/multiplexes.h line 84
signed int MultiplexDeInit(void);
// MultiplexDelete
// file multiplexes.c line 226
signed int MultiplexDelete(struct Multiplex_s *multiplex);
// MultiplexDestructor
// file multiplexes.c line 292
static void MultiplexDestructor(void *ptr);
// MultiplexEnumeratorDestroy
// file multiplexes.c line 136
void MultiplexEnumeratorDestroy(void *enumerator);
// MultiplexEnumeratorGet
// file multiplexes.c line 127
void * MultiplexEnumeratorGet();
// MultiplexEventToString
// file ../include/multiplexes.h line 219
signed int MultiplexEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload);
// MultiplexFind
// file multiplexes.c line 74
struct Multiplex_s * MultiplexFind(char *mux);
// MultiplexFindId
// file multiplexes.c line 110
struct Multiplex_s * MultiplexFindId(signed int netid, signed int tsid);
// MultiplexFindUID
// file ../include/multiplexes.h line 105
struct Multiplex_s * MultiplexFindUID(signed int uid);
// MultiplexGetAll
// file multiplexes.c line 174
struct MultiplexList_s * MultiplexGetAll(void);
// MultiplexGetNext
// file multiplexes.c line 143
struct Multiplex_s * MultiplexGetNext(void *enumerator);
// MultiplexInit
// file ../include/multiplexes.h line 78
signed int MultiplexInit(void);
// MultiplexListDestructor
// file multiplexes.c line 301
static void MultiplexListDestructor(void *ptr);
// MultiplexNetworkIdSet
// file multiplexes.c line 260
signed int MultiplexNetworkIdSet(struct Multiplex_s *multiplex, signed int netid);
// MultiplexTSIdSet
// file multiplexes.c line 245
signed int MultiplexTSIdSet(struct Multiplex_s *multiplex, signed int tsid);
// NITEventListener
// file commands/cmd_scanning.c line 1221
static void NITEventListener(void *arg, struct Event_s *event, void *payload);
// NITHandler
// file standard/dvb/nitprocessor.c line 128
static void NITHandler(void *arg, struct dvbpsi_nit_s *newNIT);
// NITProcessorCreate
// file ../include/nitprocessor.h line 30
struct NITProcessor_s * NITProcessorCreate(struct TSReader_t *reader);
// NITProcessorDestroy
// file ../include/nitprocessor.h line 31
void NITProcessorDestroy(struct NITProcessor_s *processor);
// NITProcessorFilterEventCallback
// file standard/dvb/nitprocessor.c line 96
static void NITProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details);
// NetUserExit
// file dispatchers.c line 130
static void NetUserExit(struct ev_loop *loop, struct ev_io *w, signed int revents);
// NullOutputCanHandle
// file deliverymethod.c line 193
_Bool NullOutputCanHandle(char *mrl);
// NullOutputCreate
// file deliverymethod.c line 198
struct DeliveryMethodInstance_t * NullOutputCreate(char *arg);
// NullOutputDestroy
// file deliverymethod.c line 203
void NullOutputDestroy(struct DeliveryMethodInstance_t *this);
// ObjectAllocImpl
// file ../include/objects.h line 221
void * ObjectAllocImpl(signed int size, char *file, signed int line);
// ObjectAllocInstance
// file objects.c line 364
static void * ObjectAllocInstance(signed int size, struct Class_s *clazz);
// ObjectCollectionCreateImpl
// file ../include/objects.h line 150
struct ObjectCollection_s * ObjectCollectionCreateImpl(char *name, unsigned int entries, char *file, signed int line);
// ObjectCreateImpl
// file ../include/objects.h line 130
void * ObjectCreateImpl(char *classname, char *file, signed int line);
// ObjectDeinit
// file ../include/objects.h line 63
signed int ObjectDeinit(void);
// ObjectDump
// file objects.c line 401
void ObjectDump(void *ptr);
// ObjectFreeImpl
// file ../include/objects.h line 236
void ObjectFreeImpl(void *ptr, char *file, signed int line);
// ObjectGetObjectClass
// file objects.c line 430
char * ObjectGetObjectClass(void *ptr);
// ObjectInit
// file ../include/objects.h line 58
signed int ObjectInit(void);
// ObjectIsObject
// file objects.c line 414
_Bool ObjectIsObject(void *ptr);
// ObjectRefCount
// file objects.c line 442
signed int ObjectRefCount(void *ptr);
// ObjectRefDecImpl
// file ../include/objects.h line 183
_Bool ObjectRefDecImpl(void *ptr, char *file, signed int line);
// ObjectRefIncImpl
// file ../include/objects.h line 166
void ObjectRefIncImpl(void *ptr, char *file, signed int line);
// ObjectRegisterClass
// file ../include/objects.h line 74
signed int ObjectRegisterClass(char *classname, unsigned int size, void (*destructor)(void *));
// ObjectRegisterClass::destructor_object
//
void destructor_object(void *);
// ObjectRegisterClassType
// file objects.c line 180
static signed int ObjectRegisterClassType(char *name, enum ClassType_e type, unsigned int size, void (*destructor)(void *));
// ObjectRegisterClassType::destructor_object
//
void destructor_object(void *);
// ObjectRegisterCollection
// file ../include/objects.h line 86
signed int ObjectRegisterCollection(char *name, unsigned int entrysize, void (*destructor)(void *));
// ObjectRegisterCollection::destructor_object
//
void destructor_object(void *);
// PATEventListener
// file commands/cmd_scanning.c line 1167
static void PATEventListener(void *arg, struct Event_s *event, void *payload);
// PATHandler
// file standard/mpeg2/patprocessor.c line 122
static void PATHandler(void *arg, struct dvbpsi_pat_s *newpat);
// PATProcessorCreate
// file ../include/patprocessor.h line 29
struct PATProcessor_s * PATProcessorCreate(struct TSReader_t *reader);
// PATProcessorDestroy
// file ../include/patprocessor.h line 30
void PATProcessorDestroy(struct PATProcessor_s *processor);
// PATProcessorFilterEventCallback
// file standard/mpeg2/patprocessor.c line 99
static void PATProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details);
// PIDAdd
// file pids.c line 199
static signed int PIDAdd(struct Service_t *service, struct StreamInfo_t *pid);
// PIDListCount
// file pids.c line 179
static signed int PIDListCount(struct Service_t *service);
// PMTEventListener
// file commands/cmd_scanning.c line 1198
static void PMTEventListener(void *arg, struct Event_s *event, void *payload);
// PMTHandler
// file standard/mpeg2/pmtprocessor.c line 156
static void PMTHandler(void *arg, struct dvbpsi_pmt_s *newpmt);
// PMTProcessorCreate
// file ../include/pmtprocessor.h line 30
struct PMTProcessor_s * PMTProcessorCreate(struct TSReader_t *reader);
// PMTProcessorDestroy
// file ../include/pmtprocessor.h line 31
void PMTProcessorDestroy(struct PMTProcessor_s *processor);
// PMTProcessorFilterEventCallback
// file standard/mpeg2/pmtprocessor.c line 114
static void PMTProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details);
// PMTsRecievedFindOrAdd
// file commands/cmd_scanning.c line 1125
static struct PMTReceived_t * PMTsRecievedFindOrAdd(unsigned short int id);
// PSIPProcessorCreate
// file ../include/psipprocessor.h line 29
struct PSIPProcessor_s * PSIPProcessorCreate(struct TSReader_t *reader);
// PSIPProcessorDestroy
// file ../include/psipprocessor.h line 30
void PSIPProcessorDestroy(struct PSIPProcessor_s *filter);
// PSIPProcessorFilterEventCallback
// file standard/atsc/psipprocessor.c line 143
static void PSIPProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details);
// PacketFilterListAddFilter
// file ts.c line 544
static struct TSPacketFilter_t * PacketFilterListAddFilter(struct TSReader_t *reader, struct TSFilterGroup_t *group, unsigned short int pid, void (*callback)(void *, struct TSFilterGroup_t *, struct TSPacket_t *), void *userArg);

//

// PacketFilterListRemoveFilter
// file ts.c line 615
static void PacketFilterListRemoveFilter(struct TSReader_t *reader, struct TSPacketFilter_t *packetFilter);
// ParseLine
// file commands.c line 439
static void ParseLine(char *line, char **command, char **argument);
// ParseMuxListFrequencies
// file commands/cmd_scanning.c line 1436
static struct MuxFrequencies_s * ParseMuxListFrequencies(struct MultiplexList_s *muxList);
// PluginManagerDeInit
// file ../include/pluginmgr.h line 27
void PluginManagerDeInit(void);
// PluginManagerInit
// file ../include/pluginmgr.h line 26
signed int PluginManagerInit(void);
// PluginManagerInstallPlugin
// file pluginmgr.c line 240
static void PluginManagerInstallPlugin(struct Plugin_t *pluginInterface);
// PluginManagerLoadPlugin
// file pluginmgr.c line 164
static signed int PluginManagerLoadPlugin(const char *filename, void *userarg);
// PluginManagerLsPlugins
// file pluginmgr.c line 375
static void PluginManagerLsPlugins(signed int argc, char **argv);
// PluginManagerPluginInfo
// file pluginmgr.c line 385
static void PluginManagerPluginInfo(signed int argc, char **argv);
// PluginManagerUninstallPlugin
// file pluginmgr.c line 308
static void PluginManagerUninstallPlugin(struct Plugin_t *pluginInterface);
// PluginManagerUnloadPlugin
// file pluginmgr.c line 229
static void PluginManagerUnloadPlugin(struct PluginEntry_t *entry);
// PrintResponse
// file remoteintf.c line 410
static void PrintResponse(struct _IO_FILE *fp, unsigned short int errno, char *msg);
// PrintXmlified
// file commands/cmd_epg.c line 129
static void PrintXmlified(char *text);
// ProcessCommand
// file commands.c line 363
static _Bool ProcessCommand(struct CommandContext_t *context, char *command, char *argument);
// ProcessMGT
// file standard/atsc/psipprocessor.c line 187
static void ProcessMGT(void *arg, struct dvbpsi_atsc_mgt_s *newMGT);
// ProcessPacket
// file ts.c line 928
static void ProcessPacket(struct TSReader_t *reader, struct TSPacket_t *packet);
// ProcessSTT
// file standard/atsc/psipprocessor.c line 220
static void ProcessSTT(void *arg, struct dvbpsi_atsc_stt_s *newSTT);
// ProcessTransponderList
// file commands/cmd_scanning.c line 1503
static void ProcessTransponderList(void);
// ProcessVCT
// file standard/atsc/psipprocessor.c line 229
static void ProcessVCT(void *arg, struct dvbpsi_atsc_vct_s *newVCT);
// ProgramInfoDestructor
// file pids.c line 290
static void ProgramInfoDestructor(void *ptr);
// ProgramInfoGet
// file pids.c line 93
struct ProgramInfo_s * ProgramInfoGet(struct Service_t *service);
// ProgramInfoNew
// file pids.c line 54
struct ProgramInfo_s * ProgramInfoNew(signed int nrofStreams);
// ProgramInfoRemove
// file pids.c line 161
signed int ProgramInfoRemove(struct Service_t *service);
// ProgramInfoSet
// file pids.c line 72
signed int ProgramInfoSet(struct Service_t *service, struct ProgramInfo_s *info);
// PromiscusModeEnable
// file ts.c line 507
static void PromiscusModeEnable(struct TSReader_t *reader, _Bool enable);
// PropertiesAddProperty
// file ../include/properties.h line 95
signed int PropertiesAddProperty(const char *path, const char *name, const char *desc, enum PropertyType_e type, void *userArg, signed int (*get)(void *, struct PropertyValue_s *), signed int (*set)(void *, struct PropertyValue_s *));
// PropertiesAddProperty::get_object
//
signed int get_object(void *, struct PropertyValue_s *);
// PropertiesAddProperty::set_object
//
signed int set_object(void *, struct PropertyValue_s *);
// PropertiesCreateNode
// file properties.c line 543
static struct PropertyNode_s * PropertiesCreateNode(struct PropertyNode_s *parentNode, const char *newProp);
// PropertiesCreateNodes
// file properties.c line 519
static struct PropertyNode_s * PropertiesCreateNodes(const char *path);
// PropertiesDeInit
// file ../include/properties.h line 92
signed int PropertiesDeInit(void);
// PropertiesEnumGetInfo
// file ../include/properties.h line 112
void PropertiesEnumGetInfo(void *pos, struct PropertyInfo_s *propInfo);
// PropertiesEnumNext
// file ../include/properties.h line 110
void * PropertiesEnumNext(void *pos);
// PropertiesEnumerate
// file ../include/properties.h line 108
signed int PropertiesEnumerate(char *path, void **pos);
// PropertiesFindNode
// file properties.c line 588
static struct PropertyNode_s * PropertiesFindNode(struct PropertyPathElements_s *pathElements, signed int *leftOver, struct PropertyNode_s **before);
// PropertiesGet
// file ../include/properties.h line 104
signed int PropertiesGet(char *path, struct PropertyValue_s *value);
// PropertiesGetInfo
// file ../include/properties.h line 114
signed int PropertiesGetInfo(char *path, struct PropertyInfo_s *propInfo);
// PropertiesInit
// file ../include/properties.h line 86
signed int PropertiesInit(void);
// PropertiesRemoveAllProperties
// file ../include/properties.h line 100
signed int PropertiesRemoveAllProperties(const char *path);
// PropertiesRemoveProperty
// file properties.c line 120
signed int PropertiesRemoveProperty(const char *path, const char *name);
// PropertiesSet
// file properties.c line 219
signed int PropertiesSet(char *path, struct PropertyValue_s *value);
// PropertiesSetStr
// file ../include/properties.h line 106
signed int PropertiesSetStr(char *path, char *value);
// PropertiesSimplePropertyGet
// file ../include/properties.h line 125
signed int PropertiesSimplePropertyGet(void *userArg, struct PropertyValue_s *value);
// PropertiesSimplePropertySet
// file ../include/properties.h line 136
signed int PropertiesSimplePropertySet(void *userArg, struct PropertyValue_s *value);
// PropertiesStrToValue
// file properties.c line 373
static signed int PropertiesStrToValue(char *input, enum PropertyType_e toType, struct PropertyValue_s *output);
// PropertryDestructor
// file properties.c line 670
static void PropertryDestructor(void *ptr);
// PropertyPathElementsDestructor
// file properties.c line 660
static void PropertyPathElementsDestructor(void *ptr);
// PropertyPathSplitElements
// file properties.c line 633
static struct PropertyPathElements_s * PropertyPathSplitElements(const char *path);
// RegisterEventListener
// file events.c line 421
static void RegisterEventListener(struct List_s *listenerList, void (*callback)(void *, struct Event_s *, void *), void *arg);

//

// RemoteInterfaceAcceptCallback
// file remoteintf.c line 272
static void RemoteInterfaceAcceptCallback(struct ev_loop *loop, struct ev_io *w, signed int revents);
// RemoteInterfaceAuthenticate
// file remoteintf.c line 419
static void RemoteInterfaceAuthenticate(signed int argc, char **argv);
// RemoteInterfaceDeInit
// file ../include/remoteintf.h line 30
void RemoteInterfaceDeInit(void);
// RemoteInterfaceInit
// file ../include/remoteintf.h line 29
signed int RemoteInterfaceInit(signed int adapter, char *streamerName, char *bindAddress, char *username, char *password);
// RemoteInterfaceLogout
// file remoteintf.c line 452
static void RemoteInterfaceLogout(signed int argc, char **argv);
// RemoteInterfaceWho
// file remoteintf.c line 435
static void RemoteInterfaceWho(signed int argc, char **argv);
// RemoveConnection
// file remoteintf.c line 323
static void RemoveConnection(struct Connection_t *connection);
// RemoveReferencedObject
// file objects.c line 464
static void RemoveReferencedObject(struct Object_s *toRemove);
// RollUpDescriptors
// file pids.c line 222
static void * RollUpDescriptors(struct dvbpsi_descriptor_s *descriptors, signed int *datasize);
// SDTEventListener
// file commands/cmd_scanning.c line 1213
static void SDTEventListener(void *arg, struct Event_s *event, void *payload);
// SDTHandler
// file standard/dvb/sdtprocessor.c line 139
static void SDTHandler(void *arg, struct dvbpsi_sdt_s *newSDT);
// SDTProcessorCreate
// file ../include/sdtprocessor.h line 28
struct SDTProcessor_s * SDTProcessorCreate(struct TSReader_t *reader);
// SDTProcessorDestroy
// file ../include/sdtprocessor.h line 29
void SDTProcessorDestroy(struct SDTProcessor_s *processor);
// SDTProcessorFilterEventCallback
// file standard/dvb/sdtprocessor.c line 118
static void SDTProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details);
// ScanCurrentMultiplexes
// file commands/cmd_scanning.c line 525
static void ScanCurrentMultiplexes(void);
// ScanEntryDestructor
// file commands/cmd_scanning.c line 1863
static void ScanEntryDestructor(void *ptr);
// ScanEventToString
// file commands/cmd_scanning.c line 1900
static signed int ScanEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload);
// ScanFullATSC
// file commands/cmd_scanning.c line 845
static void ScanFullATSC(void);
// ScanFullDVBC
// file commands/cmd_scanning.c line 729
static void ScanFullDVBC(void);
// ScanFullDVBT
// file commands/cmd_scanning.c line 543
static void ScanFullDVBT(void);
// ScanListAddEntry
// file commands/cmd_scanning.c line 1830
static void ScanListAddEntry(enum DVBDeliverySystem_e delSys, struct Multiplex_s *mux, struct TuningParamDocs_s *docs);
// ScanListNextEntry
// file commands/cmd_scanning.c line 1851
static struct ScanEntry_s * ScanListNextEntry(void);
// ScanListReset
// file commands/cmd_scanning.c line 1815
static void ScanListReset(void);
// ScanNetwork
// file commands/cmd_scanning.c line 943
static void ScanNetwork(char *initialdata);
// ScanStart
// file commands/cmd_scanning.c line 1544
static void ScanStart(enum ScanType_e type);
// ScanStartStopWatcher
// file commands/cmd_scanning.c line 1557
static void ScanStartStopWatcher(struct ev_loop *loop, struct ev_async *w, signed int revents);
// ScanStateMachine
// file commands/cmd_scanning.c line 1577
static void ScanStateMachine(enum ScanEvent_e event);
// ScanStop
// file commands/cmd_scanning.c line 1551
static void ScanStop(void);
// ScanningInProgressGet
// file commands/cmd_scanning.c line 1918
static signed int ScanningInProgressGet(void *userArg, struct PropertyValue_s *value);
// SectionFilterListAddFilter
// file ts.c line 685
static void SectionFilterListAddFilter(struct TSReader_t *reader, struct TSSectionFilter_t *filter);
// SectionFilterListCreate
// file ts.c line 656
static struct TSSectionFilterList_t * SectionFilterListCreate(struct TSReader_t *reader, unsigned short int pid);
// SectionFilterListDescheduleFilters
// file ts.c line 790
static void SectionFilterListDescheduleFilters(struct TSReader_t *reader);
// SectionFilterListDescheduleOneFilter
// file ts.c line 804
static void SectionFilterListDescheduleOneFilter(struct TSReader_t *reader);
// SectionFilterListDestroy
// file ts.c line 667
static void SectionFilterListDestroy(struct TSReader_t *reader, struct TSSectionFilterList_t *sfList);
// SectionFilterListFind
// file ts.c line 748
static struct TSSectionFilterList_t * SectionFilterListFind(struct TSReader_t *reader, unsigned short int pid);
// SectionFilterListPacketCallback
// file ts.c line 833
static void SectionFilterListPacketCallback(void *userArg, struct TSFilterGroup_t *group, struct TSPacket_t *packet);
// SectionFilterListPushSection
// file ts.c line 847
static void SectionFilterListPushSection(void *userArg, struct dvbpsi_decoder_s *sectionsHandle, struct dvbpsi_psi_section_s *section);
// SectionFilterListRemoveFilter
// file ts.c line 701
static void SectionFilterListRemoveFilter(struct TSReader_t *reader, struct TSSectionFilter_t *filter);
// SectionFilterListScheduleFilters
// file ts.c line 771
static void SectionFilterListScheduleFilters(struct TSReader_t *reader);
// SectionFilterListUpdatePriority
// file ts.c line 718
static void SectionFilterListUpdatePriority(struct TSSectionFilterList_t *sfList);
// SendToPacketFilters
// file ts.c line 935
static void SendToPacketFilters(struct TSReader_t *reader, unsigned short int pid, struct TSPacket_t *packet);
// ServiceAdd
// file services.c line 132
signed int ServiceAdd(signed int uid, char *name, signed int id, signed int source);
// ServiceConditionalAccessSet
// file services.c line 249
signed int ServiceConditionalAccessSet(struct Service_t *service, _Bool ca);
// ServiceCreateList
// file services.c line 596
static struct List_s * ServiceCreateList(void *enumerator);
// ServiceDeInit
// file ../include/services.h line 122
signed int ServiceDeInit(void);
// ServiceDefaultAuthoritySet
// file services.c line 328
signed int ServiceDefaultAuthoritySet(struct Service_t *service, char *defaultAuthority);
// ServiceDelete
// file services.c line 98
signed int ServiceDelete(struct Service_t *service);
// ServiceDeleteAll
// file ../include/services.h line 143
signed int ServiceDeleteAll(struct Multiplex_s *mux);
// ServiceDestructor
// file services.c line 646
static void ServiceDestructor(void *arg);
// ServiceEnumeratorDestroy
// file services.c line 513
void ServiceEnumeratorDestroy(void *enumerator);
// ServiceEnumeratorForMultiplex
// file services.c line 457
void * ServiceEnumeratorForMultiplex(struct Multiplex_s *multiplex);
// ServiceEnumeratorGet
// file services.c line 437
void * ServiceEnumeratorGet();
// ServiceEventToString
// file ../include/services.h line 379
signed int ServiceEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload);
// ServiceFilterAVSOnlyGet
// file servicefilter.c line 299
_Bool ServiceFilterAVSOnlyGet(struct ServiceFilter_s *filter);
// ServiceFilterAVSOnlySet
// file servicefilter.c line 282
void ServiceFilterAVSOnlySet(struct ServiceFilter_s *filter, _Bool enable);
// ServiceFilterAllocateFilters
// file servicefilter.c line 547
static void ServiceFilterAllocateFilters(struct ServiceFilter_s *filter);
// ServiceFilterCreate
// file ../include/servicefilter.h line 66
struct ServiceFilter_s * ServiceFilterCreate(struct TSReader_t *reader, char *name);
// ServiceFilterDeInit
// file ../include/servicefilter.h line 58
signed int ServiceFilterDeInit(void);
// ServiceFilterDeliveryMethodGet
// file servicefilter.c line 318
struct DeliveryMethodInstance_t * ServiceFilterDeliveryMethodGet(struct ServiceFilter_s *filter);
// ServiceFilterDeliveryMethodSet
// file ../include/servicefilter.h line 119
void ServiceFilterDeliveryMethodSet(struct ServiceFilter_s *filter, struct DeliveryMethodInstance_t *instance);
// ServiceFilterDestroy
// file servicefilter.c line 175
void ServiceFilterDestroy(struct ServiceFilter_s *filter);
// ServiceFilterDestroyAll
// file ../include/servicefilter.h line 78
void ServiceFilterDestroyAll(struct TSReader_t *reader);
// ServiceFilterEventToString
// file servicefilter.c line 644
static signed int ServiceFilterEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload);
// ServiceFilterFilterEventCallback
// file servicefilter.c line 326
static void ServiceFilterFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details);
// ServiceFilterFindFilter
// file servicefilter.c line 225
struct ServiceFilter_s * ServiceFilterFindFilter(struct TSReader_t *reader, const char *name);
// ServiceFilterGetListIterator
// file servicefilter.c line 217
struct ListIterator_s * ServiceFilterGetListIterator(void);
// ServiceFilterInit
// file ../include/servicefilter.h line 51
signed int ServiceFilterInit(void);
// ServiceFilterInitPacket
// file servicefilter.c line 518
static void ServiceFilterInitPacket(struct TSPacket_t *packet, struct dvbpsi_psi_section_s *section, char *sectionname);
// ServiceFilterNameGet
// file servicefilter.c line 272
char * ServiceFilterNameGet(struct ServiceFilter_s *filter);
// ServiceFilterPATRewrite
// file servicefilter.c line 404
static void ServiceFilterPATRewrite(struct ServiceFilter_s *filter);
// ServiceFilterPIDSUpdatedListener
// file servicefilter.c line 344
static void ServiceFilterPIDSUpdatedListener(void *userArg, struct Event_s *event, void *details);
// ServiceFilterPMTRewrite
// file servicefilter.c line 422
static void ServiceFilterPMTRewrite(struct ServiceFilter_s *state);
// ServiceFilterProcessPacket
// file servicefilter.c line 356
static void ServiceFilterProcessPacket(void *arg, struct TSFilterGroup_t *group, struct TSPacket_t *packet);
// ServiceFilterPropertyAVSOnlyGet
// file servicefilter.c line 629
static signed int ServiceFilterPropertyAVSOnlyGet(void *userArg, struct PropertyValue_s *value);
// ServiceFilterPropertyAVSOnlySet
// file servicefilter.c line 637
static signed int ServiceFilterPropertyAVSOnlySet(void *userArg, struct PropertyValue_s *value);
// ServiceFilterPropertyServiceGet
// file servicefilter.c line 614
static signed int ServiceFilterPropertyServiceGet(void *userArg, struct PropertyValue_s *value);
// ServiceFilterServiceGet
// file servicefilter.c line 277
struct Service_t * ServiceFilterServiceGet(struct ServiceFilter_s *filter);
// ServiceFilterServiceSet
// file ../include/servicefilter.h line 88
void ServiceFilterServiceSet(struct ServiceFilter_s *filter, struct Service_t *service);
// ServiceFind
// file services.c line 359
struct Service_t * ServiceFind(char *name);
// ServiceFindFQID
// file services.c line 403
struct Service_t * ServiceFindFQID(unsigned short int networkId, unsigned short int tsId, unsigned short int serviceId);
// ServiceFindFQIDStr
// file services.c line 423
struct Service_t * ServiceFindFQIDStr(char *FQIdStr);
// ServiceFindId
// file services.c line 386
struct Service_t * ServiceFindId(struct Multiplex_s *multiplex, signed int id);
// ServiceFindName
// file services.c line 369
struct Service_t * ServiceFindName(char *name);
// ServiceGetAll
// file services.c line 452
struct ServiceList_s * ServiceGetAll();
// ServiceGetIDNameStr
// file services.c line 579
char * ServiceGetIDNameStr(struct Service_t *service, char *buffer);
// ServiceGetIDStr
// file services.c line 565
char * ServiceGetIDStr(struct Service_t *service, char *buffer);
// ServiceGetList
// file services.c line 615
static struct ServiceList_s * ServiceGetList(char *where);
// ServiceGetListForMultiplex
// file services.c line 476
struct ServiceList_s * ServiceGetListForMultiplex(struct Multiplex_s *multiplex);
// ServiceGetListForNameLike
// file services.c line 503
struct ServiceList_s * ServiceGetListForNameLike(char *query);
// ServiceGetNext
// file services.c line 520
struct Service_t * ServiceGetNext(void *enumerator);
// ServiceInit
// file ../include/services.h line 116
signed int ServiceInit(void);
// ServiceListAll
// file services.c line 447
struct List_s * ServiceListAll();
// ServiceListDestructor
// file services.c line 663
static void ServiceListDestructor(void *arg);
// ServiceListForMultiplex
// file services.c line 471
struct List_s * ServiceListForMultiplex(struct Multiplex_s *multiplex);
// ServiceListForNameLike
// file services.c line 498
struct List_s * ServiceListForNameLike(char *query);
// ServiceNameSet
// file services.c line 194
signed int ServiceNameSet(struct Service_t *service, char *name);
// ServicePMTPIDSet
// file services.c line 170
signed int ServicePMTPIDSet(struct Service_t *service, signed int pmtpid);
// ServiceProviderSet
// file services.c line 297
signed int ServiceProviderSet(struct Service_t *service, char *provider);
// ServiceQueryNameLike
// file services.c line 484
void * ServiceQueryNameLike(char *query);
// ServiceSourceSet
// file services.c line 225
signed int ServiceSourceSet(struct Service_t *service, signed int source);
// ServiceTypeSet
// file services.c line 273
signed int ServiceTypeSet(struct Service_t *service, enum anonymous type);
// StatsAddFilterGroupStats
// file ts.c line 486
static void StatsAddFilterGroupStats(struct TSReaderStats_t *stats, const char *type, struct TSFilterGroupStats_t *filterGroupStats);
// StreamInfoListDestructor
// file pids.c line 300
static void StreamInfoListDestructor(void *ptr);
// SubTableHandler
// file standard/atsc/psipprocessor.c line 155
static void SubTableHandler(void *arg, struct dvbpsi_decoder_s *demuxHandle, unsigned char tableId, unsigned short int extension);
// SubTableHandler_link1
// file standard/dvb/sdtprocessor.c line 131
static void SubTableHandler_link1(void *arg_link1, struct dvbpsi_decoder_s *demuxHandle_link1, unsigned char tableId_link1, unsigned short int extension_link1);
// SubTableHandler_link2
// file standard/dvb/nitprocessor.c line 120
static void SubTableHandler_link2(void *arg_link2, struct dvbpsi_decoder_s *demuxHandle_link2, unsigned char tableId_link2, unsigned short int extension_link2);
// SysPropertyGetUptime
// file main.c line 588
static signed int SysPropertyGetUptime(void *userArg, struct PropertyValue_s *value);
// SysPropertyGetUptimeSecs
// file main.c line 609
static signed int SysPropertyGetUptimeSecs(void *userArg, struct PropertyValue_s *value);
// TDTHandler
// file standard/dvb/tdtprocessor.c line 125
static void TDTHandler(void *arg, struct dvbpsi_tdt_tot_s *newTDT);
// TDTProcessorCreate
// file ../include/tdtprocessor.h line 29
struct TDTProcessor_s * TDTProcessorCreate(struct TSReader_t *reader);
// TDTProcessorDestroy
// file ../include/tdtprocessor.h line 30
void TDTProcessorDestroy(struct TDTProcessor_s *processor);
// TDTProcessorFilterEventCallback
// file standard/dvb/tdtprocessor.c line 103
static void TDTProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details);
// TSFilterGroupAddPacketFilter
// file ts.c line 394
_Bool TSFilterGroupAddPacketFilter(struct TSFilterGroup_t *group, unsigned short int pid, void (*callback)(void *, struct TSFilterGroup_t *, struct TSPacket_t *), void *userArg);

//

// TSFilterGroupAddSectionFilter
// file ts.c line 345
void TSFilterGroupAddSectionFilter(struct TSFilterGroup_t *group, unsigned short int pid, signed int priority, struct dvbpsi_decoder_s *handle);
// TSFilterGroupDestroy
// file ts.c line 301
void TSFilterGroupDestroy(struct TSFilterGroup_t *group);
// TSFilterGroupRemoveAllFilters
// file ts.c line 320
void TSFilterGroupRemoveAllFilters(struct TSFilterGroup_t *group);
// TSFilterGroupRemovePacketFilter
// file ts.c line 434
void TSFilterGroupRemovePacketFilter(struct TSFilterGroup_t *group, unsigned short int pid);
// TSFilterGroupRemoveSectionFilter
// file ts.c line 364
void TSFilterGroupRemoveSectionFilter(struct TSFilterGroup_t *group, unsigned short int pid);
// TSFilterGroupResetStats
// file ts.c line 311
void TSFilterGroupResetStats(struct TSFilterGroup_t *group);
// TSReaderBitrateCallback
// file ts.c line 908
static void TSReaderBitrateCallback(struct ev_loop *loop, struct ev_timer *w, signed int revents);
// TSReaderCreate
// file ../include/ts.h line 299
struct TSReader_t * TSReaderCreate(struct DVBAdapter_s *adapter);
// TSReaderCreateFilterGroup
// file ts.c line 264
struct TSFilterGroup_t * TSReaderCreateFilterGroup(struct TSReader_t *reader, const char *name, const char *type, void (*callback)(void *, struct TSFilterGroup_t *, enum TSFilterEventType_e, void *), void *userArg);

//

// TSReaderDVRCallback
// file ts.c line 875
static void TSReaderDVRCallback(struct ev_loop *loop, struct ev_io *w, signed int revents);
// TSReaderDestroy
// file ../include/ts.h line 305
void TSReaderDestroy(struct TSReader_t *reader);
// TSReaderEnable
// file ../include/ts.h line 312
void TSReaderEnable(struct TSReader_t *reader, _Bool enable);
// TSReaderExtractStats
// file ts.c line 186
struct TSReaderStats_t * TSReaderExtractStats(struct TSReader_t *reader);
// TSReaderFindFilterGroup
// file ts.c line 282
struct TSFilterGroup_t * TSReaderFindFilterGroup(struct TSReader_t *reader, const char *name, const char *type);
// TSReaderMultiplexChanged
// file ../include/ts.h line 334
void TSReaderMultiplexChanged(struct TSReader_t *reader, struct Multiplex_s *newmultiplex);
// TSReaderNotificationCallback
// file ts.c line 915
static void TSReaderNotificationCallback(struct ev_loop *loop, struct ev_async *w, signed int revents);
// TSReaderSectionFilterOverridePriority
// file ts.c line 238
void TSReaderSectionFilterOverridePriority(struct TSReader_t *reader, unsigned short int pid, signed int priority);
// TSReaderSectionFilterResetPriority
// file ts.c line 251
void TSReaderSectionFilterResetPriority(struct TSReader_t *reader, unsigned short int pid);
// TSReaderStatsDestructor
// file ts.c line 467
static void TSReaderStatsDestructor(void *ptr);
// TSReaderZeroStats
// file ../include/ts.h line 327
void TSReaderZeroStats(struct TSReader_t *reader);
// TableEventCallback
// file pluginmgr.c line 487
static void TableEventCallback(void *arg, struct Event_s *event, void *details);

//

// TimeoutWatcher
// file commands/cmd_scanning.c line 1571
static void TimeoutWatcher(struct ev_loop *loop, struct ev_timer *w, signed int revents);
// Tokenise
// file commands.c line 501
static char ** Tokenise(char *arguments, signed int *argc);
// TransponderEntryDestructor
// file commands/cmd_scanning.c line 1877
static void TransponderEntryDestructor(void *ptr);
// TryTuneDVBC
// file commands/cmd_scanning.c line 804
static void TryTuneDVBC(struct MultiplexList_s *muxList, struct MuxFrequencies_s *muxFreqList, unsigned int freq, char *inversion, char *code_rate, unsigned int *symbolRates, signed int nrofSymbolRates, char **modulations, signed int nrofModulations);
// TuneMultiplex
// file tuning.c line 243
static void TuneMultiplex(struct Multiplex_s *multiplex);
// TuningCurrentMultiplexGet
// file tuning.c line 208
struct Multiplex_s * TuningCurrentMultiplexGet(void);
// TuningCurrentMultiplexSet
// file tuning.c line 214
void TuningCurrentMultiplexSet(struct Multiplex_s *multiplex);
// TuningCurrentServiceGet
// file tuning.c line 107
struct Service_t * TuningCurrentServiceGet(void);
// TuningCurrentServiceIsLocked
// file tuning.c line 98
_Bool TuningCurrentServiceIsLocked(void);
// TuningCurrentServiceLock
// file tuning.c line 78
_Bool TuningCurrentServiceLock(void);
// TuningCurrentServiceRetune
// file tuning.c line 172
void TuningCurrentServiceRetune(void);
// TuningCurrentServiceSet
// file tuning.c line 113
_Bool TuningCurrentServiceSet(struct Service_t *service);
// TuningCurrentServiceUnlock
// file tuning.c line 91
void TuningCurrentServiceUnlock(void);
// TuningDeInit
// file ../include/tuning.h line 68
signed int TuningDeInit(void);
// TuningInit
// file ../include/tuning.h line 63
signed int TuningInit(void);
// TuningParamDocsDestructor
// file commands/cmd_scanning.c line 1886
static void TuningParamDocsDestructor(void *ptr);
// UTF8_charnum
// file utf8.c line 191
signed int UTF8_charnum(char *s, signed int offset);
// UTF8_dec
// file utf8.c line 237
void UTF8_dec(char *s, signed int *i);
// UTF8_escape
// file utf8.c line 369
signed int UTF8_escape(char *buf, signed int sz, char *src, signed int escape_quotes);
// UTF8_escape_wchar
// file utf8.c line 341
signed int UTF8_escape_wchar(char *buf, signed int sz, unsigned int ch);
// UTF8_inc
// file utf8.c line 231
void UTF8_inc(char *s, signed int *i);
// UTF8_is_locale_utf8
// file utf8.c line 431
signed int UTF8_is_locale_utf8(char *locale);
// UTF8_memchr
// file utf8.c line 406
char * UTF8_memchr(char *s, unsigned int ch, unsigned long int sz, signed int *charn);
// UTF8_nextchar
// file ../include/utf8.h line 25
unsigned int UTF8_nextchar(char *s, signed int *i);
// UTF8_offset
// file utf8.c line 178
signed int UTF8_offset(char *str, signed int charnum);
// UTF8_printf
// file utf8.c line 471
signed int UTF8_printf(char *fmt, ...);
// UTF8_read_escape_sequence
// file utf8.c line 257
signed int UTF8_read_escape_sequence(char *str, unsigned int *dest);
// UTF8_seqlen
// file utf8.c line 49
signed int UTF8_seqlen(char *s);
// UTF8_strchr
// file utf8.c line 389
char * UTF8_strchr(char *s, unsigned int ch, signed int *charn);
// UTF8_strlen
// file utf8.c line 204
signed int UTF8_strlen(char *s);
// UTF8_toucs
// file utf8.c line 64
signed int UTF8_toucs(unsigned int *dest, signed int sz, char *src, signed int srcsz);
// UTF8_toutf8
// file utf8.c line 109
signed int UTF8_toutf8(char *dest, signed int sz, unsigned int *src, signed int srcsz);
// UTF8_unescape
// file utf8.c line 314
signed int UTF8_unescape(char *buf, signed int sz, char *src);
// UTF8_vprintf
// file utf8.c line 450
signed int UTF8_vprintf(char *fmt, void **ap);
// UTF8_wc_toutf8
// file ../include/utf8.h line 16
signed int UTF8_wc_toutf8(char *dest, unsigned int ch);
// UnRegisterEventListener
// file events.c line 432
static void UnRegisterEventListener(struct List_s *listenerList, void (*callback)(void *, struct Event_s *, void *), void *arg);

//

// UnRollDescriptors
// file pids.c line 262
static struct dvbpsi_descriptor_s * UnRollDescriptors(unsigned char *descriptors, signed int size);
// UpdateDatabase
// file main.c line 568
void UpdateDatabase();
// UserNetDispatcher
// file dispatchers.c line 144
static void * UserNetDispatcher(void *arg);
// VCTEventListener
// file commands/cmd_scanning.c line 1419
static void VCTEventListener(void *arg, struct Event_s *event, void *payload);
// YamlUtils_AddStringSection
// file yamlutils.c line 186
static void YamlUtils_AddStringSection(struct StringOutput_s *output);
// YamlUtils_DocumentToString
// file ../include/yamlutils.h line 69
signed int YamlUtils_DocumentToString(struct yaml_document_s *document, _Bool removeDocStartEnd, char **outputStr);
// YamlUtils_MappingAdd
// file ../include/yamlutils.h line 60
signed int YamlUtils_MappingAdd(struct yaml_document_s *document, signed int mapping, const char *key, const char *value);
// YamlUtils_MappingFind
// file ../include/yamlutils.h line 43
struct yaml_node_s * YamlUtils_MappingFind(struct yaml_document_s *document, struct yaml_node_s *node, const char *key);
// YamlUtils_OutputToStringSections
// file yamlutils.c line 160
static signed int YamlUtils_OutputToStringSections(void *data, unsigned char *buffer, unsigned long int size);
// YamlUtils_Parse
// file ../include/yamlutils.h line 34
signed int YamlUtils_Parse(char *str, struct yaml_document_s *document);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_history
// file /usr/include/readline/history.h line 84
extern void add_history(const char *);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bzero
// file /usr/include/string.h line 458
extern void bzero(void *, unsigned long int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// ctime
// file /usr/include/time.h line 264
extern char * ctime(const signed long int *);
// difftime
// file /usr/include/time.h line 195
extern double difftime(signed long int, signed long int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// dvbpsi_AttachDemux
// file ../include/dvbpsi/demux.h line 132
struct dvbpsi_decoder_s * dvbpsi_AttachDemux(void (*)(void *, struct dvbpsi_decoder_s *, unsigned char, unsigned short int), void *);
// dvbpsi_AttachNIT
// file ../include/dvbpsi/nit.h line 109
signed int dvbpsi_AttachNIT(struct dvbpsi_decoder_s *, unsigned char, unsigned short int, void (*)(void *, struct dvbpsi_nit_s *), void *);
// dvbpsi_AttachPAT
// file ../include/dvbpsi/pat.h line 116
struct dvbpsi_decoder_s * dvbpsi_AttachPAT(void (*)(void *, struct dvbpsi_pat_s *), void *);
// dvbpsi_AttachPMT
// file ../include/dvbpsi/pmt.h line 124
struct dvbpsi_decoder_s * dvbpsi_AttachPMT(unsigned short int, void (*)(void *, struct dvbpsi_pmt_s *), void *);
// dvbpsi_AttachSDT
// file ../include/dvbpsi/sdt.h line 131
signed int dvbpsi_AttachSDT(struct dvbpsi_decoder_s *, unsigned char, unsigned short int, void (*)(void *, struct dvbpsi_sdt_s *), void *);
// dvbpsi_AttachSections
// file ../include/dvbpsi/sections.h line 37
struct dvbpsi_decoder_s * dvbpsi_AttachSections(void (*)(void *, struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *), void *);
// dvbpsi_AttachTDTTOT
// file ../include/dvbpsi/tdttot.h line 74
struct dvbpsi_decoder_s * dvbpsi_AttachTDTTOT(void (*)(void *, struct dvbpsi_tdt_tot_s *), void *);
// dvbpsi_ClonePSISection
// file ../include/dvbpsi/psi.h line 137
struct dvbpsi_psi_section_s * dvbpsi_ClonePSISection(struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *);
// dvbpsi_DecodeDefaultAuthorityDr
// file ../include/dvbpsi/dr_73.h line 54
struct dvbpsi_default_authority_dr_s * dvbpsi_DecodeDefaultAuthorityDr(struct dvbpsi_descriptor_s *);
// dvbpsi_DecodeFrequencyListDr
// file ../include/dvbpsi/dr_62.h line 57
struct dvbpsi_frequency_list_dr_s * dvbpsi_DecodeFrequencyListDr(struct dvbpsi_descriptor_s *);
// dvbpsi_DecodeSatDelivSysDr
// file ../include/dvbpsi/dr_43.h line 83
struct dvbpsi_sat_deliv_sys_dr_s * dvbpsi_DecodeSatDelivSysDr(struct dvbpsi_descriptor_s *);
// dvbpsi_DecodeServiceDr
// file ../include/dvbpsi/dr_48.h line 82
struct dvbpsi_service_dr_s * dvbpsi_DecodeServiceDr(struct dvbpsi_descriptor_s *);
// dvbpsi_DecodeTerrDelivSysDr
// file ../include/dvbpsi/dr_5a.h line 86
struct dvbpsi_terr_deliv_sys_dr_s * dvbpsi_DecodeTerrDelivSysDr(struct dvbpsi_descriptor_s *);
// dvbpsi_DeleteDescriptors
// file ../include/dvbpsi/descriptor.h line 95
void dvbpsi_DeleteDescriptors(struct dvbpsi_descriptor_s *);
// dvbpsi_DeletePSISections
// file ../include/dvbpsi/psi.h line 160
void dvbpsi_DeletePSISections(struct dvbpsi_psi_section_s *);
// dvbpsi_DetachDemux
// file ../include/dvbpsi/demux.h line 144
void dvbpsi_DetachDemux(struct dvbpsi_decoder_s *);
// dvbpsi_DetachPAT
// file ../include/dvbpsi/pat.h line 131
void dvbpsi_DetachPAT(struct dvbpsi_decoder_s *);
// dvbpsi_DetachPMT
// file ../include/dvbpsi/pmt.h line 140
void dvbpsi_DetachPMT(struct dvbpsi_decoder_s *);
// dvbpsi_DetachSections
// file ../include/dvbpsi/sections.h line 41
void dvbpsi_DetachSections(struct dvbpsi_decoder_s *);
// dvbpsi_DetachTDTTOT
// file ../include/dvbpsi/tdttot.h line 88
void dvbpsi_DetachTDTTOT(struct dvbpsi_decoder_s *);
// dvbpsi_EmptyPAT
// file ../include/dvbpsi/pat.h line 177
void dvbpsi_EmptyPAT(struct dvbpsi_pat_s *);
// dvbpsi_EmptyPMT
// file ../include/dvbpsi/pmt.h line 192
void dvbpsi_EmptyPMT(struct dvbpsi_pmt_s *);
// dvbpsi_GenPATSections
// file ../include/dvbpsi/pat.h line 210
struct dvbpsi_psi_section_s * dvbpsi_GenPATSections(struct dvbpsi_pat_s *, signed int);
// dvbpsi_GenPMTSections
// file ../include/dvbpsi/pmt.h line 262
struct dvbpsi_psi_section_s * dvbpsi_GenPMTSections(struct dvbpsi_pmt_s *);
// dvbpsi_InitPAT
// file ../include/dvbpsi/pat.h line 147
void dvbpsi_InitPAT(struct dvbpsi_pat_s *, unsigned short int, unsigned char, signed int);
// dvbpsi_InitPMT
// file ../include/dvbpsi/pmt.h line 158
void dvbpsi_InitPMT(struct dvbpsi_pmt_s *, unsigned short int, unsigned char, signed int, unsigned short int);
// dvbpsi_NewDescriptor
// file ../include/dvbpsi/descriptor.h line 82
struct dvbpsi_descriptor_s * dvbpsi_NewDescriptor(unsigned char, unsigned char, unsigned char *);
// dvbpsi_PATAddProgram
// file ../include/dvbpsi/pat.h line 193
struct dvbpsi_pat_program_s * dvbpsi_PATAddProgram(struct dvbpsi_pat_s *, unsigned short int, unsigned short int);
// dvbpsi_PMTAddES
// file ../include/dvbpsi/pmt.h line 227
struct dvbpsi_pmt_es_s * dvbpsi_PMTAddES(struct dvbpsi_pmt_s *, unsigned char, unsigned short int);
// dvbpsi_PMTESAddDescriptor
// file ../include/dvbpsi/pmt.h line 246
struct dvbpsi_descriptor_s * dvbpsi_PMTESAddDescriptor(struct dvbpsi_pmt_es_s *, unsigned char, unsigned char, unsigned char *);
// dvbpsi_PushPacket
// file ../include/dvbpsi/dvbpsi.h line 66
void dvbpsi_PushPacket(struct dvbpsi_decoder_s *, unsigned char *);
// dvbpsi_PushSection
// file ../include/dvbpsi/sections.h line 43
void dvbpsi_PushSection(struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *);
// dvbpsi_ReleasePSISections
// file ../include/dvbpsi/psi.h line 125
void dvbpsi_ReleasePSISections(struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *);
// dvbpsi_atsc_AttachMGT
// file ../include/dvbpsi/atsc/mgt.h line 100
signed int dvbpsi_atsc_AttachMGT(struct dvbpsi_decoder_s *, unsigned char, void (*)(void *, struct dvbpsi_atsc_mgt_s *), void *);
// dvbpsi_atsc_AttachSTT
// file ../include/dvbpsi/atsc/stt.h line 78
signed int dvbpsi_atsc_AttachSTT(struct dvbpsi_decoder_s *, unsigned char, void (*)(void *, struct dvbpsi_atsc_stt_s *), void *);
// dvbpsi_atsc_AttachVCT
// file ../include/dvbpsi/atsc/vct.h line 119
signed int dvbpsi_atsc_AttachVCT(struct dvbpsi_decoder_s *, unsigned char, unsigned short int, void (*)(void *, struct dvbpsi_atsc_vct_s *), void *);
// ev_async_send
// file /usr/include/ev.h line 825
extern void ev_async_send(struct ev_loop *, struct ev_async *);
// ev_async_start
// file /usr/include/ev.h line 823
extern void ev_async_start(struct ev_loop *, struct ev_async *);
// ev_async_stop
// file /usr/include/ev.h line 824
extern void ev_async_stop(struct ev_loop *, struct ev_async *);
// ev_break
// file /usr/include/ev.h line 640
extern void ev_break(struct ev_loop *, signed int);
// ev_io_start
// file /usr/include/ev.h line 756
extern void ev_io_start(struct ev_loop *, struct ev_io *);
// ev_io_stop
// file /usr/include/ev.h line 757
extern void ev_io_stop(struct ev_loop *, struct ev_io *);
// ev_loop
// file /usr/include/ev.h line 835
static inline void ev_loop(struct ev_loop *loop, signed int flags);
// ev_loop_destroy
// file /usr/include/ev.h line 604
extern void ev_loop_destroy(struct ev_loop *);
// ev_loop_new
// file /usr/include/ev.h line 578
extern struct ev_loop * ev_loop_new(unsigned int);
// ev_run
// file /usr/include/ev.h line 639
extern signed int ev_run(struct ev_loop *, signed int);
// ev_timer_again
// file /usr/include/ev.h line 762
extern void ev_timer_again(struct ev_loop *, struct ev_timer *);
// ev_timer_start
// file /usr/include/ev.h line 759
extern void ev_timer_start(struct ev_loop *, struct ev_timer *);
// ev_timer_stop
// file /usr/include/ev.h line 760
extern void ev_timer_stop(struct ev_loop *, struct ev_timer *);
// ev_unloop
// file /usr/include/ev.h line 836
static inline void ev_unloop(struct ev_loop *loop, signed int how);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freopen
// file /usr/include/stdio.h line 278
extern struct _IO_FILE * freopen(const char *, const char *, struct _IO_FILE *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// hex_digit
// file utf8.c line 248
static signed int hex_digit(char c);
// iconv
// file /usr/include/iconv.h line 42
extern unsigned long int iconv(void *, char ** restrict , unsigned long int *, char ** restrict , unsigned long int *);
// iconv_close
// file /usr/include/iconv.h line 51
extern signed int iconv_close(void *);
// iconv_open
// file /usr/include/iconv.h line 37
extern void * iconv_open(const char *, const char *);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// installsighandler
// file main.c line 744
static void installsighandler(void);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lt_dlclose
// file /usr/include/ltdl.h line 83
extern signed int lt_dlclose(struct lt__handle *);
// lt_dlerror
// file /usr/include/ltdl.h line 82
extern const char * lt_dlerror(void);
// lt_dlexit
// file /usr/include/ltdl.h line 54
extern signed int lt_dlexit(void);
// lt_dlforeachfile
// file /usr/include/ltdl.h line 62
extern signed int lt_dlforeachfile(const char *, signed int (*)(const char *, void *), void *);
// lt_dlinit
// file /usr/include/ltdl.h line 53
extern signed int lt_dlinit(void);
// lt_dlopenext
// file /usr/include/ltdl.h line 78
extern struct lt__handle * lt_dlopenext(const char *);
// lt_dlsetsearchpath
// file /usr/include/ltdl.h line 60
extern signed int lt_dlsetsearchpath(const char *);
// lt_dlsym
// file /usr/include/ltdl.h line 81
extern void * lt_dlsym(struct lt__handle *, const char *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// octal_digit
// file utf8.c line 243
static signed int octal_digit(char c);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_21 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_21 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_21 *, const union anonymous_38 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_21 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_21 *, union anonymous_14 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_21 *, union anonymous_14 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_14 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_14 *, const union anonymous_38 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_14 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_14 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous_38 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous_38 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous_38 *, signed int);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readline
// file /usr/include/readline/readline.h line 282
extern char * readline(const char *);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// removeControlCodes
// file standard/dvb/sdtprocessor.c line 289
static void removeControlCodes(char *str);
// rl_attempted_completion_function_object
//
char ** rl_attempted_completion_function_object(const char *, signed int, signed int);
// rl_cleanup_after_signal
// file /usr/include/readline/readline.h line 428
extern void rl_cleanup_after_signal(void);
// rl_completion_matches
// file /usr/include/readline/readline.h line 443
extern char ** rl_completion_matches(const char *, char * (*)(const char *, signed int));
// rl_free_line_state
// file /usr/include/readline/readline.h line 430
extern void rl_free_line_state(void);
// setbuf
// file /usr/include/stdio.h line 332
extern void setbuf(struct _IO_FILE *, char *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// sighandler
// file main.c line 753
static void sighandler(signed int signum);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqlite3_bind_blob
// file /usr/include/sqlite3.h line 3578
signed int sqlite3_bind_blob(struct sqlite3_stmt *, signed int, const void *, signed int, void (*)(void *));
// sqlite3_busy_timeout
// file /usr/include/sqlite3.h line 2211
signed int sqlite3_busy_timeout(struct sqlite3 *, signed int);
// sqlite3_close
// file /usr/include/sqlite3.h line 313
signed int sqlite3_close(struct sqlite3 *);
// sqlite3_column_blob
// file /usr/include/sqlite3.h line 4086
const void * sqlite3_column_blob(struct sqlite3_stmt *, signed int);
// sqlite3_column_bytes
// file /usr/include/sqlite3.h line 4087
signed int sqlite3_column_bytes(struct sqlite3_stmt *, signed int);
// sqlite3_column_double
// file /usr/include/sqlite3.h line 4089
double sqlite3_column_double(struct sqlite3_stmt *, signed int);
// sqlite3_column_int
// file /usr/include/sqlite3.h line 4090
signed int sqlite3_column_int(struct sqlite3_stmt *, signed int);
// sqlite3_column_text
// file /usr/include/sqlite3.h line 4092
const unsigned char * sqlite3_column_text(struct sqlite3_stmt *, signed int);
// sqlite3_errmsg
// file /usr/include/sqlite3.h line 3102
const char * sqlite3_errmsg(struct sqlite3 *);
// sqlite3_exec
// file /usr/include/sqlite3.h line 385
signed int sqlite3_exec(struct sqlite3 *, const char *, signed int (*)(void *, signed int, char **, char **), void *, char **);
// sqlite3_finalize
// file /usr/include/sqlite3.h line 4123
signed int sqlite3_finalize(struct sqlite3_stmt *);
// sqlite3_free
// file /usr/include/sqlite3.h line 2497
void sqlite3_free(void *);
// sqlite3_mprintf
// file /usr/include/sqlite3.h line 2400
char * sqlite3_mprintf(const char *, ...);
// sqlite3_open
// file /usr/include/sqlite3.h line 3000
signed int sqlite3_open(const char *, struct sqlite3 **);
// sqlite3_prepare
// file /usr/include/sqlite3.h line 3324
signed int sqlite3_prepare(struct sqlite3 *, const char *, signed int, struct sqlite3_stmt **, const char **);
// sqlite3_step
// file /usr/include/sqlite3.h line 3875
signed int sqlite3_step(struct sqlite3_stmt *);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file main.c line 701
static void usage(char *appname);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// version
// file main.c line 730
static void version(void);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// yaml_document_add_mapping
// file /usr/include/yaml.h line 929
signed int yaml_document_add_mapping(struct yaml_document_s *, unsigned char *, enum yaml_mapping_style_e);
// yaml_document_add_scalar
// file /usr/include/yaml.h line 896
signed int yaml_document_add_scalar(struct yaml_document_s *, unsigned char *, unsigned char *, signed int, enum yaml_scalar_style_e);
// yaml_document_append_mapping_pair
// file /usr/include/yaml.h line 958
signed int yaml_document_append_mapping_pair(struct yaml_document_s *, signed int, signed int, signed int);
// yaml_document_delete
// file /usr/include/yaml.h line 845
void yaml_document_delete(struct yaml_document_s *);
// yaml_document_get_node
// file /usr/include/yaml.h line 860
struct yaml_node_s * yaml_document_get_node(struct yaml_document_s *, signed int);
// yaml_document_get_root_node
// file /usr/include/yaml.h line 879
struct yaml_node_s * yaml_document_get_root_node(struct yaml_document_s *);
// yaml_document_initialize
// file /usr/include/yaml.h line 832
signed int yaml_document_initialize(struct yaml_document_s *, struct yaml_version_directive_s *, struct yaml_tag_directive_s *, struct yaml_tag_directive_s *, signed int, signed int);
// yaml_emitter_dump
// file /usr/include/yaml.h line 1951
signed int yaml_emitter_dump(struct yaml_emitter_s *, struct yaml_document_s *);
// yaml_emitter_initialize
// file /usr/include/yaml.h line 1776
signed int yaml_emitter_initialize(struct yaml_emitter_s *);
// yaml_emitter_set_output
// file /usr/include/yaml.h line 1829
void yaml_emitter_set_output(struct yaml_emitter_s *, signed int (*)(void *, unsigned char *, unsigned long int), void *);
// yaml_parser_delete
// file /usr/include/yaml.h line 1326
void yaml_parser_delete(struct yaml_parser_s *);
// yaml_parser_initialize
// file /usr/include/yaml.h line 1317
signed int yaml_parser_initialize(struct yaml_parser_s *);
// yaml_parser_load
// file /usr/include/yaml.h line 1451
signed int yaml_parser_load(struct yaml_parser_s *, struct yaml_document_s *);
// yaml_parser_set_input_string
// file /usr/include/yaml.h line 1341
void yaml_parser_set_input_string(struct yaml_parser_s *, const unsigned char *, unsigned long int);

struct anonymous_53
{
  // start
  enum yaml_emitter_state_e *start;
  // end
  enum yaml_emitter_state_e *end;
  // top
  enum yaml_emitter_state_e *top;
};

struct anonymous_61
{
  // start
  enum yaml_parser_state_e *start;
  // end
  enum yaml_parser_state_e *end;
  // top
  enum yaml_parser_state_e *top;
};

struct anonymous_37
{
  // set
  signed int (*set)(void *, struct PropertyValue_s *);
  // get
  signed int (*get)(void *, struct PropertyValue_s *);
};

struct anonymous_33
{
  // start
  signed int *start;
  // end
  signed int *end;
  // top
  signed int *top;
};

struct anonymous_2
{
  // multiplex
  struct Multiplex_s *multiplex;
  // networkId
  signed int networkId;
};

struct anonymous_1
{
  // multiplex
  struct Multiplex_s *multiplex;
  // tsId
  signed int tsId;
};

struct anonymous_12
{
  // service
  struct Service_t *service;
};

struct anonymous_10
{
  // service
  struct Service_t *service;
  // defaultAuthority
  char *defaultAuthority;
};

struct anonymous_5
{
  // service
  struct Service_t *service;
  // name
  char *name;
};

struct anonymous_9
{
  // service
  struct Service_t *service;
  // provider
  char *provider;
};

struct anonymous_4
{
  // service
  struct Service_t *service;
  // info
  struct ProgramInfo_s *info;
};

struct anonymous_7
{
  // service
  struct Service_t *service;
  // ca
  _Bool ca;
};

struct anonymous_8
{
  // service
  struct Service_t *service;
  // type
  enum anonymous type;
};

struct anonymous_3
{
  // service
  struct Service_t *service;
  // pmtPid
  signed int pmtPid;
};

struct anonymous_6
{
  // service
  struct Service_t *service;
  // source
  unsigned short int source;
};

struct anonymous_63
{
  // start
  struct yaml_alias_data_s *start;
  // end
  struct yaml_alias_data_s *end;
  // top
  struct yaml_alias_data_s *top;
};

struct anonymous_54
{
  // start
  struct yaml_event_s *start;
  // end
  struct yaml_event_s *end;
  // head
  struct yaml_event_s *head;
  // tail
  struct yaml_event_s *tail;
};

struct anonymous_62
{
  // start
  struct yaml_mark_s *start;
  // end
  struct yaml_mark_s *end;
  // top
  struct yaml_mark_s *top;
};

struct anonymous_34
{
  // start
  struct yaml_node_pair_s *start;
  // end
  struct yaml_node_pair_s *end;
  // top
  struct yaml_node_pair_s *top;
};

struct anonymous_16
{
  // start
  struct yaml_node_s *start;
  // end
  struct yaml_node_s *end;
  // top
  struct yaml_node_s *top;
};

struct anonymous_60
{
  // start
  struct yaml_simple_key_s *start;
  // end
  struct yaml_simple_key_s *end;
  // top
  struct yaml_simple_key_s *top;
};

struct anonymous_17
{
  // start
  struct yaml_tag_directive_s *start;
  // end
  struct yaml_tag_directive_s *end;
};

struct anonymous_55
{
  // start
  struct yaml_tag_directive_s *start;
  // end
  struct yaml_tag_directive_s *end;
  // top
  struct yaml_tag_directive_s *top;
};

struct anonymous_51
{
  // start
  struct yaml_token_s *start;
  // end
  struct yaml_token_s *end;
  // head
  struct yaml_token_s *head;
  // tail
  struct yaml_token_s *tail;
};

struct anonymous_44
{
  // version_directive
  struct yaml_version_directive_s *version_directive;
  // tag_directives
  struct anonymous_17 tag_directives;
  // implicit
  signed int implicit;
};

struct anonymous_39
{
  // anchor
  unsigned char *anchor;
};

struct anonymous_40
{
  // anchor
  unsigned char *anchor;
  // tag
  unsigned char *tag;
  // value
  unsigned char *value;
  // length
  unsigned long int length;
  // plain_implicit
  signed int plain_implicit;
  // quoted_implicit
  signed int quoted_implicit;
  // style
  enum yaml_scalar_style_e style;
};

struct anonymous_42
{
  // anchor
  unsigned char *anchor;
  // tag
  unsigned char *tag;
  // implicit
  signed int implicit;
  // style
  enum yaml_mapping_style_e style;
};

struct anonymous_41
{
  // anchor
  unsigned char *anchor;
  // tag
  unsigned char *tag;
  // implicit
  signed int implicit;
  // style
  enum yaml_sequence_style_e style;
};

struct anonymous_56
{
  // anchor
  unsigned char *anchor;
  // anchor_length
  unsigned long int anchor_length;
  // alias
  signed int alias;
};

struct anonymous_64
{
  // buffer
  unsigned char *buffer;
  // size
  unsigned long int size;
  // size_written
  unsigned long int *size_written;
};

struct anonymous_68
{
  // handle
  unsigned char *handle;
  // prefix
  unsigned char *prefix;
};

struct anonymous_66
{
  // handle
  unsigned char *handle;
  // suffix
  unsigned char *suffix;
};

struct anonymous_57
{
  // handle
  unsigned char *handle;
  // handle_length
  unsigned long int handle_length;
  // suffix
  unsigned char *suffix;
  // suffix_length
  unsigned long int suffix_length;
};

struct anonymous_49
{
  // start
  unsigned char *start;
  // end
  unsigned char *end;
  // pointer
  unsigned char *pointer;
  // last
  unsigned char *last;
};

struct anonymous_65
{
  // value
  unsigned char *value;
};

struct anonymous_22
{
  // value
  unsigned char *value;
  // length
  unsigned long int length;
  // style
  enum yaml_scalar_style_e style;
};

struct anonymous_58
{
  // value
  unsigned char *value;
  // length
  unsigned long int length;
  // multiline
  signed int multiline;
  // flow_plain_allowed
  signed int flow_plain_allowed;
  // block_plain_allowed
  signed int block_plain_allowed;
  // single_quoted_allowed
  signed int single_quoted_allowed;
  // block_allowed
  signed int block_allowed;
  // style
  enum yaml_scalar_style_e style;
};

struct anonymous_47
{
  // start
  const unsigned char *start;
  // end
  const unsigned char *end;
  // current
  const unsigned char *current;
};

struct anonymous_29
{
  // data
  unsigned char data[32l];
  // len
  unsigned int len;
  // reserved1
  unsigned int reserved1[3l];
  // reserved2
  void *reserved2;
};

struct anonymous_43
{
  // encoding
  enum yaml_encoding_e encoding;
};

struct anonymous_26
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_11
{
  // id
  signed int id;
  // source
  signed int source;
  // multiplexUID
  signed int multiplexUID;
  // name
  char *name;
};

struct anonymous_45
{
  // implicit
  signed int implicit;
};

struct anonymous_67
{
  // major
  signed int major;
  // minor
  signed int minor;
};

struct anonymous_59
{
  // references
  signed int references;
  // anchor
  signed int anchor;
  // serialized
  signed int serialized;
};

struct anonymous_23
{
  // items
  struct anonymous_33 items;
  // style
  enum yaml_sequence_style_e style;
};

struct anonymous_24
{
  // pairs
  struct anonymous_34 pairs;
  // style
  enum yaml_mapping_style_e style;
};

union anonymous_25
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_38
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_15
{
  // integer
  signed int integer;
  // fp
  double fp;
  // boolean
  _Bool boolean;
  // string
  char *string;
  // ch
  char ch;
  // pid
  unsigned short int pid;
};

union anonymous_36
{
  // simple
  struct anonymous_37 simple;
};

union anonymous_13
{
  // multiplexTSId
  struct anonymous_1 multiplexTSId;
  // multiplexNetworkId
  struct anonymous_2 multiplexNetworkId;
  // servicePMTPID
  struct anonymous_3 servicePMTPID;
  // servicePIDs
  struct anonymous_4 servicePIDs;
  // serviceName
  struct anonymous_5 serviceName;
  // serviceSource
  struct anonymous_6 serviceSource;
  // serviceCA
  struct anonymous_7 serviceCA;
  // serviceType
  struct anonymous_8 serviceType;
  // serviceProvider
  struct anonymous_9 serviceProvider;
  // serviceDefaultAuthority
  struct anonymous_10 serviceDefaultAuthority;
  // serviceAdd
  struct anonymous_11 serviceAdd;
  // serviceDelete
  struct anonymous_12 serviceDelete;
};

union anonymous_52
{
  // string
  struct anonymous_64 string;
  // file
  struct _IO_FILE *file;
};

union anonymous_18
{
  // scalar
  struct anonymous_22 scalar;
  // sequence
  struct anonymous_23 sequence;
  // mapping
  struct anonymous_24 mapping;
};

union anonymous_48
{
  // string
  struct anonymous_47 string;
  // file
  struct _IO_FILE *file;
};

union anonymous_46
{
  // stream_start
  struct anonymous_43 stream_start;
  // document_start
  struct anonymous_44 document_start;
  // document_end
  struct anonymous_45 document_end;
  // alias
  struct anonymous_39 alias;
  // scalar
  struct anonymous_40 scalar;
  // sequence_start
  struct anonymous_41 sequence_start;
  // mapping_start
  struct anonymous_42 mapping_start;
};

union anonymous_50
{
  // stream_start
  struct anonymous_43 stream_start;
  // alias
  struct anonymous_65 alias;
  // anchor
  struct anonymous_65 anchor;
  // tag
  struct anonymous_66 tag;
  // scalar
  struct anonymous_22 scalar;
  // version_directive
  struct anonymous_67 version_directive;
  // tag_directive
  struct anonymous_68 tag_directive;
};

union anonymous_21
{
  // __data
  struct anonymous_26 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct EPGEvent_s
{
  // startTime
  struct tm startTime;
  // endTime
  struct tm endTime;
  // ca
  _Bool ca;
};

struct EPGEventDetail_s
{
  // lang
  char lang[4l];
  // name
  char *name;
  // value
  char *value;
};

struct EPGEventRating_s
{
  // system
  char *system;
  // rating
  char *rating;
};

union anonymous_20
{
  // event
  struct EPGEvent_s event;
  // detail
  struct EPGEventDetail_s detail;
  // rating
  struct EPGEventRating_s rating;
};

struct PluginEventListenerDetails_s
{
  // name
  char *name;
  // callback
  void (*callback)(void *, struct Event_s *, void *);
  // arg
  void *arg;
};

struct DeliveryMethodHandler_t
{
  // CanHandle
  _Bool (*CanHandle)(char *);
  // CreateInstance
  struct DeliveryMethodInstance_t * (*CreateInstance)(char *);
};

union anonymous_31
{
  // eventDetails
  struct PluginEventListenerDetails_s eventDetails;
  // dmHandler
  struct DeliveryMethodHandler_t dmHandler;
  // patCB
  void (*patCB)(struct dvbpsi_pmt_s *);
  // pmtCB
  void (*pmtCB)(struct dvbpsi_pmt_s *);
  // sdtCB
  void (*sdtCB)(struct dvbpsi_sdt_s *);
  // nitCB
  void (*nitCB)(struct dvbpsi_nit_s *);
  // tdtCB
  void (*tdtCB)(struct dvbpsi_tdt_tot_s *);
  // mgtCB
  void (*mgtCB)(struct dvbpsi_atsc_mgt_s *);
  // sttCB
  void (*sttCB)(struct dvbpsi_atsc_stt_s *);
  // vctCB
  void (*vctCB)(struct dvbpsi_atsc_vct_s *);
  // channelChangeCB
  void (*channelChangeCB)(struct Multiplex_s *, struct Service_t *);
  // installCB
  void (*installCB)(_Bool);
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_14
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct dvb_qpsk_parameters
{
  // symbol_rate
  unsigned int symbol_rate;
  // fec_inner
  enum fe_code_rate fec_inner;
};

struct dvb_qam_parameters
{
  // symbol_rate
  unsigned int symbol_rate;
  // fec_inner
  enum fe_code_rate fec_inner;
  // modulation
  enum fe_modulation modulation;
};

struct dvb_ofdm_parameters
{
  // bandwidth
  enum fe_bandwidth bandwidth;
  // code_rate_HP
  enum fe_code_rate code_rate_HP;
  // code_rate_LP
  enum fe_code_rate code_rate_LP;
  // constellation
  enum fe_modulation constellation;
  // transmission_mode
  enum fe_transmit_mode transmission_mode;
  // guard_interval
  enum fe_guard_interval guard_interval;
  // hierarchy_information
  enum fe_hierarchy hierarchy_information;
};

struct dvb_vsb_parameters
{
  // modulation
  enum fe_modulation modulation;
};

union anonymous_32
{
  // qpsk
  struct dvb_qpsk_parameters qpsk;
  // qam
  struct dvb_qam_parameters qam;
  // ofdm
  struct dvb_ofdm_parameters ofdm;
  // vsb
  struct dvb_vsb_parameters vsb;
};

union anonymous_28
{
  // uvalue
  unsigned long long int uvalue;
  // svalue
  signed long long int svalue;
};

struct dtv_stats
{
  // scale
  unsigned char scale;
  // _anon0
  union anonymous_28 _anon0;
} __attribute__ ((__packed__));

struct dtv_fe_stats
{
  // len
  unsigned char len;
  // stat
  struct dtv_stats stat[4l];
} __attribute__ ((__packed__));

union anonymous_30
{
  // data
  unsigned int data;
  // st
  struct dtv_fe_stats st;
  // buffer
  struct anonymous_29 buffer;
};

union anonymous_35
{
  // nrofEntries
  unsigned int nrofEntries;
  // __forceAlignment
  void *__forceAlignment;
};

union anonymous_27
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_0
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ATSCMultipleStrings_s
{
  // number_of_strings
  signed int number_of_strings;
  // strings
  struct ATSCString_s *strings;
};

struct ATSCString_s
{
  // lang
  char lang[3l];
  // text
  char *text;
};

struct CacheUpdateMessage_s
{
  // type
  enum CacheUpdateType type;
  // details
  union anonymous_13 details;
};

struct Class_s
{
  // name
  char *name;
  // type
  enum ClassType_e type;
  // size
  unsigned int size;
  // destructor
  void (*destructor)(void *);
  // allocatedCount
  unsigned int allocatedCount;
  // next
  struct Class_s *next;
};

struct CommandContext_t
{
  // interface
  char *interface;
  // remote
  _Bool remote;
  // infp
  struct _IO_FILE *infp;
  // outfp
  struct _IO_FILE *outfp;
  // privateArg
  void *privateArg;
  // commands
  struct Command_t *commands;
  // authenticated
  _Bool authenticated;
  // errorNumber
  unsigned short int errorNumber;
  // errorMessage
  char errorMessage[256l];
};

struct Command_t
{
  // command
  char *command;
  // minArgs
  signed int minArgs;
  // maxArgs
  signed int maxArgs;
  // shortHelp
  char *shortHelp;
  // longHelp
  char *longHelp;
  // commandfunc
  void (*commandfunc)(signed int, char **);
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct Connection_t
{
  // socketfd
  signed int socketfd;
  // fp
  struct _IO_FILE *fp;
  // clientAddress
  struct sockaddr_storage clientAddress;
  // connected
  _Bool connected;
  // thread
  unsigned long int thread;
};

struct DVBAdapterPIDFilter_s
{
  // demuxFd
  signed int demuxFd;
  // pid
  unsigned short int pid;
};

struct dvb_frontend_info
{
  // name
  char name[128l];
  // type
  enum fe_type type;
  // frequency_min
  unsigned int frequency_min;
  // frequency_max
  unsigned int frequency_max;
  // frequency_stepsize
  unsigned int frequency_stepsize;
  // frequency_tolerance
  unsigned int frequency_tolerance;
  // symbol_rate_min
  unsigned int symbol_rate_min;
  // symbol_rate_max
  unsigned int symbol_rate_max;
  // symbol_rate_tolerance
  unsigned int symbol_rate_tolerance;
  // notifier_delay
  unsigned int notifier_delay;
  // caps
  enum fe_caps caps;
};

struct dtv_property
{
  // cmd
  unsigned int cmd;
  // reserved
  unsigned int reserved[3l];
  // u
  union anonymous_30 u;
  // result
  signed int result;
} __attribute__ ((__packed__));

struct dtv_properties
{
  // num
  unsigned int num;
  // props
  struct dtv_property *props;
};

struct DVBSatelliteSettings_s
{
  // polarisation
  enum Polarisation_e polarisation;
  // satellite_number
  unsigned int satellite_number;
};

struct LNBInfo_s
{
  // name
  char *name;
  // desc
  char **desc;
  // lowFrequency
  unsigned long int lowFrequency;
  // highFrequency
  unsigned long int highFrequency;
  // switchFrequency
  unsigned long int switchFrequency;
};

struct ev_io
{
  // active
  signed int active;
  // pending
  signed int pending;
  // priority
  signed int priority;
  // data
  void *data;
  // cb
  void (*cb)(struct ev_loop *, struct ev_io *, signed int);
  // next
  struct ev_watcher_list *next;
  // fd
  signed int fd;
  // events
  signed int events;
};

struct dvb_frontend_parameters
{
  // frequency
  unsigned int frequency;
  // inversion
  enum fe_spectral_inversion inversion;
  // u
  union anonymous_32 u;
};

struct DVBAdapter_s
{
  // adapter
  signed int adapter;
  // info
  struct dvb_frontend_info info;
  // supportedDelSystems
  struct DVBSupportedDeliverySys_s *supportedDelSystems;
  // frontEndPath
  char frontEndPath[30l];
  // frontEndFd
  signed int frontEndFd;
  // frontEndLocked
  _Bool frontEndLocked;
  // tuning
  _Bool tuning;
  // currentDeliverySystem
  enum DVBDeliverySystem_e currentDeliverySystem;
  // frontEndRequestedFreq
  unsigned int frontEndRequestedFreq;
  // frontEndPropertyArray
  struct dtv_property frontEndPropertyArray[64l];
  // frontEndProperties
  struct dtv_properties frontEndProperties;
  // satelliteSettings
  struct DVBSatelliteSettings_s satelliteSettings;
  // lnbInfo
  struct LNBInfo_s lnbInfo;
  // lnbSharing
  _Bool lnbSharing;
  // demuxPath
  char demuxPath[30l];
  // hardwareRestricted
  _Bool hardwareRestricted;
  // maxFilters
  signed int maxFilters;
  // filters
  struct DVBAdapterPIDFilter_s filters[256l];
  // dvrPath
  char dvrPath[30l];
  // dvrFd
  signed int dvrFd;
  // cmdRecvFd
  signed int cmdRecvFd;
  // cmdSendFd
  signed int cmdSendFd;
  // commandWatcher
  struct ev_io commandWatcher;
  // frontendWatcher
  struct ev_io frontendWatcher;
  // forcedISDB
  _Bool forcedISDB;
  // isdbFEParams
  struct dvb_frontend_parameters isdbFEParams;
};

struct DVBSupportedDeliverySys_s
{
  // nrofSystems
  signed int nrofSystems;
  // systems
  enum DVBDeliverySystem_e systems[0l];
};

struct DeferredJob_s
{
  // processor
  void (*processor)(void *);
  // arg
  void *arg;
};

struct DeliveryMethodInstanceOps_t
{
  // OutputPacket
  void (*OutputPacket)(struct DeliveryMethodInstance_t *, struct TSPacket_t *);
  // OutputBlock
  void (*OutputBlock)(struct DeliveryMethodInstance_t *, void *, unsigned long int);
  // DestroyInstance
  void (*DestroyInstance)(struct DeliveryMethodInstance_t *);
  // ReserveHeaderSpace
  void (*ReserveHeaderSpace)(struct DeliveryMethodInstance_t *, signed int);
  // SetHeader
  void (*SetHeader)(struct DeliveryMethodInstance_t *, struct TSPacket_t *, signed int);
};

struct DeliveryMethodInstance_t
{
  // mrl
  char *mrl;
  // ops
  struct DeliveryMethodInstanceOps_t *ops;
  // private
  void *private;
};

struct EPGServiceRef_s
{
  // netId
  unsigned int netId;
  // tsId
  unsigned int tsId;
  // serviceId
  unsigned int serviceId;
};

struct EPGEventRef_s
{
  // serviceRef
  struct EPGServiceRef_s serviceRef;
  // eventId
  unsigned int eventId;
};

struct EPGChannelMessage_s
{
  // type
  enum anonymous_19 type;
  // eventRef
  struct EPGEventRef_s eventRef;
  // data
  union anonymous_20 data;
};

struct EventListenerDetails_s
{
  // callback
  void (*callback)(void *, struct Event_s *, void *);
  // arg
  void *arg;
};

struct EventSource_s
{
  // name
  char *name;
  // events
  struct List_s *events;
  // listeners
  struct List_s *listeners;
};

struct Event_s
{
  // source
  struct EventSource_s *source;
  // name
  char *name;
  // listeners
  struct List_s *listeners;
  // toString
  signed int (*toString)(struct yaml_document_s *, struct Event_s *, void *);
};

struct ListEntry_s
{
  // data
  void *data;
  // next
  struct ListEntry_s *next;
  // prev
  struct ListEntry_s *prev;
};

struct ListIterator_s
{
  // list
  struct List_s *list;
  // current
  struct ListEntry_s *current;
};

struct List_s
{
  // count
  signed int count;
  // head
  struct ListEntry_s *head;
  // tail
  struct ListEntry_s *tail;
};

struct MessageQ_s
{
  // mutex
  union anonymous_14 mutex;
  // availableCond
  union anonymous_21 availableCond;
  // quit
  _Bool quit;
  // messages
  struct List_s *messages;
};

struct ModuleLevel_s
{
  // module
  char *module;
  // level
  signed int level;
  // next
  struct ModuleLevel_s *next;
};

struct Multiplex_s
{
  // uid
  signed int uid;
  // tsId
  signed int tsId;
  // networkId
  signed int networkId;
  // patVersion
  signed int patVersion;
  // deliverySystem
  enum DVBDeliverySystem_e deliverySystem;
  // tuningParams
  char *tuningParams;
};

struct MultiplexList_s
{
  // nrofMultiplexes
  signed int nrofMultiplexes;
  // multiplexes
  struct Multiplex_s *multiplexes[0l];
};

struct MuxFrequency_s
{
  // frequency
  unsigned int frequency;
  // polarisation
  char polarisation[11l];
  // satNumber
  signed int satNumber;
};

struct MuxFrequencies_s
{
  // nrofFrequencies
  signed int nrofFrequencies;
  // frequencies
  struct MuxFrequency_s frequencies[0l];
};

struct NITProcessor_s
{
  // tsgroup
  struct TSFilterGroup_t *tsgroup;
  // demux
  struct dvbpsi_decoder_s *demux;
};

struct ObjectCollection_s
{
  // _anon0
  union anonymous_35 _anon0;
};

struct Object_s
{
  // clazz
  struct Class_s *clazz;
  // refCount
  signed int refCount;
  // size
  unsigned int size;
  // next
  struct Object_s *next;
};

struct PATProcessor_s
{
  // tsgroup
  struct TSFilterGroup_t *tsgroup;
  // multiplex
  struct Multiplex_s *multiplex;
  // pathandle
  struct dvbpsi_decoder_s *pathandle;
};

struct Service_t
{
  // name
  char *name;
  // multiplexUID
  signed int multiplexUID;
  // networkId
  signed int networkId;
  // tsId
  signed int tsId;
  // id
  signed int id;
  // source
  signed int source;
  // conditionalAccess
  _Bool conditionalAccess;
  // type
  enum anonymous type;
  // pmtPID
  signed int pmtPID;
  // provider
  char *provider;
  // defaultAuthority
  char *defaultAuthority;
};

struct dvbpsi_decoder_s
{
  // pf_callback
  void (*pf_callback)(struct dvbpsi_decoder_s *, struct dvbpsi_psi_section_s *);
  // p_private_decoder
  void *p_private_decoder;
  // i_section_max_size
  signed int i_section_max_size;
  // i_continuity_counter
  unsigned char i_continuity_counter;
  // b_discontinuity
  signed int b_discontinuity;
  // p_free_sections
  struct dvbpsi_psi_section_s *p_free_sections;
  // p_current_section
  struct dvbpsi_psi_section_s *p_current_section;
  // i_need
  signed int i_need;
  // b_complete_header
  signed int b_complete_header;
};

struct PMTProcessor_s
{
  // tsgroup
  struct TSFilterGroup_t *tsgroup;
  // services
  struct Service_t *services[256l];
  // pmtpids
  unsigned short int pmtpids[256l];
  // pmthandles
  struct dvbpsi_decoder_s *pmthandles[256l];
};

struct PMTReceived_t
{
  // id
  unsigned short int id;
  // pid
  unsigned short int pid;
  // received
  _Bool received;
};

struct PSIPProcessor_s
{
  // tsgroup
  struct TSFilterGroup_t *tsgroup;
  // demux
  struct dvbpsi_decoder_s *demux;
};

struct PluginEntry_t
{
  // handle
  struct lt__handle *handle;
  // pluginInterface
  struct Plugin_t *pluginInterface;
};

struct PluginFeatureInfo_t
{
  // feature
  signed int feature;
  // name
  char *name;
};

struct PluginFeature_t
{
  // type
  signed int type;
  // details
  union anonymous_31 details;
};

struct Plugin_t
{
  // requiredVersion
  unsigned int requiredVersion;
  // pluginFor
  unsigned int pluginFor;
  // name
  char *name;
  // version
  char *version;
  // description
  char *description;
  // author
  char *author;
  // commands
  struct Command_t *commands;
  // features
  struct PluginFeature_t *features;
};

struct ProgramInfo_s
{
  // descriptors
  struct dvbpsi_descriptor_s *descriptors;
  // pcrPID
  signed int pcrPID;
  // streamInfoList
  struct StreamInfoList_t *streamInfoList;
};

struct PropertyInfo_s
{
  // name
  char *name;
  // desc
  char *desc;
  // type
  enum PropertyType_e type;
  // readable
  _Bool readable;
  // writeable
  _Bool writeable;
  // hasChildren
  _Bool hasChildren;
};

struct PropertyNode_s
{
  // parent
  struct PropertyNode_s *parent;
  // next
  struct PropertyNode_s *next;
  // name
  const char *name;
  // desc
  const char *desc;
  // type
  enum PropertyType_e type;
  // userArg
  void *userArg;
  // accessors
  union anonymous_36 accessors;
  // childNodes
  struct PropertyNode_s *childNodes;
};

struct PropertyPathElements_s
{
  // nrofElements
  signed int nrofElements;
  // elements
  char *elements[256l];
};

struct PropertyValue_s
{
  // type
  enum PropertyType_e type;
  // u
  union anonymous_15 u;
};

struct SDTProcessor_s
{
  // tsgroup
  struct TSFilterGroup_t *tsgroup;
  // demux
  struct dvbpsi_decoder_s *demux;
};

struct ScanEntry_s
{
  // system
  enum DVBDeliverySystem_e system;
  // mux
  struct Multiplex_s *mux;
  // params
  struct TuningParamDocs_s *params;
  // next
  struct ScanEntry_s *next;
};

struct ScanList_s
{
  // start
  struct ScanEntry_s *start;
  // end
  struct ScanEntry_s *end;
  // current
  struct ScanEntry_s *current;
  // count
  signed int count;
  // pos
  signed int pos;
};

struct TSPacket_t
{
  // header
  unsigned char header[4l];
  // payload
  unsigned char payload[184l];
};

struct ServiceFilter_s
{
  // name
  char *name;
  // tsgroup
  struct TSFilterGroup_t *tsgroup;
  // propertyPath
  char propertyPath[255l];
  // dmInstance
  struct DeliveryMethodInstance_t *dmInstance;
  // service
  struct Service_t *service;
  // multiplex
  struct Multiplex_s *multiplex;
  // patVersion
  unsigned short int patVersion;
  // patPacketCounter
  unsigned char patPacketCounter;
  // avsOnly
  _Bool avsOnly;
  // serviceVersion
  unsigned short int serviceVersion;
  // pmtVersion
  unsigned short int pmtVersion;
  // pmtPacketCounter
  unsigned char pmtPacketCounter;
  // pcrPID
  unsigned short int pcrPID;
  // videoPID
  unsigned short int videoPID;
  // audioPID
  unsigned short int audioPID;
  // subPID
  unsigned short int subPID;
  // pmtPacketCount
  signed int pmtPacketCount;
  // pmtPackets
  struct TSPacket_t pmtPackets[6l];
  // setHeader
  _Bool setHeader;
  // headerCount
  signed int headerCount;
  // headerGotPAT
  _Bool headerGotPAT;
  // headerGotPMT
  _Bool headerGotPMT;
  // packets
  struct TSPacket_t packets[7l];
};

struct ServiceList_s
{
  // nrofServices
  unsigned int nrofServices;
  // services
  struct Service_t *services[0l];
};

struct StreamInfo_t
{
  // pid
  signed int pid;
  // type
  signed int type;
  // descriptors
  struct dvbpsi_descriptor_s *descriptors;
};

struct StreamInfoList_t
{
  // nrofStreams
  signed int nrofStreams;
  // streams
  struct StreamInfo_t streams[0l];
};

struct StringOutput_s
{
  // written
  unsigned long int written;
  // currentSectionPos
  signed int currentSectionPos;
  // currentSection
  struct YUStringSection_s *currentSection;
  // sections
  struct YUStringSection_s *sections;
  // sectionsEnd
  struct YUStringSection_s *sectionsEnd;
};

struct StringToParamMapping_s
{
  // str
  char *str;
  // param
  unsigned int param;
};

struct TDTProcessor_s
{
  // tsgroup
  struct TSFilterGroup_t *tsgroup;
  // handle
  struct dvbpsi_decoder_s *handle;
};

struct TSFilterGroupStats_t
{
  // name
  char *name;
  // packetsProcessed
  unsigned long long int packetsProcessed;
  // sectionsProcessed
  unsigned long long int sectionsProcessed;
  // next
  struct TSFilterGroupStats_t *next;
};

struct TSFilterGroupTypeStats_t
{
  // type
  char *type;
  // groups
  struct TSFilterGroupStats_t *groups;
  // next
  struct TSFilterGroupTypeStats_t *next;
};

struct TSFilterGroup_t
{
  // name
  char *name;
  // type
  char *type;
  // tsReader
  struct TSReader_t *tsReader;
  // eventCallback
  void (*eventCallback)(void *, struct TSFilterGroup_t *, enum TSFilterEventType_e, void *);
  // userArg
  void *userArg;
  // sectionFilters
  struct TSSectionFilter_t *sectionFilters;
  // packetFilters
  struct TSPacketFilter_t *packetFilters;
  // packetsProcessed
  volatile unsigned long long int packetsProcessed;
  // sectionsProcessed
  volatile unsigned long long int sectionsProcessed;
};

struct TSPacketFilter_t
{
  // pid
  unsigned short int pid;
  // callback
  void (*callback)(void *, struct TSFilterGroup_t *, struct TSPacket_t *);
  // userArg
  void *userArg;
  // group
  struct TSFilterGroup_t *group;
  // next
  struct TSPacketFilter_t *next;
  // flNext
  struct TSPacketFilter_t *flNext;
};

struct TSReaderStats_t
{
  // totalPackets
  unsigned long long int totalPackets;
  // bitrate
  unsigned long int bitrate;
  // types
  struct TSFilterGroupTypeStats_t *types;
};

struct ev_timer
{
  // active
  signed int active;
  // pending
  signed int pending;
  // priority
  signed int priority;
  // data
  void *data;
  // cb
  void (*cb)(struct ev_loop *, struct ev_timer *, signed int);
  // at
  double at;
  // repeat
  double repeat;
};

struct ev_async
{
  // active
  signed int active;
  // pending
  signed int pending;
  // priority
  signed int priority;
  // data
  void *data;
  // cb
  void (*cb)(struct ev_loop *, struct ev_async *, signed int);
  // sent
  volatile signed int sent;
};

struct TSReader_t
{
  // quit
  _Bool quit;
  // adapter
  struct DVBAdapter_s *adapter;
  // enabled
  _Bool enabled;
  // mutex
  union anonymous_14 mutex;
  // multiplexChanged
  _Bool multiplexChanged;
  // multiplex
  struct Multiplex_s *multiplex;
  // tsStructureChanged
  _Bool tsStructureChanged;
  // totalPackets
  volatile unsigned long long int totalPackets;
  // bitrate
  volatile unsigned long int bitrate;
  // promiscuousMode
  _Bool promiscuousMode;
  // groups
  struct List_s *groups;
  // currentlyProcessingPid
  unsigned short int currentlyProcessingPid;
  // packetFilters
  struct TSPacketFilter_t *packetFilters[8193l];
  // sectionFilters
  struct List_s *sectionFilters;
  // activeSectionFilters
  struct List_s *activeSectionFilters;
  // dvrWatcher
  struct ev_io dvrWatcher;
  // bitrateWatcher
  struct ev_timer bitrateWatcher;
  // notificationWatcher
  struct ev_async notificationWatcher;
  // prevTotalPackets
  unsigned long long int prevTotalPackets;
  // prevTime
  double prevTime;
  // buffer
  struct TSPacket_t buffer[20l];
};

struct TSSectionFilterList_t
{
  // pid
  unsigned short int pid;
  // flags
  unsigned int flags;
  // priority
  signed int priority;
  // filters
  struct List_s *filters;
  // sectionHandle
  struct dvbpsi_decoder_s *sectionHandle;
  // packetFilter
  struct TSPacketFilter_t *packetFilter;
  // tsReader
  struct TSReader_t *tsReader;
};

struct TSSectionFilter_t
{
  // pid
  unsigned short int pid;
  // priority
  signed int priority;
  // sectionHandle
  struct dvbpsi_decoder_s *sectionHandle;
  // group
  struct TSFilterGroup_t *group;
  // next
  struct TSSectionFilter_t *next;
};

struct ThreadName_s
{
  // thread
  unsigned long int thread;
  // name
  char *name;
};

struct TransponderEntry_s
{
  // netId
  signed int netId;
  // tsId
  signed int tsId;
  // frequency
  unsigned int frequency;
  // polarisation
  char *polarisation;
  // delSys
  enum DVBDeliverySystem_e delSys;
  // tuningParams
  char *tuningParams;
  // next
  struct TransponderEntry_s *next;
};

struct TuningParamDocs_s
{
  // nrofDocs
  signed int nrofDocs;
  // docs
  char *docs[0l];
};

struct YUStringSection_s
{
  // buffer
  char buffer[256l];
  // next
  struct YUStringSection_s *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct dmx_pes_filter_params
{
  // pid
  unsigned short int pid;
  // input
  enum dmx_input input;
  // output
  enum dmx_output output;
  // pes_type
  enum dmx_ts_pes pes_type;
  // flags
  unsigned int flags;
};

struct dvb_diseqc_master_cmd
{
  // msg
  unsigned char msg[6l];
  // msg_len
  unsigned char msg_len;
};

struct dvb_frontend_event
{
  // status
  enum fe_status status;
  // parameters
  struct dvb_frontend_parameters parameters;
};

struct dvbpsi_atsc_mgt_s
{
  // i_version
  unsigned char i_version;
  // b_current_next
  signed int b_current_next;
  // i_protocol
  unsigned char i_protocol;
  // p_first_table
  struct dvbpsi_atsc_mgt_table_s *p_first_table;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_atsc_mgt_table_s
{
  // i_type
  unsigned short int i_type;
  // i_pid
  unsigned short int i_pid;
  // i_version
  unsigned char i_version;
  // i_number_bytes
  unsigned int i_number_bytes;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_atsc_mgt_table_s *p_next;
};

struct dvbpsi_atsc_stt_s
{
  // i_protocol
  unsigned char i_protocol;
  // i_system_time
  unsigned int i_system_time;
  // i_gps_utc_offset
  unsigned char i_gps_utc_offset;
  // i_daylight_savings
  unsigned short int i_daylight_savings;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_atsc_vct_channel_s
{
  // i_short_name
  unsigned char i_short_name[14l];
  // i_major_number
  unsigned short int i_major_number;
  // i_minor_number
  unsigned short int i_minor_number;
  // i_modulation
  unsigned char i_modulation;
  // i_carrier_freq
  unsigned int i_carrier_freq;
  // i_channel_tsid
  unsigned short int i_channel_tsid;
  // i_program_number
  unsigned short int i_program_number;
  // i_etm_location
  unsigned char i_etm_location;
  // b_access_controlled
  signed int b_access_controlled;
  // b_path_select
  signed int b_path_select;
  // b_out_of_band
  signed int b_out_of_band;
  // b_hidden
  signed int b_hidden;
  // b_hide_guide
  signed int b_hide_guide;
  // i_service_type
  unsigned char i_service_type;
  // i_source_id
  unsigned short int i_source_id;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_atsc_vct_channel_s *p_next;
};

struct dvbpsi_atsc_vct_s
{
  // i_version
  unsigned char i_version;
  // b_current_next
  signed int b_current_next;
  // i_ts_id
  unsigned short int i_ts_id;
  // i_protocol
  unsigned char i_protocol;
  // b_cable_vct
  signed int b_cable_vct;
  // p_first_channel
  struct dvbpsi_atsc_vct_channel_s *p_first_channel;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_default_authority_dr_s
{
  // authority
  unsigned char authority[255l];
};

struct dvbpsi_descriptor_s
{
  // i_tag
  unsigned char i_tag;
  // i_length
  unsigned char i_length;
  // p_data
  unsigned char *p_data;
  // p_next
  struct dvbpsi_descriptor_s *p_next;
  // p_decoded
  void *p_decoded;
};

struct dvbpsi_frequency_list_dr_s
{
  // i_coding_type
  unsigned char i_coding_type;
  // i_number_of_frequencies
  unsigned char i_number_of_frequencies;
  // p_center_frequencies
  unsigned int p_center_frequencies[63l];
};

struct dvbpsi_nit_s
{
  // b_actual
  signed int b_actual;
  // i_network_id
  unsigned short int i_network_id;
  // i_version
  unsigned char i_version;
  // b_current_next
  signed int b_current_next;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_first_transport
  struct dvbpsi_nit_transport_s *p_first_transport;
};

struct dvbpsi_nit_transport_s
{
  // i_ts_id
  unsigned short int i_ts_id;
  // i_original_network_id
  unsigned short int i_original_network_id;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_nit_transport_s *p_next;
};

struct dvbpsi_pat_program_s
{
  // i_number
  unsigned short int i_number;
  // i_pid
  unsigned short int i_pid;
  // p_next
  struct dvbpsi_pat_program_s *p_next;
};

struct dvbpsi_pat_s
{
  // i_ts_id
  unsigned short int i_ts_id;
  // i_version
  unsigned char i_version;
  // b_current_next
  signed int b_current_next;
  // p_first_program
  struct dvbpsi_pat_program_s *p_first_program;
};

struct dvbpsi_pmt_es_s
{
  // i_type
  unsigned char i_type;
  // i_pid
  unsigned short int i_pid;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_pmt_es_s *p_next;
};

struct dvbpsi_pmt_s
{
  // i_program_number
  unsigned short int i_program_number;
  // i_version
  unsigned char i_version;
  // b_current_next
  signed int b_current_next;
  // i_pcr_pid
  unsigned short int i_pcr_pid;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_first_es
  struct dvbpsi_pmt_es_s *p_first_es;
};

struct dvbpsi_psi_section_s
{
  // i_table_id
  unsigned char i_table_id;
  // b_syntax_indicator
  signed int b_syntax_indicator;
  // b_private_indicator
  signed int b_private_indicator;
  // i_length
  unsigned short int i_length;
  // i_extension
  unsigned short int i_extension;
  // i_version
  unsigned char i_version;
  // b_current_next
  signed int b_current_next;
  // i_number
  unsigned char i_number;
  // i_last_number
  unsigned char i_last_number;
  // p_data
  unsigned char *p_data;
  // p_payload_start
  unsigned char *p_payload_start;
  // p_payload_end
  unsigned char *p_payload_end;
  // i_crc
  unsigned int i_crc;
  // i_max_size
  unsigned int i_max_size;
  // p_next
  struct dvbpsi_psi_section_s *p_next;
};

struct dvbpsi_sat_deliv_sys_dr_s
{
  // i_frequency
  unsigned int i_frequency;
  // i_orbital_position
  unsigned short int i_orbital_position;
  // i_west_east_flag
  unsigned char i_west_east_flag;
  // i_polarization
  unsigned char i_polarization;
  // i_roll_off
  unsigned char i_roll_off;
  // i_modulation_system
  unsigned char i_modulation_system;
  // i_modulation_type
  unsigned char i_modulation_type;
  // i_symbol_rate
  unsigned int i_symbol_rate;
  // i_fec_inner
  unsigned char i_fec_inner;
};

struct dvbpsi_sdt_s
{
  // i_ts_id
  unsigned short int i_ts_id;
  // i_version
  unsigned char i_version;
  // b_current_next
  signed int b_current_next;
  // i_network_id
  unsigned short int i_network_id;
  // p_first_service
  struct dvbpsi_sdt_service_s *p_first_service;
};

struct dvbpsi_sdt_service_s
{
  // i_service_id
  unsigned short int i_service_id;
  // b_eit_schedule
  signed int b_eit_schedule;
  // b_eit_present
  signed int b_eit_present;
  // i_running_status
  unsigned char i_running_status;
  // b_free_ca
  signed int b_free_ca;
  // i_descriptors_length
  unsigned short int i_descriptors_length;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
  // p_next
  struct dvbpsi_sdt_service_s *p_next;
};

struct dvbpsi_service_dr_s
{
  // i_service_type
  unsigned char i_service_type;
  // i_service_provider_name_length
  unsigned char i_service_provider_name_length;
  // i_service_provider_name
  unsigned char i_service_provider_name[252l];
  // i_service_name_length
  unsigned char i_service_name_length;
  // i_service_name
  unsigned char i_service_name[252l];
};

struct dvbpsi_tdt_tot_s
{
  // t_date_time
  struct tm t_date_time;
  // p_first_descriptor
  struct dvbpsi_descriptor_s *p_first_descriptor;
};

struct dvbpsi_terr_deliv_sys_dr_s
{
  // i_centre_frequency
  unsigned int i_centre_frequency;
  // i_bandwidth
  unsigned char i_bandwidth;
  // i_priority
  unsigned char i_priority;
  // i_time_slice_indicator
  unsigned char i_time_slice_indicator;
  // i_mpe_fec_indicator
  unsigned char i_mpe_fec_indicator;
  // i_constellation
  unsigned char i_constellation;
  // i_hierarchy_information
  unsigned char i_hierarchy_information;
  // i_code_rate_hp_stream
  unsigned char i_code_rate_hp_stream;
  // i_code_rate_lp_stream
  unsigned char i_code_rate_lp_stream;
  // i_guard_interval
  unsigned char i_guard_interval;
  // i_transmission_mode
  unsigned char i_transmission_mode;
  // i_other_frequency_flag
  unsigned char i_other_frequency_flag;
};

struct ev_watcher
{
  // active
  signed int active;
  // pending
  signed int pending;
  // priority
  signed int priority;
  // data
  void *data;
  // cb
  void (*cb)(struct ev_loop *, struct ev_watcher *, signed int);
};

struct ev_watcher_list
{
  // active
  signed int active;
  // pending
  signed int pending;
  // priority
  signed int priority;
  // data
  void *data;
  // cb
  void (*cb)(struct ev_loop *, struct ev_watcher_list *, signed int);
  // next
  struct ev_watcher_list *next;
};

struct ev_watcher_time
{
  // active
  signed int active;
  // pending
  signed int pending;
  // priority
  signed int priority;
  // data
  void *data;
  // cb
  void (*cb)(struct ev_loop *, struct ev_watcher_time *, signed int);
  // at
  double at;
};

struct in6_addr
{
  // __in6_u
  union anonymous_25 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct yaml_mark_s
{
  // index
  unsigned long int index;
  // line
  unsigned long int line;
  // column
  unsigned long int column;
};

struct yaml_alias_data_s
{
  // anchor
  unsigned char *anchor;
  // index
  signed int index;
  // mark
  struct yaml_mark_s mark;
};

struct yaml_document_s
{
  // nodes
  struct anonymous_16 nodes;
  // version_directive
  struct yaml_version_directive_s *version_directive;
  // tag_directives
  struct anonymous_17 tag_directives;
  // start_implicit
  signed int start_implicit;
  // end_implicit
  signed int end_implicit;
  // start_mark
  struct yaml_mark_s start_mark;
  // end_mark
  struct yaml_mark_s end_mark;
};

struct yaml_emitter_s
{
  // error
  enum yaml_error_type_e error;
  // problem
  const char *problem;
  // write_handler
  signed int (*write_handler)(void *, unsigned char *, unsigned long int);
  // write_handler_data
  void *write_handler_data;
  // output
  union anonymous_52 output;
  // buffer
  struct anonymous_49 buffer;
  // raw_buffer
  struct anonymous_49 raw_buffer;
  // encoding
  enum yaml_encoding_e encoding;
  // canonical
  signed int canonical;
  // best_indent
  signed int best_indent;
  // best_width
  signed int best_width;
  // unicode
  signed int unicode;
  // line_break
  enum yaml_break_e line_break;
  // states
  struct anonymous_53 states;
  // state
  enum yaml_emitter_state_e state;
  // events
  struct anonymous_54 events;
  // indents
  struct anonymous_33 indents;
  // tag_directives
  struct anonymous_55 tag_directives;
  // indent
  signed int indent;
  // flow_level
  signed int flow_level;
  // root_context
  signed int root_context;
  // sequence_context
  signed int sequence_context;
  // mapping_context
  signed int mapping_context;
  // simple_key_context
  signed int simple_key_context;
  // line
  signed int line;
  // column
  signed int column;
  // whitespace
  signed int whitespace;
  // indention
  signed int indention;
  // open_ended
  signed int open_ended;
  // anchor_data
  struct anonymous_56 anchor_data;
  // tag_data
  struct anonymous_57 tag_data;
  // scalar_data
  struct anonymous_58 scalar_data;
  // opened
  signed int opened;
  // closed
  signed int closed;
  // anchors
  struct anonymous_59 *anchors;
  // last_anchor_id
  signed int last_anchor_id;
  // document
  struct yaml_document_s *document;
};

struct yaml_event_s
{
  // type
  enum yaml_event_type_e type;
  // data
  union anonymous_46 data;
  // start_mark
  struct yaml_mark_s start_mark;
  // end_mark
  struct yaml_mark_s end_mark;
};

struct yaml_node_pair_s
{
  // key
  signed int key;
  // value
  signed int value;
};

struct yaml_node_s
{
  // type
  enum yaml_node_type_e type;
  // tag
  unsigned char *tag;
  // data
  union anonymous_18 data;
  // start_mark
  struct yaml_mark_s start_mark;
  // end_mark
  struct yaml_mark_s end_mark;
};

struct yaml_parser_s
{
  // error
  enum yaml_error_type_e error;
  // problem
  const char *problem;
  // problem_offset
  unsigned long int problem_offset;
  // problem_value
  signed int problem_value;
  // problem_mark
  struct yaml_mark_s problem_mark;
  // context
  const char *context;
  // context_mark
  struct yaml_mark_s context_mark;
  // read_handler
  signed int (*read_handler)(void *, unsigned char *, unsigned long int, unsigned long int *);
  // read_handler_data
  void *read_handler_data;
  // input
  union anonymous_48 input;
  // eof
  signed int eof;
  // buffer
  struct anonymous_49 buffer;
  // unread
  unsigned long int unread;
  // raw_buffer
  struct anonymous_49 raw_buffer;
  // encoding
  enum yaml_encoding_e encoding;
  // offset
  unsigned long int offset;
  // mark
  struct yaml_mark_s mark;
  // stream_start_produced
  signed int stream_start_produced;
  // stream_end_produced
  signed int stream_end_produced;
  // flow_level
  signed int flow_level;
  // tokens
  struct anonymous_51 tokens;
  // tokens_parsed
  unsigned long int tokens_parsed;
  // token_available
  signed int token_available;
  // indents
  struct anonymous_33 indents;
  // indent
  signed int indent;
  // simple_key_allowed
  signed int simple_key_allowed;
  // simple_keys
  struct anonymous_60 simple_keys;
  // states
  struct anonymous_61 states;
  // state
  enum yaml_parser_state_e state;
  // marks
  struct anonymous_62 marks;
  // tag_directives
  struct anonymous_55 tag_directives;
  // aliases
  struct anonymous_63 aliases;
  // document
  struct yaml_document_s *document;
};

struct yaml_simple_key_s
{
  // possible
  signed int possible;
  // required
  signed int required;
  // token_number
  unsigned long int token_number;
  // mark
  struct yaml_mark_s mark;
};

struct yaml_tag_directive_s
{
  // handle
  unsigned char *handle;
  // prefix
  unsigned char *prefix;
};

struct yaml_token_s
{
  // type
  enum yaml_token_type_e type;
  // data
  union anonymous_50 data;
  // start_mark
  struct yaml_mark_s start_mark;
  // end_mark
  struct yaml_mark_s end_mark;
};

struct yaml_version_directive_s
{
  // major
  signed int major;
  // minor
  signed int minor;
};


// ATSCEventSource
// file standard/atsc/atsc.c line 38
struct EventSource_s *ATSCEventSource = (struct EventSource_s *)(void *)0;
// ATSCFilterType
// file standard/atsc/atsc.c line 39
char ATSCFilterType[5l] = { 'A', 'T', 'S', 'C', 0 };
// ATSCScanCable
// file commands/cmd_scanning.c line 288
static _Bool ATSCScanCable = (_Bool)1;
// ATSCScanOTA
// file commands/cmd_scanning.c line 287
static _Bool ATSCScanOTA = (_Bool)1;
// ATSCTEXT
// file standard/atsc/atsctext.c line 333
static const char ATSCTEXT[9l] = { 'A', 'T', 'S', 'C', 'T', 'e', 'x', 't', 0 };
// AUTO
// file commands/cmd_scanning.c line 245
static char *AUTO = "AUTO";
// AsciiToUtf8CD
// file standard/atsc/atsctext.c line 329
static void **AsciiToUtf8CD;
// CACHE
// file cache.c line 171
static char CACHE[6l] = { 'C', 'a', 'c', 'h', 'e', 0 };
// COMMAND
// file commands.c line 121
static char COMMAND[8l] = { 'C', 'o', 'm', 'm', 'a', 'n', 'd', 0 };
// ClearFrontEndProperties
// file dvbadapter.c line 391
static struct dtv_properties ClearFrontEndProperties;
// ClearFrontEndPropertyArray
// file dvbadapter.c line 387
static struct dtv_property ClearFrontEndPropertyArray[1l] = { { .cmd=(unsigned int)2, .reserved={ 0u, 0u, 0u }, .u={ .buffer={ .data={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .len=0u,
    .reserved1={ 0u, 0u, 0u }, .reserved2=NULL } },
    .result=0 } };
// ClearFrontEndProperties
// file dvbadapter.c line 391
static struct dtv_properties ClearFrontEndProperties = { .num=(unsigned int)1, .props=ClearFrontEndPropertyArray };
// CommandDetailsInfo
// file commands/cmd_info.c line 88
struct Command_t CommandDetailsInfo[16l];
// CommandDetailsInfo
// file commands/cmd_info.c line 88
struct Command_t CommandDetailsInfo[16l] = { { .command="lsservices", .minArgs=0, .maxArgs=6, .shortHelp="List all services or for a specific multiplex.",
    .longHelp="lsservices [-id] [filters] [-q query|[multiplex]]\nLists selected services, by default all services on all multiplex are displayed.\n\n-id\nList the services fully quailified id.\n\nfilters (tv, radio, data, unknown)\nMultiple filters can be specified or if no filters are specified all selected services will be displayed\n\n-q query\nList names that match the specified query, %% can be used as a wild card character\n\nmultiplex ('mux'| uid | netid.tsid | frequency)\nSelect only services on the specified multiplex, where 'mux' indiciated the current multiplex.",
    .commandfunc=CommandListServices },
    { .command="lsmuxes", .minArgs=0, .maxArgs=1, .shortHelp="List multiplexes.",
    .longHelp="lsmuxes [-id]\nList all available multiplex UIDs.\n\n-id\nList the multiplexes network id.ts id", .commandfunc=CommandListMuxes },
    { .command="lspids", .minArgs=1, .maxArgs=2, .shortHelp="List the PIDs for a specified service.",
    .longHelp="lspids <service name or service id>\nList all the PIDs specified in <service name> PMT.",
    .commandfunc=CommandListPids },
    { .command="current", .minArgs=0, .maxArgs=0, .shortHelp="Print out the service currently being streamed.",
    .longHelp="Shows the service that is currently being streamed to the default output.",
    .commandfunc=CommandCurrent },
    { .command="serviceinfo", .minArgs=1, .maxArgs=1, .shortHelp="Display information about a service.",
    .longHelp="serviceinfo <service name or service id>\nDisplays information about the specified service.",
    .commandfunc=CommandServiceInfo },
    { .command="muxinfo", .minArgs=1, .maxArgs=2, .shortHelp="Display information about a mux.",
    .longHelp="muxinfo <uid> or\nmuxinfo <netid>.<tsid>\nmuxinfo <net id> <ts id>\nDisplays information about the specified service.",
    .commandfunc=CommandMuxInfo },
    { .command="stats", .minArgs=0, .maxArgs=0, .shortHelp="Display the stats for the PAT,PMT and service PID filters.",
    .longHelp="Display the number of packets processed for the PSI/SI filters and the number of packets filtered for each service filter and manual output.",
    .commandfunc=CommandStats },
    { .command="festatus", .minArgs=0, .maxArgs=0, .shortHelp="Displays the status of the tuner.",
    .longHelp="Displays whether the front end is locked, the bit error rate and signal to noiseratio and the signal strength",
    .commandfunc=CommandFEStatus },
    { .command="feparams", .minArgs=0, .maxArgs=0, .shortHelp="Get current frontend parameters.",
    .longHelp="Displays the current frontend parameters as a yaml document.",
    .commandfunc=CommandFEParams },
    { .command="lsprops", .minArgs=0, .maxArgs=2, .shortHelp="List available properties.",
    .longHelp="lsprops [-l] [<property path>]\nList all available properties at the specified path or the root if not supplied.Use -l to show type and whether the property is readable/writable and has any children.",
    .commandfunc=CommandListProperties },
    { .command="getprop", .minArgs=1, .maxArgs=1, .shortHelp="Get the value of a property.",
    .longHelp="getprop <property path>\nGet the value of the specified property.",
    .commandfunc=CommandGetProperty },
    { .command="setprop", .minArgs=2, .maxArgs=2, .shortHelp="Set the value of a property.",
    .longHelp="setprop <property path> <new value>\nSet the value of the specified property to that of <new value>.",
    .commandfunc=CommandSetProperty },
    { .command="propinfo", .minArgs=1, .maxArgs=1, .shortHelp="Display information about a property.",
    .longHelp="propinfo <property path>\nDisplay information about the specified property.",
    .commandfunc=CommandPropertyInfo },
    { .command="dumptsr", .minArgs=0, .maxArgs=0, .shortHelp="Dump information from the TSReader",
    .longHelp="Dump information from the TSReader",
    .commandfunc=CommandDumpTSReader },
    { .command="lslnbs", .minArgs=0, .maxArgs=0, .shortHelp="List known LNBs",
    .longHelp="List the LNBs that dvbstreamer knows about and the name used to select them", .commandfunc=CommandListLNBs },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// CommandDetailsScanning
// file commands/cmd_scanning.c line 208
struct Command_t CommandDetailsScanning[3l];
// CommandDetailsScanning
// file commands/cmd_scanning.c line 208
struct Command_t CommandDetailsScanning[3l] = { { .command="scan", .minArgs=1, .maxArgs=2, .shortHelp="Scan the specified multiplex(es) for services.",
    .longHelp="scan <multiplex>\nTunes to the specified multiplex and waits for up to 5 seconds to acquire service information.\nscan all\nTunes to all known multiplexes and waits for up to 5 seconds on each multiplex to acquire service information.\nscan full\nPerforms a full spectrum scan looking for available multiplexes. This method only supports DVB-T/C and ATSC.\nscan net <initial tuning data>\nPerforms a network scan using the initial tuning data provided this is in the same format as supplied in the initial tuning data files supplied with the dvb-utils from linuxtv.org.\nThe tuning data should be quoted, ie\nscan net \"T 489833000 8MHz 3/4 NONE QAM16 2k 1/32 NONE\"\nNetworks can be scan by calling this command more than once with different initial tuning data.\n",
    .commandfunc=CommandScan },
    { .command="cancelscan", .minArgs=0, .maxArgs=0, .shortHelp="Cancel the any scan that is in progress.",
    .longHelp="cancelscan\nCancels any scans that are currently in progress.",
    .commandfunc=CommandScanCancel },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// CommandDetailsServiceFilter
// file commands/cmd_servicefilter.c line 91
struct Command_t CommandDetailsServiceFilter[13l];
// CommandDetailsServiceFilter
// file commands/cmd_servicefilter.c line 91
struct Command_t CommandDetailsServiceFilter[13l] = { { .command="select", .minArgs=1, .maxArgs=1, .shortHelp="Select a new service to stream.",
    .longHelp="select <service name>\nSets <service name> as the current service, this may mean tuning to a different multiplex.",
    .commandfunc=CommandSelect },
    { .command="setmrl", .minArgs=1, .maxArgs=1, .shortHelp="Set the MRL of the primary service filter.",
    .longHelp="setmrl <MRL>\nSet the MRL of the primary service filter.\nNOTE: This is actually an alias of setsfmrl called with <Primary> as the service filter name.",
    .commandfunc=CommandSetMRL },
    { .command="getmrl", .minArgs=0, .maxArgs=0, .shortHelp="Get the primary service filter MRL.",
    .longHelp="getmrl\nGet the MRL of the primary service filter.\nNOTE: This is actually an alias of getsfmrl called with <Primary> as the service filter name.",
    .commandfunc=CommandGetMRL },
    { .command="addsf", .minArgs=2, .maxArgs=2, .shortHelp="Add a service filter.",
    .longHelp="addsf <service filter name> <mrl>\nAdds a new destination for sending a secondary service to.", .commandfunc=CommandAddSF },
    { .command="rmsf", .minArgs=1, .maxArgs=1, .shortHelp="Remove a service filter.",
    .longHelp="rmsf <service filter name>\nRemove a destination for sending secondary services to.",
    .commandfunc=CommandRemoveSF },
    { .command="lssfs", .minArgs=0, .maxArgs=1, .shortHelp="List all service filters.",
    .longHelp="List all service filters their names, destinations and currently selected service.",
    .commandfunc=CommandListSF },
    { .command="setsf", .minArgs=2, .maxArgs=2, .shortHelp="Set the service to be filtered by a service filter.",
    .longHelp="setsf <service filter name> <service name>\nSelects the service to be filtered by the service filter.\nCannot be used for the primary service filter (<Primary>), use 'select' instead",
    .commandfunc=CommandSetSFService },
    { .command="getsf", .minArgs=1, .maxArgs=1, .shortHelp="Get the service to stream to a secondary service output.",
    .longHelp="setsf <service filter name> <service name>\nStream the specified service to the secondary service output.",
    .commandfunc=CommandGetSFService },
    { .command="setsfmrl", .minArgs=2, .maxArgs=2, .shortHelp="Set the service filter's MRL.",
    .longHelp="setsfmrl <service filter name> <mrl>\nChange the destination for packets sent to this service filters output.If the MRL cannot be parsed no change will be made to the service filter.",
    .commandfunc=CommandSetSFMRL },
    { .command="getsfmrl", .minArgs=1, .maxArgs=1, .shortHelp="Get the service filter's MRL.",
    .longHelp="getsfmrl <service filter name>\nRetrieve the current MRL for the specified service filter.",
    .commandfunc=CommandGetSFMRL },
    { .command="setsfavsonly", .minArgs=2, .maxArgs=2, .shortHelp="Enable/disable streaming of Audio/Video/Subtitles only.",
    .longHelp="setsfavsonly <service filter name> on|off\nEnabling AVS Only cause the PMT to be rewritten to only include the first video stream, normal audio stream and the subtitles stream only.\n(Default: off)",
    .commandfunc=CommandSetSFAVSOnly },
    { .command="getsfavsonly", .minArgs=1, .maxArgs=1, .shortHelp="Get whether Audio/Video/Subtitles only streaming is enabled.",
    .longHelp="getsfavsonly <service filter name>\nRetrieves whether Audio/Video/Subtitles only streaming is enabled.",
    .commandfunc=CommandGetSFAVSOnly },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// CommandEPGInfo
// file commands/cmd_epg.c line 50
struct Command_t CommandEPGInfo[2l];
// CommandEPGInfo
// file commands/cmd_epg.c line 50
struct Command_t CommandEPGInfo[2l] = { { .command="epgdata", .minArgs=0, .maxArgs=0, .shortHelp="Register to receive EPG data in XML format.",
    .longHelp="EPG data is output to the command context in XML format until DVBStreamerterminates or the command context is closed (ie the socket is disconnected).",
    .commandfunc=CommandEPGData },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// CommandMutex
// file commands.c line 118
static union anonymous_14 CommandMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// CommandsList
// file commands.c line 117
static struct List_s *CommandsList;
// ConnectionCommands
// file remoteintf.c line 99
static struct Command_t ConnectionCommands[3l];
// ConnectionCommands
// file remoteintf.c line 99
static struct Command_t ConnectionCommands[3l] = { { .command="auth", .minArgs=2, .maxArgs=2, .shortHelp="Login to control dvbstreamer.",
    .longHelp="auth <username> <password>\nAuthenticate as the user that is able to select channels etc.",
    .commandfunc=RemoteInterfaceAuthenticate },
    { .command="logout", .minArgs=0, .maxArgs=0, .shortHelp="Close the current control connection.",
    .longHelp="Close the current control connection (only works for remote connections).",
    .commandfunc=RemoteInterfaceLogout },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// ConsoleCommandContext
// file commands.c line 82
static struct CommandContext_t ConsoleCommandContext = { .interface="console", .remote=(_Bool)0, .infp=(struct _IO_FILE *)(void *)0,
    .outfp=(struct _IO_FILE *)(void *)0, .privateArg=(void *)0,
    .commands=(struct Command_t *)(void *)0, .authenticated=(_Bool)1,
    .errorNumber=(unsigned short int)0, .errorMessage={ (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
// CurrentMultiplex
// file tuning.c line 42
static struct Multiplex_s *CurrentMultiplex = (struct Multiplex_s *)(void *)0;
// CurrentService
// file tuning.c line 43
static struct Service_t *CurrentService = (struct Service_t *)(void *)0;
// DBASE
// file dbase.c line 53
static char DBASE[6l] = { 'd', 'b', 'a', 's', 'e', 0 };
// DBaseInstance
// file dbase.c line 51
static struct sqlite3 *DBaseInstance;
// DEFERREDPROC
// file threading/deferredproc.c line 52
static const char DEFERREDPROC[13l] = { 'D', 'e', 'f', 'e', 'r', 'r', 'e', 'd', 'P', 'r', 'o', 'c', 0 };
// DELIVERYMETHOD
// file deliverymethod.c line 39
static char DELIVERYMETHOD[15l] = { 'D', 'e', 'l', 'i', 'v', 'e', 'r', 'y', 'M', 'e', 't', 'h', 'o', 'd', 0 };
// DISPATCHERS
// file dispatchers.c line 40
static char DISPATCHERS[12l] = { 'D', 'i', 's', 'p', 'a', 't', 'c', 'h', 'e', 'r', 's', 0 };
// DVBADAPTER
// file dvbadapter.c line 257
static const char DVBADAPTER[11l] = { 'D', 'V', 'B', 'A', 'd', 'a', 'p', 't', 'e', 'r', 0 };
// DVBAdapter
// file main.c line 131
static struct DVBAdapter_s *DVBAdapter;
// DVBDeliverySystemStr
// file constants.c line 2
char *DVBDeliverySystemStr[7l] = { "DVB-S", "DVB-C", "DVB-T", "ATSC", "DVB-S2", "DVB-T2", "Invalid" };
// DVBEventSource
// file standard/dvb/dvb.c line 39
struct EventSource_s *DVBEventSource;
// DVBFilterType
// file standard/dvb/dvb.c line 40
char DVBFilterType[4l] = { 'D', 'V', 'B', 0 };
// DVBSSatNumber
// file commands/cmd_scanning.c line 282
static signed int DVBSSatNumber = 0;
// DVBTEXT
// file standard/dvb/dvbtext.c line 60
static char DVBTEXT[8l] = { 'D', 'V', 'B', 'T', 'e', 'x', 't', 0 };
// DVBTScanUHF
// file commands/cmd_scanning.c line 279
static _Bool DVBTScanUHF = (_Bool)1;
// DVBTScanVHF
// file commands/cmd_scanning.c line 278
static _Bool DVBTScanVHF = (_Bool)1;
// DaemonMode
// file main.c line 124
_Bool DaemonMode = (_Bool)0;
// DataDirectory
// file main.c line 127
char DataDirectory[4096l];
// DecompressionBuffer
// file standard/atsc/atsctext.c line 326
static char DecompressionBuffer[512l];
// DeliveryMethodsList
// file deliverymethod.c line 40
static struct List_s *DeliveryMethodsList;
// EPGCHANNEL
// file epgchannel.c line 67
static const char EPGCHANNEL[12l] = { 'E', 'P', 'G', 'D', 'C', 'h', 'a', 'n', 'n', 'e', 'l', 0 };
// EPGChannelListeners
// file epgchannel.c line 68
static struct List_s *EPGChannelListeners;
// EPGChannelMutex
// file epgchannel.c line 66
static union anonymous_14 EPGChannelMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// EVENTS
// file events.c line 81
static char EVENTS[7l] = { 'E', 'v', 'e', 'n', 't', 's', 0 };
// ExitProgram
// file main.c line 123
volatile _Bool ExitProgram = (volatile _Bool)0;
// InputDispatcherThread
// file dispatchers.c line 43
static unsigned long int InputDispatcherThread;
// InputEventLoop
// file dispatchers.c line 41
static struct ev_loop *InputEventLoop = (struct ev_loop *)(void *)0;
// InputExitWatcher
// file dispatchers.c line 47
static struct ev_io InputExitWatcher;
// InstancesList
// file deliverymethod.c line 41
static struct List_s *InstancesList;
// LIST
// file list.c line 31
static const char LIST[5l] = { 'l', 'i', 's', 't', 0 };
// LNBs
// file lnb.c line 37
static struct LNBInfo_s LNBs[5l];
// cband_desc
// file lnb.c line 31
static char *cband_desc[4l] = { "Big Dish", "3700 to 4200 MHz", "Single LO, 5150 Mhz", (char *)(void *)0 };
// dbs_desc
// file lnb.c line 14
static char *dbs_desc[4l] = { "Expressvu, North America", "12200 to 12700 MHz", "Single LO, 11250 MHz", (char *)(void *)0 };
// enhan_desc
// file lnb.c line 25
static char *enhan_desc[4l] = { "Astra", "10700 to 11700 MHz", "Single LO, 9750 MHz", (char *)(void *)0 };
// standard_desc
// file lnb.c line 20
static char *standard_desc[3l] = { "10945 to 11450 Mhz", "Single LO, 10000 Mhz", (char *)(void *)0 };
// univ_desc
// file lnb.c line 8
static char *univ_desc[4l] = { "Europe", "10800 to 11800 MHz and 11600 to 12700 Mhz",
    "Dual LO, loband 9750, hiband 10600 MHz",
    (char *)(void *)0 };
// LNBs
// file lnb.c line 37
static struct LNBInfo_s LNBs[5l] = { { .name="UNIVERSAL", .desc=univ_desc, .lowFrequency=(unsigned long int)9750000, .highFrequency=(unsigned long int)10600000,
    .switchFrequency=(unsigned long int)11700000 },
    { .name="DBS", .desc=dbs_desc, .lowFrequency=(unsigned long int)11250000, .highFrequency=(unsigned long int)0,
    .switchFrequency=(unsigned long int)0 },
    { .name="STANDARD", .desc=standard_desc, .lowFrequency=(unsigned long int)10000000,
    .highFrequency=(unsigned long int)0,
    .switchFrequency=(unsigned long int)0 },
    { .name="ENHANCED", .desc=enhan_desc, .lowFrequency=(unsigned long int)9750000, .highFrequency=(unsigned long int)0,
    .switchFrequency=(unsigned long int)0 },
    { .name="C-BAND", .desc=cband_desc, .lowFrequency=(unsigned long int)5150000, .highFrequency=(unsigned long int)0,
    .switchFrequency=(unsigned long int)0 } };
// MAIN
// file main.c line 133
static const char MAIN[5l] = { 'M', 'a', 'i', 'n', 0 };
// MESSAGEQ
// file threading/messageq.c line 50
static const char MESSAGEQ[9l] = { 'M', 'e', 's', 's', 'a', 'g', 'e', 'Q', 0 };
// MPEG2EventSource
// file standard/mpeg2/mpeg2.c line 41
struct EventSource_s *MPEG2EventSource = (struct EventSource_s *)(void *)0;
// MPEG2FilterType
// file standard/mpeg2/mpeg2.c line 42
char MPEG2FilterType[6l] = { 'M', 'P', 'E', 'G', '2', 0 };
// MessageQClass
// file threading/messageq.c line 49
static char MessageQClass[9l] = { 'M', 'e', 's', 's', 'a', 'g', 'e', 'Q', 0 };
// NITPROCESSOR
// file standard/dvb/nitprocessor.c line 61
static char NITPROCESSOR[13l] = { 'N', 'I', 'T', 'P', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', 0 };
// NONE
// file commands/cmd_scanning.c line 246
static char *NONE = "NONE";
// NetUserExitWatcher
// file dispatchers.c line 48
static struct ev_io NetUserExitWatcher;
// NullOutputHandler
// file deliverymethod.c line 48
struct DeliveryMethodHandler_t NullOutputHandler;
// NullOutputHandler
// file deliverymethod.c line 48
struct DeliveryMethodHandler_t NullOutputHandler = { .CanHandle=NullOutputCanHandle, .CreateInstance=NullOutputCreate };
// NullPrefix
// file deliverymethod.c line 45
const char NullPrefix[8l] = { 'n', 'u', 'l', 'l', ':', '/', '/', 0 };
// OBJECT
// file objects.c line 91
static char OBJECT[7l] = { 'O', 'b', 'j', 'e', 'c', 't', 0 };
// PATPROCESSOR
// file standard/mpeg2/patprocessor.c line 61
static char PATPROCESSOR[13l] = { 'P', 'A', 'T', 'P', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', 0 };
// PLUGINMANAGER
// file pluginmgr.c line 110
static char PLUGINMANAGER[14l] = { 'P', 'l', 'u', 'g', 'i', 'n', 'M', 'a', 'n', 'a', 'g', 'e', 'r', 0 };
// PMTCount
// file commands/cmd_scanning.c line 265
static signed int PMTCount = 0;
// PMTPROCESSOR
// file standard/mpeg2/pmtprocessor.c line 71
static char PMTPROCESSOR[13l] = { 'P', 'M', 'T', 'P', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', 0 };
// PMTsReceived
// file commands/cmd_scanning.c line 266
static struct PMTReceived_t PMTsReceived[253l];
// PROPERTIES
// file properties.c line 76
static char PROPERTIES[11l] = { 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's', 0 };
// PSIPPROCESSOR
// file standard/atsc/psipprocessor.c line 83
static const char PSIPPROCESSOR[14l] = { 'P', 'S', 'I', 'P', 'P', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', 0 };
// PSISIPIDFilterType
// file ts.c line 97
char PSISIPIDFilterType[7l] = { 'P', 'S', 'I', '/', 'S', 'I', 0 };
// PidFile
// file main.c line 129
static char PidFile[4096l];
// PluginManagerCommands
// file pluginmgr.c line 75
static struct Command_t PluginManagerCommands[3l];
// PluginManagerCommands
// file pluginmgr.c line 75
static struct Command_t PluginManagerCommands[3l] = { { .command="lsplugins", .minArgs=0, .maxArgs=0, .shortHelp="List loaded plugins.",
    .longHelp="List all plugins that where loaded at startup.", .commandfunc=PluginManagerLsPlugins },
    { .command="plugininfo", .minArgs=1, .maxArgs=1, .shortHelp="Display the information about a plugin.",
    .longHelp="plugininfo <pluginname>\nDisplays the version, author and descriptor for a specific plugin.",
    .commandfunc=PluginManagerPluginInfo },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// PluginsList
// file pluginmgr.c line 73
static struct List_s *PluginsList;
// PrimaryService
// file main.c line 126
const char PrimaryService[10l] = { '<', 'P', 'r', 'i', 'm', 'a', 'r', 'y', '>', 0 };
// PrimaryServiceFilter
// file main.c line 132
static struct ServiceFilter_s *PrimaryServiceFilter;
// REMOTEINTERFACE
// file remoteintf.c line 135
static char REMOTEINTERFACE[16l] = { 'R', 'e', 'm', 'o', 't', 'e', 'I', 'n', 't', 'e', 'r', 'f', 'a', 'c', 'e', 0 };
// RemoteInterfaceCommands
// file remoteintf.c line 88
static struct Command_t RemoteInterfaceCommands[2l];
// RemoteInterfaceCommands
// file remoteintf.c line 88
static struct Command_t RemoteInterfaceCommands[2l] = { { .command="who", .minArgs=0, .maxArgs=0, .shortHelp="Display current control connections.",
    .longHelp="List all the control connections and if they are authenticated.",
    .commandfunc=RemoteInterfaceWho },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// ResultBuffer
// file standard/dvb/dvbtext.c line 58
static char ResultBuffer[1536l];
// ResultBufferMutex
// file standard/dvb/dvbtext.c line 57
static union anonymous_14 ResultBufferMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// SCANNING
// file commands/cmd_scanning.c line 239
static char SCANNING[9l] = { 'S', 'c', 'a', 'n', 'n', 'i', 'n', 'g', 0 };
// SDTPROCESSOR
// file standard/dvb/sdtprocessor.c line 83
static char SDTPROCESSOR[13l] = { 'S', 'D', 'T', 'P', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', 0 };
// SERVICEFILTER
// file servicefilter.c line 117
static char SERVICEFILTER[14l] = { 'S', 'e', 'r', 'v', 'i', 'c', 'e', 'F', 'i', 'l', 't', 'e', 'r', 0 };
// SegmentBuffer
// file standard/atsc/atsctext.c line 325
static char SegmentBuffer[512l];
// ServiceFilterGroupType
// file servicefilter.c line 115
char ServiceFilterGroupType[15l] = { 'S', 'e', 'r', 'v', 'i', 'c', 'e', ' ', 'F', 'i', 'l', 't', 'e', 'r', 0 };
// ServiceFilterList
// file servicefilter.c line 118
static struct List_s *ServiceFilterList;
// StartTime
// file main.c line 134
static signed long int StartTime;
// StartTime_link1
// file commands/cmd_info.c line 228
static signed long int StartTime_link1;
// TAG_BANDWIDTH
// file dvbadapter.c line 273
static const char TAG_BANDWIDTH[10l] = { 'B', 'a', 'n', 'd', 'w', 'i', 'd', 't', 'h', 0 };
// TAG_CONSTELLATION
// file dvbadapter.c line 276
static const char TAG_CONSTELLATION[14l] = { 'C', 'o', 'n', 's', 't', 'e', 'l', 'l', 'a', 't', 'i', 'o', 'n', 0 };
// TAG_FEC
// file dvbadapter.c line 270
static const char TAG_FEC[4l] = { 'F', 'E', 'C', 0 };
// TAG_FEC_HP
// file dvbadapter.c line 274
static const char TAG_FEC_HP[7l] = { 'F', 'E', 'C', ' ', 'H', 'P', 0 };
// TAG_FEC_LP
// file dvbadapter.c line 275
static const char TAG_FEC_LP[7l] = { 'F', 'E', 'C', ' ', 'L', 'P', 0 };
// TAG_FREQUENCY
// file dvbadapter.c line 268
static const char TAG_FREQUENCY[10l] = { 'F', 'r', 'e', 'q', 'u', 'e', 'n', 'c', 'y', 0 };
// TAG_GUARD_INTERVAL
// file dvbadapter.c line 277
static const char TAG_GUARD_INTERVAL[15l] = { 'G', 'u', 'a', 'r', 'd', ' ', 'I', 'n', 't', 'e', 'r', 'v', 'a', 'l', 0 };
// TAG_HIERARCHY
// file dvbadapter.c line 279
static const char TAG_HIERARCHY[10l] = { 'H', 'i', 'e', 'r', 'a', 'r', 'c', 'h', 'y', 0 };
// TAG_INVERSION
// file dvbadapter.c line 269
static const char TAG_INVERSION[10l] = { 'I', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 0 };
// TAG_MODULATION
// file dvbadapter.c line 272
static const char TAG_MODULATION[11l] = { 'M', 'o', 'd', 'u', 'l', 'a', 't', 'i', 'o', 'n', 0 };
// TAG_PILOT
// file dvbadapter.c line 283
static const char TAG_PILOT[6l] = { 'P', 'i', 'l', 'o', 't', 0 };
// TAG_POLARISATION
// file dvbadapter.c line 280
static const char TAG_POLARISATION[13l] = { 'P', 'o', 'l', 'a', 'r', 'i', 's', 'a', 't', 'i', 'o', 'n', 0 };
// TAG_ROLL_OFF
// file dvbadapter.c line 282
static const char TAG_ROLL_OFF[9l] = { 'R', 'o', 'l', 'l', ' ', 'O', 'f', 'f', 0 };
// TAG_SATELLITE_NUMBER
// file dvbadapter.c line 281
static const char TAG_SATELLITE_NUMBER[17l] = { 'S', 'a', 't', 'e', 'l', 'l', 'i', 't', 'e', ' ', 'N', 'u', 'm', 'b', 'e', 'r', 0 };
// TAG_SYMBOL_RATE
// file dvbadapter.c line 271
static const char TAG_SYMBOL_RATE[12l] = { 'S', 'y', 'm', 'b', 'o', 'l', ' ', 'R', 'a', 't', 'e', 0 };
// TAG_TRANSMISSION_MODE
// file dvbadapter.c line 278
static const char TAG_TRANSMISSION_MODE[18l] = { 'T', 'r', 'a', 'n', 's', 'm', 'i', 's', 's', 'i', 'o', 'n', ' ', 'M', 'o', 'd', 'e', 0 };
// TDTPROCESSOR
// file standard/dvb/tdtprocessor.c line 69
static char TDTPROCESSOR[13l] = { 'T', 'D', 'T', 'P', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', 0 };
// TSREADER
// file ts.c line 98
static char TSREADER[9l] = { 'T', 'S', 'R', 'e', 'a', 'd', 'e', 'r', 0 };
// TSReader
// file main.c line 130
static struct TSReader_t *TSReader;
// TUNING
// file tuning.c line 52
static const char TUNING[7l] = { 't', 'u', 'n', 'i', 'n', 'g', 0 };
// TextBuffer
// file standard/atsc/atsctext.c line 324
static char TextBuffer[1024l];
// UTF8
// file standard/dvb/dvbtext.c line 59
static char UTF8[6l] = { 'U', 'T', 'F', '-', '8', 0 };
// Ucs2ToUtf8CD
// file standard/atsc/atsctext.c line 328
static void **Ucs2ToUtf8CD;
// UserNetDispatcherThread
// file dispatchers.c line 44
static unsigned long int UserNetDispatcherThread;
// UserNetEventLoop
// file dispatchers.c line 42
static struct ev_loop *UserNetEventLoop = (struct ev_loop *)(void *)0;
// UserNetSync
// file dispatchers.c line 45
static _Bool UserNetSync = (_Bool)0;
// Utf16ToUtf8CD
// file standard/atsc/atsctext.c line 327
static void **Utf16ToUtf8CD;
// YAMLUTILS
// file yamlutils.c line 58
static char YAMLUTILS[10l] = { 'Y', 'a', 'm', 'l', 'U', 't', 'i', 'l', 's', 0 };
// authPassword
// file remoteintf.c line 129
static char *authPassword;
// authUsername
// file remoteintf.c line 128
static char *authUsername;
// bandwidthMapping
// file dvbadapter.c line 336
static struct StringToParamMapping_s bandwidthMapping[9l] = { { .str="8Mhz", .param=(unsigned int)0 },
    { .str="8000000", .param=(unsigned int)0 },
    { .str="8Mhz", .param=(unsigned int)0 },
    { .str="7Mhz", .param=(unsigned int)1 },
    { .str="7000000", .param=(unsigned int)1 },
    { .str="6Mhz", .param=(unsigned int)2 },
    { .str="6000000", .param=(unsigned int)2 },
    { .str="AUTO", .param=(unsigned int)3 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// bandwidthTable
// file commands/cmd_scanning.c line 249
static char *bandwidthTable[8l] = { "8000000", "7000000", "6000000", "AUTO", "AUTO", "AUTO", "AUTO", "AUTO" };
// cacheFlags
// file cache.c line 178
static enum CacheFlags cacheFlags[256l];
// cacheUpdateMutex
// file cache.c line 177
static union anonymous_14 cacheUpdateMutex;
// cachedPIDs
// file cache.c line 180
static struct ProgramInfo_s *cachedPIDs[256l];
// cachedServices
// file cache.c line 179
static struct Service_t *cachedServices[256l];
// cachedServicesCount
// file cache.c line 175
static signed int cachedServicesCount = 0;
// cachedServicesMultiplex
// file cache.c line 174
static struct Multiplex_s *cachedServicesMultiplex = (struct Multiplex_s *)(void *)0;
// cancelScan
// file commands/cmd_scanning.c line 242
static _Bool cancelScan = (_Bool)0;
// cd
// file standard/dvb/dvbtext.c line 56
static void *cd;
// classes
// file objects.c line 92
static struct Class_s *classes = (struct Class_s *)(void *)0;
// classesCount
// file objects.c line 93
static unsigned int classesCount = (unsigned int)0;
// commandContextKey
// file commands.c line 119
static unsigned int commandContextKey;
// connectionCondVar
// file remoteintf.c line 121
static union anonymous_21 connectionCondVar = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// connectionsList
// file remoteintf.c line 125
static struct List_s *connectionsList;
// connectionsMutex
// file remoteintf.c line 120
static union anonymous_14 connectionsMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// coreCommands
// file commands.c line 95
static struct Command_t coreCommands[3l];
// coreCommands
// file commands.c line 95
static struct Command_t coreCommands[3l] = { { .command="quit", .minArgs=0, .maxArgs=0, .shortHelp="Exit the program.",
    .longHelp="Exit the program, can be used in the startup file to stop further processing.", .commandfunc=CommandQuit },
    { .command="help", .minArgs=0, .maxArgs=1, .shortHelp="Display the list of commands or help on a specific command.",
    .longHelp="help [<command>]\nList all available commands or displays specific help for the command specifed.",
    .commandfunc=CommandHelp },
    { .command=(char *)(void *)0, .minArgs=0, .maxArgs=0,
    .shortHelp=(char *)(void *)0, .longHelp=(char *)(void *)0,
    .commandfunc=(void (*)(signed int, char **))(void *)0 } };
// cs_old
// file standard/dvb/dvbtext.c line 55
static enum CS cs_old = (enum CS)0;
// currentScanState
// file commands/cmd_scanning.c line 300
static enum ScanState_e currentScanState = (enum ScanState_e)5;
// currentService
// file commands/cmd_scanning.c line 243
static struct Service_t *currentService;
// dbaseFile
// file dbase.c line 54
static char dbaseFile[4096l];
// dbaseKey
// file dbase.c line 55
static unsigned int dbaseKey;
// deliverySystemRanges
// file commands/cmd_scanning.c line 291
signed int deliverySystemRanges[5l] = { 0, 0, 166670, 28615, 0 };
// dvbSource
// file dvbadapter.c line 261
static struct EventSource_s *dvbSource = (struct EventSource_s *)(void *)0;
// eventSource
// file servicefilter.c line 120
static struct EventSource_s *eventSource;
// eventSource_link1
// file cache.c line 172
static struct EventSource_s *eventSource_link1;
// eventUnregistered
// file events.c line 84
static struct Event_s *eventUnregistered;
// eventsMutex
// file events.c line 80
static union anonymous_14 eventsMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=1, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// eventsSource
// file events.c line 83
static struct EventSource_s *eventsSource;
// exitPipe
// file dispatchers.c line 46
static signed int exitPipe[2l];
// feActiveEvent
// file dvbadapter.c line 265
static struct Event_s *feActiveEvent;
// feIdleEvent
// file dvbadapter.c line 266
static struct Event_s *feIdleEvent;
// fecInnerTable
// file commands/cmd_scanning.c line 255
static char *fecInnerTable[16l] = { "NONE", "1/2", "2/3", "3/4", "5/6", "7/8", "8/9", "AUTO", "4/5", "AUTO", "NONE", "NONE", "NONE", "NONE", "NONE", "NONE" };
// fecMapping
// file dvbadapter.c line 311
static struct StringToParamMapping_s fecMapping[13l] = { { .str="NONE", .param=(unsigned int)0 },
    { .str="1/2", .param=(unsigned int)1 }, { .str="2/3", .param=(unsigned int)2 }, { .str="3/4", .param=(unsigned int)3 }, { .str="4/5", .param=(unsigned int)4 }, { .str="5/6", .param=(unsigned int)5 }, { .str="6/7", .param=(unsigned int)6 }, { .str="7/8", .param=(unsigned int)7 }, { .str="8/9", .param=(unsigned int)8 }, { .str="AUTO", .param=(unsigned int)9 },
    { .str="3/5", .param=(unsigned int)10 },
    { .str="9/10", .param=(unsigned int)11 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// filterAddedEvent
// file servicefilter.c line 121
static struct Event_s *filterAddedEvent;
// filterRemovedEvent
// file servicefilter.c line 122
static struct Event_s *filterRemovedEvent;
// globalListenersList
// file events.c line 79
static struct List_s *globalListenersList;
// guardIntervalMapping
// file dvbadapter.c line 345
static struct StringToParamMapping_s guardIntervalMapping[6l] = { { .str="1/32", .param=(unsigned int)0 },
    { .str="1/16", .param=(unsigned int)1 },
    { .str="1/8", .param=(unsigned int)2 }, { .str="1/4", .param=(unsigned int)3 }, { .str="AUTO", .param=(unsigned int)4 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// hexVersionStr
// file main.c line 136
static char hexVersionStr[5l];
// hierarchyMapping
// file dvbadapter.c line 354
static struct StringToParamMapping_s hierarchyMapping[6l] = { { .str="NONE", .param=(unsigned int)0 },
    { .str="1", .param=(unsigned int)1 }, { .str="2", .param=(unsigned int)2 }, { .str="4", .param=(unsigned int)3 }, { .str="AUTO", .param=(unsigned int)4 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// huffman1bo
// file standard/atsc/atsctext.c line 61
static unsigned int huffman1bo[128l] = { (unsigned int)0x0000, (unsigned int)0x003A, (unsigned int)0x003C, (unsigned int)0x003E, (unsigned int)0x0040, (unsigned int)0x0042, (unsigned int)0x0044, (unsigned int)0x0046, (unsigned int)0x0048, (unsigned int)0x004A, (unsigned int)0x004C, (unsigned int)0x004E, (unsigned int)0x0050, (unsigned int)0x0052, (unsigned int)0x0054, (unsigned int)0x0056, (unsigned int)0x0058, (unsigned int)0x005A, (unsigned int)0x005C, (unsigned int)0x005E, (unsigned int)0x0060, (unsigned int)0x0062, (unsigned int)0x0064, (unsigned int)0x0066, (unsigned int)0x0068, (unsigned int)0x006A, (unsigned int)0x006C, (unsigned int)0x006E, (unsigned int)0x0070, (unsigned int)0x0072, (unsigned int)0x0074, (unsigned int)0x0076, (unsigned int)0x0078, (unsigned int)0x00CE, (unsigned int)0x00D2, (unsigned int)0x00D4, (unsigned int)0x00D6, (unsigned int)0x00D8, (unsigned int)0x00DA, (unsigned int)0x00DC, (unsigned int)0x00E6, (unsigned int)0x00E8, (unsigned int)0x00EA, (unsigned int)0x00F0, (unsigned int)0x00F2, (unsigned int)0x00F4, (unsigned int)0x0106, (unsigned int)0x0112, (unsigned int)0x0114, (unsigned int)0x011C, (unsigned int)0x0128, (unsigned int)0x0130, (unsigned int)0x0134, (unsigned int)0x0136, (unsigned int)0x0138, (unsigned int)0x013A, (unsigned int)0x013C, (unsigned int)0x013E, (unsigned int)0x0146, (unsigned int)0x0148, (unsigned int)0x014A, (unsigned int)0x014C, (unsigned int)0x014E, (unsigned int)0x0150, (unsigned int)0x0152, (unsigned int)0x0154, (unsigned int)0x017E, (unsigned int)0x0192, (unsigned int)0x01AC, (unsigned int)0x01BA, (unsigned int)0x01D2, (unsigned int)0x01E4, (unsigned int)0x01FA, (unsigned int)0x0206, (unsigned int)0x021E, (unsigned int)0x0226, (unsigned int)0x0232, (unsigned int)0x023E, (unsigned int)0x0252, (unsigned int)0x0264, (unsigned int)0x027A, (unsigned int)0x0294, (unsigned int)0x0298, (unsigned int)0x02A4, (unsigned int)0x02C8, (unsigned int)0x02DE, (unsigned int)0x02E6, (unsigned int)0x02F4, (unsigned int)0x0304, (unsigned int)0x0306, (unsigned int)0x030C, (unsigned int)0x0310, (unsigned int)0x0312, (unsigned int)0x0314, (unsigned int)0x0316, (unsigned int)0x0318, (unsigned int)0x031A, (unsigned int)0x031C, (unsigned int)0x0352, (unsigned int)0x036A, (unsigned int)0x038E, (unsigned int)0x03AE, (unsigned int)0x03EE, (unsigned int)0x0406, (unsigned int)0x0428, (unsigned int)0x0444, (unsigned int)0x0472, (unsigned int)0x0476, (unsigned int)0x0490, (unsigned int)0x04BE, (unsigned int)0x04D6, (unsigned int)0x050A, (unsigned int)0x0544, (unsigned int)0x0564, (unsigned int)0x0566, (unsigned int)0x059A, (unsigned int)0x05D0, (unsigned int)0x05FC, (unsigned int)0x0622, (unsigned int)0x062C, (unsigned int)0x0646, (unsigned int)0x0654, (unsigned int)0x067C, (unsigned int)0x068A, (unsigned int)0x068C, (unsigned int)0x068E, (unsigned int)0x0690, (unsigned int)0x0692 };
// huffman1co
// file standard/atsc/atsctext.c line 87
static unsigned char huffman1co[1684l] = { (unsigned char)0x1B, (unsigned char)0x1C, (unsigned char)0xB4, (unsigned char)0xA4, (unsigned char)0xB2, (unsigned char)0xB7, (unsigned char)0xDA, (unsigned char)0x01, (unsigned char)0xD1, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0x04, (unsigned char)0xD5, (unsigned char)0xD9, (unsigned char)0x05, (unsigned char)0xCB, (unsigned char)0xD6, (unsigned char)0x06, (unsigned char)0xCF, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xCA, (unsigned char)0x09, (unsigned char)0xC9, (unsigned char)0xC5, (unsigned char)0xC6, (unsigned char)0x0A, (unsigned char)0xD2, (unsigned char)0xC4, (unsigned char)0xC7, (unsigned char)0xCC, (unsigned char)0xD0, (unsigned char)0xC8, (unsigned char)0xD7, (unsigned char)0xCE, (unsigned char)0x0B, (unsigned char)0xC1, (unsigned char)0x0C, (unsigned char)0xC2, (unsigned char)0xCD, (unsigned char)0xC3, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xD3, (unsigned char)0x11, (unsigned char)0xD4, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x29, (unsigned char)0x2A, (unsigned char)0xD8, (unsigned char)0xE5, (unsigned char)0xB9, (unsigned char)0x01, (unsigned char)0xA7, (unsigned char)0xB1, (unsigned char)0xEC, (unsigned char)0xD1, (unsigned char)0x02, (unsigned char)0xAD, (unsigned char)0xB2, (unsigned char)0xDA, (unsigned char)0xE3, (unsigned char)0xB3, (unsigned char)0x03, (unsigned char)0xE4, (unsigned char)0xE6, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0xE2, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xD5, (unsigned char)0x0A, (unsigned char)0xD6, (unsigned char)0x0B, (unsigned char)0xD9, (unsigned char)0x0C, (unsigned char)0xA6, (unsigned char)0xE9, (unsigned char)0xCB, (unsigned char)0xC5, (unsigned char)0xCF, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0xCA, (unsigned char)0xC9, (unsigned char)0x0F, (unsigned char)0xC7, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xE1, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0xC6, (unsigned char)0xD2, (unsigned char)0xC8, (unsigned char)0xCE, (unsigned char)0xC1, (unsigned char)0xC4, (unsigned char)0xD0, (unsigned char)0xCC, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xEF, (unsigned char)0xC2, (unsigned char)0xD7, (unsigned char)0x16, (unsigned char)0xCD, (unsigned char)0x17, (unsigned char)0xF4, (unsigned char)0xD4, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0xC3, (unsigned char)0xD3, (unsigned char)0x1B, (unsigned char)0x1C, (unsigned char)0x1D, (unsigned char)0x1E, (unsigned char)0x1F, (unsigned char)0x20, (unsigned char)0x21, (unsigned char)0x22, (unsigned char)0x23, (unsigned char)0x24, (unsigned char)0x25, (unsigned char)0x26, (unsigned char)0x27, (unsigned char)0x28, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xB1, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x04, (unsigned char)0xF3, (unsigned char)0xE4, (unsigned char)0xB9, (unsigned char)0x01, (unsigned char)0xF4, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xC1, (unsigned char)0xC8, (unsigned char)0xD3, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xB1, (unsigned char)0xD2, (unsigned char)0xD3, (unsigned char)0xD4, (unsigned char)0xD5, (unsigned char)0xAD, (unsigned char)0xCD, (unsigned char)0xC1, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xA0, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xA0, (unsigned char)0x05, (unsigned char)0xC9, (unsigned char)0xD7, (unsigned char)0xD3, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0x80, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xAD, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0xA0, (unsigned char)0xB0, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x80, (unsigned char)0x9B, (unsigned char)0xB1, (unsigned char)0xB2, (unsigned char)0xA0, (unsigned char)0xB0, (unsigned char)0xB9, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xB1, (unsigned char)0xBA, (unsigned char)0x01, (unsigned char)0xB0, (unsigned char)0x9B, (unsigned char)0x80, (unsigned char)0x80, (unsigned char)0x01, (unsigned char)0xB0, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xB8, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xB0, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xB1, (unsigned char)0xB3, (unsigned char)0xB9, (unsigned char)0xB0, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x80, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0xAA, (unsigned char)0xAD, (unsigned char)0xAE, (unsigned char)0xF6, (unsigned char)0xE7, (unsigned char)0xF4, (unsigned char)0xE2, (unsigned char)0xE9, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xC2, (unsigned char)0xF0, (unsigned char)0x9B, (unsigned char)0xF3, (unsigned char)0xE3, (unsigned char)0xE6, (unsigned char)0xF7, (unsigned char)0x03, (unsigned char)0xF5, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF2, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xE4, (unsigned char)0xA0, (unsigned char)0x0D, (unsigned char)0xEC, (unsigned char)0xEE, (unsigned char)0x0E, (unsigned char)0xED, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xC1, (unsigned char)0xD3, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xC3, (unsigned char)0x02, (unsigned char)0xE9, (unsigned char)0xEC, (unsigned char)0x03, (unsigned char)0xF2, (unsigned char)0xF5, (unsigned char)0x04, (unsigned char)0xEF, (unsigned char)0xE1, (unsigned char)0x05, (unsigned char)0xE5, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xC1, (unsigned char)0xF9, (unsigned char)0x01, (unsigned char)0xC2, (unsigned char)0xCF, (unsigned char)0xE5, (unsigned char)0xF5, (unsigned char)0x9B, (unsigned char)0xE9, (unsigned char)0x02, (unsigned char)0xA0, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xF2, (unsigned char)0x06, (unsigned char)0xEC, (unsigned char)0x07, (unsigned char)0xE1, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xE8, (unsigned char)0x0A, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF9, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0x02, (unsigned char)0xF2, (unsigned char)0xE9, (unsigned char)0xE5, (unsigned char)0xEF, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xF1, (unsigned char)0xF5, (unsigned char)0xF3, (unsigned char)0x01, (unsigned char)0xED, (unsigned char)0xF9, (unsigned char)0xC3, (unsigned char)0x02, (unsigned char)0xEC, (unsigned char)0xEE, (unsigned char)0xE4, (unsigned char)0xF8, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0xF6, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xE1, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0xCC, (unsigned char)0x01, (unsigned char)0xE5, (unsigned char)0x02, (unsigned char)0xEC, (unsigned char)0xF5, (unsigned char)0xEF, (unsigned char)0x03, (unsigned char)0xE9, (unsigned char)0xF2, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xE1, (unsigned char)0x06, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xAE, (unsigned char)0xEC, (unsigned char)0xF9, (unsigned char)0xC1, (unsigned char)0xE8, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xE1, (unsigned char)0xF5, (unsigned char)0xE9, (unsigned char)0x05, (unsigned char)0xE5, (unsigned char)0x06, (unsigned char)0xF2, (unsigned char)0xEF, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0x80, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xE9, (unsigned char)0xE1, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0x04, (unsigned char)0xEE, (unsigned char)0x0B, (unsigned char)0xBA, (unsigned char)0xD4, (unsigned char)0xAE, (unsigned char)0xF2, (unsigned char)0xE3, (unsigned char)0x01, (unsigned char)0xA0, (unsigned char)0x02, (unsigned char)0x80, (unsigned char)0x9B, (unsigned char)0xED, (unsigned char)0x03, (unsigned char)0xC9, (unsigned char)0xF3, (unsigned char)0xF4, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0x01, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0xE5, (unsigned char)0x05, (unsigned char)0xE9, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0xF5, (unsigned char)0xEE, (unsigned char)0x9B, (unsigned char)0xE5, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0x02, (unsigned char)0xE5, (unsigned char)0xEF, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0xE9, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xAA, (unsigned char)0xD4, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xE3, (unsigned char)0x02, (unsigned char)0xF2, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0x04, (unsigned char)0xF5, (unsigned char)0xF9, (unsigned char)0xE9, (unsigned char)0x05, (unsigned char)0xEF, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0x08, (unsigned char)0xCE, (unsigned char)0xA0, (unsigned char)0xC6, (unsigned char)0xF5, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xC2, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0xE9, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xE4, (unsigned char)0xF3, (unsigned char)0xE6, (unsigned char)0xF6, (unsigned char)0xF7, (unsigned char)0xF0, (unsigned char)0xF2, (unsigned char)0x01, (unsigned char)0xEC, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xF5, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xEE, (unsigned char)0x08, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xA0, (unsigned char)0xF3, (unsigned char)0xF9, (unsigned char)0xAE, (unsigned char)0xD2, (unsigned char)0xC7, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0xF5, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xE9, (unsigned char)0xEC, (unsigned char)0x06, (unsigned char)0xE5, (unsigned char)0x07, (unsigned char)0xEF, (unsigned char)0x08, (unsigned char)0xE1, (unsigned char)0x09, (unsigned char)0xF2, (unsigned char)0x0A, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0x9B, (unsigned char)0xD6, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xE8, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0xE9, (unsigned char)0xEF, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xAA, (unsigned char)0xEC, (unsigned char)0xF1, (unsigned char)0xAE, (unsigned char)0xA0, (unsigned char)0xF7, (unsigned char)0xED, (unsigned char)0xEE, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xEB, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xE3, (unsigned char)0x07, (unsigned char)0xEF, (unsigned char)0x08, (unsigned char)0xE9, (unsigned char)0xF5, (unsigned char)0x09, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0xF0, (unsigned char)0xE8, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xF4, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xE8, (unsigned char)0x0A, (unsigned char)0xAD, (unsigned char)0xCE, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xD6, (unsigned char)0x02, (unsigned char)0xF5, (unsigned char)0xF7, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0xE9, (unsigned char)0x05, (unsigned char)0xF2, (unsigned char)0x06, (unsigned char)0xEF, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xEE, (unsigned char)0x03, (unsigned char)0xEC, (unsigned char)0xAE, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0xF0, (unsigned char)0x06, (unsigned char)0xE9, (unsigned char)0xA0, (unsigned char)0xC3, (unsigned char)0xEF, (unsigned char)0x9B, (unsigned char)0xE5, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xC6, (unsigned char)0xD7, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xF2, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE8, (unsigned char)0xE5, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0xE9, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0xEF, (unsigned char)0xE1, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xE5, (unsigned char)0x01, (unsigned char)0xEF, (unsigned char)0x9B, (unsigned char)0xE1, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0x9B, (unsigned char)0xBA, (unsigned char)0xE5, (unsigned char)0xEA, (unsigned char)0xF8, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xE6, (unsigned char)0xA7, (unsigned char)0x03, (unsigned char)0xFA, (unsigned char)0xE8, (unsigned char)0x04, (unsigned char)0xF7, (unsigned char)0x05, (unsigned char)0xF5, (unsigned char)0xE2, (unsigned char)0x06, (unsigned char)0xEB, (unsigned char)0x07, (unsigned char)0xF0, (unsigned char)0x08, (unsigned char)0x80, (unsigned char)0xF6, (unsigned char)0xE7, (unsigned char)0x09, (unsigned char)0xE4, (unsigned char)0x0A, (unsigned char)0xA0, (unsigned char)0xE9, (unsigned char)0x0B, (unsigned char)0xE3, (unsigned char)0xF9, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xED, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xF3, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xEC, (unsigned char)0x12, (unsigned char)0xF4, (unsigned char)0xF2, (unsigned char)0x13, (unsigned char)0xEE, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0x18, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xF3, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0xE2, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0xA0, (unsigned char)0x02, (unsigned char)0xE5, (unsigned char)0xF2, (unsigned char)0xE9, (unsigned char)0x03, (unsigned char)0xEC, (unsigned char)0x04, (unsigned char)0xF9, (unsigned char)0x05, (unsigned char)0xEF, (unsigned char)0x06, (unsigned char)0xE1, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xC3, (unsigned char)0xCC, (unsigned char)0xC7, (unsigned char)0x9B, (unsigned char)0xE3, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0xEC, (unsigned char)0xF9, (unsigned char)0x02, (unsigned char)0xF3, (unsigned char)0x03, (unsigned char)0xF5, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xF2, (unsigned char)0x06, (unsigned char)0xE9, (unsigned char)0xA0, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xEF, (unsigned char)0xF4, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xE1, (unsigned char)0x0B, (unsigned char)0xE8, (unsigned char)0xEB, (unsigned char)0xE5, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xAE, (unsigned char)0xF5, (unsigned char)0xF7, (unsigned char)0x01, (unsigned char)0xEC, (unsigned char)0x02, (unsigned char)0xE4, (unsigned char)0xE7, (unsigned char)0xF2, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0xEF, (unsigned char)0x04, (unsigned char)0xF6, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF9, (unsigned char)0xF3, (unsigned char)0x07, (unsigned char)0xE9, (unsigned char)0xE1, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x80, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xE5, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xA0, (unsigned char)0x1E, (unsigned char)0x1F, (unsigned char)0x9B, (unsigned char)0xA1, (unsigned char)0xAD, (unsigned char)0xE8, (unsigned char)0xEA, (unsigned char)0xF1, (unsigned char)0xF5, (unsigned char)0xFA, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xBA, (unsigned char)0xF8, (unsigned char)0xA7, (unsigned char)0xE2, (unsigned char)0xE9, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xE6, (unsigned char)0xED, (unsigned char)0xE7, (unsigned char)0xEB, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xF6, (unsigned char)0xF0, (unsigned char)0x0A, (unsigned char)0xEF, (unsigned char)0x0B, (unsigned char)0xE3, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0xF9, (unsigned char)0x0F, (unsigned char)0xE4, (unsigned char)0xEC, (unsigned char)0x10, (unsigned char)0xE5, (unsigned char)0x11, (unsigned char)0xF4, (unsigned char)0xF7, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0xE1, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0xEE, (unsigned char)0xF3, (unsigned char)0x17, (unsigned char)0x80, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0xF2, (unsigned char)0x1A, (unsigned char)0x1B, (unsigned char)0xA0, (unsigned char)0x1C, (unsigned char)0x1D, (unsigned char)0xA0, (unsigned char)0x0B, (unsigned char)0xF5, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xEC, (unsigned char)0xF3, (unsigned char)0xF2, (unsigned char)0x80, (unsigned char)0xE1, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xF4, (unsigned char)0xE9, (unsigned char)0xEF, (unsigned char)0xE6, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xE5, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xBA, (unsigned char)0xF9, (unsigned char)0xA7, (unsigned char)0xF4, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xE7, (unsigned char)0xEC, (unsigned char)0x02, (unsigned char)0xEE, (unsigned char)0x03, (unsigned char)0xEF, (unsigned char)0xF5, (unsigned char)0x04, (unsigned char)0xF2, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xE9, (unsigned char)0x07, (unsigned char)0xF3, (unsigned char)0xE1, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xE5, (unsigned char)0x80, (unsigned char)0x0C, (unsigned char)0xE8, (unsigned char)0xA0, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0xE5, (unsigned char)0x0D, (unsigned char)0xE2, (unsigned char)0xF5, (unsigned char)0xF7, (unsigned char)0x9B, (unsigned char)0xEC, (unsigned char)0x01, (unsigned char)0xF9, (unsigned char)0xEE, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xF2, (unsigned char)0x05, (unsigned char)0x80, (unsigned char)0x06, (unsigned char)0xA0, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0x07, (unsigned char)0xF4, (unsigned char)0xE9, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0xA1, (unsigned char)0xF8, (unsigned char)0xE9, (unsigned char)0xEB, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0x9B, (unsigned char)0xFA, (unsigned char)0xE2, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xA0, (unsigned char)0xF0, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xE1, (unsigned char)0x08, (unsigned char)0xE6, (unsigned char)0xF2, (unsigned char)0xED, (unsigned char)0xF6, (unsigned char)0x09, (unsigned char)0xE4, (unsigned char)0x0A, (unsigned char)0xEF, (unsigned char)0xF4, (unsigned char)0xEC, (unsigned char)0xF3, (unsigned char)0xE7, (unsigned char)0xE5, (unsigned char)0x0B, (unsigned char)0xE3, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0xEE, (unsigned char)0x14, (unsigned char)0xEF, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xE1, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xD4, (unsigned char)0xEF, (unsigned char)0xE6, (unsigned char)0xEC, (unsigned char)0xF7, (unsigned char)0xE1, (unsigned char)0x01, (unsigned char)0xBA, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xF9, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xF3, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xE9, (unsigned char)0xA0, (unsigned char)0x09, (unsigned char)0x80, (unsigned char)0xE5, (unsigned char)0x0A, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0xA7, (unsigned char)0xBA, (unsigned char)0xE3, (unsigned char)0xF7, (unsigned char)0xF2, (unsigned char)0xAD, (unsigned char)0xE2, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xE6, (unsigned char)0x03, (unsigned char)0xED, (unsigned char)0xF6, (unsigned char)0x04, (unsigned char)0xEB, (unsigned char)0x05, (unsigned char)0xF4, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xF3, (unsigned char)0x09, (unsigned char)0xF5, (unsigned char)0x0A, (unsigned char)0xEF, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x80, (unsigned char)0xF9, (unsigned char)0xE1, (unsigned char)0x0D, (unsigned char)0xE4, (unsigned char)0xE9, (unsigned char)0xA0, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xEC, (unsigned char)0xE5, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xF9, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0xF3, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xE2, (unsigned char)0xED, (unsigned char)0x80, (unsigned char)0x03, (unsigned char)0xF0, (unsigned char)0xEF, (unsigned char)0x04, (unsigned char)0xA0, (unsigned char)0x05, (unsigned char)0xE9, (unsigned char)0x06, (unsigned char)0xE1, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xE5, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0xE2, (unsigned char)0xEA, (unsigned char)0xF2, (unsigned char)0xE8, (unsigned char)0xEC, (unsigned char)0xED, (unsigned char)0xFA, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xF6, (unsigned char)0x04, (unsigned char)0xBA, (unsigned char)0xE6, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xEB, (unsigned char)0xEF, (unsigned char)0x07, (unsigned char)0xA7, (unsigned char)0xF9, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xE3, (unsigned char)0x0C, (unsigned char)0xEE, (unsigned char)0xE1, (unsigned char)0x0D, (unsigned char)0xF3, (unsigned char)0x0E, (unsigned char)0xE9, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xF4, (unsigned char)0x80, (unsigned char)0xE4, (unsigned char)0xE5, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0xE7, (unsigned char)0xA0, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0x1B, (unsigned char)0x1C, (unsigned char)0xAE, (unsigned char)0xFA, (unsigned char)0xBF, (unsigned char)0x01, (unsigned char)0xA7, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0xE9, (unsigned char)0xF8, (unsigned char)0xF9, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0xE8, (unsigned char)0x04, (unsigned char)0xE1, (unsigned char)0xEB, (unsigned char)0x05, (unsigned char)0xE2, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xE3, (unsigned char)0x08, (unsigned char)0xE7, (unsigned char)0xF4, (unsigned char)0x09, (unsigned char)0x80, (unsigned char)0xF6, (unsigned char)0xF0, (unsigned char)0x0A, (unsigned char)0xE4, (unsigned char)0x0B, (unsigned char)0xF3, (unsigned char)0xF7, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xEF, (unsigned char)0xEC, (unsigned char)0xA0, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xED, (unsigned char)0xE6, (unsigned char)0x10, (unsigned char)0xF5, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xF2, (unsigned char)0x16, (unsigned char)0xEE, (unsigned char)0x17, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xED, (unsigned char)0xA7, (unsigned char)0x9B, (unsigned char)0xE4, (unsigned char)0x01, (unsigned char)0xF9, (unsigned char)0xF3, (unsigned char)0xF2, (unsigned char)0xF4, (unsigned char)0x02, (unsigned char)0xE8, (unsigned char)0x03, (unsigned char)0xEC, (unsigned char)0xF0, (unsigned char)0x04, (unsigned char)0xE1, (unsigned char)0xE9, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x80, (unsigned char)0xA0, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xE5, (unsigned char)0xEF, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0xBA, (unsigned char)0xAC, (unsigned char)0xF6, (unsigned char)0x9B, (unsigned char)0xF0, (unsigned char)0xE2, (unsigned char)0x01, (unsigned char)0xE6, (unsigned char)0x02, (unsigned char)0xA7, (unsigned char)0xAE, (unsigned char)0xE7, (unsigned char)0x03, (unsigned char)0xE3, (unsigned char)0xF5, (unsigned char)0x04, (unsigned char)0xED, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xEB, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xEE, (unsigned char)0xF2, (unsigned char)0x0A, (unsigned char)0xE4, (unsigned char)0x0B, (unsigned char)0xF9, (unsigned char)0xEC, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xF4, (unsigned char)0x80, (unsigned char)0x0E, (unsigned char)0xEF, (unsigned char)0xF3, (unsigned char)0xA0, (unsigned char)0xE1, (unsigned char)0x0F, (unsigned char)0xE9, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xE5, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0xA7, (unsigned char)0xAC, (unsigned char)0xBF, (unsigned char)0xC3, (unsigned char)0xC8, (unsigned char)0xE4, (unsigned char)0xE6, (unsigned char)0xED, (unsigned char)0xF2, (unsigned char)0xAE, (unsigned char)0xEC, (unsigned char)0xEE, (unsigned char)0xF9, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xBA, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xEB, (unsigned char)0xF0, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xE1, (unsigned char)0xE3, (unsigned char)0x0D, (unsigned char)0xE8, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xEF, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xF3, (unsigned char)0x12, (unsigned char)0xE9, (unsigned char)0x13, (unsigned char)0xE5, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xF4, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0xA0, (unsigned char)0x18, (unsigned char)0x80, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xBA, (unsigned char)0xBF, (unsigned char)0xE4, (unsigned char)0xF7, (unsigned char)0x9B, (unsigned char)0xA7, (unsigned char)0x01, (unsigned char)0xEE, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xE3, (unsigned char)0xE2, (unsigned char)0xED, (unsigned char)0x05, (unsigned char)0xF9, (unsigned char)0x06, (unsigned char)0xF4, (unsigned char)0x07, (unsigned char)0xEC, (unsigned char)0x08, (unsigned char)0xF5, (unsigned char)0xF2, (unsigned char)0x09, (unsigned char)0xE1, (unsigned char)0xF3, (unsigned char)0x0A, (unsigned char)0xEF, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xE9, (unsigned char)0x80, (unsigned char)0xE5, (unsigned char)0x0E, (unsigned char)0xA0, (unsigned char)0x0F, (unsigned char)0xE8, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0xEB, (unsigned char)0xFA, (unsigned char)0x80, (unsigned char)0xE6, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xA0, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE9, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0xE4, (unsigned char)0xF0, (unsigned char)0xED, (unsigned char)0xE2, (unsigned char)0xE3, (unsigned char)0xE7, (unsigned char)0xEC, (unsigned char)0x05, (unsigned char)0xE5, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xF4, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xF3, (unsigned char)0xEE, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0xF2, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x04, (unsigned char)0xE5, (unsigned char)0xF3, (unsigned char)0xEF, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xE1, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE9, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xA7, (unsigned char)0xE2, (unsigned char)0xEC, (unsigned char)0xE3, (unsigned char)0xF2, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xE9, (unsigned char)0xEF, (unsigned char)0xEE, (unsigned char)0xE5, (unsigned char)0xE1, (unsigned char)0x80, (unsigned char)0x05, (unsigned char)0xA0, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xF3, (unsigned char)0x0A, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0xE9, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0xF0, (unsigned char)0x02, (unsigned char)0xF4, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xA0, (unsigned char)0x13, (unsigned char)0xE3, (unsigned char)0xAD, (unsigned char)0xE4, (unsigned char)0xE9, (unsigned char)0xEE, (unsigned char)0xEF, (unsigned char)0xF0, (unsigned char)0xF4, (unsigned char)0xF6, (unsigned char)0xA1, (unsigned char)0xE1, (unsigned char)0xED, (unsigned char)0x01, (unsigned char)0xE2, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xA7, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF7, (unsigned char)0x07, (unsigned char)0x9B, (unsigned char)0xEC, (unsigned char)0x08, (unsigned char)0xE5, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0xF3, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0x80, (unsigned char)0x12, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xE5, (unsigned char)0xFA, (unsigned char)0xA0, (unsigned char)0xF9, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0x80, (unsigned char)0xE9, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B };
// huffman2bo
// file standard/atsc/atsctext.c line 204
static unsigned int huffman2bo[128l] = { (unsigned int)0x0000, (unsigned int)0x002C, (unsigned int)0x002E, (unsigned int)0x0030, (unsigned int)0x0032, (unsigned int)0x0034, (unsigned int)0x0036, (unsigned int)0x0038, (unsigned int)0x003A, (unsigned int)0x003C, (unsigned int)0x003E, (unsigned int)0x0040, (unsigned int)0x0042, (unsigned int)0x0044, (unsigned int)0x0046, (unsigned int)0x0048, (unsigned int)0x004A, (unsigned int)0x004C, (unsigned int)0x004E, (unsigned int)0x0050, (unsigned int)0x0052, (unsigned int)0x0054, (unsigned int)0x0056, (unsigned int)0x0058, (unsigned int)0x005A, (unsigned int)0x005C, (unsigned int)0x005E, (unsigned int)0x0060, (unsigned int)0x0062, (unsigned int)0x0064, (unsigned int)0x0066, (unsigned int)0x0068, (unsigned int)0x006A, (unsigned int)0x00DE, (unsigned int)0x00E0, (unsigned int)0x00EA, (unsigned int)0x00EC, (unsigned int)0x00EE, (unsigned int)0x00F0, (unsigned int)0x00F2, (unsigned int)0x00F8, (unsigned int)0x00FA, (unsigned int)0x00FC, (unsigned int)0x00FE, (unsigned int)0x0100, (unsigned int)0x0104, (unsigned int)0x0116, (unsigned int)0x0120, (unsigned int)0x0122, (unsigned int)0x012C, (unsigned int)0x0132, (unsigned int)0x0138, (unsigned int)0x013C, (unsigned int)0x0140, (unsigned int)0x0144, (unsigned int)0x0146, (unsigned int)0x014A, (unsigned int)0x014C, (unsigned int)0x0154, (unsigned int)0x0156, (unsigned int)0x0158, (unsigned int)0x015A, (unsigned int)0x015C, (unsigned int)0x015E, (unsigned int)0x0160, (unsigned int)0x0162, (unsigned int)0x0176, (unsigned int)0x0184, (unsigned int)0x0194, (unsigned int)0x01A2, (unsigned int)0x01B2, (unsigned int)0x01BA, (unsigned int)0x01C8, (unsigned int)0x01D2, (unsigned int)0x01DE, (unsigned int)0x01EA, (unsigned int)0x01F2, (unsigned int)0x01FC, (unsigned int)0x0208, (unsigned int)0x0210, (unsigned int)0x021A, (unsigned int)0x0228, (unsigned int)0x022A, (unsigned int)0x0234, (unsigned int)0x024A, (unsigned int)0x025A, (unsigned int)0x025E, (unsigned int)0x0264, (unsigned int)0x026E, (unsigned int)0x0270, (unsigned int)0x0272, (unsigned int)0x0274, (unsigned int)0x0276, (unsigned int)0x0278, (unsigned int)0x027A, (unsigned int)0x027C, (unsigned int)0x027E, (unsigned int)0x0280, (unsigned int)0x02B4, (unsigned int)0x02CE, (unsigned int)0x02F0, (unsigned int)0x031A, (unsigned int)0x0358, (unsigned int)0x036E, (unsigned int)0x038E, (unsigned int)0x03AC, (unsigned int)0x03D8, (unsigned int)0x03E0, (unsigned int)0x03F4, (unsigned int)0x0424, (unsigned int)0x0440, (unsigned int)0x0476, (unsigned int)0x04AE, (unsigned int)0x04CE, (unsigned int)0x04D0, (unsigned int)0x0506, (unsigned int)0x0534, (unsigned int)0x0560, (unsigned int)0x0586, (unsigned int)0x0592, (unsigned int)0x05AA, (unsigned int)0x05B8, (unsigned int)0x05DC, (unsigned int)0x05EC, (unsigned int)0x05EE, (unsigned int)0x05F0, (unsigned int)0x05F2, (unsigned int)0x05F4 };
// huffman2co
// file standard/atsc/atsctext.c line 225
static unsigned char huffman2co[1526l] = { (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x9B, (unsigned char)0xD6, (unsigned char)0xC9, (unsigned char)0xCF, (unsigned char)0xD7, (unsigned char)0xC7, (unsigned char)0x01, (unsigned char)0xA2, (unsigned char)0xCE, (unsigned char)0xCB, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xC5, (unsigned char)0xCC, (unsigned char)0xC6, (unsigned char)0xC8, (unsigned char)0x04, (unsigned char)0xC4, (unsigned char)0x05, (unsigned char)0xC2, (unsigned char)0x06, (unsigned char)0xC3, (unsigned char)0xD2, (unsigned char)0x07, (unsigned char)0xD3, (unsigned char)0x08, (unsigned char)0xCA, (unsigned char)0xD4, (unsigned char)0x09, (unsigned char)0xCD, (unsigned char)0xD0, (unsigned char)0x0A, (unsigned char)0xC1, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x38, (unsigned char)0x39, (unsigned char)0xAD, (unsigned char)0xAF, (unsigned char)0xB7, (unsigned char)0xDA, (unsigned char)0xA8, (unsigned char)0xB3, (unsigned char)0xB5, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xB4, (unsigned char)0xF1, (unsigned char)0xA2, (unsigned char)0xD5, (unsigned char)0xD6, (unsigned char)0xD9, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xCF, (unsigned char)0x06, (unsigned char)0xC9, (unsigned char)0xF9, (unsigned char)0xEA, (unsigned char)0xEB, (unsigned char)0xF5, (unsigned char)0xF6, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xB2, (unsigned char)0xC5, (unsigned char)0xC6, (unsigned char)0xB1, (unsigned char)0x0A, (unsigned char)0xEE, (unsigned char)0xCB, (unsigned char)0x0B, (unsigned char)0xD4, (unsigned char)0x0C, (unsigned char)0xC4, (unsigned char)0xC8, (unsigned char)0xD2, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xC7, (unsigned char)0xCA, (unsigned char)0xCE, (unsigned char)0xD0, (unsigned char)0xD7, (unsigned char)0x10, (unsigned char)0xC2, (unsigned char)0x11, (unsigned char)0xCC, (unsigned char)0xEC, (unsigned char)0xE5, (unsigned char)0xE7, (unsigned char)0x12, (unsigned char)0xCD, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0xC3, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0xED, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0xF2, (unsigned char)0x1A, (unsigned char)0xD3, (unsigned char)0x1B, (unsigned char)0x1C, (unsigned char)0xE4, (unsigned char)0x1D, (unsigned char)0xC1, (unsigned char)0xE3, (unsigned char)0x1E, (unsigned char)0xE9, (unsigned char)0xF0, (unsigned char)0xE2, (unsigned char)0xF7, (unsigned char)0x1F, (unsigned char)0xF3, (unsigned char)0xE6, (unsigned char)0x20, (unsigned char)0x21, (unsigned char)0x22, (unsigned char)0xE8, (unsigned char)0xEF, (unsigned char)0x23, (unsigned char)0x24, (unsigned char)0x25, (unsigned char)0x26, (unsigned char)0x27, (unsigned char)0x28, (unsigned char)0x29, (unsigned char)0x2A, (unsigned char)0xF4, (unsigned char)0x2B, (unsigned char)0x2C, (unsigned char)0x2D, (unsigned char)0x2E, (unsigned char)0x2F, (unsigned char)0xE1, (unsigned char)0x30, (unsigned char)0x31, (unsigned char)0x32, (unsigned char)0x33, (unsigned char)0x34, (unsigned char)0x35, (unsigned char)0x36, (unsigned char)0x37, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0xAE, (unsigned char)0xC8, (unsigned char)0xD4, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0xF3, (unsigned char)0xA0, (unsigned char)0xF4, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xAC, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0xA2, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xE2, (unsigned char)0xE4, (unsigned char)0xE5, (unsigned char)0xE6, (unsigned char)0xA0, (unsigned char)0xF2, (unsigned char)0xE1, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xF3, (unsigned char)0xE3, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0x06, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0xCA, (unsigned char)0xD3, (unsigned char)0xA2, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0xB7, (unsigned char)0xF4, (unsigned char)0xA0, (unsigned char)0xB0, (unsigned char)0xF3, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xB9, (unsigned char)0x02, (unsigned char)0xB8, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x01, (unsigned char)0xAE, (unsigned char)0x02, (unsigned char)0xB6, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xA0, (unsigned char)0xA0, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xB0, (unsigned char)0xAE, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0xAE, (unsigned char)0x01, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xAC, (unsigned char)0xAE, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0xB5, (unsigned char)0xB6, (unsigned char)0xB8, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xE6, (unsigned char)0xF5, (unsigned char)0xF3, (unsigned char)0xF4, (unsigned char)0x9B, (unsigned char)0xE4, (unsigned char)0x01, (unsigned char)0xED, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xF2, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xEC, (unsigned char)0xEE, (unsigned char)0x07, (unsigned char)0xA0, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x9B, (unsigned char)0xEC, (unsigned char)0xF5, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0xE5, (unsigned char)0xE9, (unsigned char)0xF2, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x9B, (unsigned char)0xE9, (unsigned char)0xF9, (unsigned char)0xF2, (unsigned char)0xF5, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xEC, (unsigned char)0xEF, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0xE8, (unsigned char)0x05, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF9, (unsigned char)0xF2, (unsigned char)0xF5, (unsigned char)0x9B, (unsigned char)0xE5, (unsigned char)0xEF, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xE9, (unsigned char)0xE1, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xE1, (unsigned char)0xE9, (unsigned char)0xEE, (unsigned char)0xF6, (unsigned char)0xE4, (unsigned char)0xEC, (unsigned char)0xF3, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xF2, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0x05, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0xEC, (unsigned char)0x9B, (unsigned char)0xEF, (unsigned char)0x01, (unsigned char)0xF2, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF5, (unsigned char)0xEF, (unsigned char)0x9B, (unsigned char)0xEC, (unsigned char)0xE9, (unsigned char)0x01, (unsigned char)0xE1, (unsigned char)0xF2, (unsigned char)0x02, (unsigned char)0xE5, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0xE5, (unsigned char)0xE9, (unsigned char)0xF5, (unsigned char)0xE1, (unsigned char)0x01, (unsigned char)0xEF, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xA0, (unsigned char)0xC9, (unsigned char)0xF3, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0xF2, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xEE, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0xE9, (unsigned char)0xE5, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xE5, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0xE9, (unsigned char)0xF2, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0xE9, (unsigned char)0xF5, (unsigned char)0x01, (unsigned char)0xE5, (unsigned char)0x02, (unsigned char)0xEF, (unsigned char)0xE1, (unsigned char)0xE1, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0xE3, (unsigned char)0xEF, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0xE5, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE9, (unsigned char)0x04, (unsigned char)0xE5, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0xE9, (unsigned char)0x01, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xA7, (unsigned char)0xEE, (unsigned char)0xEC, (unsigned char)0xF2, (unsigned char)0xF3, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0x06, (unsigned char)0x9B, (unsigned char)0xE8, (unsigned char)0xE9, (unsigned char)0x01, (unsigned char)0xF2, (unsigned char)0xEC, (unsigned char)0x02, (unsigned char)0xEF, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0x01, (unsigned char)0xE9, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0xEF, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xF6, (unsigned char)0xF9, (unsigned char)0x01, (unsigned char)0xAE, (unsigned char)0xE3, (unsigned char)0xE9, (unsigned char)0xF5, (unsigned char)0x9B, (unsigned char)0xE5, (unsigned char)0xEF, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0xE8, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF4, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xE8, (unsigned char)0x07, (unsigned char)0xE5, (unsigned char)0xF7, (unsigned char)0xD6, (unsigned char)0xE1, (unsigned char)0x9B, (unsigned char)0xE9, (unsigned char)0xF2, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xAE, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xEE, (unsigned char)0xE9, (unsigned char)0x02, (unsigned char)0xE5, (unsigned char)0x9B, (unsigned char)0xA0, (unsigned char)0x01, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x9B, (unsigned char)0xE8, (unsigned char)0xE5, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0x01, (unsigned char)0xE9, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0xEF, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0xE8, (unsigned char)0xEF, (unsigned char)0xF8, (unsigned char)0x9B, (unsigned char)0xA7, (unsigned char)0xF7, (unsigned char)0xFA, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xE5, (unsigned char)0xAE, (unsigned char)0x05, (unsigned char)0xE6, (unsigned char)0xE2, (unsigned char)0x06, (unsigned char)0xF6, (unsigned char)0xEB, (unsigned char)0xF5, (unsigned char)0xE9, (unsigned char)0x07, (unsigned char)0xF0, (unsigned char)0xF9, (unsigned char)0xE7, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xE4, (unsigned char)0x0A, (unsigned char)0xE3, (unsigned char)0x0B, (unsigned char)0xED, (unsigned char)0x0C, (unsigned char)0xF3, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xEC, (unsigned char)0x10, (unsigned char)0xF4, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0xF2, (unsigned char)0xA0, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xEE, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xE4, (unsigned char)0xF3, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0xE2, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xEC, (unsigned char)0xA0, (unsigned char)0x04, (unsigned char)0xE9, (unsigned char)0xF2, (unsigned char)0xF5, (unsigned char)0x05, (unsigned char)0xF9, (unsigned char)0xE1, (unsigned char)0x06, (unsigned char)0xEF, (unsigned char)0x07, (unsigned char)0xE5, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xF1, (unsigned char)0xAE, (unsigned char)0xC4, (unsigned char)0xF9, (unsigned char)0xAC, (unsigned char)0x01, (unsigned char)0xE3, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xF2, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xA0, (unsigned char)0xEC, (unsigned char)0xF5, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xE9, (unsigned char)0x07, (unsigned char)0xEB, (unsigned char)0x08, (unsigned char)0xF4, (unsigned char)0x09, (unsigned char)0xE5, (unsigned char)0x0A, (unsigned char)0xEF, (unsigned char)0xE1, (unsigned char)0xE8, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0xA7, (unsigned char)0xBB, (unsigned char)0xE6, (unsigned char)0xED, (unsigned char)0xF7, (unsigned char)0xE7, (unsigned char)0xF6, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xEE, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xEC, (unsigned char)0x05, (unsigned char)0xF5, (unsigned char)0x06, (unsigned char)0xAC, (unsigned char)0xE4, (unsigned char)0xF9, (unsigned char)0xF2, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xAE, (unsigned char)0x0A, (unsigned char)0xEF, (unsigned char)0x0B, (unsigned char)0xE1, (unsigned char)0xF3, (unsigned char)0x0C, (unsigned char)0xE9, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xE5, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0xA0, (unsigned char)0x1D, (unsigned char)0x1E, (unsigned char)0xA9, (unsigned char)0xE8, (unsigned char)0xF5, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xAD, (unsigned char)0xBB, (unsigned char)0xEB, (unsigned char)0xFA, (unsigned char)0x02, (unsigned char)0xA7, (unsigned char)0xE6, (unsigned char)0xE2, (unsigned char)0xE7, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xE9, (unsigned char)0xF8, (unsigned char)0x07, (unsigned char)0xAC, (unsigned char)0xEF, (unsigned char)0xF0, (unsigned char)0x08, (unsigned char)0xED, (unsigned char)0xF6, (unsigned char)0xF9, (unsigned char)0x09, (unsigned char)0xF7, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xAE, (unsigned char)0x0C, (unsigned char)0xE3, (unsigned char)0x0D, (unsigned char)0xE5, (unsigned char)0xF4, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xE4, (unsigned char)0x10, (unsigned char)0xEC, (unsigned char)0x11, (unsigned char)0xE1, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0xEE, (unsigned char)0xF3, (unsigned char)0x17, (unsigned char)0x18, (unsigned char)0xF2, (unsigned char)0xA0, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0x1B, (unsigned char)0x1C, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xAE, (unsigned char)0x9B, (unsigned char)0xEC, (unsigned char)0x01, (unsigned char)0xF5, (unsigned char)0x02, (unsigned char)0xF4, (unsigned char)0xE6, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0xE9, (unsigned char)0x04, (unsigned char)0xF2, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xA0, (unsigned char)0x08, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xAD, (unsigned char)0xE7, (unsigned char)0x9B, (unsigned char)0xA7, (unsigned char)0xF9, (unsigned char)0x01, (unsigned char)0xEC, (unsigned char)0x02, (unsigned char)0xAC, (unsigned char)0xF2, (unsigned char)0x03, (unsigned char)0xAE, (unsigned char)0xF3, (unsigned char)0xF5, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xEF, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xE9, (unsigned char)0xE1, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xE8, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xE5, (unsigned char)0x0C, (unsigned char)0xA0, (unsigned char)0x0D, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0xA7, (unsigned char)0xAC, (unsigned char)0xF3, (unsigned char)0xAD, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x9B, (unsigned char)0xF9, (unsigned char)0xF5, (unsigned char)0xAE, (unsigned char)0x03, (unsigned char)0xEE, (unsigned char)0x04, (unsigned char)0xF2, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xF4, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xEF, (unsigned char)0xE1, (unsigned char)0xA0, (unsigned char)0x0A, (unsigned char)0xE9, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xE5, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xAC, (unsigned char)0xE2, (unsigned char)0xF8, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0xFA, (unsigned char)0x01, (unsigned char)0xEB, (unsigned char)0x02, (unsigned char)0xA0, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xF0, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xE6, (unsigned char)0xF6, (unsigned char)0x07, (unsigned char)0xE4, (unsigned char)0xED, (unsigned char)0xE7, (unsigned char)0x08, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0xF2, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xEC, (unsigned char)0x0C, (unsigned char)0xE5, (unsigned char)0xE3, (unsigned char)0x0D, (unsigned char)0xF4, (unsigned char)0x0E, (unsigned char)0xF3, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xEE, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x03, (unsigned char)0xEF, (unsigned char)0x9B, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0xF5, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xEC, (unsigned char)0xF9, (unsigned char)0xA7, (unsigned char)0xEE, (unsigned char)0x01, (unsigned char)0xAC, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xF3, (unsigned char)0x05, (unsigned char)0xE9, (unsigned char)0x06, (unsigned char)0xA0, (unsigned char)0x07, (unsigned char)0xE5, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0xA7, (unsigned char)0xAD, (unsigned char)0xEE, (unsigned char)0xE3, (unsigned char)0xEB, (unsigned char)0xF2, (unsigned char)0x9B, (unsigned char)0xE2, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xF5, (unsigned char)0x03, (unsigned char)0xF4, (unsigned char)0xAC, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xE6, (unsigned char)0xED, (unsigned char)0xF6, (unsigned char)0x06, (unsigned char)0xAE, (unsigned char)0xF0, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xF3, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xE4, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xF9, (unsigned char)0x0D, (unsigned char)0xEF, (unsigned char)0x0E, (unsigned char)0xE1, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xE9, (unsigned char)0xEC, (unsigned char)0x11, (unsigned char)0xA0, (unsigned char)0xE5, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xA7, (unsigned char)0xBB, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xF9, (unsigned char)0xAE, (unsigned char)0xE2, (unsigned char)0x02, (unsigned char)0xED, (unsigned char)0xF3, (unsigned char)0x03, (unsigned char)0xF5, (unsigned char)0xEF, (unsigned char)0xF0, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xE9, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xA0, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0xAD, (unsigned char)0xBB, (unsigned char)0xE2, (unsigned char)0xEA, (unsigned char)0xED, (unsigned char)0xF2, (unsigned char)0xFA, (unsigned char)0xE6, (unsigned char)0xEC, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0x04, (unsigned char)0xA7, (unsigned char)0xF6, (unsigned char)0xF9, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xEB, (unsigned char)0xEF, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xAC, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xE3, (unsigned char)0xAE, (unsigned char)0x0D, (unsigned char)0xEE, (unsigned char)0xE9, (unsigned char)0x0E, (unsigned char)0xE1, (unsigned char)0x0F, (unsigned char)0xF3, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xF4, (unsigned char)0x12, (unsigned char)0xE7, (unsigned char)0xE5, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0xE4, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0xA0, (unsigned char)0x18, (unsigned char)0x1A, (unsigned char)0x1B, (unsigned char)0xC2, (unsigned char)0x9B, (unsigned char)0xAD, (unsigned char)0xAC, (unsigned char)0xF8, (unsigned char)0x01, (unsigned char)0xAE, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0xE7, (unsigned char)0xE8, (unsigned char)0xF9, (unsigned char)0xE9, (unsigned char)0xEB, (unsigned char)0x04, (unsigned char)0xE3, (unsigned char)0xE1, (unsigned char)0x05, (unsigned char)0xF6, (unsigned char)0x06, (unsigned char)0xE4, (unsigned char)0x07, (unsigned char)0xE2, (unsigned char)0xF0, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xF3, (unsigned char)0xF4, (unsigned char)0xF7, (unsigned char)0xEF, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xEC, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xF5, (unsigned char)0xED, (unsigned char)0x11, (unsigned char)0xE6, (unsigned char)0xA0, (unsigned char)0x12, (unsigned char)0xF2, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xEE, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0x18, (unsigned char)0x19, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xAD, (unsigned char)0xED, (unsigned char)0xF9, (unsigned char)0x9B, (unsigned char)0xAE, (unsigned char)0x01, (unsigned char)0xF3, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xF5, (unsigned char)0xF4, (unsigned char)0xF0, (unsigned char)0x04, (unsigned char)0xEF, (unsigned char)0x05, (unsigned char)0xE9, (unsigned char)0x06, (unsigned char)0xE8, (unsigned char)0xA0, (unsigned char)0xE1, (unsigned char)0xEC, (unsigned char)0x07, (unsigned char)0xF2, (unsigned char)0x08, (unsigned char)0xE5, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x9B, (unsigned char)0xF5, (unsigned char)0x19, (unsigned char)0x1A, (unsigned char)0xA9, (unsigned char)0xBB, (unsigned char)0xF6, (unsigned char)0xE6, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xAD, (unsigned char)0xE2, (unsigned char)0xF0, (unsigned char)0x02, (unsigned char)0xA7, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xF5, (unsigned char)0xE3, (unsigned char)0xAC, (unsigned char)0xE7, (unsigned char)0xF2, (unsigned char)0x06, (unsigned char)0xEB, (unsigned char)0x07, (unsigned char)0xEC, (unsigned char)0xED, (unsigned char)0xEE, (unsigned char)0xF9, (unsigned char)0x08, (unsigned char)0xAE, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xE4, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0xF4, (unsigned char)0x0D, (unsigned char)0xF3, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0xE1, (unsigned char)0xEF, (unsigned char)0x11, (unsigned char)0xE9, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0xE5, (unsigned char)0x14, (unsigned char)0xA0, (unsigned char)0x15, (unsigned char)0x16, (unsigned char)0x17, (unsigned char)0x18, (unsigned char)0xA0, (unsigned char)0x16, (unsigned char)0xA2, (unsigned char)0xA7, (unsigned char)0xE2, (unsigned char)0xEB, (unsigned char)0xED, (unsigned char)0xEE, (unsigned char)0x9B, (unsigned char)0xF7, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xBB, (unsigned char)0xF9, (unsigned char)0xF0, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xEC, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xF5, (unsigned char)0xE1, (unsigned char)0x09, (unsigned char)0xAC, (unsigned char)0xE3, (unsigned char)0x0A, (unsigned char)0xE8, (unsigned char)0x0B, (unsigned char)0xE9, (unsigned char)0x0C, (unsigned char)0xEF, (unsigned char)0xF3, (unsigned char)0xAE, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0xE5, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x11, (unsigned char)0xF4, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0x14, (unsigned char)0x15, (unsigned char)0xBB, (unsigned char)0xE2, (unsigned char)0xAD, (unsigned char)0xED, (unsigned char)0x01, (unsigned char)0x9B, (unsigned char)0xA7, (unsigned char)0xE3, (unsigned char)0xAC, (unsigned char)0xEC, (unsigned char)0xEE, (unsigned char)0x02, (unsigned char)0xF7, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xF9, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xF4, (unsigned char)0xAE, (unsigned char)0xF5, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xF2, (unsigned char)0xE1, (unsigned char)0xF3, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0xE9, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0xEF, (unsigned char)0xE5, (unsigned char)0x10, (unsigned char)0xA0, (unsigned char)0xE8, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0x13, (unsigned char)0x11, (unsigned char)0x12, (unsigned char)0xEF, (unsigned char)0xF6, (unsigned char)0x9B, (unsigned char)0xEB, (unsigned char)0xF9, (unsigned char)0x01, (unsigned char)0xA0, (unsigned char)0xE2, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0x03, (unsigned char)0xED, (unsigned char)0x04, (unsigned char)0xE3, (unsigned char)0xE9, (unsigned char)0x05, (unsigned char)0xE4, (unsigned char)0xE5, (unsigned char)0xE7, (unsigned char)0x06, (unsigned char)0xEC, (unsigned char)0xF0, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xF3, (unsigned char)0x0C, (unsigned char)0xF4, (unsigned char)0xEE, (unsigned char)0x0D, (unsigned char)0xF2, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x05, (unsigned char)0xE5, (unsigned char)0xF3, (unsigned char)0xF9, (unsigned char)0x9B, (unsigned char)0x01, (unsigned char)0xEF, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0xE1, (unsigned char)0x04, (unsigned char)0xE9, (unsigned char)0x0A, (unsigned char)0x0B, (unsigned char)0xAE, (unsigned char)0x9B, (unsigned char)0xEC, (unsigned char)0xED, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xF3, (unsigned char)0xEE, (unsigned char)0xF2, (unsigned char)0x03, (unsigned char)0xE5, (unsigned char)0x04, (unsigned char)0xE8, (unsigned char)0xA0, (unsigned char)0xE1, (unsigned char)0x05, (unsigned char)0xEF, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x08, (unsigned char)0xE9, (unsigned char)0x09, (unsigned char)0x05, (unsigned char)0x06, (unsigned char)0xA0, (unsigned char)0xAC, (unsigned char)0xAD, (unsigned char)0xF4, (unsigned char)0xE9, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0x03, (unsigned char)0x9B, (unsigned char)0x04, (unsigned char)0x11, (unsigned char)0xA0, (unsigned char)0xBF, (unsigned char)0xE1, (unsigned char)0xE2, (unsigned char)0xE6, (unsigned char)0xED, (unsigned char)0xE4, (unsigned char)0xE9, (unsigned char)0xF7, (unsigned char)0xA7, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0xBB, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0xEC, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0xEE, (unsigned char)0x06, (unsigned char)0xEF, (unsigned char)0x07, (unsigned char)0xAC, (unsigned char)0xE5, (unsigned char)0xF3, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0x0A, (unsigned char)0xAE, (unsigned char)0x0B, (unsigned char)0x0C, (unsigned char)0x0D, (unsigned char)0x0E, (unsigned char)0x0F, (unsigned char)0x10, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0xA0, (unsigned char)0xAE, (unsigned char)0xE1, (unsigned char)0xE5, (unsigned char)0xEC, (unsigned char)0xFA, (unsigned char)0x9B, (unsigned char)0xEF, (unsigned char)0xE9, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B, (unsigned char)0x9B };
// infoStreamerName
// file remoteintf.c line 127
static char *infoStreamerName;
// initCount
// file standard/atsc/psipprocessor.c line 85
static signed int initCount = 0;
// inversionMapping
// file dvbadapter.c line 304
static struct StringToParamMapping_s inversionMapping[4l] = { { .str="OFF", .param=(unsigned int)0 }, { .str="ON", .param=(unsigned int)1 }, { .str="AUTO", .param=(unsigned int)2 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// jobQ
// file threading/deferredproc.c line 53
static struct MessageQ_s *jobQ = (struct MessageQ_s *)(void *)0;
// lnbPropertyParent
// file dvbadapter.c line 259
static const char lnbPropertyParent[12l] = { 'a', 'd', 'a', 'p', 't', 'e', 'r', '.', 'l', 'n', 'b', 0 };
// lockMutex
// file tuning.c line 49
static union anonymous_14 lockMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// lockTimeoutC
// file commands/cmd_scanning.c line 272
static signed int lockTimeoutC = 60;
// lockTimeoutS
// file commands/cmd_scanning.c line 271
static signed int lockTimeoutS = 60;
// lockTimeoutT
// file commands/cmd_scanning.c line 270
static signed int lockTimeoutT = 30;
// locked
// file tuning.c line 50
static _Bool locked = (_Bool)0;
// lockedEvent
// file dvbadapter.c line 262
static struct Event_s *lockedEvent;
// logFP
// file logging.c line 76
static struct _IO_FILE *logFP = (struct _IO_FILE *)(void *)0;
// mgtEvent
// file standard/atsc/psipprocessor.c line 88
static struct Event_s *mgtEvent = (struct Event_s *)(void *)0;
// modulationMapping
// file dvbadapter.c line 285
static struct StringToParamMapping_s modulationMapping[22l] = { { .str="QPSK", .param=(unsigned int)0 },
    { .str="QAM16", .param=(unsigned int)1 },
    { .str="16QAM", .param=(unsigned int)1 },
    { .str="QAM32", .param=(unsigned int)2 },
    { .str="32QAM", .param=(unsigned int)2 },
    { .str="QAM64", .param=(unsigned int)3 },
    { .str="64QAM", .param=(unsigned int)3 },
    { .str="QAM128", .param=(unsigned int)4 },
    { .str="128QAM", .param=(unsigned int)4 },
    { .str="QAM256", .param=(unsigned int)5 },
    { .str="256QAM", .param=(unsigned int)5 },
    { .str="AUTO", .param=(unsigned int)6 },
    { .str="8VSB", .param=(unsigned int)7 },
    { .str="16VSB", .param=(unsigned int)8 },
    { .str="8PSK", .param=(unsigned int)9 },
    { .str="PSK8", .param=(unsigned int)9 },
    { .str="16APSK", .param=(unsigned int)10 },
    { .str="APSK16", .param=(unsigned int)10 },
    { .str="32APSK", .param=(unsigned int)11 },
    { .str="APSK32", .param=(unsigned int)11 },
    { .str="DQPSK", .param=(unsigned int)12 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// moduleLevels
// file logging.c line 78
static struct ModuleLevel_s *moduleLevels = (struct ModuleLevel_s *)(void *)0;
// mulitplexChangedEvent
// file tuning.c line 47
static struct Event_s *mulitplexChangedEvent;
// multiplexAddedEvent
// file multiplexes.c line 53
static struct Event_s *multiplexAddedEvent;
// multiplexRemovedEvent
// file multiplexes.c line 54
static struct Event_s *multiplexRemovedEvent;
// multiplexSource
// file multiplexes.c line 52
static struct EventSource_s *multiplexSource;
// mutex
// file logging.c line 75
static union anonymous_14 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mutex_link1
// file standard/atsc/atsctext.c line 331
static union anonymous_14 mutex_link1 = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// nitEvent
// file standard/dvb/nitprocessor.c line 60
static struct Event_s *nitEvent = (struct Event_s *)(void *)0;
// nitProcessor
// file standard/dvb/dvb.c line 42
static struct NITProcessor_s *nitProcessor = (struct NITProcessor_s *)(void *)0;
// nullInstanceOps
// file deliverymethod.c line 53
static struct DeliveryMethodInstanceOps_t nullInstanceOps;
// nullInstanceOps
// file deliverymethod.c line 53
static struct DeliveryMethodInstanceOps_t nullInstanceOps = { .OutputPacket=(void (*)(struct DeliveryMethodInstance_t *, struct TSPacket_t *))(void *)0, .OutputBlock=(void (*)(struct DeliveryMethodInstance_t *, void *, unsigned long int))(void *)0,
    .DestroyInstance=NullOutputDestroy,
    .ReserveHeaderSpace=(void (*)(struct DeliveryMethodInstance_t *, signed int))(void *)0, .SetHeader=(void (*)(struct DeliveryMethodInstance_t *, struct TSPacket_t *, signed int))(void *)0 };
// objectMutex
// file objects.c line 96
static union anonymous_14 objectMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=1, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ofdmCodeRateTable
// file commands/cmd_scanning.c line 250
static char *ofdmCodeRateTable[8l] = { "1/2", "2/3", "3/4", "4/5", "5/6", "7/8", "NONE", "NONE" };
// ofdmConstellationTable
// file commands/cmd_scanning.c line 251
static char *ofdmConstellationTable[4l] = { "QPSK", "16QAM", "64QAM", "AUTO" };
// ofdmGuardIntTable
// file commands/cmd_scanning.c line 253
static char *ofdmGuardIntTable[4l] = { "1/32", "1/16", "1/8", "1/4" };
// ofdmHierarchyTable
// file commands/cmd_scanning.c line 252
static char *ofdmHierarchyTable[8l] = { "NONE", "1", "2", "4", "NONE", "1", "2", "4" };
// ofdmTransmitModeTable
// file commands/cmd_scanning.c line 254
static char *ofdmTransmitModeTable[4l] = { "2000", "8000", "AUTO", "AUTO" };
// offsetsFromUTF8
// file utf8.c line 32
static const unsigned int offsetsFromUTF8[6l] = { (const unsigned int)0x00000000UL, (const unsigned int)0x00003080UL, (const unsigned int)0x000E2080UL, (const unsigned int)0x03C82080UL, (const unsigned int)0xFA082080UL, (const unsigned int)0x82082080UL };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// patEvent
// file standard/mpeg2/patprocessor.c line 62
static struct Event_s *patEvent = (struct Event_s *)(void *)0;
// patProcessor
// file standard/mpeg2/mpeg2.c line 43
static struct PATProcessor_s *patProcessor;
// pidsUpdatedEvent
// file cache.c line 173
static struct Event_s *pidsUpdatedEvent;
// pilotMapping
// file dvbadapter.c line 380
static struct StringToParamMapping_s pilotMapping[4l] = { { .str="ON", .param=(unsigned int)0 }, { .str="OFF", .param=(unsigned int)1 }, { .str="AUTO", .param=(unsigned int)2 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// pluginFeatures
// file pluginmgr.c line 94
struct PluginFeatureInfo_t pluginFeatures[12l] = { { .feature=0x01, .name="PLUGIN_FEATURE_TYPE_EVENT_LISTENER" },
    { .feature=0x02, .name="PLUGIN_FEATURE_TYPE_PATPROCESSOR" },
    { .feature=0x03, .name="PLUGIN_FEATURE_TYPE_PMTPROCESSOR" },
    { .feature=0x04, .name="PLUGIN_FEATURE_TYPE_DELIVERYMETHOD" },
    { .feature=0x05, .name="PLUGIN_FEATURE_TYPE_SDTPROCESSOR" },
    { .feature=0x06, .name="PLUGIN_FEATURE_TYPE_NITPROCESSOR" },
    { .feature=0x07, .name="PLUGIN_FEATURE_TYPE_TDTPROCESSOR" },
    { .feature=0xFF, .name="PLUGIN_FEATURE_TYPE_INSTALL" },
    { .feature=0x08, .name="PLUGIN_FEATURE_TYPE_MGTPROCESSOR" },
    { .feature=0x09, .name="PLUGIN_FEATURE_TYPE_STTPROCESSOR" },
    { .feature=0x0A, .name="PLUGIN_FEATURE_TYPE_VCTPROCESSOR" },
    { .feature=0x00, .name="PLUGIN_FEATURE_TYPE_NONE" } };
// pmtEvent
// file standard/mpeg2/pmtprocessor.c line 72
static struct Event_s *pmtEvent = (struct Event_s *)(void *)0;
// pmtProcessor
// file standard/mpeg2/mpeg2.c line 44
static struct PMTProcessor_s *pmtProcessor;
// polarisationMapping
// file dvbadapter.c line 363
static struct StringToParamMapping_s polarisationMapping[5l] = { { .str="Horizontal", .param=(unsigned int)0 },
    { .str="Vertical", .param=(unsigned int)1 },
    { .str="Left", .param=(unsigned int)0 },
    { .str="Right", .param=(unsigned int)1 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// polarisationTable
// file commands/cmd_scanning.c line 257
static char *polarisationTable[4l] = { "Horizontal", "Vertical", "Left", "Right" };
// previousScanState
// file commands/cmd_scanning.c line 300
static enum ScanState_e previousScanState = (enum ScanState_e)5;
// processingThread
// file threading/deferredproc.c line 54
static unsigned long int processingThread;
// propertyParent
// file dvbadapter.c line 258
static const char propertyParent[8l] = { 'a', 'd', 'a', 'p', 't', 'e', 'r', 0 };
// propertyParent_link1
// file commands/cmd_scanning.c line 240
static char propertyParent_link1[14l] = { 'c', 'o', 'm', 'm', 'a', 'n', 'd', 's', '.', 's', 'c', 'a', 'n', 0 };
// psipProcessor
// file standard/atsc/atsc.c line 40
static struct PSIPProcessor_s *psipProcessor;
// quit
// file commands.c line 116
static _Bool quit = (_Bool)0;
// referencedObjects
// file objects.c line 94
static struct Object_s *referencedObjects = (struct Object_s *)(void *)0;
// remoteIntfExit
// file remoteintf.c line 118
static _Bool remoteIntfExit = (_Bool)0;
// removeFailedFreqs
// file commands/cmd_scanning.c line 274
static _Bool removeFailedFreqs = (_Bool)1;
// responselineStart
// file remoteintf.c line 133
static char responselineStart[19l] = { 'D', 'V', 'B', 'S', 't', 'r', 'e', 'a', 'm', 'e', 'r', '/', '2', '.', '1', '.', '0', '/', 0 };
// rl_attempted_completion_function
// file /usr/include/readline/readline.h line 618
extern char ** (*rl_attempted_completion_function)(const char *, signed int, signed int);
// rl_attempted_completion_over
// file /usr/include/readline/readline.h line 710
extern signed int rl_attempted_completion_over;
// rl_catch_signals
// file /usr/include/readline/readline.h line 588
extern signed int rl_catch_signals;
// rl_instream
// file /usr/include/readline/readline.h line 533
extern struct _IO_FILE *rl_instream;
// rl_readline_name
// file /usr/include/readline/readline.h line 491
extern const char *rl_readline_name;
// rollOffMapping
// file dvbadapter.c line 372
static struct StringToParamMapping_s rollOffMapping[5l] = { { .str="0.20", .param=(unsigned int)1 },
    { .str="0.25", .param=(unsigned int)2 },
    { .str="0.35", .param=(unsigned int)0 },
    { .str="AUTO", .param=(unsigned int)3 },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// rollOffTable
// file commands/cmd_scanning.c line 258
static char *rollOffTable[4l] = { "0.35", "0.25", "0.20", "" };
// rootProperty
// file properties.c line 75
static struct PropertyNode_s rootProperty;
// scanCanceledEvent
// file commands/cmd_scanning.c line 308
static struct Event_s *scanCanceledEvent;
// scanEndEvent
// file commands/cmd_scanning.c line 307
static struct Event_s *scanEndEvent;
// scanEventSource
// file commands/cmd_scanning.c line 305
static struct EventSource_s *scanEventSource;
// scanMuxAddedEvent
// file commands/cmd_scanning.c line 310
static struct Event_s *scanMuxAddedEvent;
// scanStartAsync
// file commands/cmd_scanning.c line 302
static struct ev_async scanStartAsync;
// scanStartEvent
// file commands/cmd_scanning.c line 306
static struct Event_s *scanStartEvent;
// scanTryingMuxEvent
// file commands/cmd_scanning.c line 309
static struct Event_s *scanTryingMuxEvent;
// scanType
// file commands/cmd_scanning.c line 299
static enum ScanType_e scanType = (enum ScanType_e)0;
// scanningmutex
// file commands/cmd_scanning.c line 267
static union anonymous_14 scanningmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// sdtEvent
// file standard/dvb/sdtprocessor.c line 84
static struct Event_s *sdtEvent = (struct Event_s *)(void *)0;
// sdtProcessor
// file standard/dvb/dvb.c line 41
static struct SDTProcessor_s *sdtProcessor = (struct SDTProcessor_s *)(void *)0;
// serverSocket
// file remoteintf.c line 123
static signed int serverSocket;
// serverSocketWatcher
// file remoteintf.c line 124
static struct ev_io serverSocketWatcher;
// serverStartTime
// file remoteintf.c line 132
static signed long int serverStartTime;
// serviceAddedEvent
// file services.c line 64
static struct Event_s *serviceAddedEvent;
// serviceAllDeletedEvent
// file services.c line 66
static struct Event_s *serviceAllDeletedEvent;
// serviceChangedEvent
// file tuning.c line 46
static struct Event_s *serviceChangedEvent;
// serviceChangedEvent_link1
// file servicefilter.c line 123
static struct Event_s *serviceChangedEvent_link1;
// serviceDeletedEvent
// file services.c line 65
static struct Event_s *serviceDeletedEvent;
// servicesSource
// file services.c line 63
static struct EventSource_s *servicesSource;
// singleInstance
// file deliverymethod.c line 61
static struct DeliveryMethodInstance_t singleInstance;
// singleInstance
// file deliverymethod.c line 61
static struct DeliveryMethodInstance_t singleInstance = { .mrl="null://", .ops=&nullInstanceOps, .private=(void *)0 };
// sourcesList
// file events.c line 78
static struct List_s *sourcesList;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// sttEvent
// file standard/atsc/psipprocessor.c line 89
static struct Event_s *sttEvent = (struct Event_s *)(void *)0;
// tablesTimeout
// file commands/cmd_scanning.c line 273
static signed int tablesTimeout = 60;
// tdtEvent
// file standard/dvb/tdtprocessor.c line 68
static struct Event_s *tdtEvent = (struct Event_s *)(void *)0;
// tdtProcessor
// file standard/dvb/dvb.c line 43
static struct TDTProcessor_s *tdtProcessor = (struct TDTProcessor_s *)(void *)0;
// threadNames
// file logging.c line 77
static struct ThreadName_s threadNames[100l];
// timeoutTimer
// file commands/cmd_scanning.c line 303
static struct ev_timer timeoutTimer;
// toScan
// file commands/cmd_scanning.c line 262
static struct ScanList_s toScan = { .start=(struct ScanEntry_s *)(void *)0, .end=(struct ScanEntry_s *)(void *)0,
    .current=(struct ScanEntry_s *)(void *)0,
    .count=0,
    .pos=0 };
// trailingBytesForUTF8
// file utf8.c line 37
static const char trailingBytesForUTF8[256l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)4, (const char)4, (const char)4, (const char)4, (const char)5, (const char)5, (const char)5, (const char)5 };
// transmissonModeMapping
// file dvbadapter.c line 329
static struct StringToParamMapping_s transmissonModeMapping[6l] = { { .str="2k", .param=(unsigned int)TRANSMISSION_MODE_2K },
    { .str="2000", .param=(unsigned int)TRANSMISSION_MODE_2K },
    { .str="8k", .param=(unsigned int)TRANSMISSION_MODE_8K },
    { .str="8000", .param=(unsigned int)TRANSMISSION_MODE_2K },
    { .str="AUTO", .param=(unsigned int)TRANSMISSION_MODE_AUTO },
    { .str=(char *)(void *)0, .param=(unsigned int)0 } };
// transponderList
// file commands/cmd_scanning.c line 264
static struct List_s *transponderList = (struct List_s *)(void *)0;
// tuningFailedEvent
// file dvbadapter.c line 264
static struct Event_s *tuningFailedEvent;
// tuningSource
// file tuning.c line 45
static struct EventSource_s *tuningSource;
// typeInited
// file pids.c line 49
static _Bool typeInited = (_Bool)0;
// uidSeed
// file multiplexes.c line 50
static signed int uidSeed;
// unlockedEvent
// file dvbadapter.c line 263
static struct Event_s *unlockedEvent;
// utf16ToUtf8CD
// file standard/atsc/psipprocessor.c line 86
static void *utf16ToUtf8CD;
// vctEvent
// file standard/atsc/psipprocessor.c line 90
static struct Event_s *vctEvent = (struct Event_s *)(void *)0;
// verbosity
// file logging.c line 74
static signed int verbosity = 0;
// versionStr
// file main.c line 135
static char *versionStr = "2.1.0";

// ATSCMultipleStringsConvert
// file standard/atsc/atsctext.c line 367
struct ATSCMultipleStrings_s * ATSCMultipleStringsConvert(unsigned char *data, unsigned char len)
{
  struct ATSCMultipleStrings_s *result;
  signed int stringIndex;
  unsigned char *pos = data + (signed long int)1;
  pthread_mutex_lock(&mutex_link1);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("ATSCMultipleStrings_t", "standard/atsc/atsctext.c", 374);
  result = (struct ATSCMultipleStrings_s *)return_value_ObjectCreateImpl_1;
  result->number_of_strings = (signed int)data[(signed long int)0];
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)result->number_of_strings, sizeof(struct ATSCString_s) /*16ul*/ );
  result->strings = (struct ATSCString_s *)return_value_calloc_2;
  LogModule(4, ATSCTEXT, "Start of conversion: Number of strings = %d\n", data[(signed long int)0]);
  stringIndex = 0;
  for( ; !(stringIndex >= result->number_of_strings); stringIndex = stringIndex + 1)
  {
    signed int segments;
    signed int segmentIndex;
    signed int sbIndex;
    _Bool supported = (_Bool)1;
    (result->strings + (signed long int)stringIndex)->lang[(signed long int)0] = (char)pos[(signed long int)0];
    (result->strings + (signed long int)stringIndex)->lang[(signed long int)1] = (char)pos[(signed long int)1];
    (result->strings + (signed long int)stringIndex)->lang[(signed long int)2] = (char)pos[(signed long int)2];
    segments = (signed int)pos[(signed long int)3];
    pos = pos + (signed long int)4;
    TextBuffer[(signed long int)0] = (char)0;
    sbIndex = 0;
    LogModule(4, ATSCTEXT, "Number of segments = %d\n", segments);
    segmentIndex = 0;
    for( ; !(segmentIndex >= segments); segmentIndex = segmentIndex + 1)
      pos=AppendSegment(pos, &sbIndex, &supported);
    if(!(supported == (_Bool)0))
      (result->strings + (signed long int)stringIndex)->text=strdup(TextBuffer);

    else
      (result->strings + (signed long int)stringIndex)->text = (char *)(void *)0;
  }
  LogModule(4, ATSCTEXT, "End of conversion\n");
  pthread_mutex_unlock(&mutex_link1);
  return result;
}

// ATSCMultipleStringsDeInit
// file ../include/atsctext.h line 71
void ATSCMultipleStringsDeInit(void)
{
  iconv_close((void *)Utf16ToUtf8CD);
  iconv_close((void *)Ucs2ToUtf8CD);
  iconv_close((void *)AsciiToUtf8CD);
}

// ATSCMultipleStringsDestructor
// file standard/atsc/atsctext.c line 419
static void ATSCMultipleStringsDestructor(struct ATSCMultipleStrings_s *strings)
{
  signed int i = 0;
  for( ; !(i >= strings->number_of_strings); i = i + 1)
    free((void *)(strings->strings + (signed long int)i)->text);
  free((void *)strings->strings);
}

// ATSCMultipleStringsInit
// file ../include/atsctext.h line 65
signed int ATSCMultipleStringsInit(void)
{
  ObjectRegisterClass("ATSCMultipleStrings_t", (unsigned int)sizeof(struct ATSCMultipleStrings_s) /*16ul*/ , (void (*)(void *))ATSCMultipleStringsDestructor);
  void *return_value_iconv_open_1;
  return_value_iconv_open_1=iconv_open("UTF-8", "UTF-16BE");
  Utf16ToUtf8CD = (void **)return_value_iconv_open_1;
  if((signed long int)Utf16ToUtf8CD == -1l)
    return 1;

  else
  {
    void *return_value_iconv_open_2;
    return_value_iconv_open_2=iconv_open("UTF-8", "UCS-2BE");
    Ucs2ToUtf8CD = (void **)return_value_iconv_open_2;
    if((signed long int)Ucs2ToUtf8CD == -1l)
      return 1;

    else
    {
      void *return_value_iconv_open_3;
      return_value_iconv_open_3=iconv_open("ASCII", "UCS-2BE");
      AsciiToUtf8CD = (void **)return_value_iconv_open_3;
      if((signed long int)AsciiToUtf8CD == -1l)
        return 1;

      else
        return 0;
    }
  }
}

// ATSCStandardDeinit
// file ../include/standard/atsc.h line 31
signed int ATSCStandardDeinit(struct TSReader_t *reader)
{
  MPEG2StandardDeinit(reader);
  PSIPProcessorDestroy(psipProcessor);
  ATSCMultipleStringsDeInit();
  return 0;
}

// ATSCStandardInit
// file ../include/standard/atsc.h line 30
signed int ATSCStandardInit(struct TSReader_t *reader)
{
  if(ATSCEventSource == ((struct EventSource_s *)NULL))
    ATSCEventSource=EventsRegisterSource(ATSCFilterType);

  signed int return_value_ATSCMultipleStringsInit_1;
  return_value_ATSCMultipleStringsInit_1=ATSCMultipleStringsInit();
  if(!(return_value_ATSCMultipleStringsInit_1 == 0))
    return -1;

  else
  {
    signed int return_value_MPEG2StandardInit_2;
    return_value_MPEG2StandardInit_2=MPEG2StandardInit(reader);
    if(!(return_value_MPEG2StandardInit_2 == 0))
      return -1;

    else
    {
      psipProcessor=PSIPProcessorCreate(reader);
      if(psipProcessor == ((struct PSIPProcessor_s *)NULL))
      {
        MPEG2StandardDeinit(reader);
        return -1;
      }

      else
        return 0;
    }
  }
}

// AddConnection
// file remoteintf.c line 287
static void AddConnection(signed int socketfd, struct sockaddr_storage *clientAddress)
{
  char connectionStr[48l];
  struct _IO_FILE *fp;
  struct Connection_t *connection;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("Connection_t", "remoteintf.c", 291);
  connection = (struct Connection_t *)return_value_ObjectCreateImpl_1;
  GetConnectionString(clientAddress, connectionStr);
  fp=fdopen(socketfd, "r+");
  if(!(connection == ((struct Connection_t *)NULL)))
  {
    connection->connected = (_Bool)1;
    connection->socketfd = socketfd;
    connection->fp = fp;
    connection->clientAddress = *clientAddress;
    LogModule(1, REMOTEINTERFACE, "Connection attempt from %s accepted!\n", (const void *)connectionStr);
    pthread_mutex_lock(&connectionsMutex);
    ListAdd(connectionsList, (void *)connection);
    pthread_mutex_unlock(&connectionsMutex);
    pthread_create(&connection->thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)HandleConnection, (void *)connection);
    LogRegisterThread(connection->thread, connectionStr);
  }

  else
  {
    LogModule(1, REMOTEINTERFACE, "Connection attempt from %s rejected as no connections structures left!\n", (const void *)connectionStr);
    PrintResponse(fp, (unsigned short int)0x0001, "Too many connect clients!");
    fclose(fp);
  }
}

// AppendSegment
// file standard/atsc/atsctext.c line 429
static unsigned char * AppendSegment(unsigned char *segment, signed int *sbIndex, _Bool *supported)
{
  void *textStandard = (void *)0;
  signed int compressionType = (signed int)segment[(signed long int)0];
  signed int mode = (signed int)segment[(signed long int)1];
  signed int numberBytes = (signed int)segment[(signed long int)2];
  unsigned char *rawText;
  signed int i;
  unsigned long int inBytesLeft;
  unsigned long int outBytesLeft;
  char *outBytes;
  char *inBytes;
  unsigned long int ret;
  rawText = segment + (signed long int)3;
  segment = segment + (signed long int)(3 + numberBytes);
  LogModule(4, ATSCTEXT, "Segment: compressionType=%d mode=%d numberBytes=%d *sbIndex=%d\n", compressionType, mode, numberBytes, *sbIndex);
  switch(mode)
  {
    case 0x3e:

    case 0x48:
    {
      LogModule(4, ATSCTEXT, "Unsupported mode!(%d)\n", mode);
      *supported = (_Bool)0;
      break;
    }
    case 0xff:
    {
      LogModule(4, ATSCTEXT, "ASCII to UTF8(%d)\n", mode);
      textStandard = (void *)AsciiToUtf8CD;
      break;
    }
    case 0x3f:
    {
      LogModule(4, ATSCTEXT, "UTF16 to UTF8(%d)\n", mode);
      textStandard = (void *)Utf16ToUtf8CD;
      break;
    }
    default:
    {
      LogModule(4, ATSCTEXT, "UCS2 to UTF8(%d)\n", mode);
      textStandard = (void *)Ucs2ToUtf8CD;
    }
  }
  if(*supported == (_Bool)0)
    return segment;

  else
  {
    switch(compressionType)
    {
      case 0x00:
      {
        i = 0;
        for( ; !(i >= numberBytes); i = i + 1)
        {
          SegmentBuffer[(signed long int)(i * 2 + 0)] = (char)mode;
          SegmentBuffer[(signed long int)(i * 2 + 1)] = (char)rawText[(signed long int)i];
        }
        inBytes = SegmentBuffer;
        inBytesLeft = (unsigned long int)(numberBytes * 2);
        break;
      }
      case 0x01:

      case 0x02:
      {
        HuffmanDecode((unsigned char *)&DecompressionBuffer, rawText, (signed int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1), numberBytes, compressionType);
        inBytes = DecompressionBuffer;
        inBytesLeft=strlen(DecompressionBuffer);
        break;
      }
      default:
        *supported = (_Bool)0;
    }
    if(*supported == (_Bool)0)
      return segment;

    else
    {
      outBytesLeft = sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)*sbIndex;
      outBytes = TextBuffer + (signed long int)*sbIndex;
      ret=iconv(textStandard, (char **)&inBytes, &inBytesLeft, &outBytes, &outBytesLeft);
      if(!(ret == 18446744073709551615ul))
      {
        *outBytes = (char)0;
        *sbIndex = *sbIndex + (signed int)((signed long int)outBytes - (signed long int)(TextBuffer + (signed long int)*sbIndex));
      }

      return segment;
    }
  }
}

// AttemptComplete
// file commands.c line 316
static char ** AttemptComplete(const char *text, signed int start, signed int end)
{
  char **matches = (char **)(void *)0;
  if(start == 0)
    matches=rl_completion_matches(text, CompleteCommand);

  else
    rl_attempted_completion_over = 1;
  return matches;
}

// BCDFixedPoint3_7ToDouble
// file commands/cmd_scanning.c line 1401
static double BCDFixedPoint3_7ToDouble(unsigned int bcd)
{
  signed int integer;
  signed int fraction;
  integer = (signed int)((bcd >> 28 & (unsigned int)0xf) * (unsigned int)100 + (bcd >> 24 & (unsigned int)0xf) * (unsigned int)10 + (bcd >> 20 & (unsigned int)0xf));
  fraction = (signed int)((bcd >> 16 & (unsigned int)0xf) * (unsigned int)10000 + (bcd >> 12 & (unsigned int)0xf) * (unsigned int)1000 + (bcd >> 8 & (unsigned int)0xf) * (unsigned int)100 + (bcd >> 4 & (unsigned int)0xf) * (unsigned int)10 + (bcd & (unsigned int)0xf));
  return (double)integer + (double)fraction / 100000.0;
}

// CacheDeInit
// file ../include/cache.h line 54
void CacheDeInit()
{
  CacheServicesFree();
  pthread_mutex_destroy(&cacheUpdateMutex);
}

// CacheInit
// file ../include/cache.h line 48
signed int CacheInit()
{
  union anonymous_38 mutexAttr;
  pthread_mutexattr_init(&mutexAttr);
  pthread_mutexattr_settype(&mutexAttr, 1);
  pthread_mutex_init(&cacheUpdateMutex, &mutexAttr);
  pthread_mutexattr_destroy(&mutexAttr);
  eventSource_link1=EventsRegisterSource("Cache");
  pidsUpdatedEvent=EventsRegisterEvent(eventSource_link1, "PIDsUpdated", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);
  ObjectRegisterClass("CacheUpdateMessage_t", (unsigned int)sizeof(struct CacheUpdateMessage_s) /*32ul*/ , (void (*)(void *))(void *)0);
  return 0;
}

// CacheLoad
// file ../include/cache.h line 61
signed int CacheLoad(struct Multiplex_s *multiplex)
{
  signed int result = 1;
  struct List_s *list = (struct List_s *)(void *)0;
  pthread_mutex_lock(&cacheUpdateMutex);
  LogModule(3, CACHE, "Freeing services\n");
  CacheServicesFree();
  list=ServiceListForMultiplex(multiplex);
  LogModule(3, CACHE, "Loading %d services for %d\n", list->count, multiplex->uid);
  cachedServicesCount = list->count;
  struct ListEntry_s *tmp_if_expr_1;
  if(list->count >= 1)
  {
    struct ListIterator_s iterator;
    signed int i = 0;
    iterator.current = list->head;
    iterator.list = list;
    for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); i = i + 1)
    {
      cachedServices[(signed long int)i] = (struct Service_t *)iterator.current->data;
      LogModule(3, CACHE, "Loaded 0x%04x %s\n", cachedServices[(signed long int)i]->id, cachedServices[(signed long int)i]->name);
      cachedPIDs[(signed long int)i]=ProgramInfoGet(cachedServices[(signed long int)i]);
      cacheFlags[(signed long int)i] = (enum CacheFlags)CacheFlag_Clean;
      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_1 = iterator.current->next;

      else
        tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
      iterator.current = tmp_if_expr_1;
    }
    ListFree(list, (void (*)(void *))(void *)0);
  }

  do
    if(!(multiplex == ((struct Multiplex_s *)NULL)))
      ObjectRefIncImpl((void *)multiplex, "cache.c", 244);

  while((_Bool)0);
  cachedServicesMultiplex = multiplex;
  result = 0;
  pthread_mutex_unlock(&cacheUpdateMutex);
  return result;
}

// CacheMultiplexGet
// file cache.c line 253
struct Multiplex_s * CacheMultiplexGet(void)
{
  return cachedServicesMultiplex;
}

// CacheProcessUpdateMessage
// file cache.c line 844
static void CacheProcessUpdateMessage(void *ptr)
{
  struct CacheUpdateMessage_s *msg = (struct CacheUpdateMessage_s *)ptr;
  signed int rc;
  struct Multiplex_s *mux = (struct Multiplex_s *)(void *)0;
  struct Service_t *service = (struct Service_t *)(void *)0;
  DBaseTransactionBegin();
  switch((signed int)msg->type)
  {
    case CacheUpdate_Multiplex_TS_id:
    {
      LogModule(3, CACHE, "Updating Multiplex TS id\n");
      mux = msg->details.multiplexTSId.multiplex;
      rc=MultiplexTSIdSet(mux, msg->details.multiplexTSId.tsId);
      if(!(rc == 0))
        LogModule(0, CACHE, "Failed to update Multiplex TS id (0x%x)\n", rc);

      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Multiplex_Network_id:
    {
      LogModule(3, CACHE, "Updating Multiplex Original Network id\n");
      mux = msg->details.multiplexNetworkId.multiplex;
      rc=MultiplexNetworkIdSet(mux, msg->details.multiplexNetworkId.networkId);
      if(!(rc == 0))
        LogModule(0, CACHE, "Failed to update Multiplex Original Network id (0x%x)\n", rc);

      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_PMT_PID:
    {
      service = msg->details.servicePMTPID.service;
      LogModule(3, CACHE, "Updating PMT PID for %s\n", service->name);
      ServicePMTPIDSet(service, msg->details.servicePMTPID.pmtPid);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_PIDs:
    {
      service = msg->details.servicePIDs.service;
      LogModule(3, CACHE, "Updating PIDs for %s\n", service->name);
      ProgramInfoRemove(service);
      ProgramInfoSet(service, msg->details.servicePIDs.info);
      ObjectRefDecImpl((void *)msg->details.servicePIDs.info, "cache.c", 885);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_Name:
    {
      service = msg->details.serviceName.service;
      LogModule(3, CACHE, "Updating name for 0x%04x new name %s\n", service->id, msg->details.serviceName.name);
      ServiceNameSet(service, msg->details.serviceName.name);
      free((void *)msg->details.serviceName.name);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_Source:
    {
      service = msg->details.serviceSource.service;
      LogModule(3, CACHE, "Updating source for 0x%04x new source %x\n", service->id, msg->details.serviceSource.source);
      ServiceSourceSet(service, (signed int)msg->details.serviceSource.source);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_CA:
    {
      service = msg->details.serviceCA.service;
      LogModule(3, CACHE, "Updating CA state for 0x%04x new CA state %s\n", service->id, msg->details.serviceCA.ca != (_Bool)0 ? "CA" : "FTA");
      ServiceConditionalAccessSet(service, msg->details.serviceCA.ca);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_Type:
    {
      service = msg->details.serviceType.service;
      LogModule(3, CACHE, "Updating Type for 0x%04x new Type %d\n", service->id, msg->details.serviceType.type);
      ServiceTypeSet(service, msg->details.serviceType.type);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_Provider:
    {
      service = msg->details.serviceProvider.service;
      LogModule(3, CACHE, "Updating provider for 0x%04x new provider %s\n", service->id, service->provider);
      ServiceProviderSet(service, msg->details.serviceProvider.provider);
      free((void *)msg->details.serviceProvider.provider);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_Default_Auth:
    {
      service = msg->details.serviceDefaultAuthority.service;
      LogModule(3, CACHE, "Updating default authority for 0x%04x new authority %s\n", service->id, msg->details.serviceDefaultAuthority.defaultAuthority);
      ServiceDefaultAuthoritySet(service, msg->details.serviceDefaultAuthority.defaultAuthority);
      free((void *)msg->details.serviceDefaultAuthority.defaultAuthority);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_Added:
    {
      LogModule(3, CACHE, "Adding service 0x%04x\n", msg->details.serviceAdd.id);
      ServiceAdd(msg->details.serviceAdd.multiplexUID, msg->details.serviceAdd.name, msg->details.serviceAdd.id, msg->details.serviceAdd.source);
      free((void *)msg->details.serviceAdd.name);
      goto __CPROVER_DUMP_L17;
    }
    case CacheUpdate_Service_Deleted:
    {
      service = msg->details.serviceDelete.service;
      LogModule(3, CACHE, "Deleting service %s (0x%04x)\n", service->name, service->id);
      ServiceDelete(service);
      ProgramInfoRemove(service);
      do
        if(!(service == ((struct Service_t *)NULL)))
          ObjectRefDecImpl((void *)service, "cache.c", 946);

      while((_Bool)0);
    }
    default:
    {

    __CPROVER_DUMP_L17:
      ;
      DBaseTransactionCommit();
      if(!(mux == ((struct Multiplex_s *)NULL)))
        ObjectRefDecImpl((void *)mux, "cache.c", 953);

      if(!(service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)service, "cache.c", 958);

      ObjectRefDecImpl((void *)msg, "cache.c", 961);
    }
  }
}

// CacheProgramInfoGet
// file ../include/cache.h line 120
struct ProgramInfo_s * CacheProgramInfoGet(struct Service_t *service)
{
  struct ProgramInfo_s *result = (struct ProgramInfo_s *)(void *)0;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          result = cachedPIDs[(signed long int)i];
          if(!(result == ((struct ProgramInfo_s *)NULL)))
            ObjectRefIncImpl((void *)result, "cache.c", 346);

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
  return result;
}

// CacheServiceAdd
// file ../include/cache.h line 199
struct Service_t * CacheServiceAdd(signed int id, signed int source)
{
  struct CacheUpdateMessage_s *msg;
  struct Service_t *result;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("Service_t", "cache.c", 690);
  result = (struct Service_t *)return_value_ObjectCreateImpl_1;
  if(!(result == ((struct Service_t *)NULL)))
  {
    result->id = id;
    result->source = source;
    result->pmtPID = 8191;
    signed int return_value_asprintf_2;
    return_value_asprintf_2=asprintf(&result->name, "%04x", id);
    if(return_value_asprintf_2 == -1)
    {
      LogModule(0, CACHE, "Failed to allocate memory for default service name (0x%04x).\n", result->id);
      result->name = (char *)(void *)0;
    }

    result->multiplexUID = cachedServicesMultiplex->uid;
    pthread_mutex_lock(&cacheUpdateMutex);
    LogModule(3, CACHE, "Added service %04x at %d\n", result->id, cachedServicesCount);
    do
      if(!(result == ((struct Service_t *)NULL)))
        ObjectRefIncImpl((void *)result, "cache.c", 706);

    while((_Bool)0);
    cachedServices[(signed long int)cachedServicesCount] = result;
    cachedPIDs[(signed long int)cachedServicesCount] = (struct ProgramInfo_s *)(void *)0;
    cacheFlags[(signed long int)cachedServicesCount] = (enum CacheFlags)CacheFlag_Clean;
    cachedServicesCount = cachedServicesCount + 1;
    void *return_value_ObjectCreateImpl_3;
    return_value_ObjectCreateImpl_3=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 712);
    msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_3;
    if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
    {
      msg->type = (enum CacheUpdateType)CacheUpdate_Service_Added;
      msg->details.serviceAdd.id = id;
      msg->details.serviceAdd.multiplexUID = cachedServicesMultiplex->uid;
      msg->details.serviceAdd.source = result->source;
      msg->details.serviceAdd.name=strdup(result->name);
      DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
      ObjectRefDecImpl((void *)msg, "cache.c", 721);
    }

    pthread_mutex_unlock(&cacheUpdateMutex);
  }

  return result;
}

// CacheServiceDelete
// file ../include/cache.h line 217
void CacheServiceDelete(struct Service_t *service)
{
  struct CacheUpdateMessage_s *msg;
  signed int deletedIndex = -1;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          deletedIndex = i;
          break;
        }

      }

    }

  if(!(deletedIndex == -1))
  {
    LogModule(3, CACHE, "Removing service at index %d\n", deletedIndex);
    if(!(cachedPIDs[(signed long int)deletedIndex] == ((struct ProgramInfo_s *)NULL)))
      ObjectRefDecImpl((void *)cachedPIDs[(signed long int)deletedIndex], "cache.c", 790);

    cachedServicesCount = cachedServicesCount - 1;
    i = deletedIndex;
    for( ; !(i >= cachedServicesCount); i = i + 1)
    {
      LogModule(3, CACHE, "Moving %s (%x) to %d\n", cachedServices[(signed long int)(i + 1)]->name, cachedServices[(signed long int)(i + 1)]->id, i);
      cachedPIDs[(signed long int)i] = cachedPIDs[(signed long int)(i + 1)];
      cachedServices[(signed long int)i] = cachedServices[(signed long int)(i + 1)];
      cacheFlags[(signed long int)i] = cacheFlags[(signed long int)(i + 1)];
    }
    void *return_value_ObjectCreateImpl_1;
    return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 804);
    msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
    if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
    {
      msg->type = (enum CacheUpdateType)CacheUpdate_Service_Deleted;
      ObjectRefIncImpl((void *)service, "cache.c", 808);
      msg->details.serviceDelete.service = service;
      DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
      ObjectRefDecImpl((void *)msg, "cache.c", 811);
    }

  }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheServiceFind
// file cache.c line 258
struct Service_t * CacheServiceFind(char *name)
{
  struct Service_t *result = (struct Service_t *)(void *)0;
  signed int netId;
  signed int tsId;
  signed int serviceId;
  result=CacheServiceFindName(name);
  if(result == ((struct Service_t *)NULL))
  {
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(name, "%x.%x.%x", &netId, &tsId, &serviceId);
    if(return_value_sscanf_1 == 3)
    {
      if(cachedServicesMultiplex->networkId == netId)
      {
        if(cachedServicesMultiplex->tsId == tsId)
          result=CacheServiceFindId(serviceId);

      }

    }

  }

  return result;
}

// CacheServiceFindId
// file ../include/cache.h line 88
struct Service_t * CacheServiceFindId(signed int id)
{
  struct Service_t *result = (struct Service_t *)(void *)0;
  signed int i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(cachedServices[(signed long int)i]->id == id)
    {
      result = cachedServices[(signed long int)i];
      do
        if(!(result == ((struct Service_t *)NULL)))
          ObjectRefIncImpl((void *)result, "cache.c", 290);

      while((_Bool)0);
      break;
    }

  return result;
}

// CacheServiceFindName
// file cache.c line 298
struct Service_t * CacheServiceFindName(char *name)
{
  struct Service_t *result = (struct Service_t *)(void *)0;
  signed int i;
  LogModule(4, CACHE, "Checking cached services for \"%s\"\n", name);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
  {
    LogModule(4, CACHE, "cachedServices[%d]->name = %s\n", i, cachedServices[(signed long int)i]->name);
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(cachedServices[(signed long int)i]->name, name);
    if(return_value_strcmp_1 == 0)
    {
      result = cachedServices[(signed long int)i];
      do
        if(!(result == ((struct Service_t *)NULL)))
          ObjectRefIncImpl((void *)result, "cache.c", 309);

      while((_Bool)0);
      LogModule(4, CACHE, "Found in cached services!\n");
      break;
    }

  }
  if(result == ((struct Service_t *)NULL))
    LogModule(4, CACHE, "Not found in cached services\n");

  return result;
}

// CacheServiceSeen
// file ../include/cache.h line 211
_Bool CacheServiceSeen(struct Service_t *service, _Bool seen, _Bool pat)
{
  _Bool exists = (_Bool)0;
  signed int seenIndex = -1;
  signed int i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          seenIndex = i;
          break;
        }

      }

    }

  _Bool tmp_if_expr_1;
  if(!(seenIndex == -1))
  {
    signed int flag = pat != (_Bool)0 ? CacheFlag_Not_Seen_In_PAT : CacheFlag_Not_Seen_In_SDT;
    if(!(seen == (_Bool)0))
      cacheFlags[(signed long int)seenIndex] = cacheFlags[(signed long int)seenIndex] & (enum CacheFlags)~flag;

    else
      cacheFlags[(signed long int)seenIndex] = cacheFlags[(signed long int)seenIndex] | (enum CacheFlags)flag;
    if(!((CacheFlag_Not_Seen_In_PAT & (signed int)cacheFlags[(signed long int)seenIndex]) == 0))
      tmp_if_expr_1 = ((signed int)cacheFlags[(signed long int)seenIndex] & CacheFlag_Not_Seen_In_SDT) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      exists = (_Bool)0;

    else
      exists = (_Bool)1;
  }

  return exists;
}

// CacheServicesFree
// file cache.c line 823
static void CacheServicesFree(void)
{
  signed int i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
  {
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      do
        if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
          ObjectRefDecImpl((void *)cachedServices[(signed long int)i], "cache.c", 830);

      while((_Bool)0);
      cachedServices[(signed long int)i] = (struct Service_t *)(void *)0;
    }

    if(!(cachedPIDs[(signed long int)i] == ((struct ProgramInfo_s *)NULL)))
    {
      ObjectRefDecImpl((void *)cachedPIDs[(signed long int)i], "cache.c", 835);
      cachedPIDs[(signed long int)i] = (struct ProgramInfo_s *)(void *)0;
    }

  }
  cachedServicesCount = 0;
  do
    if(!(cachedServicesMultiplex == ((struct Multiplex_s *)NULL)))
      ObjectRefDecImpl((void *)cachedServicesMultiplex, "cache.c", 840);

  while((_Bool)0);
  cachedServicesMultiplex = (struct Multiplex_s *)(void *)0;
}

// CacheServicesGet
// file ../include/cache.h line 105
struct Service_t ** CacheServicesGet(signed int *count)
{
  pthread_mutex_lock(&cacheUpdateMutex);
  *count = cachedServicesCount;
  return cachedServices;
}

// CacheServicesRelease
// file ../include/cache.h line 111
void CacheServicesRelease(void)
{
  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateMultiplex
// file ../include/cache.h line 129
void CacheUpdateMultiplex(struct Multiplex_s *multiplex, signed int patversion, signed int tsid)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  if(!(cachedServicesMultiplex == ((struct Multiplex_s *)NULL)))
  {
    if(multiplex->uid == cachedServicesMultiplex->uid)
    {
      cachedServicesMultiplex->patVersion = patversion;
      cachedServicesMultiplex->tsId = tsid;
      i = 0;
      for( ; !(i >= cachedServicesCount); i = i + 1)
        cachedServices[(signed long int)i]->tsId = tsid;
      void *return_value_ObjectCreateImpl_1;
      return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 370);
      msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
      if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
      {
        msg->type = (enum CacheUpdateType)CacheUpdate_Multiplex_TS_id;
        ObjectRefIncImpl((void *)multiplex, "cache.c", 374);
        msg->details.multiplexTSId.multiplex = multiplex;
        msg->details.multiplexTSId.tsId = tsid;
        DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
        ObjectRefDecImpl((void *)msg, "cache.c", 378);
      }

    }

  }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateNetworkId
// file cache.c line 385
void CacheUpdateNetworkId(struct Multiplex_s *multiplex, signed int netid)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  if(!(cachedServicesMultiplex == ((struct Multiplex_s *)NULL)))
  {
    if(multiplex->uid == cachedServicesMultiplex->uid)
    {
      cachedServicesMultiplex->networkId = netid;
      i = 0;
      for( ; !(i >= cachedServicesCount); i = i + 1)
        cachedServices[(signed long int)i]->networkId = netid;
      void *return_value_ObjectCreateImpl_1;
      return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 398);
      msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
      if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
      {
        msg->type = (enum CacheUpdateType)CacheUpdate_Multiplex_Network_id;
        ObjectRefIncImpl((void *)multiplex, "cache.c", 402);
        msg->details.multiplexNetworkId.multiplex = multiplex;
        msg->details.multiplexNetworkId.networkId = netid;
        DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
        ObjectRefDecImpl((void *)msg, "cache.c", 406);
      }

    }

  }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateProgramInfo
// file ../include/cache.h line 192
void CacheUpdateProgramInfo(struct Service_t *service, struct ProgramInfo_s *info)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          if(!(cachedPIDs[(signed long int)i] == ((struct ProgramInfo_s *)NULL)))
            ObjectRefDecImpl((void *)cachedPIDs[(signed long int)i], "cache.c", 663);

          cachedPIDs[(signed long int)i] = info;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 668);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_PIDs;
            ObjectRefIncImpl((void *)service, "cache.c", 672);
            msg->details.servicePIDs.service = service;
            ObjectRefIncImpl((void *)info, "cache.c", 674);
            msg->details.servicePIDs.info = info;
            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 677);
          }

          EventsFireEventListeners(pidsUpdatedEvent, (void *)cachedServices[(signed long int)i]);
          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateServiceConditionalAccess
// file cache.c line 595
void CacheUpdateServiceConditionalAccess(struct Service_t *service, _Bool ca)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          cachedServices[(signed long int)i]->conditionalAccess = ca;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 606);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_CA;
            ObjectRefIncImpl((void *)service, "cache.c", 610);
            msg->details.serviceCA.service = service;
            msg->details.serviceCA.ca = ca;
            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 614);
          }

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateServiceDefaultAuthority
// file cache.c line 525
void CacheUpdateServiceDefaultAuthority(struct Service_t *service, char *defaultAuthority)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          if(!(cachedServices[(signed long int)i]->defaultAuthority == ((char *)NULL)))
            free((void *)cachedServices[(signed long int)i]->defaultAuthority);

          if(!(defaultAuthority == ((char *)NULL)))
            cachedServices[(signed long int)i]->defaultAuthority=strdup(defaultAuthority);

          else
            cachedServices[(signed long int)i]->defaultAuthority = (char *)(void *)0;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 547);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_Default_Auth;
            ObjectRefIncImpl((void *)service, "cache.c", 551);
            msg->details.serviceDefaultAuthority.service = service;
            if(!(defaultAuthority == ((char *)NULL)))
              msg->details.serviceDefaultAuthority.defaultAuthority=strdup(defaultAuthority);

            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 558);
          }

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateServiceName
// file cache.c line 441
void CacheUpdateServiceName(struct Service_t *service, char *name)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          if(!(cachedServices[(signed long int)i]->name == ((char *)NULL)))
            free((void *)cachedServices[(signed long int)i]->name);

          if(!(name == ((char *)NULL)))
            cachedServices[(signed long int)i]->name=strdup(name);

          else
            cachedServices[(signed long int)i]->name = (char *)(void *)0;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 463);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_Name;
            ObjectRefIncImpl((void *)service, "cache.c", 467);
            msg->details.serviceName.service = service;
            if(!(name == ((char *)NULL)))
              msg->details.serviceName.name=strdup(name);

            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 474);
          }

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateServicePMTPID
// file ../include/cache.h line 143
void CacheUpdateServicePMTPID(struct Service_t *service, signed int pmtpid)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          cachedServices[(signed long int)i]->pmtPID = pmtpid;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 424);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_PMT_PID;
            ObjectRefIncImpl((void *)service, "cache.c", 428);
            msg->details.servicePMTPID.service = service;
            msg->details.servicePMTPID.pmtPid = pmtpid;
            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 432);
          }

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateServiceProvider
// file cache.c line 483
void CacheUpdateServiceProvider(struct Service_t *service, char *provider)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          if(!(cachedServices[(signed long int)i]->provider == ((char *)NULL)))
            free((void *)cachedServices[(signed long int)i]->provider);

          if(!(provider == ((char *)NULL)))
            cachedServices[(signed long int)i]->provider=strdup(provider);

          else
            cachedServices[(signed long int)i]->provider = (char *)(void *)0;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 505);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_Provider;
            ObjectRefIncImpl((void *)service, "cache.c", 509);
            msg->details.serviceProvider.service = service;
            if(!(provider == ((char *)NULL)))
              msg->details.serviceProvider.provider=strdup(provider);

            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 516);
          }

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateServiceSource
// file cache.c line 567
void CacheUpdateServiceSource(struct Service_t *service, unsigned short int source)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          cachedServices[(signed long int)i]->source = (signed int)source;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 578);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_Source;
            ObjectRefIncImpl((void *)service, "cache.c", 582);
            msg->details.serviceSource.service = service;
            msg->details.serviceSource.source = source;
            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 586);
          }

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheUpdateServiceType
// file cache.c line 623
void CacheUpdateServiceType(struct Service_t *service, enum anonymous type)
{
  struct CacheUpdateMessage_s *msg;
  signed int i;
  pthread_mutex_lock(&cacheUpdateMutex);
  i = 0;
  for( ; !(i >= cachedServicesCount); i = i + 1)
    if(!(cachedServices[(signed long int)i] == ((struct Service_t *)NULL)))
    {
      if(service->multiplexUID == cachedServices[(signed long int)i]->multiplexUID)
      {
        if(service->id == cachedServices[(signed long int)i]->id)
        {
          cachedServices[(signed long int)i]->type = type;
          void *return_value_ObjectCreateImpl_1;
          return_value_ObjectCreateImpl_1=ObjectCreateImpl("CacheUpdateMessage_t", "cache.c", 634);
          msg = (struct CacheUpdateMessage_s *)return_value_ObjectCreateImpl_1;
          if(!(msg == ((struct CacheUpdateMessage_s *)NULL)))
          {
            msg->type = (enum CacheUpdateType)CacheUpdate_Service_Type;
            ObjectRefIncImpl((void *)service, "cache.c", 638);
            msg->details.serviceType.service = service;
            msg->details.serviceType.type = type;
            DeferredProcessingAddJob(CacheProcessUpdateMessage, (void *)msg);
            ObjectRefDecImpl((void *)msg, "cache.c", 642);
          }

          break;
        }

      }

    }

  pthread_mutex_unlock(&cacheUpdateMutex);
}

// CacheWriteback
// file ../include/cache.h line 66
void CacheWriteback()
{
  ;
}

// CheckPMTsReceived
// file commands/cmd_scanning.c line 1147
static void CheckPMTsReceived(void)
{
  signed int i;
  _Bool all = (_Bool)1;
  i = 0;
  for( ; !(i >= PMTCount); i = i + 1)
    if(PMTsReceived[(signed long int)i].received == (_Bool)0)
      all = (_Bool)0;

  if(!(all == (_Bool)0))
    ScanStateMachine((enum ScanEvent_e)ScanEvent_PMTsReceived);

}

// CommandAddSF
// file commands/cmd_servicefilter.c line 254
static void CommandAddSF(signed int argc, char **argv)
{
  struct TSReader_t *tsReader;
  tsReader=MainTSReaderGet();
  struct ServiceFilter_s *filter;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandAddSF__1__1__1__1__context;
        CommandAddSF__1__1__1__1__context=CommandContextGet();
        CommandAddSF__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandAddSF__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  filter=ServiceFilterFindFilter(tsReader, argv[(signed long int)0]);
  if(!(filter == ((struct ServiceFilter_s *)NULL)))
    do
    {
      struct CommandContext_t *CommandAddSF__1__2__1__context;
      CommandAddSF__1__2__1__context=CommandContextGet();
      CommandAddSF__1__2__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandAddSF__1__2__1__context->errorMessage, (unsigned long int)256, "Service Filter of that name already exists!");
    }
    while((_Bool)0);

  else
  {
    struct DeliveryMethodInstance_t *instance;
    char *return_value_strdup_1;
    return_value_strdup_1=strdup(argv[(signed long int)0]);
    filter=ServiceFilterCreate(tsReader, return_value_strdup_1);
    instance=DeliveryMethodCreate(argv[(signed long int)1]);
    if(instance == ((struct DeliveryMethodInstance_t *)NULL))
      instance=DeliveryMethodCreate("null://");

    ServiceFilterDeliveryMethodSet(filter, instance);
  }

__CPROVER_DUMP_L8:
  ;
}

// CommandContextGet
// file commands.c line 171
struct CommandContext_t * CommandContextGet(void)
{
  void *return_value_pthread_getspecific_1;
  return_value_pthread_getspecific_1=pthread_getspecific(commandContextKey);
  return (struct CommandContext_t *)return_value_pthread_getspecific_1;
}

// CommandContextSet
// file commands.c line 166
static void CommandContextSet(struct CommandContext_t *context)
{
  pthread_setspecific(commandContextKey, (const void *)context);
}

// CommandCurrent
// file commands/cmd_info.c line 472
static void CommandCurrent(signed int argc, char **argv)
{
  struct Service_t *service;
  service=TuningCurrentServiceGet();
  if(!(service == ((struct Service_t *)NULL)))
  {
    char *idName;
    idName=ServiceGetIDNameStr(service, (char *)(void *)0);
    CommandPrintf("%s\n", idName);
    free((void *)idName);
    do
      if(!(service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)service, "commands/cmd_info.c", 480);

    while((_Bool)0);
  }

}

// CommandDeInit
// file ../include/commands.h line 141
void CommandDeInit(void)
{
  ListFree(CommandsList, (void (*)(void *))(void *)0);
}

// CommandDumpTSReader
// file commands/cmd_info.c line 828
static void CommandDumpTSReader(signed int argc, char **argv)
{
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  struct ListIterator_s iterator;
  signed int p;
  signed int count = 0;
  pthread_mutex_lock(&reader->mutex);
  p = 0;
  for( ; !(p >= 8193); p = p + 1)
    count = count + (reader->packetFilters[(signed long int)p] == (struct TSPacketFilter_t *)(void *)0 ? 0 : 1);
  CommandPrintf("PID Filters (%d)\n", count);
  p = 0;
  for( ; !(p >= 8193); p = p + 1)
  {
    struct TSPacketFilter_t *filter;
    if(!(reader->packetFilters[(signed long int)p] == ((struct TSPacketFilter_t *)NULL)))
    {
      CommandPrintf("    0x%04x : ", p);
      filter = reader->packetFilters[(signed long int)p];
      for( ; !(filter == ((struct TSPacketFilter_t *)NULL)); filter = filter->flNext)
      {
        if(!(filter->group == ((struct TSFilterGroup_t *)NULL)))
          CommandPrintf("\"%s\"", filter->group->name);

        else
          CommandPrintf("<Section Filter>");
        if(!(filter->flNext == ((struct TSPacketFilter_t *)NULL)))
          CommandPrintf(", ");

        else
          CommandPrintf("\n");
      }
    }

  }
  CommandPrintf("Section filters - Active (%d)\n", reader->activeSectionFilters->count);
  iterator.current = reader->activeSectionFilters->head;
  iterator.list = reader->activeSectionFilters;
  struct ListEntry_s *tmp_if_expr_2;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct ListIterator_s CommandDumpTSReader__1__3__1__iterator_sf;
    struct TSSectionFilterList_t *sfList = (struct TSSectionFilterList_t *)iterator.current->data;
    struct TSSectionFilter_t *sf;
    CommandPrintf("    0x%04x\n", sfList->pid);
    CommandDumpTSReader__1__3__1__iterator_sf.current = sfList->filters->head;
    CommandDumpTSReader__1__3__1__iterator_sf.list = sfList->filters;
    for( ; !(CommandDumpTSReader__1__3__1__iterator_sf.current == ((struct ListEntry_s *)NULL)); CommandDumpTSReader__1__3__1__iterator_sf.current = tmp_if_expr_2)
    {
      sf = (struct TSSectionFilter_t *)CommandDumpTSReader__1__3__1__iterator_sf.current->data;
      CommandPrintf("        %s\n", sf->group->name);
      if(!(CommandDumpTSReader__1__3__1__iterator_sf.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_2 = CommandDumpTSReader__1__3__1__iterator_sf.current->next;

      else
        tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
    }
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  CommandPrintf("Section filters - Awaiting scheduling (%d)\n", reader->sectionFilters->count);
  iterator.current = reader->sectionFilters->head;
  iterator.list = reader->sectionFilters;
  struct ListEntry_s *tmp_if_expr_4;
  struct ListEntry_s *tmp_if_expr_3;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_3)
  {
    struct ListIterator_s iterator_sf;
    struct TSSectionFilterList_t *CommandDumpTSReader__1__4__1__sfList = (struct TSSectionFilterList_t *)iterator.current->data;
    struct TSSectionFilter_t *CommandDumpTSReader__1__4__1__sf;
    CommandPrintf("    0x%04x\n", CommandDumpTSReader__1__4__1__sfList->pid);
    iterator_sf.current = CommandDumpTSReader__1__4__1__sfList->filters->head;
    iterator_sf.list = CommandDumpTSReader__1__4__1__sfList->filters;
    for( ; !(iterator_sf.current == ((struct ListEntry_s *)NULL)); iterator_sf.current = tmp_if_expr_4)
    {
      CommandDumpTSReader__1__4__1__sf = (struct TSSectionFilter_t *)iterator_sf.current->data;
      CommandPrintf("        %s\n", CommandDumpTSReader__1__4__1__sf->group->name);
      if(!(iterator_sf.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_4 = iterator_sf.current->next;

      else
        tmp_if_expr_4 = (struct ListEntry_s *)(void *)0;
    }
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_3 = iterator.current->next;

    else
      tmp_if_expr_3 = (struct ListEntry_s *)(void *)0;
  }
  pthread_mutex_unlock(&reader->mutex);
}

// CommandEPGData
// file commands/cmd_epg.c line 79
static void CommandEPGData(signed int argc, char **argv)
{
  struct MessageQ_s *msgQ;
  msgQ=MessageQCreate();
  char startTimeStr[25l];
  char endTimeStr[25l];
  struct CommandContext_t *cmdContext;
  cmdContext=CommandContextGet();
  EPGChannelRegisterListener(msgQ);
  CommandPrintf("<epg>\n");
  fflush(cmdContext->outfp);
  signed int return_value_ferror_1;
  _Bool return_value_MessageQIsQuitSet_2;
  do
  {
    return_value_ferror_1=ferror(cmdContext->outfp);
    if(!(return_value_ferror_1 == 0))
      break;

    return_value_MessageQIsQuitSet_2=MessageQIsQuitSet(msgQ);
    if(return_value_MessageQIsQuitSet_2 != (_Bool)0)
      break;

    if(ExitProgram != (_Bool)0)
      break;

    struct EPGChannelMessage_s *msg;
    void *return_value_MessageQReceiveTimed_3;
    return_value_MessageQReceiveTimed_3=MessageQReceiveTimed(msgQ, (unsigned long int)400);
    msg = (struct EPGChannelMessage_s *)return_value_MessageQReceiveTimed_3;
    if(!(msg == ((struct EPGChannelMessage_s *)NULL)))
    {
      CommandPrintf("<event net=\"0x%04x\" ts=\"0x%04x\" source=\"0x%04x\" event=\"0x%08x\">\n", msg->eventRef.serviceRef.netId, msg->eventRef.serviceRef.tsId, msg->eventRef.serviceRef.serviceId, msg->eventRef.eventId);
      switch((signed int)msg->type)
      {
        case EPGChannelMessageType_Event:
        {
          strftime(startTimeStr, sizeof(char [25l]) /*25ul*/ , "%Y-%m-%d %T", &msg->data.event.startTime);
          strftime(endTimeStr, sizeof(char [25l]) /*25ul*/ , "%Y-%m-%d %T", &msg->data.event.endTime);
          CommandPrintf("<new start=\"%s\" end=\"%s\" ca=\"%s\"/>\n", (const void *)startTimeStr, (const void *)endTimeStr, msg->data.event.ca != (_Bool)0 ? "yes" : "no");
          break;
        }
        case EPGChannelMessageType_Detail:
        {
          CommandPrintf("<detail lang=\"%s\" name=\"%s\">", (const void *)msg->data.detail.lang, msg->data.detail.name);
          PrintXmlified(msg->data.detail.value);
          CommandPrintf("</detail>\n");
          break;
        }
        case EPGChannelMessageType_Rating:
          CommandPrintf("<rating system=\"%s\" value=\"%s\"/>\n", msg->data.rating.system, msg->data.rating.rating);
      }
      CommandPrintf("</event>\n");
      fflush(cmdContext->outfp);
      ObjectRefDecImpl((void *)msg, "commands/cmd_epg.c", 121);
    }

  }
  while((_Bool)1);
  EPGChannelUnregisterListener(msgQ);
  MessageQDestroy(msgQ);
}

// CommandExecute
// file commands.c line 284
_Bool CommandExecute(struct CommandContext_t *context, char *line)
{
  _Bool commandFound = (_Bool)0;
  char *command = (char *)(void *)0;
  char *argument = (char *)(void *)0;
  CommandContextSet(context);
  do
  {
    struct CommandContext_t *CommandExecute__1__1__context;
    CommandExecute__1__1__context=CommandContextGet();
    CommandExecute__1__1__context->errorNumber = (unsigned short int)0x0000;
    snprintf(CommandExecute__1__1__context->errorMessage, (unsigned long int)256, "OK");
  }
  while((_Bool)0);
  ParseLine(line, &command, &argument);
  unsigned long int return_value_strlen_1;
  if(!(command == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(command);
    if(return_value_strlen_1 >= 1ul)
    {
      commandFound=ProcessCommand(context, command, argument);
      free((void *)command);
      if(!(argument == ((char *)NULL)))
        free((void *)argument);

      if(commandFound == (_Bool)0)
        do
        {
          struct CommandContext_t *CommandExecute__1__2__2__1__context;
          CommandExecute__1__2__2__1__context=CommandContextGet();
          CommandExecute__1__2__2__1__context->errorNumber = (unsigned short int)0x0002;
          snprintf(CommandExecute__1__2__2__1__context->errorMessage, (unsigned long int)256, "Unknown command");
        }
        while((_Bool)0);

    }

  }

  CommandContextSet((struct CommandContext_t *)(void *)0);
  return commandFound;
}

// CommandExecuteConsole
// file ../include/commands.h line 174
_Bool CommandExecuteConsole(char *line)
{
  _Bool found = (_Bool)0;
  _Bool return_value_CommandExecute_1;
  return_value_CommandExecute_1=CommandExecute(&ConsoleCommandContext, line);
  if(!(return_value_CommandExecute_1 == (_Bool)0))
  {
    add_history(line);
    found = (_Bool)1;
  }

  if(!((signed int)ConsoleCommandContext.errorNumber == 0x0000))
    printf("%s\n", (const void *)ConsoleCommandContext.errorMessage);

  return found;
}

// CommandFEParams
// file commands/cmd_info.c line 591
static void CommandFEParams(signed int argc, char **argv)
{
  struct DVBAdapter_s *adapter;
  adapter=MainDVBAdapterGet();
  enum DVBDeliverySystem_e system;
  char *params;
  params=DVBFrontEndParametersGet(adapter, &system);
  CommandPrintf("Delivery System: %s\n", DVBDeliverySystemStr[(signed long int)system]);
  CommandPrintf("%s\n", params);
  free((void *)params);
}

// CommandFEStatus
// file commands/cmd_info.c line 570
static void CommandFEStatus(signed int argc, char **argv)
{
  enum DVBFrontEndStatus_e status;
  unsigned int ber;
  unsigned int strength;
  unsigned int snr;
  unsigned int ucblocks;
  struct DVBAdapter_s *return_value_MainDVBAdapterGet_1;
  return_value_MainDVBAdapterGet_1=MainDVBAdapterGet();
  signed int return_value_DVBFrontEndStatus_2;
  return_value_DVBFrontEndStatus_2=DVBFrontEndStatus(return_value_MainDVBAdapterGet_1, &status, &ber, &strength, &snr, &ucblocks);
  if(!(return_value_DVBFrontEndStatus_2 == 0))
    CommandPrintf("Failed to get frontend status!\n");

  else
  {
    CommandPrintf("Tuner status: [ %s%s%s%s%s%s ]\n", ((signed int)status & FESTATUS_HAS_SIGNAL) != 0 ? "Signal, " : "", ((signed int)status & FESTATUS_TIMEDOUT) != 0 ? "Timed out, " : "", ((signed int)status & FESTATUS_HAS_LOCK) != 0 ? "Lock, " : "", ((signed int)status & FESTATUS_HAS_CARRIER) != 0 ? "Carrier, " : "", ((signed int)status & FESTATUS_HAS_VITERBI) != 0 ? "VITERBI, " : "", ((signed int)status & FESTATUS_HAS_SYNC) != 0 ? "Sync " : "");
    CommandPrintf("Signal Strength: %d%%\nSNR: %d%%\nBER: %d\nUncorrected Blocks: %d\n", (strength * (unsigned int)100) / (unsigned int)0xffff, (snr * (unsigned int)100) / (unsigned int)0xffff, ber, ucblocks);
  }
}

// CommandGetMRL
// file commands/cmd_servicefilter.c line 246
static void CommandGetMRL(signed int argc, char **argv)
{
  char *tmpArgs[1l];
  tmpArgs[(signed long int)0] = (char *)PrimaryService;
  CommandGetSFMRL(1, tmpArgs);
}

// CommandGetProperty
// file commands/cmd_info.c line 765
static void CommandGetProperty(signed int argc, char **argv)
{
  struct PropertyValue_s value;
  signed int return_value_PropertiesGet_1;
  return_value_PropertiesGet_1=PropertiesGet(argv[(signed long int)0], &value);
  if(return_value_PropertiesGet_1 == 0)
    switch((signed int)value.type)
    {
      case PropertyType_Int:
      {
        CommandPrintf("%d\n", value.u.integer);
        break;
      }
      case PropertyType_Float:
      {
        CommandPrintf("%lf\n", value.u.fp);
        break;
      }
      case PropertyType_Boolean:
      {
        CommandPrintf("%s\n", value.u.boolean != (_Bool)0 ? "True" : "False");
        break;
      }
      case PropertyType_String:
      {
        CommandPrintf("%s\n", value.u.string);
        free((void *)value.u.string);
        break;
      }
      case PropertyType_Char:
      {
        CommandPrintf("%c\n", value.u.ch);
        break;
      }
      case PropertyType_PID:
      {
        CommandPrintf("%u\n", value.u.pid);
        break;
      }
      case PropertyType_IPAddress:
        CommandPrintf("%s\n", value.u.string);
    }

}

// CommandGetSFAVSOnly
// file commands/cmd_servicefilter.c line 446
static void CommandGetSFAVSOnly(signed int argc, char **argv)
{
  struct ServiceFilter_s *filter;
  _Bool avsOnly;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandGetSFAVSOnly__1__1__1__1__context;
        CommandGetSFAVSOnly__1__1__1__1__context=CommandContextGet();
        CommandGetSFAVSOnly__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandGetSFAVSOnly__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L6;
    }

  }
  while((_Bool)0);
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  filter=ServiceFilterFindFilter(reader, argv[(signed long int)0]);
  if(filter == ((struct ServiceFilter_s *)NULL))
    do
    {
      struct CommandContext_t *CommandGetSFAVSOnly__1__2__1__1__context;
      CommandGetSFAVSOnly__1__2__1__1__context=CommandContextGet();
      CommandGetSFAVSOnly__1__2__1__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandGetSFAVSOnly__1__2__1__1__context->errorMessage, (unsigned long int)256, "Service filter not found!");
    }
    while((_Bool)0);

  else
  {
    avsOnly=ServiceFilterAVSOnlyGet(filter);
    CommandPrintf("%s : A/V/S Only = %s\n", argv[(signed long int)0], avsOnly != (_Bool)0 ? "On" : "Off");
  }

__CPROVER_DUMP_L6:
  ;
}

// CommandGetSFMRL
// file commands/cmd_servicefilter.c line 415
static void CommandGetSFMRL(signed int argc, char **argv)
{
  struct ServiceFilter_s *filter;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandGetSFMRL__1__1__1__1__context;
        CommandGetSFMRL__1__1__1__1__context=CommandContextGet();
        CommandGetSFMRL__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandGetSFMRL__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L6;
    }

  }
  while((_Bool)0);
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  filter=ServiceFilterFindFilter(reader, argv[(signed long int)0]);
  if(filter == ((struct ServiceFilter_s *)NULL))
    do
    {
      struct CommandContext_t *CommandGetSFMRL__1__2__1__1__context;
      CommandGetSFMRL__1__2__1__1__context=CommandContextGet();
      CommandGetSFMRL__1__2__1__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandGetSFMRL__1__2__1__1__context->errorMessage, (unsigned long int)256, "Service filter not found!");
    }
    while((_Bool)0);

  else
  {
    struct DeliveryMethodInstance_t *return_value_ServiceFilterDeliveryMethodGet_1;
    return_value_ServiceFilterDeliveryMethodGet_1=ServiceFilterDeliveryMethodGet(filter);
    char *return_value_DeliveryMethodGetMRL_2;
    return_value_DeliveryMethodGetMRL_2=DeliveryMethodGetMRL(return_value_ServiceFilterDeliveryMethodGet_1);
    CommandPrintf("%s\n", return_value_DeliveryMethodGetMRL_2);
  }

__CPROVER_DUMP_L6:
  ;
}

// CommandGetSFService
// file commands/cmd_servicefilter.c line 378
static void CommandGetSFService(signed int argc, char **argv)
{
  struct ServiceFilter_s *filter;
  struct Service_t *service;
  char *idName;
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  filter=ServiceFilterFindFilter(reader, argv[(signed long int)0]);
  if(filter == ((struct ServiceFilter_s *)NULL))
    do
    {
      struct CommandContext_t *context;
      context=CommandContextGet();
      context->errorNumber = (unsigned short int)0xffff;
      snprintf(context->errorMessage, (unsigned long int)256, "Service filter not found!");
    }
    while((_Bool)0);

  else
  {
    service=ServiceFilterServiceGet(filter);
    if(!(service == ((struct Service_t *)NULL)))
    {
      idName=ServiceGetIDNameStr(service, (char *)(void *)0);
      CommandPrintf("%s\n", idName);
      free((void *)idName);
    }

  }
}

// CommandGets
// file commands.c line 188
char * CommandGets(char *buffer, signed int len)
{
  struct CommandContext_t *context;
  context=CommandContextGet();
  char *return_value_fgets_1;
  return_value_fgets_1=fgets(buffer, len, context->infp);
  return return_value_fgets_1;
}

// CommandHelp
// file commands.c line 592
static void CommandHelp(signed int argc, char **argv)
{
  signed int i;
  struct ListIterator_s iterator;
  struct CommandContext_t *context;
  context=CommandContextGet();
  struct ListEntry_s *tmp_if_expr_1;
  struct ListEntry_s *tmp_if_expr_2;
  if(!(argc == 0))
  {
    struct Command_t *requestedcmd = (struct Command_t *)(void *)0;
    if(!(context->commands == ((struct Command_t *)NULL)))
      requestedcmd=FindCommand(context->commands, argv[(signed long int)0]);

    if(requestedcmd == ((struct Command_t *)NULL))
    {
      iterator.current = CommandsList->head;
      iterator.list = CommandsList;
      for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
      {
        struct Command_t *commands = (struct Command_t *)iterator.current->data;
        requestedcmd=FindCommand(commands, argv[(signed long int)0]);
        if(!(requestedcmd == ((struct Command_t *)NULL)))
          break;

        if(!(iterator.current == ((struct ListEntry_s *)NULL)))
          tmp_if_expr_1 = iterator.current->next;

        else
          tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
      }
    }

    if(!(requestedcmd == ((struct Command_t *)NULL)))
      CommandPrintf("%s\n\n", requestedcmd->longHelp);

    else
      do
      {
        struct CommandContext_t *CommandHelp__1__1__4__1__context;
        CommandHelp__1__1__4__1__context=CommandContextGet();
        CommandHelp__1__1__4__1__context->errorNumber = (unsigned short int)0xffff;
        snprintf(CommandHelp__1__1__4__1__context->errorMessage, (unsigned long int)256, "No help for unknown command!");
      }
      while((_Bool)0);
  }

  else
  {
    iterator.current = CommandsList->head;
    iterator.list = CommandsList;
    for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_2)
    {
      struct Command_t *CommandHelp__1__2__1__1__commands = (struct Command_t *)iterator.current->data;
      i = 0;
      for( ; !((CommandHelp__1__2__1__1__commands + (signed long int)i)->command == ((char *)NULL)); i = i + 1)
        CommandPrintf("%12s - %s\n", (CommandHelp__1__2__1__1__commands + (signed long int)i)->command, (CommandHelp__1__2__1__1__commands + (signed long int)i)->shortHelp);
      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_2 = iterator.current->next;

      else
        tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
    }
    if(!(context->commands == ((struct Command_t *)NULL)))
    {
      i = 0;
      for( ; !((context->commands + (signed long int)i)->command == ((char *)NULL)); i = i + 1)
        CommandPrintf("%12s - %s\n", (context->commands + (signed long int)i)->command, (context->commands + (signed long int)i)->shortHelp);
    }

  }
}

// CommandInit
// file ../include/commands.h line 136
signed int CommandInit(void)
{
  rl_readline_name = "DVBStreamer";
  rl_attempted_completion_function = AttemptComplete;
  CommandsList=ListCreate();
  if(CommandsList == ((struct List_s *)NULL))
  {
    LogModule(0, COMMAND, "Failed to allocate CommandsList!\n");
    return -1;
  }

  else
  {
    ListAdd(CommandsList, (void *)coreCommands);
    pthread_key_create(&commandContextKey, (void (*)(void *))(void *)0);
    ConsoleCommandContext.outfp = stdout;
    ConsoleCommandContext.infp = stdin;
    return 0;
  }
}

// CommandInstallEPG
// file commands/cmd_epg.c line 66
void CommandInstallEPG(void)
{
  CommandRegisterCommands(CommandEPGInfo);
}

// CommandInstallInfo
// file commands/cmd_info.c line 232
void CommandInstallInfo(void)
{
  CommandRegisterCommands(CommandDetailsInfo);
  StartTime_link1=time((signed long int *)(void *)0);
}

// CommandInstallScanning
// file commands/cmd_scanning.c line 315
void CommandInstallScanning(void)
{
  struct ev_loop *loop;
  struct Event_s *feLockedEvent;
  char propertyName[255l];
  LogModule(3, SCANNING, "Starting to install scanning.\n");
  ObjectRegisterClass("ScanEntry_t", (unsigned int)sizeof(struct ScanEntry_s) /*32ul*/ , ScanEntryDestructor);
  ObjectRegisterClass("TransponderEntry_t", (unsigned int)sizeof(struct TransponderEntry_s) /*48ul*/ , TransponderEntryDestructor);
  ObjectRegisterCollection("TuningParamDocs_t", (unsigned int)sizeof(char *) /*8ul*/ , TuningParamDocsDestructor);
  ObjectRegisterCollection("MuxFrequencies_t", (unsigned int)sizeof(struct MuxFrequency_s) /*20ul*/ , (void (*)(void *))(void *)0);
  scanEventSource=EventsRegisterSource("Scan");
  scanStartEvent=EventsRegisterEvent(scanEventSource, "Started", ScanEventToString);
  scanEndEvent=EventsRegisterEvent(scanEventSource, "Finished", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);
  scanCanceledEvent=EventsRegisterEvent(scanEventSource, "Cancel", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);
  scanTryingMuxEvent=EventsRegisterEvent(scanEventSource, "Trying", ScanEventToString);
  scanMuxAddedEvent=EventsRegisterEvent(scanEventSource, "Found", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);
  loop=DispatchersGetInput();
  do
  {

  __CPROVER_DUMP_L1:
    ;
    ((struct ev_watcher *)(void *)&scanStartAsync)->pending = 0;
    ((struct ev_watcher *)(void *)&scanStartAsync)->active = ((struct ev_watcher *)(void *)&scanStartAsync)->pending;
    ((struct ev_watcher *)(void *)&scanStartAsync)->priority = 0;
    (&scanStartAsync)->cb = ScanStartStopWatcher;
    memmove((void *)&((struct ev_watcher *)&scanStartAsync)->cb, (const void *)&(&scanStartAsync)->cb, sizeof(void (*)(struct ev_loop *, struct ev_async *, signed int)) /*8ul*/ );
  }
  while((_Bool)0);
  do
  {

  __CPROVER_DUMP_L2:
    ;
    ((struct ev_watcher *)(void *)&timeoutTimer)->pending = 0;
    ((struct ev_watcher *)(void *)&timeoutTimer)->active = ((struct ev_watcher *)(void *)&timeoutTimer)->pending;
    ((struct ev_watcher *)(void *)&timeoutTimer)->priority = 0;
    (&timeoutTimer)->cb = TimeoutWatcher;
    memmove((void *)&((struct ev_watcher *)&timeoutTimer)->cb, (const void *)&(&timeoutTimer)->cb, sizeof(void (*)(struct ev_loop *, struct ev_timer *, signed int)) /*8ul*/ );
    do
    {
      ((struct ev_watcher_time *)&timeoutTimer)->at = 1.0;
      (&timeoutTimer)->repeat = 1.0;
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  ev_async_start(loop, &scanStartAsync);
  _Bool return_value_MainIsDVB_3;
  return_value_MainIsDVB_3=MainIsDVB();
  if(!(return_value_MainIsDVB_3 == (_Bool)0))
  {
    struct Event_s *return_value_EventsFindEvent_1;
    return_value_EventsFindEvent_1=EventsFindEvent("DVB.SDT");
    EventsRegisterEventListener(return_value_EventsFindEvent_1, SDTEventListener, (void *)0);
    struct Event_s *return_value_EventsFindEvent_2;
    return_value_EventsFindEvent_2=EventsFindEvent("DVB.NIT");
    EventsRegisterEventListener(return_value_EventsFindEvent_2, NITEventListener, (void *)0);
  }

  _Bool return_value_MainIsATSC_5;
  return_value_MainIsATSC_5=MainIsATSC();
  if(!(return_value_MainIsATSC_5 == (_Bool)0))
  {
    struct Event_s *return_value_EventsFindEvent_4;
    return_value_EventsFindEvent_4=EventsFindEvent("ATSC.VCT");
    EventsRegisterEventListener(return_value_EventsFindEvent_4, VCTEventListener, (void *)0);
  }

  struct Event_s *return_value_EventsFindEvent_6;
  return_value_EventsFindEvent_6=EventsFindEvent("MPEG2.PAT");
  EventsRegisterEventListener(return_value_EventsFindEvent_6, PATEventListener, (void *)0);
  struct Event_s *return_value_EventsFindEvent_7;
  return_value_EventsFindEvent_7=EventsFindEvent("MPEG2.PMT");
  EventsRegisterEventListener(return_value_EventsFindEvent_7, PMTEventListener, (void *)0);
  LogModule(3, SCANNING, "Finding fe locked event.\n");
  feLockedEvent=EventsFindEvent("DVBAdapter.Locked");
  EventsRegisterEventListener(feLockedEvent, FELockedEventListener, (void *)0);
  PropertiesAddProperty(propertyParent_link1, "inprogress", "Whether an scan is currently in progress", (enum PropertyType_e)PropertyType_Boolean, (void *)0, ScanningInProgressGet, (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyParent_link1, "state", "Get the current state id of the scanning state machine.", (enum PropertyType_e)PropertyType_Int, (void *)&currentScanState, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyParent_link1, "position", "Get the current position within the list of frequencies to scan.", (enum PropertyType_e)PropertyType_Int, (void *)&toScan.pos, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyParent_link1, "total", "Get the total number of frequencies to scan.", (enum PropertyType_e)PropertyType_Int, (void *)&toScan.count, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyParent_link1, "removefailed", "Whether frequencies currently in the database that fail to lock should be removed.", (enum PropertyType_e)PropertyType_Boolean, (void *)&removeFailedFreqs, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  sprintf(propertyName, "%s.locktimeout", (const void *)propertyParent_link1);
  PropertiesAddProperty(propertyName, "terrestrial", "Number of seconds to wait for the frontent to lock (DVB-T and ATSC).", (enum PropertyType_e)PropertyType_Int, (void *)&lockTimeoutT, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyName, "satellite", "Number of seconds to wait for the frontent to lock (DVB-S/S2).", (enum PropertyType_e)PropertyType_Int, (void *)&lockTimeoutS, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyName, "satellite", "Number of seconds to wait for the frontent to lock (DVB-C).", (enum PropertyType_e)PropertyType_Int, (void *)&lockTimeoutC, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyParent_link1, "tablestimeout", "Number of seconds to wait for the required tables.", (enum PropertyType_e)PropertyType_Int, (void *)&tablesTimeout, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  sprintf(propertyName, "%s.dvb.t", (const void *)propertyParent_link1);
  PropertiesAddProperty(propertyName, "scanvhf", "Whether VHF channels should be scanned when doing a full spectrum scan", (enum PropertyType_e)PropertyType_Boolean, (void *)&DVBTScanVHF, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyName, "scanuhf", "Whether UHF channels should be scanned when doing a full spectrum scan", (enum PropertyType_e)PropertyType_Boolean, (void *)&DVBTScanUHF, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  sprintf(propertyName, "%s.dvb.s", (const void *)propertyParent_link1);
  PropertiesAddProperty(propertyName, "scansatnumber", "The switch position/satellite number to scan.", (enum PropertyType_e)PropertyType_Int, (void *)&DVBSSatNumber, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  sprintf(propertyName, "%s.atsc", (const void *)propertyParent_link1);
  PropertiesAddProperty(propertyName, "scanota", "Whether OTA ATSC signals should be scanned for.", (enum PropertyType_e)PropertyType_Boolean, (void *)&ATSCScanOTA, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty(propertyName, "scancable", "Whether ATSC cable signals should be scanned for.", (enum PropertyType_e)PropertyType_Boolean, (void *)&ATSCScanOTA, ((1 | 2) & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, ((1 | 2) & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  CommandRegisterCommands(CommandDetailsScanning);
}

// CommandInstallServiceFilter
// file commands/cmd_servicefilter.c line 200
void CommandInstallServiceFilter(void)
{
  CommandRegisterCommands(CommandDetailsServiceFilter);
}

// CommandListLNBs
// file commands/cmd_info.c line 900
static void CommandListLNBs(signed int argc, char **argv)
{
  struct LNBInfo_s *knownLNB;
  signed int i = 0;
  i = 0;
  do
  {
    knownLNB=LNBEnumerate(i);
    if(knownLNB == ((struct LNBInfo_s *)NULL))
      break;

    char **desclines;
    CommandPrintf("%s :\n", knownLNB->name);
    desclines = knownLNB->desc;
    for( ; !(*desclines == ((char *)NULL)); desclines = desclines + 1l)
      CommandPrintf("   %s\n", *desclines);
    CommandPrintf("\n");
    i = i + 1;
  }
  while((_Bool)1);
}

// CommandListMuxes
// file commands/cmd_info.c line 443
static void CommandListMuxes(signed int argc, char **argv)
{
  signed int i;
  struct MultiplexList_s *list;
  struct Multiplex_s *multiplex = (struct Multiplex_s *)(void *)0;
  _Bool ids = (_Bool)0;
  signed int return_value_strcmp_1;
  if(argc == 1)
  {
    return_value_strcmp_1=strcmp(argv[(signed long int)0], "-id");
    if(return_value_strcmp_1 == 0)
      ids = (_Bool)1;

  }

  list=MultiplexGetAll();
  i = 0;
  for( ; !(i >= list->nrofMultiplexes); i = i + 1)
  {
    multiplex = (struct Multiplex_s *)list->multiplexes[(signed long int)i];
    if(!(ids == (_Bool)0))
      CommandPrintf("%04x.%04x : %d \n", multiplex->networkId & 0xffff, multiplex->tsId & 0xffff, multiplex->uid);

    else
      CommandPrintf("%d\n", multiplex->uid);
  }
  ObjectRefDecImpl((void *)list, "commands/cmd_info.c", 469);
}

// CommandListPids
// file commands/cmd_info.c line 601
static void CommandListPids(signed int argc, char **argv)
{
  struct Service_t *service;
  service=ServiceFind(argv[(signed long int)0]);
  signed int return_value_strcmp_1;
  if(!(service == ((struct Service_t *)NULL)))
  {
    _Bool cached = (_Bool)1;
    signed int i;
    struct ProgramInfo_s *info;
    _Bool numericOutput = (_Bool)0;
    if(argc == 2)
    {
      return_value_strcmp_1=strcmp(argv[(signed long int)1], "-n");
      if(return_value_strcmp_1 == 0)
        numericOutput = (_Bool)1;

    }

    info=CacheProgramInfoGet(service);
    if(info == ((struct ProgramInfo_s *)NULL))
    {
      info=ProgramInfoGet(service);
      cached = (_Bool)0;
    }

    if(!(info == ((struct ProgramInfo_s *)NULL)))
    {
      _Bool pcrPresent = (_Bool)0;
      CommandPrintf("%d PIDs for \"%s\"%s\n", info->streamInfoList->nrofStreams, argv[(signed long int)0], cached != (_Bool)0 ? " (Cached)" : "");
      i = 0;
      for( ; !(i >= info->streamInfoList->nrofStreams); i = i + 1)
      {
        if(info->streamInfoList->streams[(signed long int)i].pid == info->pcrPID)
          pcrPresent = (_Bool)1;

        if(!(numericOutput == (_Bool)0))
          CommandPrintf("%4d: { type: %d }\n", info->streamInfoList->streams[(signed long int)i].pid, info->streamInfoList->streams[(signed long int)i].type);

        else
        {
          char *return_value_GetStreamTypeString_2;
          return_value_GetStreamTypeString_2=GetStreamTypeString(info->streamInfoList->streams[(signed long int)i].type);
          CommandPrintf("%4d: { type: \"%s\" }\n", info->streamInfoList->streams[(signed long int)i].pid, return_value_GetStreamTypeString_2);
        }
      }
      if(pcrPresent == (_Bool)0)
      {
        if(!(numericOutput == (_Bool)0))
          CommandPrintf("%4d: { type: -1 }\n", info->pcrPID);

        else
          CommandPrintf("%4d: { type: PCR }\n", info->pcrPID);
      }

      ObjectRefDecImpl((void *)info, "commands/cmd_info.c", 656);
    }

    else
      CommandPrintf("0 PIDs for \"%s\"\n", argv[(signed long int)0]);
    do
      if(!(service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)service, "commands/cmd_info.c", 663);

    while((_Bool)0);
  }

  else
    do
    {
      struct CommandContext_t *context;
      context=CommandContextGet();
      context->errorNumber = (unsigned short int)0xffff;
      snprintf(context->errorMessage, (unsigned long int)256, "Service not found!");
    }
    while((_Bool)0);
}

// CommandListProperties
// file commands/cmd_info.c line 713
static void CommandListProperties(signed int argc, char **argv)
{
  void *pos;
  struct PropertyInfo_s propInfo;
  char *path = (char *)(void *)0;
  char *typeStr;
  signed int i;
  _Bool list = (_Bool)0;
  i = 0;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp("-l", argv[(signed long int)i]);
    if(return_value_strcmp_1 == 0)
      list = (_Bool)1;

    else
      if(path == ((char *)NULL))
        path = argv[(signed long int)i];

  }
  signed int return_value_PropertiesEnumerate_2;
  return_value_PropertiesEnumerate_2=PropertiesEnumerate(path, &pos);
  if(return_value_PropertiesEnumerate_2 == 0)
  {
    if(!(pos == NULL))
      while(!(pos == NULL))
      {
        PropertiesEnumGetInfo(pos, &propInfo);
        if(!(list == (_Bool)0))
        {
          typeStr=GetPropertyTypeString(propInfo.type);
          CommandPrintf("%c%c%c %-10s %s\n", (signed int)propInfo.hasChildren == 1 ? 68 : 45, (signed int)propInfo.readable == 1 ? 82 : 45, (signed int)propInfo.writeable == 1 ? 87 : 45, typeStr, propInfo.name);
        }

        else
          CommandPrintf("%s\n", propInfo.name);
        pos=PropertiesEnumNext(pos);
      }

    else
      do
      {
        struct CommandContext_t *context;
        context=CommandContextGet();
        context->errorNumber = (unsigned short int)0xffff;
        snprintf(context->errorMessage, (unsigned long int)256, "Property %s does not have any children!", path);
      }
      while((_Bool)0);
  }

  else
    do
    {
      struct CommandContext_t *CommandListProperties__1__3__1__context;
      CommandListProperties__1__3__1__context=CommandContextGet();
      CommandListProperties__1__3__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandListProperties__1__3__1__context->errorMessage, (unsigned long int)256, "Couldn't find property \"%s\"", path);
    }
    while((_Bool)0);
}

// CommandListSF
// file commands/cmd_servicefilter.c line 295
static void CommandListSF(signed int argc, char **argv)
{
  struct ListIterator_s iterator;
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  _Bool fullListing = (_Bool)0;
  if(argc == 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp("-l", argv[(signed long int)0]);
    if(return_value_strcmp_1 == 0)
      fullListing = (_Bool)1;

  }

  iterator.current = reader->groups->head;
  iterator.list = reader->groups;
  struct ListEntry_s *tmp_if_expr_2;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_2)
  {
    struct TSFilterGroup_t *group = (struct TSFilterGroup_t *)iterator.current->data;
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(group->type, ServiceFilterGroupType);
    if(return_value_strcmp_4 == 0)
    {
      struct ServiceFilter_s *filter = (struct ServiceFilter_s *)group->userArg;
      char *name;
      name=ServiceFilterNameGet(filter);
      if(!(fullListing == (_Bool)0))
      {
        struct Service_t *service;
        service=ServiceFilterServiceGet(filter);
        char *serviceIdName = (char *)(void *)0;
        if(!(service == ((struct Service_t *)NULL)))
          serviceIdName=ServiceGetIDNameStr(service, (char *)(void *)0);

        struct DeliveryMethodInstance_t *dmInstance;
        dmInstance=ServiceFilterDeliveryMethodGet(filter);
        char *return_value_DeliveryMethodGetMRL_3;
        return_value_DeliveryMethodGetMRL_3=DeliveryMethodGetMRL(dmInstance);
        CommandPrintf("%-10s : { mrl: \"%s\", service: { %s } }\n", name, return_value_DeliveryMethodGetMRL_3, serviceIdName != ((char *)NULL) ? serviceIdName : "");
        if(!(serviceIdName == ((char *)NULL)))
          free((void *)serviceIdName);

      }

      else
        CommandPrintf("%s\n", name);
    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_2 = iterator.current->next;

    else
      tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
  }
}

// CommandListServices
// file commands/cmd_info.c line 246
static void CommandListServices(signed int argc, char **argv)
{
  struct List_s *list = (struct List_s *)(void *)0;
  struct Service_t *service;
  struct Multiplex_s *multiplex = (struct Multiplex_s *)(void *)0;
  signed int i;
  _Bool dvbIds = (_Bool)0;
  char *query = (char *)(void *)0;
  unsigned int filterByType = (unsigned int)0;
  unsigned int filterByAccess = (unsigned int)0;
  char *provider = (char *)(void *)0;
  char *providerStr = "provider=";
  UpdateDatabase();
  i = 0;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  unsigned long int return_value_strlen_2;
  signed int return_value_strncmp_3;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_strcmp_12;
    return_value_strcmp_12=strcmp(argv[(signed long int)i], "-id");
    if(return_value_strcmp_12 == 0)
      dvbIds = (_Bool)1;

    else
    {
      return_value_strcmp_11=strcmp(argv[(signed long int)i], "-q");
      if(return_value_strcmp_11 == 0)
      {
        if(!(multiplex == ((struct Multiplex_s *)NULL)))
        {
          do
          {
            struct CommandContext_t *context;
            context=CommandContextGet();
            context->errorNumber = (unsigned short int)0xffff;
            snprintf(context->errorMessage, (unsigned long int)256, "Cannot specify a multiplex and a query string!");
          }
          while((_Bool)0);
          goto __CPROVER_DUMP_L41;
        }

        if(1 + i >= argc)
        {
          do
          {
            struct CommandContext_t *CommandListServices__1__1__1__2__2__1__context;
            CommandListServices__1__1__1__2__2__1__context=CommandContextGet();
            CommandListServices__1__1__1__2__2__1__context->errorNumber = (unsigned short int)0xffff;
            snprintf(CommandListServices__1__1__1__2__2__1__context->errorMessage, (unsigned long int)256, "Missing query string");
          }
          while((_Bool)0);
          goto __CPROVER_DUMP_L41;
        }

        i = i + 1;
        query = argv[(signed long int)i];
      }

      else
      {
        return_value_strcmp_10=strcmp(argv[(signed long int)i], "mux");
        if(return_value_strcmp_10 == 0)
        {
          if(!(query == ((char *)NULL)))
          {
            do
            {
              struct CommandContext_t *CommandListServices__1__1__1__3__1__1__context;
              CommandListServices__1__1__1__3__1__1__context=CommandContextGet();
              CommandListServices__1__1__1__3__1__1__context->errorNumber = (unsigned short int)0xffff;
              snprintf(CommandListServices__1__1__1__3__1__1__context->errorMessage, (unsigned long int)256, "Cannot specify a multiplex and a query string!");
            }
            while((_Bool)0);
            goto __CPROVER_DUMP_L41;
          }

          if(!(multiplex == ((struct Multiplex_s *)NULL)))
            do
              if(!(multiplex == ((struct Multiplex_s *)NULL)))
                ObjectRefDecImpl((void *)multiplex, "commands/cmd_info.c", 292);

            while((_Bool)0);

          multiplex=TuningCurrentMultiplexGet();
          if(multiplex == ((struct Multiplex_s *)NULL))
          {
            do
            {
              struct CommandContext_t *CommandListServices__1__1__1__3__3__1__context;
              CommandListServices__1__1__1__3__3__1__context=CommandContextGet();
              CommandListServices__1__1__1__3__3__1__context->errorNumber = (unsigned short int)0xffff;
              snprintf(CommandListServices__1__1__1__3__3__1__context->errorMessage, (unsigned long int)256, "No multiplex currently selected!");
            }
            while((_Bool)0);
            goto __CPROVER_DUMP_L41;
          }

        }

        else
        {
          return_value_strcmp_9=strcmp(argv[(signed long int)i], "tv");
          if(return_value_strcmp_9 == 0)
            filterByType = filterByType | (unsigned int)1;

          else
          {
            return_value_strcmp_8=strcmp(argv[(signed long int)i], "radio");
            if(return_value_strcmp_8 == 0)
              filterByType = filterByType | (unsigned int)2;

            else
            {
              return_value_strcmp_7=strcmp(argv[(signed long int)i], "data");
              if(return_value_strcmp_7 == 0)
                filterByType = filterByType | (unsigned int)4;

              else
              {
                return_value_strcmp_6=strcmp(argv[(signed long int)i], "unknown");
                if(return_value_strcmp_6 == 0)
                  filterByType = filterByType | (unsigned int)8;

                else
                {
                  return_value_strcmp_5=strcmp(argv[(signed long int)i], "fta");
                  if(return_value_strcmp_5 == 0)
                    filterByAccess = filterByAccess | (unsigned int)1;

                  else
                  {
                    return_value_strcmp_4=strcmp(argv[(signed long int)i], "ca");
                    if(return_value_strcmp_4 == 0)
                      filterByAccess = filterByAccess | (unsigned int)2;

                    else
                    {
                      return_value_strlen_2=strlen(providerStr);
                      return_value_strncmp_3=strncmp(argv[(signed long int)i], providerStr, return_value_strlen_2);
                      if(return_value_strncmp_3 == 0)
                      {
                        unsigned long int return_value_strlen_1;
                        return_value_strlen_1=strlen(providerStr);
                        provider = argv[(signed long int)i] + (signed long int)return_value_strlen_1;
                      }

                      else
                      {
                        if(!(multiplex == ((struct Multiplex_s *)NULL)))
                          do
                            if(!(multiplex == ((struct Multiplex_s *)NULL)))
                              ObjectRefDecImpl((void *)multiplex, "commands/cmd_info.c", 333);

                          while((_Bool)0);

                        multiplex=MultiplexFind(argv[(signed long int)i]);
                        if(multiplex == ((struct Multiplex_s *)NULL))
                        {
                          do
                          {
                            struct CommandContext_t *CommandListServices__1__1__1__11__2__1__context;
                            CommandListServices__1__1__1__11__2__1__context=CommandContextGet();
                            CommandListServices__1__1__1__11__2__1__context->errorNumber = (unsigned short int)0xffff;
                            snprintf(CommandListServices__1__1__1__11__2__1__context->errorMessage, (unsigned long int)256, "Failed to find multiplex \"%s\"\n", argv[(signed long int)i]);
                          }
                          while((_Bool)0);
                          goto __CPROVER_DUMP_L41;
                        }

                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if(!(query == ((char *)NULL)))
    list=ServiceListForNameLike(query);

  else
    if(!(multiplex == ((struct Multiplex_s *)NULL)))
    {
      list=ServiceListForMultiplex(multiplex);
      do
        if(!(multiplex == ((struct Multiplex_s *)NULL)))
          ObjectRefDecImpl((void *)multiplex, "commands/cmd_info.c", 352);

      while((_Bool)0);
    }

    else
      list=ServiceListAll();
  struct ListEntry_s *tmp_if_expr_13;
  if(!(list == ((struct List_s *)NULL)))
  {
    struct ListIterator_s iterator;
    iterator.current = list->head;
    iterator.list = list;
    for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_13)
    {
      service = (struct Service_t *)iterator.current->data;
      _Bool return_value_FilterService_14;
      return_value_FilterService_14=FilterService(service, filterByType, filterByAccess, provider);
      if(!(return_value_FilterService_14 == (_Bool)0))
      {
        if(!(dvbIds == (_Bool)0))
        {
          char *idName;
          idName=ServiceGetIDNameStr(service, (char *)(void *)0);
          CommandPrintf("%s\n", idName);
          free((void *)idName);
        }

        else
          CommandPrintf("%s\n", service->name);
      }

      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_13 = iterator.current->next;

      else
        tmp_if_expr_13 = (struct ListEntry_s *)(void *)0;
    }
    ListFree(list, ListFreeObject);
  }


__CPROVER_DUMP_L41:
  ;
}

// CommandLoop
// file ../include/commands.h line 160
void CommandLoop(void)
{
  quit = (_Bool)0;
  while(ExitProgram == (_Bool)0 && quit == (_Bool)0)
  {
    char *line;
    line=readline("DVBStreamer>");
    if(!(line == ((char *)NULL)))
    {
      CommandExecuteConsole(line);
      free((void *)line);
    }

  }
}

// CommandMuxInfo
// file commands/cmd_info.c line 511
static void CommandMuxInfo(signed int argc, char **argv)
{
  struct Multiplex_s *multiplex = (struct Multiplex_s *)(void *)0;
  if(argc == 1)
    multiplex=MultiplexFind(argv[(signed long int)0]);

  if(argc == 2)
  {
    signed int netId = 0;
    signed int tsId = 0;
    sscanf(argv[(signed long int)0], "%x", &netId);
    sscanf(argv[(signed long int)1], "%x", &tsId);
    multiplex=MultiplexFindId(netId, tsId);
  }

  if(!(multiplex == ((struct Multiplex_s *)NULL)))
  {
    char *line;
    CommandPrintf("UID                 : %d\n", multiplex->uid);
    CommandPrintf("ID                  : %04x.%04x\n", multiplex->networkId, multiplex->tsId);
    CommandPrintf("PAT Version         : %d\n", multiplex->patVersion);
    CommandPrintf("Tuning Parameters: \n");
    CommandPrintf("    Type: %s\n", DVBDeliverySystemStr[(signed long int)multiplex->deliverySystem]);
    line=strtok(multiplex->tuningParams, "\n");
    while(!(line == ((char *)NULL)))
    {
      CommandPrintf("    %s\n", line);
      line=strtok((char *)(void *)0, "\n");
    }
    do
      if(!(multiplex == ((struct Multiplex_s *)NULL)))
        ObjectRefDecImpl((void *)multiplex, "commands/cmd_info.c", 540);

    while((_Bool)0);
  }

  else
    do
    {
      struct CommandContext_t *context;
      context=CommandContextGet();
      context->errorNumber = (unsigned short int)0xffff;
      snprintf(context->errorMessage, (unsigned long int)256, "Multiplex not found!");
    }
    while((_Bool)0);
}

// CommandPrintf
// file commands.c line 176
signed int CommandPrintf(const char *fmt, ...)
{
  void **args;
  signed int result = 0;
  struct CommandContext_t *context;
  context=CommandContextGet();
  args = (void **)&fmt;
  result=vfprintf(context->outfp, fmt, args);
  args = ((void **)NULL);
  return result;
}

// CommandProcessFile
// file ../include/commands.h line 167
signed int CommandProcessFile(char *file)
{
  signed int lineno = 0;
  struct _IO_FILE *fp;
  char line[256l];
  char *nl;
  fp=fopen(file, "r");
  signed int return_value_feof_1;
  if(fp == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    quit = (_Bool)0;
    do
    {
      return_value_feof_1=feof(fp);
      if(!(return_value_feof_1 == 0))
        break;

      if(quit != (_Bool)0)
        break;

      char *return_value_fgets_3;
      return_value_fgets_3=fgets(line, (signed int)sizeof(char [256l]) /*256ul*/ , fp);
      if(!(return_value_fgets_3 == ((char *)NULL)))
      {
        nl=strchr(line, 10);
        if(!(nl == ((char *)NULL)))
          *nl = (char)0;

        nl=strchr(line, 13);
        if(!(nl == ((char *)NULL)))
          *nl = (char)0;

        lineno = lineno + 1;
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(line);
        if(return_value_strlen_2 >= 1ul)
        {
          CommandExecute(&ConsoleCommandContext, line);
          if(!((signed int)ConsoleCommandContext.errorNumber == 0x0000))
          {
            if((signed int)ConsoleCommandContext.errorNumber == 0x0002)
              fprintf(stderr, "%s(%d): Unknown command \"%s\"\n", file, lineno, (const void *)line);

            else
              fprintf(stderr, "%s(%d): %s\n", file, lineno, (const void *)ConsoleCommandContext.errorMessage);
          }

        }

      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// CommandPropertyInfo
// file commands/cmd_info.c line 810
static void CommandPropertyInfo(signed int argc, char **argv)
{
  struct PropertyInfo_s propInfo;
  signed int return_value_PropertiesGetInfo_2;
  return_value_PropertiesGetInfo_2=PropertiesGetInfo(argv[(signed long int)0], &propInfo);
  if(return_value_PropertiesGetInfo_2 == 0)
  {
    char *return_value_GetPropertyTypeString_1;
    return_value_GetPropertyTypeString_1=GetPropertyTypeString(propInfo.type);
    CommandPrintf("Type         : %s\n", return_value_GetPropertyTypeString_1);
    CommandPrintf("Readable     : %s\n", (signed int)propInfo.readable == 1 ? "Yes" : "No");
    CommandPrintf("Writeable    : %s\n", (signed int)propInfo.writeable == 1 ? "Yes" : "No");
    CommandPrintf("Has Children : %s\n", (signed int)propInfo.hasChildren == 1 ? "Yes" : "No");
    CommandPrintf("Description  : |\n    %s\n", propInfo.desc == (char *)(void *)0 ? "" : propInfo.desc);
  }

  else
    do
    {
      struct CommandContext_t *context;
      context=CommandContextGet();
      context->errorNumber = (unsigned short int)0xffff;
      snprintf(context->errorMessage, (unsigned long int)256, "Couldn't find property \"%s\"", argv[(signed long int)0]);
    }
    while((_Bool)0);
}

// CommandQuit
// file commands.c line 577
static void CommandQuit(signed int argc, char **argv)
{
  struct CommandContext_t *context;
  context=CommandContextGet();
  if(!(context->remote == (_Bool)0))
    do
    {
      struct CommandContext_t *CommandQuit__1__1__1__context;
      CommandQuit__1__1__1__context=CommandContextGet();
      CommandQuit__1__1__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandQuit__1__1__1__context->errorMessage, (unsigned long int)256, "Only console sessions can do that!");
    }
    while((_Bool)0);

  else
    quit = (_Bool)1;
}

// CommandRegisterCommands
// file commands.c line 153
void CommandRegisterCommands(struct Command_t *commands)
{
  pthread_mutex_lock(&CommandMutex);
  ListAdd(CommandsList, (void *)commands);
  pthread_mutex_unlock(&CommandMutex);
}

// CommandRemoveSF
// file commands/cmd_servicefilter.c line 278
static void CommandRemoveSF(signed int argc, char **argv)
{
  struct ServiceFilter_s *filter;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandRemoveSF__1__1__1__1__context;
        CommandRemoveSF__1__1__1__1__context=CommandContextGet();
        CommandRemoveSF__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandRemoveSF__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(argv[(signed long int)0], PrimaryService);
  if(return_value_strcmp_1 == 0)
    do
    {
      struct CommandContext_t *CommandRemoveSF__1__2__1__context;
      CommandRemoveSF__1__2__1__context=CommandContextGet();
      CommandRemoveSF__1__2__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandRemoveSF__1__2__1__context->errorMessage, (unsigned long int)256, "You cannot remove the primary service!");
    }
    while((_Bool)0);

  else
  {
    struct TSReader_t *reader;
    reader=MainTSReaderGet();
    filter=ServiceFilterFindFilter(reader, argv[(signed long int)0]);
    if(filter == ((struct ServiceFilter_s *)NULL))
      do
      {
        struct CommandContext_t *CommandRemoveSF__1__3__1__1__context;
        CommandRemoveSF__1__3__1__1__context=CommandContextGet();
        CommandRemoveSF__1__3__1__1__context->errorNumber = (unsigned short int)0xffff;
        snprintf(CommandRemoveSF__1__3__1__1__context->errorMessage, (unsigned long int)256, "Service filter not found!");
      }
      while((_Bool)0);

    else
      ServiceFilterDestroy(filter);
  }

__CPROVER_DUMP_L8:
  ;
}

// CommandScan
// file commands/cmd_scanning.c line 438
static void CommandScan(signed int argc, char **argv)
{
  struct Multiplex_s *multiplex;
  signed int i;
  struct DVBAdapter_s *adapter;
  struct DVBSupportedDeliverySys_s *supportedDelSys;
  do
  {
    struct CommandContext_t *CommandScan__1__1__context;
    CommandScan__1__1__context=CommandContextGet();
    if(CommandScan__1__1__context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandScan__1__1__1__1__context;
        CommandScan__1__1__1__1__context=CommandContextGet();
        CommandScan__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandScan__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L23;
    }

  }
  while((_Bool)0);
  pthread_mutex_lock(&scanningmutex);
  _Bool return_value_TuningCurrentServiceIsLocked_4;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(!((signed int)currentScanState == ScanState_Stopped))
    do
    {
      struct CommandContext_t *CommandScan__1__2__1__context;
      CommandScan__1__2__1__context=CommandContextGet();
      CommandScan__1__2__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandScan__1__2__1__context->errorMessage, (unsigned long int)256, "Scan in progress!");
    }
    while((_Bool)0);

  else
  {
    return_value_TuningCurrentServiceIsLocked_4=TuningCurrentServiceIsLocked();
    if(!(return_value_TuningCurrentServiceIsLocked_4 == (_Bool)0))
      do
      {
        struct CommandContext_t *context;
        context=CommandContextGet();
        context->errorNumber = (unsigned short int)0xffff;
        snprintf(context->errorMessage, (unsigned long int)256, "Current Service is locked!");
      }
      while((_Bool)0);

    else
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(argv[(signed long int)0], "all");
      if(return_value_strcmp_3 == 0)
        ScanCurrentMultiplexes();

      else
      {
        return_value_strcmp_2=strcmp(argv[(signed long int)0], "full");
        if(return_value_strcmp_2 == 0)
        {
          adapter=MainDVBAdapterGet();
          supportedDelSys=DVBFrontEndGetDeliverySystems(adapter);
          i = 0;
          for( ; !(i >= supportedDelSys->nrofSystems); i = i + 1)
            switch((signed int)supportedDelSys->systems[(signed long int)i])
            {
              case DELSYS_DVBT:
              {
                ScanFullDVBT();
                break;
              }
              case DELSYS_DVBC:
              {
                ScanFullDVBC();
                break;
              }
              case DELSYS_ATSC:
              {
                ScanFullATSC();
                break;
              }
              default:
                do
                {
                  struct CommandContext_t *CommandScan__1__4__2__1__1__1__1__context;
                  CommandScan__1__4__2__1__1__1__1__context=CommandContextGet();
                  CommandScan__1__4__2__1__1__1__1__context->errorNumber = (unsigned short int)0xffff;
                  snprintf(CommandScan__1__4__2__1__1__1__1__context->errorMessage, (unsigned long int)256, "Frontend type doesn't support a full spectrum scan mode!");
                }
                while((_Bool)0);
            }
          ScanStart((enum ScanType_e)ScanType_List);
        }

        else
        {
          return_value_strcmp_1=strcmp(argv[(signed long int)0], "net");
          if(return_value_strcmp_1 == 0)
          {
            if(argc == 2)
              ScanNetwork(argv[(signed long int)1]);

            else
              do
              {
                struct CommandContext_t *CommandScan__1__4__3__2__1__context;
                CommandScan__1__4__3__2__1__context=CommandContextGet();
                CommandScan__1__4__3__2__1__context->errorNumber = (unsigned short int)0x0003;
                snprintf(CommandScan__1__4__3__2__1__context->errorMessage, (unsigned long int)256, "Expected quoted initial tuning data!");
              }
              while((_Bool)0);
          }

          else
          {
            multiplex=MultiplexFind(argv[(signed long int)0]);
            if(!(multiplex == ((struct Multiplex_s *)NULL)))
            {
              CommandPrintf("Scanning %d\n", multiplex->uid);
              ScanListAddEntry(multiplex->deliverySystem, multiplex, (struct TuningParamDocs_s *)(void *)0);
              ScanStart((enum ScanType_e)ScanType_List);
            }

            else
              do
              {
                struct CommandContext_t *CommandScan__1__4__4__2__1__context;
                CommandScan__1__4__4__2__1__context=CommandContextGet();
                CommandScan__1__4__4__2__1__context->errorNumber = (unsigned short int)0xffff;
                snprintf(CommandScan__1__4__4__2__1__context->errorMessage, (unsigned long int)256, "Failed to find multiplex to scan!");
              }
              while((_Bool)0);
          }
        }
      }
    }
  }
  pthread_mutex_unlock(&scanningmutex);

__CPROVER_DUMP_L23:
  ;
}

// CommandScanCancel
// file commands/cmd_scanning.c line 519
static void CommandScanCancel(signed int argc, char **argv)
{
  ScanStop();
}

// CommandSelect
// file commands/cmd_servicefilter.c line 214
static void CommandSelect(signed int argc, char **argv)
{
  struct Service_t *service;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandSelect__1__1__1__1__context;
        CommandSelect__1__1__1__1__context=CommandContextGet();
        CommandSelect__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandSelect__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  UpdateDatabase();
  service=ServiceFind(argv[(signed long int)0]);
  if(!(service == ((struct Service_t *)NULL)))
  {
    char *idName;
    TuningCurrentServiceSet(service);
    idName=ServiceGetIDNameStr(service, (char *)(void *)0);
    CommandPrintf("%s\n", idName);
    free((void *)idName);
    do
      if(!(service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)service, "commands/cmd_servicefilter.c", 230);

    while((_Bool)0);
  }

  else
    do
    {
      struct CommandContext_t *CommandSelect__1__3__1__context;
      CommandSelect__1__3__1__context=CommandContextGet();
      CommandSelect__1__3__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandSelect__1__3__1__context->errorMessage, (unsigned long int)256, "Service not found!");
    }
    while((_Bool)0);

__CPROVER_DUMP_L8:
  ;
}

// CommandServiceInfo
// file commands/cmd_info.c line 483
static void CommandServiceInfo(signed int argc, char **argv)
{
  struct Service_t *service;
  UpdateDatabase();
  service=ServiceFind(argv[(signed long int)0]);
  if(!(service == ((struct Service_t *)NULL)))
  {
    CommandPrintf("Name                : \"%s\"\n", service->name);
    CommandPrintf("Provider            : \"%s\"\n", service->provider);
    static const char *serviceType[4l] = { "Digital TV", "Digital Radio", "Data", "Unknown" };
    CommandPrintf("Type                : %s\n", serviceType[(signed long int)service->type]);
    CommandPrintf("Conditional Access? : %s\n", service->conditionalAccess != (_Bool)0 ? "CA" : "Free to Air");
    CommandPrintf("ID                  : %04x.%04x.%04x\n", service->networkId, service->tsId, service->id);
    CommandPrintf("Multiplex UID       : %d\n", service->multiplexUID);
    CommandPrintf("Source              : 0x%04x\n", service->source);
    CommandPrintf("Default Authority   : \"%s\"\n", service->defaultAuthority);
    CommandPrintf("PMT PID             : 0x%04x\n", service->pmtPID);
    do
      if(!(service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)service, "commands/cmd_info.c", 503);

    while((_Bool)0);
  }

  else
    do
    {
      struct CommandContext_t *context;
      context=CommandContextGet();
      context->errorNumber = (unsigned short int)0xffff;
      snprintf(context->errorMessage, (unsigned long int)256, "Service not found!");
    }
    while((_Bool)0);
}

// CommandSetMRL
// file commands/cmd_servicefilter.c line 238
static void CommandSetMRL(signed int argc, char **argv)
{
  char *tmpArgs[2l];
  tmpArgs[(signed long int)0] = (char *)PrimaryService;
  tmpArgs[(signed long int)1] = argv[(signed long int)0];
  CommandSetSFMRL(2, tmpArgs);
}

// CommandSetProperty
// file commands/cmd_info.c line 801
static void CommandSetProperty(signed int argc, char **argv)
{
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandSetProperty__1__1__1__1__context;
        CommandSetProperty__1__1__1__1__context=CommandContextGet();
        CommandSetProperty__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandSetProperty__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L6;
    }

  }
  while((_Bool)0);
  signed int return_value_PropertiesSetStr_1;
  return_value_PropertiesSetStr_1=PropertiesSetStr(argv[(signed long int)0], argv[(signed long int)1]);
  if(!(return_value_PropertiesSetStr_1 == 0))
    do
    {
      struct CommandContext_t *CommandSetProperty__1__2__1__context;
      CommandSetProperty__1__2__1__context=CommandContextGet();
      CommandSetProperty__1__2__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandSetProperty__1__2__1__context->errorMessage, (unsigned long int)256, "Failed to set property \"%s\"", argv[(signed long int)0]);
    }
    while((_Bool)0);


__CPROVER_DUMP_L6:
  ;
}

// CommandSetSFAVSOnly
// file commands/cmd_servicefilter.c line 425
static void CommandSetSFAVSOnly(signed int argc, char **argv)
{
  struct ServiceFilter_s *filter;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandSetSFAVSOnly__1__1__1__1__context;
        CommandSetSFAVSOnly__1__1__1__1__context=CommandContextGet();
        CommandSetSFAVSOnly__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandSetSFAVSOnly__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L9;
    }

  }
  while((_Bool)0);
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  filter=ServiceFilterFindFilter(reader, argv[(signed long int)0]);
  signed int return_value_strcasecmp_1;
  if(filter == ((struct ServiceFilter_s *)NULL))
    do
    {
      struct CommandContext_t *CommandSetSFAVSOnly__1__2__1__1__context;
      CommandSetSFAVSOnly__1__2__1__1__context=CommandContextGet();
      CommandSetSFAVSOnly__1__2__1__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandSetSFAVSOnly__1__2__1__1__context->errorMessage, (unsigned long int)256, "Service filter not found!");
    }
    while((_Bool)0);

  else
  {
    signed int return_value_strcasecmp_2;
    return_value_strcasecmp_2=strcasecmp(argv[(signed long int)1], "on");
    if(return_value_strcasecmp_2 == 0)
      ServiceFilterAVSOnlySet(filter, (_Bool)1);

    else
    {
      return_value_strcasecmp_1=strcasecmp(argv[(signed long int)1], "off");
      if(return_value_strcasecmp_1 == 0)
        ServiceFilterAVSOnlySet(filter, (_Bool)0);

      else
        do
        {
          struct CommandContext_t *CommandSetSFAVSOnly__1__5__1__context;
          CommandSetSFAVSOnly__1__5__1__context=CommandContextGet();
          CommandSetSFAVSOnly__1__5__1__context->errorNumber = (unsigned short int)0x0003;
          snprintf(CommandSetSFAVSOnly__1__5__1__context->errorMessage, (unsigned long int)256, "Need to specify on or off.\n");
        }
        while((_Bool)0);
    }
  }

__CPROVER_DUMP_L9:
  ;
}

// CommandSetSFMRL
// file commands/cmd_servicefilter.c line 395
static void CommandSetSFMRL(signed int argc, char **argv)
{
  struct ServiceFilter_s *filter;
  struct DeliveryMethodInstance_t *instance;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandSetSFMRL__1__1__1__1__context;
        CommandSetSFMRL__1__1__1__1__context=CommandContextGet();
        CommandSetSFMRL__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandSetSFMRL__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  filter=ServiceFilterFindFilter(reader, argv[(signed long int)0]);
  if(filter == ((struct ServiceFilter_s *)NULL))
    do
    {
      struct CommandContext_t *CommandSetSFMRL__1__2__1__1__context;
      CommandSetSFMRL__1__2__1__1__context=CommandContextGet();
      CommandSetSFMRL__1__2__1__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandSetSFMRL__1__2__1__1__context->errorMessage, (unsigned long int)256, "Service filter not found!");
    }
    while((_Bool)0);

  else
  {
    instance=DeliveryMethodCreate(argv[(signed long int)1]);
    if(!(instance == ((struct DeliveryMethodInstance_t *)NULL)))
    {
      ServiceFilterDeliveryMethodSet(filter, instance);
      struct DeliveryMethodInstance_t *return_value_ServiceFilterDeliveryMethodGet_1;
      return_value_ServiceFilterDeliveryMethodGet_1=ServiceFilterDeliveryMethodGet(filter);
      char *return_value_DeliveryMethodGetMRL_2;
      return_value_DeliveryMethodGetMRL_2=DeliveryMethodGetMRL(return_value_ServiceFilterDeliveryMethodGet_1);
      CommandPrintf("MRL set to \"%s\" for %s\n", return_value_DeliveryMethodGetMRL_2, argv[(signed long int)0]);
    }

    else
      do
      {
        struct CommandContext_t *CommandSetSFMRL__1__4__1__context;
        CommandSetSFMRL__1__4__1__context=CommandContextGet();
        CommandSetSFMRL__1__4__1__context->errorNumber = (unsigned short int)0xffff;
        snprintf(CommandSetSFMRL__1__4__1__context->errorMessage, (unsigned long int)256, "Failed to set MRL!");
      }
      while((_Bool)0);
  }

__CPROVER_DUMP_L8:
  ;
}

// CommandSetSFService
// file commands/cmd_servicefilter.c line 340
static void CommandSetSFService(signed int argc, char **argv)
{
  struct ServiceFilter_s *filter;
  char *outputName = argv[(signed long int)0];
  char *serviceName = argv[(signed long int)1];
  struct Service_t *service;
  char *idName;
  do
  {
    struct CommandContext_t *context;
    context=CommandContextGet();
    if(context->authenticated == (_Bool)0)
    {
      do
      {
        struct CommandContext_t *CommandSetSFService__1__1__1__1__context;
        CommandSetSFService__1__1__1__1__context=CommandContextGet();
        CommandSetSFService__1__1__1__1__context->errorNumber = (unsigned short int)0x0004;
        snprintf(CommandSetSFService__1__1__1__1__context->errorMessage, (unsigned long int)256, "Not authenticated!");
      }
      while((_Bool)0);
      goto __CPROVER_DUMP_L13;
    }

  }
  while((_Bool)0);
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(outputName, PrimaryService);
  if(return_value_strcmp_1 == 0)
    do
    {
      struct CommandContext_t *CommandSetSFService__1__2__1__context;
      CommandSetSFService__1__2__1__context=CommandContextGet();
      CommandSetSFService__1__2__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(CommandSetSFService__1__2__1__context->errorMessage, (unsigned long int)256, "Use 'select' to change the primary service!");
    }
    while((_Bool)0);

  else
  {
    struct TSReader_t *reader;
    reader=MainTSReaderGet();
    filter=ServiceFilterFindFilter(reader, outputName);
    if(filter == ((struct ServiceFilter_s *)NULL))
      do
      {
        struct CommandContext_t *CommandSetSFService__1__3__1__1__context;
        CommandSetSFService__1__3__1__1__context=CommandContextGet();
        CommandSetSFService__1__3__1__1__context->errorNumber = (unsigned short int)0xffff;
        snprintf(CommandSetSFService__1__3__1__1__context->errorMessage, (unsigned long int)256, "Service filter not found!");
      }
      while((_Bool)0);

    else
    {
      service=ServiceFindName(serviceName);
      if(service == ((struct Service_t *)NULL))
        service=ServiceFindFQIDStr(serviceName);

      if(service == ((struct Service_t *)NULL))
        do
        {
          struct CommandContext_t *CommandSetSFService__1__5__1__context;
          CommandSetSFService__1__5__1__context=CommandContextGet();
          CommandSetSFService__1__5__1__context->errorNumber = (unsigned short int)0xffff;
          snprintf(CommandSetSFService__1__5__1__context->errorMessage, (unsigned long int)256, "Service not found!");
        }
        while((_Bool)0);

      else
      {
        ServiceFilterServiceSet(filter, service);
        idName=ServiceGetIDNameStr(service, (char *)(void *)0);
        CommandPrintf("%s\n", idName);
        free((void *)idName);
        do
          if(!(service == ((struct Service_t *)NULL)))
            ObjectRefDecImpl((void *)service, "commands/cmd_servicefilter.c", 375);

        while((_Bool)0);
      }
    }
  }

__CPROVER_DUMP_L13:
  ;
}

// CommandStats
// file commands/cmd_info.c line 549
static void CommandStats(signed int argc, char **argv)
{
  struct TSReader_t *tsReader;
  tsReader=MainTSReaderGet();
  struct TSReaderStats_t *stats;
  stats=TSReaderExtractStats(tsReader);
  struct TSFilterGroupTypeStats_t *typeStats = stats->types;
  for( ; !(typeStats == ((struct TSFilterGroupTypeStats_t *)NULL)); typeStats = typeStats->next)
  {
    struct TSFilterGroupStats_t *groupStats;
    CommandPrintf("%s: \n", typeStats->type);
    groupStats = typeStats->groups;
    for( ; !(groupStats == ((struct TSFilterGroupStats_t *)NULL)); groupStats = groupStats->next)
      CommandPrintf("    %20s : %lld (%lld)\n", groupStats->name, groupStats->packetsProcessed, groupStats->sectionsProcessed);
    CommandPrintf("\n");
  }
  CommandPrintf("Total packets processed: %lld\n", stats->totalPackets);
  CommandPrintf("Approximate TS bitrate : %gMbs\n", (double)stats->bitrate / (1024.0 * 1024.0));
  ObjectRefDecImpl((void *)stats, "commands/cmd_info.c", 566);
}

// CommandUnInstallEPG
// file commands/cmd_epg.c line 71
void CommandUnInstallEPG(void)
{
  CommandUnRegisterCommands(CommandEPGInfo);
}

// CommandUnInstallInfo
// file commands/cmd_info.c line 238
void CommandUnInstallInfo(void)
{
  CommandUnRegisterCommands(CommandDetailsInfo);
}

// CommandUnInstallScanning
// file commands/cmd_scanning.c line 408
void CommandUnInstallScanning(void)
{
  struct ev_loop *loop;
  loop=DispatchersGetInput();
  ev_async_stop(loop, &scanStartAsync);
  CommandUnRegisterCommands(CommandDetailsScanning);
  PropertiesRemoveAllProperties(propertyParent_link1);
  struct Event_s *return_value_EventsFindEvent_1;
  return_value_EventsFindEvent_1=EventsFindEvent("DVBAdapter.Locked");
  EventsUnregisterEventListener(return_value_EventsFindEvent_1, FELockedEventListener, (void *)0);
  struct Event_s *return_value_EventsFindEvent_2;
  return_value_EventsFindEvent_2=EventsFindEvent("MPEG2.PAT");
  EventsUnregisterEventListener(return_value_EventsFindEvent_2, PATEventListener, (void *)0);
  struct Event_s *return_value_EventsFindEvent_3;
  return_value_EventsFindEvent_3=EventsFindEvent("MPEG2.PMT");
  EventsUnregisterEventListener(return_value_EventsFindEvent_3, PMTEventListener, (void *)0);
  _Bool return_value_MainIsDVB_6;
  return_value_MainIsDVB_6=MainIsDVB();
  if(!(return_value_MainIsDVB_6 == (_Bool)0))
  {
    struct Event_s *return_value_EventsFindEvent_4;
    return_value_EventsFindEvent_4=EventsFindEvent("DVB.SDT");
    EventsUnregisterEventListener(return_value_EventsFindEvent_4, SDTEventListener, (void *)0);
    struct Event_s *return_value_EventsFindEvent_5;
    return_value_EventsFindEvent_5=EventsFindEvent("DVB.NIT");
    EventsUnregisterEventListener(return_value_EventsFindEvent_5, NITEventListener, (void *)0);
  }

  _Bool return_value_MainIsATSC_8;
  return_value_MainIsATSC_8=MainIsATSC();
  if(!(return_value_MainIsATSC_8 == (_Bool)0))
  {
    struct Event_s *return_value_EventsFindEvent_7;
    return_value_EventsFindEvent_7=EventsFindEvent("ATSC.VCT");
    EventsUnregisterEventListener(return_value_EventsFindEvent_7, VCTEventListener, (void *)0);
  }

}

// CommandUnInstallServiceFilter
// file commands/cmd_servicefilter.c line 205
void CommandUnInstallServiceFilter(void)
{
  CommandUnRegisterCommands(CommandDetailsServiceFilter);
}

// CommandUnRegisterCommands
// file commands.c line 160
void CommandUnRegisterCommands(struct Command_t *commands)
{
  pthread_mutex_lock(&CommandMutex);
  ListRemove(CommandsList, (void *)commands);
  pthread_mutex_unlock(&CommandMutex);
}

// CompleteCommand
// file commands.c line 331
static char * CompleteCommand(const char *text, signed int state)
{
  signed int i;
  static struct ListIterator_s iterator;
  static signed int textlen;
  static signed int lastIndex = -1;
  if(state == 0)
  {
    lastIndex = -1;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(text);
    textlen = (signed int)return_value_strlen_1;
    iterator.current = CommandsList->head;
    iterator.list = CommandsList;
  }

  struct ListEntry_s *tmp_if_expr_4;
  while(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct Command_t *commands = (struct Command_t *)iterator.current->data;
    i = lastIndex + 1;
    for( ; !((commands + (signed long int)i)->command == ((char *)NULL)); i = i + 1)
    {
      signed int return_value_strncasecmp_3;
      return_value_strncasecmp_3=strncasecmp(text, (commands + (signed long int)i)->command, (unsigned long int)textlen);
      if(return_value_strncasecmp_3 == 0)
      {
        lastIndex = i;
        char *return_value_strdup_2;
        return_value_strdup_2=strdup((commands + (signed long int)i)->command);
        return return_value_strdup_2;
      }

    }
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_4 = iterator.current->next;

    else
      tmp_if_expr_4 = (struct ListEntry_s *)(void *)0;
    iterator.current = tmp_if_expr_4;
    lastIndex = -1;
  }
  return (char *)(void *)0;
}

// ConvertDTVPropertiesToYaml
// file dvbadapter.c line 1801
static void ConvertDTVPropertiesToYaml(enum DVBDeliverySystem_e delSys, struct dtv_properties *feparams, struct DVBSatelliteSettings_s *satSettings, struct yaml_document_s *doc)
{
  char temp[25l];
  sprintf(temp, "%u", (feparams->props + (signed long int)1)->u.data);
  YamlUtils_MappingAdd(doc, 1, TAG_FREQUENCY, temp);
  char *return_value_MapValueToString_1;
  return_value_MapValueToString_1=MapValueToString(inversionMapping, (feparams->props + (signed long int)2)->u.data, "AUTO");
  YamlUtils_MappingAdd(doc, 1, TAG_INVERSION, return_value_MapValueToString_1);
  char *return_value_MapValueToString_2;
  char *return_value_MapValueToString_3;
  char *return_value_MapValueToString_4;
  char *return_value_MapValueToString_5;
  char *return_value_MapValueToString_6;
  char *return_value_MapValueToString_7;
  char *return_value_MapValueToString_8;
  char *return_value_MapValueToString_9;
  char *return_value_MapValueToString_10;
  char *return_value_MapValueToString_11;
  char *return_value_MapValueToString_12;
  char *return_value_MapValueToString_13;
  char *return_value_MapValueToString_14;
  char *return_value_MapValueToString_15;
  char *return_value_MapValueToString_16;
  char *return_value_MapValueToString_17;
  char *return_value_MapValueToString_18;
  char *return_value_MapValueToString_19;
  switch((signed int)delSys)
  {
    case DELSYS_DVBS:
    {
      return_value_MapValueToString_2=MapValueToString(fecMapping, (feparams->props + (signed long int)3)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_FEC, return_value_MapValueToString_2);
      sprintf(temp, "%u", (feparams->props + (signed long int)4)->u.data);
      YamlUtils_MappingAdd(doc, 1, TAG_SYMBOL_RATE, temp);
      return_value_MapValueToString_3=MapValueToString(polarisationMapping, (unsigned int)satSettings->polarisation, "Horizontal");
      YamlUtils_MappingAdd(doc, 1, TAG_POLARISATION, return_value_MapValueToString_3);
      sprintf(temp, "%u", satSettings->satellite_number);
      YamlUtils_MappingAdd(doc, 1, TAG_SATELLITE_NUMBER, temp);
      break;
    }
    case DELSYS_DVBS2:
    {
      return_value_MapValueToString_4=MapValueToString(modulationMapping, (feparams->props + (signed long int)5)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_MODULATION, return_value_MapValueToString_4);
      return_value_MapValueToString_5=MapValueToString(fecMapping, (feparams->props + (signed long int)3)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_FEC, return_value_MapValueToString_5);
      sprintf(temp, "%u", (feparams->props + (signed long int)4)->u.data);
      YamlUtils_MappingAdd(doc, 1, TAG_SYMBOL_RATE, temp);
      return_value_MapValueToString_6=MapValueToString(pilotMapping, (feparams->props + (signed long int)6)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_PILOT, return_value_MapValueToString_6);
      return_value_MapValueToString_7=MapValueToString(rollOffMapping, (feparams->props + (signed long int)7)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_ROLL_OFF, return_value_MapValueToString_7);
      return_value_MapValueToString_8=MapValueToString(polarisationMapping, (unsigned int)satSettings->polarisation, "Horizontal");
      YamlUtils_MappingAdd(doc, 1, TAG_POLARISATION, return_value_MapValueToString_8);
      sprintf(temp, "%u", satSettings->satellite_number);
      YamlUtils_MappingAdd(doc, 1, TAG_SATELLITE_NUMBER, temp);
      break;
    }
    case DELSYS_DVBC:
    {
      return_value_MapValueToString_9=MapValueToString(fecMapping, (feparams->props + (signed long int)3)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_FEC, return_value_MapValueToString_9);
      sprintf(temp, "%u", (feparams->props + (signed long int)4)->u.data);
      YamlUtils_MappingAdd(doc, 1, TAG_SYMBOL_RATE, temp);
      return_value_MapValueToString_10=MapValueToString(modulationMapping, (feparams->props + (signed long int)5)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_MODULATION, return_value_MapValueToString_10);
      break;
    }
    case DELSYS_DVBT:
    {
      sprintf(temp, "%u", (feparams->props + (signed long int)3)->u.data);
      YamlUtils_MappingAdd(doc, 1, TAG_BANDWIDTH, temp);
      return_value_MapValueToString_11=MapValueToString(fecMapping, (feparams->props + (signed long int)4)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_FEC_HP, return_value_MapValueToString_11);
      return_value_MapValueToString_12=MapValueToString(fecMapping, (feparams->props + (signed long int)5)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_FEC_LP, return_value_MapValueToString_12);
      return_value_MapValueToString_13=MapValueToString(modulationMapping, (feparams->props + (signed long int)6)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_CONSTELLATION, return_value_MapValueToString_13);
      return_value_MapValueToString_14=MapValueToString(guardIntervalMapping, (feparams->props + (signed long int)7)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_GUARD_INTERVAL, return_value_MapValueToString_14);
      return_value_MapValueToString_15=MapValueToString(transmissonModeMapping, (feparams->props + (signed long int)8)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_TRANSMISSION_MODE, return_value_MapValueToString_15);
      return_value_MapValueToString_16=MapValueToString(hierarchyMapping, (feparams->props + (signed long int)9)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_HIERARCHY, return_value_MapValueToString_16);
      break;
    }
    case DELSYS_ATSC:
    {
      return_value_MapValueToString_17=MapValueToString(modulationMapping, (feparams->props + (signed long int)3)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_MODULATION, return_value_MapValueToString_17);
      break;
    }
    case DELSYS_ISDBT:
    {
      sprintf(temp, "%u", (feparams->props + (signed long int)3)->u.data);
      YamlUtils_MappingAdd(doc, 1, TAG_BANDWIDTH, temp);
      return_value_MapValueToString_18=MapValueToString(guardIntervalMapping, (feparams->props + (signed long int)7)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_GUARD_INTERVAL, return_value_MapValueToString_18);
      return_value_MapValueToString_19=MapValueToString(transmissonModeMapping, (feparams->props + (signed long int)8)->u.data, "AUTO");
      YamlUtils_MappingAdd(doc, 1, TAG_TRANSMISSION_MODE, return_value_MapValueToString_19);
      break;
    }
    default:
      ;
  }
}

// ConvertDVBServiceType
// file standard/dvb/sdtprocessor.c line 269
static enum anonymous ConvertDVBServiceType(signed int type)
{
  enum anonymous result = (enum anonymous)ServiceType_Unknown;
  switch(type)
  {
    case 1:
    {
      result = (enum anonymous)ServiceType_TV;
      goto __CPROVER_DUMP_L4;
    }
    case 2:
    {
      result = (enum anonymous)ServiceType_Radio;
      goto __CPROVER_DUMP_L4;
    }
    case 3:

    case 12:

    case 16:
      result = (enum anonymous)ServiceType_Data;
    default:
    {

    __CPROVER_DUMP_L4:
      ;
      return result;
    }
  }
}

// ConvertStringToBandwith
// file dvbadapter.c line 1695
static unsigned int ConvertStringToBandwith(const char *str, unsigned int defaultValue)
{
  char *suffix;
  unsigned int result;
  unsigned long int return_value_strtoul_1;
  return_value_strtoul_1=strtoul(str, &suffix, 10);
  result = (unsigned int)return_value_strtoul_1;
  if(suffix == str)
    result = defaultValue;

  else
    if(!(*suffix == 0))
    {
      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(suffix, "Mhz");
      if(return_value_strcasecmp_2 == 0)
        result = result * (unsigned int)1000000;

      else
        result = defaultValue;
    }

  return result;
}

// ConvertStringToUInt32
// file dvbadapter.c line 1595
static unsigned int ConvertStringToUInt32(const char *str, unsigned int defaultValue)
{
  char *suffix;
  unsigned int result;
  unsigned long int return_value_strtoul_1;
  return_value_strtoul_1=strtoul(str, &suffix, 10);
  result = (unsigned int)return_value_strtoul_1;
  if(suffix == str)
    result = defaultValue;

  return result;
}

// ConvertYamlNode
// file dvbadapter.c line 1606
static unsigned int ConvertYamlNode(struct yaml_document_s *document, const char *key, unsigned int (*convert)(const char *, unsigned int), unsigned int defaultValue)
{
  struct yaml_node_s *node;
  struct yaml_node_s *return_value_yaml_document_get_root_node_1;
  return_value_yaml_document_get_root_node_1=yaml_document_get_root_node(document);
  node=YamlUtils_MappingFind(document, return_value_yaml_document_get_root_node_1, key);
  if(!(node == ((struct yaml_node_s *)NULL)))
  {
    if((signed int)node->type == YAML_SCALAR_NODE)
    {
      unsigned int return_value;
      return_value=convert((const char *)node->data.scalar.value, defaultValue);
      return return_value;
    }

  }

  return defaultValue;
}

// ConvertYamlToDTVProperties
// file dvbadapter.c line 1717
static void ConvertYamlToDTVProperties(enum DVBDeliverySystem_e delSys, struct yaml_document_s *doc, struct DVBAdapter_s *adapter)
{
  adapter->frontEndRequestedFreq=ConvertYamlNode(doc, TAG_FREQUENCY, ConvertStringToUInt32, (unsigned int)0);
  do
  {
    adapter->frontEndPropertyArray[(signed long int)1].cmd = (unsigned int)3;
    adapter->frontEndPropertyArray[(signed long int)1].u.data = adapter->frontEndRequestedFreq;
  }
  while((_Bool)0);
  do
  {
    adapter->frontEndPropertyArray[(signed long int)2].cmd = (unsigned int)6;
    adapter->frontEndPropertyArray[(signed long int)2].u.data=MapYamlNode(doc, TAG_INVERSION, inversionMapping, (unsigned int)INVERSION_AUTO);
  }
  while((_Bool)0);
  unsigned int return_value_MapYamlNode_1;
  unsigned int return_value_MapYamlNode_2;
  unsigned int return_value_MapYamlNode_3;
  unsigned int return_value_MapYamlNode_4;
  unsigned int return_value_MapYamlNode_5;
  unsigned int return_value_MapYamlNode_6;
  unsigned int return_value_MapYamlNode_7;
  unsigned int return_value_MapYamlNode_8;
  unsigned int return_value_MapYamlNode_9;
  unsigned int return_value_MapYamlNode_10;
  switch((signed int)delSys)
  {
    case DELSYS_DVBS:
    {
      do
      {
        adapter->frontEndPropertyArray[(signed long int)0].cmd = (unsigned int)17;
        adapter->frontEndPropertyArray[(signed long int)0].u.data = (unsigned int)5;
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)3].cmd = (unsigned int)9;
        adapter->frontEndPropertyArray[(signed long int)3].u.data=MapYamlNode(doc, TAG_FEC, fecMapping, (unsigned int)FEC_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)4].cmd = (unsigned int)8;
        adapter->frontEndPropertyArray[(signed long int)4].u.data=ConvertYamlNode(doc, TAG_SYMBOL_RATE, ConvertStringToUInt32, (unsigned int)0);
      }
      while((_Bool)0);
      adapter->frontEndProperties.num = (unsigned int)5;
      return_value_MapYamlNode_1=MapYamlNode(doc, TAG_POLARISATION, polarisationMapping, (unsigned int)POL_HORIZONTAL);
      adapter->satelliteSettings.polarisation = (enum Polarisation_e)return_value_MapYamlNode_1;
      adapter->satelliteSettings.satellite_number=ConvertYamlNode(doc, TAG_SATELLITE_NUMBER, ConvertStringToUInt32, (unsigned int)0);
      break;
    }
    case DELSYS_DVBS2:
    {
      do
      {
        adapter->frontEndPropertyArray[(signed long int)0].cmd = (unsigned int)17;
        adapter->frontEndPropertyArray[(signed long int)0].u.data = (unsigned int)6;
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)5].cmd = (unsigned int)4;
        adapter->frontEndPropertyArray[(signed long int)5].u.data=MapYamlNode(doc, TAG_MODULATION, modulationMapping, (unsigned int)QPSK);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)3].cmd = (unsigned int)9;
        adapter->frontEndPropertyArray[(signed long int)3].u.data=MapYamlNode(doc, TAG_FEC, fecMapping, (unsigned int)FEC_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)4].cmd = (unsigned int)8;
        adapter->frontEndPropertyArray[(signed long int)4].u.data=ConvertYamlNode(doc, TAG_SYMBOL_RATE, ConvertStringToUInt32, (unsigned int)0);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)6].cmd = (unsigned int)12;
        adapter->frontEndPropertyArray[(signed long int)6].u.data=MapYamlNode(doc, TAG_PILOT, pilotMapping, (unsigned int)2);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)7].cmd = (unsigned int)13;
        adapter->frontEndPropertyArray[(signed long int)7].u.data=MapYamlNode(doc, TAG_ROLL_OFF, rollOffMapping, (unsigned int)3);
      }
      while((_Bool)0);
      adapter->frontEndProperties.num = (unsigned int)8;
      return_value_MapYamlNode_2=MapYamlNode(doc, TAG_POLARISATION, polarisationMapping, (unsigned int)POL_HORIZONTAL);
      adapter->satelliteSettings.polarisation = (enum Polarisation_e)return_value_MapYamlNode_2;
      adapter->satelliteSettings.satellite_number=ConvertYamlNode(doc, TAG_SATELLITE_NUMBER, ConvertStringToUInt32, (unsigned int)0);
      break;
    }
    case DELSYS_DVBC:
    {
      do
      {
        adapter->frontEndPropertyArray[(signed long int)0].cmd = (unsigned int)17;
        adapter->frontEndPropertyArray[(signed long int)0].u.data = (unsigned int)1;
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)3].cmd = (unsigned int)9;
        adapter->frontEndPropertyArray[(signed long int)3].u.data=MapYamlNode(doc, TAG_FEC, fecMapping, (unsigned int)FEC_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)4].cmd = (unsigned int)8;
        adapter->frontEndPropertyArray[(signed long int)4].u.data=ConvertYamlNode(doc, TAG_SYMBOL_RATE, ConvertStringToUInt32, (unsigned int)0);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)5].cmd = (unsigned int)4;
        adapter->frontEndPropertyArray[(signed long int)5].u.data=MapYamlNode(doc, TAG_MODULATION, modulationMapping, (unsigned int)QAM_AUTO);
      }
      while((_Bool)0);
      adapter->frontEndProperties.num = (unsigned int)6;
      break;
    }
    case DELSYS_DVBT:
    {
      do
      {
        adapter->frontEndPropertyArray[(signed long int)0].cmd = (unsigned int)17;
        adapter->frontEndPropertyArray[(signed long int)0].u.data = (unsigned int)3;
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)3].cmd = (unsigned int)5;
        adapter->frontEndPropertyArray[(signed long int)3].u.data=ConvertYamlNode(doc, TAG_BANDWIDTH, ConvertStringToBandwith, (unsigned int)0);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)4].cmd = (unsigned int)36;
        adapter->frontEndPropertyArray[(signed long int)4].u.data=MapYamlNode(doc, TAG_FEC_HP, fecMapping, (unsigned int)FEC_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)5].cmd = (unsigned int)37;
        adapter->frontEndPropertyArray[(signed long int)5].u.data=MapYamlNode(doc, TAG_FEC_LP, fecMapping, (unsigned int)FEC_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)6].cmd = (unsigned int)4;
        adapter->frontEndPropertyArray[(signed long int)6].u.data=MapYamlNode(doc, TAG_CONSTELLATION, modulationMapping, (unsigned int)QAM_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)7].cmd = (unsigned int)38;
        adapter->frontEndPropertyArray[(signed long int)7].u.data=MapYamlNode(doc, TAG_GUARD_INTERVAL, guardIntervalMapping, (unsigned int)GUARD_INTERVAL_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)8].cmd = (unsigned int)39;
        adapter->frontEndPropertyArray[(signed long int)8].u.data=MapYamlNode(doc, TAG_TRANSMISSION_MODE, transmissonModeMapping, (unsigned int)TRANSMISSION_MODE_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)9].cmd = (unsigned int)40;
        adapter->frontEndPropertyArray[(signed long int)9].u.data=MapYamlNode(doc, TAG_HIERARCHY, hierarchyMapping, (unsigned int)HIERARCHY_AUTO);
      }
      while((_Bool)0);
      adapter->frontEndProperties.num = (unsigned int)10;
      break;
    }
    case DELSYS_ATSC:
    {
      do
      {
        adapter->frontEndPropertyArray[(signed long int)0].cmd = (unsigned int)17;
        adapter->frontEndPropertyArray[(signed long int)0].u.data = (unsigned int)11;
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)3].cmd = (unsigned int)4;
        adapter->frontEndPropertyArray[(signed long int)3].u.data=MapYamlNode(doc, TAG_MODULATION, modulationMapping, (unsigned int)QAM_AUTO);
      }
      while((_Bool)0);
      adapter->frontEndProperties.num = (unsigned int)4;
      break;
    }
    case DELSYS_ISDBT:
    {
      do
      {
        adapter->frontEndPropertyArray[(signed long int)0].cmd = (unsigned int)17;
        adapter->frontEndPropertyArray[(signed long int)0].u.data = (unsigned int)8;
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)3].cmd = (unsigned int)5;
        adapter->frontEndPropertyArray[(signed long int)3].u.data=ConvertYamlNode(doc, TAG_BANDWIDTH, ConvertStringToBandwith, (unsigned int)0);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)4].cmd = (unsigned int)39;
        adapter->frontEndPropertyArray[(signed long int)4].u.data=MapYamlNode(doc, TAG_TRANSMISSION_MODE, transmissonModeMapping, (unsigned int)TRANSMISSION_MODE_AUTO);
      }
      while((_Bool)0);
      do
      {
        adapter->frontEndPropertyArray[(signed long int)5].cmd = (unsigned int)38;
        adapter->frontEndPropertyArray[(signed long int)5].u.data=MapYamlNode(doc, TAG_GUARD_INTERVAL, guardIntervalMapping, (unsigned int)GUARD_INTERVAL_AUTO);
      }
      while((_Bool)0);
      adapter->frontEndProperties.num = (unsigned int)6;
      adapter->isdbFEParams.frequency=ConvertYamlNode(doc, TAG_FREQUENCY, ConvertStringToUInt32, (unsigned int)0);
      return_value_MapYamlNode_3=MapYamlNode(doc, TAG_INVERSION, inversionMapping, (unsigned int)INVERSION_AUTO);
      adapter->isdbFEParams.inversion = (enum fe_spectral_inversion)return_value_MapYamlNode_3;
      return_value_MapYamlNode_4=MapYamlNode(doc, TAG_BANDWIDTH, bandwidthMapping, (unsigned int)BANDWIDTH_AUTO);
      adapter->isdbFEParams.u.ofdm.bandwidth = (enum fe_bandwidth)return_value_MapYamlNode_4;
      return_value_MapYamlNode_5=MapYamlNode(doc, TAG_FEC_HP, fecMapping, (unsigned int)FEC_AUTO);
      adapter->isdbFEParams.u.ofdm.code_rate_HP = (enum fe_code_rate)return_value_MapYamlNode_5;
      return_value_MapYamlNode_6=MapYamlNode(doc, TAG_FEC_LP, fecMapping, (unsigned int)FEC_AUTO);
      adapter->isdbFEParams.u.ofdm.code_rate_LP = (enum fe_code_rate)return_value_MapYamlNode_6;
      return_value_MapYamlNode_7=MapYamlNode(doc, TAG_CONSTELLATION, modulationMapping, (unsigned int)QAM_AUTO);
      adapter->isdbFEParams.u.ofdm.constellation = (enum fe_modulation)return_value_MapYamlNode_7;
      return_value_MapYamlNode_8=MapYamlNode(doc, TAG_GUARD_INTERVAL, guardIntervalMapping, (unsigned int)GUARD_INTERVAL_AUTO);
      adapter->isdbFEParams.u.ofdm.guard_interval = (enum fe_guard_interval)return_value_MapYamlNode_8;
      return_value_MapYamlNode_9=MapYamlNode(doc, TAG_TRANSMISSION_MODE, transmissonModeMapping, (unsigned int)TRANSMISSION_MODE_AUTO);
      adapter->isdbFEParams.u.ofdm.transmission_mode = (enum fe_transmit_mode)return_value_MapYamlNode_9;
      return_value_MapYamlNode_10=MapYamlNode(doc, TAG_HIERARCHY, hierarchyMapping, (unsigned int)HIERARCHY_AUTO);
      adapter->isdbFEParams.u.ofdm.hierarchy_information = (enum fe_hierarchy)return_value_MapYamlNode_10;
    }
    default:
      ;
  }
  adapter->frontEndPropertyArray[(signed long int)adapter->frontEndProperties.num].cmd = (unsigned int)1;
  adapter->frontEndProperties.num = adapter->frontEndProperties.num + 1u;
}

// DBaseCheckVersion
// file dbase.c line 151
static signed int DBaseCheckVersion()
{
  signed int rc;
  double DBaseCheckVersion__1__version;
  rc=DBaseMetadataGetDouble("dbase_version", &DBaseCheckVersion__1__version);
  if(!(rc == 0))
  {
    LogModule(3, DBASE, "Failed to get version from Metadata table (%d)\n", rc);
    rc=DBaseCreateTables();
  }

  else
  {
    LogModule(3, DBASE, "Current version of database is %f\n", DBaseCheckVersion__1__version);
    if(DBaseCheckVersion__1__version < 2.0)
    {
      signed int pid;
      char path[4096l];
      char *filename;
      signed long int len;
      signed int return_value_getpid_1;
      return_value_getpid_1=getpid();
      sprintf(path, "/proc/%d/exe", return_value_getpid_1);
      len=readlink(path, path, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
      path[len] = (char)0;
      filename=strrchr(path, 47);
      strcpy(filename + (signed long int)1, "convertdvbdb");
      pid=fork();
      if(!(pid == 0))
        waitpid(pid, &rc, 0);

      else
      {
        execl(path, path, (const void *)dbaseFile, (void *)0);
        exit(1);
      }
    }

  }
  return rc;
}

// DBaseConnectionGet
// file ../include/dbase.h line 323
struct sqlite3 * DBaseConnectionGet(void)
{
  struct sqlite3 *connection;
  void *return_value_pthread_getspecific_1;
  return_value_pthread_getspecific_1=pthread_getspecific(dbaseKey);
  connection = (struct sqlite3 *)return_value_pthread_getspecific_1;
  if(connection == ((struct sqlite3 *)NULL))
  {
    signed int rc;
    rc=sqlite3_open(dbaseFile, &connection);
    if(!(rc == 0))
    {
      const char *return_value_sqlite3_errmsg_2;
      return_value_sqlite3_errmsg_2=sqlite3_errmsg(connection);
      LogModule(0, DBASE, "Can't open database: %s\n", return_value_sqlite3_errmsg_2);
      sqlite3_close(connection);
      connection = (struct sqlite3 *)(void *)0;
    }

    else
    {
      LogModule(3, DBASE, "Database opened successfully. (%p)\n", connection);
      sqlite3_busy_timeout(connection, 500);
      pthread_setspecific(dbaseKey, (void *)connection);
    }
  }

  return connection;
}

// DBaseCount
// file ../include/dbase.h line 344
signed int DBaseCount(char *table, char *where)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  signed int result = -1;
  if(where == ((char *)NULL))
    do
    {
      char *sqlstring;
      sqlstring=sqlite3_mprintf("SELECT count() FROM %s;", table);
      if(!(sqlstring == ((char *)NULL)))
      {
        struct sqlite3 *return_value_DBaseConnectionGet_1;
        return_value_DBaseConnectionGet_1=DBaseConnectionGet();
        rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
        sqlite3_free((void *)sqlstring);
      }

      else
        rc = 7;
    }
    while((_Bool)0);

  else
    do
    {
      char *DBaseCount__1__2__1__sqlstring;
      DBaseCount__1__2__1__sqlstring=sqlite3_mprintf("SELECT count() FROM %s WHERE %s;", table, where);
      if(!(DBaseCount__1__2__1__sqlstring == ((char *)NULL)))
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        rc=sqlite3_prepare(return_value_DBaseConnectionGet_2, DBaseCount__1__2__1__sqlstring, -1, &stmt, (const char **)(void *)0);
        sqlite3_free((void *)DBaseCount__1__2__1__sqlstring);
      }

      else
        rc = 7;
    }
    while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_3;
        return_value_DBaseConnectionGet_3=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_4;
        return_value_sqlite3_errmsg_4=sqlite3_errmsg(return_value_DBaseConnectionGet_3);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseCount", 136, rc, return_value_sqlite3_errmsg_4);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return -1;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  if(rc == 100)
  {
    result=sqlite3_column_int(stmt, 0);
    rc = 0;
  }

  rc=sqlite3_finalize(stmt);
  return result;
}

// DBaseCreateTables
// file dbase.c line 193
static signed int DBaseCreateTables(void)
{
  signed int rc = 0;
  LogModule(3, DBASE, "Creating tables\n");
  sqlite3_exec(DBaseInstance, "BEGIN TRANSACTION;", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  rc=sqlite3_exec(DBaseInstance, "CREATE TABLE Metadata ( name PRIMARY KEY,value);", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  if(!(rc == 0))
  {
    const char *return_value_sqlite3_errmsg_1;
    return_value_sqlite3_errmsg_1=sqlite3_errmsg(DBaseInstance);
    LogModule(0, DBASE, "Failed to create Metadata table: %s\n", return_value_sqlite3_errmsg_1);
    return rc;
  }

  rc=sqlite3_exec(DBaseInstance, "CREATE TABLE Services ( mplexuid,id,source,ca,type,name,pmtpid DEFAULT -1,provider,defauthority,PRIMARY KEY ( mplexuid,id));", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  if(!(rc == 0))
  {
    const char *return_value_sqlite3_errmsg_2;
    return_value_sqlite3_errmsg_2=sqlite3_errmsg(DBaseInstance);
    LogModule(0, DBASE, "Failed to create Services table: %s\n", return_value_sqlite3_errmsg_2);
    return rc;
  }

  rc=sqlite3_exec(DBaseInstance, "CREATE TABLE Multiplexes ( uid INTEGER PRIMARY KEY,type,tsid DEFAULT -1,netid DEFAULT -1,tuningparams);", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  if(!(rc == 0))
  {
    const char *return_value_sqlite3_errmsg_3;
    return_value_sqlite3_errmsg_3=sqlite3_errmsg(DBaseInstance);
    LogModule(0, DBASE, "Failed to create Multiplexes table: %s\n", return_value_sqlite3_errmsg_3);
    return rc;
  }

  rc=sqlite3_exec(DBaseInstance, "CREATE TABLE PIDs ( mplexuid,serviceid,pid,type,descriptors DEFAULT NULL,PRIMARY KEY(mplexuid,serviceid,pid));", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  if(!(rc == 0))
  {
    const char *return_value_sqlite3_errmsg_4;
    return_value_sqlite3_errmsg_4=sqlite3_errmsg(DBaseInstance);
    LogModule(0, DBASE, "Failed to create PIDs table: %s\n", return_value_sqlite3_errmsg_4);
    return rc;
  }

  DBaseMetadataSetDouble("dbase_version", 2.0);
  sqlite3_exec(DBaseInstance, "COMMIT TRANSACTION;", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  return rc;
}

// DBaseDeInit
// file ../include/dbase.h line 317
void DBaseDeInit()
{
  pthread_setspecific(dbaseKey, (void *)0);
  sqlite3_close(DBaseInstance);
}

// DBaseInit
// file ../include/dbase.h line 311
signed int DBaseInit(signed int adapter)
{
  signed int rc;
  pthread_key_create(&dbaseKey, (void (*)(void *))sqlite3_close);
  sprintf(dbaseFile, "%s/adapter%d.db", (const void *)DataDirectory, adapter);
  rc=sqlite3_open(dbaseFile, &DBaseInstance);
  if(!(rc == 0))
  {
    const char *return_value_sqlite3_errmsg_1;
    return_value_sqlite3_errmsg_1=sqlite3_errmsg(DBaseInstance);
    LogModule(0, DBASE, "Can't open database: %s\n", return_value_sqlite3_errmsg_1);
    sqlite3_close(DBaseInstance);
  }

  else
  {
    pthread_setspecific(dbaseKey, (void *)DBaseInstance);
    sqlite3_busy_timeout(DBaseInstance, 500);
    rc=DBaseCheckVersion();
  }
  return rc;
}

// DBaseMetadataDelete
// file ../include/dbase.h line 399
signed int DBaseMetadataDelete(char *name)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("DELETE FROM Metadata WHERE name='%q';", name);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataDelete", 370, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataDelete", 373, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// DBaseMetadataGet
// file ../include/dbase.h line 353
signed int DBaseMetadataGet(char *name, char **value)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  signed int result = 1;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT value FROM Metadata WHERE name='%q';", name);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataGet", 270, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataGet", 273, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  if(rc == 100)
  {
    const unsigned char *return_value_sqlite3_column_text_6;
    return_value_sqlite3_column_text_6=sqlite3_column_text(stmt, 0);
    *value=strdup((char *)return_value_sqlite3_column_text_6);
    result = 0;
  }

  rc=sqlite3_finalize(stmt);
  return result;
}

// DBaseMetadataGetDouble
// file dbase.c line 331
signed int DBaseMetadataGetDouble(char *name, double *value)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  signed int result = 1;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT value FROM Metadata WHERE name='%q';", name);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataGetDouble", 338, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataGetDouble", 341, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  if(rc == 100)
  {
    *value=sqlite3_column_double(stmt, 0);
    result = 0;
  }

  rc=sqlite3_finalize(stmt);
  return result;
}

// DBaseMetadataGetInt
// file ../include/dbase.h line 369
signed int DBaseMetadataGetInt(char *name, signed int *value)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  signed int result = 1;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT value FROM Metadata WHERE name='%q';", name);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataGetInt", 305, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataGetInt", 308, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  if(rc == 100)
  {
    *value=sqlite3_column_int(stmt, 0);
    result = 0;
  }

  rc=sqlite3_finalize(stmt);
  return result;
}

// DBaseMetadataSet
// file ../include/dbase.h line 361
signed int DBaseMetadataSet(char *name, char *value)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("INSERT OR REPLACE INTO Metadata (name,value) VALUES('%q','%q');", name, value);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataSet", 289, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataSet", 292, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// DBaseMetadataSetDouble
// file dbase.c line 351
signed int DBaseMetadataSetDouble(char *name, double value)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("INSERT OR REPLACE INTO Metadata (name,value) VALUES('%q',%e);", name, value);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataSetDouble", 357, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataSetDouble", 360, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// DBaseMetadataSetInt
// file ../include/dbase.h line 376
signed int DBaseMetadataSetInt(char *name, signed int value)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("INSERT OR REPLACE INTO Metadata (name,value) VALUES('%q',%d);", name, value);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataSetInt", 323, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"DBaseMetadataSetInt", 326, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// DBaseTransactionBegin
// file dbase.c line 112
signed int DBaseTransactionBegin(void)
{
  struct sqlite3 *connection;
  connection=DBaseConnectionGet();
  signed int return_value_sqlite3_exec_1;
  return_value_sqlite3_exec_1=sqlite3_exec(connection, "BEGIN TRANSACTION;", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  return return_value_sqlite3_exec_1;
}

// DBaseTransactionCommit
// file dbase.c line 118
signed int DBaseTransactionCommit(void)
{
  struct sqlite3 *connection;
  connection=DBaseConnectionGet();
  signed int return_value_sqlite3_exec_1;
  return_value_sqlite3_exec_1=sqlite3_exec(connection, "COMMIT TRANSACTION;", (signed int (*)(void *, signed int, char **, char **))(void *)0, (void *)0, (char **)(void *)0);
  return return_value_sqlite3_exec_1;
}

// DVBCommandCallback
// file dvbadapter.c line 1269
static void DVBCommandCallback(struct ev_loop *loop, struct ev_io *w, signed int revents)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)w->data;
  char cmd;
  _Bool retune = (_Bool)0;
  ev_io_start(loop, w);
  signed long int return_value_read_13;
  return_value_read_13=read(adapter->cmdRecvFd, (void *)&cmd, (unsigned long int)1);
  _Bool tmp_if_expr_9;
  if(return_value_read_13 == 1l)
  {
    switch((signed int)cmd)
    {
      case 0:
      {
        DVBDemuxStopAllFilters(adapter);
        retune = (_Bool)1;
        break;
      }
      case 1:
      {
        if(adapter->frontEndFd == -1)
        {
          retune = (_Bool)1;
          adapter->frontEndFd=open(adapter->frontEndPath, 02);
          if(adapter->frontEndFd == -1)
          {
            signed int *return_value___errno_location_1;
            return_value___errno_location_1=__errno_location();
            char *return_value_strerror_2;
            return_value_strerror_2=strerror(*return_value___errno_location_1);
            LogModule(0, DVBADAPTER, "Failed to open %s : %s\n", (const void *)adapter->frontEndPath, return_value_strerror_2);
            goto __CPROVER_DUMP_L16;
          }

          EventsFireEventListeners(feActiveEvent, (void *)adapter);
          do
          {
            (&adapter->frontendWatcher)->fd = adapter->frontEndFd;
            (&adapter->frontendWatcher)->events = 1 | 128;
          }
          while((_Bool)0);
          ev_io_start(loop, &adapter->frontendWatcher);
        }

        break;
      }
      case 2:
        if(!(adapter->frontEndFd == -1))
        {
          ev_io_stop(loop, &adapter->frontendWatcher);
          DVBDemuxStopAllFilters(adapter);
          close(adapter->frontEndFd);
          adapter->frontEndFd = -1;
          EventsFireEventListeners(feIdleEvent, (void *)adapter);
        }

    }
    if(!(retune == (_Bool)0))
    {
      if(!(adapter->frontEndFd == -1))
      {
        adapter->tuning = (_Bool)1;
        if(!(adapter->forcedISDB == (_Bool)0))
        {
          adapter->isdbFEParams.frequency = adapter->frontEndRequestedFreq;
          LogModule(3, DVBADAPTER, "ISDB Tuning to %d", adapter->frontEndRequestedFreq);
          signed int return_value_ioctl_5;
          return_value_ioctl_5=ioctl(adapter->frontEndFd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(76 << 0)) | sizeof(struct dvb_frontend_parameters) /*36ul*/  << 0 + 8 + 8, &adapter->isdbFEParams);
          if(!(return_value_ioctl_5 >= 0))
          {
            signed int *return_value___errno_location_3;
            return_value___errno_location_3=__errno_location();
            char *return_value_strerror_4;
            return_value_strerror_4=strerror(*return_value___errno_location_3);
            LogModule(0, DVBADAPTER, "FE_SET_FRONTEND: %s\n", return_value_strerror_4);
          }

        }

        else
        {
          adapter->frontEndPropertyArray[(signed long int)1].u.data = adapter->frontEndRequestedFreq;
          signed int return_value_ioctl_8;
          return_value_ioctl_8=ioctl(adapter->frontEndFd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(82 << 0)) | sizeof(struct dtv_properties) /*16ul*/  << 0 + 8 + 8, &ClearFrontEndProperties);
          if(!(return_value_ioctl_8 >= 0))
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            char *return_value_strerror_7;
            return_value_strerror_7=strerror(*return_value___errno_location_6);
            LogModule(0, DVBADAPTER, "Clear FE_SET_PROPERTY: %s\n", return_value_strerror_7);
          }

          LogModule(3, DVBADAPTER, "Tuning to %d", adapter->frontEndRequestedFreq);
          if((signed int)adapter->currentDeliverySystem == DELSYS_DVBS)
            tmp_if_expr_9 = (_Bool)1;

          else
            tmp_if_expr_9 = (signed int)adapter->currentDeliverySystem == DELSYS_DVBS2 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_9)
            DVBFrontEndSatelliteSetup(adapter);

          signed int return_value_ioctl_12;
          return_value_ioctl_12=ioctl(adapter->frontEndFd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(82 << 0)) | sizeof(struct dtv_properties) /*16ul*/  << 0 + 8 + 8, &adapter->frontEndProperties);
          if(!(return_value_ioctl_12 >= 0))
          {
            signed int *return_value___errno_location_10;
            return_value___errno_location_10=__errno_location();
            char *return_value_strerror_11;
            return_value_strerror_11=strerror(*return_value___errno_location_10);
            LogModule(0, DVBADAPTER, "Tune FE_SET_PROPERTY: %s\n", return_value_strerror_11);
          }

        }
      }

    }

  }


__CPROVER_DUMP_L16:
  ;
}

// DVBCommandSend
// file dvbadapter.c line 1261
static void DVBCommandSend(struct DVBAdapter_s *adapter, char cmd)
{
  signed long int return_value_write_1;
  return_value_write_1=write(adapter->cmdSendFd, (const void *)&cmd, (unsigned long int)1);
  if(!(return_value_write_1 == 1l))
    LogModule(0, DVBADAPTER, "Failed to write to monitor pipe!");

}

// DVBDVRGetFD
// file dvbadapter.c line 1256
signed int DVBDVRGetFD(struct DVBAdapter_s *adapter)
{
  return adapter->dvrFd;
}

// DVBDemuxAllocateFilter
// file dvbadapter.c line 1094
signed int DVBDemuxAllocateFilter(struct DVBAdapter_s *adapter, unsigned short int pid)
{
  signed int result = -1;
  signed int i;
  signed int idxToUse = -1;
  i = 0;
  for( ; !(i >= adapter->maxFilters); i = i + 1)
    if(adapter->filters[(signed long int)i].demuxFd == -1)
      idxToUse = i;

    else
      if(adapter->filters[(signed long int)i].pid == pid)
      {
        idxToUse = -1;
        result = 0;
        break;
      }

  _Bool tmp_if_expr_3;
  if(!(idxToUse == -1))
  {
    LogModule(3, DVBADAPTER, "Allocation filter for pid 0x%x\n", pid);
    adapter->filters[(signed long int)idxToUse].demuxFd=open(adapter->demuxPath, 02);
    if(adapter->filters[(signed long int)idxToUse].demuxFd == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      LogModule(0, DVBADAPTER, "Failed to open %s : %s when attempting to allocate filter for PID 0x%x\n", (const void *)adapter->demuxPath, return_value_strerror_2, pid);
    }

    else
    {
      struct dmx_pes_filter_params pesFilterParam;
      memset((void *)&pesFilterParam, 0, sizeof(struct dmx_pes_filter_params) /*20ul*/ );
      LogModule(3, DVBADAPTER, "Filter fd %d\n", adapter->filters[(signed long int)idxToUse].demuxFd);
      adapter->filters[(signed long int)idxToUse].pid = pid;
      pesFilterParam.pid = pid;
      pesFilterParam.input = (enum dmx_input)DMX_IN_FRONTEND;
      pesFilterParam.output = (enum dmx_output)DMX_OUT_TS_TAP;
      pesFilterParam.pes_type = (enum dmx_ts_pes)DMX_PES_OTHER;
      if(!(adapter->frontEndLocked == (_Bool)0))
        tmp_if_expr_3 = !(adapter->tuning != (_Bool)0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        LogModule(3, DVBADAPTER, "Starting pid filter immediately!\n");
        pesFilterParam.flags = (unsigned int)4;
      }

      else
        pesFilterParam.flags = (unsigned int)0;
      signed int return_value_ioctl_6;
      return_value_ioctl_6=ioctl(adapter->filters[(signed long int)idxToUse].demuxFd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(44 << 0)) | sizeof(struct dmx_pes_filter_params) /*20ul*/  << 0 + 8 + 8, &pesFilterParam);
      if(!(return_value_ioctl_6 >= 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        LogModule(0, DVBADAPTER, "set_pid: %s\n", return_value_strerror_5);
      }

      else
        result = 0;
    }
  }

  return result;
}

// DVBDemuxGetAvailableFilters
// file dvbadapter.c line 1075
signed int DVBDemuxGetAvailableFilters(struct DVBAdapter_s *adapter)
{
  signed int count = 0;
  signed int i = 0;
  for( ; !(i >= adapter->maxFilters); i = i + 1)
    if(adapter->filters[(signed long int)i].demuxFd == -1)
      count = count + 1;

  return count;
}

// DVBDemuxGetMaxFilters
// file dvbadapter.c line 1070
signed int DVBDemuxGetMaxFilters(struct DVBAdapter_s *adapter)
{
  return adapter->maxFilters;
}

// DVBDemuxIsHardwareRestricted
// file dvbadapter.c line 1089
_Bool DVBDemuxIsHardwareRestricted(struct DVBAdapter_s *adapter)
{
  return adapter->hardwareRestricted;
}

// DVBDemuxReleaseAllFilters
// file dvbadapter.c line 1182
signed int DVBDemuxReleaseAllFilters(struct DVBAdapter_s *adapter)
{
  signed int result = -1;
  signed int i;
  LogModule(3, DVBADAPTER, "Releasing all filters");
  i = 0;
  for( ; !(i >= adapter->maxFilters); i = i + 1)
    if(!(adapter->filters[(signed long int)i].demuxFd == -1))
    {
      close(adapter->filters[(signed long int)i].demuxFd);
      adapter->filters[(signed long int)i].demuxFd = -1;
      result = 0;
    }

  return result;
}

// DVBDemuxReleaseFilter
// file dvbadapter.c line 1161
signed int DVBDemuxReleaseFilter(struct DVBAdapter_s *adapter, unsigned short int pid)
{
  signed int result = -1;
  if((signed int)pid == 8192 || !(adapter->hardwareRestricted == (_Bool)0))
  {
    signed int i = 0;
    for( ; !(i >= adapter->maxFilters); i = i + 1)
      if(!(adapter->filters[(signed long int)i].demuxFd == -1))
      {
        if(adapter->filters[(signed long int)i].pid == pid)
        {
          LogModule(3, DVBADAPTER, "Releasing filter for pid 0x%x fd %d\n", pid, adapter->filters[(signed long int)i].demuxFd);
          close(adapter->filters[(signed long int)i].demuxFd);
          adapter->filters[(signed long int)i].demuxFd = -1;
          result = 0;
          break;
        }

      }

  }

  return result;
}

// DVBDemuxSetBufferSize
// file dvbadapter.c line 1039
signed int DVBDemuxSetBufferSize(struct DVBAdapter_s *adapter, unsigned long int size)
{
  signed int i = 0;
  for( ; !(i >= adapter->maxFilters); i = i + 1)
  {
    signed int demuxFd = adapter->filters[(signed long int)0].demuxFd;
    if(!(demuxFd == -1))
    {
      signed int return_value_ioctl_3;
      return_value_ioctl_3=ioctl(demuxFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(42 << 0) | (unsigned int)(0 << 0 + 8 + 8)), 0);
      if(!(return_value_ioctl_3 >= 0))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        LogModule(0, DVBADAPTER, "DMX_STOP: %s\n", return_value_strerror_2);
        return -1;
      }

      signed int return_value_ioctl_6;
      return_value_ioctl_6=ioctl(demuxFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(45 << 0) | (unsigned int)(0 << 0 + 8 + 8)), size);
      if(!(return_value_ioctl_6 >= 0))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        LogModule(0, DVBADAPTER, "DMX_SET_BUFFER_SIZE: %s\n", return_value_strerror_5);
        return -1;
      }

      signed int return_value_ioctl_9;
      return_value_ioctl_9=ioctl(demuxFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(41 << 0) | (unsigned int)(0 << 0 + 8 + 8)), 0);
      if(!(return_value_ioctl_9 >= 0))
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        char *return_value_strerror_8;
        return_value_strerror_8=strerror(*return_value___errno_location_7);
        LogModule(0, DVBADAPTER, "DMX_STOP: %s\n", return_value_strerror_8);
        return -1;
      }

    }

  }
  return 0;
}

// DVBDemuxStartAllFilters
// file dvbadapter.c line 1232
static void DVBDemuxStartAllFilters(struct DVBAdapter_s *adapter)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= adapter->maxFilters); i = i + 1)
    if(!(adapter->filters[(signed long int)i].demuxFd == -1))
      DVBDemuxStartFilter(adapter, &adapter->filters[(signed long int)i]);

}

// DVBDemuxStartFilter
// file dvbadapter.c line 1200
static signed int DVBDemuxStartFilter(struct DVBAdapter_s *adapter, struct DVBAdapterPIDFilter_s *filter)
{
  signed int result = 0;
  (void)adapter;
  LogModule(3, DVBADAPTER, "Starting filter %d\n", filter->pid);
  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(filter->demuxFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(41 << 0) | (unsigned int)(0 << 0 + 8 + 8)), (void *)0);
  if(!(return_value_ioctl_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    LogModule(0, DVBADAPTER, "filter(fd %d) start: %s\n", filter->demuxFd, return_value_strerror_2);
    result = -1;
  }

  return result;
}

// DVBDemuxStopAllFilters
// file dvbadapter.c line 1244
static void DVBDemuxStopAllFilters(struct DVBAdapter_s *adapter)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= adapter->maxFilters); i = i + 1)
    if(!(adapter->filters[(signed long int)i].demuxFd == -1))
      DVBDemuxStopFilter(adapter, &adapter->filters[(signed long int)i]);

}

// DVBDemuxStopFilter
// file dvbadapter.c line 1216
static signed int DVBDemuxStopFilter(struct DVBAdapter_s *adapter, struct DVBAdapterPIDFilter_s *filter)
{
  signed int result = 0;
  (void)adapter;
  LogModule(3, DVBADAPTER, "Stopping filter %d\n", filter->pid);
  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(filter->demuxFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(42 << 0) | (unsigned int)(0 << 0 + 8 + 8)), (void *)0);
  if(!(return_value_ioctl_3 >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    LogModule(0, DVBADAPTER, "filter(fd %d) stop: %s\n", filter->demuxFd, return_value_strerror_2);
    result = -1;
  }

  return result;
}

// DVBDispose
// file dvbadapter.c line 643
void DVBDispose(struct DVBAdapter_s *adapter)
{
  struct ev_loop *inputLoop;
  inputLoop=DispatchersGetInput();
  if(adapter->dvrFd >= 0)
  {
    LogModule(4, DVBADAPTER, "Closing DVR file descriptor\n");
    close(adapter->dvrFd);
  }

  LogModule(4, DVBADAPTER, "Closing Demux file descriptors\n");
  DVBDemuxReleaseAllFilters(adapter);
  ev_io_stop(inputLoop, &adapter->frontendWatcher);
  ev_io_stop(inputLoop, &adapter->commandWatcher);
  if(adapter->frontEndFd >= 0)
  {
    LogModule(4, DVBADAPTER, "Closing Frontend file descriptor\n");
    close(adapter->frontEndFd);
    LogModule(4, DVBADAPTER, "Closed Frontend file descriptor\n");
    adapter->frontEndFd = -1;
  }

  close(adapter->cmdRecvFd);
  close(adapter->cmdSendFd);
  PropertiesRemoveAllProperties(propertyParent);
  ObjectRefDecImpl((void *)adapter->supportedDelSystems, "dvbadapter.c", 669);
  ObjectRefDecImpl((void *)adapter, "dvbadapter.c", 670);
}

// DVBEventToString
// file dvbadapter.c line 1417
static signed int DVBEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)payload;
  char adapterStr[4l];
  signed int mappingId;
  mappingId=yaml_document_add_mapping(document, (unsigned char *)"tag:yaml.org,2002:map", (enum yaml_mapping_style_e)YAML_ANY_MAPPING_STYLE);
  sprintf(adapterStr, "%d", adapter->adapter);
  YamlUtils_MappingAdd(document, mappingId, "Adapter", adapterStr);
  return mappingId;
}

// DVBFrontEndDeliverySystemSupported
// file dvbadapter.c line 678
_Bool DVBFrontEndDeliverySystemSupported(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e system)
{
  signed int i = 0;
  for( ; !(i >= adapter->supportedDelSystems->nrofSystems); i = i + 1)
    if(adapter->supportedDelSystems->systems[(signed long int)i] == system)
      return (_Bool)1;

  return (_Bool)0;
}

// DVBFrontEndGetDeliverySystems
// file dvbadapter.c line 673
struct DVBSupportedDeliverySys_s * DVBFrontEndGetDeliverySystems(struct DVBAdapter_s *adapter)
{
  return adapter->supportedDelSystems;
}

// DVBFrontEndIsLocked
// file dvbadapter.c line 1028
_Bool DVBFrontEndIsLocked(struct DVBAdapter_s *adapter)
{
  return adapter->frontEndLocked;
}

// DVBFrontEndLNBInfoGet
// file dvbadapter.c line 893
void DVBFrontEndLNBInfoGet(struct DVBAdapter_s *adapter, struct LNBInfo_s *lnbInfo)
{
  *lnbInfo = adapter->lnbInfo;
}

// DVBFrontEndLNBInfoSet
// file dvbadapter.c line 888
void DVBFrontEndLNBInfoSet(struct DVBAdapter_s *adapter, struct LNBInfo_s *lnbInfo)
{
  adapter->lnbInfo = *lnbInfo;
}

// DVBFrontEndParameterSupported
// file dvbadapter.c line 741
_Bool DVBFrontEndParameterSupported(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e system, char *param, char *value)
{
  char *DVBFrontEndParameterSupported__1__AUTO = "AUTO";
  _Bool return_value_DVBFrontEndDeliverySystemSupported_67;
  return_value_DVBFrontEndDeliverySystemSupported_67=DVBFrontEndDeliverySystemSupported(adapter, system);
  _Bool tmp_if_expr_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcmp_61;
  _Bool tmp_if_expr_63;
  signed int return_value_strcmp_62;
  _Bool tmp_if_expr_65;
  signed int return_value_strcmp_64;
  signed int return_value_strcmp_60;
  _Bool tmp_if_expr_17;
  signed int return_value_strcmp_16;
  _Bool tmp_if_expr_19;
  signed int return_value_strcmp_18;
  _Bool tmp_if_expr_21;
  signed int return_value_strcmp_20;
  signed int return_value_strcmp_59;
  _Bool tmp_if_expr_25;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_58;
  signed int return_value_strcmp_57;
  _Bool tmp_if_expr_30;
  signed int return_value_strcmp_29;
  _Bool tmp_if_expr_32;
  signed int return_value_strcmp_31;
  _Bool tmp_if_expr_34;
  signed int return_value_strcmp_33;
  signed int return_value_strcmp_54;
  _Bool tmp_if_expr_56;
  signed int return_value_strcmp_55;
  _Bool tmp_if_expr_38;
  signed int return_value_strcasecmp_37;
  _Bool tmp_if_expr_41;
  signed int return_value_strcasecmp_40;
  _Bool tmp_if_expr_44;
  signed int return_value_strcasecmp_43;
  _Bool tmp_if_expr_47;
  signed int return_value_strcasecmp_46;
  _Bool tmp_if_expr_50;
  signed int return_value_strcasecmp_49;
  if(!(return_value_DVBFrontEndDeliverySystemSupported_67 == (_Bool)0))
  {
    signed int return_value_strcmp_66;
    return_value_strcmp_66=strcmp(param, "Inversion");
    if(return_value_strcmp_66 == 0)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(value, DVBFrontEndParameterSupported__1__AUTO);
      if(return_value_strcasecmp_1 == 0)
        return (_Bool)((signed int)adapter->info.caps & FE_CAN_INVERSION_AUTO);

      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(value, "ON");
      if(return_value_strcasecmp_2 == 0)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_strcasecmp_3=strcasecmp(value, "OFF");
        tmp_if_expr_4 = return_value_strcasecmp_3 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        return (_Bool)1;

    }

    else
    {
      return_value_strcmp_61=strcmp(param, "FEC");
      if(return_value_strcmp_61 == 0)
        tmp_if_expr_63 = (_Bool)1;

      else
      {
        return_value_strcmp_62=strcmp(param, "FEC HP");
        tmp_if_expr_63 = return_value_strcmp_62 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_63)
        tmp_if_expr_65 = (_Bool)1;

      else
      {
        return_value_strcmp_64=strcmp(param, "FEC LP");
        tmp_if_expr_65 = return_value_strcmp_64 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_65)
      {
        signed int return_value_strcasecmp_5;
        return_value_strcasecmp_5=strcasecmp(value, DVBFrontEndParameterSupported__1__AUTO);
        if(return_value_strcasecmp_5 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_AUTO);

        signed int return_value_strcmp_6;
        return_value_strcmp_6=strcmp(value, "1/2");
        if(return_value_strcmp_6 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_1_2);

        signed int return_value_strcmp_7;
        return_value_strcmp_7=strcmp(value, "2/3");
        if(return_value_strcmp_7 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_2_3);

        signed int return_value_strcmp_8;
        return_value_strcmp_8=strcmp(value, "3/4");
        if(return_value_strcmp_8 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_3_4);

        signed int return_value_strcmp_9;
        return_value_strcmp_9=strcmp(value, "4/5");
        if(return_value_strcmp_9 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_4_5);

        signed int return_value_strcmp_10;
        return_value_strcmp_10=strcmp(value, "5/6");
        if(return_value_strcmp_10 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_5_6);

        signed int return_value_strcmp_11;
        return_value_strcmp_11=strcmp(value, "6/7");
        if(return_value_strcmp_11 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_6_7);

        signed int return_value_strcmp_12;
        return_value_strcmp_12=strcmp(value, "7/8");
        if(return_value_strcmp_12 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_7_8);

        signed int return_value_strcmp_13;
        return_value_strcmp_13=strcmp(value, "8/9");
        if(return_value_strcmp_13 == 0)
          return (_Bool)((signed int)adapter->info.caps & FE_CAN_FEC_8_9);

      }

      else
      {
        return_value_strcmp_60=strcmp(param, "Guard Interval");
        if(return_value_strcmp_60 == 0)
        {
          signed int return_value_strcmp_14;
          return_value_strcmp_14=strcmp(value, DVBFrontEndParameterSupported__1__AUTO);
          if(return_value_strcmp_14 == 0)
            return (_Bool)((signed int)adapter->info.caps & FE_CAN_GUARD_INTERVAL_AUTO);

          signed int return_value_strcmp_15;
          return_value_strcmp_15=strcmp(value, "1/32");
          if(return_value_strcmp_15 == 0)
            tmp_if_expr_17 = (_Bool)1;

          else
          {
            return_value_strcmp_16=strcmp(value, "1/16");
            tmp_if_expr_17 = return_value_strcmp_16 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_17)
            tmp_if_expr_19 = (_Bool)1;

          else
          {
            return_value_strcmp_18=strcmp(value, "1/8");
            tmp_if_expr_19 = return_value_strcmp_18 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_19)
            tmp_if_expr_21 = (_Bool)1;

          else
          {
            return_value_strcmp_20=strcmp(value, "1/4");
            tmp_if_expr_21 = return_value_strcmp_20 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_21)
            return (_Bool)1;

        }

        else
        {
          return_value_strcmp_59=strcmp(param, "Transmission Mode");
          if(return_value_strcmp_59 == 0)
          {
            signed int return_value_strcmp_22;
            return_value_strcmp_22=strcmp(value, DVBFrontEndParameterSupported__1__AUTO);
            if(return_value_strcmp_22 == 0)
              return (_Bool)((signed int)adapter->info.caps & FE_CAN_TRANSMISSION_MODE_AUTO);

            signed int return_value_strcmp_23;
            return_value_strcmp_23=strcmp(value, "4000");
            if(return_value_strcmp_23 == 0)
              tmp_if_expr_25 = (_Bool)1;

            else
            {
              return_value_strcmp_24=strcmp(value, "2000");
              tmp_if_expr_25 = return_value_strcmp_24 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_25)
              return (_Bool)1;

          }

          else
          {
            return_value_strcmp_58=strcmp(param, "Bandwidth");
            if(return_value_strcmp_58 == 0)
            {
              signed int return_value_strcasecmp_26;
              return_value_strcasecmp_26=strcasecmp(value, DVBFrontEndParameterSupported__1__AUTO);
              if(return_value_strcasecmp_26 == 0)
                return (_Bool)((signed int)adapter->info.caps & FE_CAN_BANDWIDTH_AUTO);

              return (_Bool)1;
            }

            else
            {
              return_value_strcmp_57=strcmp(param, "Hierarchy");
              if(return_value_strcmp_57 == 0)
              {
                signed int return_value_strcasecmp_27;
                return_value_strcasecmp_27=strcasecmp(value, DVBFrontEndParameterSupported__1__AUTO);
                if(return_value_strcasecmp_27 == 0)
                  return (_Bool)((signed int)adapter->info.caps & FE_CAN_HIERARCHY_AUTO);

                signed int return_value_strcasecmp_28;
                return_value_strcasecmp_28=strcasecmp(value, "NONE");
                if(return_value_strcasecmp_28 == 0)
                  tmp_if_expr_30 = (_Bool)1;

                else
                {
                  return_value_strcmp_29=strcmp(value, "1");
                  tmp_if_expr_30 = return_value_strcmp_29 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_30)
                  tmp_if_expr_32 = (_Bool)1;

                else
                {
                  return_value_strcmp_31=strcmp(value, "2");
                  tmp_if_expr_32 = return_value_strcmp_31 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_32)
                  tmp_if_expr_34 = (_Bool)1;

                else
                {
                  return_value_strcmp_33=strcmp(value, "4");
                  tmp_if_expr_34 = return_value_strcmp_33 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_34)
                  return (_Bool)1;

                return (_Bool)1;
              }

              else
              {
                return_value_strcmp_54=strcmp(param, "Modulation");
                if(return_value_strcmp_54 == 0)
                  tmp_if_expr_56 = (_Bool)1;

                else
                {
                  return_value_strcmp_55=strcmp(param, "Constellation");
                  tmp_if_expr_56 = return_value_strcmp_55 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_56)
                {
                  signed int return_value_strcasecmp_35;
                  return_value_strcasecmp_35=strcasecmp(value, "QPSK");
                  if(return_value_strcasecmp_35 == 0)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_QPSK);

                  signed int return_value_strcasecmp_36;
                  return_value_strcasecmp_36=strcasecmp(value, "16QAM");
                  if(return_value_strcasecmp_36 == 0)
                    tmp_if_expr_38 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_37=strcasecmp(value, "QAM16");
                    tmp_if_expr_38 = return_value_strcasecmp_37 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_38)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_QAM_16);

                  signed int return_value_strcasecmp_39;
                  return_value_strcasecmp_39=strcasecmp(value, "32QAM");
                  if(return_value_strcasecmp_39 == 0)
                    tmp_if_expr_41 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_40=strcasecmp(value, "QAM32");
                    tmp_if_expr_41 = return_value_strcasecmp_40 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_41)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_QAM_32);

                  signed int return_value_strcasecmp_42;
                  return_value_strcasecmp_42=strcasecmp(value, "64QAM");
                  if(return_value_strcasecmp_42 == 0)
                    tmp_if_expr_44 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_43=strcasecmp(value, "QAM64");
                    tmp_if_expr_44 = return_value_strcasecmp_43 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_44)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_QAM_64);

                  signed int return_value_strcasecmp_45;
                  return_value_strcasecmp_45=strcasecmp(value, "128QAM");
                  if(return_value_strcasecmp_45 == 0)
                    tmp_if_expr_47 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_46=strcasecmp(value, "QAM128");
                    tmp_if_expr_47 = return_value_strcasecmp_46 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_47)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_QAM_128);

                  signed int return_value_strcasecmp_48;
                  return_value_strcasecmp_48=strcasecmp(value, "256QAM");
                  if(return_value_strcasecmp_48 == 0)
                    tmp_if_expr_50 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_49=strcasecmp(value, "QAM256");
                    tmp_if_expr_50 = return_value_strcasecmp_49 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_50)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_QAM_256);

                  signed int return_value_strcasecmp_51;
                  return_value_strcasecmp_51=strcasecmp(value, "AUTO");
                  if(return_value_strcasecmp_51 == 0)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_QAM_AUTO);

                  signed int return_value_strcasecmp_52;
                  return_value_strcasecmp_52=strcasecmp(value, "8VSB");
                  if(return_value_strcasecmp_52 == 0)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_8VSB);

                  signed int return_value_strcasecmp_53;
                  return_value_strcasecmp_53=strcasecmp(value, "16VSB");
                  if(return_value_strcasecmp_53 == 0)
                    return (_Bool)((signed int)adapter->info.caps & FE_CAN_16VSB);

                }

              }
            }
          }
        }
      }
    }
  }

  return (_Bool)0;
}

// DVBFrontEndParametersGet
// file dvbadapter.c line 712
char * DVBFrontEndParametersGet(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e *system)
{
  char *output;
  struct yaml_document_s document;
  yaml_document_initialize(&document, (struct yaml_version_directive_s *)(void *)0, (struct yaml_tag_directive_s *)(void *)0, (struct yaml_tag_directive_s *)(void *)0, 0, 0);
  yaml_document_add_mapping(&document, (unsigned char *)"tag:yaml.org,2002:map", (enum yaml_mapping_style_e)YAML_ANY_MAPPING_STYLE);
  struct dtv_property props[64l];
  struct dtv_properties properties;
  properties.props = props;
  properties.num = adapter->frontEndProperties.num;
  memcpy((void *)props, (const void *)&adapter->frontEndPropertyArray, sizeof(struct dtv_property) /*76ul*/  * (unsigned long int)properties.num);
  props[(signed long int)1].u.data = adapter->frontEndRequestedFreq;
  ConvertDTVPropertiesToYaml(adapter->currentDeliverySystem, &properties, &adapter->satelliteSettings, &document);
  *system = adapter->currentDeliverySystem;
  YamlUtils_DocumentToString(&document, (_Bool)1, &output);
  return output;
}

// DVBFrontEndSatelliteSetup
// file dvbadapter.c line 898
static signed int DVBFrontEndSatelliteSetup(struct DVBAdapter_s *adapter)
{
  _Bool tone = (_Bool)0;
  struct dvb_diseqc_master_cmd cmd = { .msg={ (unsigned char)0xe0, (unsigned char)0x10, (unsigned char)0x38, (unsigned char)0xf0, (unsigned char)0x00, (unsigned char)0x00 }, .msg_len=(unsigned char)4 };
  unsigned long int return_value_LNBTransponderToIntermediateFreq_1;
  return_value_LNBTransponderToIntermediateFreq_1=LNBTransponderToIntermediateFreq(&adapter->lnbInfo, (unsigned long int)adapter->frontEndPropertyArray[(signed long int)1].u.data, &tone);
  adapter->frontEndPropertyArray[(signed long int)1].u.data = (unsigned int)return_value_LNBTransponderToIntermediateFreq_1;
  _Bool tmp_if_expr_2;
  do
  {
    if(!(adapter->frontEndPropertyArray[1l].u.data >= adapter->info.frequency_min))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = adapter->frontEndPropertyArray[(signed long int)1].u.data > adapter->info.frequency_max ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      LogModule(0, DVBADAPTER, "IFreq (%lu) outside of adapters range (%lu ... %lu), wrong LNB settings?", adapter->frontEndPropertyArray[(signed long int)1].u.data, adapter->info.frequency_min, adapter->info.frequency_max);

  }
  while((_Bool)0);
  if(adapter->lnbSharing == (_Bool)0)
  {
    cmd.msg[(signed long int)3] = (unsigned char)((unsigned int)0xf0 | adapter->satelliteSettings.satellite_number * (unsigned int)4 & (unsigned int)0x0f | (unsigned int)(tone != (_Bool)0 ? 1 : 0) | (unsigned int)(adapter->satelliteSettings.polarisation != (enum Polarisation_e)0 ? 0 : 2));
    signed int return_value_ioctl_3;
    return_value_ioctl_3=ioctl(adapter->frontEndFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(66 << 0) | (unsigned int)(0 << 0 + 8 + 8)), 1);
    if(!(return_value_ioctl_3 >= 0))
      return -1;

    usleep((unsigned int)15000);
    signed int return_value_ioctl_4;
    return_value_ioctl_4=ioctl(adapter->frontEndFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(67 << 0) | (unsigned int)(0 << 0 + 8 + 8)), adapter->satelliteSettings.polarisation != (enum Polarisation_e)0 ? 0 : 1);
    if(!(return_value_ioctl_4 >= 0))
      return -1;

    usleep((unsigned int)15000);
    signed int return_value_ioctl_5;
    return_value_ioctl_5=ioctl(adapter->frontEndFd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(63 << 0)) | sizeof(struct dvb_diseqc_master_cmd) /*7ul*/  << 0 + 8 + 8, &cmd);
    if(!(return_value_ioctl_5 >= 0))
      return -1;

    usleep((unsigned int)15000);
    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(adapter->frontEndFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(65 << 0) | (unsigned int)(0 << 0 + 8 + 8)), adapter->satelliteSettings.satellite_number % (unsigned int)2 != 0u ? 1 : 0);
    if(!(return_value_ioctl_6 >= 0))
      return -1;

    usleep((unsigned int)15000);
    signed int return_value_ioctl_7;
    return_value_ioctl_7=ioctl(adapter->frontEndFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(66 << 0) | (unsigned int)(0 << 0 + 8 + 8)), tone != (_Bool)0 ? 0 : 1);
    if(!(return_value_ioctl_7 >= 0))
      return -1;

    usleep((unsigned int)15000);
  }

  return 0;
}

// DVBFrontEndSetActive
// file dvbadapter.c line 1033
signed int DVBFrontEndSetActive(struct DVBAdapter_s *adapter, _Bool active)
{
  DVBCommandSend(adapter, (char)(active != (_Bool)0 ? 1 : 2));
  return 0;
}

// DVBFrontEndStatus
// file dvbadapter.c line 960
signed int DVBFrontEndStatus(struct DVBAdapter_s *adapter, enum DVBFrontEndStatus_e *status, unsigned int *ber, unsigned int *strength, unsigned int *snr, unsigned int *ucblock)
{
  unsigned int tempU32;
  unsigned short int tempU16;
  if(!(status == ((enum DVBFrontEndStatus_e *)NULL)))
  {
    signed int return_value_ioctl_3;
    return_value_ioctl_3=ioctl(adapter->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(69 << 0)) | sizeof(enum fe_status) /*4ul*/  << 0 + 8 + 8, (enum fe_status *)status);
    if(!(return_value_ioctl_3 >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      LogModule(0, DVBADAPTER, "FE_READ_STATUS: %s\n", return_value_strerror_2);
      return -1;
    }

  }

  if(!(ber == ((unsigned int *)NULL)))
  {
    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(adapter->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(70 << 0)) | sizeof(unsigned int) /*4ul*/  << 0 + 8 + 8, &tempU32);
    if(!(return_value_ioctl_6 >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      LogModule(1, DVBADAPTER, "FE_READ_BER: %s\n", return_value_strerror_5);
      *ber = 0xffffffff;
    }

    else
      *ber = tempU32;
  }

  if(!(strength == ((unsigned int *)NULL)))
  {
    signed int return_value_ioctl_9;
    return_value_ioctl_9=ioctl(adapter->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(71 << 0)) | sizeof(unsigned short int) /*2ul*/  << 0 + 8 + 8, &tempU16);
    if(!(return_value_ioctl_9 >= 0))
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      LogModule(1, DVBADAPTER, "FE_READ_SIGNAL_STRENGTH: %s\n", return_value_strerror_8);
      *strength = (unsigned int)0xffff;
    }

    else
      *strength = (unsigned int)tempU16;
  }

  if(!(snr == ((unsigned int *)NULL)))
  {
    signed int return_value_ioctl_12;
    return_value_ioctl_12=ioctl(adapter->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(72 << 0)) | sizeof(unsigned short int) /*2ul*/  << 0 + 8 + 8, &tempU16);
    if(!(return_value_ioctl_12 >= 0))
    {
      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      char *return_value_strerror_11;
      return_value_strerror_11=strerror(*return_value___errno_location_10);
      LogModule(1, DVBADAPTER, "FE_READ_SNR: %s\n", return_value_strerror_11);
      *snr = (unsigned int)0xffff;
    }

    else
      *snr = (unsigned int)tempU16;
  }

  if(!(ucblock == ((unsigned int *)NULL)))
  {
    signed int return_value_ioctl_15;
    return_value_ioctl_15=ioctl(adapter->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(73 << 0)) | sizeof(unsigned int) /*4ul*/  << 0 + 8 + 8, &tempU32);
    if(!(return_value_ioctl_15 >= 0))
    {
      signed int *return_value___errno_location_13;
      return_value___errno_location_13=__errno_location();
      char *return_value_strerror_14;
      return_value_strerror_14=strerror(*return_value___errno_location_13);
      LogModule(1, DVBADAPTER, "FE_READ_UNCORRECTED_BLOCKS: %s\n", return_value_strerror_14);
      *ucblock = 0xffffffff;
    }

    else
      *ucblock = tempU32;
  }

  return 0;
}

// DVBFrontEndTune
// file dvbadapter.c line 691
signed int DVBFrontEndTune(struct DVBAdapter_s *adapter, enum DVBDeliverySystem_e system, char *params)
{
  struct yaml_document_s document;
  memset((void *)&document, 0, sizeof(struct yaml_document_s) /*104ul*/ );
  signed int return_value_YamlUtils_Parse_1;
  return_value_YamlUtils_Parse_1=YamlUtils_Parse(params, &document);
  if(!(return_value_YamlUtils_Parse_1 == 0))
  {
    adapter->currentDeliverySystem = system;
    ConvertYamlToDTVProperties(system, &document, adapter);
    yaml_document_delete(&document);
    adapter->tuning = (_Bool)1;
    DVBCommandSend(adapter, (char)0);
  }

  return 0;
}

// DVBFrontendCallback
// file dvbadapter.c line 1363
static void DVBFrontendCallback(struct ev_loop *loop, struct ev_io *w, signed int revents)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)w->data;
  struct dvb_frontend_event event;
  _Bool feLocked = adapter->frontEndLocked;
  ev_io_start(loop, w);
  signed int return_value_ioctl_5;
  return_value_ioctl_5=ioctl(adapter->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(78 << 0)) | sizeof(struct dvb_frontend_event) /*40ul*/  << 0 + 8 + 8, &event);
  if(return_value_ioctl_5 == 0)
  {
    if(!((FE_HAS_LOCK & (signed int)event.status) == 0))
      feLocked = (_Bool)1;

    else
      feLocked = (_Bool)0;
    if(!(feLocked == adapter->frontEndLocked))
    {
      adapter->frontEndLocked = feLocked;
      if(!(adapter->frontEndLocked == (_Bool)0))
      {
        adapter->tuning = (_Bool)0;
        DVBDemuxStartAllFilters(adapter);
        adapter->frontEndProperties.num = adapter->frontEndProperties.num - 1u;
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        signed int return_value_ioctl_4;
        return_value_ioctl_4=ioctl(adapter->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(83 << 0)) | sizeof(struct dtv_properties) /*16ul*/  << 0 + 8 + 8, &adapter->frontEndProperties);
        if(!(return_value_ioctl_4 == 0))
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          char *return_value_strerror_3;
          return_value_strerror_3=strerror(*return_value___errno_location_2);
          LogModule(0, DVBADAPTER, "FE_GET_PROPERTY: %s\n", return_value_strerror_3);
        }

        adapter->frontEndProperties.num = adapter->frontEndProperties.num + 1u;
        EventsFireEventListeners(lockedEvent, (void *)adapter);
      }

      else
      {
        DVBDemuxStopAllFilters(adapter);
        EventsFireEventListeners(unlockedEvent, (void *)adapter);
      }
    }

    if(!(event.parameters.frequency >= 1u))
      EventsFireEventListeners(tuningFailedEvent, (void *)adapter);

  }

}

// DVBInit
// file dvbadapter.c line 400
struct DVBAdapter_s * DVBInit(signed int adapter, _Bool hwRestricted, _Bool forceISDB)
{
  struct DVBAdapter_s *result = (struct DVBAdapter_s *)(void *)0;
  signed int monitorFds[2l];
  struct ev_loop *inputLoop;
  _Bool lnbInput = (_Bool)0;
  if(dvbSource == ((struct EventSource_s *)NULL))
  {
    dvbSource=EventsRegisterSource("DVBAdapter");
    lockedEvent=EventsRegisterEvent(dvbSource, "Locked", DVBEventToString);
    unlockedEvent=EventsRegisterEvent(dvbSource, "Unlocked", DVBEventToString);
    tuningFailedEvent=EventsRegisterEvent(dvbSource, "TuneFailed", DVBEventToString);
    feActiveEvent=EventsRegisterEvent(dvbSource, "FrontEndActive", DVBEventToString);
    feIdleEvent=EventsRegisterEvent(dvbSource, "FrontEndIdle", DVBEventToString);
  }

  ObjectRegisterClass("DVBAdapter_t", (unsigned int)sizeof(struct DVBAdapter_s) /*7424ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterCollection("DVBSupportedDeliverySys_t", (unsigned int)sizeof(enum DVBDeliverySystem_e) /*4ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("DVBAdapter_t", "dvbadapter.c", 418);
  result = (struct DVBAdapter_s *)return_value_ObjectCreateImpl_1;
  struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_10;
  struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_13;
  if(!(result == ((struct DVBAdapter_s *)NULL)))
  {
    signed int i;
    result->frontEndFd = -1;
    result->dvrFd = -1;
    result->adapter = adapter;
    sprintf(result->frontEndPath, "/dev/dvb/adapter%d/frontend0", adapter);
    sprintf(result->demuxPath, "/dev/dvb/adapter%d/demux0", adapter);
    sprintf(result->dvrPath, "/dev/dvb/adapter%d/dvr0", adapter);
    result->maxFilters = 256;
    i = 0;
    for( ; !(i >= 256); i = i + 1)
      if(!(i >= result->maxFilters))
      {
        result->filters[(signed long int)i].demuxFd=open(result->demuxPath, 02);
        if(result->filters[(signed long int)i].demuxFd == -1)
          result->maxFilters = i;

      }

      else
        result->filters[(signed long int)i].demuxFd = -1;
    LogModule(1, DVBADAPTER, "Maximum filters = %d", result->maxFilters);
    i = 0;
    for( ; !(i >= result->maxFilters); i = i + 1)
    {
      close(result->filters[(signed long int)i].demuxFd);
      result->filters[(signed long int)i].demuxFd = -1;
    }
    result->frontEndFd=open(result->frontEndPath, 02);
    if(result->frontEndFd == -1)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      LogModule(0, DVBADAPTER, "Failed to open %s : %s\n", (const void *)result->frontEndPath, return_value_strerror_3);
      ObjectRefDecImpl((void *)result, "dvbadapter.c", 459);
      return (struct DVBAdapter_s *)(void *)0;
    }

    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(result->frontEndFd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(61 << 0)) | sizeof(struct dvb_frontend_info) /*168ul*/  << 0 + 8 + 8, &result->info);
    if(!(return_value_ioctl_6 >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      LogModule(0, DVBADAPTER, "Failed to get front end info: %s\n", return_value_strerror_5);
      ObjectRefDecImpl((void *)result, "dvbadapter.c", 467);
      return (struct DVBAdapter_s *)(void *)0;
    }

    result->currentDeliverySystem = (enum DVBDeliverySystem_e)DELSYS_MAX_SUPPORTED;
    LogModule(1, DVBADAPTER, "Caps 0x%08x", result->info.caps);
    if(!(forceISDB == (_Bool)0))
    {
      struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_7;
      return_value_ObjectCollectionCreateImpl_7=ObjectCollectionCreateImpl("DVBSupportedDeliverySys_t", (unsigned int)1, "dvbadapter.c", 474);
      result->supportedDelSystems = (struct DVBSupportedDeliverySys_s *)return_value_ObjectCollectionCreateImpl_7;
      result->supportedDelSystems->systems[(signed long int)0] = (enum DVBDeliverySystem_e)DELSYS_ISDBT;
      result->forcedISDB = forceISDB;
    }

    else
      switch((signed int)result->info.type)
      {
        case FE_QPSK:
        {
          if(!((FE_CAN_2G_MODULATION & (signed int)result->info.caps) == 0))
          {
            struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_8;
            return_value_ObjectCollectionCreateImpl_8=ObjectCollectionCreateImpl("DVBSupportedDeliverySys_t", (unsigned int)2, "dvbadapter.c", 486);
            result->supportedDelSystems = (struct DVBSupportedDeliverySys_s *)return_value_ObjectCollectionCreateImpl_8;
            result->supportedDelSystems->systems[(signed long int)0] = (enum DVBDeliverySystem_e)DELSYS_DVBS;
            result->supportedDelSystems->systems[(signed long int)1] = (enum DVBDeliverySystem_e)DELSYS_DVBS2;
          }

          else
          {
            struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_9;
            return_value_ObjectCollectionCreateImpl_9=ObjectCollectionCreateImpl("DVBSupportedDeliverySys_t", (unsigned int)1, "dvbadapter.c", 493);
            result->supportedDelSystems = (struct DVBSupportedDeliverySys_s *)return_value_ObjectCollectionCreateImpl_9;
            result->supportedDelSystems->systems[(signed long int)0] = (enum DVBDeliverySystem_e)DELSYS_DVBS;
          }
          lnbInput = (_Bool)1;
          break;
        }
        case FE_QAM:
        {
          return_value_ObjectCollectionCreateImpl_10=ObjectCollectionCreateImpl("DVBSupportedDeliverySys_t", (unsigned int)1, "dvbadapter.c", 499);
          result->supportedDelSystems = (struct DVBSupportedDeliverySys_s *)return_value_ObjectCollectionCreateImpl_10;
          result->supportedDelSystems->systems[(signed long int)0] = (enum DVBDeliverySystem_e)DELSYS_DVBC;
          break;
        }
        case FE_OFDM:
        {
          if(!((FE_CAN_2G_MODULATION & (signed int)result->info.caps) == 0))
          {
            struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_11;
            return_value_ObjectCollectionCreateImpl_11=ObjectCollectionCreateImpl("DVBSupportedDeliverySys_t", (unsigned int)2, "dvbadapter.c", 506);
            result->supportedDelSystems = (struct DVBSupportedDeliverySys_s *)return_value_ObjectCollectionCreateImpl_11;
            result->supportedDelSystems->systems[(signed long int)0] = (enum DVBDeliverySystem_e)DELSYS_DVBT;
            result->supportedDelSystems->systems[(signed long int)1] = (enum DVBDeliverySystem_e)DELSYS_DVBT2;
          }

          else
          {
            struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_12;
            return_value_ObjectCollectionCreateImpl_12=ObjectCollectionCreateImpl("DVBSupportedDeliverySys_t", (unsigned int)1, "dvbadapter.c", 513);
            result->supportedDelSystems = (struct DVBSupportedDeliverySys_s *)return_value_ObjectCollectionCreateImpl_12;
            result->supportedDelSystems->systems[(signed long int)0] = (enum DVBDeliverySystem_e)DELSYS_DVBT;
          }
          break;
        }
        case FE_ATSC:
        {
          return_value_ObjectCollectionCreateImpl_13=ObjectCollectionCreateImpl("DVBSupportedDeliverySys_t", (unsigned int)1, "dvbadapter.c", 518);
          result->supportedDelSystems = (struct DVBSupportedDeliverySys_s *)return_value_ObjectCollectionCreateImpl_13;
          result->supportedDelSystems->systems[(signed long int)0] = (enum DVBDeliverySystem_e)DELSYS_ATSC;
        }
      }
    result->dvrFd=open(result->dvrPath, 00 | 04000);
    if(result->dvrFd == -1)
    {
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      char *return_value_strerror_15;
      return_value_strerror_15=strerror(*return_value___errno_location_14);
      LogModule(0, DVBADAPTER, "Failed to open %s : %s\n", (const void *)result->dvrPath, return_value_strerror_15);
      ObjectRefDecImpl((void *)result->supportedDelSystems, "dvbadapter.c", 528);
      close(result->frontEndFd);
      ObjectRefDecImpl((void *)result, "dvbadapter.c", 530);
      return (struct DVBAdapter_s *)(void *)0;
    }

    signed int return_value_pipe_18;
    return_value_pipe_18=pipe(monitorFds);
    if(return_value_pipe_18 == -1)
    {
      signed int *return_value___errno_location_16;
      return_value___errno_location_16=__errno_location();
      char *return_value_strerror_17;
      return_value_strerror_17=strerror(*return_value___errno_location_16);
      LogModule(0, DVBADAPTER, "Failed to create pipe : %s\n", return_value_strerror_17);
      ObjectRefDecImpl((void *)result->supportedDelSystems, "dvbadapter.c", 537);
      close(result->dvrFd);
      close(result->frontEndFd);
      ObjectRefDecImpl((void *)result, "dvbadapter.c", 540);
      return (struct DVBAdapter_s *)(void *)0;
    }

    result->cmdRecvFd = monitorFds[(signed long int)0];
    result->cmdSendFd = monitorFds[(signed long int)1];
    if(hwRestricted == (_Bool)0)
    {
      struct _IO_FILE *fp;
      char sysPath[4096l];
      signed int speed;
      char text[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      sprintf(sysPath, "/sys/class/dvb/dvb%d.demux0/device/speed", adapter);
      fp=fopen(sysPath, "r");
      if(!(fp == ((struct _IO_FILE *)NULL)))
      {
        signed int return_value_fscanf_19;
        return_value_fscanf_19=fscanf(fp, "%d", &speed);
        if(!(return_value_fscanf_19 == 0))
        {
          LogModule(1, DVBADAPTER, "Bus speed = %d!\n", speed);
          if(!(speed >= 13))
            hwRestricted = (_Bool)1;

        }

        fclose(fp);
      }

      sprintf(sysPath, "/sys/class/dvb/dvb%d.demux0/device/manufacturer", adapter);
      fp=fopen(sysPath, "r");
      if(!(fp == ((struct _IO_FILE *)NULL)))
      {
        fread((void *)text, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, (unsigned long int)1, fp);
        fclose(fp);
        LogModule(1, DVBADAPTER, "Device Manufacturer: %s\n", (const void *)text);
      }

      sprintf(sysPath, "/sys/class/dvb/dvb%d.demux0/device/product", adapter);
      fp=fopen(sysPath, "r");
      if(!(fp == ((struct _IO_FILE *)NULL)))
      {
        fread((void *)text, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, (unsigned long int)1, fp);
        fclose(fp);
        LogModule(1, DVBADAPTER, "Device Product: %s\n", (const void *)text);
      }

    }

    result->hardwareRestricted = hwRestricted;
    result->frontEndProperties.props = result->frontEndPropertyArray;
    if(!(hwRestricted == (_Bool)0))
      LogModule(1, DVBADAPTER, "Running in hardware restricted mode!\n");

    inputLoop=DispatchersGetInput();
    do
    {

    __CPROVER_DUMP_L29:
      ;
      ((struct ev_watcher *)(void *)&result->frontendWatcher)->pending = 0;
      ((struct ev_watcher *)(void *)&result->frontendWatcher)->active = ((struct ev_watcher *)(void *)&result->frontendWatcher)->pending;
      ((struct ev_watcher *)(void *)&result->frontendWatcher)->priority = 0;
      (&result->frontendWatcher)->cb = DVBFrontendCallback;
      memmove((void *)&((struct ev_watcher *)&result->frontendWatcher)->cb, (const void *)&(&result->frontendWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_io *, signed int)) /*8ul*/ );
      do
      {
        (&result->frontendWatcher)->fd = result->frontEndFd;
        (&result->frontendWatcher)->events = 1 | 128;
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L31:
      ;
      ((struct ev_watcher *)(void *)&result->commandWatcher)->pending = 0;
      ((struct ev_watcher *)(void *)&result->commandWatcher)->active = ((struct ev_watcher *)(void *)&result->commandWatcher)->pending;
      ((struct ev_watcher *)(void *)&result->commandWatcher)->priority = 0;
      (&result->commandWatcher)->cb = DVBCommandCallback;
      memmove((void *)&((struct ev_watcher *)&result->commandWatcher)->cb, (const void *)&(&result->commandWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_io *, signed int)) /*8ul*/ );
      do
      {
        (&result->commandWatcher)->fd = result->cmdRecvFd;
        (&result->commandWatcher)->events = 1 | 128;
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    result->frontendWatcher.data = (void *)result;
    result->commandWatcher.data = (void *)result;
    ev_io_start(inputLoop, &result->frontendWatcher);
    ev_io_start(inputLoop, &result->commandWatcher);
    PropertiesAddProperty(propertyParent, "number", "The number of the adapter being used", (enum PropertyType_e)PropertyType_Int, (void *)&result->adapter, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
    PropertiesAddProperty(propertyParent, "name", "Hardware driver name", (enum PropertyType_e)PropertyType_String, (void *)result->info.name, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
    PropertiesAddProperty(propertyParent, "hwrestricted", "Whether the hardware is not capable of supplying the entire TS.", (enum PropertyType_e)PropertyType_Boolean, (void *)&result->hardwareRestricted, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
    PropertiesAddProperty(propertyParent, "maxfilters", "The maximum number of PID filters available.", (enum PropertyType_e)PropertyType_Boolean, (void *)&result->maxFilters, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
    PropertiesAddProperty(propertyParent, "systems", "The broadcast systems the frontend is capable of receiving", (enum PropertyType_e)PropertyType_String, (void *)result, DVBPropertyDeliverySystemsGet, (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
    PropertiesAddProperty(propertyParent, "active", "Whether the frontend is currently in use.", (enum PropertyType_e)PropertyType_Boolean, (void *)result, DVBPropertyActiveGet, DVBPropertyActiveSet);
    if(!(lnbInput == (_Bool)0))
    {
      PropertiesAddProperty(propertyParent, "lnb", "LNB Name", (enum PropertyType_e)PropertyType_String, (void *)result, DVBPropertyLNBNameGet, DVBPropertyLNBNameSet);
      PropertiesAddProperty(lnbPropertyParent, "sharing", "Whether this adapter is sharing an LNB so shouldn't use tone/voltage control.", (enum PropertyType_e)PropertyType_Boolean, (void *)result, DVBPropertyLNBSharingGet, DVBPropertyLNBSharingSet);
      PropertiesAddProperty(lnbPropertyParent, "high", "High frequency", (enum PropertyType_e)PropertyType_Int, (void *)result, DVBPropertyLNBHighFreqGet, DVBPropertyLNBHighFreqSet);
      PropertiesAddProperty(lnbPropertyParent, "low", "Low frequency", (enum PropertyType_e)PropertyType_Int, (void *)result, DVBPropertyLNBLowFreqGet, DVBPropertyLNBLowFreqSet);
      PropertiesAddProperty(lnbPropertyParent, "switch", "Switch frequency", (enum PropertyType_e)PropertyType_Int, (void *)result, DVBPropertyLNBSwitchFreqGet, DVBPropertyLNBSwitchFreqSet);
    }

  }

  return result;
}

// DVBPropertyActiveGet
// file dvbadapter.c line 1427
static signed int DVBPropertyActiveGet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  value->u.boolean = adapter->frontEndFd != -1;
  return 0;
}

// DVBPropertyActiveSet
// file dvbadapter.c line 1434
static signed int DVBPropertyActiveSet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  signed int return_value_DVBFrontEndSetActive_1;
  return_value_DVBFrontEndSetActive_1=DVBFrontEndSetActive(adapter, value->u.boolean);
  return return_value_DVBFrontEndSetActive_1;
}

// DVBPropertyDeliverySystemsGet
// file dvbadapter.c line 1440
static signed int DVBPropertyDeliverySystemsGet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  signed int i;
  signed int size = 0;
  i = 0;
  for( ; !(i >= adapter->supportedDelSystems->nrofSystems); i = i + 1)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(DVBDeliverySystemStr[(signed long int)adapter->supportedDelSystems->systems[(signed long int)i]]);
    size = size + (signed int)((unsigned long int)2 + return_value_strlen_1 + (unsigned long int)1);
  }
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(size + 1));
  value->u.string = (char *)return_value_malloc_2;
  value->u.string[(signed long int)0] = (char)0;
  i = 0;
  for( ; !(i >= adapter->supportedDelSystems->nrofSystems); i = i + 1)
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(value->u.string);
    sprintf(value->u.string + (signed long int)return_value_strlen_3, "- %s\n", DVBDeliverySystemStr[(signed long int)adapter->supportedDelSystems->systems[(signed long int)i]]);
  }
  return 0;
}

// DVBPropertyLNBHighFreqGet
// file dvbadapter.c line 1483
static signed int DVBPropertyLNBHighFreqGet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  value->u.integer = (signed int)adapter->lnbInfo.highFrequency;
  return 0;
}

// DVBPropertyLNBHighFreqSet
// file dvbadapter.c line 1461
static signed int DVBPropertyLNBHighFreqSet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  adapter->lnbInfo.name = (char *)(void *)0;
  adapter->lnbInfo.highFrequency = (unsigned long int)value->u.integer;
  return 0;
}

// DVBPropertyLNBLowFreqGet
// file dvbadapter.c line 1489
static signed int DVBPropertyLNBLowFreqGet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  value->u.integer = (signed int)adapter->lnbInfo.lowFrequency;
  return 0;
}

// DVBPropertyLNBLowFreqSet
// file dvbadapter.c line 1468
static signed int DVBPropertyLNBLowFreqSet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  adapter->lnbInfo.name = (char *)(void *)0;
  adapter->lnbInfo.lowFrequency = (unsigned long int)value->u.integer;
  return 0;
}

// DVBPropertyLNBNameGet
// file dvbadapter.c line 1503
static signed int DVBPropertyLNBNameGet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  if(!(adapter->lnbInfo.name == ((char *)NULL)))
    value->u.string=strdup(adapter->lnbInfo.name);

  else
    value->u.string=strdup("User Defined");
  return 0;
}

// DVBPropertyLNBNameSet
// file dvbadapter.c line 1517
static signed int DVBPropertyLNBNameSet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  struct LNBInfo_s newInfo;
  signed int return_value_LNBDecode_1;
  return_value_LNBDecode_1=LNBDecode(value->u.string, &newInfo);
  if(!(return_value_LNBDecode_1 == 0))
    return -1;

  else
  {
    adapter->lnbInfo = newInfo;
    return 0;
  }
}

// DVBPropertyLNBSharingGet
// file dvbadapter.c line 1531
static signed int DVBPropertyLNBSharingGet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  value->u.boolean = adapter->lnbSharing;
  return 0;
}

// DVBPropertyLNBSharingSet
// file dvbadapter.c line 1538
static signed int DVBPropertyLNBSharingSet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  adapter->lnbSharing = value->u.boolean;
  if(!(adapter->lnbSharing == (_Bool)0))
  {
    signed int return_value_ioctl_1;
    return_value_ioctl_1=ioctl(adapter->frontEndFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(66 << 0) | (unsigned int)(0 << 0 + 8 + 8)), 1);
    if(!(return_value_ioctl_1 >= 0))
      LogModule(0, DVBADAPTER, "Failed to set tone off");

    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(adapter->frontEndFd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(111 << 0 + 8) | (unsigned int)(67 << 0) | (unsigned int)(0 << 0 + 8 + 8)), 2);
    if(!(return_value_ioctl_2 >= 0))
      LogModule(0, DVBADAPTER, "Failed to set voltage off");

  }

  return 0;
}

// DVBPropertyLNBSwitchFreqGet
// file dvbadapter.c line 1495
static signed int DVBPropertyLNBSwitchFreqGet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  value->u.integer = (signed int)adapter->lnbInfo.switchFrequency;
  return 0;
}

// DVBPropertyLNBSwitchFreqSet
// file dvbadapter.c line 1475
static signed int DVBPropertyLNBSwitchFreqSet(void *userArg, struct PropertyValue_s *value)
{
  struct DVBAdapter_s *adapter = (struct DVBAdapter_s *)userArg;
  adapter->lnbInfo.name = (char *)(void *)0;
  adapter->lnbInfo.switchFrequency = (unsigned long int)value->u.integer;
  return 0;
}

// DVBStandardDeinit
// file ../include/standard/dvb.h line 31
signed int DVBStandardDeinit(struct TSReader_t *reader)
{
  MPEG2StandardDeinit(reader);
  SDTProcessorDestroy(sdtProcessor);
  NITProcessorDestroy(nitProcessor);
  TDTProcessorDestroy(tdtProcessor);
  return 0;
}

// DVBStandardInit
// file ../include/standard/dvb.h line 30
signed int DVBStandardInit(struct TSReader_t *reader)
{
  if(DVBEventSource == ((struct EventSource_s *)NULL))
    DVBEventSource=EventsRegisterSource(DVBFilterType);

  signed int return_value_MPEG2StandardInit_1;
  return_value_MPEG2StandardInit_1=MPEG2StandardInit(reader);
  if(!(return_value_MPEG2StandardInit_1 == 0))
    return -1;

  else
  {
    sdtProcessor=SDTProcessorCreate(reader);
    if(!(sdtProcessor == ((struct SDTProcessor_s *)NULL)))
    {
      nitProcessor=NITProcessorCreate(reader);
      if(nitProcessor == ((struct NITProcessor_s *)NULL))
        goto failure;

      tdtProcessor=TDTProcessorCreate(reader);
      if(tdtProcessor == ((struct TDTProcessor_s *)NULL))
        goto failure;

      return 0;
    }

    else
    {

    failure:
      ;
      MPEG2StandardDeinit(reader);
      if(!(sdtProcessor == ((struct SDTProcessor_s *)NULL)))
        SDTProcessorDestroy(sdtProcessor);

      if(!(nitProcessor == ((struct NITProcessor_s *)NULL)))
        NITProcessorDestroy(nitProcessor);

      if(!(tdtProcessor == ((struct TDTProcessor_s *)NULL)))
        TDTProcessorDestroy(tdtProcessor);

      return -1;
    }
  }
}

// DVBTextToUTF8
// file ../include/dvbtext.h line 44
char * DVBTextToUTF8(char *toConvert, unsigned long int toConvertLen)
{
  enum CS cs_new = (enum CS)CS_UNKNOWN;
  char asciiBuffer[256l];
  unsigned long int inBytesLeft;
  unsigned long int outBytesLeft;
  char *outBytes;
  char *inBytes;
  unsigned long int ret;
  char *result;
  if(toConvertLen == 0ul)
    return (char *)(void *)0;

  else
    switch((signed int)(unsigned char)*toConvert)
    {      cs_new = (enum CS)ISO6937;
      case 0x01:
      {
        cs_new = (enum CS)ISO8859_5;
        toConvert = toConvert + (signed long int)1;
        toConvertLen = toConvertLen - (unsigned long int)1;
        goto __CPROVER_DUMP_L10;
      }
      case 0x02:
      {
        cs_new = (enum CS)ISO8859_6;
        toConvert = toConvert + (signed long int)1;
        toConvertLen = toConvertLen - (unsigned long int)1;
        goto __CPROVER_DUMP_L10;
      }
      case 0x03:
      {
        cs_new = (enum CS)ISO8859_7;
        toConvert = toConvert + (signed long int)1;
        toConvertLen = toConvertLen - (unsigned long int)1;
        goto __CPROVER_DUMP_L10;
      }
      case 0x04:
      {
        cs_new = (enum CS)ISO8859_8;
        toConvert = toConvert + (signed long int)1;
        toConvertLen = toConvertLen - (unsigned long int)1;
        goto __CPROVER_DUMP_L10;
      }
      case 0x05:
      {
        cs_new = (enum CS)ISO8859_9;
        toConvert = toConvert + (signed long int)1;
        toConvertLen = toConvertLen - (unsigned long int)1;
        goto __CPROVER_DUMP_L10;
      }
      case 0x10:
      {
        cs_new = (enum CS)(CS_OTHER + ((signed int)(unsigned char)toConvert[(signed long int)1] << 8) + (signed int)(unsigned char)toConvert[(signed long int)2]);
        toConvert = toConvert + (signed long int)3;
        toConvertLen = toConvertLen - (unsigned long int)3;
        goto __CPROVER_DUMP_L10;
      }
      case 0x11:
      {
        cs_new = (enum CS)ISO10646;
        toConvert = toConvert + (signed long int)1;
        toConvertLen = toConvertLen - (unsigned long int)1;
        goto __CPROVER_DUMP_L10;
      }
      case 0x00:
        return (char *)(void *)0;
      default:
      {

      __CPROVER_DUMP_L10:
        ;
        pthread_mutex_lock(&ResultBufferMutex);
        if((signed int)cs_old == CS_UNKNOWN || !(cs_old == cs_new))
        {
          if(!(cd == NULL))
          {
            LogModule(3, DVBTEXT, "Closing previous conversion descriptor.\n");
            iconv_close(cd);
            cd = (void *)0;
          }

          LogModule(3, DVBTEXT, "Opening new conversion descriptor.\n");
          switch((signed int)cs_new)
          {
            case ISO6937:
            {
              cd=iconv_open(UTF8, "ISO6937");
              if((signed long int)cd == -1l)
              {
                signed int toConvertIndex;
                signed int asciiIndex = 0;
                toConvertIndex = 0;
                for( ; !((unsigned long int)toConvertIndex >= toConvertLen); toConvertIndex = toConvertIndex + 1)
                {
                  unsigned char ch = (unsigned char)toConvert[(signed long int)toConvertIndex];
                  if(!((signed int)ch >= 128))
                  {
                    asciiBuffer[(signed long int)asciiIndex] = (char)ch;
                    asciiIndex = asciiIndex + 1;
                  }

                }
                toConvert = asciiBuffer;
                toConvertLen = (unsigned long int)asciiIndex;
                cd=iconv_open(UTF8, "ISO8859-1");
              }

              break;
            }
            case ISO8859_5:
            {
              cd=iconv_open(UTF8, "ISO8859-5");
              break;
            }
            case ISO8859_6:
            {
              cd=iconv_open(UTF8, "ISO8859-6");
              break;
            }
            case ISO8859_7:
            {
              cd=iconv_open(UTF8, "ISO8859-7");
              break;
            }
            case ISO8859_8:
            {
              cd=iconv_open(UTF8, "ISO8859-8");
              break;
            }
            case ISO8859_9:
            {
              cd=iconv_open(UTF8, "ISO8859-9");
              break;
            }
            case ISO10646:
            {
              cd=iconv_open(UTF8, "ISO-10646/UTF8");
              break;
            }
            default:
            {
              char from[14l];
              signed int i = (signed int)cs_new - CS_OTHER;
              snprintf(from, sizeof(char [14l]) /*14ul*/ , "ISO8859-%d", i);
              cd=iconv_open(UTF8, from);
            }
          }
          cs_old = cs_new;
        }

        if((signed long int)cd == -1l)
        {
          pthread_mutex_unlock(&ResultBufferMutex);
          LogModule(0, DVBTEXT, "Failed to open conversion descriptor!\n");
          return (char *)(void *)0;
        }

        inBytes = toConvert;
        inBytesLeft = toConvertLen;
        outBytesLeft = sizeof(char [1536l]) /*1536ul*/ ;
        outBytes = ResultBuffer;
        ret=iconv(cd, (char **)&inBytes, &inBytesLeft, &outBytes, &outBytesLeft);
        if(ret == 18446744073709551615ul)
        {
          pthread_mutex_unlock(&ResultBufferMutex);
          return (char *)(void *)0;
        }

        *outBytes = (char)0;
        result=strdup(ResultBuffer);
        pthread_mutex_unlock(&ResultBufferMutex);
        return result;
      }
    }
}

// DeInitDaemon
// file main.c line 853
static void DeInitDaemon(void)
{
  unlink(PidFile);
  exit(0);
}

// DeferredProcessingAddJob
// file ../include/deferredproc.h line 61
void DeferredProcessingAddJob(void (*processor)(void *), void *arg)
{
  if(!(jobQ == ((struct MessageQ_s *)NULL)))
  {
    struct DeferredJob_s *job;
    void *return_value_ObjectCreateImpl_1;
    return_value_ObjectCreateImpl_1=ObjectCreateImpl("DeferredJob_t", "threading/deferredproc.c", 85);
    job = (struct DeferredJob_s *)return_value_ObjectCreateImpl_1;
    LogModule(4, DEFERREDPROC, "Adding job %p (processor:%p, arg:%p)\n", job, processor, arg);
    job->processor = processor;
    job->arg = arg;
    ObjectRefIncImpl(arg, "threading/deferredproc.c", 89);
    MessageQSend(jobQ, (void *)job);
    ObjectRefDecImpl((void *)job, "threading/deferredproc.c", 91);
  }

}

// DeferredProcessingDeinit
// file ../include/deferredproc.h line 49
void DeferredProcessingDeinit(void)
{
  MessageQSetQuit(jobQ);
  pthread_join(processingThread, (void **)(void *)0);
  MessageQDestroy(jobQ);
  pthread_detach(processingThread);
  jobQ = (struct MessageQ_s *)(void *)0;
}

// DeferredProcessingInit
// file ../include/deferredproc.h line 43
signed int DeferredProcessingInit(void)
{
  ObjectRegisterClass("DeferredJob_t", (unsigned int)sizeof(struct DeferredJob_s) /*16ul*/ , (void (*)(void *))(void *)0);
  jobQ=MessageQCreate();
  pthread_create(&processingThread, (const union pthread_attr_t *)(void *)0, DeferredProcessingThread, (void *)0);
  return 0;
}

// DeferredProcessingThread
// file threading/deferredproc.c line 99
static void * DeferredProcessingThread(void *arg)
{
  struct DeferredJob_s *job;
  LogRegisterThread(processingThread, DEFERREDPROC);
  LogModule(3, DEFERREDPROC, "Deferred processing thread started\n");
  _Bool return_value_MessageQIsQuitSet_1;
  do
  {
    return_value_MessageQIsQuitSet_1=MessageQIsQuitSet(jobQ);
    if(return_value_MessageQIsQuitSet_1 != (_Bool)0)
      break;

    void *return_value_MessageQReceive_2;
    return_value_MessageQReceive_2=MessageQReceive(jobQ);
    job = (struct DeferredJob_s *)return_value_MessageQReceive_2;
    if(!(job == ((struct DeferredJob_s *)NULL)))
    {
      LogModule(4, DEFERREDPROC, "Running job %p (processor:%p, arg:%p)\n", job, job->processor, job->arg);
      job->processor(job->arg);
      LogModule(4, DEFERREDPROC, "Finished job %p (processor:%p, arg:%p)\n", job, job->processor, job->arg);
      ObjectRefDecImpl((void *)job, "threading/deferredproc.c", 112);
    }

  }
  while((_Bool)1);
  MessageQResetQuit(jobQ);
  signed int return_value_MessageQAvailable_3;
  return_value_MessageQAvailable_3=MessageQAvailable(jobQ);
  LogModule(3, DEFERREDPROC, "Discarding %d jobs\n", return_value_MessageQAvailable_3);
  signed int return_value_MessageQAvailable_4;
  do
  {
    return_value_MessageQAvailable_4=MessageQAvailable(jobQ);
    if(return_value_MessageQAvailable_4 == 0)
      break;

    void *return_value_MessageQReceive_5;
    return_value_MessageQReceive_5=MessageQReceive(jobQ);
    job = (struct DeferredJob_s *)return_value_MessageQReceive_5;
    if(!(job == ((struct DeferredJob_s *)NULL)))
    {
      ObjectRefDecImpl(job->arg, "threading/deferredproc.c", 122);
      ObjectRefDecImpl((void *)job, "threading/deferredproc.c", 123);
    }

  }
  while((_Bool)1);
  LogModule(3, DEFERREDPROC, "Deferred processing thread stopped\n");
  return (void *)0;
}

// DeliveryMethodCreate
// file ../include/deliverymethod.h line 164
struct DeliveryMethodInstance_t * DeliveryMethodCreate(char *mrl)
{
  struct ListIterator_s iterator;
  struct DeliveryMethodInstance_t *instance = (struct DeliveryMethodInstance_t *)(void *)0;
  LogModule(3, DELIVERYMETHOD, "Looking for handler for %s", mrl);
  iterator.current = DeliveryMethodsList->head;
  iterator.list = DeliveryMethodsList;
  struct ListEntry_s *tmp_if_expr_1;
  if(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct DeliveryMethodHandler_t *handler = (struct DeliveryMethodHandler_t *)iterator.current->data;
    LogModule(3, DELIVERYMETHOD, "Checking handler %p", handler);
    _Bool return_value;
    return_value=handler->CanHandle(mrl);
    if(!(return_value == (_Bool)0))
    {
      instance=handler->CreateInstance(mrl);
      if(instance->mrl == ((char *)NULL))
        LogModule(3, DELIVERYMETHOD, "MRL field not set when creating instance for %s", mrl);

      ListAdd(InstancesList, (void *)instance);
      LogModule(3, DELIVERYMETHOD, "Created DeliveryMethodInstance(%p) for %s\n", instance, instance->mrl);
    }

    else
    {
      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_1 = iterator.current->next;

      else
        tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
      iterator.current = tmp_if_expr_1;
    }
  }

  return instance;
}

// DeliveryMethodDestroy
// file ../include/deliverymethod.h line 178
void DeliveryMethodDestroy(struct DeliveryMethodInstance_t *instance)
{
  LogModule(3, DELIVERYMETHOD, "Released DeliveryMethodInstance(%p) for %s\n", instance, instance->mrl);
  instance->ops->DestroyInstance(instance);
  ListRemove(InstancesList, (void *)instance);
}

// DeliveryMethodDestroyAll
// file ../include/deliverymethod.h line 188
void DeliveryMethodDestroyAll()
{
  struct ListIterator_s iterator;
  iterator.current = InstancesList->head;
  iterator.list = InstancesList;
  struct ListEntry_s *tmp_if_expr_1;
  while(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct DeliveryMethodInstance_t *instance = (struct DeliveryMethodInstance_t *)iterator.current->data;
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
    iterator.current = tmp_if_expr_1;
    DeliveryMethodDestroy(instance);
  }
}

// DeliveryMethodGetMRL
// file ../include/deliverymethod.h line 171
char * DeliveryMethodGetMRL(struct DeliveryMethodInstance_t *instance)
{
  return instance->mrl;
}

// DeliveryMethodManagerDeInit
// file ../include/deliverymethod.h line 145
void DeliveryMethodManagerDeInit(void)
{
  ListFree(DeliveryMethodsList, (void (*)(void *))(void *)0);
  if(!(InstancesList->count == 0))
    LogModule(0, DELIVERYMETHOD, "Instances still exist when shutting down Delivery Method Manager!\n");

  ListFree(InstancesList, (void (*)(void *))(void *)0);
}

// DeliveryMethodManagerInit
// file ../include/deliverymethod.h line 139
signed int DeliveryMethodManagerInit(void)
{
  DeliveryMethodsList=ListCreate();
  if(DeliveryMethodsList == ((struct List_s *)NULL))
    return -1;

  else
  {
    InstancesList=ListCreate();
    if(InstancesList == ((struct List_s *)NULL))
    {
      ListFree(DeliveryMethodsList, (void (*)(void *))(void *)0);
      return -1;
    }

    else
    {
      DeliveryMethodManagerRegister(&NullOutputHandler);
      return 0;
    }
  }
}

// DeliveryMethodManagerRegister
// file deliverymethod.c line 97
void DeliveryMethodManagerRegister(struct DeliveryMethodHandler_t *handler)
{
  ListAdd(DeliveryMethodsList, (void *)handler);
}

// DeliveryMethodManagerUnRegister
// file deliverymethod.c line 102
void DeliveryMethodManagerUnRegister(struct DeliveryMethodHandler_t *handler)
{
  ListRemove(DeliveryMethodsList, (void *)handler);
}

// DeliveryMethodOutputBlock
// file deliverymethod.c line 182
void DeliveryMethodOutputBlock(struct DeliveryMethodInstance_t *instance, void *block, unsigned long int blockLen)
{
  if(!(instance->ops->OutputBlock == ((void (*)(struct DeliveryMethodInstance_t *, void *, unsigned long int))NULL)))
    instance->ops->OutputBlock(instance, block, blockLen);

}

// DeliveryMethodOutputPacket
// file ../include/deliverymethod.h line 210
void DeliveryMethodOutputPacket(struct DeliveryMethodInstance_t *instance, struct TSPacket_t *packet)
{
  if(!(instance->ops->OutputPacket == ((void (*)(struct DeliveryMethodInstance_t *, struct TSPacket_t *))NULL)))
    instance->ops->OutputPacket(instance, packet);

}

// DeliveryMethodReserveHeaderSpace
// file ../include/deliverymethod.h line 195
void DeliveryMethodReserveHeaderSpace(struct DeliveryMethodInstance_t *instance, signed int nrofPackets)
{
  if(!(instance->ops->ReserveHeaderSpace == ((void (*)(struct DeliveryMethodInstance_t *, signed int))NULL)))
    instance->ops->ReserveHeaderSpace(instance, nrofPackets);

}

// DeliveryMethodSetHeader
// file ../include/deliverymethod.h line 203
void DeliveryMethodSetHeader(struct DeliveryMethodInstance_t *instance, struct TSPacket_t *packets, signed int nrofPackets)
{
  if(!(instance->ops->SetHeader == ((void (*)(struct DeliveryMethodInstance_t *, struct TSPacket_t *, signed int))NULL)))
    instance->ops->SetHeader(instance, packets, nrofPackets);

}

// DispatchersDeInit
// file ../include/dispatchers.h line 28
signed int DispatchersDeInit(void)
{
  ev_io_stop(InputEventLoop, &InputExitWatcher);
  ev_io_stop(UserNetEventLoop, &NetUserExitWatcher);
  ev_loop_destroy(InputEventLoop);
  ev_loop_destroy(UserNetEventLoop);
  return 0;
}

// DispatchersExitLoop
// file ../include/dispatchers.h line 30
void DispatchersExitLoop(void)
{
  write(exitPipe[(signed long int)1], (const void *)"e", (unsigned long int)1);
}

// DispatchersGetInput
// file ../include/dispatchers.h line 32
struct ev_loop * DispatchersGetInput(void)
{
  return InputEventLoop;
}

// DispatchersGetNetwork
// file dispatchers.c line 115
struct ev_loop * DispatchersGetNetwork(void)
{
  return UserNetEventLoop;
}

// DispatchersGetUserInput
// file dispatchers.c line 120
struct ev_loop * DispatchersGetUserInput(void)
{
  return UserNetEventLoop;
}

// DispatchersInit
// file ../include/dispatchers.h line 27
signed int DispatchersInit(void)
{
  signed int return_value_pipe_1;
  return_value_pipe_1=pipe(exitPipe);
  if(!(return_value_pipe_1 == 0))
    return -1;

  else
  {
    UserNetEventLoop=ev_loop_new((unsigned int)0);
    InputEventLoop=ev_loop_new((unsigned int)0);
    do
    {

    __CPROVER_DUMP_L2:
      ;
      ((struct ev_watcher *)(void *)&InputExitWatcher)->pending = 0;
      ((struct ev_watcher *)(void *)&InputExitWatcher)->active = ((struct ev_watcher *)(void *)&InputExitWatcher)->pending;
      ((struct ev_watcher *)(void *)&InputExitWatcher)->priority = 0;
      (&InputExitWatcher)->cb = InputExit;
      memmove((void *)&((struct ev_watcher *)&InputExitWatcher)->cb, (const void *)&(&InputExitWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_io *, signed int)) /*8ul*/ );
      do
      {
        (&InputExitWatcher)->fd = exitPipe[(signed long int)0];
        (&InputExitWatcher)->events = 1 | 128;
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L4:
      ;
      ((struct ev_watcher *)(void *)&NetUserExitWatcher)->pending = 0;
      ((struct ev_watcher *)(void *)&NetUserExitWatcher)->active = ((struct ev_watcher *)(void *)&NetUserExitWatcher)->pending;
      ((struct ev_watcher *)(void *)&NetUserExitWatcher)->priority = 0;
      (&NetUserExitWatcher)->cb = NetUserExit;
      memmove((void *)&((struct ev_watcher *)&NetUserExitWatcher)->cb, (const void *)&(&NetUserExitWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_io *, signed int)) /*8ul*/ );
      do
      {
        (&NetUserExitWatcher)->fd = exitPipe[(signed long int)0];
        (&NetUserExitWatcher)->events = 1 | 128;
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    ev_io_start(InputEventLoop, &InputExitWatcher);
    ev_io_start(UserNetEventLoop, &NetUserExitWatcher);
    return 0;
  }
}

// DispatchersStart
// file ../include/dispatchers.h line 29
void DispatchersStart(_Bool sync)
{
  pthread_create(&InputDispatcherThread, (const union pthread_attr_t *)(void *)0, InputDispatcher, (void *)0);
  if(!(sync == (_Bool)0))
    ev_loop(UserNetEventLoop, 0);

  else
    pthread_create(&UserNetDispatcherThread, (const union pthread_attr_t *)(void *)0, UserNetDispatcher, (void *)0);
  UserNetSync = sync;
}

// DispatchersStop
// file ../include/dispatchers.h line 31
void DispatchersStop(void)
{
  DispatchersExitLoop();
  pthread_join(InputDispatcherThread, (void **)(void *)0);
  if(UserNetSync == (_Bool)0)
    pthread_join(UserNetDispatcherThread, (void **)(void *)0);

}

// DumpDescriptor
// file standard/atsc/psipprocessor.c line 355
static void DumpDescriptor(char *prefix, struct dvbpsi_descriptor_s *descriptor)
{
  signed int i;
  char line[49l];
  line[(signed long int)0] = (char)0;
  LogModule(3, PSIPPROCESSOR, "%sTag : 0x%02x (Length %d)\n", prefix, descriptor->i_tag, descriptor->i_length);
  i = 0;
  for( ; !(i >= (signed int)descriptor->i_length); i = i + 1)
  {
    if(i % 16 == 0 && !(i == 0))
    {
      LogModule(3, PSIPPROCESSOR, "%s%s\n", prefix, (const void *)line);
      line[(signed long int)0] = (char)0;
    }

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(line);
    sprintf(line + (signed long int)return_value_strlen_1, "%02x ", descriptor->p_data[(signed long int)i]);
  }
  if(!(line[0l] == 0))
    LogModule(3, PSIPPROCESSOR, "%s%s\n", prefix, (const void *)line);

}

// EPGChannelDeInit
// file ../include/epgchannel.h line 60
signed int EPGChannelDeInit(void)
{
  ListFree(EPGChannelListeners, (void (*)(void *))MessageQDestroy);
  return 0;
}

// EPGChannelInit
// file ../include/epgchannel.h line 54
signed int EPGChannelInit(void)
{
  ObjectRegisterClass("EPGChannelMessage_t", (unsigned int)sizeof(struct EPGChannelMessage_s) /*144ul*/ , EPGChannelMessageDestructor);
  EPGChannelListeners=ListCreate();
  return 0;
}

// EPGChannelMessageDestructor
// file epgchannel.c line 169
static void EPGChannelMessageDestructor(void *ptr)
{
  struct EPGChannelMessage_s *msg = (struct EPGChannelMessage_s *)ptr;
  switch((signed int)msg->type)
  {
    case EPGChannelMessageType_Event:
      break;
    case EPGChannelMessageType_Detail:
    {
      free((void *)msg->data.detail.name);
      free((void *)msg->data.detail.value);
      break;
    }
    case EPGChannelMessageType_Rating:
    {
      free((void *)msg->data.rating.system);
      free((void *)msg->data.rating.rating);
    }
  }
}

// EPGChannelNewDetail
// file epgchannel.c line 136
signed int EPGChannelNewDetail(struct EPGEventRef_s *eventRef, char *lang, char *name, char *value)
{
  struct EPGChannelMessage_s *msg;
  struct EPGEventDetail_s *eventDetail;
  do
  {
    signed int count;
    pthread_mutex_lock(&EPGChannelMutex);
    count = EPGChannelListeners->count;
    pthread_mutex_unlock(&EPGChannelMutex);
    if(count == 0)
    {
      LogModule(10, EPGCHANNEL, "Not creating message, no listeners!");
      return 0;
    }

  }
  while((_Bool)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("EPGChannelMessage_t", "epgchannel.c", 142);
  msg = (struct EPGChannelMessage_s *)return_value_ObjectCreateImpl_1;
  msg->type = (enum anonymous_19)EPGChannelMessageType_Detail;
  msg->eventRef = *eventRef;
  memcpy((void *)msg->data.detail.lang, (const void *)lang, sizeof(char [4l]) /*4ul*/ );
  msg->data.detail.name=strdup(name);
  msg->data.detail.value=strdup(value);
  EPGChannelSendMessage(msg);
  return 0;
}

// EPGChannelNewEvent
// file epgchannel.c line 103
signed int EPGChannelNewEvent(struct EPGEventRef_s *eventRef, struct tm *startTime, struct tm *endTime, _Bool ca)
{
  struct EPGChannelMessage_s *msg;
  do
  {
    signed int count;
    pthread_mutex_lock(&EPGChannelMutex);
    count = EPGChannelListeners->count;
    pthread_mutex_unlock(&EPGChannelMutex);
    if(count == 0)
    {
      LogModule(10, EPGCHANNEL, "Not creating message, no listeners!");
      return 0;
    }

  }
  while((_Bool)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("EPGChannelMessage_t", "epgchannel.c", 109);
  msg = (struct EPGChannelMessage_s *)return_value_ObjectCreateImpl_1;
  msg->type = (enum anonymous_19)EPGChannelMessageType_Event;
  msg->eventRef = *eventRef;
  msg->data.event.startTime = *startTime;
  msg->data.event.endTime = *endTime;
  msg->data.event.ca = ca;
  EPGChannelSendMessage(msg);
  return 0;
}

// EPGChannelNewRating
// file epgchannel.c line 120
signed int EPGChannelNewRating(struct EPGEventRef_s *eventRef, char *system, char *rating)
{
  struct EPGChannelMessage_s *msg;
  do
  {
    signed int count;
    pthread_mutex_lock(&EPGChannelMutex);
    count = EPGChannelListeners->count;
    pthread_mutex_unlock(&EPGChannelMutex);
    if(count == 0)
    {
      LogModule(10, EPGCHANNEL, "Not creating message, no listeners!");
      return 0;
    }

  }
  while((_Bool)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("EPGChannelMessage_t", "epgchannel.c", 126);
  msg = (struct EPGChannelMessage_s *)return_value_ObjectCreateImpl_1;
  msg->type = (enum anonymous_19)EPGChannelMessageType_Rating;
  msg->eventRef = *eventRef;
  msg->data.rating.system=strdup(system);
  msg->data.rating.rating=strdup(rating);
  EPGChannelSendMessage(msg);
  return 0;
}

// EPGChannelRegisterListener
// file ../include/epgchannel.h line 62
signed int EPGChannelRegisterListener(struct MessageQ_s *msgQ)
{
  pthread_mutex_lock(&EPGChannelMutex);
  ListAdd(EPGChannelListeners, (void *)msgQ);
  pthread_mutex_unlock(&EPGChannelMutex);
  return 0;
}

// EPGChannelSendMessage
// file epgchannel.c line 156
static void EPGChannelSendMessage(struct EPGChannelMessage_s *msg)
{
  struct ListIterator_s iterator;
  pthread_mutex_lock(&EPGChannelMutex);
  iterator.current = EPGChannelListeners->head;
  iterator.list = EPGChannelListeners;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct MessageQ_s *msgQ = (struct MessageQ_s *)iterator.current->data;
    MessageQSend(msgQ, (void *)msg);
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  pthread_mutex_unlock(&EPGChannelMutex);
  ObjectRefDecImpl((void *)msg, "epgchannel.c", 166);
}

// EPGChannelUnregisterListener
// file ../include/epgchannel.h line 63
signed int EPGChannelUnregisterListener(struct MessageQ_s *msgQ)
{
  pthread_mutex_lock(&EPGChannelMutex);
  ListRemove(EPGChannelListeners, (void *)msgQ);
  pthread_mutex_unlock(&EPGChannelMutex);
  return 0;
}

// EPGEventDetailDestructor
// file epgtypes.c line 72
static void EPGEventDetailDestructor(void *arg)
{
  struct EPGEventDetail_s *detail = (struct EPGEventDetail_s *)arg;
  free((void *)detail->name);
  free((void *)detail->value);
}

// EPGEventRatingDestructor
// file epgtypes.c line 65
static void EPGEventRatingDestructor(void *arg)
{
  struct EPGEventRating_s *rating = (struct EPGEventRating_s *)arg;
  free((void *)rating->rating);
  free((void *)rating->system);
}

// EPGTypesDeInit
// file ../include/epgtypes.h line 103
signed int EPGTypesDeInit(void)
{
  return 0;
}

// EPGTypesInit
// file ../include/epgtypes.h line 97
signed int EPGTypesInit(void)
{
  ObjectRegisterClass("EPGEvent_t", (unsigned int)sizeof(struct EPGEvent_s) /*120ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("EPGEventRating_t", (unsigned int)sizeof(struct EPGEventRating_s) /*16ul*/ , EPGEventRatingDestructor);
  ObjectRegisterClass("EPGEventDetail_t", (unsigned int)sizeof(struct EPGEventDetail_s) /*24ul*/ , EPGEventDetailDestructor);
  return 0;
}

// EventFree
// file events.c line 405
static void EventFree(struct Event_s *event)
{
  if(!(event == eventUnregistered) && !(eventUnregistered == ((struct Event_s *)NULL)))
    EventsFireEventListeners(eventUnregistered, (void *)event);

  free((void *)event->name);
  ListFree(event->listeners, (void (*)(void *))EventListenerDetailsFree);
  ObjectRefDecImpl((void *)event, "events.c", 413);
}

// EventListenerDetailsFree
// file events.c line 416
static void EventListenerDetailsFree(struct EventListenerDetails_s *details)
{
  ObjectRefDecImpl((void *)details, "events.c", 418);
}

// EventSourceFree
// file events.c line 397
static void EventSourceFree(struct EventSource_s *source)
{
  free((void *)source->name);
  ListFree(source->listeners, (void (*)(void *))EventListenerDetailsFree);
  ListFree(source->events, (void (*)(void *))EventFree);
  ObjectRefDecImpl((void *)source, "events.c", 402);
}

// EventUnregisteredToString
// file events.c line 459
static signed int EventUnregisteredToString(struct yaml_document_s *document, struct Event_s *event, void *payload)
{
  struct Event_s *unregEvent = (struct Event_s *)payload;
  signed int node;
  char *eventName;
  asprintf(&eventName, "%s.%s", unregEvent->source->name, unregEvent->name);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(eventName);
  node=yaml_document_add_scalar(document, (unsigned char *)"tag:yaml.org,2002:str", (unsigned char *)eventName, (signed int)return_value_strlen_1, (enum yaml_scalar_style_e)YAML_ANY_SCALAR_STYLE);
  free((void *)eventName);
  return node;
}

// EventsDeInit
// file ../include/events.h line 97
signed int EventsDeInit(void)
{
  eventsSource = (struct EventSource_s *)(void *)0;
  eventUnregistered = (struct Event_s *)(void *)0;
  ListFree(sourcesList, (void (*)(void *))EventSourceFree);
  ListFree(globalListenersList, (void (*)(void *))EventListenerDetailsFree);
  return 0;
}

// EventsEventName
// file events.c line 355
char * EventsEventName(struct Event_s *event)
{
  char *result = (char *)(void *)0;
  asprintf(&result, "%s.%s", event->source->name, event->name);
  return result;
}

// EventsEventToString
// file events.c line 362
char * EventsEventToString(struct Event_s *event, void *payload)
{
  char *result = (char *)(void *)0;
  signed int ret;
  struct yaml_document_s document;
  ret=asprintf(&result, "%s.%s", event->source->name, event->name);
  if(ret == -1)
  {
    LogModule(1, EVENTS, "Failed to allocate memory for event description string.");
    return (char *)(void *)0;
  }

  else
  {
    yaml_document_initialize(&document, (struct yaml_version_directive_s *)(void *)0, (struct yaml_tag_directive_s *)(void *)0, (struct yaml_tag_directive_s *)(void *)0, 0, 0);
    yaml_document_add_mapping(&document, (unsigned char *)"tag:yaml.org,2002:map", (enum yaml_mapping_style_e)YAML_ANY_MAPPING_STYLE);
    YamlUtils_MappingAdd(&document, 1, "Name", result);
    free((void *)result);
    if(!(event->toString == ((signed int (*)(struct yaml_document_s *, struct Event_s *, void *))NULL)))
    {
      signed int valueId;
      valueId=event->toString(&document, event, payload);
      if(!(valueId == 0))
      {
        char *key = "Details";
        signed int keyId;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(key);
        keyId=yaml_document_add_scalar(&document, (unsigned char *)"tag:yaml.org,2002:str", (unsigned char *)key, (signed int)return_value_strlen_1, (enum yaml_scalar_style_e)YAML_ANY_SCALAR_STYLE);
        yaml_document_append_mapping_pair(&document, 1, keyId, valueId);
      }

    }

    YamlUtils_DocumentToString(&document, (_Bool)1, &result);
    return result;
  }
}

// EventsFindEvent
// file ../include/events.h line 191
struct Event_s * EventsFindEvent(const char *name)
{
  char *sourceName;
  signed int sourceNameLen;
  struct EventSource_s *source = (struct EventSource_s *)(void *)0;
  struct Event_s *result = (struct Event_s *)(void *)0;
  pthread_mutex_lock(&eventsMutex);
  sourceNameLen = 0;
  for( ; !(name[(signed long int)sourceNameLen] == 0); sourceNameLen = sourceNameLen + 1)
    if((signed int)name[(signed long int)sourceNameLen] == 46)
      break;

  void *return_value_ObjectAllocImpl_1;
  return_value_ObjectAllocImpl_1=ObjectAllocImpl(sourceNameLen + 1, "events.c", 297);
  sourceName = (char *)return_value_ObjectAllocImpl_1;
  struct ListEntry_s *tmp_if_expr_2;
  if(!(sourceName == ((char *)NULL)))
  {
    memcpy((void *)sourceName, (const void *)name, (unsigned long int)sourceNameLen);
    sourceName[(signed long int)sourceNameLen] = (char)0;
    source=EventsFindSource(sourceName);
    if(!(source == ((struct EventSource_s *)NULL)))
    {
      struct ListIterator_s iterator;
      iterator.current = source->events->head;
      iterator.list = source->events;
      for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_2)
      {
        struct Event_s *event = (struct Event_s *)iterator.current->data;
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(event->name, &name[(signed long int)(sourceNameLen + 1)]);
        if(return_value_strcmp_3 == 0)
        {
          result = event;
          break;
        }

        if(!(iterator.current == ((struct ListEntry_s *)NULL)))
          tmp_if_expr_2 = iterator.current->next;

        else
          tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
      }
    }

    ObjectFreeImpl((void *)sourceName, "events.c", 318);
  }

  pthread_mutex_unlock(&eventsMutex);
  return result;
}

// EventsFindSource
// file events.c line 217
struct EventSource_s * EventsFindSource(const char *name)
{
  struct ListIterator_s iterator;
  struct EventSource_s *result = (struct EventSource_s *)(void *)0;
  pthread_mutex_lock(&eventsMutex);
  iterator.current = sourcesList->head;
  iterator.list = sourcesList;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct EventSource_s *source = (struct EventSource_s *)iterator.current->data;
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(source->name, name);
    if(return_value_strcmp_2 == 0)
    {
      result = source;
      break;
    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  pthread_mutex_unlock(&eventsMutex);
  return result;
}

// EventsFireEventListeners
// file ../include/events.h line 204
void EventsFireEventListeners(struct Event_s *event, void *payload)
{
  pthread_mutex_lock(&eventsMutex);
  LogModule(4, EVENTS, "Firing event %s.%s\n", event->source->name, event->name);
  FireEventListeners(globalListenersList, event, payload);
  FireEventListeners(event->source->listeners, event, payload);
  FireEventListeners(event->listeners, event, payload);
  pthread_mutex_unlock(&eventsMutex);
}

// EventsInit
// file ../include/events.h line 90
signed int EventsInit(void)
{
  ObjectRegisterClass("EventListenerDetails_t", (unsigned int)sizeof(struct EventListenerDetails_s) /*16ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("Event_t", (unsigned int)sizeof(struct Event_s) /*32ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("EventSource_t", (unsigned int)sizeof(struct EventSource_s) /*24ul*/ , (void (*)(void *))(void *)0);
  sourcesList=ListCreate();
  globalListenersList=ListCreate();
  eventsSource=EventsRegisterSource(EVENTS);
  eventUnregistered=EventsRegisterEvent(eventsSource, "Unregistered", EventUnregisteredToString);
  return 0;
}

// EventsRegisterEvent
// file ../include/events.h line 178
struct Event_s * EventsRegisterEvent(struct EventSource_s *source, char *name, signed int (*toString)(struct yaml_document_s *, struct Event_s *, void *))
{
  struct Event_s *result = (struct Event_s *)(void *)0;
  pthread_mutex_lock(&eventsMutex);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("Event_t", "events.c", 260);
  result = (struct Event_s *)return_value_ObjectCreateImpl_1;
  if(!(result == ((struct Event_s *)NULL)))
  {
    result->name=strdup(name);
    result->source = source;
    result->toString = toString;
    result->listeners=ListCreate();
    ListAdd(source->events, (void *)result);
    LogModule(3, EVENTS, "New event registered (%s.%s)\n", source->name, name);
  }

  pthread_mutex_unlock(&eventsMutex);
  return result;
}

// EventsRegisterEventListener
// file ../include/events.h line 212
void EventsRegisterEventListener(struct Event_s *event, void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  if(!(event == ((struct Event_s *)NULL)))
  {
    pthread_mutex_lock(&eventsMutex);
    RegisterEventListener(event->listeners, listener, arg);
    pthread_mutex_unlock(&eventsMutex);
  }

}

// EventsRegisterListener
// file events.c line 177
void EventsRegisterListener(void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  pthread_mutex_lock(&eventsMutex);
  RegisterEventListener(globalListenersList, listener, arg);
  pthread_mutex_unlock(&eventsMutex);
}

// EventsRegisterListenerByName
// file ../include/events.h line 108
void EventsRegisterListenerByName(const char *event, void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  char *return_value_strchr_1;
  if((signed int)*event == 0)
    EventsRegisterListener(listener, arg);

  else
  {
    return_value_strchr_1=strchr(event, 46);
    if(return_value_strchr_1 == ((char *)NULL))
    {
      struct EventSource_s *src;
      src=EventsFindSource(event);
      if(!(src == ((struct EventSource_s *)NULL)))
        EventsRegisterSourceListener(src, listener, arg);

      else
        LogModule(1, EVENTS, "Failed to find event source %s", event);
    }

    else
    {
      struct Event_s *evt;
      evt=EventsFindEvent(event);
      if(!(evt == ((struct Event_s *)NULL)))
        EventsRegisterEventListener(evt, listener, arg);

      else
        LogModule(1, EVENTS, "Failed to find event %s", event);
    }
  }
}

// EventsRegisterSource
// file ../include/events.h line 137
struct EventSource_s * EventsRegisterSource(char *name)
{
  struct EventSource_s *result = (struct EventSource_s *)(void *)0;
  pthread_mutex_lock(&eventsMutex);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("EventSource_t", "events.c", 195);
  result = (struct EventSource_s *)return_value_ObjectCreateImpl_1;
  if(!(result == ((struct EventSource_s *)NULL)))
  {
    result->name=strdup(name);
    result->listeners=ListCreate();
    result->events=ListCreate();
    ListAdd(sourcesList, (void *)result);
    LogModule(3, EVENTS, "New event source registered (%s)\n", name);
  }

  pthread_mutex_unlock(&eventsMutex);
  return result;
}

// EventsRegisterSourceListener
// file events.c line 236
void EventsRegisterSourceListener(struct EventSource_s *source, void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  if(!(source == ((struct EventSource_s *)NULL)))
  {
    pthread_mutex_lock(&eventsMutex);
    RegisterEventListener(source->listeners, listener, arg);
    pthread_mutex_unlock(&eventsMutex);
  }

}

// EventsUnregisterEvent
// file ../include/events.h line 184
void EventsUnregisterEvent(struct Event_s *event)
{
  pthread_mutex_lock(&eventsMutex);
  LogModule(3, EVENTS, "Event unregistered (%s.%s)\n", event->source->name, event->name);
  ListRemove(event->source->events, (void *)event);
  EventFree(event);
  pthread_mutex_unlock(&eventsMutex);
}

// EventsUnregisterEventListener
// file ../include/events.h line 220
void EventsUnregisterEventListener(struct Event_s *event, void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  if(!(event == ((struct Event_s *)NULL)))
  {
    pthread_mutex_lock(&eventsMutex);
    UnRegisterEventListener(event->listeners, listener, arg);
    pthread_mutex_unlock(&eventsMutex);
  }

}

// EventsUnregisterListener
// file events.c line 184
void EventsUnregisterListener(void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  pthread_mutex_lock(&eventsMutex);
  UnRegisterEventListener(globalListenersList, listener, arg);
  pthread_mutex_unlock(&eventsMutex);
}

// EventsUnregisterListenerByName
// file ../include/events.h line 116
void EventsUnregisterListenerByName(const char *event, void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  char *return_value_strchr_1;
  if((signed int)*event == 0)
    EventsUnregisterListener(listener, arg);

  else
  {
    return_value_strchr_1=strchr(event, 46);
    if(return_value_strchr_1 == ((char *)NULL))
    {
      struct EventSource_s *src;
      src=EventsFindSource(event);
      if(!(src == ((struct EventSource_s *)NULL)))
        EventsUnregisterSourceListener(src, listener, arg);

      else
        LogModule(1, EVENTS, "Failed to find event source %s", event);
    }

    else
    {
      struct Event_s *evt;
      evt=EventsFindEvent(event);
      if(!(evt == ((struct Event_s *)NULL)))
        EventsUnregisterEventListener(evt, listener, arg);

      else
        LogModule(1, EVENTS, "Failed to find event %s", event);
    }
  }
}

// EventsUnregisterSource
// file ../include/events.h line 144
void EventsUnregisterSource(struct EventSource_s *source)
{
  pthread_mutex_lock(&eventsMutex);
  LogModule(3, EVENTS, "Event source unregistered (%s)\n", source->name);
  ListRemove(sourcesList, (void *)source);
  EventSourceFree(source);
  pthread_mutex_unlock(&eventsMutex);
}

// EventsUnregisterSourceListener
// file events.c line 246
void EventsUnregisterSourceListener(struct EventSource_s *source, void (*listener)(void *, struct Event_s *, void *), void *arg)
{
  if(!(source == ((struct EventSource_s *)NULL)))
  {
    pthread_mutex_lock(&eventsMutex);
    UnRegisterEventListener(source->listeners, listener, arg);
    pthread_mutex_unlock(&eventsMutex);
  }

}

// FELockedEventListener
// file commands/cmd_scanning.c line 1428
static void FELockedEventListener(void *arg, struct Event_s *event, void *payload)
{
  if((signed int)currentScanState == ScanState_NextMux)
    ScanStateMachine((enum ScanEvent_e)ScanEvent_FELocked);

}

// FilterService
// file commands/cmd_info.c line 386
static _Bool FilterService(struct Service_t *service, unsigned int filterByType, unsigned int filterByAccess, char *provider)
{
  _Bool filterByTypeResult = (_Bool)0;
  _Bool filterByAccessResult = (_Bool)0;
  _Bool filterByProviderResult = (_Bool)0;
  if(!(filterByType == 0u))
  {
    if(!((1u & filterByType) == 0u))
    {
      if((signed int)service->type == ServiceType_TV)
        filterByTypeResult = (_Bool)1;

    }

    if(!((2u & filterByType) == 0u))
    {
      if((signed int)service->type == ServiceType_Radio)
        filterByTypeResult = (_Bool)1;

    }

    if(!((4u & filterByType) == 0u))
    {
      if((signed int)service->type == ServiceType_Data)
        filterByTypeResult = (_Bool)1;

    }

    if(!((8u & filterByType) == 0u))
    {
      if((signed int)service->type == ServiceType_Unknown)
        filterByTypeResult = (_Bool)1;

    }

  }

  else
    filterByTypeResult = (_Bool)1;
  if(!(filterByAccess == 0u))
  {
    if(!((1u & filterByAccess) == 0u))
    {
      if(service->conditionalAccess == (_Bool)0)
        filterByAccessResult = (_Bool)1;

    }

    if(!((2u & filterByAccess) == 0u))
    {
      if(!(service->conditionalAccess == (_Bool)0))
        filterByAccessResult = (_Bool)1;

    }

  }

  else
    filterByAccessResult = (_Bool)1;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(!(provider == ((char *)NULL)))
  {
    if(!(service->provider == ((char *)NULL)))
    {
      return_value_strcmp_1=strcmp(provider, service->provider);
      tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    filterByProviderResult = tmp_if_expr_2;
  }

  else
    filterByProviderResult = (_Bool)1;
  return filterByTypeResult != (_Bool)0 && filterByAccessResult != (_Bool)0 && filterByProviderResult != (_Bool)0;
}

// FindClass
// file objects.c line 451
static struct Class_s * FindClass(char *classname)
{
  struct Class_s *clazz = classes;
  for( ; !(clazz == ((struct Class_s *)NULL)); clazz = clazz->next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(classname, clazz->name);
    if(return_value_strcmp_1 == 0)
      return clazz;

  }
  return (struct Class_s *)(void *)0;
}

// FindCommand
// file commands.c line 426
static struct Command_t * FindCommand(struct Command_t *commands, char *command)
{
  signed int i = 0;
  for( ; !((commands + (signed long int)i)->command == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(command, (commands + (signed long int)i)->command);
    if(return_value_strcasecmp_1 == 0)
      return &commands[(signed long int)i];

  }
  return (struct Command_t *)(void *)0;
}

// FindMultiplexFrequency
// file commands/cmd_scanning.c line 1475
static struct Multiplex_s * FindMultiplexFrequency(struct MultiplexList_s *muxList, struct MuxFrequencies_s *muxFreqList, unsigned long int freq, signed int range, char *polarisation, signed int satNumber)
{
  signed int i = 0;
  _Bool tmp_if_expr_2;
  for( ; !(i >= muxList->nrofMultiplexes); i = i + 1)
    if((unsigned long int)muxFreqList->frequencies[(signed long int)i].frequency >= freq + -((unsigned long int)range))
    {
      if(freq + (unsigned long int)range >= (unsigned long int)muxFreqList->frequencies[(signed long int)i].frequency)
      {
        _Bool found = (_Bool)1;
        if(!(polarisation == ((char *)NULL)))
        {
          signed int return_value_strcmp_1;
          return_value_strcmp_1=strcmp(polarisation, muxFreqList->frequencies[(signed long int)i].polarisation);
          if(return_value_strcmp_1 == 0)
            tmp_if_expr_2 = muxFreqList->frequencies[(signed long int)i].satNumber == satNumber ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          found = tmp_if_expr_2;
        }

        if(!(found == (_Bool)0))
        {
          ObjectRefIncImpl((void *)muxList->multiplexes[(signed long int)i], "commands/cmd_scanning.c", 1495);
          return muxList->multiplexes[(signed long int)i];
        }

      }

    }

  return (struct Multiplex_s *)(void *)0;
}

// FindPluginFeatureName
// file pluginmgr.c line 474
static char * FindPluginFeatureName(signed int type)
{
  signed int i = 0;
  for( ; !(pluginFeatures[(signed long int)i].feature == 0x00); i = i + 1)
    if(pluginFeatures[(signed long int)i].feature == type)
      return pluginFeatures[(signed long int)i].name;

  return (char *)(void *)0;
}

// FindTransponder
// file commands/cmd_scanning.c line 1384
static _Bool FindTransponder(signed int freq, char *polarisation)
{
  struct ListIterator_s iterator;
  iterator.current = transponderList->head;
  iterator.list = transponderList;
  signed int return_value_strcmp_2;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TransponderEntry_s *entry = (struct TransponderEntry_s *)iterator.current->data;
    if(entry->frequency == (unsigned int)freq)
    {
      if(!(polarisation == ((char *)NULL)))
      {
        if(!(entry->polarisation == ((char *)NULL)))
        {
          return_value_strcmp_2=strcmp(entry->polarisation, polarisation);
          if(return_value_strcmp_2 == 0)
            return (_Bool)1;

        }

      }

    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  return (_Bool)0;
}

// FireEventListeners
// file events.c line 448
static void FireEventListeners(struct List_s *listenerList, struct Event_s *event, void *payload)
{
  struct ListIterator_s iterator;
  iterator.current = listenerList->head;
  iterator.list = listenerList;
  struct ListEntry_s *tmp_if_expr_1;
  if(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct EventListenerDetails_s *details = (struct EventListenerDetails_s *)iterator.current->data;
    details->callback(details->arg, event, payload);
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
    iterator.current = tmp_if_expr_1;
  }

}

// GetConnectionString
// file remoteintf.c line 467
static void GetConnectionString(struct sockaddr_storage *connAddr, char *output)
{
  if((signed int)connAddr->ss_family == 2)
  {
    inet_ntop((signed int)connAddr->ss_family, (const void *)&((struct sockaddr_in *)connAddr)->sin_addr, output, (unsigned int)16);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(output);
    sprintf(output + (signed long int)return_value_strlen_1, ":%d", ((struct sockaddr_in *)connAddr)->sin_port);
  }

  else
    if((signed int)connAddr->ss_family == 10)
    {
      *output = (char)91;
      inet_ntop((signed int)connAddr->ss_family, (const void *)&((struct sockaddr_in *)connAddr)->sin_addr, output + (signed long int)1, (unsigned int)46);
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(output);
      sprintf(output + (signed long int)return_value_strlen_2, "]:%d", ((struct sockaddr_in *)connAddr)->sin_port);
    }

    else
    {
      strcpy(output, "<unknown>");
      LogModule(0, REMOTEINTERFACE, "Unknown family %d\n", connAddr->ss_family);
    }
}

// GetPropertyTypeString
// file commands/cmd_info.c line 917
static char * GetPropertyTypeString(enum PropertyType_e type)
{
  char *typeStr = (char *)(void *)0;
  switch((signed int)type)
  {
    case PropertyType_None:
    {
      typeStr = "None";
      break;
    }
    case PropertyType_Int:
    {
      typeStr = "Integer";
      break;
    }
    case PropertyType_Float:
    {
      typeStr = "Float";
      break;
    }
    case PropertyType_Boolean:
    {
      typeStr = "Boolean";
      break;
    }
    case PropertyType_String:
    {
      typeStr = "String";
      break;
    }
    case PropertyType_Char:
    {
      typeStr = "Character";
      break;
    }
    case PropertyType_PID:
    {
      typeStr = "PID";
      break;
    }
    case PropertyType_IPAddress:
    {
      typeStr = "IP Address";
      break;
    }
    default:
      typeStr = "Unknown";
  }
  return typeStr;
}

// GetStreamTypeString
// file commands/cmd_info.c line 671
static char * GetStreamTypeString(signed int type)
{
  char *result = "Unknown";
  switch(type)
  {
    case 0x00:
    {
      result = "ITU-T | ISO/IEC Reserved";
      break;
    }
    case 0x01:
    {
      result = "ISO/IEC 11172 Video";
      break;
    }
    case 0x02:
    {
      result = "ITU-T Rec. H.262 | ISO/IEC 13818-2 Video or ISO/IEC 11172-2 constrained parameter video stream";
      break;
    }
    case 0x03:
    {
      result = "ISO/IEC 11172 Audio";
      break;
    }
    case 0x04:
    {
      result = "ISO/IEC 13818-3 Audio";
      break;
    }
    case 0x05:
    {
      result = "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 private_sections";
      break;
    }
    case 0x06:
    {
      result = "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 PES packets containing private data";
      break;
    }
    case 0x07:
    {
      result = "ISO/IEC 13522 MHEG";
      break;
    }
    case 0x08:
    {
      result = "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Annex A DSM-CC";
      break;
    }
    case 0x09:
    {
      result = "ITU-T Rec. H.222.1";
      break;
    }
    case 0x0A:
    {
      result = "ISO/IEC 13818-6 type A";
      break;
    }
    case 0x0B:
    {
      result = "ISO/IEC 13818-6 type B";
      break;
    }
    case 0x0C:
    {
      result = "ISO/IEC 13818-6 type C";
      break;
    }
    case 0x0D:
    {
      result = "ISO/IEC 13818-6 type D";
      break;
    }
    case 0x0E:
    {
      result = "ITU-T Rec. H.222.0 | ISO/IEC 13818-1 auxiliary";
      break;
    }
    case 0x0F:
    {
      result = "ISO/IEC 13818-7 Audio with ADTS transport syntax";
      break;
    }
    case 0x10:
    {
      result = "ISO/IEC 14496-2 Visual";
      break;
    }
    case 0x11:
    {
      result = "ISO/IEC 14496-3 Audio with the LATM transport syntax as defined in ISO/IEC 14496-3 / AMD 1";
      break;
    }
    case 0x12:
    {
      result = "ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in PES packets";
      break;
    }
    case 0x13:
    {
      result = "ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in ISO/IEC14496_sections.";
      break;
    }
    case 0x14:
    {
      result = "ISO/IEC 13818-6 Synchronized Download Protocol";
      break;
    }
    case 0x15:
    {
      result = "Metadata carried in PES packets";
      break;
    }
    case 0x16:
    {
      result = "Metadata carried in metadata_sections";
      break;
    }
    case 0x17:
    {
      result = "Metadata carried in ISO/IEC 13818-6 Data Carousel";
      break;
    }
    case 0x18:
    {
      result = "Metadata carried in ISO/IEC 13818-6 Object Carousel";
      break;
    }
    case 0x19:
    {
      result = "Metadata carried in ISO/IEC 13818-6 Synchronized Download Protocol";
      break;
    }
    case 0x1A:
    {
      result = "IPMP stream (defined in ISO/IEC 13818-11, MPEG-2 IPMP)";
      break;
    }
    case 0x1B:
    {
      result = "AVC video stream as defined in ITU-T Rec. H.264 | ISO/IEC 14496-10 Video";
      break;
    }
    case 0x7F:
      result = "IPMP stream";
  }
  result = "User Private";
  return result;
}

// HandleConnection
// file remoteintf.c line 337
static void HandleConnection(struct Connection_t *connection)
{
  struct pollfd pfd[1l];
  char connectionStr[48l];
  char line[256l];
  signed int socketfd;
  struct _IO_FILE *fp;
  struct CommandContext_t context;
  GetConnectionString(&connection->clientAddress, connectionStr);
  context.interface = connectionStr;
  context.authenticated = (_Bool)0;
  context.remote = (_Bool)1;
  context.infp = connection->fp;
  context.outfp = connection->fp;
  context.privateArg = (void *)connection;
  context.commands = ConnectionCommands;
  socketfd = connection->socketfd;
  fp = connection->fp;
  pfd[(signed long int)0].fd = socketfd;
  pfd[(signed long int)0].events = (signed short int)0x001;
  PrintResponse(fp, (unsigned short int)0x0000, "Ready");
  while(remoteIntfExit == (_Bool)0)
  {
    if(connection->connected == (_Bool)0)
      break;

    signed int r;
    pfd[(signed long int)0].revents = (signed short int)0;
    r=poll(pfd, (unsigned long int)1, 30000);
    if(!((0x001 & (signed int)pfd[0l].revents) == 0))
    {
      char *nl;
      char *return_value_fgets_1;
      return_value_fgets_1=fgets(line, 256, fp);
      if(!(return_value_fgets_1 == ((char *)NULL)))
      {
        nl=strchr(line, 10);
        if(!(nl == ((char *)NULL)))
          *nl = (char)0;

        nl=strchr(line, 13);
        if(!(nl == ((char *)NULL)))
          *nl = (char)0;

        LogModule(3, REMOTEINTERFACE, "%s: Received Line: \"%s\"\n", context.interface, (const void *)line);
        CommandExecute(&context, line);
        PrintResponse(fp, context.errorNumber, context.errorMessage);
      }

      else
        connection->connected = (_Bool)0;
    }

    else
      connection->connected = (_Bool)0;
  }
  LogModule(1, REMOTEINTERFACE, "%s: Connection closed!\n", context.interface);
  fclose(fp);
  connection->connected = (_Bool)0;
  LogModule(3, REMOTEINTERFACE, "Connection thread exiting.\n");
  unsigned long int return_value_pthread_self_2;
  return_value_pthread_self_2=pthread_self();
  LogUnregisterThread(return_value_pthread_self_2);
  pthread_detach(connection->thread);
  RemoveConnection(connection);
}

// HuffmanDecode
// file standard/atsc/atsctext.c line 538
static void HuffmanDecode(unsigned char *dest, unsigned char *src, signed int destLen, signed int srcLen, signed int comp)
{
  unsigned char p = (unsigned char)0;
  unsigned char c = (unsigned char)0;
  unsigned char o = (unsigned char)0;
  unsigned char b = (unsigned char)0;
  unsigned char *co;
  unsigned int i;
  unsigned int j;
  unsigned int k;
  unsigned int to;
  unsigned int zo;
  unsigned int z;
  unsigned int *bo;
  if(comp == 1)
  {
    bo = huffman1bo;
    co = huffman1co;
    z = (unsigned int)1683;
  }

  else
  {
    bo = huffman2bo;
    co = huffman2co;
    z = (unsigned int)1525;
  }
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)(srcLen << 3)); i = i + 1u)
  {
    if((signed int)p >= 128)
      goto __CPROVER_DUMP_L12;

    to = bo[(signed long int)p];
    b = (unsigned char)((signed int)src[(signed long int)(i >> 3)] & 1 << (~i & (unsigned int)7));
    if(!((signed int)b == 0))
      b = (unsigned char)1;

    zo = to + (unsigned int)((signed int)o << 1) + (unsigned int)b;
    if(!(z >= zo))
      goto __CPROVER_DUMP_L12;

    o = co[(signed long int)zo];
    if(!((0x80 & (signed int)o) == 0))
    {
      c = (unsigned char)(0x7F & (signed int)o);
      if((signed int)c == 27)
      {
        i = i + 1u;
        j = i & (unsigned int)7;
        k = (unsigned int)8 - j;
        c = src[(signed long int)(i >> 3)];
        if(!(j == 0u))
        {
          c = c << j;
          b = src[(signed long int)((i >> 3) + (unsigned int)1)];
          b = b >> k;
          c = c | b;
        }

        i = i + (unsigned int)7;
      }

      p = c;
      o = (unsigned char)0;
      *dest = c;
      destLen = destLen - 1;
      if(!(destLen >= 1))
      {
        *dest = (unsigned char)0;
        break;
      }

      dest = dest + 1l;
      if((signed int)c == 0)
        break;

    }

  }

__CPROVER_DUMP_L12:
  ;
}

// InformMultiplexChanged
// file ts.c line 1000
static void InformMultiplexChanged(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  iterator.current = reader->groups->head;
  iterator.list = reader->groups;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSFilterGroup_t *group = (struct TSFilterGroup_t *)iterator.current->data;
    if(!(group->eventCallback == ((void (*)(void *, struct TSFilterGroup_t *, enum TSFilterEventType_e, void *))NULL)))
      group->eventCallback(group->userArg, group, (enum TSFilterEventType_e)TSFilterEventType_MuxChanged, (void *)reader->multiplex);

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
}

// InformTSStructureChanged
// file ts.c line 987
static void InformTSStructureChanged(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  iterator.current = reader->groups->head;
  iterator.list = reader->groups;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSFilterGroup_t *group = (struct TSFilterGroup_t *)iterator.current->data;
    if(!(group->eventCallback == ((void (*)(void *, struct TSFilterGroup_t *, enum TSFilterEventType_e, void *))NULL)))
      group->eventCallback(group->userArg, group, (enum TSFilterEventType_e)TSFilterEventType_StructureChanged, (void *)0);

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
}

// InitDaemon
// file main.c line 779
static void InitDaemon(signed int adapter)
{
  signed int pid;
  signed int sid;
  pid=fork();
  if(!(pid >= 0))
  {
    LogModule(0, MAIN, "First fork failed while going into daemon mode");
    exit(1);
  }

  if(pid >= 1)
    exit(0);

  sid=setsid();
  if(!(sid >= 0))
  {
    LogModule(0, MAIN, "setsid failed while going into daemon mode");
    exit(1);
  }

  signed int return_value_chdir_1;
  return_value_chdir_1=chdir("/");
  if(!(return_value_chdir_1 >= 0))
  {
    LogModule(0, MAIN, "chdir failed while going into daemon mode");
    exit(1);
  }

  struct _IO_FILE *return_value_freopen_2;
  return_value_freopen_2=freopen("/dev/null", "r", stdin);
  if(return_value_freopen_2 == ((struct _IO_FILE *)NULL))
    LogModule(0, MAIN, "Failed to redirect stdin to /dev/null!");

  LoggingRedirectStdErrStdOut();
  pid=fork();
  if(!(pid >= 0))
  {
    LogModule(0, MAIN, "Second fork failed while going into daemon mode");
    exit(1);
  }

  if(pid >= 1)
  {
    struct _IO_FILE *fp;
    sprintf(PidFile, "/var/run/dvbstreamer-%d.pid", adapter);
    fp=fopen(PidFile, "wt");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      sprintf(PidFile, "%s/dvbstreamer-%d.pid", (const void *)DataDirectory, adapter);
      fp=fopen(PidFile, "wt");
    }

    if(!(fp == ((struct _IO_FILE *)NULL)))
    {
      fprintf(fp, "%d", pid);
      fclose(fp);
    }

    exit(0);
  }

  DaemonMode = (_Bool)1;
}

// InputDispatcher
// file dispatchers.c line 135
static void * InputDispatcher(void *arg)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  LogRegisterThread(return_value_pthread_self_1, "InputDispatcher");
  LogModule(2, DISPATCHERS, "Input dispatcher started");
  ev_loop(InputEventLoop, 0);
  LogModule(2, DISPATCHERS, "Input dispatcher finished");
  return (void *)0;
}

// InputExit
// file dispatchers.c line 125
static void InputExit(struct ev_loop *loop, struct ev_io *w, signed int revents)
{
  ev_unloop(loop, 2);
}

// InstallSysProperties
// file main.c line 575
static void InstallSysProperties(void)
{
  sprintf(hexVersionStr, "%02x%02x", 2, 1);
  PropertiesAddProperty("sys", "version", "Version of this instance of DVBStreamer", (enum PropertyType_e)PropertyType_String, (void *)&versionStr, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty("sys", "hexversion", "Version of this instance of DVBStreamer as a 16 bit hex number", (enum PropertyType_e)PropertyType_String, (void *)&hexVersionStr, (1 & 1) != 0 ? PropertiesSimplePropertyGet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0, (1 & 2) != 0 ? PropertiesSimplePropertySet : (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty("sys", "uptime", "The time that this instance has been running in days/hours/minutes/seconds.", (enum PropertyType_e)PropertyType_String, (void *)0, SysPropertyGetUptime, (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
  PropertiesAddProperty("sys.uptime", "seconds", "The time that this instance has been running in seconds.", (enum PropertyType_e)PropertyType_Int, (void *)0, SysPropertyGetUptimeSecs, (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
}

// LNBDecode
// file ../include/lnb.h line 28
signed int LNBDecode(char *str, struct LNBInfo_s *lnb)
{
  signed int i;
  char *cp;
  char *np;
  memset((void *)lnb, 0, sizeof(struct LNBInfo_s) /*40ul*/ );
  cp = str;
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(*cp == 0); cp = cp + 1l)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*cp]) == 0)
      break;

  }
  const unsigned short int **return_value___ctype_b_loc_3;
  return_value___ctype_b_loc_3=__ctype_b_loc();
  _Bool tmp_if_expr_5;
  const unsigned short int **return_value___ctype_b_loc_4;
  const unsigned short int **return_value___ctype_b_loc_6;
  const unsigned short int **return_value___ctype_b_loc_8;
  if(!((1024 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*cp]) == 0))
  {
    i = 0;
    for( ; !(i >= 5); i = i + 1)
    {
      signed int return_value_strcasecmp_2;
      return_value_strcasecmp_2=strcasecmp(LNBs[(signed long int)i].name, cp);
      if(return_value_strcasecmp_2 == 0)
      {
        *lnb = LNBs[(signed long int)i];
        return 0;
      }

    }
    return 1;
  }

  else
  {
    if((signed int)*cp == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___ctype_b_loc_4=__ctype_b_loc();
      tmp_if_expr_5 = !(((signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*cp] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return 0;

    else
    {
      lnb->lowFrequency=strtoul(cp, &np, 0);
      if(lnb->lowFrequency == 0ul)
        return 1;

      else
      {
        cp = np;
        for( ; !(*cp == 0); cp = cp + 1l)
        {
          return_value___ctype_b_loc_6=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)*cp]) == 0)
          {
            if(!((signed int)*cp == 44))
              break;

          }

        }
        if((signed int)*cp == 0)
          return 0;

        else
        {
          const unsigned short int **return_value___ctype_b_loc_7;
          return_value___ctype_b_loc_7=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)*cp]) == 0)
            return 1;

          else
          {
            lnb->highFrequency=strtoul(cp, &np, 0);
            cp = np;
            for( ; !(*cp == 0); cp = cp + 1l)
            {
              return_value___ctype_b_loc_8=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)*cp]) == 0)
              {
                if(!((signed int)*cp == 44))
                  break;

              }

            }
            if((signed int)*cp == 0)
              return 0;

            else
            {
              const unsigned short int **return_value___ctype_b_loc_9;
              return_value___ctype_b_loc_9=__ctype_b_loc();
              if((2048 & (signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)*cp]) == 0)
                return 1;

              else
              {
                lnb->switchFrequency=strtoul(cp, (char ** restrict )(void *)0, 0);
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// LNBEnumerate
// file ../include/lnb.h line 21
struct LNBInfo_s * LNBEnumerate(signed int curno)
{
  if(curno >= 5)
    return (struct LNBInfo_s *)(void *)0;

  else
    return &LNBs[(signed long int)curno];
}

// LNBTransponderToIntermediateFreq
// file ../include/lnb.h line 39
unsigned long int LNBTransponderToIntermediateFreq(struct LNBInfo_s *info, unsigned long int freq, _Bool *tone)
{
  _Bool hiband = (_Bool)0;
  unsigned long int ifreq = (unsigned long int)0;
  *tone = (_Bool)0;
  if(!(info->switchFrequency == 0ul))
  {
    if(!(info->highFrequency == 0ul))
    {
      if(freq >= info->switchFrequency)
        hiband = (_Bool)1;

    }

  }

  if(!(hiband == (_Bool)0))
  {
    ifreq = freq - info->highFrequency;
    *tone = (_Bool)1;
  }

  else
  {
    if(!(freq >= info->lowFrequency))
      ifreq = info->lowFrequency - freq;

    else
      ifreq = freq - info->lowFrequency;
    *tone = (_Bool)0;
  }
  return ifreq;
}

// ListAdd
// file ../include/list.h line 157
_Bool ListAdd(struct List_s *list, void *data)
{
  struct ListIterator_s iterator = { .list=list, .current=list->tail };
  _Bool return_value_ListInsertAfterCurrent_1;
  return_value_ListInsertAfterCurrent_1=ListInsertAfterCurrent(&iterator, data);
  return return_value_ListInsertAfterCurrent_1;
}

// ListCreate
// file ../include/list.h line 122
struct List_s * ListCreate()
{
  ObjectRegisterClass("List_t", (unsigned int)sizeof(struct List_s) /*24ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("List_t", "list.c", 40);
  return (struct List_s *)return_value_ObjectCreateImpl_1;
}

// ListDump
// file list.c line 220
void ListDump(struct List_s *list)
{
  struct ListIterator_s iterator;
  LogModule(3, LIST, "Dumping list %p (%d entries)\n", list, list->count);
  iterator.current = list->head;
  iterator.list = list;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    LogModule(3, LIST, "Current = %010p prev = %010p  next = %010p data = %010p\n", iterator.current, iterator.current->prev, iterator.current->next, iterator.current->data);
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  LogModule(3, LIST, "End of dump\n");
}

// ListFree
// file ../include/list.h line 136
void ListFree(struct List_s *list, void (*destructor)(void *))
{
  struct ListEntry_s *entry;
  struct ListEntry_s *next;
  if(!(list == ((struct List_s *)NULL)))
  {
    entry = list->head;
    for( ; !(entry == ((struct ListEntry_s *)NULL)); entry = next)
    {
      next = entry->next;
      if(!(destructor == ((void (*)(void *))NULL)))
        destructor(entry->data);

      free((void *)entry);
    }
    list->count = 0;
    list->head = (struct ListEntry_s *)(void *)0;
    list->tail = (struct ListEntry_s *)(void *)0;
    ObjectRefDecImpl((void *)list, "list.c", 61);
  }

}

// ListFreeObject
// file ../include/list.h line 149
void ListFreeObject(void *ptr)
{
  ObjectRefDecImpl(ptr, "list.c", 67);
}

// ListGet
// file list.c line 202
_Bool ListGet(struct List_s *list, signed int index, void **data)
{
  signed int i;
  struct ListEntry_s *entry = list->head;
  _Bool result = (_Bool)0;
  i = 0;
  for( ; !(entry == ((struct ListEntry_s *)NULL)) && !(i >= index); i = i + 1)
    entry = entry->next;
  if(!(entry == ((struct ListEntry_s *)NULL)))
  {
    *data = entry->data;
    result = (_Bool)1;
  }

  return result;
}

// ListInsertAfterCurrent
// file list.c line 76
_Bool ListInsertAfterCurrent(struct ListIterator_s *iterator, void *data)
{
  struct ListEntry_s *entry;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ListEntry_s) /*24ul*/ );
  entry = (struct ListEntry_s *)return_value_calloc_1;
  if(entry == ((struct ListEntry_s *)NULL))
    return (_Bool)0;

  else
  {
    entry->data = data;
    if(iterator->current == ((struct ListEntry_s *)NULL))
    {
      entry->next = (struct ListEntry_s *)(void *)0;
      entry->prev = iterator->list->tail;
      if(!(entry->prev == ((struct ListEntry_s *)NULL)))
        entry->prev->next = entry;

    }

    else
    {
      entry->next = iterator->current->next;
      entry->prev = iterator->current;
      iterator->current->next = entry;
      if(!(entry->next == ((struct ListEntry_s *)NULL)))
        entry->next->prev = entry;

    }
    if(iterator->list->head == ((struct ListEntry_s *)NULL))
      iterator->list->head = entry;

    if(entry->next == ((struct ListEntry_s *)NULL))
      iterator->list->tail = entry;

    iterator->list->count = iterator->list->count + 1;
    return (_Bool)1;
  }
}

// ListInsertBeforeCurrent
// file list.c line 116
_Bool ListInsertBeforeCurrent(struct ListIterator_s *iterator, void *data)
{
  struct ListEntry_s *entry;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ListEntry_s) /*24ul*/ );
  entry = (struct ListEntry_s *)return_value_calloc_1;
  if(entry == ((struct ListEntry_s *)NULL))
    return (_Bool)0;

  else
  {
    entry->data = data;
    entry->next = iterator->current;
    if(iterator->current == ((struct ListEntry_s *)NULL))
    {
      entry->prev = iterator->list->tail;
      iterator->list->tail = entry;
    }

    else
    {
      entry->prev = iterator->current->prev;
      entry->next->prev = entry;
    }
    if(iterator->current == iterator->list->head)
      iterator->list->head = entry;

    if(!(entry->prev == ((struct ListEntry_s *)NULL)))
      entry->prev->next = entry;

    iterator->list->count = iterator->list->count + 1;
    return (_Bool)1;
  }
}

// ListRemove
// file ../include/list.h line 174
_Bool ListRemove(struct List_s *list, void *data)
{
  struct ListIterator_s iterator;
  iterator.current = list->head;
  iterator.list = list;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    if(data == iterator.current->data)
    {
      ListRemoveCurrent(&iterator);
      return (_Bool)1;
    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  return (_Bool)0;
}

// ListRemoveCurrent
// file ../include/list.h line 205
void ListRemoveCurrent(struct ListIterator_s *iterator)
{
  struct List_s *list = iterator->list;
  struct ListEntry_s *entry = iterator->current;
  iterator->current = entry->next;
  if(entry == list->head)
    list->head = entry->next;

  if(entry == list->tail)
    list->tail = entry->prev;

  if(!(entry->prev == ((struct ListEntry_s *)NULL)))
    entry->prev->next = entry->next;

  if(!(entry->next == ((struct ListEntry_s *)NULL)))
    entry->next->prev = entry->prev;

  free((void *)entry);
  iterator->list->count = iterator->list->count - 1;
}

// ListReplace
// file list.c line 162
_Bool ListReplace(struct List_s *list, void *oldData, void *newData)
{
  struct ListIterator_s iterator;
  iterator.current = list->head;
  iterator.list = list;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    if(oldData == iterator.current->data)
    {
      iterator.current->data = newData;
      return (_Bool)1;
    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  return (_Bool)0;
}

// LogGetModuleLevel
// file logging.c line 309
static signed int LogGetModuleLevel(const char *module, signed int level)
{
  signed int result = level;
  struct ModuleLevel_s *modLevel = moduleLevels;
  for( ; !(modLevel == ((struct ModuleLevel_s *)NULL)); modLevel = modLevel->next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(modLevel->module, module);
    if(return_value_strcmp_1 == 0)
    {
      if(!(level >= modLevel->level))
        result = verbosity + 1;

      break;
    }

  }
  return result;
}

// LogGetThreadName
// file logging.c line 294
static char * LogGetThreadName(unsigned long int thread)
{
  signed int i = 0;
  for( ; !(i >= 100); i = i + 1)
    if(thread == threadNames[(signed long int)i].thread)
      return threadNames[(signed long int)i].name;

  static char numericName[20l];
  sprintf(numericName, "0x%08lx", (unsigned long int)thread);
  return numericName;
}

// LogImpl
// file logging.c line 258
static void LogImpl(signed int level, const char *module, const char *format, void **valist)
{
  char timeBuffer[24l];
  signed long int curtime;
  struct tm *loctime;
  char *thread;
  pthread_mutex_lock(&mutex);
  curtime=time((signed long int *)(void *)0);
  loctime=localtime(&curtime);
  strftime(timeBuffer, sizeof(char [24l]) /*24ul*/ , "%F %T", loctime);
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  thread=LogGetThreadName(return_value_pthread_self_1);
  fprintf(logFP, "%-19s | %-15s | %2d | %-15s | ", (const void *)timeBuffer, module != ((const char *)NULL) ? module : "<Unknown>", level, thread);
  vfprintf(logFP, format, valist);
  char *return_value_strchr_2;
  return_value_strchr_2=strchr(format, 10);
  if(return_value_strchr_2 == ((char *)NULL))
    fprintf(logFP, "\n");

  signed int *return_value___errno_location_6;
  if(level == 0)
  {
    return_value___errno_location_6=__errno_location();
    if(!(*return_value___errno_location_6 == 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      fprintf(logFP, "%-19s | %-15s | %2d | %-15s | errno = %d (%s)\n", (const void *)timeBuffer, module != ((const char *)NULL) ? module : "<Unknown>", level, thread, *return_value___errno_location_3, return_value_strerror_5);
    }

  }

  pthread_mutex_unlock(&mutex);
}

// LogLevelDec
// file logging.c line 154
void LogLevelDec(void)
{
  verbosity = verbosity + 1;
}

// LogLevelGet
// file logging.c line 144
signed int LogLevelGet(void)
{
  return verbosity;
}

// LogLevelInc
// file logging.c line 149
void LogLevelInc(void)
{
  verbosity = verbosity + 1;
}

// LogLevelIsEnabled
// file logging.c line 159
_Bool LogLevelIsEnabled(signed int level)
{
  return level <= verbosity;
}

// LogLevelSet
// file logging.c line 139
void LogLevelSet(signed int level)
{
  verbosity = level;
}

// LogLoadModuleLevels
// file ../include/logging.h line 126
void LogLoadModuleLevels(const char *path)
{
  struct _IO_FILE *fp;
  char line[256l];
  char module[128l];
  signed int level;
  fp=fopen(path, "r");
  signed int return_value_feof_1;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    do
    {
      return_value_feof_1=feof(fp);
      if(!(return_value_feof_1 == 0))
        break;

      char *return_value_fgets_4;
      return_value_fgets_4=fgets(line, (signed int)(sizeof(char [256l]) /*256ul*/  - (unsigned long int)1), fp);
      if(!(return_value_fgets_4 == ((char *)NULL)))
      {
        printf("Module Level Line: %s", (const void *)line);
        signed int return_value_sscanf_3;
        return_value_sscanf_3=sscanf(line, "%s %d\n", (const void *)module, &level);
        if(return_value_sscanf_3 == 2)
        {
          struct ModuleLevel_s *modLevel;
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct ModuleLevel_s) /*24ul*/ );
          modLevel = (struct ModuleLevel_s *)return_value_malloc_2;
          printf("Module : %s Level %d\n", (const void *)module, level);
          modLevel->module=strdup(module);
          modLevel->level = level;
          modLevel->next = moduleLevels;
          moduleLevels = modLevel;
        }

      }

    }
    while((_Bool)1);

}

// LogModule
// file ../include/logging.h line 149
extern void LogModule(signed int level, const char *module, char *format, ...)
{
  void **valist;
  if(level == 0)
  {
    valist = (void **)&format;
    vfprintf(stderr, format, valist);
    valist = ((void **)NULL);
    char *return_value_strchr_1;
    return_value_strchr_1=strchr(format, 10);
    if(return_value_strchr_1 == ((char *)NULL))
      fprintf(stderr, "\n");

  }

  signed int return_value_LogGetModuleLevel_2;
  return_value_LogGetModuleLevel_2=LogGetModuleLevel(module, level);
  if(verbosity >= return_value_LogGetModuleLevel_2)
  {
    valist = (void **)&format;
    LogImpl(level, module, format, valist);
    valist = ((void **)NULL);
  }

}

// LogRegisterThread
// file ../include/logging.h line 134
void LogRegisterThread(unsigned long int thread, const char *name)
{
  signed int i;
  pthread_mutex_lock(&mutex);
  i = 0;
  for( ; !(i >= 100); i = i + 1)
    if(threadNames[(signed long int)i].thread == 0ul)
    {
      threadNames[(signed long int)i].thread = thread;
      threadNames[(signed long int)i].name=strdup(name);
      break;
    }

  pthread_mutex_unlock(&mutex);
}

// LogUnregisterThread
// file ../include/logging.h line 140
void LogUnregisterThread(unsigned long int thread)
{
  signed int i;
  pthread_mutex_lock(&mutex);
  i = 0;
  for( ; !(i >= 100); i = i + 1)
    if(threadNames[(signed long int)i].thread == thread)
    {
      threadNames[(signed long int)i].thread = (unsigned long int)0;
      free((void *)threadNames[(signed long int)i].name);
      break;
    }

  pthread_mutex_unlock(&mutex);
}

// LoggingDeInit
// file ../include/logging.h line 91
void LoggingDeInit(void)
{
  fclose(logFP);
}

// LoggingInit
// file ../include/logging.h line 69
signed int LoggingInit(char *filename, signed int logLevel)
{
  char *logFile;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)4096, (unsigned long int)1);
  logFile = (char *)return_value_calloc_1;
  sprintf(logFile, "/var/log/%s", filename);
  logFP=fopen(logFile, "a");
  if(logFP == ((struct _IO_FILE *)NULL))
  {
    sprintf(logFile, "%s/%s", (const void *)DataDirectory, filename);
    logFP=fopen(logFile, "a");
  }

  if(logFP == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    setbuf(logFP, (char *)(void *)0);
    LoggingInitCommon(logLevel);
    return 0;
  }
}

// LoggingInitCommon
// file logging.c line 249
static void LoggingInitCommon(signed int logLevel)
{
  fprintf(logFP, "------------------- | --------------- | -- | --------------- | ----------------------------------------\n");
  fprintf(logFP, "Date       Time     | Module          | Lv | Thread          | Details\n");
  fprintf(logFP, "------------------- | --------------- | -- | --------------- | ----------------------------------------\n");
  verbosity = logLevel;
  memset((void *)&threadNames, 0, sizeof(struct ThreadName_s [100l]) /*1600ul*/ );
}

// LoggingInitFile
// file ../include/logging.h line 78
signed int LoggingInitFile(char *filepath, signed int logLevel)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(filepath, "-");
  if(return_value_strcmp_1 == 0)
    logFP = stderr;

  else
  {
    logFP=fopen(filepath, "a");
    if(logFP == ((struct _IO_FILE *)NULL))
      return -1;

    setbuf(logFP, (char *)(void *)0);
  }
  LoggingInitCommon(logLevel);
  return 0;
}

// LoggingRedirectStdErrStdOut
// file ../include/logging.h line 85
void LoggingRedirectStdErrStdOut(void)
{
  signed int return_value_fileno_1;
  return_value_fileno_1=fileno(logFP);
  dup2(return_value_fileno_1, 1);
  signed int return_value_fileno_2;
  return_value_fileno_2=fileno(logFP);
  dup2(return_value_fileno_2, 2);
}

// MPEG2StandardDeinit
// file ../include/standard/mpeg2.h line 32
signed int MPEG2StandardDeinit(struct TSReader_t *reader)
{
  reader = reader;
  PATProcessorDestroy(patProcessor);
  PMTProcessorDestroy(pmtProcessor);
  return 0;
}

// MPEG2StandardInit
// file ../include/standard/mpeg2.h line 31
signed int MPEG2StandardInit(struct TSReader_t *reader)
{
  if(MPEG2EventSource == ((struct EventSource_s *)NULL))
    MPEG2EventSource=EventsRegisterSource(MPEG2FilterType);

  patProcessor=PATProcessorCreate(reader);
  if(patProcessor == ((struct PATProcessor_s *)NULL))
    return -1;

  else
  {
    pmtProcessor=PMTProcessorCreate(reader);
    if(pmtProcessor == ((struct PMTProcessor_s *)NULL))
    {
      PATProcessorDestroy(patProcessor);
      return -1;
    }

    else
      return 0;
  }
}

// MainDVBAdapterGet
// file main.c line 623
struct DVBAdapter_s * MainDVBAdapterGet(void)
{
  return DVBAdapter;
}

// MainIsATSC
// file main.c line 664
_Bool MainIsATSC()
{
  signed int i;
  struct DVBSupportedDeliverySys_s *supportedSystems;
  supportedSystems=DVBFrontEndGetDeliverySystems(DVBAdapter);
  i = 0;
  for( ; !(i >= supportedSystems->nrofSystems); i = i + 1)
    if((signed int)supportedSystems->systems[(signed long int)i] == DELSYS_ATSC)
      return (_Bool)1;

  return (_Bool)0;
}

// MainIsDVB
// file main.c line 633
_Bool MainIsDVB()
{
  signed int i;
  struct DVBSupportedDeliverySys_s *supportedSystems;
  supportedSystems=DVBFrontEndGetDeliverySystems(DVBAdapter);
  i = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; !(i >= supportedSystems->nrofSystems); i = i + 1)
  {
    if((signed int)supportedSystems->systems[(signed long int)i] == DELSYS_DVBS)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)supportedSystems->systems[(signed long int)i] == DELSYS_DVBC ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)supportedSystems->systems[(signed long int)i] == DELSYS_DVBT ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return (_Bool)1;

  }
  return (_Bool)0;
}

// MainIsISDB
// file main.c line 684
_Bool MainIsISDB()
{
  signed int i;
  struct DVBSupportedDeliverySys_s *supportedSystems;
  supportedSystems=DVBFrontEndGetDeliverySystems(DVBAdapter);
  i = 0;
  for( ; !(i >= supportedSystems->nrofSystems); i = i + 1)
    if((signed int)supportedSystems->systems[(signed long int)i] == DELSYS_ISDBT)
      return (_Bool)1;

  return (_Bool)0;
}

// MainServiceFilterGetPrimary
// file main.c line 628
struct ServiceFilter_s * MainServiceFilterGetPrimary(void)
{
  return PrimaryServiceFilter;
}

// MainTSReaderGet
// file main.c line 618
struct TSReader_t * MainTSReaderGet(void)
{
  return TSReader;
}

// MapStringToValue
// file dvbadapter.c line 1572
static unsigned int MapStringToValue(struct StringToParamMapping_s *mapping, const char *str, unsigned int defaultValue)
{
  signed int i = 0;
  for( ; !((mapping + (signed long int)i)->str == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp((mapping + (signed long int)i)->str, str);
    if(return_value_strcasecmp_1 == 0)
      return (mapping + (signed long int)i)->param;

  }
  return defaultValue;
}

// MapValueToString
// file dvbadapter.c line 1558
static char * MapValueToString(struct StringToParamMapping_s *mapping, unsigned int value, char *defaultValue)
{
  signed int i = 0;
  for( ; !((mapping + (signed long int)i)->str == ((char *)NULL)); i = i + 1)
    if((mapping + (signed long int)i)->param == value)
      return (mapping + (signed long int)i)->str;

  return defaultValue;
}

// MapYamlNode
// file dvbadapter.c line 1585
static unsigned int MapYamlNode(struct yaml_document_s *document, const char *key, struct StringToParamMapping_s *mapping, unsigned int defaultValue)
{
  struct yaml_node_s *node;
  struct yaml_node_s *return_value_yaml_document_get_root_node_1;
  return_value_yaml_document_get_root_node_1=yaml_document_get_root_node(document);
  node=YamlUtils_MappingFind(document, return_value_yaml_document_get_root_node_1, key);
  if(!(node == ((struct yaml_node_s *)NULL)))
  {
    if((signed int)node->type == YAML_SCALAR_NODE)
    {
      unsigned int return_value_MapStringToValue_2;
      return_value_MapStringToValue_2=MapStringToValue(mapping, (const char *)node->data.scalar.value, defaultValue);
      return return_value_MapStringToValue_2;
    }

  }

  return defaultValue;
}

// MessageQAvailable
// file threading/messageq.c line 110
signed int MessageQAvailable(struct MessageQ_s *msgQ)
{
  signed int count = 0;
  pthread_mutex_lock(&msgQ->mutex);
  count = msgQ->messages->count;
  pthread_mutex_unlock(&msgQ->mutex);
  return count;
}

// MessageQCreate
// file ../include/messageq.h line 43
struct MessageQ_s * MessageQCreate()
{
  struct MessageQ_s *result;
  ObjectRegisterClass(MessageQClass, (unsigned int)sizeof(struct MessageQ_s) /*104ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl(MessageQClass, "threading/messageq.c", 60);
  result = (struct MessageQ_s *)return_value_ObjectCreateImpl_1;
  if(!(result == ((struct MessageQ_s *)NULL)))
  {
    result->messages=ListCreate();
    if(!(result->messages == ((struct List_s *)NULL)))
    {
      pthread_mutex_init(&result->mutex, (const union anonymous_38 *)(void *)0);
      pthread_cond_init(&result->availableCond, (const union anonymous_38 *)(void *)0);
      LogModule(3, MESSAGEQ, "Create messageq %p\n", result);
    }

    else
    {
      ObjectRefDecImpl((void *)result, "threading/messageq.c", 72);
      result = (struct MessageQ_s *)(void *)0;
    }
  }

  return result;
}

// MessageQDestroy
// file ../include/messageq.h line 49
void MessageQDestroy(struct MessageQ_s *msgQ)
{
  struct ListIterator_s iterator;
  LogModule(3, MESSAGEQ, "Destroying messageq %p\n", msgQ);
  MessageQSetQuit(msgQ);
  pthread_mutex_lock(&msgQ->mutex);
  iterator.current = msgQ->messages->head;
  iterator.list = msgQ->messages;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    void *object = iterator.current->data;
    ObjectRefDecImpl(object, "threading/messageq.c", 88);
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  ListFree(msgQ->messages, (void (*)(void *))(void *)0);
  pthread_mutex_unlock(&msgQ->mutex);
  pthread_mutex_destroy(&msgQ->mutex);
  pthread_cond_destroy(&msgQ->availableCond);
  ObjectRefDecImpl((void *)msgQ, "threading/messageq.c", 94);
  LogModule(3, MESSAGEQ, "Destroyed messageq %p\n", msgQ);
}

// MessageQIsQuitSet
// file ../include/messageq.h line 108
_Bool MessageQIsQuitSet(struct MessageQ_s *msgQ)
{
  _Bool result = (_Bool)0;
  pthread_mutex_lock(&msgQ->mutex);
  result = msgQ->quit;
  pthread_mutex_unlock(&msgQ->mutex);
  return result;
}

// MessageQReceive
// file threading/messageq.c line 119
void * MessageQReceive(struct MessageQ_s *msgQ)
{
  void *result = (void *)0;
  pthread_mutex_lock(&msgQ->mutex);
  if(msgQ->quit == (_Bool)0)
  {
    if(msgQ->messages->count == 0)
      pthread_cond_wait(&msgQ->availableCond, &msgQ->mutex);

    if(msgQ->quit == (_Bool)0)
    {
      struct ListIterator_s iterator;
      iterator.current = msgQ->messages->head;
      iterator.list = msgQ->messages;
      result = iterator.current->data;
      ListRemoveCurrent(&iterator);
    }

  }

  pthread_mutex_unlock(&msgQ->mutex);
  return result;
}

// MessageQReceiveTimed
// file ../include/messageq.h line 87
void * MessageQReceiveTimed(struct MessageQ_s *msgQ, unsigned long int timeout)
{
  void *result = (void *)0;
  struct timespec tilltime;
  pthread_mutex_lock(&msgQ->mutex);
  if(msgQ->quit == (_Bool)0)
  {
    if(msgQ->messages->count == 0)
    {
      clock_gettime(0, &tilltime);
      tilltime.tv_nsec = tilltime.tv_nsec + (signed long int)(timeout * (unsigned long int)1000000);
      pthread_cond_timedwait(&msgQ->availableCond, &msgQ->mutex, &tilltime);
    }

    if(msgQ->quit == (_Bool)0)
    {
      if(msgQ->messages->count >= 1)
      {
        struct ListIterator_s iterator;
        iterator.current = msgQ->messages->head;
        iterator.list = msgQ->messages;
        result = iterator.current->data;
        ListRemoveCurrent(&iterator);
      }

    }

  }

  pthread_mutex_unlock(&msgQ->mutex);
  return result;
}

// MessageQResetQuit
// file threading/messageq.c line 176
void MessageQResetQuit(struct MessageQ_s *msgQ)
{
  pthread_mutex_lock(&msgQ->mutex);
  msgQ->quit = (_Bool)0;
  pthread_mutex_unlock(&msgQ->mutex);
}

// MessageQSend
// file ../include/messageq.h line 60
void MessageQSend(struct MessageQ_s *msgQ, void *msg)
{
  pthread_mutex_lock(&msgQ->mutex);
  if(msgQ->quit == (_Bool)0)
  {
    ObjectRefIncImpl(msg, "threading/messageq.c", 103);
    ListAdd(msgQ->messages, msg);
    pthread_cond_signal(&msgQ->availableCond);
  }

  pthread_mutex_unlock(&msgQ->mutex);
}

// MessageQSetQuit
// file threading/messageq.c line 168
void MessageQSetQuit(struct MessageQ_s *msgQ)
{
  pthread_mutex_lock(&msgQ->mutex);
  msgQ->quit = (_Bool)1;
  pthread_cond_signal(&msgQ->availableCond);
  pthread_mutex_unlock(&msgQ->mutex);
}

// MultiplexAdd
// file multiplexes.c line 196
signed int MultiplexAdd(enum DVBDeliverySystem_e delSys, char *tuningParams, struct Multiplex_s **mux)
{
  struct Multiplex_s *multiplex;
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("INSERT INTO Multiplexes(uid,type,tuningparams)VALUES (%d, %d, %Q);", uidSeed, delSys, tuningParams);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexAdd", 206, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  void *return_value_ObjectCreateImpl_4;
  return_value_ObjectCreateImpl_4=ObjectCreateImpl("Multiplex_t", "multiplexes.c", 212);
  multiplex = (struct Multiplex_s *)return_value_ObjectCreateImpl_4;
  multiplex->uid = uidSeed;
  uidSeed = uidSeed + 1;
  multiplex->tsId = 0;
  multiplex->networkId = 0;
  multiplex->deliverySystem = delSys;
  multiplex->patVersion = -1;
  multiplex->tuningParams=strdup(tuningParams);
  EventsFireEventListeners(multiplexAddedEvent, (void *)multiplex);
  *mux = multiplex;
  return rc;
}

// MultiplexDeInit
// file ../include/multiplexes.h line 84
signed int MultiplexDeInit(void)
{
  return 0;
}

// MultiplexDelete
// file multiplexes.c line 226
signed int MultiplexDelete(struct Multiplex_s *multiplex)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("DELETE FROM Multiplexes WHERE uid=%d;", multiplex->uid);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexDelete", 232, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  ServiceDeleteAll(multiplex);
  EventsFireEventListeners(multiplexRemovedEvent, (void *)multiplex);
  return 0;
}

// MultiplexDestructor
// file multiplexes.c line 292
static void MultiplexDestructor(void *ptr)
{
  struct Multiplex_s *mux = (struct Multiplex_s *)ptr;
  if(!(mux->tuningParams == ((char *)NULL)))
    free((void *)mux->tuningParams);

}

// MultiplexEnumeratorDestroy
// file multiplexes.c line 136
void MultiplexEnumeratorDestroy(void *enumerator)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)enumerator;
  rc=sqlite3_finalize(stmt);
}

// MultiplexEnumeratorGet
// file multiplexes.c line 127
void * MultiplexEnumeratorGet()
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  struct sqlite3 *return_value_DBaseConnectionGet_1;
  return_value_DBaseConnectionGet_1=DBaseConnectionGet();
  rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, "SELECT Multiplexes.uid,Multiplexes.tsid,Multiplexes.netid,Multiplexes.type,Multiplexes.tuningparams FROM Multiplexes;", -1, &stmt, (const char **)(void *)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexEnumeratorGet", 132, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (void *)0;
    }

  while((_Bool)0);
  return (void *)stmt;
}

// MultiplexEventToString
// file ../include/multiplexes.h line 219
signed int MultiplexEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload)
{
  struct Multiplex_s *mux = (struct Multiplex_s *)payload;
  char idStr[16l];
  signed int mappingId;
  mappingId=yaml_document_add_mapping(document, (unsigned char *)"tag:yaml.org,2002:map", (enum yaml_mapping_style_e)YAML_ANY_MAPPING_STYLE);
  sprintf(idStr, "%d", mux->uid);
  YamlUtils_MappingAdd(document, mappingId, "Multiplex UID", idStr);
  sprintf(idStr, "%04x.%04x", mux->networkId & 0xffff, mux->tsId & 0xffff);
  YamlUtils_MappingAdd(document, mappingId, "Multiplex ID", idStr);
  return mappingId;
}

// MultiplexFind
// file multiplexes.c line 74
struct Multiplex_s * MultiplexFind(char *mux)
{
  struct Multiplex_s *result = (struct Multiplex_s *)(void *)0;
  signed int netId;
  signed int tsId;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(mux, "%x.%x", &netId, &tsId);
  if(return_value_sscanf_1 == 2)
    result=MultiplexFindId(netId, tsId);

  else
  {
    signed int n;
    n=atoi(mux);
    result=MultiplexFindUID(n);
  }
  return result;
}

// MultiplexFindId
// file multiplexes.c line 110
struct Multiplex_s * MultiplexFindId(signed int netid, signed int tsid)
{
  struct Multiplex_s *result = (struct Multiplex_s *)(void *)0;
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT Multiplexes.uid,Multiplexes.tsid,Multiplexes.netid,Multiplexes.type,Multiplexes.tuningparams FROM Multiplexes WHERE netid=%d AND tsid=%d;", netid, tsid);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexFindId", 119, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (struct Multiplex_s *)(void *)0;
    }

  while((_Bool)0);
  result=MultiplexGetNext((void *)stmt);
  rc=sqlite3_finalize(stmt);
  return result;
}

// MultiplexFindUID
// file ../include/multiplexes.h line 105
struct Multiplex_s * MultiplexFindUID(signed int uid)
{
  struct Multiplex_s *result = (struct Multiplex_s *)(void *)0;
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT Multiplexes.uid,Multiplexes.tsid,Multiplexes.netid,Multiplexes.type,Multiplexes.tuningparams FROM Multiplexes WHERE uid=%d;", uid);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexFindUID", 102, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (struct Multiplex_s *)(void *)0;
    }

  while((_Bool)0);
  result=MultiplexGetNext((void *)stmt);
  rc=sqlite3_finalize(stmt);
  return result;
}

// MultiplexGetAll
// file multiplexes.c line 174
struct MultiplexList_s * MultiplexGetAll(void)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  signed int i;
  signed int count;
  struct MultiplexList_s *list;
  count=DBaseCount("Multiplexes", (char *)(void *)0);
  struct sqlite3 *return_value_DBaseConnectionGet_1;
  return_value_DBaseConnectionGet_1=DBaseConnectionGet();
  rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, "SELECT Multiplexes.uid,Multiplexes.tsid,Multiplexes.netid,Multiplexes.type,Multiplexes.tuningparams FROM Multiplexes;", -1, &stmt, (const char **)(void *)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexGetAll", 185, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (struct MultiplexList_s *)(void *)0;
    }

  while((_Bool)0);
  struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_4;
  return_value_ObjectCollectionCreateImpl_4=ObjectCollectionCreateImpl("MultiplexList_t", (unsigned int)count, "multiplexes.c", 187);
  list = (struct MultiplexList_s *)return_value_ObjectCollectionCreateImpl_4;
  i = 0;
  for( ; !(i >= count); i = i + 1)
    list->multiplexes[(signed long int)i]=MultiplexGetNext((void *)stmt);
  rc=sqlite3_finalize(stmt);
  return list;
}

// MultiplexGetNext
// file multiplexes.c line 143
struct Multiplex_s * MultiplexGetNext(void *enumerator)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)enumerator;
  char *tmp;
  rc=sqlite3_step(stmt);
  if(rc == 100)
  {
    struct Multiplex_s *multiplex;
    void *return_value_ObjectCreateImpl_1;
    return_value_ObjectCreateImpl_1=ObjectCreateImpl("Multiplex_t", "multiplexes.c", 153);
    multiplex = (struct Multiplex_s *)return_value_ObjectCreateImpl_1;
    multiplex->uid=sqlite3_column_int(stmt, 0);
    signed int return_value_sqlite3_column_int_2;
    return_value_sqlite3_column_int_2=sqlite3_column_int(stmt, 1);
    multiplex->tsId = return_value_sqlite3_column_int_2 & 0xffff;
    signed int return_value_sqlite3_column_int_3;
    return_value_sqlite3_column_int_3=sqlite3_column_int(stmt, 2);
    multiplex->networkId = return_value_sqlite3_column_int_3 & 0xffff;
    signed int return_value_sqlite3_column_int_4;
    return_value_sqlite3_column_int_4=sqlite3_column_int(stmt, 3);
    multiplex->deliverySystem = (enum DVBDeliverySystem_e)return_value_sqlite3_column_int_4;
    multiplex->patVersion = -1;
    const unsigned char *return_value_sqlite3_column_text_5;
    return_value_sqlite3_column_text_5=sqlite3_column_text(stmt, 4);
    tmp = (char *)return_value_sqlite3_column_text_5;
    if(!(tmp == ((char *)NULL)))
      multiplex->tuningParams=strdup(tmp);

    return multiplex;
  }

  if(!(rc == 101))
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_6;
      return_value_DBaseConnectionGet_6=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_7;
      return_value_sqlite3_errmsg_7=sqlite3_errmsg(return_value_DBaseConnectionGet_6);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexGetNext", 169, rc, return_value_sqlite3_errmsg_7);
    }
    while((_Bool)0);

  return (struct Multiplex_s *)(void *)0;
}

// MultiplexInit
// file ../include/multiplexes.h line 78
signed int MultiplexInit(void)
{
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  uidSeed = (signed int)return_value_time_1;
  multiplexSource=EventsRegisterSource("Multiplexes");
  multiplexAddedEvent=EventsRegisterEvent(multiplexSource, "Added", MultiplexEventToString);
  multiplexRemovedEvent=EventsRegisterEvent(multiplexSource, "Removed", MultiplexEventToString);
  ObjectRegisterCollection("MultiplexList_t", (unsigned int)sizeof(struct Multiplex_s *) /*8ul*/ , MultiplexListDestructor);
  signed int return_value_ObjectRegisterClass_2;
  return_value_ObjectRegisterClass_2=ObjectRegisterClass("Multiplex_t", (unsigned int)sizeof(struct Multiplex_s) /*32ul*/ , MultiplexDestructor);
  return return_value_ObjectRegisterClass_2;
}

// MultiplexListDestructor
// file multiplexes.c line 301
static void MultiplexListDestructor(void *ptr)
{
  struct MultiplexList_s *muxList = (struct MultiplexList_s *)ptr;
  signed int i = 0;
  for( ; !(i >= muxList->nrofMultiplexes); i = i + 1)
    ObjectRefDecImpl((void *)muxList->multiplexes[(signed long int)i], "multiplexes.c", 307);
}

// MultiplexNetworkIdSet
// file multiplexes.c line 260
signed int MultiplexNetworkIdSet(struct Multiplex_s *multiplex, signed int netid)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Multiplexes SET netid=%d WHERE uid=%d;", netid, multiplex->uid);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  multiplex->networkId = netid;
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexNetworkIdSet", 267, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// MultiplexTSIdSet
// file multiplexes.c line 245
signed int MultiplexTSIdSet(struct Multiplex_s *multiplex, signed int tsid)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Multiplexes SET tsid=%d WHERE uid=%d;", tsid, multiplex->uid);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  multiplex->tsId = tsid;
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"MultiplexTSIdSet", 252, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// NITEventListener
// file commands/cmd_scanning.c line 1221
static void NITEventListener(void *arg, struct Event_s *event, void *payload)
{
  struct dvbpsi_nit_s *newnit = (struct dvbpsi_nit_s *)payload;
  struct DVBAdapter_s *adapter;
  adapter=MainDVBAdapterGet();
  struct TransponderEntry_s *tpEntry;
  signed int i;
  struct dvbpsi_nit_transport_s *transport = (struct dvbpsi_nit_transport_s *)(void *)0;
  unsigned int frequency;
  char tparams[256l];
  char sparams[256l];
  char *polarisation = (char *)(void *)0;
  enum DVBDeliverySystem_e delSys = (enum DVBDeliverySystem_e)DELSYS_MAX_SUPPORTED;
  tparams[(signed long int)0] = (char)0;
  sparams[(signed long int)0] = (char)0;
  struct dvbpsi_sat_deliv_sys_dr_s *satDelSysDr;
  _Bool return_value_DVBFrontEndDeliverySystemSupported_3;
  _Bool return_value_DVBFrontEndDeliverySystemSupported_6;
  _Bool return_value_DVBFrontEndDeliverySystemSupported_9;
  if((signed int)scanType == ScanType_Network && !(transponderList == ((struct List_s *)NULL)) && ((signed int)currentScanState == ScanState_WaitingForTables || (signed int)currentScanState == ScanState_WaitingForNIT))
  {
    transport = newnit->p_first_transport;
    for( ; !(transport == ((struct dvbpsi_nit_transport_s *)NULL)); transport = transport->p_next)
    {
      struct dvbpsi_descriptor_s *descriptor = transport->p_first_descriptor;
      for( ; !(descriptor == ((struct dvbpsi_descriptor_s *)NULL)); descriptor = descriptor->p_next)
        switch((signed int)descriptor->i_tag)
        {
          case 0x43:
          {
            sparams[(signed long int)0] = (char)0;
            satDelSysDr=dvbpsi_DecodeSatDelivSysDr(descriptor);
            polarisation = polarisationTable[(signed long int)satDelSysDr->i_polarization];
            return_value_DVBFrontEndDeliverySystemSupported_3=DVBFrontEndDeliverySystemSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBS);
            if(!(return_value_DVBFrontEndDeliverySystemSupported_3 == (_Bool)0))
            {
              if(!((signed int)satDelSysDr->i_modulation_system == 1))
              {
                double freq;
                freq=BCDFixedPoint3_7ToDouble(satDelSysDr->i_frequency);
                double symbolRate;
                symbolRate=BCDFixedPoint3_7ToDouble(satDelSysDr->i_symbol_rate << 4);
                frequency = (unsigned int)(freq * 1000000.0);
                sprintf(tparams, "Inversion: AUTO\nFEC: %s\nSymbol Rate: %u\nPolarisation: %s\nSatellite Number: %d\n", fecInnerTable[(signed long int)satDelSysDr->i_fec_inner], (unsigned int)(symbolRate * 1000000.0), polarisation, DVBSSatNumber);
                delSys = (enum DVBDeliverySystem_e)DELSYS_DVBS;
                do
                {
                  _Bool return_value_FindTransponder_2;
                  return_value_FindTransponder_2=FindTransponder((signed int)frequency, polarisation);
                  if(return_value_FindTransponder_2 == (_Bool)0)
                  {
                    void *return_value_ObjectCreateImpl_1;
                    return_value_ObjectCreateImpl_1=ObjectCreateImpl("TransponderEntry_t", "commands/cmd_scanning.c", 1287);
                    tpEntry = (struct TransponderEntry_s *)return_value_ObjectCreateImpl_1;
                    if(!(tpEntry == ((struct TransponderEntry_s *)NULL)))
                    {
                      tpEntry->delSys = delSys;
                      asprintf(&tpEntry->tuningParams, "Frequency: %u\n%s", frequency, (const void *)sparams);
                      tpEntry->frequency = frequency;
                      tpEntry->netId = (signed int)transport->i_original_network_id;
                      tpEntry->tsId = (signed int)transport->i_ts_id;
                      ListAdd(transponderList, (void *)tpEntry);
                    }

                  }

                }
                while((_Bool)0);
              }

            }

            return_value_DVBFrontEndDeliverySystemSupported_6=DVBFrontEndDeliverySystemSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBS2);
            if(!(return_value_DVBFrontEndDeliverySystemSupported_6 == (_Bool)0))
            {
              if((signed int)satDelSysDr->i_modulation_system == 1)
              {
                double NITEventListener__1__1__1__1__1__1__1__2__freq;
                NITEventListener__1__1__1__1__1__1__1__2__freq=BCDFixedPoint3_7ToDouble(satDelSysDr->i_frequency);
                double NITEventListener__1__1__1__1__1__1__1__2__symbolRate;
                NITEventListener__1__1__1__1__1__1__1__2__symbolRate=BCDFixedPoint3_7ToDouble(satDelSysDr->i_symbol_rate << 4);
                frequency = (unsigned int)(NITEventListener__1__1__1__1__1__1__1__2__freq * 1000000.0);
                sprintf(tparams, "Inversion: AUTO\nFEC: %s\nSymbol Rate: %u\nRoll Off: %s\nPolarisation: %s\nSatellite Number: %d\n", fecInnerTable[(signed long int)satDelSysDr->i_fec_inner], (unsigned int)(NITEventListener__1__1__1__1__1__1__1__2__symbolRate * 1000000.0), rollOffTable[(signed long int)satDelSysDr->i_roll_off], polarisationTable[(signed long int)satDelSysDr->i_polarization], DVBSSatNumber);
                delSys = (enum DVBDeliverySystem_e)DELSYS_DVBS2;
                do
                {
                  _Bool return_value_FindTransponder_5;
                  return_value_FindTransponder_5=FindTransponder((signed int)frequency, polarisation);
                  if(return_value_FindTransponder_5 == (_Bool)0)
                  {
                    void *return_value_ObjectCreateImpl_4;
                    return_value_ObjectCreateImpl_4=ObjectCreateImpl("TransponderEntry_t", "commands/cmd_scanning.c", 1309);
                    tpEntry = (struct TransponderEntry_s *)return_value_ObjectCreateImpl_4;
                    if(!(tpEntry == ((struct TransponderEntry_s *)NULL)))
                    {
                      tpEntry->delSys = delSys;
                      asprintf(&tpEntry->tuningParams, "Frequency: %u\n%s", frequency, (const void *)sparams);
                      tpEntry->frequency = frequency;
                      tpEntry->netId = (signed int)transport->i_original_network_id;
                      tpEntry->tsId = (signed int)transport->i_ts_id;
                      ListAdd(transponderList, (void *)tpEntry);
                    }

                  }

                }
                while((_Bool)0);
              }

            }

            break;
          }
          case 0x5a:
          {
            polarisation = (char *)(void *)0;
            tparams[(signed long int)0] = (char)0;
            return_value_DVBFrontEndDeliverySystemSupported_9=DVBFrontEndDeliverySystemSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBT);
            if(!(return_value_DVBFrontEndDeliverySystemSupported_9 == (_Bool)0))
            {
              struct dvbpsi_terr_deliv_sys_dr_s *terrDelSysDr;
              terrDelSysDr=dvbpsi_DecodeTerrDelivSysDr(descriptor);
              if(!(terrDelSysDr == ((struct dvbpsi_terr_deliv_sys_dr_s *)NULL)))
              {
                frequency = terrDelSysDr->i_centre_frequency * (unsigned int)10;
                sprintf(tparams, "Inversion: AUTO\nBandwidth: %s\nFEC HP: %s\nFEC LP: %s\nConstellation: %s\nGuard Interval: %s\nHierarchy: %s\nTransmission Mode: %s\n", bandwidthTable[(signed long int)terrDelSysDr->i_bandwidth], ofdmCodeRateTable[(signed long int)terrDelSysDr->i_code_rate_hp_stream], ofdmCodeRateTable[(signed long int)terrDelSysDr->i_code_rate_lp_stream], ofdmConstellationTable[(signed long int)terrDelSysDr->i_constellation], ofdmGuardIntTable[(signed long int)terrDelSysDr->i_guard_interval], ofdmHierarchyTable[(signed long int)terrDelSysDr->i_hierarchy_information], ofdmTransmitModeTable[(signed long int)terrDelSysDr->i_transmission_mode]);
                delSys = (enum DVBDeliverySystem_e)DELSYS_DVBT;
                do
                {
                  _Bool return_value_FindTransponder_8;
                  return_value_FindTransponder_8=FindTransponder((signed int)frequency, polarisation);
                  if(return_value_FindTransponder_8 == (_Bool)0)
                  {
                    void *return_value_ObjectCreateImpl_7;
                    return_value_ObjectCreateImpl_7=ObjectCreateImpl("TransponderEntry_t", "commands/cmd_scanning.c", 1338);
                    tpEntry = (struct TransponderEntry_s *)return_value_ObjectCreateImpl_7;
                    if(!(tpEntry == ((struct TransponderEntry_s *)NULL)))
                    {
                      tpEntry->delSys = delSys;
                      asprintf(&tpEntry->tuningParams, "Frequency: %u\n%s", frequency, (const void *)tparams);
                      tpEntry->frequency = frequency;
                      tpEntry->netId = (signed int)transport->i_original_network_id;
                      tpEntry->tsId = (signed int)transport->i_ts_id;
                      ListAdd(transponderList, (void *)tpEntry);
                    }

                  }

                }
                while((_Bool)0);
                if((signed int)terrDelSysDr->i_other_frequency_flag == 0)
                  tparams[(signed long int)0] = (char)0;

              }

            }

            break;
          }
          case 0x62:
          {
            struct dvbpsi_frequency_list_dr_s *freqListDr;
            freqListDr=dvbpsi_DecodeFrequencyListDr(descriptor);
            switch((signed int)freqListDr->i_coding_type)
            {
              case 1:
              {
                if(!(sparams[0l] == 0))
                {
                  i = 0;
                  for( ; !(i >= (signed int)freqListDr->i_number_of_frequencies); i = i + 1)
                  {
                    double NITEventListener__1__1__1__1__1__1__1__4__1__1__1__1__freq;
                    NITEventListener__1__1__1__1__1__1__1__4__1__1__1__1__freq=BCDFixedPoint3_7ToDouble(freqListDr->p_center_frequencies[(signed long int)i]);
                    frequency = (unsigned int)(NITEventListener__1__1__1__1__1__1__1__4__1__1__1__1__freq * 1000000.0);
                    do
                    {
                      _Bool return_value_FindTransponder_11;
                      return_value_FindTransponder_11=FindTransponder((signed int)frequency, polarisation);
                      if(return_value_FindTransponder_11 == (_Bool)0)
                      {
                        void *return_value_ObjectCreateImpl_10;
                        return_value_ObjectCreateImpl_10=ObjectCreateImpl("TransponderEntry_t", "commands/cmd_scanning.c", 1359);
                        tpEntry = (struct TransponderEntry_s *)return_value_ObjectCreateImpl_10;
                        if(!(tpEntry == ((struct TransponderEntry_s *)NULL)))
                        {
                          tpEntry->delSys = delSys;
                          asprintf(&tpEntry->tuningParams, "Frequency: %u\n%s", frequency, (const void *)sparams);
                          tpEntry->frequency = frequency;
                          tpEntry->netId = (signed int)transport->i_original_network_id;
                          tpEntry->tsId = (signed int)transport->i_ts_id;
                          ListAdd(transponderList, (void *)tpEntry);
                        }

                      }

                    }
                    while((_Bool)0);
                  }
                }

                goto __CPROVER_DUMP_L31;
              }
              case 2:
                goto __CPROVER_DUMP_L31;
              case 3:
                if(!(tparams[0l] == 0))
                {
                  i = 0;
                  for( ; !(i >= (signed int)freqListDr->i_number_of_frequencies); i = i + 1)
                  {
                    frequency = freqListDr->p_center_frequencies[(signed long int)i] * (unsigned int)10;
                    do
                    {
                      _Bool return_value_FindTransponder_13;
                      return_value_FindTransponder_13=FindTransponder((signed int)frequency, polarisation);
                      if(return_value_FindTransponder_13 == (_Bool)0)
                      {
                        void *return_value_ObjectCreateImpl_12;
                        return_value_ObjectCreateImpl_12=ObjectCreateImpl("TransponderEntry_t", "commands/cmd_scanning.c", 1371);
                        tpEntry = (struct TransponderEntry_s *)return_value_ObjectCreateImpl_12;
                        if(!(tpEntry == ((struct TransponderEntry_s *)NULL)))
                        {
                          tpEntry->delSys = delSys;
                          asprintf(&tpEntry->tuningParams, "Frequency: %u\n%s", frequency, (const void *)tparams);
                          tpEntry->frequency = frequency;
                          tpEntry->netId = (signed int)transport->i_original_network_id;
                          tpEntry->tsId = (signed int)transport->i_ts_id;
                          ListAdd(transponderList, (void *)tpEntry);
                        }

                      }

                    }
                    while((_Bool)0);
                  }
                }

              default:

                __CPROVER_DUMP_L31:
                  ;
            }
          }
        }
    }
  }

}

// NITHandler
// file standard/dvb/nitprocessor.c line 128
static void NITHandler(void *arg, struct dvbpsi_nit_s *newNIT)
{
  EventsFireEventListeners(nitEvent, (void *)newNIT);
  ObjectRefDecImpl((void *)newNIT, "standard/dvb/nitprocessor.c", 131);
}

// NITProcessorCreate
// file ../include/nitprocessor.h line 30
struct NITProcessor_s * NITProcessorCreate(struct TSReader_t *reader)
{
  struct NITProcessor_s *result;
  if(nitEvent == ((struct Event_s *)NULL))
    nitEvent=EventsRegisterEvent(DVBEventSource, "NIT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);

  ObjectRegisterClass("NITProcessor_t", (unsigned int)sizeof(struct NITProcessor_s) /*16ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("NITProcessor_t", "standard/dvb/nitprocessor.c", 74);
  result = (struct NITProcessor_s *)return_value_ObjectCreateImpl_1;
  if(!(result == ((struct NITProcessor_s *)NULL)))
    result->tsgroup=TSReaderCreateFilterGroup(reader, NITPROCESSOR, "DVB", NITProcessorFilterEventCallback, (void *)result);

  return result;
}

// NITProcessorDestroy
// file ../include/nitprocessor.h line 31
void NITProcessorDestroy(struct NITProcessor_s *processor)
{
  TSFilterGroupDestroy(processor->tsgroup);
  if(!(processor->demux == ((struct dvbpsi_decoder_s *)NULL)))
    dvbpsi_DetachDemux(processor->demux);

  ObjectRefDecImpl((void *)processor, "standard/dvb/nitprocessor.c", 90);
}

// NITProcessorFilterEventCallback
// file standard/dvb/nitprocessor.c line 96
static void NITProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details)
{
  struct NITProcessor_s *state = (struct NITProcessor_s *)userArg;
  if((signed int)event == TSFilterEventType_MuxChanged)
  {
    if(!(state->demux == ((struct dvbpsi_decoder_s *)NULL)))
    {
      TSFilterGroupRemoveSectionFilter(state->tsgroup, (unsigned short int)0x0010);
      dvbpsi_DetachDemux(state->demux);
    }

    if(!(details == NULL))
    {
      state->demux=dvbpsi_AttachDemux(SubTableHandler_link2, (void *)state);
      TSFilterGroupAddSectionFilter(state->tsgroup, (unsigned short int)0x0010, 1, state->demux);
    }

    else
      state->demux = (struct dvbpsi_decoder_s *)(void *)0;
  }

}

// NetUserExit
// file dispatchers.c line 130
static void NetUserExit(struct ev_loop *loop, struct ev_io *w, signed int revents)
{
  ev_unloop(loop, 2);
}

// NullOutputCanHandle
// file deliverymethod.c line 193
_Bool NullOutputCanHandle(char *mrl)
{
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(NullPrefix, mrl, sizeof(const char [8l]) /*8ul*/  - (unsigned long int)1);
  return return_value_strncmp_1 == 0;
}

// NullOutputCreate
// file deliverymethod.c line 198
struct DeliveryMethodInstance_t * NullOutputCreate(char *arg)
{
  return &singleInstance;
}

// NullOutputDestroy
// file deliverymethod.c line 203
void NullOutputDestroy(struct DeliveryMethodInstance_t *this)
{
  ;
}

// ObjectAllocImpl
// file ../include/objects.h line 221
void * ObjectAllocImpl(signed int size, char *file, signed int line)
{
  void *result;
  pthread_mutex_lock(&objectMutex);
  result=ObjectAllocInstance(size, (struct Class_s *)(void *)0);
  if(!(result == NULL))
    LogModule(4, OBJECT, "(%p) Malloc'ed memory size %d app ptr %p (%s:%d)\n", (struct Object_s *)((char *)result - (signed long int)sizeof(struct Object_s) /*24ul*/ ), size, result, file, line);

  pthread_mutex_unlock(&objectMutex);
  return result;
}

// ObjectAllocInstance
// file objects.c line 364
static void * ObjectAllocInstance(signed int size, struct Class_s *clazz)
{
  struct Object_s *result = (struct Object_s *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)size + sizeof(struct Object_s) /*24ul*/ );
  result = (struct Object_s *)return_value_malloc_1;
  if(result == ((struct Object_s *)NULL))
    return (void *)0;

  else
  {
    memset((void *)((char *)result + (signed long int)sizeof(struct Object_s) /*24ul*/ ), 0, (unsigned long int)size);
    result->clazz = clazz;
    result->size = (unsigned int)size;
    result->refCount = 1;
    result->next = referencedObjects;
    referencedObjects = result;
    return (void *)((char *)result + (signed long int)sizeof(struct Object_s) /*24ul*/ );
  }
}

// ObjectCollectionCreateImpl
// file ../include/objects.h line 150
struct ObjectCollection_s * ObjectCollectionCreateImpl(char *name, unsigned int entries, char *file, signed int line)
{
  struct Class_s *clazz;
  struct ObjectCollection_s *result;
  pthread_mutex_lock(&objectMutex);
  clazz=FindClass(name);
  if(clazz == ((struct Class_s *)NULL))
  {
    pthread_mutex_unlock(&objectMutex);
    return (struct ObjectCollection_s *)(void *)0;
  }

  else
  {
    void *return_value_ObjectAllocInstance_1;
    return_value_ObjectAllocInstance_1=ObjectAllocInstance((signed int)(sizeof(struct ObjectCollection_s) /*8ul*/  + (unsigned long int)(clazz->size * entries)), clazz);
    result = (struct ObjectCollection_s *)return_value_ObjectAllocInstance_1;
    if(!(result == ((struct ObjectCollection_s *)NULL)))
    {
      result->_anon0.nrofEntries = entries;
      LogModule(4, OBJECT, "(%p) Created collection of class \"%s\" entries %d app ptr %p (%s:%d)\n", (struct Object_s *)((char *)result - (signed long int)sizeof(struct Object_s) /*24ul*/ ), name, entries, result, file, line);
    }

    else
      LogModule(0, OBJECT, "Failed to create collection of class \"%s\" entries %d\n", name, entries);
    clazz->allocatedCount = clazz->allocatedCount + 1u;
    pthread_mutex_unlock(&objectMutex);
    return result;
  }
}

// ObjectCreateImpl
// file ../include/objects.h line 130
void * ObjectCreateImpl(char *classname, char *file, signed int line)
{
  struct Class_s *clazz;
  void *result;
  pthread_mutex_lock(&objectMutex);
  clazz=FindClass(classname);
  if(clazz == ((struct Class_s *)NULL))
  {
    pthread_mutex_unlock(&objectMutex);
    return (void *)0;
  }

  else
  {
    result=ObjectAllocInstance((signed int)clazz->size, clazz);
    if(!(result == NULL))
      LogModule(4, OBJECT, "(%p) Created object of class \"%s\" app ptr %p (%s:%d)\n", (struct Object_s *)((char *)result - (signed long int)sizeof(struct Object_s) /*24ul*/ ), classname, result, file, line);

    else
      LogModule(0, OBJECT, "Failed to create object of class \"%s\"\n", classname);
    clazz->allocatedCount = clazz->allocatedCount + 1u;
    pthread_mutex_unlock(&objectMutex);
    return result;
  }
}

// ObjectDeinit
// file ../include/objects.h line 63
signed int ObjectDeinit(void)
{
  if(!(referencedObjects == ((struct Object_s *)NULL)))
  {
    struct Object_s *current;
    struct Object_s *next;
    LogModule(3, OBJECT, "Objects with references outstanding:\n");
    current = referencedObjects;
    for( ; !(current == ((struct Object_s *)NULL)); current = next)
    {
      if(!(current->clazz == ((struct Class_s *)NULL)))
        LogModule(3, OBJECT, "\t%p (class %s) (refCount %u)\n", (void *)((char *)current + (signed long int)sizeof(struct Object_s) /*24ul*/ ), current->clazz->name, current->refCount);

      else
        LogModule(3, OBJECT, "\t%p (size %u) (malloc'ed)\n", (void *)((char *)current + (signed long int)sizeof(struct Object_s) /*24ul*/ ), current->size);
      next = current->next;
      free((void *)current);
    }
  }

  if(classesCount >= 1u)
  {
    struct Class_s *clazz;
    struct Class_s *ObjectDeinit__1__2__next = (struct Class_s *)(void *)0;
    LogModule(3, OBJECT, "%u Registered Classes:\n", classesCount);
    LogModule(3, OBJECT, "\tClass Name                       | Size       | Count      |Destructor?\n");
    LogModule(3, OBJECT, "\t---------------------------------|------------|------------|------------\n");
    clazz = classes;
    for( ; !(clazz == ((struct Class_s *)NULL)); clazz = ObjectDeinit__1__2__next)
    {
      LogModule(3, OBJECT, "\t%-32s | %10d | %10d | %s\n", clazz->name, clazz->size, clazz->allocatedCount, clazz->destructor != ((void (*)(void *))NULL) ? "Yes" : "No");
      ObjectDeinit__1__2__next = clazz->next;
      free((void *)clazz->name);
      free((void *)clazz);
    }
  }

  pthread_mutex_destroy(&objectMutex);
  return 0;
}

// ObjectDump
// file objects.c line 401
void ObjectDump(void *ptr)
{
  struct Object_s *object = (struct Object_s *)((char *)ptr - (signed long int)sizeof(struct Object_s) /*24ul*/ );
  if(!(object->clazz == ((struct Class_s *)NULL)))
    LogModule(3, OBJECT, "Object(%p) of class \"%s\" app ptr %p ref count %u\n", object, object->clazz->name, ptr, object->refCount);

  else
    LogModule(3, OBJECT, "Malloc'ed(%p) size %u app ptr %p ref count %u\n", object, object->size, ptr, object->refCount);
}

// ObjectFreeImpl
// file ../include/objects.h line 236
void ObjectFreeImpl(void *ptr, char *file, signed int line)
{
  struct Object_s *object = (struct Object_s *)((char *)ptr - (signed long int)sizeof(struct Object_s) /*24ul*/ );
  do
    if(!(object->clazz == ((struct Class_s *)NULL)))
    {
      LogModule(0, OBJECT, "Attempt to free a class based object! (%p class %s)\n", ptr, object->clazz->name);
      exit(1);
    }

  while((_Bool)0);
  do
    if(!(object->refCount == 1))
    {
      LogModule(0, OBJECT, "Attempt to free a memory area with a reference count > 1 (%d)\n", object->refCount);
      exit(1);
    }

  while((_Bool)0);
  ObjectRefDecImpl(ptr, file, line);
}

// ObjectGetObjectClass
// file objects.c line 430
char * ObjectGetObjectClass(void *ptr)
{
  char *classname = (char *)(void *)0;
  struct Object_s *object = (struct Object_s *)((char *)ptr - (signed long int)sizeof(struct Object_s) /*24ul*/ );
  if(!(object->clazz == ((struct Class_s *)NULL)))
    classname = object->clazz->name;

  return classname;
}

// ObjectInit
// file ../include/objects.h line 58
signed int ObjectInit(void)
{
  classes = (struct Class_s *)(void *)0;
  classesCount = (unsigned int)0;
  referencedObjects = (struct Object_s *)(void *)0;
  return 0;
}

// ObjectIsObject
// file objects.c line 414
_Bool ObjectIsObject(void *ptr)
{
  struct Object_s *object;
  struct Object_s *possibleObject = (struct Object_s *)((char *)ptr - (signed long int)sizeof(struct Object_s) /*24ul*/ );
  object = referencedObjects;
  for( ; !(object == ((struct Object_s *)NULL)); object = object->next)
    if(object == possibleObject)
      return (_Bool)1;

  return (_Bool)0;
}

// ObjectRefCount
// file objects.c line 442
signed int ObjectRefCount(void *ptr)
{
  struct Object_s *object = (struct Object_s *)((char *)ptr - (signed long int)sizeof(struct Object_s) /*24ul*/ );
  return object->refCount;
}

// ObjectRefDecImpl
// file ../include/objects.h line 183
_Bool ObjectRefDecImpl(void *ptr, char *file, signed int line)
{
  _Bool result = (_Bool)1;
  struct Object_s *object;
  char *clazzName = "<Malloc>";
  if(ptr == NULL)
  {
    LogModule(0, OBJECT, "Attempt to decrement the reference of NULL! Offending code %s:%d\n", file, line);
    return (_Bool)0;
  }

  else
  {
    pthread_mutex_lock(&objectMutex);
    object = (struct Object_s *)((char *)ptr - (signed long int)sizeof(struct Object_s) /*24ul*/ );
    if(!(object->clazz == ((struct Class_s *)NULL)))
      clazzName = object->clazz->name;

    if(object->refCount >= 1)
    {
      object->refCount = object->refCount - 1;
      LogModule(10, OBJECT, "(%p:%s) Decrementing ref count, now %d (%s:%d)\n", object, clazzName, object->refCount, file, line);
    }

    if(object->refCount == 0)
    {
      if(!(object->clazz == ((struct Class_s *)NULL)))
        LogModule(4, OBJECT, "(%p) Releasing object of class \"%s\" app ptr %p\n", object, object->clazz->name, ptr);

      else
        LogModule(4, OBJECT, "(%p) Releasing malloc'ed size %u app ptr %p\n", object, object->size, ptr);
      if(!(object->clazz == ((struct Class_s *)NULL)))
      {
        if(!(object->clazz->destructor == ((void (*)(void *))NULL)))
          object->clazz->destructor(ptr);

      }

      if(!(object->clazz == ((struct Class_s *)NULL)))
      {
        if(!(object->clazz->size == object->size))
        {
          if((signed int)object->clazz->type == ClassType_Object)
            LogModule(0, OBJECT, "(%p) Class size != Object size! (class %u object %u)\n", object, object->clazz->size, object->size);

        }

      }

      RemoveReferencedObject(object);
      memset((void *)((char *)object + (signed long int)sizeof(struct Object_s) /*24ul*/ ), 0, (unsigned long int)object->size);
      free((void *)object);
      result = (_Bool)0;
    }

    pthread_mutex_unlock(&objectMutex);
    return result;
  }
}

// ObjectRefIncImpl
// file ../include/objects.h line 166
void ObjectRefIncImpl(void *ptr, char *file, signed int line)
{
  struct Object_s *object;
  char *clazzName = "<Malloc>";
  pthread_mutex_lock(&objectMutex);
  object = (struct Object_s *)((char *)ptr - (signed long int)sizeof(struct Object_s) /*24ul*/ );
  object->refCount = object->refCount + 1;
  if(!(object->clazz == ((struct Class_s *)NULL)))
    clazzName = object->clazz->name;

  LogModule(10, OBJECT, "(%p:%s) Incrementing ref count, now %d (%s:%d)\n", object, clazzName, object->refCount, file, line);
  pthread_mutex_unlock(&objectMutex);
}

// ObjectRegisterClass
// file ../include/objects.h line 74
signed int ObjectRegisterClass(char *classname, unsigned int size, void (*destructor)(void *))
{
  signed int result;
  pthread_mutex_lock(&objectMutex);
  result=ObjectRegisterClassType(classname, (enum ClassType_e)ClassType_Object, size, destructor);
  if(result == 0)
    LogModule(4, OBJECT, "Registered Class \"%s\" size %d destructor? %s\n", classname, size, destructor != ((void (*)(void *))NULL) ? "Yes" : "No");

  pthread_mutex_unlock(&objectMutex);
  return result;
}

// ObjectRegisterClassType
// file objects.c line 180
static signed int ObjectRegisterClassType(char *name, enum ClassType_e type, unsigned int size, void (*destructor)(void *))
{
  struct Class_s *clazz;
  clazz=FindClass(name);
  if(!(clazz == ((struct Class_s *)NULL)))
    return 2;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct Class_s) /*40ul*/ );
    clazz = (struct Class_s *)return_value_malloc_1;
    if(clazz == ((struct Class_s *)NULL))
    {
      LogModule(0, OBJECT, "No space to register class %s", name);
      return 1;
    }

    else
    {
      clazz->name=strdup(name);
      clazz->type = type;
      clazz->size = size;
      clazz->destructor = destructor;
      clazz->allocatedCount = (unsigned int)0;
      clazz->next = classes;
      classes = clazz;
      classesCount = classesCount + 1u;
      return 0;
    }
  }
}

// ObjectRegisterCollection
// file ../include/objects.h line 86
signed int ObjectRegisterCollection(char *name, unsigned int entrysize, void (*destructor)(void *))
{
  signed int result;
  pthread_mutex_lock(&objectMutex);
  result=ObjectRegisterClassType(name, (enum ClassType_e)ClassType_Collection, entrysize, destructor);
  if(result == 0)
    LogModule(4, OBJECT, "Registered Collection \"%s\" size %d destructor? %s\n", name, entrysize, destructor != ((void (*)(void *))NULL) ? "Yes" : "No");

  pthread_mutex_unlock(&objectMutex);
  return result;
}

// PATEventListener
// file commands/cmd_scanning.c line 1167
static void PATEventListener(void *arg, struct Event_s *event, void *payload)
{
  struct dvbpsi_pat_s *newpat = (struct dvbpsi_pat_s *)payload;
  if((signed int)currentScanState == ScanState_WaitingForTables)
  {
    signed int i;
    struct dvbpsi_pat_program_s *patentry = newpat->p_first_program;
    patentry = newpat->p_first_program;
    i = 0;
    PMTCount = 0;
    for( ; !(patentry == ((struct dvbpsi_pat_program_s *)NULL)); patentry = patentry->p_next)
      if(!((signed int)patentry->i_number == 0x0000))
      {
        struct PMTReceived_t *pr;
        pr=PMTsRecievedFindOrAdd(patentry->i_number);
        if(!(pr == ((struct PMTReceived_t *)NULL)))
        {
          pr->pid = patentry->i_pid;
          PMTCount = PMTCount + 1;
        }

        i = i + 1;
      }

    ScanStateMachine((enum ScanEvent_e)ScanEvent_PATReceived);
    CheckPMTsReceived();
  }

}

// PATHandler
// file standard/mpeg2/patprocessor.c line 122
static void PATHandler(void *arg, struct dvbpsi_pat_s *newpat)
{
  struct PATProcessor_s *state = (struct PATProcessor_s *)arg;
  struct Multiplex_s *multiplex = state->multiplex;
  signed int count;
  signed int i;
  struct Service_t **services;
  struct dvbpsi_pat_program_s *patentry;
  LogModule(3, PATPROCESSOR, "PAT recieved, version %d (old version %d)\n", newpat->i_version, multiplex->patVersion);
  if(multiplex->patVersion == -1)
    state->tsgroup->tsReader->tsStructureChanged = (_Bool)1;

  patentry = newpat->p_first_program;
  for( ; !(patentry == ((struct dvbpsi_pat_program_s *)NULL)); patentry = patentry->p_next)
  {
    LogModule(3, PATPROCESSOR, "Service 0x%04x PMT PID 0x%04x\n", patentry->i_number, patentry->i_pid);
    if(!((signed int)patentry->i_number == 0x0000))
    {
      struct Service_t *service;
      service=CacheServiceFindId((signed int)patentry->i_number);
      if(service == ((struct Service_t *)NULL))
      {
        LogModule(3, PATPROCESSOR, "Service not found in cache while processing PAT, adding 0x%04x\n", patentry->i_number);
        service=CacheServiceAdd((signed int)patentry->i_number, (signed int)patentry->i_number);
        state->tsgroup->tsReader->tsStructureChanged = (_Bool)1;
      }

      else
        CacheServiceSeen(service, (_Bool)1, (_Bool)1);
      if(!(service == ((struct Service_t *)NULL)))
      {
        if(!(service->pmtPID == (signed int)patentry->i_pid))
          CacheUpdateServicePMTPID(service, (signed int)patentry->i_pid);

      }

      if(!(service == ((struct Service_t *)NULL)))
        do
          if(!(service == ((struct Service_t *)NULL)))
            ObjectRefDecImpl((void *)service, "standard/mpeg2/patprocessor.c", 163);

        while((_Bool)0);

    }

  }
  services=CacheServicesGet(&count);
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    _Bool found = (_Bool)0;
    patentry = newpat->p_first_program;
    for( ; !(patentry == ((struct dvbpsi_pat_program_s *)NULL)); patentry = patentry->p_next)
      if(services[(signed long int)i]->id == (signed int)patentry->i_number)
      {
        found = (_Bool)1;
        break;
      }

    if(found == (_Bool)0)
    {
      LogModule(3, PATPROCESSOR, "Service not found in PAT while checking cache, deleting 0x%04x (%s)\n", services[(signed long int)i]->id, services[(signed long int)i]->name);
      _Bool return_value_CacheServiceSeen_1;
      return_value_CacheServiceSeen_1=CacheServiceSeen(services[(signed long int)i], (_Bool)0, (_Bool)1);
      if(return_value_CacheServiceSeen_1 == (_Bool)0)
      {
        CacheServicesRelease();
        CacheServiceDelete(services[(signed long int)i]);
        services=CacheServicesGet(&count);
        i = i - 1;
        state->tsgroup->tsReader->tsStructureChanged = (_Bool)1;
      }

    }

  }
  CacheServicesRelease();
  CacheUpdateMultiplex(multiplex, (signed int)newpat->i_version, (signed int)newpat->i_ts_id);
  EventsFireEventListeners(patEvent, (void *)newpat);
  ObjectRefDecImpl((void *)newpat, "standard/mpeg2/patprocessor.c", 201);
}

// PATProcessorCreate
// file ../include/patprocessor.h line 29
struct PATProcessor_s * PATProcessorCreate(struct TSReader_t *reader)
{
  struct PATProcessor_s *state;
  if(patEvent == ((struct Event_s *)NULL))
    patEvent=EventsRegisterEvent(MPEG2EventSource, "PAT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);

  ObjectRegisterClass("PATProcessor_t", (unsigned int)sizeof(struct PATProcessor_s) /*24ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("PATProcessor_t", "standard/mpeg2/patprocessor.c", 76);
  state = (struct PATProcessor_s *)return_value_ObjectCreateImpl_1;
  if(!(state == ((struct PATProcessor_s *)NULL)))
    state->tsgroup=TSReaderCreateFilterGroup(reader, PATPROCESSOR, MPEG2FilterType, PATProcessorFilterEventCallback, (void *)state);

  return state;
}

// PATProcessorDestroy
// file ../include/patprocessor.h line 30
void PATProcessorDestroy(struct PATProcessor_s *processor)
{
  TSFilterGroupDestroy(processor->tsgroup);
  if(!(processor->multiplex == ((struct Multiplex_s *)NULL)))
  {
    dvbpsi_DetachPAT(processor->pathandle);
    do
      if(!(processor->multiplex == ((struct Multiplex_s *)NULL)))
        ObjectRefDecImpl((void *)processor->multiplex, "standard/mpeg2/patprocessor.c", 91);

    while((_Bool)0);
  }

  ObjectRefDecImpl((void *)processor, "standard/mpeg2/patprocessor.c", 93);
}

// PATProcessorFilterEventCallback
// file standard/mpeg2/patprocessor.c line 99
static void PATProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details)
{
  struct PATProcessor_s *state = (struct PATProcessor_s *)userArg;
  if((signed int)event == TSFilterEventType_MuxChanged)
  {
    if(!(state->multiplex == ((struct Multiplex_s *)NULL)))
    {
      do
        if(!(state->multiplex == ((struct Multiplex_s *)NULL)))
          ObjectRefDecImpl((void *)state->multiplex, "standard/mpeg2/patprocessor.c", 107);

      while((_Bool)0);
      TSFilterGroupRemoveSectionFilter(state->tsgroup, (unsigned short int)0);
      dvbpsi_DetachPAT(state->pathandle);
    }

    state->multiplex = (struct Multiplex_s *)details;
    if(!(details == NULL))
    {
      do
        if(!(state->multiplex == ((struct Multiplex_s *)NULL)))
          ObjectRefIncImpl((void *)state->multiplex, "standard/mpeg2/patprocessor.c", 114);

      while((_Bool)0);
      state->pathandle=dvbpsi_AttachPAT(PATHandler, (void *)state);
      TSFilterGroupAddSectionFilter(state->tsgroup, (unsigned short int)0, -1, state->pathandle);
    }

  }

}

// PIDAdd
// file pids.c line 199
static signed int PIDAdd(struct Service_t *service, struct StreamInfo_t *pid)
{
  void *descriptorblob;
  signed int size;
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("INSERT INTO PIDs (mplexuid,serviceid,pid,type,descriptors) VALUES (%d,%d,%d,%d,?);", service->multiplexUID, service->id, pid->pid, pid->type);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"PIDAdd", 213, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  descriptorblob=RollUpDescriptors(pid->descriptors, &size);
  sqlite3_bind_blob(stmt, 1, descriptorblob, size, free);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// PIDListCount
// file pids.c line 179
static signed int PIDListCount(struct Service_t *service)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  signed int result = -1;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT count () FROM PIDs WHERE mplexuid=%d AND serviceid=%d AND pid<8192;", service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"PIDListCount", 187, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return -1;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  if(rc == 100)
  {
    result=sqlite3_column_int(stmt, 0);
    rc = 0;
  }

  rc=sqlite3_finalize(stmt);
  return result;
}

// PMTEventListener
// file commands/cmd_scanning.c line 1198
static void PMTEventListener(void *arg, struct Event_s *event, void *payload)
{
  struct dvbpsi_pmt_s *newpmt = (struct dvbpsi_pmt_s *)payload;
  if((signed int)currentScanState == ScanState_WaitingForTables)
  {
    struct PMTReceived_t *pr;
    pr=PMTsRecievedFindOrAdd(newpmt->i_program_number);
    if(!(pr == ((struct PMTReceived_t *)NULL)))
      pr->received = (_Bool)1;

    CheckPMTsReceived();
  }

}

// PMTHandler
// file standard/mpeg2/pmtprocessor.c line 156
static void PMTHandler(void *arg, struct dvbpsi_pmt_s *newpmt)
{
  struct Service_t *service = (struct Service_t *)arg;
  struct ProgramInfo_s *info;
  struct dvbpsi_pmt_es_s *esentry = newpmt->p_first_es;
  signed int count = 0;
  LogModule(3, PMTPROCESSOR, "PMT recieved, version %d on PID %d\n", newpmt->i_version, service->pmtPID);
  EventsFireEventListeners(pmtEvent, (void *)newpmt);
  for( ; !(esentry == ((struct dvbpsi_pmt_es_s *)NULL)); count = count + 1)
    esentry = esentry->p_next;
  LogModule(4, PMTPROCESSOR, "%d PIDs in PMT\n", count);
  info=ProgramInfoNew(count);
  if(!(info == ((struct ProgramInfo_s *)NULL)))
  {
    signed int i;
    info->pcrPID = (signed int)newpmt->i_pcr_pid;
    info->descriptors = newpmt->p_first_descriptor;
    newpmt->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
    esentry = newpmt->p_first_es;
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      LogModule(4, PMTPROCESSOR, "    %u %d\n", esentry->i_pid, esentry->i_type);
      info->streamInfoList->streams[(signed long int)i].pid = (signed int)esentry->i_pid;
      info->streamInfoList->streams[(signed long int)i].type = (signed int)esentry->i_type;
      info->streamInfoList->streams[(signed long int)i].descriptors = esentry->p_first_descriptor;
      struct dvbpsi_descriptor_s *desc = esentry->p_first_descriptor;
      for( ; !(desc == ((struct dvbpsi_descriptor_s *)NULL)); desc = desc->p_next)
        LogModule(4, PMTPROCESSOR, "        Descriptor 0x%02x %u\n", desc->i_tag, desc->i_length);
      esentry->p_first_descriptor = (struct dvbpsi_descriptor_s *)(void *)0;
      esentry = esentry->p_next;
    }
    LogModule(4, PMTPROCESSOR, "About to update cache\n");
    CacheUpdateProgramInfo(service, info);
  }

  ObjectRefDecImpl((void *)newpmt, "standard/mpeg2/pmtprocessor.c", 204);
}

// PMTProcessorCreate
// file ../include/pmtprocessor.h line 30
struct PMTProcessor_s * PMTProcessorCreate(struct TSReader_t *reader)
{
  struct PMTProcessor_s *state;
  if(pmtEvent == ((struct Event_s *)NULL))
    pmtEvent=EventsRegisterEvent(MPEG2EventSource, "PMT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);

  ObjectRegisterClass("PMTProcessor_t", (unsigned int)sizeof(struct PMTProcessor_s) /*4616ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("PMTProcessor_t", "standard/mpeg2/pmtprocessor.c", 86);
  state = (struct PMTProcessor_s *)return_value_ObjectCreateImpl_1;
  if(!(state == ((struct PMTProcessor_s *)NULL)))
    state->tsgroup=TSReaderCreateFilterGroup(reader, PMTPROCESSOR, MPEG2FilterType, PMTProcessorFilterEventCallback, (void *)state);

  return state;
}

// PMTProcessorDestroy
// file ../include/pmtprocessor.h line 31
void PMTProcessorDestroy(struct PMTProcessor_s *processor)
{
  signed int i;
  TSFilterGroupDestroy(processor->tsgroup);
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    if(!(processor->pmthandles[(signed long int)i] == ((struct dvbpsi_decoder_s *)NULL)))
    {
      dvbpsi_DetachPMT(processor->pmthandles[(signed long int)i]);
      processor->pmthandles[(signed long int)i] = (struct dvbpsi_decoder_s *)(void *)0;
      do
        if(!(processor->services[(signed long int)i] == ((struct Service_t *)NULL)))
          ObjectRefDecImpl((void *)processor->services[(signed long int)i], "standard/mpeg2/pmtprocessor.c", 104);

      while((_Bool)0);
      processor->services[(signed long int)i] = (struct Service_t *)(void *)0;
    }

  ObjectRefDecImpl((void *)processor, "standard/mpeg2/pmtprocessor.c", 108);
}

// PMTProcessorFilterEventCallback
// file standard/mpeg2/pmtprocessor.c line 114
static void PMTProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details)
{
  struct PMTProcessor_s *state = (struct PMTProcessor_s *)userArg;
  signed int count;
  signed int i;
  struct Service_t **services;
  TSFilterGroupRemoveAllFilters(state->tsgroup);
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    if(!(state->pmthandles[(signed long int)i] == ((struct dvbpsi_decoder_s *)NULL)))
    {
      dvbpsi_DetachPMT(state->pmthandles[(signed long int)i]);
      state->pmthandles[(signed long int)i] = (struct dvbpsi_decoder_s *)(void *)0;
      do
        if(!(state->services[(signed long int)i] == ((struct Service_t *)NULL)))
          ObjectRefDecImpl((void *)state->services[(signed long int)i], "standard/mpeg2/pmtprocessor.c", 129);

      while((_Bool)0);
      state->services[(signed long int)i] = (struct Service_t *)(void *)0;
    }

  services=CacheServicesGet(&count);
  if(count >= 257)
  {
    LogModule(0, PMTPROCESSOR, "Too many services in TS, cannot monitor them all only monitoring %d out of %d\n", 256, count);
    count = 256;
  }

  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    do
      if(!(services[(signed long int)i] == ((struct Service_t *)NULL)))
        ObjectRefIncImpl((void *)services[(signed long int)i], "standard/mpeg2/pmtprocessor.c", 143);

    while((_Bool)0);
    state->services[(signed long int)i] = services[(signed long int)i];
  }
  CacheServicesRelease();
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    state->pmthandles[(signed long int)i]=dvbpsi_AttachPMT((unsigned short int)services[(signed long int)i]->id, PMTHandler, (void *)services[(signed long int)i]);
    TSFilterGroupAddSectionFilter(state->tsgroup, (unsigned short int)services[(signed long int)i]->pmtPID, 0, state->pmthandles[(signed long int)i]);
  }
}

// PMTsRecievedFindOrAdd
// file commands/cmd_scanning.c line 1125
static struct PMTReceived_t * PMTsRecievedFindOrAdd(unsigned short int id)
{
  signed int i = 0;
  for( ; !(i >= 253); i = i + 1)
  {
    if(id == PMTsReceived[(signed long int)i].id)
    {
      LogModule(1, SCANNING, "Found id %d @ %d", id, i);
      return &PMTsReceived[(signed long int)i];
    }

    if((signed int)PMTsReceived[(signed long int)i].id == 0)
    {
      LogModule(1, SCANNING, "Adding id %d @ %d", id, i);
      PMTsReceived[(signed long int)i].id = id;
      return &PMTsReceived[(signed long int)i];
    }

  }
  LogModule(1, SCANNING, "Out of space while adding PMT");
  return (struct PMTReceived_t *)(void *)0;
}

// PSIPProcessorCreate
// file ../include/psipprocessor.h line 29
struct PSIPProcessor_s * PSIPProcessorCreate(struct TSReader_t *reader)
{
  struct PSIPProcessor_s *result;
  if(initCount == 0)
  {
    utf16ToUtf8CD=iconv_open("UTF-8", "UTF-16BE");
    if(!((signed long int)utf16ToUtf8CD == -1l))
      goto __CPROVER_DUMP_L1;

    LogModule(0, PSIPPROCESSOR, "Failed to open iconv to convert UTF16 to UTF8\n");
    return (struct PSIPProcessor_s *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    initCount = initCount + 1;
    if(mgtEvent == ((struct Event_s *)NULL))
    {
      mgtEvent=EventsRegisterEvent(ATSCEventSource, "MGT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);
      sttEvent=EventsRegisterEvent(ATSCEventSource, "STT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);
      vctEvent=EventsRegisterEvent(ATSCEventSource, "VCT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);
    }

    ObjectRegisterClass("PSIPProcessor_t", (unsigned int)sizeof(struct PSIPProcessor_s) /*16ul*/ , (void (*)(void *))(void *)0);
    void *return_value_ObjectCreateImpl_1;
    return_value_ObjectCreateImpl_1=ObjectCreateImpl("PSIPProcessor_t", "standard/atsc/psipprocessor.c", 116);
    result = (struct PSIPProcessor_s *)return_value_ObjectCreateImpl_1;
    if(!(result == ((struct PSIPProcessor_s *)NULL)))
      result->tsgroup=TSReaderCreateFilterGroup(reader, PSIPPROCESSOR, ATSCFilterType, PSIPProcessorFilterEventCallback, (void *)result);

    return result;
  }
}

// PSIPProcessorDestroy
// file ../include/psipprocessor.h line 30
void PSIPProcessorDestroy(struct PSIPProcessor_s *filter)
{
  TSFilterGroupDestroy(filter->tsgroup);
  if(!(filter->demux == ((struct dvbpsi_decoder_s *)NULL)))
    dvbpsi_DetachDemux(filter->demux);

  ObjectRefDecImpl((void *)filter, "standard/atsc/psipprocessor.c", 133);
  initCount = initCount - 1;
  if(initCount == 0)
    iconv_close(utf16ToUtf8CD);

}

// PSIPProcessorFilterEventCallback
// file standard/atsc/psipprocessor.c line 143
static void PSIPProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details)
{
  struct PSIPProcessor_s *state = (struct PSIPProcessor_s *)userArg;
  if(!(state->demux == ((struct dvbpsi_decoder_s *)NULL)))
  {
    TSFilterGroupRemoveSectionFilter(state->tsgroup, (unsigned short int)0x1ffb);
    dvbpsi_DetachDemux(state->demux);
  }

  state->demux=dvbpsi_AttachDemux(SubTableHandler, (void *)state);
  TSFilterGroupAddSectionFilter(state->tsgroup, (unsigned short int)0x1ffb, 1, state->demux);
}

// PacketFilterListAddFilter
// file ts.c line 544
static struct TSPacketFilter_t * PacketFilterListAddFilter(struct TSReader_t *reader, struct TSFilterGroup_t *group, unsigned short int pid, void (*callback)(void *, struct TSFilterGroup_t *, struct TSPacket_t *), void *userArg)
{
  struct TSPacketFilter_t *packetFilter;
  if(reader->packetFilters[(signed long int)pid] == ((struct TSPacketFilter_t *)NULL))
  {
    if(reader->promiscuousMode == (_Bool)0)
    {
      if(!((signed int)pid == 8192))
      {
        signed int p;
        signed int pidCount = 0;
        signed int freePIDCount;
        p = 0;
        for( ; !(p >= 8193); p = p + 1)
          pidCount = pidCount + (reader->packetFilters[(signed long int)p] != (struct TSPacketFilter_t *)(void *)0 ? 1 : 0);
        signed int return_value_DVBDemuxGetMaxFilters_1;
        return_value_DVBDemuxGetMaxFilters_1=DVBDemuxGetMaxFilters(reader->adapter);
        freePIDCount = return_value_DVBDemuxGetMaxFilters_1 - pidCount;
        if(!(reader->activeSectionFilters->count >= 4))
          freePIDCount = freePIDCount - (4 - reader->activeSectionFilters->count);

        if(!(group == ((struct TSFilterGroup_t *)NULL)) && !(freePIDCount >= 1))
          return (struct TSPacketFilter_t *)(void *)0;

        signed int return_value_DVBDemuxAllocateFilter_4;
        return_value_DVBDemuxAllocateFilter_4=DVBDemuxAllocateFilter(reader->adapter, pid);
        if(!(return_value_DVBDemuxAllocateFilter_4 == 0))
        {
          _Bool return_value_DVBDemuxIsHardwareRestricted_3;
          return_value_DVBDemuxIsHardwareRestricted_3=DVBDemuxIsHardwareRestricted(reader->adapter);
          if(!(return_value_DVBDemuxIsHardwareRestricted_3 == (_Bool)0))
          {
            if(group == ((struct TSFilterGroup_t *)NULL))
              return (struct TSPacketFilter_t *)(void *)0;

            if(!(group == ((struct TSFilterGroup_t *)NULL)))
            {
              if(reader->activeSectionFilters->count >= 5)
                SectionFilterListDescheduleOneFilter(reader);

            }

            signed int return_value_DVBDemuxAllocateFilter_2;
            return_value_DVBDemuxAllocateFilter_2=DVBDemuxAllocateFilter(reader->adapter, pid);
            if(!(return_value_DVBDemuxAllocateFilter_2 == 0))
            {
              LogModule(1, TSREADER, "Failed to allocate filter for 0x%04x", pid);
              return (struct TSPacketFilter_t *)(void *)0;
            }

          }

          else
            PromiscusModeEnable(reader, (_Bool)1);
        }

      }

    }

    _Bool return_value_DVBDemuxIsHardwareRestricted_5;
    return_value_DVBDemuxIsHardwareRestricted_5=DVBDemuxIsHardwareRestricted(reader->adapter);
    if(return_value_DVBDemuxIsHardwareRestricted_5 == (_Bool)0)
    {
      if(reader->promiscuousMode == (_Bool)0)
      {
        if((signed int)pid == 8192)
          PromiscusModeEnable(reader, (_Bool)1);

      }

    }

  }

  void *return_value_ObjectCreateImpl_6;
  return_value_ObjectCreateImpl_6=ObjectCreateImpl("TSPacketFilter_t", "ts.c", 605);
  packetFilter = (struct TSPacketFilter_t *)return_value_ObjectCreateImpl_6;
  packetFilter->pid = pid;
  packetFilter->group = group;
  packetFilter->callback = callback;
  packetFilter->userArg = userArg;
  packetFilter->flNext = reader->packetFilters[(signed long int)pid];
  reader->packetFilters[(signed long int)pid] = packetFilter;
  return packetFilter;
}

// PacketFilterListRemoveFilter
// file ts.c line 615
static void PacketFilterListRemoveFilter(struct TSReader_t *reader, struct TSPacketFilter_t *packetFilter)
{
  struct TSPacketFilter_t *cur = (struct TSPacketFilter_t *)(void *)0;
  struct TSPacketFilter_t *prev = (struct TSPacketFilter_t *)(void *)0;
  LogModule(3, TSREADER, "Removing packet filter %p on pid 0x%02x", packetFilter, packetFilter->pid);
  if((signed int)reader->currentlyProcessingPid == (-32769 & (signed int)packetFilter->pid))
  {
    LogModule(3, TSREADER, "Removing packet filter (replaced with NULL)");
    packetFilter->pid = packetFilter->pid | (unsigned short int)0x8000;
  }

  else
  {
    cur = reader->packetFilters[(signed long int)packetFilter->pid];
    for( ; !(cur == ((struct TSPacketFilter_t *)NULL)); cur = cur->flNext)
    {
      if(cur == packetFilter)
        break;

      prev = cur;
    }
    if(cur == packetFilter)
    {
      if(prev == ((struct TSPacketFilter_t *)NULL))
        reader->packetFilters[(signed long int)packetFilter->pid] = cur->flNext;

      else
        prev->flNext = cur->flNext;
    }

    if(reader->packetFilters[(signed long int)packetFilter->pid] == ((struct TSPacketFilter_t *)NULL))
    {
      if(reader->promiscuousMode == (_Bool)0)
      {
        if(!((signed int)packetFilter->pid == 8192))
          DVBDemuxReleaseFilter(reader->adapter, packetFilter->pid);

      }

    }

    ObjectRefDecImpl((void *)packetFilter, "ts.c", 653);
  }
}

// ParseLine
// file commands.c line 439
static void ParseLine(char *line, char **command, char **argument)
{
  signed long int eol = (signed long int)0;
  signed long int eoc = (signed long int)0;
  char *resultCmd = (char *)(void *)0;
  char *resultArg = (char *)(void *)0;
  _Bool tmp_if_expr_2;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    if(!(*line == 0))
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      tmp_if_expr_2 = ((signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*line] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    line = line + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  const unsigned short int **return_value___ctype_b_loc_5;
  _Bool tmp_if_expr_8;
  const unsigned short int **return_value___ctype_b_loc_7;
  if(!((signed int)*line == 35))
  {
    eol = (signed long int)0;
    do
    {
      if(!(line[eol] == 0))
        tmp_if_expr_3 = (signed int)line[eol] != 35 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      eol = eol + 1l;
    }
    while((_Bool)1);
    eoc = (signed long int)0;
    for( ; !(line[eoc] == 0) && !(eoc >= eol); eoc = eoc + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc_4;
      return_value___ctype_b_loc_4=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)line[eoc]]) == 0))
        break;

    }
    if(!(eoc == eol))
    {
      signed long int argStart;
      signed long int argEnd;
      signed long int argLen;
      argStart = eoc + (signed long int)1;
      do
      {
        if(!(argStart >= eol))
        {
          return_value___ctype_b_loc_5=__ctype_b_loc();
          tmp_if_expr_6 = ((signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)line[argStart]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        if(!tmp_if_expr_6)
          break;

        argStart = argStart + 1l;
      }
      while((_Bool)1);
      argEnd = eol - (signed long int)1;
      do
      {
        if(!(argStart >= argEnd))
        {
          return_value___ctype_b_loc_7=__ctype_b_loc();
          tmp_if_expr_8 = ((signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)line[argEnd]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_8 = (_Bool)0;
        if(!tmp_if_expr_8)
          break;

        argEnd = argEnd - 1l;
      }
      while((_Bool)1);
      argLen = (argEnd - argStart) + (signed long int)1;
      if(argLen >= 1l)
      {
        void *return_value_malloc_9;
        return_value_malloc_9=malloc((unsigned long int)(argLen + (signed long int)1));
        resultArg = (char *)return_value_malloc_9;
        if(!(resultArg == ((char *)NULL)))
        {
          strncpy(resultArg, line + argStart, (unsigned long int)argLen);
          resultArg[argLen] = (char)0;
        }

      }

    }

    if(!(eoc == 0l))
    {
      void *return_value_malloc_10;
      return_value_malloc_10=malloc((unsigned long int)(eoc + (signed long int)1));
      resultCmd = (char *)return_value_malloc_10;
      if(!(resultCmd == ((char *)NULL)))
      {
        strncpy(resultCmd, line, (unsigned long int)eoc);
        resultCmd[eoc] = (char)0;
      }

    }

    *command = resultCmd;
    *argument = resultArg;
  }

}

// ParseMuxListFrequencies
// file commands/cmd_scanning.c line 1436
static struct MuxFrequencies_s * ParseMuxListFrequencies(struct MultiplexList_s *muxList)
{
  signed int i;
  struct MuxFrequencies_s *result;
  struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_1;
  return_value_ObjectCollectionCreateImpl_1=ObjectCollectionCreateImpl("MuxFrequencies_t", (unsigned int)muxList->nrofMultiplexes, "commands/cmd_scanning.c", 1439);
  result = (struct MuxFrequencies_s *)return_value_ObjectCollectionCreateImpl_1;
  _Bool tmp_if_expr_6;
  if(!(result == ((struct MuxFrequencies_s *)NULL)))
  {
    i = 0;
    for( ; !(i >= muxList->nrofMultiplexes); i = i + 1)
    {
      struct yaml_document_s document;
      memset((void *)&document, 0, sizeof(struct yaml_document_s) /*104ul*/ );
      signed int return_value_YamlUtils_Parse_7;
      return_value_YamlUtils_Parse_7=YamlUtils_Parse(muxList->multiplexes[(signed long int)i]->tuningParams, &document);
      if(!(return_value_YamlUtils_Parse_7 == 0))
      {
        struct yaml_node_s *node;
        struct yaml_node_s *return_value_yaml_document_get_root_node_2;
        return_value_yaml_document_get_root_node_2=yaml_document_get_root_node(&document);
        node=YamlUtils_MappingFind(&document, return_value_yaml_document_get_root_node_2, "Frequency");
        if(!(node == ((struct yaml_node_s *)NULL)))
        {
          if((signed int)node->type == YAML_SCALAR_NODE)
          {
            unsigned long int return_value_strtoul_3;
            return_value_strtoul_3=strtoul((const char *)node->data.scalar.value, (char ** restrict )(void *)0, 10);
            result->frequencies[(signed long int)i].frequency = (unsigned int)return_value_strtoul_3;
          }

        }

        if((signed int)muxList->multiplexes[(signed long int)i]->deliverySystem == DELSYS_DVBS)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)muxList->multiplexes[(signed long int)i]->deliverySystem == DELSYS_DVBS2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          struct yaml_node_s *return_value_yaml_document_get_root_node_4;
          return_value_yaml_document_get_root_node_4=yaml_document_get_root_node(&document);
          node=YamlUtils_MappingFind(&document, return_value_yaml_document_get_root_node_4, "Polarisation");
          if(!(node == ((struct yaml_node_s *)NULL)))
          {
            if((signed int)node->type == YAML_SCALAR_NODE)
              strncpy(result->frequencies[(signed long int)i].polarisation, (const char *)node->data.scalar.value, sizeof(char [11l]) /*11ul*/ );

          }

          struct yaml_node_s *return_value_yaml_document_get_root_node_5;
          return_value_yaml_document_get_root_node_5=yaml_document_get_root_node(&document);
          node=YamlUtils_MappingFind(&document, return_value_yaml_document_get_root_node_5, "Satellite Number");
          if(!(node == ((struct yaml_node_s *)NULL)))
          {
            if((signed int)node->type == YAML_SCALAR_NODE)
              result->frequencies[(signed long int)i].satNumber=atoi((const char *)node->data.scalar.value);

          }

        }

      }

      yaml_document_delete(&document);
    }
  }

  return result;
}

// PluginManagerDeInit
// file ../include/pluginmgr.h line 27
void PluginManagerDeInit(void)
{
  LogModule(3, PLUGINMANAGER, "Plugin Manager Deinitialising...\n");
  CommandUnRegisterCommands(PluginManagerCommands);
  ListFree(PluginsList, (void (*)(void *))PluginManagerUnloadPlugin);
  lt_dlexit();
  LogModule(3, PLUGINMANAGER, "Plugin Manager Deinitialised\n");
}

// PluginManagerInit
// file ../include/pluginmgr.h line 26
signed int PluginManagerInit(void)
{
  struct ListIterator_s iterator;
  unsigned char isSuitableMask;
  lt_dlinit();
  PluginsList=ListCreate();
  LogModule(3, PLUGINMANAGER, "Plugin Manager Initialising...\n");
  lt_dlsetsearchpath("/usr/lib/dvbstreamer/plugins");
  lt_dlforeachfile("/usr/lib/dvbstreamer/plugins", PluginManagerLoadPlugin, (void *)0);
  _Bool return_value_MainIsDVB_1;
  return_value_MainIsDVB_1=MainIsDVB();
  isSuitableMask = (unsigned char)(return_value_MainIsDVB_1 != (_Bool)0 ? 0x01 : 0x02);
  iterator.current = PluginsList->head;
  iterator.list = PluginsList;
  struct ListEntry_s *tmp_if_expr_2;
  while(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct PluginEntry_t *entry = (struct PluginEntry_t *)iterator.current->data;
    if(!((entry->pluginInterface->pluginFor & (unsigned int)isSuitableMask) == 0u))
    {
      LogModule(3, PLUGINMANAGER, "Installing %s\n", entry->pluginInterface->name);
      PluginManagerInstallPlugin(entry->pluginInterface);
      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_2 = iterator.current->next;

      else
        tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
      iterator.current = tmp_if_expr_2;
    }

    else
    {
      LogModule(3, PLUGINMANAGER, "Not installing %s as not suitable.\n", entry->pluginInterface->name);
      lt_dlclose(entry->handle);
      free((void *)entry);
      ListRemoveCurrent(&iterator);
    }
  }
  CommandRegisterCommands(PluginManagerCommands);
  LogModule(3, PLUGINMANAGER, "Plugin Manager Initialised\n");
  return 0;
}

// PluginManagerInstallPlugin
// file pluginmgr.c line 240
static void PluginManagerInstallPlugin(struct Plugin_t *pluginInterface)
{
  signed int i;
  if(!(pluginInterface->commands == ((struct Command_t *)NULL)))
    CommandRegisterCommands(pluginInterface->commands);

  if(!(pluginInterface->features == ((struct PluginFeature_t *)NULL)))
  {
    i = 0;
    for( ; !((pluginInterface->features + (signed long int)i)->type == 0x00); i = i + 1)
    {
      struct PluginFeature_t *feature = &pluginInterface->features[(signed long int)i];
      switch(feature->type)
      {
        case 0x01:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed event listener (%s)\n", pluginInterface->name, feature->details.eventDetails.name);
          EventsRegisterListenerByName(feature->details.eventDetails.name, feature->details.eventDetails.callback, feature->details.eventDetails.arg);
          break;
        }
        case 0x02:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed PAT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("MPEG2.PAT", TableEventCallback, (void *)feature->details.patCB);
          break;
        }
        case 0x03:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed PMT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("MPEG2.PMT", TableEventCallback, (void *)feature->details.pmtCB);
          break;
        }
        case 0x04:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed Delivery method.\n", pluginInterface->name);
          DeliveryMethodManagerRegister(&feature->details.dmHandler);
          break;
        }
        case 0x05:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed SDT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("DVB.SDT", TableEventCallback, (void *)feature->details.sdtCB);
          break;
        }
        case 0x06:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed NIT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("DVB.NIT", TableEventCallback, (void *)feature->details.nitCB);
          break;
        }
        case 0x07:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed TDT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("DVB.TDT", TableEventCallback, (void *)feature->details.tdtCB);
          break;
        }
        case 0x08:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed MGT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("ATSC.MGT", TableEventCallback, (void *)feature->details.mgtCB);
          break;
        }
        case 0x09:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed STT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("ATSC.STT", TableEventCallback, (void *)feature->details.sttCB);
          break;
        }
        case 0x0A:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Installed VCT processor.\n", pluginInterface->name);
          EventsRegisterListenerByName("ATSC.VCT", TableEventCallback, (void *)feature->details.vctCB);
          break;
        }
        case 0xFF:
          feature->details.installCB((_Bool)1);
      }
    }
  }

}

// PluginManagerLoadPlugin
// file pluginmgr.c line 164
static signed int PluginManagerLoadPlugin(const char *filename, void *userarg)
{
  struct lt__handle *handle;
  handle=lt_dlopenext(filename);
  LogModule(4, PLUGINMANAGER, "Attempting to load %s\n", filename);
  struct ListEntry_s *tmp_if_expr_2;
  if(!(handle == ((struct lt__handle *)NULL)))
  {
    struct Plugin_t *pluginInterface;
    void *return_value_lt_dlsym_1;
    return_value_lt_dlsym_1=lt_dlsym(handle, "PluginInterface");
    pluginInterface = (struct Plugin_t *)return_value_lt_dlsym_1;
    if(!(pluginInterface == ((struct Plugin_t *)NULL)))
    {
      struct ListIterator_s iterator;
      struct PluginEntry_t *entry = (struct PluginEntry_t *)(void *)0;
      _Bool addPlugin = (_Bool)1;
      if(!(pluginInterface->requiredVersion == 33619969u))
        addPlugin = (_Bool)0;

      if(!(addPlugin == (_Bool)0))
      {
        iterator.current = PluginsList->head;
        iterator.list = PluginsList;
        for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_2)
        {
          struct PluginEntry_t *PluginManagerLoadPlugin__1__1__1__2__1__1__entry = (struct PluginEntry_t *)iterator.current->data;
          signed int return_value_strcmp_3;
          return_value_strcmp_3=strcmp(pluginInterface->name, PluginManagerLoadPlugin__1__1__1__2__1__1__entry->pluginInterface->name);
          if(return_value_strcmp_3 == 0)
          {
            LogModule(4, PLUGINMANAGER, "Plugin already loaded, igoring this instance.\n");
            addPlugin = (_Bool)0;
            break;
          }

          if(!(iterator.current == ((struct ListEntry_s *)NULL)))
            tmp_if_expr_2 = iterator.current->next;

          else
            tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
        }
      }

      if(!(addPlugin == (_Bool)0))
      {
        void *return_value_calloc_4;
        return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct PluginEntry_t) /*16ul*/ );
        entry = (struct PluginEntry_t *)return_value_calloc_4;
        if(!(entry == ((struct PluginEntry_t *)NULL)))
        {
          entry->pluginInterface = pluginInterface;
          entry->handle = handle;
          _Bool return_value_ListAdd_5;
          return_value_ListAdd_5=ListAdd(PluginsList, (void *)entry);
          if(!(return_value_ListAdd_5 == (_Bool)0))
          {
            LogModule(2, PLUGINMANAGER, "Loaded plugin %s\n", pluginInterface->name);
            return 0;
          }

          free((void *)entry);
        }

      }

    }

    else
      LogModule(4, PLUGINMANAGER, "PluginInterface not found for %s.\n", filename);
    lt_dlclose(handle);
  }

  else
  {
    const char *return_value_lt_dlerror_6;
    return_value_lt_dlerror_6=lt_dlerror();
    LogModule(4, PLUGINMANAGER, "Failed to open plugin %s - reason %s\n", filename, return_value_lt_dlerror_6);
  }
  return 0;
}

// PluginManagerLsPlugins
// file pluginmgr.c line 375
static void PluginManagerLsPlugins(signed int argc, char **argv)
{
  struct ListIterator_s iterator;
  iterator.current = PluginsList->head;
  iterator.list = PluginsList;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct PluginEntry_t *entry = (struct PluginEntry_t *)iterator.current->data;
    CommandPrintf("%s\n", entry->pluginInterface->name);
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
}

// PluginManagerPluginInfo
// file pluginmgr.c line 385
static void PluginManagerPluginInfo(signed int argc, char **argv)
{
  struct ListIterator_s iterator;
  struct Plugin_t *pluginInterface = (struct Plugin_t *)(void *)0;
  iterator.current = PluginsList->head;
  iterator.list = PluginsList;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct PluginEntry_t *entry = (struct PluginEntry_t *)iterator.current->data;
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(entry->pluginInterface->name, argv[(signed long int)0]);
    if(return_value_strcmp_2 == 0)
    {
      pluginInterface = entry->pluginInterface;
      break;
    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  if(!(pluginInterface == ((struct Plugin_t *)NULL)))
  {
    signed int i;
    char *pluginFor = "<Invalid>";
    CommandPrintf("Name        : %s\nVersion     : %s\nAuthor      : %s\nDescription :\n%s\n\n", pluginInterface->name, pluginInterface->version, pluginInterface->author, pluginInterface->description);
    CommandPrintf("Plugin Details\n--------------\n");
    switch(pluginInterface->pluginFor)
    {
      case (unsigned int)0x01:
      {
        pluginFor = "DVB";
        break;
      }
      case (unsigned int)0x02:
      {
        pluginFor = "ATSC";
        break;
      }
      case (unsigned int)0xff:
        pluginFor = "All transport types";
    }
    CommandPrintf("\nPlugin For : %s\n", pluginFor);
    CommandPrintf("\nFeatures   :\n");
    if(!(pluginInterface->features == ((struct PluginFeature_t *)NULL)))
    {
      i = 0;
      for( ; !((pluginInterface->features + (signed long int)i)->type == 0x00); i = i + 1)
      {
        char *name;
        name=FindPluginFeatureName((pluginInterface->features + (signed long int)i)->type);
        if(!(name == ((char *)NULL)))
          CommandPrintf("\t%s\n", name);

        else
          CommandPrintf("\t<Invalid Feature type %d>\n", (pluginInterface->features + (signed long int)i)->type);
      }
    }

    else
      CommandPrintf("\t<None>\n");
    CommandPrintf("\nCommands   :\n");
    if(!(pluginInterface->commands == ((struct Command_t *)NULL)))
    {
      i = 0;
      for( ; !((pluginInterface->commands + (signed long int)i)->command == ((char *)NULL)); i = i + 1)
        CommandPrintf("\t%s\n", (pluginInterface->commands + (signed long int)i)->command);
    }

    else
      CommandPrintf("\t<None>\n");
    CommandPrintf("\n");
  }

  else
    CommandPrintf("Plugin \"%s\" not found.\n", argv[(signed long int)0]);
}

// PluginManagerUninstallPlugin
// file pluginmgr.c line 308
static void PluginManagerUninstallPlugin(struct Plugin_t *pluginInterface)
{
  signed int i;
  if(!(pluginInterface->commands == ((struct Command_t *)NULL)))
    CommandUnRegisterCommands(pluginInterface->commands);

  if(!(pluginInterface->features == ((struct PluginFeature_t *)NULL)))
  {
    i = 0;
    for( ; !((pluginInterface->features + (signed long int)i)->type == 0x00); i = i + 1)
    {
      struct PluginFeature_t *feature = &pluginInterface->features[(signed long int)i];
      switch(feature->type)
      {
        case 0x01:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled event listener (%s)\n", pluginInterface->name, feature->details.eventDetails.name);
          EventsUnregisterListenerByName(feature->details.eventDetails.name, feature->details.eventDetails.callback, feature->details.eventDetails.arg);
          break;
        }
        case 0x02:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled PAT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("MPEG2.PAT", TableEventCallback, (void *)feature->details.patCB);
          break;
        }
        case 0x03:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled PMT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("MPEG2.PMT", TableEventCallback, (void *)feature->details.pmtCB);
          break;
        }
        case 0x04:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled Delivery method.\n", pluginInterface->name);
          DeliveryMethodManagerRegister(&feature->details.dmHandler);
          break;
        }
        case 0x05:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled SDT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("DVB.SDT", TableEventCallback, (void *)feature->details.sdtCB);
          break;
        }
        case 0x06:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled NIT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("DVB.NIT", TableEventCallback, (void *)feature->details.nitCB);
          break;
        }
        case 0x07:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled TDT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("DVB.TDT", TableEventCallback, (void *)feature->details.tdtCB);
          break;
        }
        case 0x08:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled MGT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("ATSC.MGT", TableEventCallback, (void *)feature->details.mgtCB);
          break;
        }
        case 0x09:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled STT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("ATSC.STT", TableEventCallback, (void *)feature->details.sttCB);
          break;
        }
        case 0x0A:
        {
          LogModule(4, PLUGINMANAGER, "plugin %s: Uninstalled VCT processor.\n", pluginInterface->name);
          EventsUnregisterListenerByName("ATSC.VCT", TableEventCallback, (void *)feature->details.vctCB);
          break;
        }
        case 0xFF:
          feature->details.installCB((_Bool)0);
      }
    }
  }

}

// PluginManagerUnloadPlugin
// file pluginmgr.c line 229
static void PluginManagerUnloadPlugin(struct PluginEntry_t *entry)
{
  LogModule(3, PLUGINMANAGER, "Uninstalling %s\n", entry->pluginInterface->name);
  PluginManagerUninstallPlugin(entry->pluginInterface);
  if(!(entry->handle == ((struct lt__handle *)NULL)))
    lt_dlclose(entry->handle);

  free((void *)entry);
}

// PrintResponse
// file remoteintf.c line 410
static void PrintResponse(struct _IO_FILE *fp, unsigned short int errno, char *msg)
{
  fprintf(fp, "%s%d %s\n", (const void *)responselineStart, errno, msg);
  fflush(fp);
}

// PrintXmlified
// file commands/cmd_epg.c line 129
static void PrintXmlified(char *text)
{
  char buffer[256l];
  char temp[10l];
  signed int bufferIndex = 0;
  signed int i;
  signed int utf8CharLen;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  len = (signed int)return_value_strlen_1;
  buffer[(signed long int)0] = (char)0;
  i = 0;
  while(!(i >= len))
  {
    unsigned int ch;
    ch=UTF8_nextchar(text, &i);
    switch(ch)
    {
      case (unsigned int)9:

      case (unsigned int)10:

      case (unsigned int)61:
      {
        temp[(signed long int)0] = (char)ch;
        temp[(signed long int)1] = (char)0;
        break;
      }
      case (unsigned int)38:
      {
        strcpy(temp, "&amp;");
        break;
      }
      case (unsigned int)60:
      {
        strcpy(temp, "&lt;");
        break;
      }
      case (unsigned int)62:
      {
        strcpy(temp, "&gt;");
        break;
      }
      case (unsigned int)0x007F:
        fprintf(stderr, "Illegal char %04x\n", i);
      default:
      {
        utf8CharLen=UTF8_wc_toutf8(temp, ch);
        temp[(signed long int)utf8CharLen] = (char)0;
      }
    }
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(temp);
    if(return_value_strlen_2 + (unsigned long int)bufferIndex >= 255ul)
    {
      CommandPrintf("%s", (const void *)buffer);
      bufferIndex = 0;
      buffer[(signed long int)0] = (char)0;
    }

    strcat(buffer, temp);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(temp);
    bufferIndex = bufferIndex + (signed int)return_value_strlen_3;
  }
  if(!(bufferIndex == 0))
    CommandPrintf("%s", (const void *)buffer);

}

// ProcessCommand
// file commands.c line 363
static _Bool ProcessCommand(struct CommandContext_t *context, char *command, char *argument)
{
  char **argv = (char **)(void *)0;
  signed int argc = 0;
  _Bool commandFound = (_Bool)0;
  struct ListIterator_s iterator;
  struct Command_t *commandInfo = (struct Command_t *)(void *)0;
  pthread_mutex_lock(&CommandMutex);
  if(!(context->commands == ((struct Command_t *)NULL)))
    commandInfo=FindCommand(context->commands, command);

  struct ListEntry_s *tmp_if_expr_1;
  if(commandInfo == ((struct Command_t *)NULL))
  {
    iterator.current = CommandsList->head;
    iterator.list = CommandsList;
    for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
    {
      struct Command_t *commands = (struct Command_t *)iterator.current->data;
      commandInfo=FindCommand(commands, command);
      if(!(commandInfo == ((struct Command_t *)NULL)))
        break;

      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_1 = iterator.current->next;

      else
        tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
    }
  }

  pthread_mutex_unlock(&CommandMutex);
  _Bool tmp_if_expr_3;
  if(!(commandInfo == ((struct Command_t *)NULL)))
  {
    if(!(argument == ((char *)NULL)))
      argv=Tokenise(argument, &argc);

    else
    {
      argc = 0;
      void *return_value_calloc_2;
      return_value_calloc_2=calloc(sizeof(char *) /*8ul*/ , (unsigned long int)1);
      argv = (char **)return_value_calloc_2;
      argv[(signed long int)0] = (char *)(void *)0;
    }
    if(argc >= commandInfo->minArgs)
      tmp_if_expr_3 = argc <= commandInfo->maxArgs ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      commandInfo->commandfunc(argc, argv);

    else
      do
      {
        struct CommandContext_t *ProcessCommand__1__3__4__1__context;
        ProcessCommand__1__3__4__1__context=CommandContextGet();
        ProcessCommand__1__3__4__1__context->errorNumber = (unsigned short int)0x0003;
        snprintf(ProcessCommand__1__3__4__1__context->errorMessage, (unsigned long int)256, "Incorrect number of arguments!");
      }
      while((_Bool)0);
    for( ; argc >= 1; argc = argc - 1)
      free((void *)argv[(signed long int)(argc - 1)]);
    free((void *)argv);
    commandFound = (_Bool)1;
  }

  return commandFound;
}

// ProcessMGT
// file standard/atsc/psipprocessor.c line 187
static void ProcessMGT(void *arg, struct dvbpsi_atsc_mgt_s *newMGT)
{
  struct dvbpsi_atsc_mgt_table_s *table;
  struct dvbpsi_descriptor_s *descriptor;
  struct Multiplex_s *current;
  current=TuningCurrentMultiplexGet();
  if(current->networkId == -1)
    CacheUpdateNetworkId(current, current->uid & 0xffff);

  do
    if(!(current == ((struct Multiplex_s *)NULL)))
      ObjectRefDecImpl((void *)current, "standard/atsc/psipprocessor.c", 196);

  while((_Bool)0);
  LogModule(3, PSIPPROCESSOR, "New MGT Received! Version %d Protocol %d\n", newMGT->i_version, newMGT->i_protocol);
  table = newMGT->p_first_table;
  for( ; !(table == ((struct dvbpsi_atsc_mgt_table_s *)NULL)); table = table->p_next)
  {
    LogModule(3, PSIPPROCESSOR, "\tType=%d PID=%d Version=%d number bytes=%d\n", table->i_type, table->i_pid, table->i_version, table->i_number_bytes);
    LogModule(3, PSIPPROCESSOR, "\tStart of Descriptors\n");
    descriptor = table->p_first_descriptor;
    for( ; !(descriptor == ((struct dvbpsi_descriptor_s *)NULL)); descriptor = descriptor->p_next)
      DumpDescriptor("\t\t\t", descriptor);
    LogModule(3, PSIPPROCESSOR, "\tEnd of Descriptors\n");
  }
  LogModule(3, PSIPPROCESSOR, "\tStart of Descriptors\n");
  descriptor = newMGT->p_first_descriptor;
  for( ; !(descriptor == ((struct dvbpsi_descriptor_s *)NULL)); descriptor = descriptor->p_next)
    DumpDescriptor("\t\t", descriptor);
  LogModule(3, PSIPPROCESSOR, "\tEnd of Descriptors\n");
  EventsFireEventListeners(mgtEvent, (void *)newMGT);
  ObjectRefDecImpl((void *)newMGT, "standard/atsc/psipprocessor.c", 217);
}

// ProcessPacket
// file ts.c line 928
static void ProcessPacket(struct TSReader_t *reader, struct TSPacket_t *packet)
{
  SendToPacketFilters(reader, (unsigned short int)(((signed int)packet->header[(signed long int)1] & 0x1f) << 8 | (signed int)packet->header[(signed long int)2] & 0xff), packet);
  SendToPacketFilters(reader, (unsigned short int)8192, packet);
  reader->totalPackets = reader->totalPackets + 1ull;
}

// ProcessSTT
// file standard/atsc/psipprocessor.c line 220
static void ProcessSTT(void *arg, struct dvbpsi_atsc_stt_s *newSTT)
{
  LogModule(4, PSIPPROCESSOR, "New STT Received! Protocol %d GPS Time =%lu GPS->UTC Offset = %u \n", newSTT->i_protocol, newSTT->i_system_time, newSTT->i_gps_utc_offset);
  EventsFireEventListeners(sttEvent, (void *)newSTT);
  ObjectRefDecImpl((void *)newSTT, "standard/atsc/psipprocessor.c", 226);
}

// ProcessTransponderList
// file commands/cmd_scanning.c line 1503
static void ProcessTransponderList(void)
{
  struct Multiplex_s *mux;
  struct ListIterator_s iterator;
  struct MultiplexList_s *muxList;
  muxList=MultiplexGetAll();
  struct MuxFrequencies_s *muxFreqList;
  muxFreqList=ParseMuxListFrequencies(muxList);
  struct ListEntry_s *tmp_if_expr_1;
  if(transponderList->count >= 1)
  {
    iterator.current = transponderList->head;
    iterator.list = transponderList;
    for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
    {
      struct TransponderEntry_s *entry = (struct TransponderEntry_s *)iterator.current->data;
      mux=MultiplexFindId(entry->netId, entry->tsId);
      if(!(mux == ((struct Multiplex_s *)NULL)))
        do
          if(!(mux == ((struct Multiplex_s *)NULL)))
            ObjectRefDecImpl((void *)mux, "commands/cmd_scanning.c", 1519);

        while((_Bool)0);

      else
      {
        mux=FindMultiplexFrequency(muxList, muxFreqList, (unsigned long int)entry->frequency, deliverySystemRanges[(signed long int)entry->delSys], entry->polarisation, DVBSSatNumber);
        if(!(mux == ((struct Multiplex_s *)NULL)))
          ScanListAddEntry(entry->delSys, mux, (struct TuningParamDocs_s *)(void *)0);

        else
        {
          struct TuningParamDocs_s *docs;
          struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_2;
          return_value_ObjectCollectionCreateImpl_2=ObjectCollectionCreateImpl("TuningParamDocs_t", (unsigned int)1, "commands/cmd_scanning.c", 1532);
          docs = (struct TuningParamDocs_s *)return_value_ObjectCollectionCreateImpl_2;
          docs->docs[(signed long int)0] = entry->tuningParams;
          entry->tuningParams = (char *)(void *)0;
          ScanListAddEntry(entry->delSys, (struct Multiplex_s *)(void *)0, docs);
        }
      }
      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_1 = iterator.current->next;

      else
        tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
    }
  }

  ObjectRefDecImpl((void *)muxList, "commands/cmd_scanning.c", 1540);
  ObjectRefDecImpl((void *)muxFreqList, "commands/cmd_scanning.c", 1541);
}

// ProcessVCT
// file standard/atsc/psipprocessor.c line 229
static void ProcessVCT(void *arg, struct dvbpsi_atsc_vct_s *newVCT)
{
  struct dvbpsi_descriptor_s *descriptor;
  struct dvbpsi_atsc_vct_channel_s *channel;
  signed int count;
  signed int i;
  struct Service_t **services;
  struct TSReader_t *tsReader = ((struct TSFilterGroup_t *)arg)->tsReader;
  LogModule(3, PSIPPROCESSOR, "New VCT Recieved! Version %d Protocol %d Cable VCT? %s TS Id = 0x%04x\n", newVCT->i_version, newVCT->i_protocol, newVCT->b_cable_vct != 0 ? "Yes" : "No", newVCT->i_ts_id);
  channel = newVCT->p_first_channel;
  for( ; !(channel == ((struct dvbpsi_atsc_vct_channel_s *)NULL)); channel = channel->p_next)
  {
    char serviceName[53l];
    char *inbuf;
    unsigned long int inbytes;
    char *outbuf;
    unsigned long int outbytes;
    signed int ret;
    sprintf(serviceName, "%d-%d ", channel->i_major_number, channel->i_minor_number);
    inbuf = (char *)channel->i_short_name;
    inbytes = (unsigned long int)14;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(serviceName);
    outbuf = serviceName + (signed long int)return_value_strlen_1;
    outbytes = sizeof(char [53l]) /*53ul*/  - (unsigned long int)10;
    unsigned long int return_value_iconv_2;
    return_value_iconv_2=iconv(utf16ToUtf8CD, (char **)&inbuf, &inbytes, &outbuf, &outbytes);
    ret = (signed int)return_value_iconv_2;
    if(ret == -1)
      LogModule(0, PSIPPROCESSOR, "Failed to convert service name\n");

    else
    {
      struct Service_t *service;
      service=CacheServiceFindId((signed int)channel->i_program_number);
      *outbuf = (char)0;
      if(service == ((struct Service_t *)NULL))
        service=CacheServiceAdd((signed int)channel->i_program_number, (signed int)channel->i_source_id);

      else
        CacheServiceSeen(service, (_Bool)1, (_Bool)0);
      if(!(service->source == (signed int)channel->i_source_id))
        CacheUpdateServiceSource(service, channel->i_source_id);

      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(service->name, serviceName);
      if(!(return_value_strcmp_3 == 0))
        CacheUpdateServiceName(service, serviceName);

      LogModule(3, PSIPPROCESSOR, "\t%s\n", (const void *)serviceName);
      LogModule(3, PSIPPROCESSOR, "\t\tTS ID          = %04x\n", channel->i_channel_tsid);
      LogModule(3, PSIPPROCESSOR, "\t\tProgram number = %04x\n", channel->i_program_number);
      LogModule(3, PSIPPROCESSOR, "\t\tSource id      = %04x\n", channel->i_source_id);
      LogModule(3, PSIPPROCESSOR, "\t\tService type   = %d\n", channel->i_service_type);
      do
        if(!(service == ((struct Service_t *)NULL)))
          ObjectRefDecImpl((void *)service, "standard/atsc/psipprocessor.c", 291);

      while((_Bool)0);
    }
    LogModule(3, PSIPPROCESSOR, "\tStart of Descriptors\n");
    descriptor = channel->p_first_descriptor;
    for( ; !(descriptor == ((struct dvbpsi_descriptor_s *)NULL)); descriptor = descriptor->p_next)
    {
      DumpDescriptor("\t\t\t", descriptor);
      if((signed int)descriptor->i_tag == 0xa0)
      {
        struct ATSCMultipleStrings_s *strings;
        strings=ATSCMultipleStringsConvert(descriptor->p_data, descriptor->i_length);
        signed int s = 0;
        for( ; !(s >= strings->number_of_strings); s = s + 1)
          LogModule(3, PSIPPROCESSOR, "\t\t\t\t%d (%c%c%c): %s\n", s, (strings->strings + (signed long int)s)->lang[(signed long int)0], (strings->strings + (signed long int)s)->lang[(signed long int)1], (strings->strings + (signed long int)s)->lang[(signed long int)2], (strings->strings + (signed long int)s)->text);
        ObjectRefDecImpl((void *)strings, "standard/atsc/psipprocessor.c", 308);
      }

    }
    LogModule(3, PSIPPROCESSOR, "\tEnd of Descriptors\n");
  }
  descriptor = newVCT->p_first_descriptor;
  for( ; !(descriptor == ((struct dvbpsi_descriptor_s *)NULL)); descriptor = descriptor->p_next)
    DumpDescriptor("\t\t", descriptor);
  LogModule(3, PSIPPROCESSOR, "\tEnd of Descriptors\n");
  services=CacheServicesGet(&count);
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    _Bool found = (_Bool)0;
    channel = newVCT->p_first_channel;
    for( ; !(channel == ((struct dvbpsi_atsc_vct_channel_s *)NULL)); channel = channel->p_next)
      if(services[(signed long int)i]->id == (signed int)channel->i_program_number)
      {
        found = (_Bool)1;
        break;
      }

    if(found == (_Bool)0)
    {
      LogModule(3, PSIPPROCESSOR, "Channel not found in VCT while checking cache, deleting 0x%04x (%s)\n", services[(signed long int)i]->id, services[(signed long int)i]->name);
      _Bool return_value_CacheServiceSeen_4;
      return_value_CacheServiceSeen_4=CacheServiceSeen(services[(signed long int)i], (_Bool)0, (_Bool)0);
      if(return_value_CacheServiceSeen_4 == (_Bool)0)
      {
        CacheServicesRelease();
        CacheServiceDelete(services[(signed long int)i]);
        services=CacheServicesGet(&count);
        i = i - 1;
        tsReader->tsStructureChanged = (_Bool)1;
      }

    }

  }
  CacheServicesRelease();
  EventsFireEventListeners(vctEvent, (void *)newVCT);
  ObjectRefDecImpl((void *)newVCT, "standard/atsc/psipprocessor.c", 351);
}

// ProgramInfoDestructor
// file pids.c line 290
static void ProgramInfoDestructor(void *ptr)
{
  struct ProgramInfo_s *info = (struct ProgramInfo_s *)ptr;
  if(!(info->descriptors == ((struct dvbpsi_descriptor_s *)NULL)))
    dvbpsi_DeleteDescriptors(info->descriptors);

  ObjectRefDecImpl((void *)info->streamInfoList, "pids.c", 297);
}

// ProgramInfoGet
// file pids.c line 93
struct ProgramInfo_s * ProgramInfoGet(struct Service_t *service)
{
  signed int count;
  count=PIDListCount(service);
  struct ProgramInfo_s *result = (struct ProgramInfo_s *)(void *)0;
  if(count >= 1)
  {
    result=ProgramInfoNew(count);
    if(!(result == ((struct ProgramInfo_s *)NULL)))
    {
      signed int i;
      signed int rc;
      struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
      do
      {
        char *sqlstring;
        sqlstring=sqlite3_mprintf("SELECT pid,type,descriptors FROM PIDs WHERE mplexuid=%d AND serviceid=%d AND pid<8192;", service->multiplexUID, service->id);
        if(!(sqlstring == ((char *)NULL)))
        {
          struct sqlite3 *return_value_DBaseConnectionGet_1;
          return_value_DBaseConnectionGet_1=DBaseConnectionGet();
          rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
          sqlite3_free((void *)sqlstring);
        }

        else
          rc = 7;
      }
      while((_Bool)0);
      if(rc == 0)
      {
        i = 0;
        for( ; !(i >= count); i = i + 1)
        {
          rc=sqlite3_step(stmt);
          if(rc == 100)
          {
            result->streamInfoList->streams[(signed long int)i].pid=sqlite3_column_int(stmt, 0);
            result->streamInfoList->streams[(signed long int)i].type=sqlite3_column_int(stmt, 1);
            const void *return_value_sqlite3_column_blob_2;
            return_value_sqlite3_column_blob_2=sqlite3_column_blob(stmt, 2);
            signed int return_value_sqlite3_column_bytes_3;
            return_value_sqlite3_column_bytes_3=sqlite3_column_bytes(stmt, 2);
            result->streamInfoList->streams[(signed long int)i].descriptors=UnRollDescriptors((unsigned char *)return_value_sqlite3_column_blob_2, return_value_sqlite3_column_bytes_3);
          }

          else
            break;
        }
        rc=sqlite3_finalize(stmt);
        do
        {
          char *ProgramInfoGet__1__1__1__2__2__sqlstring;
          ProgramInfoGet__1__1__1__2__2__sqlstring=sqlite3_mprintf("SELECT pid,descriptors FROM PIDs WHERE mplexuid=%d AND serviceid=%d AND pid>%d;", service->multiplexUID, service->id, 0x8000);
          if(!(ProgramInfoGet__1__1__1__2__2__sqlstring == ((char *)NULL)))
          {
            struct sqlite3 *return_value_DBaseConnectionGet_4;
            return_value_DBaseConnectionGet_4=DBaseConnectionGet();
            rc=sqlite3_prepare(return_value_DBaseConnectionGet_4, ProgramInfoGet__1__1__1__2__2__sqlstring, -1, &stmt, (const char **)(void *)0);
            sqlite3_free((void *)ProgramInfoGet__1__1__1__2__2__sqlstring);
          }

          else
            rc = 7;
        }
        while((_Bool)0);
        if(rc == 0)
        {
          rc=sqlite3_step(stmt);
          if(rc == 100)
          {
            signed int return_value_sqlite3_column_int_5;
            return_value_sqlite3_column_int_5=sqlite3_column_int(stmt, 0);
            result->pcrPID = return_value_sqlite3_column_int_5 & 0x1fff;
            const void *return_value_sqlite3_column_blob_6;
            return_value_sqlite3_column_blob_6=sqlite3_column_blob(stmt, 1);
            signed int return_value_sqlite3_column_bytes_7;
            return_value_sqlite3_column_bytes_7=sqlite3_column_bytes(stmt, 1);
            result->descriptors=UnRollDescriptors((unsigned char *)return_value_sqlite3_column_blob_6, return_value_sqlite3_column_bytes_7);
          }

          rc=sqlite3_finalize(stmt);
        }

      }

      else
      {
        ObjectRefDecImpl((void *)result, "pids.c", 152);
        result = (struct ProgramInfo_s *)(void *)0;
      }
    }

  }

  return result;
}

// ProgramInfoNew
// file pids.c line 54
struct ProgramInfo_s * ProgramInfoNew(signed int nrofStreams)
{
  struct ProgramInfo_s *info;
  if(typeInited == (_Bool)0)
  {
    ObjectRegisterClass("ProgramInfo_t", (unsigned int)sizeof(struct ProgramInfo_s) /*24ul*/ , ProgramInfoDestructor);
    ObjectRegisterCollection("StreamInfoList_t", (unsigned int)sizeof(struct StreamInfo_t) /*16ul*/ , StreamInfoListDestructor);
    typeInited = (_Bool)1;
  }

  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("ProgramInfo_t", "pids.c", 63);
  info = (struct ProgramInfo_s *)return_value_ObjectCreateImpl_1;
  if(!(info == ((struct ProgramInfo_s *)NULL)))
  {
    struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_2;
    return_value_ObjectCollectionCreateImpl_2=ObjectCollectionCreateImpl("StreamInfoList_t", (unsigned int)nrofStreams, "pids.c", 66);
    info->streamInfoList = (struct StreamInfoList_t *)return_value_ObjectCollectionCreateImpl_2;
  }

  return info;
}

// ProgramInfoRemove
// file pids.c line 161
signed int ProgramInfoRemove(struct Service_t *service)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("DELETE FROM PIDs WHERE mplexuid=%d AND serviceid=%d;", service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ProgramInfoRemove", 168, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  return 0;
}

// ProgramInfoSet
// file pids.c line 72
signed int ProgramInfoSet(struct Service_t *service, struct ProgramInfo_s *info)
{
  signed int rc = 0;
  signed int i;
  struct StreamInfo_t pid;
  i = 0;
  for( ; !(i >= info->streamInfoList->nrofStreams); i = i + 1)
  {
    rc=PIDAdd(service, &info->streamInfoList->streams[(signed long int)i]);
    if(!(rc == 0))
      break;

  }
  pid.pid = 0x8000 | info->pcrPID & 0x1fff;
  pid.type = 0;
  pid.descriptors = info->descriptors;
  PIDAdd(service, &pid);
  return rc;
}

// PromiscusModeEnable
// file ts.c line 507
static void PromiscusModeEnable(struct TSReader_t *reader, _Bool enable)
{
  signed int i;
  if(!(enable == reader->promiscuousMode))
  {
    i = 0;
    for( ; !(i >= 8193); i = i + 1)
      if(!(reader->packetFilters[(signed long int)i] == ((struct TSPacketFilter_t *)NULL)))
      {
        if(!(enable == (_Bool)0))
          DVBDemuxReleaseFilter(reader->adapter, (unsigned short int)i);

        else
        {
          DVBDemuxAllocateFilter(reader->adapter, (unsigned short int)i);
          LogModule(1, TSREADER, "Failed to allocate filter for 0x%04x", i);
        }
      }

    if(!(enable == (_Bool)0))
      DVBDemuxAllocateFilter(reader->adapter, (unsigned short int)8192);

    else
      DVBDemuxReleaseFilter(reader->adapter, (unsigned short int)8192);
    reader->promiscuousMode = enable;
  }

}

// PropertiesAddProperty
// file ../include/properties.h line 95
signed int PropertiesAddProperty(const char *path, const char *name, const char *desc, enum PropertyType_e type, void *userArg, signed int (*get)(void *, struct PropertyValue_s *), signed int (*set)(void *, struct PropertyValue_s *))
{
  struct PropertyNode_s *parentNode;
  parentNode=PropertiesCreateNodes(path);
  struct PropertyNode_s *propertyNode;
  propertyNode=PropertiesCreateNode(parentNode, name);
  propertyNode->desc = desc;
  propertyNode->type = type;
  propertyNode->userArg = userArg;
  propertyNode->accessors.simple.get = get;
  propertyNode->accessors.simple.set = set;
  return 0;
}

// PropertiesCreateNode
// file properties.c line 543
static struct PropertyNode_s * PropertiesCreateNode(struct PropertyNode_s *parentNode, const char *newProp)
{
  struct PropertyNode_s *childNode = (struct PropertyNode_s *)(void *)0;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("PropertyNode_t", "properties.c", 547);
  childNode = (struct PropertyNode_s *)return_value_ObjectCreateImpl_1;
  childNode->name=strdup(newProp);
  childNode->type = (enum PropertyType_e)PropertyType_None;
  childNode->desc = (const char *)(void *)0;
  childNode->parent = parentNode;
  if(!(parentNode->childNodes == ((struct PropertyNode_s *)NULL)))
  {
    struct PropertyNode_s *node;
    struct PropertyNode_s *prevNode = (struct PropertyNode_s *)(void *)0;
    node = parentNode->childNodes;
    for( ; !(node == ((struct PropertyNode_s *)NULL)); node = node->next)
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(node->name, newProp);
      if(return_value_strcmp_2 >= 1)
        break;

      prevNode = node;
    }
    if(node == ((struct PropertyNode_s *)NULL))
    {
      prevNode->next = childNode;
      childNode->next = (struct PropertyNode_s *)(void *)0;
    }

    else
    {
      childNode->next = node;
      if(!(prevNode == ((struct PropertyNode_s *)NULL)))
        prevNode->next = childNode;

      else
        parentNode->childNodes = childNode;
    }
  }

  else
    parentNode->childNodes = childNode;
  return childNode;
}

// PropertiesCreateNodes
// file properties.c line 519
static struct PropertyNode_s * PropertiesCreateNodes(const char *path)
{
  signed int toCreate = -1;
  signed int i;
  struct PropertyNode_s *currentNode;
  struct PropertyPathElements_s *pathElements;
  pathElements=PropertyPathSplitElements(path);
  currentNode=PropertiesFindNode(pathElements, &toCreate, (struct PropertyNode_s **)(void *)0);
  if(currentNode == ((struct PropertyNode_s *)NULL))
    currentNode = &rootProperty;

  if(!(toCreate == -1))
  {
    i = toCreate;
    for( ; !(i >= pathElements->nrofElements); i = i + 1)
      currentNode=PropertiesCreateNode(currentNode, pathElements->elements[(signed long int)i]);
  }

  ObjectRefDecImpl((void *)pathElements, "properties.c", 539);
  return currentNode;
}

// PropertiesDeInit
// file ../include/properties.h line 92
signed int PropertiesDeInit(void)
{
  while(!(rootProperty.childNodes == ((struct PropertyNode_s *)NULL)))
    PropertiesRemoveAllProperties(rootProperty.childNodes->name);
  return 0;
}

// PropertiesEnumGetInfo
// file ../include/properties.h line 112
void PropertiesEnumGetInfo(void *pos, struct PropertyInfo_s *propInfo)
{
  struct PropertyNode_s *node = (struct PropertyNode_s *)pos;
  if(!(node == ((struct PropertyNode_s *)NULL)))
  {
    propInfo->name = (char *)node->name;
    propInfo->desc = (char *)node->desc;
    propInfo->type = node->type;
    propInfo->readable = node->accessors.simple.get != (signed int (*)(void *, struct PropertyValue_s *))(void *)0;
    propInfo->writeable = node->accessors.simple.set != (signed int (*)(void *, struct PropertyValue_s *))(void *)0;
    propInfo->hasChildren = node->childNodes != (struct PropertyNode_s *)(void *)0;
  }

}

// PropertiesEnumNext
// file ../include/properties.h line 110
void * PropertiesEnumNext(void *pos)
{
  struct PropertyNode_s *node = (struct PropertyNode_s *)pos;
  if(!(node == ((struct PropertyNode_s *)NULL)))
    return (void *)node->next;

  else
    return (void *)0;
}

// PropertiesEnumerate
// file ../include/properties.h line 108
signed int PropertiesEnumerate(char *path, void **pos)
{
  signed int result = 0;
  signed int leftOver = -1;
  struct PropertyPathElements_s *pathElements = (struct PropertyPathElements_s *)(void *)0;
  struct PropertyNode_s *node = (struct PropertyNode_s *)(void *)0;
  _Bool tmp_if_expr_1;
  if(path == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)path[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    node = &rootProperty;

  else
  {
    pathElements=PropertyPathSplitElements(path);
    node=PropertiesFindNode(pathElements, &leftOver, (struct PropertyNode_s **)(void *)0);
  }
  if(node == ((struct PropertyNode_s *)NULL) || !(leftOver == -1))
    result = -1;

  else
    *pos = (void *)node->childNodes;
  if(!(pathElements == ((struct PropertyPathElements_s *)NULL)))
    ObjectRefDecImpl((void *)pathElements, "properties.c", 317);

  return result;
}

// PropertiesFindNode
// file properties.c line 588
static struct PropertyNode_s * PropertiesFindNode(struct PropertyPathElements_s *pathElements, signed int *leftOver, struct PropertyNode_s **before)
{
  struct PropertyNode_s *result = (struct PropertyNode_s *)(void *)0;
  struct PropertyNode_s *currentNode = &rootProperty;
  struct PropertyNode_s *prevNode = (struct PropertyNode_s *)(void *)0;
  struct PropertyNode_s *childNode;
  signed int i;
  _Bool nodeFound = (_Bool)1;
  *leftOver = -1;
  i = 0;
  for( ; !(i >= pathElements->nrofElements); i = i + 1)
  {
    nodeFound = (_Bool)0;
    prevNode = (struct PropertyNode_s *)(void *)0;
    childNode = currentNode->childNodes;
    for( ; !(childNode == ((struct PropertyNode_s *)NULL)); childNode = childNode->next)
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(childNode->name, pathElements->elements[(signed long int)i]);
      if(return_value_strcmp_1 == 0)
      {
        currentNode = childNode;
        nodeFound = (_Bool)1;
        break;
      }

      prevNode = childNode;
    }
    if(nodeFound == (_Bool)0)
      break;

  }
  if(!(before == ((struct PropertyNode_s **)NULL)))
    *before = prevNode;

  if(!(i >= pathElements->nrofElements))
    *leftOver = i;

  if(!(currentNode == &rootProperty))
    result = currentNode;

  return result;
}

// PropertiesGet
// file ../include/properties.h line 104
signed int PropertiesGet(char *path, struct PropertyValue_s *value)
{
  signed int result = -1;
  signed int leftOver;
  struct PropertyPathElements_s *pathElements;
  pathElements=PropertyPathSplitElements(path);
  struct PropertyNode_s *node;
  node=PropertiesFindNode(pathElements, &leftOver, (struct PropertyNode_s **)(void *)0);
  if(leftOver == -1 && !(node == ((struct PropertyNode_s *)NULL)))
  {
    if(!(node->accessors.simple.get == ((signed int (*)(void *, struct PropertyValue_s *))NULL)))
    {
      value->type = node->type;
      result=node->accessors.simple.get(node->userArg, value);
    }

  }

  ObjectRefDecImpl((void *)pathElements, "properties.c", 256);
  return result;
}

// PropertiesGetInfo
// file ../include/properties.h line 114
signed int PropertiesGetInfo(char *path, struct PropertyInfo_s *propInfo)
{
  signed int result = 0;
  signed int leftOver;
  struct PropertyPathElements_s *pathElements;
  pathElements=PropertyPathSplitElements(path);
  struct PropertyNode_s *node;
  node=PropertiesFindNode(pathElements, &leftOver, (struct PropertyNode_s **)(void *)0);
  if(node == ((struct PropertyNode_s *)NULL) || !(leftOver == -1))
    result = -1;

  else
  {
    propInfo->name = (char *)node->name;
    propInfo->desc = (char *)node->desc;
    propInfo->type = node->type;
    propInfo->readable = node->accessors.simple.get != (signed int (*)(void *, struct PropertyValue_s *))(void *)0;
    propInfo->writeable = node->accessors.simple.set != (signed int (*)(void *, struct PropertyValue_s *))(void *)0;
    propInfo->hasChildren = node->childNodes != (struct PropertyNode_s *)(void *)0;
  }
  ObjectRefDecImpl((void *)pathElements, "properties.c", 369);
  return result;
}

// PropertiesInit
// file ../include/properties.h line 86
signed int PropertiesInit(void)
{
  rootProperty.parent = (struct PropertyNode_s *)(void *)0;
  rootProperty.next = (struct PropertyNode_s *)(void *)0;
  rootProperty.name = "";
  rootProperty.desc = "Root of all properties";
  rootProperty.type = (enum PropertyType_e)PropertyType_None;
  rootProperty.childNodes = (struct PropertyNode_s *)(void *)0;
  ObjectRegisterClass("PropertyNode_t", (unsigned int)sizeof(struct PropertyNode_s) /*72ul*/ , PropertryDestructor);
  ObjectRegisterClass("PropertyPathElements_t", (unsigned int)sizeof(struct PropertyPathElements_s) /*2056ul*/ , PropertyPathElementsDestructor);
  return 0;
}

// PropertiesRemoveAllProperties
// file ../include/properties.h line 100
signed int PropertiesRemoveAllProperties(const char *path)
{
  signed int result = 0;
  signed int leftOver;
  struct PropertyPathElements_s *pathElements;
  pathElements=PropertyPathSplitElements(path);
  struct PropertyNode_s *prevNode = (struct PropertyNode_s *)(void *)0;
  struct PropertyNode_s *node;
  node=PropertiesFindNode(pathElements, &leftOver, &prevNode);
  struct PropertyNode_s *nextNode;
  struct PropertyNode_s *parentNode = node;
  if(node == ((struct PropertyNode_s *)NULL) || !(leftOver == -1))
  {
    LogModule(0, PROPERTIES, "Couldn't find parent \"%s\" while trying to remove nodes", path);
    result = -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    while((_Bool)1)
    {
      if(!(node->childNodes == ((struct PropertyNode_s *)NULL)))
      {
        node = node->childNodes;
        goto __CPROVER_DUMP_L1;
      }

      if(!(node == parentNode))
      {
        if(node->next == ((struct PropertyNode_s *)NULL))
        {
          nextNode = node->parent;
          nextNode->childNodes = (struct PropertyNode_s *)(void *)0;
        }

        else
          nextNode = node->next;
        ObjectRefDecImpl((void *)node, "properties.c", 199);
        node = nextNode;
      }

      if(node == parentNode)
        break;

    }
    nextNode = parentNode->next;
    if(parentNode->parent->childNodes == parentNode)
      parentNode->parent->childNodes = nextNode;

    if(!(prevNode == ((struct PropertyNode_s *)NULL)))
      prevNode->next = nextNode;

    ObjectRefDecImpl((void *)parentNode, "properties.c", 213);
  }
  ObjectRefDecImpl((void *)pathElements, "properties.c", 215);
  return result;
}

// PropertiesRemoveProperty
// file properties.c line 120
signed int PropertiesRemoveProperty(const char *path, const char *name)
{
  signed int result = 0;
  signed int leftOver;
  struct PropertyPathElements_s *pathElements;
  pathElements=PropertyPathSplitElements(path);
  struct PropertyNode_s *parentNode;
  parentNode=PropertiesFindNode(pathElements, &leftOver, (struct PropertyNode_s **)(void *)0);
  ObjectRefDecImpl((void *)pathElements, "properties.c", 126);
  if(parentNode == ((struct PropertyNode_s *)NULL) || !(leftOver == -1))
  {
    LogModule(0, PROPERTIES, "Couldn't find parent \"%s\" while trying to remove node %s", path, name);
    result = -1;
  }

  else
  {
    struct PropertyNode_s *prevNode = (struct PropertyNode_s *)(void *)0;
    struct PropertyNode_s *currentNode = parentNode->childNodes;
    for( ; !(currentNode == ((struct PropertyNode_s *)NULL)); currentNode = currentNode->next)
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(name, currentNode->name);
      if(return_value_strcmp_1 == 0)
        break;

      prevNode = currentNode;
    }
    if(currentNode == ((struct PropertyNode_s *)NULL))
    {
      LogModule(0, PROPERTIES, "Couldn't find \"%s\" with parent %s", name, path);
      result = -1;
    }

    else
      if(!(currentNode->childNodes == ((struct PropertyNode_s *)NULL)))
      {
        LogModule(0, PROPERTIES, "Not removing \"%s\" with parent %s as it has children", name, path);
        result = -1;
      }

      else
      {
        prevNode->next = currentNode->next;
        ObjectRefDecImpl((void *)currentNode, "properties.c", 160);
      }
  }
  return result;
}

// PropertiesSet
// file properties.c line 219
signed int PropertiesSet(char *path, struct PropertyValue_s *value)
{
  signed int result = -1;
  signed int leftOver;
  struct PropertyPathElements_s *pathElements;
  pathElements=PropertyPathSplitElements(path);
  struct PropertyNode_s *node;
  node=PropertiesFindNode(pathElements, &leftOver, (struct PropertyNode_s **)(void *)0);
  _Bool tmp_if_expr_1;
  if(leftOver == -1 && !(node == ((struct PropertyNode_s *)NULL)))
  {
    if(node->type == value->type)
      tmp_if_expr_1 = node->accessors.simple.set != (signed int (*)(void *, struct PropertyValue_s *))(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      result=node->accessors.simple.set(node->userArg, value);

    else
      LogModule(0, PROPERTIES, "Wrong type supplied as value while trying to set property %s!", path);
  }

  ObjectRefDecImpl((void *)pathElements, "properties.c", 237);
  return result;
}

// PropertiesSetStr
// file ../include/properties.h line 106
signed int PropertiesSetStr(char *path, char *value)
{
  signed int result = -1;
  struct PropertyValue_s newValue;
  signed int leftOver;
  struct PropertyPathElements_s *pathElements;
  pathElements=PropertyPathSplitElements(path);
  struct PropertyNode_s *node;
  node=PropertiesFindNode(pathElements, &leftOver, (struct PropertyNode_s **)(void *)0);
  _Bool tmp_if_expr_1;
  if(node == ((struct PropertyNode_s *)NULL) || !(leftOver == -1))
    result = -1;

  else
  {
    PropertiesStrToValue(value, node->type, &newValue);
    if(node->type == newValue.type)
      tmp_if_expr_1 = node->accessors.simple.set != (signed int (*)(void *, struct PropertyValue_s *))(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      result=node->accessors.simple.set(node->userArg, &newValue);

    else
    {
      LogModule(0, PROPERTIES, "Wrong type supplied as value while trying to set property %s!", path);
      result = -1;
    }
  }
  ObjectRefDecImpl((void *)pathElements, "properties.c", 287);
  return result;
}

// PropertiesSimplePropertyGet
// file ../include/properties.h line 125
signed int PropertiesSimplePropertyGet(void *userArg, struct PropertyValue_s *value)
{
  signed int result = 0;
  switch((signed int)value->type)
  {
    case PropertyType_Int:
    {
      value->u.integer = *((signed int *)userArg);
      break;
    }
    case PropertyType_Float:
    {
      value->u.fp = *((double *)userArg);
      break;
    }
    case PropertyType_Boolean:
    {
      value->u.boolean = *((_Bool *)userArg);
      break;
    }
    case PropertyType_String:
    {
      value->u.string=strdup(*((char **)userArg));
      break;
    }
    case PropertyType_Char:
    {
      value->u.ch = *((char *)userArg);
      break;
    }
    case PropertyType_PID:
    {
      value->u.pid = *((unsigned short int *)userArg);
      break;
    }
    case PropertyType_IPAddress:
    {
      result = -1;
      break;
    }
    default:
      result = -1;
  }
  return result;
}

// PropertiesSimplePropertySet
// file ../include/properties.h line 136
signed int PropertiesSimplePropertySet(void *userArg, struct PropertyValue_s *value)
{
  signed int result = 0;
  switch((signed int)value->type)
  {
    case PropertyType_Int:
    {
      *((signed int *)userArg) = value->u.integer;
      break;
    }
    case PropertyType_Float:
    {
      *((double *)userArg) = value->u.fp;
      break;
    }
    case PropertyType_Boolean:
    {
      *((_Bool *)userArg) = value->u.boolean;
      break;
    }
    case PropertyType_String:
    {
      *((char **)userArg) = value->u.string;
      break;
    }
    case PropertyType_Char:
    {
      *((char *)userArg) = value->u.ch;
      break;
    }
    case PropertyType_PID:
    {
      *((unsigned short int *)userArg) = value->u.pid;
      break;
    }
    case PropertyType_IPAddress:
    {
      result = -1;
      break;
    }
    default:
      result = -1;
  }
  return result;
}

// PropertiesStrToValue
// file properties.c line 373
static signed int PropertiesStrToValue(char *input, enum PropertyType_e toType, struct PropertyValue_s *output)
{
  unsigned int pid;
  output->type = (enum PropertyType_e)PropertyType_None;
  signed int return_value_sscanf_1;
  signed int return_value_sscanf_2;
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_sscanf_5;
  switch((signed int)toType)
  {
    case PropertyType_Int:
    {
      return_value_sscanf_1=sscanf(input, "%d", &output->u.integer);
      if(return_value_sscanf_1 == 1)
        output->type = (enum PropertyType_e)PropertyType_Int;

      break;
    }
    case PropertyType_Float:
    {
      return_value_sscanf_2=sscanf(input, "%lf", &output->u.fp);
      if(return_value_sscanf_2 == 1)
        output->type = (enum PropertyType_e)PropertyType_Float;

      break;
    }
    case PropertyType_Boolean:
    {
      return_value_strcasecmp_4=strcasecmp(input, "true");
      if(return_value_strcasecmp_4 == 0)
      {
        output->type = (enum PropertyType_e)PropertyType_Boolean;
        output->u.boolean = (_Bool)1;
      }

      else
      {
        return_value_strcasecmp_3=strcasecmp(input, "false");
        if(return_value_strcasecmp_3 == 0)
        {
          output->type = (enum PropertyType_e)PropertyType_Boolean;
          output->u.boolean = (_Bool)0;
        }

      }
      break;
    }
    case PropertyType_String:
    {
      output->type = (enum PropertyType_e)PropertyType_String;
      output->u.string=strdup(input);
      break;
    }
    case PropertyType_Char:
    {
      output->type = (enum PropertyType_e)PropertyType_Char;
      output->u.ch = *input;
      break;
    }
    case PropertyType_PID:
    {
      return_value_sscanf_5=sscanf(input, "%u", &pid);
      if(return_value_sscanf_5 == 0)
      {
        if(!(pid >= 8193u))
        {
          output->type = (enum PropertyType_e)PropertyType_PID;
          output->u.pid = (unsigned short int)pid;
        }

      }

      break;
    }
    case PropertyType_IPAddress:
      break;
    default:
      ;
  }
  return (signed int)output->type == PropertyType_None ? -1 : 0;
}

// PropertryDestructor
// file properties.c line 670
static void PropertryDestructor(void *ptr)
{
  struct PropertyNode_s *node = (struct PropertyNode_s *)ptr;
  free((void *)(char *)node->name);
}

// PropertyPathElementsDestructor
// file properties.c line 660
static void PropertyPathElementsDestructor(void *ptr)
{
  struct PropertyPathElements_s *pathElements = (struct PropertyPathElements_s *)ptr;
  signed int i = 0;
  for( ; !(i >= pathElements->nrofElements); i = i + 1)
    free((void *)pathElements->elements[(signed long int)i]);
}

// PropertyPathSplitElements
// file properties.c line 633
static struct PropertyPathElements_s * PropertyPathSplitElements(const char *path)
{
  struct PropertyPathElements_s *pathElements;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("PropertyPathElements_t", "properties.c", 635);
  pathElements = (struct PropertyPathElements_s *)return_value_ObjectCreateImpl_1;
  char *elementStart = (char *)path;
  char *elementEnd = (char *)(void *)0;
  char nodeName[255l];
  for( ; !(elementStart == ((char *)NULL)); pathElements->nrofElements = pathElements->nrofElements + 1)
  {
    elementEnd=strchr(elementStart, 46);
    if(!(elementEnd == ((char *)NULL)))
    {
      signed int len = (signed int)(elementEnd - elementStart);
      strncpy(nodeName, elementStart, (unsigned long int)len);
      nodeName[(signed long int)len] = (char)0;
      elementStart = elementEnd + (signed long int)1;
    }

    else
    {
      strcpy(nodeName, elementStart);
      elementStart = (char *)(void *)0;
    }
    pathElements->elements[(signed long int)pathElements->nrofElements]=strdup(nodeName);
  }
  return pathElements;
}

// RegisterEventListener
// file events.c line 421
static void RegisterEventListener(struct List_s *listenerList, void (*callback)(void *, struct Event_s *, void *), void *arg)
{
  struct EventListenerDetails_s *details;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("EventListenerDetails_t", "events.c", 423);
  details = (struct EventListenerDetails_s *)return_value_ObjectCreateImpl_1;
  if(!(details == ((struct EventListenerDetails_s *)NULL)))
  {
    details->callback = callback;
    details->arg = arg;
    ListAdd(listenerList, (void *)details);
  }

}

// RemoteInterfaceAcceptCallback
// file remoteintf.c line 272
static void RemoteInterfaceAcceptCallback(struct ev_loop *loop, struct ev_io *w, signed int revents)
{
  signed int clientfd;
  struct sockaddr_storage clientAddress;
  unsigned int clientAddressSize = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  clientfd=accept(serverSocket, (struct sockaddr *)&clientAddress, &clientAddressSize);
  if(clientfd >= 0)
    AddConnection(clientfd, &clientAddress);

}

// RemoteInterfaceAuthenticate
// file remoteintf.c line 419
static void RemoteInterfaceAuthenticate(signed int argc, char **argv)
{
  struct CommandContext_t *context;
  context=CommandContextGet();
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(argv[(signed long int)0], authUsername);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(return_value_strcmp_1 == 0)
  {
    return_value_strcmp_2=strcmp(argv[(signed long int)1], authPassword);
    tmp_if_expr_3 = return_value_strcmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    context->authenticated = (_Bool)1;
    do
    {
      struct CommandContext_t *RemoteInterfaceAuthenticate__1__1__1__context;
      RemoteInterfaceAuthenticate__1__1__1__context=CommandContextGet();
      RemoteInterfaceAuthenticate__1__1__1__context->errorNumber = (unsigned short int)0x0000;
      snprintf(RemoteInterfaceAuthenticate__1__1__1__context->errorMessage, (unsigned long int)256, "Authenticated.");
    }
    while((_Bool)0);
  }

  else
  {
    context->authenticated = (_Bool)0;
    do
    {
      struct CommandContext_t *RemoteInterfaceAuthenticate__1__2__1__context;
      RemoteInterfaceAuthenticate__1__2__1__context=CommandContextGet();
      RemoteInterfaceAuthenticate__1__2__1__context->errorNumber = (unsigned short int)0x0004;
      snprintf(RemoteInterfaceAuthenticate__1__2__1__context->errorMessage, (unsigned long int)256, "Authentication failed!");
    }
    while((_Bool)0);
  }
}

// RemoteInterfaceDeInit
// file ../include/remoteintf.h line 30
void RemoteInterfaceDeInit(void)
{
  struct ListIterator_s iterator;
  struct ev_loop *return_value_DispatchersGetNetwork_1;
  return_value_DispatchersGetNetwork_1=DispatchersGetNetwork();
  ev_io_start(return_value_DispatchersGetNetwork_1, &serverSocketWatcher);
  CommandUnRegisterCommands(RemoteInterfaceCommands);
  remoteIntfExit = (_Bool)1;
  close(serverSocket);
  pthread_mutex_lock(&connectionsMutex);
  struct ListEntry_s *tmp_if_expr_2;
  if(connectionsList->count >= 1)
  {
    iterator.current = connectionsList->head;
    iterator.list = connectionsList;
    for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_2)
    {
      struct Connection_t *connection = (struct Connection_t *)iterator.current->data;
      close(connection->socketfd);
      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_2 = iterator.current->next;

      else
        tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
    }
    pthread_cond_wait(&connectionCondVar, &connectionsMutex);
  }

  pthread_mutex_unlock(&connectionsMutex);
  free((void *)infoStreamerName);
  free((void *)authUsername);
  free((void *)authPassword);
  ListFree(connectionsList, (void (*)(void *))(void *)0);
}

// RemoteInterfaceInit
// file ../include/remoteintf.h line 29
signed int RemoteInterfaceInit(signed int adapter, char *streamerName, char *bindAddress, char *username, char *password)
{
  struct ev_loop *netLoop;
  netLoop=DispatchersGetNetwork();
  unsigned int address_len;
  struct sockaddr_storage address;
  struct addrinfo *addrinfo;
  struct addrinfo hints;
  char portnumber[10l];
  sprintf(portnumber, "%d", 54197 + adapter);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = 1;
  hints.ai_flags = 0x0020 | 0x0001;
  signed int return_value_getaddrinfo_1;
  return_value_getaddrinfo_1=getaddrinfo(bindAddress, portnumber, &hints, &addrinfo);
  if(addrinfo == ((struct addrinfo *)NULL) || !(return_value_getaddrinfo_1 == 0))
  {
    LogModule(3, REMOTEINTERFACE, "Failed to set bind address\n");
    return 1;
  }

  else
    if((unsigned long int)addrinfo->ai_addrlen >= 129ul)
    {
      freeaddrinfo(addrinfo);
      LogModule(3, REMOTEINTERFACE, "Failed to parse bind address\n");
      return 1;
    }

    else
    {
      address_len = addrinfo->ai_addrlen;
      memcpy((void *)&address, (const void *)addrinfo->ai_addr, (unsigned long int)addrinfo->ai_addrlen);
      freeaddrinfo(addrinfo);
      serverSocket=socket((signed int)address.ss_family, 1, 6);
      if(!(serverSocket >= 0))
      {
        LogModule(0, REMOTEINTERFACE, "Failed to create server socket!\n");
        return 1;
      }

      else
      {
        signed int return_value_bind_2;
        return_value_bind_2=bind(serverSocket, (struct sockaddr *)&address, address_len);
        if(!(return_value_bind_2 >= 0))
        {
          LogModule(0, REMOTEINTERFACE, "Failed to bind server to port %d\n", 54197 + adapter);
          close(serverSocket);
          return 1;
        }

        else
        {
          ObjectRegisterClass("Connection_t", (unsigned int)sizeof(struct Connection_t) /*160ul*/ , (void (*)(void *))(void *)0);
          connectionsList=ListCreate();
          listen(serverSocket, 1);
          infoStreamerName=strdup(streamerName);
          authUsername=strdup(username);
          authPassword=strdup(password);
          time(&serverStartTime);
          char *return_value_ctime_3;
          return_value_ctime_3=ctime(&serverStartTime);
          LogModule(1, REMOTEINTERFACE, "Server created %s", return_value_ctime_3);
          LogModule(3, REMOTEINTERFACE, "Username    : %s\n", authUsername);
          LogModule(3, REMOTEINTERFACE, "Password    : %s\n", authPassword);
          LogModule(3, REMOTEINTERFACE, "Server Name : %s\n", infoStreamerName);
          CommandRegisterCommands(RemoteInterfaceCommands);
          PropertiesAddProperty("sys.rc", "servername", "Name of this dvbstreamer instance.", (enum PropertyType_e)PropertyType_String, (void *)&infoStreamerName, PropertiesSimplePropertyGet, (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
          PropertiesAddProperty("sys.rc", "username", "Username used to authenticate.", (enum PropertyType_e)PropertyType_String, (void *)&infoStreamerName, (signed int (*)(void *, struct PropertyValue_s *))(void *)0, PropertiesSimplePropertySet);
          PropertiesAddProperty("sys.rc", "password", "Password used to authenticate.", (enum PropertyType_e)PropertyType_String, (void *)&infoStreamerName, (signed int (*)(void *, struct PropertyValue_s *))(void *)0, PropertiesSimplePropertySet);
          do
          {

          __CPROVER_DUMP_L5:
            ;
            ((struct ev_watcher *)(void *)&serverSocketWatcher)->pending = 0;
            ((struct ev_watcher *)(void *)&serverSocketWatcher)->active = ((struct ev_watcher *)(void *)&serverSocketWatcher)->pending;
            ((struct ev_watcher *)(void *)&serverSocketWatcher)->priority = 0;
            (&serverSocketWatcher)->cb = RemoteInterfaceAcceptCallback;
            memmove((void *)&((struct ev_watcher *)&serverSocketWatcher)->cb, (const void *)&(&serverSocketWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_io *, signed int)) /*8ul*/ );
            do
            {
              (&serverSocketWatcher)->fd = serverSocket;
              (&serverSocketWatcher)->events = 1 | 128;
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          ev_io_start(netLoop, &serverSocketWatcher);
          return 0;
        }
      }
    }
}

// RemoteInterfaceLogout
// file remoteintf.c line 452
static void RemoteInterfaceLogout(signed int argc, char **argv)
{
  struct CommandContext_t *RemoteInterfaceLogout__1__context;
  RemoteInterfaceLogout__1__context=CommandContextGet();
  if(!(RemoteInterfaceLogout__1__context->remote == (_Bool)0))
  {
    struct Connection_t *connection = (struct Connection_t *)RemoteInterfaceLogout__1__context->privateArg;
    connection->connected = (_Bool)0;
    do
    {
      struct CommandContext_t *context;
      context=CommandContextGet();
      context->errorNumber = (unsigned short int)0x0000;
      snprintf(context->errorMessage, (unsigned long int)256, "Bye!");
    }
    while((_Bool)0);
  }

  else
    do
    {
      struct CommandContext_t *RemoteInterfaceLogout__1__2__1__context;
      RemoteInterfaceLogout__1__2__1__context=CommandContextGet();
      RemoteInterfaceLogout__1__2__1__context->errorNumber = (unsigned short int)0xffff;
      snprintf(RemoteInterfaceLogout__1__2__1__context->errorMessage, (unsigned long int)256, "Not a remote connection!");
    }
    while((_Bool)0);
}

// RemoteInterfaceWho
// file remoteintf.c line 435
static void RemoteInterfaceWho(signed int argc, char **argv)
{
  char connectionStr[48l];
  struct ListIterator_s iterator;
  iterator.current = connectionsList->head;
  iterator.list = connectionsList;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct Connection_t *connection = (struct Connection_t *)iterator.current->data;
    if(!(connection->connected == (_Bool)0))
    {
      GetConnectionString(&connection->clientAddress, connectionStr);
      CommandPrintf("%s\n", (const void *)connectionStr);
    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
}

// RemoveConnection
// file remoteintf.c line 323
static void RemoveConnection(struct Connection_t *connection)
{
  pthread_mutex_lock(&connectionsMutex);
  ListRemove(connectionsList, (void *)connection);
  ObjectRefDecImpl((void *)connection, "remoteintf.c", 327);
  if(connectionsList->count == 0)
  {
    if(!(remoteIntfExit == (_Bool)0))
      pthread_cond_broadcast(&connectionCondVar);

  }

  pthread_mutex_unlock(&connectionsMutex);
}

// RemoveReferencedObject
// file objects.c line 464
static void RemoveReferencedObject(struct Object_s *toRemove)
{
  struct Object_s *current = referencedObjects;
  struct Object_s *previous = (struct Object_s *)(void *)0;
  for( ; !(current == ((struct Object_s *)NULL)); current = current->next)
  {
    if(current == toRemove)
    {
      if(!(previous == ((struct Object_s *)NULL)))
        previous->next = current->next;

      else
        referencedObjects = current->next;
      break;
    }

    previous = current;
  }
}

// RollUpDescriptors
// file pids.c line 222
static void * RollUpDescriptors(struct dvbpsi_descriptor_s *descriptors, signed int *datasize)
{
  unsigned char *result;
  signed int size = 0;
  signed int pos = 0;
  struct dvbpsi_descriptor_s *current = descriptors;
  for( ; !(current == ((struct dvbpsi_descriptor_s *)NULL)); current = current->p_next)
    size = size + (signed int)current->i_length + 2;
  if(size == 0)
  {
    *datasize = 0;
    return (void *)0;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)size);
    result = (unsigned char *)return_value_malloc_1;
    if(result == ((unsigned char *)NULL))
    {
      LogModule(0, "PIDS", "Failed to allocate memory to roll up descriptors! (size %d)\n", size);
      *datasize = 0;
      return (void *)0;
    }

    else
    {
      current = descriptors;
      for( ; !(current == ((struct dvbpsi_descriptor_s *)NULL)); current = current->p_next)
      {
        result[(signed long int)pos] = current->i_tag;
        result[(signed long int)(pos + 1)] = current->i_length;
        memcpy((void *)&result[(signed long int)(pos + 2)], (const void *)current->p_data, (unsigned long int)current->i_length);
        pos = pos + (signed int)current->i_length + 2;
      }
      *datasize = size;
      return (void *)result;
    }
  }
}

// SDTEventListener
// file commands/cmd_scanning.c line 1213
static void SDTEventListener(void *arg, struct Event_s *event, void *payload)
{
  if((signed int)currentScanState == ScanState_WaitingForTables)
    ScanStateMachine((enum ScanEvent_e)ScanEvent_SDTReceived);

}

// SDTHandler
// file standard/dvb/sdtprocessor.c line 139
static void SDTHandler(void *arg, struct dvbpsi_sdt_s *newSDT)
{
  struct SDTProcessor_s *state = (struct SDTProcessor_s *)arg;
  struct dvbpsi_sdt_service_s *sdtservice = newSDT->p_first_service;
  signed int count;
  signed int i;
  struct Service_t **services;
  struct Multiplex_s *mux;
  LogModule(3, SDTPROCESSOR, "SDT recieved, version %d\n", newSDT->i_version);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  while(!(sdtservice == ((struct dvbpsi_sdt_service_s *)NULL)))
  {
    struct dvbpsi_descriptor_s *descriptor = sdtservice->p_first_descriptor;
    _Bool ca;
    struct Service_t *service;
    service=CacheServiceFindId((signed int)sdtservice->i_service_id);
    if(service == ((struct Service_t *)NULL))
      service=CacheServiceAdd((signed int)sdtservice->i_service_id, (signed int)sdtservice->i_service_id);

    else
      CacheServiceSeen(service, (_Bool)1, (_Bool)0);
    for( ; !(descriptor == ((struct dvbpsi_descriptor_s *)NULL)); descriptor = descriptor->p_next)
    {
      if((signed int)descriptor->i_tag == 0x48)
      {
        struct dvbpsi_service_dr_s *servicedesc;
        servicedesc=dvbpsi_DecodeServiceDr(descriptor);
        if(!(servicedesc == ((struct dvbpsi_service_dr_s *)NULL)))
        {
          char *name;
          enum anonymous type;
          type=ConvertDVBServiceType((signed int)servicedesc->i_service_type);
          name=DVBTextToUTF8((char *)servicedesc->i_service_name, (unsigned long int)servicedesc->i_service_name_length);
          if(!(name == ((char *)NULL)))
          {
            removeControlCodes(name);
            signed int return_value_strcmp_1;
            return_value_strcmp_1=strcmp(name, service->name);
            if(!(return_value_strcmp_1 == 0))
            {
              LogModule(3, SDTPROCESSOR, "Updating service 0x%04x = %s\n", sdtservice->i_service_id, name);
              CacheUpdateServiceName(service, name);
            }

            free((void *)name);
          }

          name=DVBTextToUTF8((char *)servicedesc->i_service_provider_name, (unsigned long int)servicedesc->i_service_provider_name_length);
          if(!(name == ((char *)NULL)))
          {
            if(service->provider == ((char *)NULL))
              tmp_if_expr_3 = (_Bool)1;

            else
            {
              return_value_strcmp_2=strcmp(name, service->provider);
              tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_3)
            {
              LogModule(3, SDTPROCESSOR, "Updating service provider 0x%04x = %s\n", sdtservice->i_service_id, name);
              CacheUpdateServiceProvider(service, name);
            }

            free((void *)name);
          }

          if(!(service->type == type))
            CacheUpdateServiceType(service, type);

        }

      }

      if((signed int)descriptor->i_tag == 0x73)
      {
        struct dvbpsi_default_authority_dr_s *defAuthDesc;
        defAuthDesc=dvbpsi_DecodeDefaultAuthorityDr(descriptor);
        if(!(defAuthDesc == ((struct dvbpsi_default_authority_dr_s *)NULL)))
        {
          if(service->defaultAuthority == ((char *)NULL))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_strcmp_4=strcmp((char *)defAuthDesc->authority, service->defaultAuthority);
            tmp_if_expr_5 = return_value_strcmp_4 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
          {
            LogModule(3, SDTPROCESSOR, "Updating service default authority 0x%04x = %s\n", sdtservice->i_service_id, (const void *)defAuthDesc->authority);
            CacheUpdateServiceDefaultAuthority(service, (char *)defAuthDesc->authority);
          }

        }

      }

    }
    ca = (_Bool)(sdtservice->b_free_ca != 0 ? 1 : 0);
    if(!(service->conditionalAccess == ca))
      CacheUpdateServiceConditionalAccess(service, ca);

    do
      if(!(service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)service, "standard/dvb/sdtprocessor.c", 223);

    while((_Bool)0);
    sdtservice = sdtservice->p_next;
  }
  services=CacheServicesGet(&count);
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    _Bool found = (_Bool)0;
    sdtservice = newSDT->p_first_service;
    for( ; !(sdtservice == ((struct dvbpsi_sdt_service_s *)NULL)); sdtservice = sdtservice->p_next)
      if(services[(signed long int)i]->id == (signed int)sdtservice->i_service_id)
      {
        found = (_Bool)1;
        break;
      }

    if(found == (_Bool)0)
    {
      LogModule(3, SDTPROCESSOR, "Service not found in SDT while checking cache, deleting 0x%04x (%s)\n", services[(signed long int)i]->id, services[(signed long int)i]->name);
      _Bool return_value_CacheServiceSeen_6;
      return_value_CacheServiceSeen_6=CacheServiceSeen(services[(signed long int)i], (_Bool)0, (_Bool)0);
      if(return_value_CacheServiceSeen_6 == (_Bool)0)
      {
        CacheServicesRelease();
        CacheServiceDelete(services[(signed long int)i]);
        services=CacheServicesGet(&count);
        i = i - 1;
        state->tsgroup->tsReader->tsStructureChanged = (_Bool)1;
      }

    }

  }
  CacheServicesRelease();
  mux=TuningCurrentMultiplexGet();
  if(!(mux->networkId == (signed int)newSDT->i_network_id))
    CacheUpdateNetworkId(mux, (signed int)newSDT->i_network_id);

  do
    if(!(mux == ((struct Multiplex_s *)NULL)))
      ObjectRefDecImpl((void *)mux, "standard/dvb/sdtprocessor.c", 263);

  while((_Bool)0);
  EventsFireEventListeners(sdtEvent, (void *)newSDT);
  ObjectRefDecImpl((void *)newSDT, "standard/dvb/sdtprocessor.c", 266);
}

// SDTProcessorCreate
// file ../include/sdtprocessor.h line 28
struct SDTProcessor_s * SDTProcessorCreate(struct TSReader_t *reader)
{
  struct SDTProcessor_s *state = (struct SDTProcessor_s *)(void *)0;
  if(sdtEvent == ((struct Event_s *)NULL))
    sdtEvent=EventsRegisterEvent(DVBEventSource, "SDT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);

  ObjectRegisterClass("SDTProcessor_t", (unsigned int)sizeof(struct SDTProcessor_s) /*16ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("SDTProcessor_t", "standard/dvb/sdtprocessor.c", 97);
  state = (struct SDTProcessor_s *)return_value_ObjectCreateImpl_1;
  if(!(state == ((struct SDTProcessor_s *)NULL)))
    state->tsgroup=TSReaderCreateFilterGroup(reader, SDTPROCESSOR, "DVB", SDTProcessorFilterEventCallback, (void *)state);

  return state;
}

// SDTProcessorDestroy
// file ../include/sdtprocessor.h line 29
void SDTProcessorDestroy(struct SDTProcessor_s *processor)
{
  TSFilterGroupDestroy(processor->tsgroup);
  if(!(processor->demux == ((struct dvbpsi_decoder_s *)NULL)))
    dvbpsi_DetachDemux(processor->demux);

  ObjectRefDecImpl((void *)processor, "standard/dvb/sdtprocessor.c", 112);
}

// SDTProcessorFilterEventCallback
// file standard/dvb/sdtprocessor.c line 118
static void SDTProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details)
{
  struct SDTProcessor_s *state = (struct SDTProcessor_s *)userArg;
  if(!(state->demux == ((struct dvbpsi_decoder_s *)NULL)))
  {
    TSFilterGroupRemoveSectionFilter(state->tsgroup, (unsigned short int)0x11);
    dvbpsi_DetachDemux(state->demux);
  }

  state->demux=dvbpsi_AttachDemux(SubTableHandler_link1, (void *)state);
  TSFilterGroupAddSectionFilter(state->tsgroup, (unsigned short int)0x11, 1, state->demux);
}

// ScanCurrentMultiplexes
// file commands/cmd_scanning.c line 525
static void ScanCurrentMultiplexes(void)
{
  signed int i;
  struct MultiplexList_s *list;
  list=MultiplexGetAll();
  if(!(list == ((struct MultiplexList_s *)NULL)))
  {
    i = 0;
    for( ; ExitProgram == (_Bool)0 && !(i >= list->nrofMultiplexes); i = i + 1)
    {
      ScanListAddEntry(list->multiplexes[(signed long int)i]->deliverySystem, list->multiplexes[(signed long int)i], (struct TuningParamDocs_s *)(void *)0);
      ObjectRefIncImpl((void *)list->multiplexes[(signed long int)i], "commands/cmd_scanning.c", 535);
    }
    ObjectRefDecImpl((void *)list, "commands/cmd_scanning.c", 537);
  }

  ScanStart((enum ScanType_e)ScanType_List);
}

// ScanEntryDestructor
// file commands/cmd_scanning.c line 1863
static void ScanEntryDestructor(void *ptr)
{
  struct ScanEntry_s *entry = (struct ScanEntry_s *)ptr;
  if(!(entry->mux == ((struct Multiplex_s *)NULL)))
    ObjectRefDecImpl((void *)entry->mux, "commands/cmd_scanning.c", 1868);

  if(!(entry->params == ((struct TuningParamDocs_s *)NULL)))
    ObjectRefDecImpl((void *)entry->params, "commands/cmd_scanning.c", 1873);

}

// ScanEventToString
// file commands/cmd_scanning.c line 1900
static signed int ScanEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload)
{
  char temp[5l];
  signed int mappingId;
  mappingId=yaml_document_add_mapping(document, (unsigned char *)"tag:yaml.org,2002:map", (enum yaml_mapping_style_e)YAML_ANY_MAPPING_STYLE);
  sprintf(temp, "%d", toScan.count);
  YamlUtils_MappingAdd(document, mappingId, "Total transponders", temp);
  sprintf(temp, "%d", toScan.pos);
  YamlUtils_MappingAdd(document, mappingId, "Transponder", temp);
  LogModule(1, SCANNING, "Total %d Current %d", toScan.count, toScan.pos);
  return mappingId;
}

// ScanFullATSC
// file commands/cmd_scanning.c line 845
static void ScanFullATSC(void)
{
  struct MultiplexList_s *muxList;
  muxList=MultiplexGetAll();
  struct MuxFrequencies_s *muxFreqList;
  muxFreqList=ParseMuxListFrequencies(muxList);
  struct Multiplex_s *mux;
  signed int channel;
  signed int base_offset = 0;
  unsigned int freq;
  if(!(ATSCScanOTA == (_Bool)0))
  {
    channel = 2;
    for( ; cancelScan == (_Bool)0 && !(channel >= 70); channel = channel + 1)
    {
      if(!(channel >= 5))
        base_offset = 45028615;

      else
        if(!(channel >= 7))
          base_offset = 49028615;

        else
          if(!(channel >= 14))
            base_offset = 135028615;

          else
            base_offset = 389028615;
      freq = (unsigned int)(base_offset + channel * 6000000);
      mux=FindMultiplexFrequency(muxList, muxFreqList, (unsigned long int)freq, 28615, (char *)(void *)0, 0);
      if(!(mux == ((struct Multiplex_s *)NULL)))
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_ATSC, mux, (struct TuningParamDocs_s *)(void *)0);

      else
      {
        struct TuningParamDocs_s *docs;
        struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_1;
        return_value_ObjectCollectionCreateImpl_1=ObjectCollectionCreateImpl("TuningParamDocs_t", (unsigned int)1, "commands/cmd_scanning.c", 885);
        docs = (struct TuningParamDocs_s *)return_value_ObjectCollectionCreateImpl_1;
        asprintf(&docs->docs[(signed long int)0], "Frequency: %u\nInversion: AUTO\nModulation: 8VSB\n", freq);
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_ATSC, (struct Multiplex_s *)(void *)0, docs);
      }
    }
  }

  if(!(ATSCScanCable == (_Bool)0))
  {
    channel = 2;
    for( ; cancelScan == (_Bool)0 && !(channel >= 134); channel = channel + 1)
    {
      if(!(channel >= 5))
        base_offset = 45000000;

      else
        if(!(channel >= 7))
          base_offset = 49000000;

        else
          if(!(channel >= 14))
            base_offset = 135000000;

          else
            if(!(channel >= 17))
              base_offset = 39012500;

            else
              if(!(channel >= 23))
                base_offset = 39000000;

              else
                if(!(channel >= 25))
                  base_offset = 81000000;

                else
                  if(!(channel >= 54))
                    base_offset = 81012500;

                  else
                    if(!(channel >= 95))
                      base_offset = 81000000;

                    else
                      if(!(channel >= 98))
                        base_offset = -477000000;

                      else
                        if(!(channel >= 100))
                          base_offset = -476987500;

                        else
                          base_offset = 51000000;
      freq = (unsigned int)(base_offset + channel * 6000000);
      mux=FindMultiplexFrequency(muxList, muxFreqList, (unsigned long int)freq, 0, (char *)(void *)0, 0);
      if(!(mux == ((struct Multiplex_s *)NULL)))
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_ATSC, mux, (struct TuningParamDocs_s *)(void *)0);

      else
      {
        struct TuningParamDocs_s *ScanFullATSC__1__2__1__1__2__docs;
        struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_2;
        return_value_ObjectCollectionCreateImpl_2=ObjectCollectionCreateImpl("TuningParamDocs_t", (unsigned int)1, "commands/cmd_scanning.c", 930);
        ScanFullATSC__1__2__1__1__2__docs = (struct TuningParamDocs_s *)return_value_ObjectCollectionCreateImpl_2;
        asprintf(&ScanFullATSC__1__2__1__1__2__docs->docs[(signed long int)0], "Frequency: %u\nInversion: AUTO\nModulation: QAM256\n", freq);
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_ATSC, (struct Multiplex_s *)(void *)0, ScanFullATSC__1__2__1__1__2__docs);
      }
    }
  }

  ObjectRefDecImpl((void *)muxList, "commands/cmd_scanning.c", 939);
  ObjectRefDecImpl((void *)muxFreqList, "commands/cmd_scanning.c", 940);
}

// ScanFullDVBC
// file commands/cmd_scanning.c line 729
static void ScanFullDVBC(void)
{
  signed int channel;
  char *inversion;
  char *modulations[6l];
  signed int nrofModulations = 0;
  unsigned int symbolRates[2l] = { (unsigned int)6900000, (unsigned int)6875000 };
  signed int nrofSymbolRates = 2;
  char *code_rate;
  struct DVBAdapter_s *adapter;
  adapter=MainDVBAdapterGet();
  struct MultiplexList_s *muxList;
  muxList=MultiplexGetAll();
  struct MuxFrequencies_s *muxFreqList;
  muxFreqList=ParseMuxListFrequencies(muxList);
  _Bool return_value_DVBFrontEndParameterSupported_1;
  return_value_DVBFrontEndParameterSupported_1=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBC, "Inversion", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_1 == (_Bool)0))
    inversion = AUTO;

  else
  {
    LogModule(1, SCANNING, "INVERSION_AUTO not supported, trying INVERSION_OFF.\n");
    inversion = "OFF";
  }
  _Bool return_value_DVBFrontEndParameterSupported_2;
  return_value_DVBFrontEndParameterSupported_2=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBC, "Modulation", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_2 == (_Bool)0))
  {
    modulations[(signed long int)0] = AUTO;
    nrofModulations = 1;
  }

  else
  {
    LogModule(1, SCANNING, "QAM_AUTO not supported, trying QAM_64.\n");
    modulations[(signed long int)0] = "QAM64";
    modulations[(signed long int)1] = "QAM128";
    modulations[(signed long int)2] = "QAM256";
    nrofModulations = 3;
  }
  _Bool return_value_DVBFrontEndParameterSupported_3;
  return_value_DVBFrontEndParameterSupported_3=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBC, "FEC", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_3 == (_Bool)0))
    code_rate = AUTO;

  else
  {
    LogModule(1, SCANNING, "FEC_AUTO not supported, trying FEC_NONE.\n");
    code_rate = NONE;
  }
  channel = 2;
  for( ; cancelScan == (_Bool)0 && !(channel >= 5); channel = channel + 1)
    TryTuneDVBC(muxList, muxFreqList, (unsigned int)(36500000 + channel * 7000000), inversion, code_rate, symbolRates, nrofSymbolRates, modulations, nrofModulations);
  channel = 1;
  for( ; cancelScan == (_Bool)0 && !(channel >= 11); channel = channel + 1)
    TryTuneDVBC(muxList, muxFreqList, (unsigned int)(100500000 + channel * 7000000), inversion, code_rate, symbolRates, nrofSymbolRates, modulations, nrofModulations);
  channel = 1;
  for( ; cancelScan == (_Bool)0 && !(channel >= 10); channel = channel + 1)
    TryTuneDVBC(muxList, muxFreqList, (unsigned int)(97000000 + channel * 8000000), inversion, code_rate, symbolRates, nrofSymbolRates, modulations, nrofModulations);
  channel = 5;
  for( ; cancelScan == (_Bool)0 && !(channel >= 23); channel = channel + 1)
    TryTuneDVBC(muxList, muxFreqList, (unsigned int)(142500000 + channel * 7000000), inversion, code_rate, symbolRates, nrofSymbolRates, modulations, nrofModulations);
  channel = 21;
  for( ; cancelScan == (_Bool)0 && !(channel >= 91); channel = channel + 1)
    TryTuneDVBC(muxList, muxFreqList, (unsigned int)(138000000 + channel * 8000000), inversion, code_rate, symbolRates, nrofSymbolRates, modulations, nrofModulations);
  ObjectRefDecImpl((void *)muxList, "commands/cmd_scanning.c", 800);
  ObjectRefDecImpl((void *)muxFreqList, "commands/cmd_scanning.c", 801);
}

// ScanFullDVBT
// file commands/cmd_scanning.c line 543
static void ScanFullDVBT(void)
{
  char *inversion;
  char *constellation;
  char *transmit_mode;
  char *guard_interval;
  char *hierarchy;
  char *code_rate;
  struct DVBAdapter_s *adapter;
  adapter=MainDVBAdapterGet();
  signed int channel;
  signed int channelCount = 0;
  signed int totalChannels = 0;
  struct MultiplexList_s *muxList;
  muxList=MultiplexGetAll();
  struct MuxFrequencies_s *muxFreqList;
  muxFreqList=ParseMuxListFrequencies(muxList);
  struct Multiplex_s *mux;
  signed int offsetIndex = 0;
  unsigned int frequency;
  unsigned int offsets[3l] = { (unsigned int)-166670, (unsigned int)0, (unsigned int)166670 };
  _Bool return_value_DVBFrontEndParameterSupported_1;
  return_value_DVBFrontEndParameterSupported_1=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBT, "Inversion", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_1 == (_Bool)0))
    inversion = AUTO;

  else
  {
    LogModule(1, SCANNING, "INVERSION_AUTO not supported, trying INVERSION_OFF.\n");
    inversion = "OFF";
  }
  _Bool return_value_DVBFrontEndParameterSupported_2;
  return_value_DVBFrontEndParameterSupported_2=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBT, "Modulation", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_2 == (_Bool)0))
    constellation = AUTO;

  else
  {
    LogModule(1, SCANNING, "QAM_AUTO not supported, trying QAM_64.\n");
    constellation = "QAM64";
  }
  _Bool return_value_DVBFrontEndParameterSupported_3;
  return_value_DVBFrontEndParameterSupported_3=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBT, "Transmission Mode", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_3 == (_Bool)0))
    transmit_mode = AUTO;

  else
  {
    LogModule(1, SCANNING, "TRANSMISSION_MODE not supported, trying TRANSMISSION_MODE_8K.\n");
    transmit_mode = "8K";
  }
  _Bool return_value_DVBFrontEndParameterSupported_4;
  return_value_DVBFrontEndParameterSupported_4=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBT, "Guard Interval", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_4 == (_Bool)0))
    guard_interval = AUTO;

  else
  {
    LogModule(1, SCANNING, "GUARD_INTERVAL_AUTO not supported, trying GUARD_INTERVAL_1_8.\n");
    guard_interval = "1/8";
  }
  _Bool return_value_DVBFrontEndParameterSupported_5;
  return_value_DVBFrontEndParameterSupported_5=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBT, "Hierarchy", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_5 == (_Bool)0))
    hierarchy = AUTO;

  else
  {
    LogModule(1, SCANNING, "HIERARCHY_AUTO not supported, trying HIERARCHY_NONE.\n");
    hierarchy = NONE;
  }
  _Bool return_value_DVBFrontEndParameterSupported_6;
  return_value_DVBFrontEndParameterSupported_6=DVBFrontEndParameterSupported(adapter, (enum DVBDeliverySystem_e)DELSYS_DVBT, "FEC", AUTO);
  if(!(return_value_DVBFrontEndParameterSupported_6 == (_Bool)0))
    code_rate = AUTO;

  else
  {
    LogModule(1, SCANNING, "FEC_AUTO not supported, trying FEC_NONE.\n");
    code_rate = NONE;
  }
  if(!(DVBTScanVHF == (_Bool)0))
    totalChannels = totalChannels + 8;

  if(!(DVBTScanUHF == (_Bool)0))
    totalChannels = totalChannels + 49;

  CommandPrintf("Scanning %d frequencies\n", totalChannels);
  if(!(DVBTScanVHF == (_Bool)0))
  {
    channel = 5;
    for( ; cancelScan == (_Bool)0 && !(channel >= 13); channel = channel + 1)
    {
      frequency = (unsigned int)(142500000 + channel * 7000000);
      channelCount = channelCount + 1;
      offsetIndex = 0;
      for( ; !(offsetIndex >= 3); offsetIndex = offsetIndex + 1)
      {
        mux=FindMultiplexFrequency(muxList, muxFreqList, (unsigned long int)(frequency + offsets[(signed long int)offsetIndex]), 0, (char *)(void *)0, 0);
        if(!(mux == ((struct Multiplex_s *)NULL)))
          break;

      }
      if(!(mux == ((struct Multiplex_s *)NULL)))
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_DVBT, mux, (struct TuningParamDocs_s *)(void *)0);

      else
      {
        struct TuningParamDocs_s *docs;
        struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_7;
        return_value_ObjectCollectionCreateImpl_7=ObjectCollectionCreateImpl("TuningParamDocs_t", (unsigned int)3, "commands/cmd_scanning.c", 653);
        docs = (struct TuningParamDocs_s *)return_value_ObjectCollectionCreateImpl_7;
        offsetIndex = 0;
        for( ; !(offsetIndex >= 3); offsetIndex = offsetIndex + 1)
          asprintf(&docs->docs[(signed long int)offsetIndex], "Frequency: %d\nInversion: %s\nBandwidth: 7Mhz\nFEC LP: %s\nFEC HP: %s\nConstellation: %s\nTransmission Mode: %s\nGuard Interval: %s\nHierarchy: %s\n", frequency + offsets[(signed long int)offsetIndex], inversion, code_rate, code_rate, constellation, transmit_mode, guard_interval, hierarchy);
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_DVBT, (struct Multiplex_s *)(void *)0, docs);
      }
    }
  }

  if(!(DVBTScanUHF == (_Bool)0))
  {
    channel = 21;
    for( ; cancelScan == (_Bool)0 && !(channel >= 70); channel = channel + 1)
    {
      frequency = (unsigned int)(306000000 + channel * 8000000);
      channelCount = channelCount + 1;
      offsetIndex = 0;
      for( ; !(offsetIndex >= 3); offsetIndex = offsetIndex + 1)
      {
        mux=FindMultiplexFrequency(muxList, muxFreqList, (unsigned long int)(frequency + offsets[(signed long int)offsetIndex]), 0, (char *)(void *)0, 0);
        if(!(mux == ((struct Multiplex_s *)NULL)))
          break;

      }
      if(!(mux == ((struct Multiplex_s *)NULL)))
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_DVBT, mux, (struct TuningParamDocs_s *)(void *)0);

      else
      {
        struct TuningParamDocs_s *ScanFullDVBT__1__16__1__1__3__docs;
        struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_8;
        return_value_ObjectCollectionCreateImpl_8=ObjectCollectionCreateImpl("TuningParamDocs_t", (unsigned int)3, "commands/cmd_scanning.c", 700);
        ScanFullDVBT__1__16__1__1__3__docs = (struct TuningParamDocs_s *)return_value_ObjectCollectionCreateImpl_8;
        offsetIndex = 0;
        for( ; !(offsetIndex >= 3); offsetIndex = offsetIndex + 1)
          asprintf(&ScanFullDVBT__1__16__1__1__3__docs->docs[(signed long int)offsetIndex], "Frequency: %d\nInversion: %s\nBandwidth: 8Mhz\nFEC LP: %s\nFEC HP: %s\nConstellation: %s\nTransmission Mode: %s\nGuard Interval: %s\nHierarchy: %s\n", frequency + offsets[(signed long int)offsetIndex], inversion, code_rate, code_rate, constellation, transmit_mode, guard_interval, hierarchy);
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_DVBT, (struct Multiplex_s *)(void *)0, ScanFullDVBT__1__16__1__1__3__docs);
      }
    }
  }

  ObjectRefDecImpl((void *)muxList, "commands/cmd_scanning.c", 725);
  ObjectRefDecImpl((void *)muxFreqList, "commands/cmd_scanning.c", 726);
}

// ScanListAddEntry
// file commands/cmd_scanning.c line 1830
static void ScanListAddEntry(enum DVBDeliverySystem_e delSys, struct Multiplex_s *mux, struct TuningParamDocs_s *docs)
{
  struct ScanEntry_s *entry;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("ScanEntry_t", "commands/cmd_scanning.c", 1833);
  entry = (struct ScanEntry_s *)return_value_ObjectCreateImpl_1;
  entry->system = delSys;
  entry->mux = mux;
  entry->params = docs;
  if(toScan.start == ((struct ScanEntry_s *)NULL))
  {
    toScan.start = entry;
    toScan.current = entry;
  }

  else
    toScan.end->next = entry;
  toScan.end = entry;
  toScan.count = toScan.count + 1;
}

// ScanListNextEntry
// file commands/cmd_scanning.c line 1851
static struct ScanEntry_s * ScanListNextEntry(void)
{
  struct ScanEntry_s *entry = (struct ScanEntry_s *)(void *)0;
  if(!(toScan.current == ((struct ScanEntry_s *)NULL)))
  {
    entry = toScan.current;
    toScan.current = entry->next;
    toScan.pos = toScan.pos + 1;
  }

  return entry;
}

// ScanListReset
// file commands/cmd_scanning.c line 1815
static void ScanListReset(void)
{
  struct ScanEntry_s *entry = toScan.start;
  for( ; !(entry == ((struct ScanEntry_s *)NULL)); entry = entry->next)
    ObjectRefDecImpl((void *)entry, "commands/cmd_scanning.c", 1820);
  toScan.start = (struct ScanEntry_s *)(void *)0;
  toScan.end = (struct ScanEntry_s *)(void *)0;
  toScan.current = (struct ScanEntry_s *)(void *)0;
  toScan.count = 0;
  toScan.pos = 0;
}

// ScanNetwork
// file commands/cmd_scanning.c line 943
static void ScanNetwork(char *initialdata)
{
  struct Multiplex_s *mux;
  _Bool parsed = (_Bool)0;
  char modStr[7l];
  unsigned int symbolRate;
  char bwStr[5l];
  char fecHiStr[5l];
  char fecLoStr[5l];
  char transModeStr[5l];
  char guardIntStr[5l];
  char hierarchyStr[5l];
  char polarisationStr[2l];
  char params[256l];
  char *polarisation = (char *)(void *)0;
  char *inversion;
  enum DVBDeliverySystem_e delSys = (enum DVBDeliverySystem_e)DELSYS_MAX_SUPPORTED;
  unsigned int frequency;
  struct MultiplexList_s *muxList;
  muxList=MultiplexGetAll();
  struct MuxFrequencies_s *muxFreqList;
  muxFreqList=ParseMuxListFrequencies(muxList);
  struct DVBAdapter_s *adapter;
  adapter=MainDVBAdapterGet();
  signed int muxFindRange = 0;
  switch((signed int)initialdata[(signed long int)0])
  {
    case 84:
    {
      delSys = (enum DVBDeliverySystem_e)DELSYS_DVBT;
      break;
    }
    case 83:
    {
      delSys = (enum DVBDeliverySystem_e)DELSYS_DVBS;
      break;
    }
    case 67:
    {
      delSys = (enum DVBDeliverySystem_e)DELSYS_DVBC;
      break;
    }
    case 65:
      delSys = (enum DVBDeliverySystem_e)DELSYS_ATSC;
  }
  _Bool return_value_DVBFrontEndDeliverySystemSupported_1;
  return_value_DVBFrontEndDeliverySystemSupported_1=DVBFrontEndDeliverySystemSupported(adapter, delSys);
  signed int return_value_sscanf_3;
  signed int return_value_sscanf_4;
  signed int return_value_sscanf_5;
  signed int return_value_sscanf_6;
  if(return_value_DVBFrontEndDeliverySystemSupported_1 == (_Bool)0)
    do
    {
      struct CommandContext_t *context;
      context=CommandContextGet();
      context->errorNumber = (unsigned short int)0xffff;
      snprintf(context->errorMessage, (unsigned long int)256, "Frontend doesn't support the required delivery system!");
    }
    while((_Bool)0);

  else
  {
    _Bool return_value_DVBFrontEndParameterSupported_2;
    return_value_DVBFrontEndParameterSupported_2=DVBFrontEndParameterSupported(adapter, delSys, "Inversion", AUTO);
    if(!(return_value_DVBFrontEndParameterSupported_2 == (_Bool)0))
      inversion = AUTO;

    else
    {
      LogModule(1, SCANNING, "INVERSION_AUTO not supported, trying INVERSION_OFF.\n");
      inversion = "OFF";
    }
    switch((signed int)delSys)
    {
      case DELSYS_DVBT:
      {
        return_value_sscanf_3=sscanf(initialdata, "T %u %4s %4s %4s %6s %4s %4s %4s", &frequency, (const void *)bwStr, (const void *)fecHiStr, (const void *)fecLoStr, (const void *)modStr, (const void *)transModeStr, (const void *)guardIntStr, (const void *)hierarchyStr);
        if(return_value_sscanf_3 == 8)
        {
          sprintf(params, "Frequency: %u\nInversion: %s\nBandwidth: %s\nFEC HP: %s\nFEC LP: %s\nConstellation: %s\nTransmission Mode: %s\nGuard Interval: %s\nHierarchy: %s\n", frequency, inversion, (const void *)bwStr, (const void *)fecHiStr, (const void *)fecLoStr, (const void *)modStr, (const void *)transModeStr, (const void *)guardIntStr, (const void *)hierarchyStr);
          muxFindRange = 166670;
          parsed = (_Bool)1;
        }

        break;
      }
      case DELSYS_DVBC:
      {
        return_value_sscanf_4=sscanf(initialdata, "C %u %u %4s %6s", &frequency, &symbolRate, (const void *)fecHiStr, (const void *)modStr);
        if(return_value_sscanf_4 == 4)
        {
          sprintf(params, "Frequency: %u\nInversion: %s\nSymbol Rate: %u\nFEC: %s\nModulation: %s\n", frequency, inversion, symbolRate, (const void *)fecHiStr, (const void *)modStr);
          muxFindRange = 0;
          parsed = (_Bool)1;
        }

        break;
      }
      case DELSYS_DVBS:
      {
        return_value_sscanf_5=sscanf(initialdata, "S %u %1[HVLR] %u %4s\n", &frequency, (const void *)polarisationStr, &symbolRate, (const void *)fecHiStr);
        if(return_value_sscanf_5 == 4)
        {
          switch((signed int)polarisationStr[(signed long int)0])
          {
            case 76:
            {
              polarisation = "Left";
              break;
            }
            case 82:
            {
              polarisation = "Right";
              break;
            }
            case 72:
            {
              polarisation = "Horizontal";
              break;
            }
            case 86:

            default:
              polarisation = "Vertical";
          }
          sprintf(params, "Frequency: %u\nInversion: %s\nSymbol Rate: %u\nFEC: %s\nPolarisation: %s\nSatellite Number: %d\n", frequency, inversion, symbolRate, (const void *)fecHiStr, polarisation, DVBSSatNumber);
          muxFindRange = 0;
          parsed = (_Bool)1;
        }

        break;
      }
      case DELSYS_ATSC:
      {
        return_value_sscanf_6=sscanf(initialdata, "A %u %7s\n", &frequency, (const void *)modStr);
        if(return_value_sscanf_6 == 2)
        {
          sprintf(params, "Frequency: %u\nInversion: %s\nModulation: %s\n", frequency, inversion, (const void *)modStr);
          muxFindRange = 28615;
          parsed = (_Bool)1;
        }

        break;
      }
      default:
        ;
    }
    if(!(parsed == (_Bool)0))
    {
      transponderList=ListCreate();
      mux=FindMultiplexFrequency(muxList, muxFreqList, (unsigned long int)frequency, muxFindRange, polarisation, DVBSSatNumber);
      if(!(mux == ((struct Multiplex_s *)NULL)))
        ScanListAddEntry(delSys, mux, (struct TuningParamDocs_s *)(void *)0);

      else
      {
        struct TuningParamDocs_s *docs;
        struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_7;
        return_value_ObjectCollectionCreateImpl_7=ObjectCollectionCreateImpl("TuningParamDocs_t", (unsigned int)1, "commands/cmd_scanning.c", 1112);
        docs = (struct TuningParamDocs_s *)return_value_ObjectCollectionCreateImpl_7;
        docs->docs[(signed long int)0]=strdup(params);
        ScanListAddEntry(delSys, (struct Multiplex_s *)(void *)0, docs);
      }
      ScanStart((enum ScanType_e)ScanType_Network);
    }

    else
      do
      {
        struct CommandContext_t *ScanNetwork__1__7__1__context;
        ScanNetwork__1__7__1__context=CommandContextGet();
        ScanNetwork__1__7__1__context->errorNumber = (unsigned short int)0xffff;
        snprintf(ScanNetwork__1__7__1__context->errorMessage, (unsigned long int)256, "Failed to parse initial tuning data!");
      }
      while((_Bool)0);
  }
}

// ScanStart
// file commands/cmd_scanning.c line 1544
static void ScanStart(enum ScanType_e type)
{
  scanType = type;
  cancelScan = (_Bool)0;
  struct ev_loop *return_value_DispatchersGetInput_1;
  return_value_DispatchersGetInput_1=DispatchersGetInput();
  ev_async_send(return_value_DispatchersGetInput_1, &scanStartAsync);
}

// ScanStartStopWatcher
// file commands/cmd_scanning.c line 1557
static void ScanStartStopWatcher(struct ev_loop *loop, struct ev_async *w, signed int revents)
{
  if(!(cancelScan == (_Bool)0))
    ScanStateMachine((enum ScanEvent_e)ScanEvent_Cancel);

  else
  {
    currentScanState = (enum ScanState_e)ScanState_Init;
    previousScanState = currentScanState;
    ScanStateMachine((enum ScanEvent_e)ScanEvent_StateEntered);
  }
}

// ScanStateMachine
// file commands/cmd_scanning.c line 1577
static void ScanStateMachine(enum ScanEvent_e event)
{
  enum ScanEvent_e nextEvent;
  enum DVBDeliverySystem_e delSys;
  char *tuningParams;
  LogModule(2, SCANNING, "ScanStateMachine: event = %d", event);
  _Bool tmp_if_expr_3;
  _Bool return_value_MainIsDVB_2;
  for( ; !((signed int)event == ScanEvent_NoEvent); event = nextEvent)
  {
    nextEvent = (enum ScanEvent_e)ScanEvent_NoEvent;
    previousScanState = currentScanState;
    switch((signed int)currentScanState)
    {
      case ScanState_Init:
      {
        if((signed int)event == ScanEvent_StateEntered)
        {
          EventsFireEventListeners(scanStartEvent, (void *)0);
          struct ev_loop *return_value_DispatchersGetInput_1;
          return_value_DispatchersGetInput_1=DispatchersGetInput();
          ev_timer_start(return_value_DispatchersGetInput_1, &timeoutTimer);
          currentService=TuningCurrentServiceGet();
          TuningCurrentServiceLock();
          PMTCount = 253;
          memset((void *)PMTsReceived, 0, sizeof(struct PMTReceived_t [253l]) /*1518ul*/ );
          toScan.current = toScan.start;
          currentScanState = (enum ScanState_e)ScanState_NextMux;
        }

        break;
      }      static signed int timeout = 0;
      case ScanState_NextMux:
      {
        switch((signed int)event)
        {          static struct ScanEntry_s *currentEntry = (struct ScanEntry_s *)(void *)0;          static signed int currentTuningParams = 0;
          case ScanEvent_StateEntered:
          {
            EventsFireEventListeners(scanTryingMuxEvent, (void *)0);
            currentTuningParams = -1;
            currentEntry=ScanListNextEntry();
            if(!(currentEntry == ((struct ScanEntry_s *)NULL)))
              nextEvent = (enum ScanEvent_e)ScanEvent_NextTuningParams;

            else
              currentScanState = (enum ScanState_e)ScanState_Stopping;
            break;
          }
          case ScanEvent_NextTuningParams:
          {
            currentTuningParams = currentTuningParams + 1;
            tuningParams = (char *)(void *)0;
            if(!(currentEntry->mux == ((struct Multiplex_s *)NULL)))
            {
              if(currentTuningParams == 0)
              {
                delSys = currentEntry->mux->deliverySystem;
                tuningParams = currentEntry->mux->tuningParams;
              }

            }

            else
              if(!(currentTuningParams >= currentEntry->params->nrofDocs))
              {
                delSys = currentEntry->system;
                tuningParams = currentEntry->params->docs[(signed long int)currentTuningParams];
              }

            switch((signed int)delSys)
            {
              case DELSYS_DVBT:

              case DELSYS_ATSC:
              {
                timeout = lockTimeoutT;
                break;
              }
              case DELSYS_DVBC:
              {
                timeout = lockTimeoutC;
                break;
              }
              case DELSYS_DVBS:

              case DELSYS_DVBS2:

              default:
                timeout = lockTimeoutS;
            }
            if(!(tuningParams == ((char *)NULL)))
            {
              struct TSReader_t *tsReader;
              tsReader=MainTSReaderGet();
              struct DVBAdapter_s *adapter;
              adapter=MainDVBAdapterGet();
              TSReaderEnable(tsReader, (_Bool)0);
              DVBFrontEndTune(adapter, delSys, tuningParams);
            }

            else
              nextEvent = (enum ScanEvent_e)ScanEvent_StateEntered;
            break;
          }
          case ScanEvent_FELocked:
          {
            if(currentEntry->mux == ((struct Multiplex_s *)NULL))
            {
              struct DVBAdapter_s *ScanStateMachine__1__1__1__1__2__8__adapter;
              ScanStateMachine__1__1__1__1__2__8__adapter=MainDVBAdapterGet();
              enum DVBDeliverySystem_e ScanStateMachine__1__1__1__1__2__8__delSys;
              char *ScanStateMachine__1__1__1__1__2__8__tuningParams;
              ScanStateMachine__1__1__1__1__2__8__tuningParams=DVBFrontEndParametersGet(ScanStateMachine__1__1__1__1__2__8__adapter, &ScanStateMachine__1__1__1__1__2__8__delSys);
              MultiplexAdd(ScanStateMachine__1__1__1__1__2__8__delSys, ScanStateMachine__1__1__1__1__2__8__tuningParams, &currentEntry->mux);
              free((void *)ScanStateMachine__1__1__1__1__2__8__tuningParams);
              EventsFireEventListeners(scanMuxAddedEvent, (void *)0);
            }

            TuningCurrentMultiplexSet(currentEntry->mux);
            currentScanState = (enum ScanState_e)ScanState_WaitingForTables;
            break;
          }
          case ScanEvent_TimerTick:
          {
            timeout = timeout - 1;
            if(!(timeout >= 1))
            {
              nextEvent = (enum ScanEvent_e)ScanEvent_NextTuningParams;
              if(!(removeFailedFreqs == (_Bool)0))
              {
                if(!(currentEntry->mux == ((struct Multiplex_s *)NULL)))
                  MultiplexDelete(currentEntry->mux);

              }

            }

          }
        }
        break;
      }
      case ScanState_WaitingForTables:
      {
        static _Bool SDTReceived = (_Bool)0;
        static _Bool PMTReceived = (_Bool)0;
        static _Bool PATReceived = (_Bool)0;
        switch((signed int)event)
        {
          case ScanEvent_StateEntered:
          {
            PATReceived = (_Bool)0;
            PMTReceived = (_Bool)0;
            SDTReceived = (_Bool)0;
            timeout = tablesTimeout;
            break;
          }
          case ScanEvent_PATReceived:
          {
            PATReceived = (_Bool)1;
            break;
          }
          case ScanEvent_PMTsReceived:
          {
            PMTReceived = (_Bool)1;
            break;
          }
          case ScanEvent_SDTReceived:
          {
            SDTReceived = (_Bool)1;
            break;
          }
          case ScanEvent_TimerTick:
          {
            timeout = timeout - 1;
            if(!(timeout >= 1))
              currentScanState = (enum ScanState_e)ScanState_NextMux;

          }
        }
        if(!(PATReceived == (_Bool)0) && !(PMTReceived == (_Bool)0) && !(SDTReceived == (_Bool)0))
        {
          if((signed int)scanType == ScanType_Network)
          {
            return_value_MainIsDVB_2=MainIsDVB();
            tmp_if_expr_3 = return_value_MainIsDVB_2 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
            currentScanState = (enum ScanState_e)ScanState_WaitingForNIT;

          else
            currentScanState = (enum ScanState_e)ScanState_NextMux;
        }

        break;
      }
      case ScanState_WaitingForNIT:
      {
        switch((signed int)event)
        {
          case ScanEvent_StateEntered:
          {
            timeout = tablesTimeout;
            break;
          }
          case ScanEvent_TimerTick:
          {
            timeout = timeout - 1;
            if(!(timeout >= 1))
            {
              ProcessTransponderList();
              currentScanState = (enum ScanState_e)ScanState_NextMux;
            }

          }
        }
        break;
      }
      case ScanState_Canceling:
      {
        if((signed int)event == ScanEvent_StateEntered)
        {
          EventsFireEventListeners(scanCanceledEvent, (void *)0);
          currentScanState = (enum ScanState_e)ScanState_Stopping;
        }

        break;
      }
      case ScanState_Stopping:
      {
        if((signed int)event == ScanEvent_StateEntered)
        {
          TuningCurrentServiceUnlock();
          TuningCurrentServiceRetune();
          if(!(transponderList == ((struct List_s *)NULL)))
          {
            ListFree(transponderList, ListFreeObject);
            transponderList = (struct List_s *)(void *)0;
          }

          ScanListReset();
          struct ev_loop *return_value_DispatchersGetInput_4;
          return_value_DispatchersGetInput_4=DispatchersGetInput();
          ev_timer_stop(return_value_DispatchersGetInput_4, &timeoutTimer);
          currentScanState = (enum ScanState_e)ScanState_Stopped;
        }

        break;
      }
      case ScanState_Stopped:
        if((signed int)event == ScanEvent_StateEntered)
          EventsFireEventListeners(scanEndEvent, (void *)0);

        else
          if((signed int)event == ScanEvent_Cancel)
            event = (enum ScanEvent_e)ScanEvent_NoEvent;

    }
    if((signed int)event == ScanEvent_Cancel)
      currentScanState = (enum ScanState_e)ScanState_Canceling;

    if(!(currentScanState == previousScanState))
    {
      LogModule(2, SCANNING, "Previous State (%d) != Current State(%d)", previousScanState, currentScanState);
      nextEvent = (enum ScanEvent_e)ScanEvent_StateEntered;
    }

    LogModule(2, SCANNING, "State %d Next Event = %d", currentScanState, nextEvent);
  }
}

// ScanStop
// file commands/cmd_scanning.c line 1551
static void ScanStop(void)
{
  cancelScan = (_Bool)1;
  struct ev_loop *return_value_DispatchersGetInput_1;
  return_value_DispatchersGetInput_1=DispatchersGetInput();
  ev_async_send(return_value_DispatchersGetInput_1, &scanStartAsync);
}

// ScanningInProgressGet
// file commands/cmd_scanning.c line 1918
static signed int ScanningInProgressGet(void *userArg, struct PropertyValue_s *value)
{
  value->type = (enum PropertyType_e)PropertyType_Boolean;
  value->u.boolean = (signed int)currentScanState != ScanState_Stopped;
  return 0;
}

// SectionFilterListAddFilter
// file ts.c line 685
static void SectionFilterListAddFilter(struct TSReader_t *reader, struct TSSectionFilter_t *filter)
{
  struct TSSectionFilterList_t *sfList;
  sfList=SectionFilterListFind(reader, filter->pid);
  if(sfList == ((struct TSSectionFilterList_t *)NULL))
  {
    sfList=SectionFilterListCreate(reader, filter->pid);
    if(!(sfList == ((struct TSSectionFilterList_t *)NULL)))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    ListAdd(sfList->filters, (void *)filter);
    SectionFilterListUpdatePriority(sfList);
    SectionFilterListScheduleFilters(reader);
  }
}

// SectionFilterListCreate
// file ts.c line 656
static struct TSSectionFilterList_t * SectionFilterListCreate(struct TSReader_t *reader, unsigned short int pid)
{
  struct TSSectionFilterList_t *sfList;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("TSSectionFilterList_t", "ts.c", 658);
  sfList = (struct TSSectionFilterList_t *)return_value_ObjectCreateImpl_1;
  sfList->pid = pid;
  sfList->filters=ListCreate();
  sfList->tsReader = reader;
  sfList->sectionHandle=dvbpsi_AttachSections(SectionFilterListPushSection, (void *)sfList);
  ListAdd(reader->sectionFilters, (void *)sfList);
  return sfList;
}

// SectionFilterListDescheduleFilters
// file ts.c line 790
static void SectionFilterListDescheduleFilters(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  LogModule(3, TSREADER, "Descheduling section filters");
  iterator.current = reader->activeSectionFilters->head;
  iterator.list = reader->activeSectionFilters;
  while(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct TSSectionFilterList_t *sfList = (struct TSSectionFilterList_t *)iterator.current->data;
    PacketFilterListRemoveFilter(sfList->tsReader, sfList->packetFilter);
    sfList->packetFilter = (struct TSPacketFilter_t *)(void *)0;
    ListRemoveCurrent(&iterator);
    ListAdd(reader->sectionFilters, (void *)sfList);
  }
}

// SectionFilterListDescheduleOneFilter
// file ts.c line 804
static void SectionFilterListDescheduleOneFilter(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  struct TSSectionFilterList_t *toDeschedule = (struct TSSectionFilterList_t *)(void *)0;
  LogModule(3, TSREADER, "Descheduling one section filter");
  iterator.current = reader->activeSectionFilters->head;
  iterator.list = reader->activeSectionFilters;
  _Bool tmp_if_expr_2;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSSectionFilterList_t *sfList = (struct TSSectionFilterList_t *)iterator.current->data;
    if(reader->packetFilters[(signed long int)sfList->pid] == sfList->packetFilter)
    {
      if(sfList->packetFilter->flNext == ((struct TSPacketFilter_t *)NULL))
      {
        if(toDeschedule == ((struct TSSectionFilterList_t *)NULL))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = toDeschedule->priority < sfList->priority ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          toDeschedule = sfList;

      }

    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  if(!(toDeschedule == ((struct TSSectionFilterList_t *)NULL)))
  {
    LogModule(3, TSREADER, "Chose %d to deschedule.", toDeschedule->pid);
    ListRemove(reader->activeSectionFilters, (void *)toDeschedule);
    ListAdd(reader->sectionFilters, (void *)toDeschedule);
    PacketFilterListRemoveFilter(reader, toDeschedule->packetFilter);
    toDeschedule->packetFilter = (struct TSPacketFilter_t *)(void *)0;
  }

}

// SectionFilterListDestroy
// file ts.c line 667
static void SectionFilterListDestroy(struct TSReader_t *reader, struct TSSectionFilterList_t *sfList)
{
  _Bool return_value_ListRemove_1;
  return_value_ListRemove_1=ListRemove(reader->activeSectionFilters, (void *)sfList);
  if(!(return_value_ListRemove_1 == (_Bool)0))
  {
    LogModule(3, TSREADER, "Removed active section filter %p", sfList);
    PacketFilterListRemoveFilter(reader, sfList->packetFilter);
  }

  else
  {
    LogModule(3, TSREADER, "Removed section filter %p", sfList);
    ListRemove(reader->sectionFilters, (void *)sfList);
  }
  ListFree(sfList->filters, (void (*)(void *))(void *)0);
  dvbpsi_DetachSections(sfList->sectionHandle);
  ObjectRefDecImpl((void *)sfList, "ts.c", 682);
}

// SectionFilterListFind
// file ts.c line 748
static struct TSSectionFilterList_t * SectionFilterListFind(struct TSReader_t *reader, unsigned short int pid)
{
  struct ListIterator_s iterator;
  iterator.current = reader->activeSectionFilters->head;
  iterator.list = reader->activeSectionFilters;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSSectionFilterList_t *sfList = (struct TSSectionFilterList_t *)iterator.current->data;
    if(sfList->pid == pid)
      return sfList;

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  iterator.current = reader->sectionFilters->head;
  iterator.list = reader->sectionFilters;
  struct ListEntry_s *tmp_if_expr_2;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_2)
  {
    struct TSSectionFilterList_t *SectionFilterListFind__1__2__1__sfList = (struct TSSectionFilterList_t *)iterator.current->data;
    if(SectionFilterListFind__1__2__1__sfList->pid == pid)
      return SectionFilterListFind__1__2__1__sfList;

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_2 = iterator.current->next;

    else
      tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
  }
  return (struct TSSectionFilterList_t *)(void *)0;
}

// SectionFilterListPacketCallback
// file ts.c line 833
static void SectionFilterListPacketCallback(void *userArg, struct TSFilterGroup_t *group, struct TSPacket_t *packet)
{
  struct TSSectionFilterList_t *sfList = (struct TSSectionFilterList_t *)userArg;
  if(!((1u & sfList->flags) == 0u))
  {
    if(!((0x40 & (signed int)packet->header[1l]) == 0x40))
      goto __CPROVER_DUMP_L3;

    sfList->flags = sfList->flags & (unsigned int)~1;
  }

  dvbpsi_PushPacket(sfList->sectionHandle, (unsigned char *)packet);

__CPROVER_DUMP_L3:
  ;
}

// SectionFilterListPushSection
// file ts.c line 847
static void SectionFilterListPushSection(void *userArg, struct dvbpsi_decoder_s *sectionsHandle, struct dvbpsi_psi_section_s *section)
{
  struct TSSectionFilterList_t *sfList = (struct TSSectionFilterList_t *)userArg;
  struct ListIterator_s iterator;
  struct dvbpsi_psi_section_s *cloned;
  iterator.current = sfList->filters->head;
  iterator.list = sfList->filters;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSSectionFilter_t *filter = (struct TSSectionFilter_t *)iterator.current->data;
    cloned=dvbpsi_ClonePSISection(filter->sectionHandle, section);
    if(!(filter->group == ((struct TSFilterGroup_t *)NULL)))
      filter->group->sectionsProcessed = filter->group->sectionsProcessed + 1ull;

    dvbpsi_PushSection(filter->sectionHandle, cloned);
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  dvbpsi_ReleasePSISections(sfList->sectionHandle, section);
  if(!(sfList->packetFilter == ((struct TSPacketFilter_t *)NULL)))
  {
    if(!(sfList->tsReader->sectionFilters->count == 0))
    {
      ListRemove(sfList->tsReader->activeSectionFilters, (void *)sfList);
      ListAdd(sfList->tsReader->sectionFilters, (void *)sfList);
      PacketFilterListRemoveFilter(sfList->tsReader, sfList->packetFilter);
      sfList->packetFilter = (struct TSPacketFilter_t *)(void *)0;
    }

  }

}

// SectionFilterListRemoveFilter
// file ts.c line 701
static void SectionFilterListRemoveFilter(struct TSReader_t *reader, struct TSSectionFilter_t *filter)
{
  struct TSSectionFilterList_t *sfList;
  sfList=SectionFilterListFind(reader, filter->pid);
  if(!(sfList == ((struct TSSectionFilterList_t *)NULL)))
  {
    ListRemove(sfList->filters, (void *)filter);
    if(sfList->filters->count == 0)
      SectionFilterListDestroy(reader, sfList);

    else
      SectionFilterListUpdatePriority(sfList);
  }

}

// SectionFilterListScheduleFilters
// file ts.c line 771
static void SectionFilterListScheduleFilters(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  LogModule(3, TSREADER, "Scheduling section filters");
  iterator.current = reader->sectionFilters->head;
  iterator.list = reader->sectionFilters;
  while(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct TSSectionFilterList_t *sfList = (struct TSSectionFilterList_t *)iterator.current->data;
    sfList->flags = sfList->flags | (unsigned int)1;
    sfList->packetFilter=PacketFilterListAddFilter(reader, (struct TSFilterGroup_t *)(void *)0, sfList->pid, SectionFilterListPacketCallback, (void *)sfList);
    if(sfList->packetFilter == ((struct TSPacketFilter_t *)NULL))
      break;

    ListRemoveCurrent(&iterator);
    ListAdd(reader->activeSectionFilters, (void *)sfList);
  }
}

// SectionFilterListUpdatePriority
// file ts.c line 718
static void SectionFilterListUpdatePriority(struct TSSectionFilterList_t *sfList)
{
  struct ListIterator_s iterator;
  _Bool first = (_Bool)1;
  signed int currentPriority = 0;
  struct ListEntry_s *tmp_if_expr_1;
  if((2u & sfList->flags) == 0u)
  {
    iterator.current = sfList->filters->head;
    iterator.list = sfList->filters;
    for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
    {
      struct TSSectionFilter_t *filter = (struct TSSectionFilter_t *)iterator.current->data;
      if(!(first == (_Bool)0))
      {
        currentPriority = filter->priority;
        first = (_Bool)0;
      }

      else
        if(!(filter->priority >= currentPriority))
          currentPriority = filter->priority;

      if(!(iterator.current == ((struct ListEntry_s *)NULL)))
        tmp_if_expr_1 = iterator.current->next;

      else
        tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
    }
    sfList->priority = currentPriority;
  }

}

// SendToPacketFilters
// file ts.c line 935
static void SendToPacketFilters(struct TSReader_t *reader, unsigned short int pid, struct TSPacket_t *packet)
{
  struct TSPacketFilter_t *cur;
  struct TSPacketFilter_t *prev = (struct TSPacketFilter_t *)(void *)0;
  struct TSPacketFilter_t *next;
  if(!(reader->packetFilters[(signed long int)pid] == ((struct TSPacketFilter_t *)NULL)))
  {
    reader->currentlyProcessingPid = pid;
    cur = reader->packetFilters[(signed long int)pid];
    for( ; !(cur == ((struct TSPacketFilter_t *)NULL)); cur = cur->flNext)
      if((0x8000 & (signed int)cur->pid) == 0)
      {
        if(!(cur->group == ((struct TSFilterGroup_t *)NULL)))
          cur->group->packetsProcessed = cur->group->packetsProcessed + 1ull;

        cur->callback(cur->userArg, cur->group, packet);
      }

    reader->currentlyProcessingPid = (unsigned short int)0xffff;
    cur = reader->packetFilters[(signed long int)pid];
    for( ; !(cur == ((struct TSPacketFilter_t *)NULL)); cur = next)
    {
      next = cur->flNext;
      if(!((0x8000 & (signed int)cur->pid) == 0))
      {
        LogModule(3, TSREADER, "Removing %p (%d) as marked as disabled", cur, (signed int)cur->pid & 0x7fff);
        if(prev == ((struct TSPacketFilter_t *)NULL))
          reader->packetFilters[(signed long int)pid] = cur->flNext;

        else
          prev->flNext = cur->flNext;
        ObjectRefDecImpl((void *)cur, "ts.c", 970);
      }

      else
        prev = cur;
    }
    if(reader->packetFilters[(signed long int)pid] == ((struct TSPacketFilter_t *)NULL))
    {
      if(reader->promiscuousMode == (_Bool)0)
      {
        if(!((signed int)pid == 8192))
          DVBDemuxReleaseFilter(reader->adapter, pid);

      }

      SectionFilterListScheduleFilters(reader);
    }

  }

}

// ServiceAdd
// file services.c line 132
signed int ServiceAdd(signed int uid, char *name, signed int id, signed int source)
{
  struct Service_t *service = (struct Service_t *)(void *)0;
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("INSERT INTO Services(mplexuid,id,source,ca,type,pmtpid,name)VALUES (%d,%d,%d,%d,%d,%d,'%q');", uid, id, source, 0, ServiceType_Unknown, 8191, name);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceAdd", 148, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_4;
        return_value_DBaseConnectionGet_4=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_5;
        return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceAdd", 151, rc, return_value_sqlite3_errmsg_5);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  void *return_value_ObjectCreateImpl_6;
  return_value_ObjectCreateImpl_6=ObjectCreateImpl("Service_t", "services.c", 156);
  service = (struct Service_t *)return_value_ObjectCreateImpl_6;
  service->multiplexUID = uid;
  service->id = id;
  service->name=strdup(name);
  service->source = source;
  service->conditionalAccess = (_Bool)0;
  service->type = (enum anonymous)ServiceType_Unknown;
  service->pmtPID = 8191;
  EventsFireEventListeners(serviceAddedEvent, (void *)service);
  do
    if(!(service == ((struct Service_t *)NULL)))
      ObjectRefDecImpl((void *)service, "services.c", 165);

  while((_Bool)0);
  return 0;
}

// ServiceConditionalAccessSet
// file services.c line 249
signed int ServiceConditionalAccessSet(struct Service_t *service, _Bool ca)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Services SET ca=%d WHERE mplexuid=%d AND id=%d;", ca, service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceConditionalAccessSet", 257, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  if(rc == 101)
  {
    service->conditionalAccess = ca;
    rc = 0;
  }

  else
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_4;
      return_value_DBaseConnectionGet_4=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_5;
      return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceConditionalAccessSet", 267, rc, return_value_sqlite3_errmsg_5);
    }
    while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// ServiceCreateList
// file services.c line 596
static struct List_s * ServiceCreateList(void *enumerator)
{
  struct List_s *list;
  list=ListCreate();
  struct Service_t *service = (struct Service_t *)(void *)0;
  do
  {
    service=ServiceGetNext(enumerator);
    if(!(service == ((struct Service_t *)NULL)))
      ListAdd(list, (void *)service);

  }
  while(!(service == ((struct Service_t *)NULL)));
  ServiceEnumeratorDestroy(enumerator);
  return list;
}

// ServiceDeInit
// file ../include/services.h line 122
signed int ServiceDeInit(void)
{
  EventsUnregisterSource(servicesSource);
  return 0;
}

// ServiceDefaultAuthoritySet
// file services.c line 328
signed int ServiceDefaultAuthoritySet(struct Service_t *service, char *defaultAuthority)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Services SET defauthority='%q' WHERE mplexuid=%d AND id=%d;", defaultAuthority, service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceDefaultAuthoritySet", 336, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(rc == 101)
  {
    if(service->defaultAuthority == ((char *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(defaultAuthority, service->defaultAuthority);
      tmp_if_expr_5 = return_value_strcmp_4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      if(!(service->defaultAuthority == ((char *)NULL)))
        free((void *)service->defaultAuthority);

      service->defaultAuthority=strdup(defaultAuthority);
    }

    rc = 0;
  }

  else
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_6;
      return_value_DBaseConnectionGet_6=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_7;
      return_value_sqlite3_errmsg_7=sqlite3_errmsg(return_value_DBaseConnectionGet_6);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceDefaultAuthoritySet", 353, rc, return_value_sqlite3_errmsg_7);
    }
    while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// ServiceDelete
// file services.c line 98
signed int ServiceDelete(struct Service_t *service)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("DELETE FROM Services WHERE mplexuid=%d AND id=%d;", service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceDelete", 105, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  EventsFireEventListeners(serviceDeletedEvent, (void *)service);
  return 0;
}

// ServiceDeleteAll
// file ../include/services.h line 143
signed int ServiceDeleteAll(struct Multiplex_s *mux)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("DELETE FROM Services WHERE mplexuid=%d;", mux->uid);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceDeleteAll", 122, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  rc=sqlite3_finalize(stmt);
  EventsFireEventListeners(serviceAllDeletedEvent, (void *)mux);
  return 0;
}

// ServiceDestructor
// file services.c line 646
static void ServiceDestructor(void *arg)
{
  struct Service_t *service = (struct Service_t *)arg;
  if(!(service->name == ((char *)NULL)))
    free((void *)service->name);

  if(!(service->provider == ((char *)NULL)))
    free((void *)service->provider);

  if(!(service->defaultAuthority == ((char *)NULL)))
    free((void *)service->defaultAuthority);

}

// ServiceEnumeratorDestroy
// file services.c line 513
void ServiceEnumeratorDestroy(void *enumerator)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)enumerator;
  rc=sqlite3_finalize(stmt);
}

// ServiceEnumeratorForMultiplex
// file services.c line 457
void * ServiceEnumeratorForMultiplex(struct Multiplex_s *multiplex)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Services.mplexuid=Multiplexes.uid AND Services.mplexuid=%d;", multiplex->uid);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceEnumeratorForMultiplex", 466, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (void *)0;
    }

  while((_Bool)0);
  return (void *)stmt;
}

// ServiceEnumeratorGet
// file services.c line 437
void * ServiceEnumeratorGet()
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  struct sqlite3 *return_value_DBaseConnectionGet_1;
  return_value_DBaseConnectionGet_1=DBaseConnectionGet();
  rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, "SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Services.mplexuid=Multiplexes.uid;", -1, &stmt, (const char **)(void *)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceEnumeratorGet", 443, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (void *)0;
    }

  while((_Bool)0);
  return (void *)stmt;
}

// ServiceEventToString
// file ../include/services.h line 379
signed int ServiceEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload)
{
  struct Service_t *service = (struct Service_t *)payload;
  char idStr[20l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char *name = idStr;
  signed int mappingId;
  mappingId=yaml_document_add_mapping(document, (unsigned char *)"tag:yaml.org,2002:map", (enum yaml_mapping_style_e)YAML_ANY_MAPPING_STYLE);
  if(!(service == ((struct Service_t *)NULL)))
  {
    sprintf(idStr, "%04x.%04x.%04x", service->networkId & 0xffff, service->tsId & 0xffff, service->id & 0xffff);
    name = service->name;
  }

  YamlUtils_MappingAdd(document, mappingId, "Service ID", idStr);
  YamlUtils_MappingAdd(document, mappingId, "Service Name", name);
  return mappingId;
}

// ServiceFilterAVSOnlyGet
// file servicefilter.c line 299
_Bool ServiceFilterAVSOnlyGet(struct ServiceFilter_s *filter)
{
  return filter->avsOnly;
}

// ServiceFilterAVSOnlySet
// file servicefilter.c line 282
void ServiceFilterAVSOnlySet(struct ServiceFilter_s *filter, _Bool enable)
{
  if(!(enable == filter->avsOnly))
  {
    TSFilterGroupRemoveAllFilters(filter->tsgroup);
    filter->avsOnly = enable;
    if(!(filter->service == ((struct Service_t *)NULL)))
    {
      if(!(filter->avsOnly == (_Bool)0))
        ServiceFilterPMTRewrite(filter);

      ServiceFilterAllocateFilters(filter);
    }

  }

}

// ServiceFilterAllocateFilters
// file servicefilter.c line 547
static void ServiceFilterAllocateFilters(struct ServiceFilter_s *filter)
{
  signed int muxUID;
  struct Multiplex_s *mux;
  mux=TuningCurrentMultiplexGet();
  _Bool tmp_if_expr_1;
  if(!(mux == ((struct Multiplex_s *)NULL)))
  {
    muxUID = mux->uid;
    do
      if(!(mux == ((struct Multiplex_s *)NULL)))
        ObjectRefDecImpl((void *)mux, "servicefilter.c", 559);

    while((_Bool)0);
    if(filter->service == ((struct Service_t *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = filter->service->multiplexUID != muxUID ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
    {
      pthread_mutex_lock(&filter->tsgroup->tsReader->mutex);
      TSFilterGroupAddPacketFilter(filter->tsgroup, (unsigned short int)0x00, ServiceFilterProcessPacket, (void *)filter);
      TSFilterGroupAddPacketFilter(filter->tsgroup, (unsigned short int)filter->service->pmtPID, ServiceFilterProcessPacket, (void *)filter);
      if(!(filter->avsOnly == (_Bool)0))
      {
        TSFilterGroupAddPacketFilter(filter->tsgroup, filter->pcrPID, ServiceFilterProcessPacket, (void *)filter);
        if(!((signed int)filter->audioPID == 0xffff))
        {
          if(!(filter->audioPID == filter->pcrPID))
            TSFilterGroupAddPacketFilter(filter->tsgroup, filter->audioPID, ServiceFilterProcessPacket, (void *)filter);

        }

        if(!((signed int)filter->videoPID == 0xffff))
        {
          if(!(filter->videoPID == filter->pcrPID))
            TSFilterGroupAddPacketFilter(filter->tsgroup, filter->videoPID, ServiceFilterProcessPacket, (void *)filter);

        }

        if(!((signed int)filter->subPID == 0xffff))
        {
          if(!(filter->subPID == filter->pcrPID))
            TSFilterGroupAddPacketFilter(filter->tsgroup, filter->subPID, ServiceFilterProcessPacket, (void *)filter);

        }

      }

      else
      {
        struct ProgramInfo_s *info;
        info=CacheProgramInfoGet(filter->service);
        if(!(info == ((struct ProgramInfo_s *)NULL)))
        {
          signed int i;
          if(!(info->pcrPID == 0x1fff))
            TSFilterGroupAddPacketFilter(filter->tsgroup, (unsigned short int)info->pcrPID, ServiceFilterProcessPacket, (void *)filter);

          i = 0;
          for( ; !(i >= info->streamInfoList->nrofStreams); i = i + 1)
            if(!(info->streamInfoList->streams[(signed long int)i].pid == info->pcrPID))
              TSFilterGroupAddPacketFilter(filter->tsgroup, (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid, ServiceFilterProcessPacket, (void *)filter);

          ObjectRefDecImpl((void *)info, "servicefilter.c", 608);
        }

      }
      pthread_mutex_unlock(&filter->tsgroup->tsReader->mutex);
    }

  }

}

// ServiceFilterCreate
// file ../include/servicefilter.h line 66
struct ServiceFilter_s * ServiceFilterCreate(struct TSReader_t *reader, char *name)
{
  struct ServiceFilter_s *result;
  struct Event_s *cachePIDSUpdatedEvent;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("ServiceFilter_t", "servicefilter.c", 154);
  result = (struct ServiceFilter_s *)return_value_ObjectCreateImpl_1;
  if(!(result == ((struct ServiceFilter_s *)NULL)))
  {
    result->name=strdup(name);
    result->tsgroup=TSReaderCreateFilterGroup(reader, name, ServiceFilterGroupType, ServiceFilterFilterEventCallback, (void *)result);
    sprintf(result->propertyPath, "filters.service.%s", name);
    PropertiesAddProperty(result->propertyPath, "service", "The service that is currently being filtered", (enum PropertyType_e)PropertyType_String, (void *)result, ServiceFilterPropertyServiceGet, (signed int (*)(void *, struct PropertyValue_s *))(void *)0);
    PropertiesAddProperty(result->propertyPath, "avsonly", "Whether only the first Audio/Video/Subtitle streams should be filtered.", (enum PropertyType_e)PropertyType_Boolean, (void *)result, ServiceFilterPropertyAVSOnlyGet, ServiceFilterPropertyAVSOnlySet);
    cachePIDSUpdatedEvent=EventsFindEvent("Cache.PIDsUpdated");
    EventsRegisterEventListener(cachePIDSUpdatedEvent, ServiceFilterPIDSUpdatedListener, (void *)result);
    ListAdd(ServiceFilterList, (void *)result);
    EventsFireEventListeners(filterAddedEvent, (void *)result);
  }

  return result;
}

// ServiceFilterDeInit
// file ../include/servicefilter.h line 58
signed int ServiceFilterDeInit(void)
{
  EventsUnregisterEvent(filterAddedEvent);
  EventsUnregisterEvent(filterRemovedEvent);
  EventsUnregisterEvent(serviceChangedEvent_link1);
  EventsUnregisterSource(eventSource);
  ListFree(ServiceFilterList, (void (*)(void *))(void *)0);
  return 0;
}

// ServiceFilterDeliveryMethodGet
// file servicefilter.c line 318
struct DeliveryMethodInstance_t * ServiceFilterDeliveryMethodGet(struct ServiceFilter_s *filter)
{
  return filter->dmInstance;
}

// ServiceFilterDeliveryMethodSet
// file ../include/servicefilter.h line 119
void ServiceFilterDeliveryMethodSet(struct ServiceFilter_s *filter, struct DeliveryMethodInstance_t *instance)
{
  struct DeliveryMethodInstance_t *prevInstance = filter->dmInstance;
  DeliveryMethodReserveHeaderSpace(instance, 1 + 6);
  filter->dmInstance = instance;
  filter->setHeader = (_Bool)1;
  if(!(prevInstance == ((struct DeliveryMethodInstance_t *)NULL)))
    DeliveryMethodDestroy(prevInstance);

}

// ServiceFilterDestroy
// file servicefilter.c line 175
void ServiceFilterDestroy(struct ServiceFilter_s *filter)
{
  struct Event_s *cachePIDSUpdatedEvent;
  EventsFireEventListeners(filterRemovedEvent, (void *)filter);
  cachePIDSUpdatedEvent=EventsFindEvent("Cache.PIDsUpdated");
  EventsUnregisterEventListener(cachePIDSUpdatedEvent, ServiceFilterPIDSUpdatedListener, (void *)filter);
  PropertiesRemoveAllProperties(filter->propertyPath);
  TSFilterGroupDestroy(filter->tsgroup);
  DeliveryMethodDestroy(filter->dmInstance);
  if(!(filter->multiplex == ((struct Multiplex_s *)NULL)))
    do
      if(!(filter->multiplex == ((struct Multiplex_s *)NULL)))
        ObjectRefDecImpl((void *)filter->multiplex, "servicefilter.c", 190);

    while((_Bool)0);

  if(!(filter->service == ((struct Service_t *)NULL)))
    do
      if(!(filter->service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)filter->service, "servicefilter.c", 194);

    while((_Bool)0);

  ListRemove(ServiceFilterList, (void *)filter);
  free((void *)filter->name);
  ObjectRefDecImpl((void *)filter, "servicefilter.c", 198);
}

// ServiceFilterDestroyAll
// file ../include/servicefilter.h line 78
void ServiceFilterDestroyAll(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  pthread_mutex_lock(&reader->mutex);
  iterator.current = ServiceFilterList->head;
  iterator.list = ServiceFilterList;
  struct ListEntry_s *tmp_if_expr_1;
  while(!(iterator.current == ((struct ListEntry_s *)NULL)))
  {
    struct ServiceFilter_s *filter = (struct ServiceFilter_s *)iterator.current->data;
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
    iterator.current = tmp_if_expr_1;
    ServiceFilterDestroy(filter);
  }
  pthread_mutex_unlock(&reader->mutex);
}

// ServiceFilterEventToString
// file servicefilter.c line 644
static signed int ServiceFilterEventToString(struct yaml_document_s *document, struct Event_s *event, void *payload)
{
  struct ServiceFilter_s *filter = (struct ServiceFilter_s *)payload;
  signed int mappingId;
  mappingId=yaml_document_add_mapping(document, (unsigned char *)"tag:yaml.org,2002:map", (enum yaml_mapping_style_e)YAML_ANY_MAPPING_STYLE);
  YamlUtils_MappingAdd(document, mappingId, "Filter Name", filter->name);
  if(event == serviceChangedEvent_link1)
  {
    char serviceId[16l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    char *serviceName = "";
    struct Service_t *service;
    service=ServiceFilterServiceGet(filter);
    if(!(service == ((struct Service_t *)NULL)))
    {
      sprintf(serviceId, "%04x.%04x.%04x", service->networkId, service->tsId, service->id);
      serviceName = service->name;
    }

    YamlUtils_MappingAdd(document, mappingId, "Service Name", serviceName);
    YamlUtils_MappingAdd(document, mappingId, "Service ID", serviceId);
  }

  return mappingId;
}

// ServiceFilterFilterEventCallback
// file servicefilter.c line 326
static void ServiceFilterFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details)
{
  struct ServiceFilter_s *filter = (struct ServiceFilter_s *)userArg;
  TSFilterGroupRemoveAllFilters(filter->tsgroup);
  if((signed int)event == TSFilterEventType_StructureChanged)
  {
    if(!(filter->service == ((struct Service_t *)NULL)))
    {
      ServiceFilterPATRewrite(filter);
      if(!(filter->avsOnly == (_Bool)0))
        ServiceFilterPMTRewrite(filter);

    }

  }

  ServiceFilterAllocateFilters(filter);
}

// ServiceFilterFindFilter
// file servicefilter.c line 225
struct ServiceFilter_s * ServiceFilterFindFilter(struct TSReader_t *reader, const char *name)
{
  struct ListIterator_s iterator;
  iterator.current = reader->groups->head;
  iterator.list = reader->groups;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSFilterGroup_t *group = (struct TSFilterGroup_t *)iterator.current->data;
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(group->type, ServiceFilterGroupType);
    if(return_value_strcmp_3 == 0)
    {
      struct ServiceFilter_s *filter = (struct ServiceFilter_s *)group->userArg;
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(filter->name, name);
      if(return_value_strcmp_2 == 0)
        return filter;

    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  return (struct ServiceFilter_s *)(void *)0;
}

// ServiceFilterGetListIterator
// file servicefilter.c line 217
struct ListIterator_s * ServiceFilterGetListIterator(void)
{
  struct ListIterator_s *iterator;
  void *return_value_ObjectAllocImpl_1;
  return_value_ObjectAllocImpl_1=ObjectAllocImpl((signed int)sizeof(struct ListIterator_s) /*16ul*/ , "servicefilter.c", 219);
  iterator = (struct ListIterator_s *)return_value_ObjectAllocImpl_1;
  iterator->current = ServiceFilterList->head;
  iterator->list = ServiceFilterList;
  return iterator;
}

// ServiceFilterInit
// file ../include/servicefilter.h line 51
signed int ServiceFilterInit(void)
{
  ServiceFilterList=ListCreate();
  ObjectRegisterClass("ServiceFilter_t", (unsigned int)sizeof(struct ServiceFilter_s) /*2776ul*/ , (void (*)(void *))(void *)0);
  eventSource=EventsRegisterSource("ServiceFilter");
  filterAddedEvent=EventsRegisterEvent(eventSource, "Added", ServiceFilterEventToString);
  filterRemovedEvent=EventsRegisterEvent(eventSource, "Removed", ServiceFilterEventToString);
  serviceChangedEvent_link1=EventsRegisterEvent(eventSource, "ServiceChanged", ServiceFilterEventToString);
  return 0;
}

// ServiceFilterInitPacket
// file servicefilter.c line 518
static void ServiceFilterInitPacket(struct TSPacket_t *packet, struct dvbpsi_psi_section_s *section, char *sectionname)
{
  unsigned char *data;
  signed int len;
  signed int i;
  packet->header[(signed long int)0] = (unsigned char)0x47;
  packet->header[(signed long int)1] = (unsigned char)0x40;
  packet->header[(signed long int)2] = (unsigned char)0x00;
  packet->header[(signed long int)3] = (unsigned char)0x10;
  packet->payload[(signed long int)0] = (unsigned char)0;
  data = section->p_data;
  len = (signed int)section->i_length + 3;
  if((unsigned long int)len >= 184ul)
    LogModule(0, SERVICEFILTER, "!!! ERROR %s section too big to fit in 1 TS packet !!!\n");

  i = 0;
  for( ; !(i >= len); i = i + 1)
    packet->payload[(signed long int)(1 + i)] = data[(signed long int)i];
  i = len + 1;
  for( ; !(i >= 184); i = i + 1)
    packet->payload[(signed long int)i] = (unsigned char)0xff;
}

// ServiceFilterNameGet
// file servicefilter.c line 272
char * ServiceFilterNameGet(struct ServiceFilter_s *filter)
{
  return filter->name;
}

// ServiceFilterPATRewrite
// file servicefilter.c line 404
static void ServiceFilterPATRewrite(struct ServiceFilter_s *filter)
{
  struct dvbpsi_pat_s pat;
  struct dvbpsi_psi_section_s *section;
  filter->patVersion = filter->patVersion + 1;
  dvbpsi_InitPAT(&pat, (unsigned short int)filter->multiplex->tsId, (unsigned char)filter->patVersion, 1);
  dvbpsi_PATAddProgram(&pat, (unsigned short int)filter->service->id, (unsigned short int)filter->service->pmtPID);
  section=dvbpsi_GenPATSections(&pat, 1);
  ServiceFilterInitPacket(&filter->packets[(signed long int)0], section, "PAT");
  dvbpsi_DeletePSISections(section);
  dvbpsi_EmptyPAT(&pat);
}

// ServiceFilterPIDSUpdatedListener
// file servicefilter.c line 344
static void ServiceFilterPIDSUpdatedListener(void *userArg, struct Event_s *event, void *details)
{
  struct ServiceFilter_s *filter = (struct ServiceFilter_s *)userArg;
  struct Service_t *updatedService = (struct Service_t *)details;
  if(!(filter->service == ((struct Service_t *)NULL)))
  {
    if(filter->service->multiplexUID == updatedService->multiplexUID)
    {
      if(filter->service->id == updatedService->id)
      {
        TSFilterGroupRemoveAllFilters(filter->tsgroup);
        ServiceFilterPMTRewrite(filter);
        ServiceFilterAllocateFilters(filter);
      }

    }

  }

}

// ServiceFilterPMTRewrite
// file servicefilter.c line 422
static void ServiceFilterPMTRewrite(struct ServiceFilter_s *state)
{
  signed int i;
  struct ProgramInfo_s *info;
  _Bool vfound = (_Bool)0;
  _Bool afound = (_Bool)0;
  _Bool sfound = (_Bool)0;
  struct dvbpsi_pmt_s pmt;
  struct dvbpsi_pmt_es_s *es;
  struct dvbpsi_psi_section_s *section;
  state->pmtVersion = state->pmtVersion + 1;
  dvbpsi_InitPMT(&pmt, (unsigned short int)state->service->id, (unsigned char)state->pmtVersion, 1, (unsigned short int)0x1fff);
  state->pcrPID = (unsigned short int)0xffff;
  state->videoPID = (unsigned short int)0xffff;
  state->audioPID = (unsigned short int)0xffff;
  state->subPID = (unsigned short int)0xffff;
  LogModule(3, SERVICEFILTER, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
  LogModule(3, SERVICEFILTER, "Rewriting PMT on PID %x\n", state->service->pmtPID);
  info=CacheProgramInfoGet(state->service);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!(info == ((struct ProgramInfo_s *)NULL)))
  {
    state->pcrPID = (unsigned short int)info->pcrPID;
    pmt.i_pcr_pid = state->pcrPID;
    i = 0;
    for( ; !(i >= info->streamInfoList->nrofStreams) && (afound == (_Bool)0 || sfound == (_Bool)0 || vfound == (_Bool)0); i = i + 1)
    {
      LogModule(3, SERVICEFILTER, "\tpid = %x type =%d\n", info->streamInfoList->streams[(signed long int)i].pid, info->streamInfoList->streams[(signed long int)i].type);
      if(vfound == (_Bool)0)
      {
        if(info->streamInfoList->streams[(signed long int)i].type == 1)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = info->streamInfoList->streams[(signed long int)i].type == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          vfound = (_Bool)1;
          state->videoPID = (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid;
          es=dvbpsi_PMTAddES(&pmt, (unsigned char)info->streamInfoList->streams[(signed long int)i].type, (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid);
        }

      }

      if(afound == (_Bool)0)
      {
        if(info->streamInfoList->streams[(signed long int)i].type == 3)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = info->streamInfoList->streams[(signed long int)i].type == 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = info->streamInfoList->streams[(signed long int)i].type == 0x81 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
        {
          afound = (_Bool)1;
          state->audioPID = (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid;
          es=dvbpsi_PMTAddES(&pmt, (unsigned char)info->streamInfoList->streams[(signed long int)i].type, (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid);
        }

      }

      if(info->streamInfoList->streams[(signed long int)i].type == 6)
      {
        struct dvbpsi_descriptor_s *desc = info->streamInfoList->streams[(signed long int)i].descriptors;
        for( ; !(desc == ((struct dvbpsi_descriptor_s *)NULL)); desc = desc->p_next)
        {
          if(sfound == (_Bool)0)
          {
            if((signed int)desc->i_tag == 0x59)
            {
              sfound = (_Bool)1;
              state->subPID = (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid;
              es=dvbpsi_PMTAddES(&pmt, (unsigned char)info->streamInfoList->streams[(signed long int)i].type, (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid);
              dvbpsi_PMTESAddDescriptor(es, desc->i_tag, desc->i_length, desc->p_data);
              break;
            }

          }

          if(afound == (_Bool)0)
          {
            if((signed int)desc->i_tag == 0x6a)
            {
              afound = (_Bool)1;
              state->audioPID = (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid;
              es=dvbpsi_PMTAddES(&pmt, (unsigned char)info->streamInfoList->streams[(signed long int)i].type, (unsigned short int)info->streamInfoList->streams[(signed long int)i].pid);
              dvbpsi_PMTESAddDescriptor(es, desc->i_tag, desc->i_length, desc->p_data);
              break;
            }

          }

        }
      }

    }
    ObjectRefDecImpl((void *)info, "servicefilter.c", 503);
  }

  LogModule(3, SERVICEFILTER, "videopid = %x audiopid = %x subpid = %x\n", state->videoPID, state->audioPID, state->subPID);
  section=dvbpsi_GenPMTSections(&pmt);
  ServiceFilterInitPacket(&state->packets[(signed long int)1], section, "PMT");
  do
  {
    state->packets[(signed long int)1].header[(signed long int)1] = (unsigned char)((signed int)state->packets[(signed long int)1].header[(signed long int)1] & 0xe0 | state->service->pmtPID >> 8 & 0x1f);
    state->packets[(signed long int)1].header[(signed long int)2] = (unsigned char)(state->service->pmtPID & 0xff);
  }
  while((_Bool)0);
  LogModule(3, SERVICEFILTER, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
  dvbpsi_DeletePSISections(section);
  dvbpsi_EmptyPMT(&pmt);
  state->headerGotPMT = (_Bool)1;
  state->headerCount = 2;
}

// ServiceFilterProcessPacket
// file servicefilter.c line 356
static void ServiceFilterProcessPacket(void *arg, struct TSFilterGroup_t *group, struct TSPacket_t *packet)
{
  struct ServiceFilter_s *filter = (struct ServiceFilter_s *)arg;
  unsigned short int pid = (unsigned short int)(((signed int)packet->header[(signed long int)1] & 0x1f) << 8 | (signed int)packet->header[(signed long int)2] & 0xff);
  unsigned char tmp_post_1;
  if((signed int)pid == 0)
  {
    tmp_post_1 = filter->patPacketCounter;
    filter->patPacketCounter = filter->patPacketCounter + 1;
    filter->packets[(signed long int)0].header[(signed long int)3] = (unsigned char)((signed int)filter->packets[(signed long int)0].header[(signed long int)3] & 0xf0 | (signed int)tmp_post_1 & 0x0f);
    packet = &filter->packets[(signed long int)0];
  }

  unsigned char tmp_post_2;
  if((signed int)pid == filter->service->pmtPID)
  {
    if(!(filter->avsOnly == (_Bool)0))
    {
      tmp_post_2 = filter->pmtPacketCounter;
      filter->pmtPacketCounter = filter->pmtPacketCounter + 1;
      filter->packets[(signed long int)1].header[(signed long int)3] = (unsigned char)((signed int)filter->packets[(signed long int)1].header[(signed long int)3] & 0xf0 | (signed int)tmp_post_2 & 0x0f);
      packet = &filter->packets[(signed long int)1];
    }

    else
    {
      if((0x40 & (signed int)packet->header[1l]) == 0x40)
      {
        if(filter->pmtPacketCount >= 1)
        {
          filter->headerGotPMT = (_Bool)1;
          filter->headerCount = 1 + filter->pmtPacketCount;
          memcpy((void *)&filter->packets[(signed long int)1], (const void *)&filter->pmtPackets, (unsigned long int)(188 * filter->pmtPacketCount));
        }

        filter->pmtPacketCount = 0;
      }

      if(!(filter->pmtPacketCount >= 6))
      {
        memcpy((void *)&filter->pmtPackets[(signed long int)filter->pmtPacketCount], (const void *)packet, (unsigned long int)188);
        filter->pmtPacketCount = filter->pmtPacketCount + 1;
      }

    }
  }

  if(!(filter->setHeader == (_Bool)0))
  {
    if(!(filter->headerGotPMT == (_Bool)0))
    {
      DeliveryMethodSetHeader(filter->dmInstance, filter->packets, filter->headerCount);
      filter->setHeader = (_Bool)0;
    }

  }

  DeliveryMethodOutputPacket(filter->dmInstance, packet);
}

// ServiceFilterPropertyAVSOnlyGet
// file servicefilter.c line 629
static signed int ServiceFilterPropertyAVSOnlyGet(void *userArg, struct PropertyValue_s *value)
{
  struct ServiceFilter_s *state = (struct ServiceFilter_s *)userArg;
  value->type = (enum PropertyType_e)PropertyType_Boolean;
  value->u.boolean = state->avsOnly;
  return 0;
}

// ServiceFilterPropertyAVSOnlySet
// file servicefilter.c line 637
static signed int ServiceFilterPropertyAVSOnlySet(void *userArg, struct PropertyValue_s *value)
{
  struct ServiceFilter_s *filter = (struct ServiceFilter_s *)userArg;
  ServiceFilterAVSOnlySet(filter, value->u.boolean);
  return 0;
}

// ServiceFilterPropertyServiceGet
// file servicefilter.c line 614
static signed int ServiceFilterPropertyServiceGet(void *userArg, struct PropertyValue_s *value)
{
  struct ServiceFilter_s *state = (struct ServiceFilter_s *)userArg;
  value->type = (enum PropertyType_e)PropertyType_String;
  if(!(state->service == ((struct Service_t *)NULL)))
    value->u.string=ServiceGetIDNameStr(state->service, (char *)(void *)0);

  else
    value->u.string=strdup("");
  return 0;
}

// ServiceFilterServiceGet
// file servicefilter.c line 277
struct Service_t * ServiceFilterServiceGet(struct ServiceFilter_s *filter)
{
  return filter->service;
}

// ServiceFilterServiceSet
// file ../include/servicefilter.h line 88
void ServiceFilterServiceSet(struct ServiceFilter_s *filter, struct Service_t *service)
{
  if(!(filter->service == ((struct Service_t *)NULL)))
  {
    do
      if(!(filter->service == ((struct Service_t *)NULL)))
        ObjectRefDecImpl((void *)filter->service, "servicefilter.c", 249);

    while((_Bool)0);
    do
      if(!(filter->multiplex == ((struct Multiplex_s *)NULL)))
        ObjectRefDecImpl((void *)filter->multiplex, "servicefilter.c", 250);

    while((_Bool)0);
  }

  TSFilterGroupRemoveAllFilters(filter->tsgroup);
  filter->service = service;
  if(!(service == ((struct Service_t *)NULL)))
  {
    filter->multiplex=MultiplexFindUID(service->multiplexUID);
    do
      if(!(service == ((struct Service_t *)NULL)))
        ObjectRefIncImpl((void *)service, "servicefilter.c", 257);

    while((_Bool)0);
    ServiceFilterPATRewrite(filter);
    if(!(filter->avsOnly == (_Bool)0))
      ServiceFilterPMTRewrite(filter);

    ServiceFilterAllocateFilters(filter);
  }

  else
    filter->multiplex = (struct Multiplex_s *)(void *)0;
  EventsFireEventListeners(serviceChangedEvent_link1, (void *)filter);
}

// ServiceFind
// file services.c line 359
struct Service_t * ServiceFind(char *name)
{
  struct Service_t *result;
  result=ServiceFindName(name);
  if(result == ((struct Service_t *)NULL))
    result=ServiceFindFQIDStr(name);

  return result;
}

// ServiceFindFQID
// file services.c line 403
struct Service_t * ServiceFindFQID(unsigned short int networkId, unsigned short int tsId, unsigned short int serviceId)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  struct Service_t *result;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Multiplexes.netid=%d AND Multiplexes.tsid=%d AND Services.mplexuid=Multiplexes.uid AND id=%d;", networkId, tsId, serviceId);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceFindFQID", 415, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (struct Service_t *)(void *)0;
    }

  while((_Bool)0);
  result=ServiceGetNext((void *)stmt);
  rc=sqlite3_finalize(stmt);
  return result;
}

// ServiceFindFQIDStr
// file services.c line 423
struct Service_t * ServiceFindFQIDStr(char *FQIdStr)
{
  unsigned short int networkId = (unsigned short int)0;
  unsigned short int tsId = (unsigned short int)0;
  unsigned short int serviceId = (unsigned short int)0;
  struct Service_t *service = (struct Service_t *)(void *)0;
  signed int return_value_sscanf_1;
  return_value_sscanf_1=sscanf(FQIdStr, "%hx.%hx.%hx", &networkId, &tsId, &serviceId);
  if(return_value_sscanf_1 == 3)
    service=ServiceFindFQID(networkId, tsId, serviceId);

  return service;
}

// ServiceFindId
// file services.c line 386
struct Service_t * ServiceFindId(struct Multiplex_s *multiplex, signed int id)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  struct Service_t *result;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Services.mplexuid=%d AND Services.id=%d AND Multiplexes.uid=Services.mplexuid;", multiplex->uid, id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceFindId", 396, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (struct Service_t *)(void *)0;
    }

  while((_Bool)0);
  result=ServiceGetNext((void *)stmt);
  rc=sqlite3_finalize(stmt);
  return result;
}

// ServiceFindName
// file services.c line 369
struct Service_t * ServiceFindName(char *name)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  struct Service_t *result;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Services.name='%q' AND Multiplexes.uid=Services.mplexuid;", name);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceFindName", 378, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (struct Service_t *)(void *)0;
    }

  while((_Bool)0);
  result=ServiceGetNext((void *)stmt);
  rc=sqlite3_finalize(stmt);
  return result;
}

// ServiceGetAll
// file services.c line 452
struct ServiceList_s * ServiceGetAll()
{
  struct ServiceList_s *return_value_ServiceGetList_1;
  return_value_ServiceGetList_1=ServiceGetList((char *)(void *)0);
  return return_value_ServiceGetList_1;
}

// ServiceGetIDNameStr
// file services.c line 579
char * ServiceGetIDNameStr(struct Service_t *service, char *buffer)
{
  if(buffer == ((char *)NULL))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(service->name);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(4 + 1 + 4 + 1 + 4 + 1 + 5) + return_value_strlen_1);
    buffer = (char *)return_value_malloc_2;
  }

  if(!(buffer == ((char *)NULL)))
  {
    sprintf(buffer, "%04x.%04x.%04x : \"%s\"", service->networkId & 0xffff, service->tsId & 0xffff, service->id & 0xffff, service->name);
    return buffer;
  }

  else
    return (char *)(void *)0;
}

// ServiceGetIDStr
// file services.c line 565
char * ServiceGetIDStr(struct Service_t *service, char *buffer)
{
  if(buffer == ((char *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(4 + 1 + 4 + 1 + 4 + 1));
    buffer = (char *)return_value_malloc_1;
  }

  if(!(buffer == ((char *)NULL)))
  {
    sprintf(buffer, "%04x.%04x.%04x", service->networkId & 0xffff, service->tsId & 0xffff, service->id & 0xffff);
    return buffer;
  }

  else
    return (char *)(void *)0;
}

// ServiceGetList
// file services.c line 615
static struct ServiceList_s * ServiceGetList(char *where)
{
  signed int count;
  signed int i;
  struct ServiceList_s *list;
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  count=DBaseCount("Services", where);
  if(!(where == ((char *)NULL)))
    do
    {
      char *sqlstring;
      sqlstring=sqlite3_mprintf("SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Services.mplexuid=Multiplexes.uid AND %s;", where);
      if(!(sqlstring == ((char *)NULL)))
      {
        struct sqlite3 *return_value_DBaseConnectionGet_1;
        return_value_DBaseConnectionGet_1=DBaseConnectionGet();
        rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
        sqlite3_free((void *)sqlstring);
      }

      else
        rc = 7;
    }
    while((_Bool)0);

  else
  {
    struct sqlite3 *return_value_DBaseConnectionGet_2;
    return_value_DBaseConnectionGet_2=DBaseConnectionGet();
    rc=sqlite3_prepare(return_value_DBaseConnectionGet_2, "SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Services.mplexuid=Multiplexes.uid;", -1, &stmt, (const char **)(void *)0);
  }
  struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_3;
  return_value_ObjectCollectionCreateImpl_3=ObjectCollectionCreateImpl("ServiceList_t", (unsigned int)count, "services.c", 634);
  list = (struct ServiceList_s *)return_value_ObjectCollectionCreateImpl_3;
  if(!(list == ((struct ServiceList_s *)NULL)))
  {
    i = 0;
    for( ; !(i >= count); i = i + 1)
      list->services[(signed long int)i]=ServiceGetNext((void *)stmt);
  }

  rc=sqlite3_finalize(stmt);
  return list;
}

// ServiceGetListForMultiplex
// file services.c line 476
struct ServiceList_s * ServiceGetListForMultiplex(struct Multiplex_s *multiplex)
{
  char where[50l];
  sprintf(where, "Services.mplexuid=%d", multiplex->uid);
  struct ServiceList_s *return_value_ServiceGetList_1;
  return_value_ServiceGetList_1=ServiceGetList(where);
  return return_value_ServiceGetList_1;
}

// ServiceGetListForNameLike
// file services.c line 503
struct ServiceList_s * ServiceGetListForNameLike(char *query)
{
  char *where;
  struct ServiceList_s *list;
  where=sqlite3_mprintf("Services.name LIKE %Q", query);
  list=ServiceGetList(where);
  sqlite3_free((void *)where);
  return list;
}

// ServiceGetNext
// file services.c line 520
struct Service_t * ServiceGetNext(void *enumerator)
{
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)enumerator;
  signed int rc;
  rc=sqlite3_step(stmt);
  if(rc == 100)
  {
    struct Service_t *service = (struct Service_t *)(void *)0;
    char *name;
    void *return_value_ObjectCreateImpl_1;
    return_value_ObjectCreateImpl_1=ObjectCreateImpl("Service_t", "services.c", 531);
    service = (struct Service_t *)return_value_ObjectCreateImpl_1;
    service->multiplexUID=sqlite3_column_int(stmt, 0);
    signed int return_value_sqlite3_column_int_2;
    return_value_sqlite3_column_int_2=sqlite3_column_int(stmt, 1);
    service->id = return_value_sqlite3_column_int_2 & 0xffff;
    service->source=sqlite3_column_int(stmt, 2);
    signed int return_value_sqlite3_column_int_3;
    return_value_sqlite3_column_int_3=sqlite3_column_int(stmt, 3);
    service->conditionalAccess = (_Bool)(return_value_sqlite3_column_int_3 != 0 ? 1 : 0);
    signed int return_value_sqlite3_column_int_4;
    return_value_sqlite3_column_int_4=sqlite3_column_int(stmt, 4);
    service->type = (enum anonymous)return_value_sqlite3_column_int_4;
    const unsigned char *return_value_sqlite3_column_text_5;
    return_value_sqlite3_column_text_5=sqlite3_column_text(stmt, 5);
    name = (char *)return_value_sqlite3_column_text_5;
    if(!(name == ((char *)NULL)))
      service->name=strdup(name);

    signed int return_value_sqlite3_column_int_6;
    return_value_sqlite3_column_int_6=sqlite3_column_int(stmt, 6);
    service->pmtPID = return_value_sqlite3_column_int_6 & 0xffff;
    const unsigned char *return_value_sqlite3_column_text_7;
    return_value_sqlite3_column_text_7=sqlite3_column_text(stmt, 7);
    name = (char *)return_value_sqlite3_column_text_7;
    if(!(name == ((char *)NULL)))
      service->provider=strdup(name);

    const unsigned char *return_value_sqlite3_column_text_8;
    return_value_sqlite3_column_text_8=sqlite3_column_text(stmt, 8);
    name = (char *)return_value_sqlite3_column_text_8;
    if(!(name == ((char *)NULL)))
      service->defaultAuthority=strdup(name);

    signed int return_value_sqlite3_column_int_9;
    return_value_sqlite3_column_int_9=sqlite3_column_int(stmt, 9);
    service->networkId = return_value_sqlite3_column_int_9 & 0xffff;
    signed int return_value_sqlite3_column_int_10;
    return_value_sqlite3_column_int_10=sqlite3_column_int(stmt, 10);
    service->tsId = return_value_sqlite3_column_int_10 & 0xffff;
    return service;
  }

  if(!(rc == 101))
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_11;
      return_value_DBaseConnectionGet_11=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_12;
      return_value_sqlite3_errmsg_12=sqlite3_errmsg(return_value_DBaseConnectionGet_11);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceGetNext", 560, rc, return_value_sqlite3_errmsg_12);
    }
    while((_Bool)0);

  return (struct Service_t *)(void *)0;
}

// ServiceInit
// file ../include/services.h line 116
signed int ServiceInit(void)
{
  signed int result = 0;
  result=ObjectRegisterClass("Service_t", (unsigned int)sizeof(struct Service_t) /*56ul*/ , ServiceDestructor);
  if(result == 0)
    result=ObjectRegisterCollection("ServiceList_t", (unsigned int)sizeof(struct Service_t *) /*8ul*/ , ServiceListDestructor);

  if(result == 0)
  {
    servicesSource=EventsRegisterSource("Services");
    serviceAddedEvent=EventsRegisterEvent(servicesSource, "Added", ServiceEventToString);
    serviceDeletedEvent=EventsRegisterEvent(servicesSource, "Deleted", ServiceEventToString);
    serviceAllDeletedEvent=EventsRegisterEvent(servicesSource, "AllDeleted", MultiplexEventToString);
  }

  return result;
}

// ServiceListAll
// file services.c line 447
struct List_s * ServiceListAll()
{
  void *return_value_ServiceEnumeratorGet_1;
  return_value_ServiceEnumeratorGet_1=ServiceEnumeratorGet();
  struct List_s *return_value_ServiceCreateList_2;
  return_value_ServiceCreateList_2=ServiceCreateList(return_value_ServiceEnumeratorGet_1);
  return return_value_ServiceCreateList_2;
}

// ServiceListDestructor
// file services.c line 663
static void ServiceListDestructor(void *arg)
{
  struct ServiceList_s *list = (struct ServiceList_s *)arg;
  signed int i = 0;
  for( ; !((unsigned int)i >= list->nrofServices); i = i + 1)
    ObjectRefDecImpl((void *)list->services[(signed long int)i], "services.c", 669);
}

// ServiceListForMultiplex
// file services.c line 471
struct List_s * ServiceListForMultiplex(struct Multiplex_s *multiplex)
{
  void *return_value_ServiceEnumeratorForMultiplex_1;
  return_value_ServiceEnumeratorForMultiplex_1=ServiceEnumeratorForMultiplex(multiplex);
  struct List_s *return_value_ServiceCreateList_2;
  return_value_ServiceCreateList_2=ServiceCreateList(return_value_ServiceEnumeratorForMultiplex_1);
  return return_value_ServiceCreateList_2;
}

// ServiceListForNameLike
// file services.c line 498
struct List_s * ServiceListForNameLike(char *query)
{
  void *return_value_ServiceQueryNameLike_1;
  return_value_ServiceQueryNameLike_1=ServiceQueryNameLike(query);
  struct List_s *return_value_ServiceCreateList_2;
  return_value_ServiceCreateList_2=ServiceCreateList(return_value_ServiceQueryNameLike_1);
  return return_value_ServiceCreateList_2;
}

// ServiceNameSet
// file services.c line 194
signed int ServiceNameSet(struct Service_t *service, char *name)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Services SET name='%q' WHERE mplexuid=%d AND id=%d;", name, service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceNameSet", 202, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(rc == 101)
  {
    if(service->name == ((char *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(name, service->name);
      tmp_if_expr_5 = return_value_strcmp_4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      if(!(service->name == ((char *)NULL)))
        free((void *)service->name);

      service->name=strdup(name);
    }

    rc = 0;
  }

  else
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_6;
      return_value_DBaseConnectionGet_6=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_7;
      return_value_sqlite3_errmsg_7=sqlite3_errmsg(return_value_DBaseConnectionGet_6);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceNameSet", 219, rc, return_value_sqlite3_errmsg_7);
    }
    while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// ServicePMTPIDSet
// file services.c line 170
signed int ServicePMTPIDSet(struct Service_t *service, signed int pmtpid)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Services SET pmtpid=%d WHERE mplexuid=%d AND id=%d;", pmtpid, service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServicePMTPIDSet", 178, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  if(rc == 101)
  {
    service->pmtPID = pmtpid;
    rc = 0;
  }

  else
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_4;
      return_value_DBaseConnectionGet_4=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_5;
      return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServicePMTPIDSet", 188, rc, return_value_sqlite3_errmsg_5);
    }
    while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// ServiceProviderSet
// file services.c line 297
signed int ServiceProviderSet(struct Service_t *service, char *provider)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Services SET provider='%q' WHERE mplexuid=%d AND id=%d;", provider, service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceProviderSet", 305, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(rc == 101)
  {
    if(service->provider == ((char *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(provider, service->provider);
      tmp_if_expr_5 = return_value_strcmp_4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      if(!(service->provider == ((char *)NULL)))
        free((void *)service->provider);

      service->provider=strdup(provider);
    }

    rc = 0;
  }

  else
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_6;
      return_value_DBaseConnectionGet_6=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_7;
      return_value_sqlite3_errmsg_7=sqlite3_errmsg(return_value_DBaseConnectionGet_6);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceProviderSet", 322, rc, return_value_sqlite3_errmsg_7);
    }
    while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// ServiceQueryNameLike
// file services.c line 484
void * ServiceQueryNameLike(char *query)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("SELECT Services.mplexuid,Services.id,Services.source,Services.ca,Services.type,Services.name,Services.pmtpid,Services.provider,Services.defauthority,Multiplexes.netid,Multiplexes.tsid FROM Services,Multiplexes WHERE Services.mplexuid=Multiplexes.uid AND Services.name LIKE %Q;", query);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceQueryNameLike", 493, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return (void *)0;
    }

  while((_Bool)0);
  return (void *)stmt;
}

// ServiceSourceSet
// file services.c line 225
signed int ServiceSourceSet(struct Service_t *service, signed int source)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Services SET source=%d WHERE mplexuid=%d AND id=%d;", source, service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceSourceSet", 233, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  if(rc == 101)
  {
    service->source = source;
    rc = 0;
  }

  else
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_4;
      return_value_DBaseConnectionGet_4=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_5;
      return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceSourceSet", 243, rc, return_value_sqlite3_errmsg_5);
    }
    while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// ServiceTypeSet
// file services.c line 273
signed int ServiceTypeSet(struct Service_t *service, enum anonymous type)
{
  signed int rc;
  struct sqlite3_stmt *stmt = (struct sqlite3_stmt *)(void *)0;
  do
  {
    char *sqlstring;
    sqlstring=sqlite3_mprintf("UPDATE Services SET type=%d WHERE mplexuid=%d AND id=%d;", type, service->multiplexUID, service->id);
    if(!(sqlstring == ((char *)NULL)))
    {
      struct sqlite3 *return_value_DBaseConnectionGet_1;
      return_value_DBaseConnectionGet_1=DBaseConnectionGet();
      rc=sqlite3_prepare(return_value_DBaseConnectionGet_1, sqlstring, -1, &stmt, (const char **)(void *)0);
      sqlite3_free((void *)sqlstring);
    }

    else
      rc = 7;
  }
  while((_Bool)0);
  do
    if(!(rc == 0) && !(rc == 100) && !(rc == 101))
    {
      do
      {
        struct sqlite3 *return_value_DBaseConnectionGet_2;
        return_value_DBaseConnectionGet_2=DBaseConnectionGet();
        const char *return_value_sqlite3_errmsg_3;
        return_value_sqlite3_errmsg_3=sqlite3_errmsg(return_value_DBaseConnectionGet_2);
        LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceTypeSet", 281, rc, return_value_sqlite3_errmsg_3);
      }
      while((_Bool)0);
      if(!(stmt == ((struct sqlite3_stmt *)NULL)))
        rc=sqlite3_finalize(stmt);

      return rc;
    }

  while((_Bool)0);
  rc=sqlite3_step(stmt);
  if(rc == 101)
  {
    service->type = type;
    rc = 0;
  }

  else
    do
    {
      struct sqlite3 *return_value_DBaseConnectionGet_4;
      return_value_DBaseConnectionGet_4=DBaseConnectionGet();
      const char *return_value_sqlite3_errmsg_5;
      return_value_sqlite3_errmsg_5=sqlite3_errmsg(return_value_DBaseConnectionGet_4);
      LogModule(3, "dbase", "%s(%d): Failed with error code 0x%x=%s\n", (const void *)"ServiceTypeSet", 291, rc, return_value_sqlite3_errmsg_5);
    }
    while((_Bool)0);
  rc=sqlite3_finalize(stmt);
  return rc;
}

// StatsAddFilterGroupStats
// file ts.c line 486
static void StatsAddFilterGroupStats(struct TSReaderStats_t *stats, const char *type, struct TSFilterGroupStats_t *filterGroupStats)
{
  struct TSFilterGroupTypeStats_t *typeStats = stats->types;
  for( ; !(typeStats == ((struct TSFilterGroupTypeStats_t *)NULL)); typeStats = typeStats->next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(typeStats->type, type);
    if(return_value_strcmp_1 == 0)
      break;

  }
  if(typeStats == ((struct TSFilterGroupTypeStats_t *)NULL))
  {
    void *return_value_ObjectCreateImpl_2;
    return_value_ObjectCreateImpl_2=ObjectCreateImpl("TSFilterGroupTypeStats_t", "ts.c", 498);
    typeStats = (struct TSFilterGroupTypeStats_t *)return_value_ObjectCreateImpl_2;
    typeStats->type = (char *)type;
    typeStats->next = stats->types;
    stats->types = typeStats;
  }

  filterGroupStats->next = typeStats->groups;
  typeStats->groups = filterGroupStats;
}

// StreamInfoListDestructor
// file pids.c line 300
static void StreamInfoListDestructor(void *ptr)
{
  struct StreamInfoList_t *list = (struct StreamInfoList_t *)ptr;
  signed int i = 0;
  for( ; !(i >= list->nrofStreams); i = i + 1)
    if(!(list->streams[(signed long int)i].descriptors == ((struct dvbpsi_descriptor_s *)NULL)))
      dvbpsi_DeleteDescriptors(list->streams[(signed long int)i].descriptors);

}

// SubTableHandler
// file standard/atsc/psipprocessor.c line 155
static void SubTableHandler(void *arg, struct dvbpsi_decoder_s *demuxHandle, unsigned char tableId, unsigned short int extension)
{
  switch((signed int)tableId)
  {
    case 0xC7:
    {
      dvbpsi_atsc_AttachMGT(demuxHandle, tableId, ProcessMGT, arg);
      break;
    }
    case 0xC8:

    case 0xC9:
    {
      struct Multiplex_s *current;
      current=TuningCurrentMultiplexGet();
      if((signed int)extension == current->tsId)
        dvbpsi_atsc_AttachVCT(demuxHandle, tableId, extension, ProcessVCT, arg);

      do
        if(!(current == ((struct Multiplex_s *)NULL)))
          ObjectRefDecImpl((void *)current, "standard/atsc/psipprocessor.c", 174);

      while((_Bool)0);
      break;
    }
    case 0xCA:
      break;
    case 0xCD:
      dvbpsi_atsc_AttachSTT(demuxHandle, tableId, ProcessSTT, arg);
  }
}

// SubTableHandler_link1
// file standard/dvb/sdtprocessor.c line 131
static void SubTableHandler_link1(void *arg_link1, struct dvbpsi_decoder_s *demuxHandle_link1, unsigned char tableId_link1, unsigned short int extension_link1)
{
  if((signed int)tableId_link1 == 0x42)
    dvbpsi_AttachSDT(demuxHandle_link1, tableId_link1, extension_link1, SDTHandler, arg_link1);

}

// SubTableHandler_link2
// file standard/dvb/nitprocessor.c line 120
static void SubTableHandler_link2(void *arg_link2, struct dvbpsi_decoder_s *demuxHandle_link2, unsigned char tableId_link2, unsigned short int extension_link2)
{
  if((signed int)tableId_link2 == 0x40 || (signed int)tableId_link2 == 0x41)
    dvbpsi_AttachNIT(demuxHandle_link2, tableId_link2, extension_link2, NITHandler, arg_link2);

}

// SysPropertyGetUptime
// file main.c line 588
static signed int SysPropertyGetUptime(void *userArg, struct PropertyValue_s *value)
{
  char *uptimeStr = (char *)(void *)0;
  signed long int now;
  signed int seconds;
  signed int d;
  signed int h;
  signed int m;
  signed int s;
  time(&now);
  double return_value_difftime_1;
  return_value_difftime_1=difftime(now, StartTime);
  seconds = (signed int)return_value_difftime_1;
  d = seconds / (24 * 60 * 60);
  h = (seconds - d * 24 * 60 * 60) / (60 * 60);
  m = (seconds - (d * 24 * 60 * 60 + h * 60 * 60)) / 60;
  s = seconds - (d * 24 * 60 * 60 + h * 60 * 60 + m * 60);
  signed int return_value_asprintf_2;
  return_value_asprintf_2=asprintf(&uptimeStr, "%d Days %d Hours %d Minutes %d seconds", d, h, m, s);
  if(return_value_asprintf_2 == -1)
    LogModule(1, MAIN, "Failed to allocate memory for uptime string.\n");

  value->u.string = uptimeStr;
  return 0;
}

// SysPropertyGetUptimeSecs
// file main.c line 609
static signed int SysPropertyGetUptimeSecs(void *userArg, struct PropertyValue_s *value)
{
  signed long int now;
  time(&now);
  double return_value_difftime_1;
  return_value_difftime_1=difftime(now, StartTime);
  value->u.integer = (signed int)return_value_difftime_1;
  return 0;
}

// TDTHandler
// file standard/dvb/tdtprocessor.c line 125
static void TDTHandler(void *arg, struct dvbpsi_tdt_tot_s *newTDT)
{
  EventsFireEventListeners(tdtEvent, (void *)newTDT);
  ObjectRefDecImpl((void *)newTDT, "standard/dvb/tdtprocessor.c", 128);
}

// TDTProcessorCreate
// file ../include/tdtprocessor.h line 29
struct TDTProcessor_s * TDTProcessorCreate(struct TSReader_t *reader)
{
  struct TDTProcessor_s *state;
  if(tdtEvent == ((struct Event_s *)NULL))
    tdtEvent=EventsRegisterEvent(DVBEventSource, "TDT", (signed int (*)(struct yaml_document_s *, struct Event_s *, void *))(void *)0);

  ObjectRegisterClass("TDTProcessor_t", (unsigned int)sizeof(struct TDTProcessor_s) /*16ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("TDTProcessor_t", "standard/dvb/tdtprocessor.c", 81);
  state = (struct TDTProcessor_s *)return_value_ObjectCreateImpl_1;
  if(!(state == ((struct TDTProcessor_s *)NULL)))
    state->tsgroup=TSReaderCreateFilterGroup(reader, TDTPROCESSOR, "DVB", TDTProcessorFilterEventCallback, (void *)state);

  return state;
}

// TDTProcessorDestroy
// file ../include/tdtprocessor.h line 30
void TDTProcessorDestroy(struct TDTProcessor_s *processor)
{
  TSFilterGroupDestroy(processor->tsgroup);
  if(!(processor->handle == ((struct dvbpsi_decoder_s *)NULL)))
    dvbpsi_DetachTDTTOT(processor->handle);

  ObjectRefDecImpl((void *)processor, "standard/dvb/tdtprocessor.c", 97);
}

// TDTProcessorFilterEventCallback
// file standard/dvb/tdtprocessor.c line 103
static void TDTProcessorFilterEventCallback(void *userArg, struct TSFilterGroup_t *group, enum TSFilterEventType_e event, void *details)
{
  struct TDTProcessor_s *state = (struct TDTProcessor_s *)userArg;
  if((signed int)event == TSFilterEventType_MuxChanged)
  {
    if(!(state->handle == ((struct dvbpsi_decoder_s *)NULL)))
    {
      TSFilterGroupRemoveSectionFilter(state->tsgroup, (unsigned short int)0x14);
      dvbpsi_DetachTDTTOT(state->handle);
    }

    if(!(details == NULL))
    {
      state->handle=dvbpsi_AttachTDTTOT(TDTHandler, (void *)state);
      TSFilterGroupAddSectionFilter(state->tsgroup, (unsigned short int)0x14, 2, state->handle);
    }

    else
      state->handle = (struct dvbpsi_decoder_s *)(void *)0;
  }

}

// TSFilterGroupAddPacketFilter
// file ts.c line 394
_Bool TSFilterGroupAddPacketFilter(struct TSFilterGroup_t *group, unsigned short int pid, void (*callback)(void *, struct TSFilterGroup_t *, struct TSPacket_t *), void *userArg)
{
  struct TSPacketFilter_t *packetFilter;
  _Bool result = (_Bool)1;
  if((signed int)pid >= 8193)
  {
    LogModule(1, TSREADER, "Invalid PID %u supplied to %s", pid, (const void *)"TSFilterGroupAddPacketFilter");
    return (_Bool)0;
  }

  else
  {
    pthread_mutex_lock(&group->tsReader->mutex);
    packetFilter = group->packetFilters;
    for( ; !(packetFilter == ((struct TSPacketFilter_t *)NULL)); packetFilter = packetFilter->next)
      if(packetFilter->pid == pid)
      {
        LogModule(3, TSREADER, "PID 0x%04x is already being packet filtered for filter group %s", pid, group->name);
        result = (_Bool)0;
        break;
      }

    if(!(result == (_Bool)0))
    {
      LogModule(3, TSREADER, "Adding packet filter 0x%04x for filter group %s", pid, group->name);
      packetFilter=PacketFilterListAddFilter(group->tsReader, group, pid, callback, userArg);
      if(!(packetFilter == ((struct TSPacketFilter_t *)NULL)))
      {
        packetFilter->next = group->packetFilters;
        group->packetFilters = packetFilter;
      }

      else
        result = (_Bool)0;
    }

    pthread_mutex_unlock(&group->tsReader->mutex);
    return result;
  }
}

// TSFilterGroupAddSectionFilter
// file ts.c line 345
void TSFilterGroupAddSectionFilter(struct TSFilterGroup_t *group, unsigned short int pid, signed int priority, struct dvbpsi_decoder_s *handle)
{
  struct TSSectionFilter_t *sectionFilter;
  do
    if((signed int)pid >= 8193)
    {
      LogModule(0, TSREADER, "Invalid PID %u supplied to %s", pid, (const void *)"TSFilterGroupAddSectionFilter");
      goto __CPROVER_DUMP_L3;
    }

  while((_Bool)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("TSSectionFilter_t", "ts.c", 351);
  sectionFilter = (struct TSSectionFilter_t *)return_value_ObjectCreateImpl_1;
  sectionFilter->pid = pid;
  sectionFilter->priority = priority;
  sectionFilter->sectionHandle = handle;
  sectionFilter->group = group;
  LogModule(3, TSREADER, "Adding section filter 0x%04x for filter group %s", pid, group->name);
  pthread_mutex_lock(&group->tsReader->mutex);
  sectionFilter->next = group->sectionFilters;
  group->sectionFilters = sectionFilter;
  SectionFilterListAddFilter(group->tsReader, sectionFilter);
  pthread_mutex_unlock(&group->tsReader->mutex);

__CPROVER_DUMP_L3:
  ;
}

// TSFilterGroupDestroy
// file ts.c line 301
void TSFilterGroupDestroy(struct TSFilterGroup_t *group)
{
  LogModule(3, TSREADER, "Destroying filter group %s", group->name);
  TSFilterGroupRemoveAllFilters(group);
  pthread_mutex_lock(&group->tsReader->mutex);
  ListRemove(group->tsReader->groups, (void *)group);
  pthread_mutex_unlock(&group->tsReader->mutex);
  ObjectRefDecImpl((void *)group, "ts.c", 308);
}

// TSFilterGroupRemoveAllFilters
// file ts.c line 320
void TSFilterGroupRemoveAllFilters(struct TSFilterGroup_t *group)
{
  struct TSPacketFilter_t *packetFilter;
  struct TSPacketFilter_t *packetFilterNext;
  struct TSSectionFilter_t *sectionFilter;
  struct TSSectionFilter_t *sectionFilterNext;
  LogModule(3, TSREADER, "Removing all filters for filter group %s", group->name);
  pthread_mutex_lock(&group->tsReader->mutex);
  packetFilter = group->packetFilters;
  for( ; !(packetFilter == ((struct TSPacketFilter_t *)NULL)); packetFilter = packetFilterNext)
  {
    LogModule(3, TSREADER, "Removing %p", packetFilter);
    packetFilterNext = packetFilter->next;
    PacketFilterListRemoveFilter(group->tsReader, packetFilter);
  }
  group->packetFilters = (struct TSPacketFilter_t *)(void *)0;
  sectionFilter = group->sectionFilters;
  for( ; !(sectionFilter == ((struct TSSectionFilter_t *)NULL)); sectionFilter = sectionFilterNext)
  {
    SectionFilterListRemoveFilter(group->tsReader, sectionFilter);
    sectionFilterNext = sectionFilter->next;
    ObjectRefDecImpl((void *)sectionFilter, "ts.c", 339);
  }
  group->sectionFilters = (struct TSSectionFilter_t *)(void *)0;
  pthread_mutex_unlock(&group->tsReader->mutex);
}

// TSFilterGroupRemovePacketFilter
// file ts.c line 434
void TSFilterGroupRemovePacketFilter(struct TSFilterGroup_t *group, unsigned short int pid)
{
  struct TSPacketFilter_t *packetFilter;
  struct TSPacketFilter_t *packetFilterPrev = (struct TSPacketFilter_t *)(void *)0;
  do
    if((signed int)pid >= 8193)
    {
      LogModule(0, TSREADER, "Invalid PID %u supplied to %s", pid, (const void *)"TSFilterGroupRemovePacketFilter");
      goto __CPROVER_DUMP_L8;
    }

  while((_Bool)0);
  LogModule(3, TSREADER, "Removing packet filter 0x%04x for filter group %s", pid, group->name);
  pthread_mutex_lock(&group->tsReader->mutex);
  packetFilter = group->packetFilters;
  for( ; !(packetFilter == ((struct TSPacketFilter_t *)NULL)); packetFilter = packetFilter->next)
  {
    if(packetFilter->pid == pid)
    {
      if(!(packetFilterPrev == ((struct TSPacketFilter_t *)NULL)))
        packetFilterPrev->next = packetFilter->next;

      else
        group->packetFilters = packetFilter->next;
      PacketFilterListRemoveFilter(group->tsReader, packetFilter);
      break;
    }

    packetFilterPrev = packetFilter;
  }
  pthread_mutex_unlock(&group->tsReader->mutex);

__CPROVER_DUMP_L8:
  ;
}

// TSFilterGroupRemoveSectionFilter
// file ts.c line 364
void TSFilterGroupRemoveSectionFilter(struct TSFilterGroup_t *group, unsigned short int pid)
{
  struct TSSectionFilter_t *sectionFilter;
  struct TSSectionFilter_t *sectionFilterPrev = (struct TSSectionFilter_t *)(void *)0;
  do
    if((signed int)pid >= 8193)
    {
      LogModule(0, TSREADER, "Invalid PID %u supplied to %s", pid, (const void *)"TSFilterGroupRemoveSectionFilter");
      goto __CPROVER_DUMP_L8;
    }

  while((_Bool)0);
  LogModule(3, TSREADER, "Removing section filter 0x%04x for filter group %s", pid, group->name);
  pthread_mutex_lock(&group->tsReader->mutex);
  sectionFilter = group->sectionFilters;
  for( ; !(sectionFilter == ((struct TSSectionFilter_t *)NULL)); sectionFilter = sectionFilter->next)
  {
    if(sectionFilter->pid == pid)
    {
      if(!(sectionFilterPrev == ((struct TSSectionFilter_t *)NULL)))
        sectionFilterPrev->next = sectionFilter->next;

      else
        group->sectionFilters = sectionFilter->next;
      SectionFilterListRemoveFilter(group->tsReader, sectionFilter);
      ObjectRefDecImpl((void *)sectionFilter, "ts.c", 386);
      break;
    }

    sectionFilterPrev = sectionFilter;
  }
  pthread_mutex_unlock(&group->tsReader->mutex);

__CPROVER_DUMP_L8:
  ;
}

// TSFilterGroupResetStats
// file ts.c line 311
void TSFilterGroupResetStats(struct TSFilterGroup_t *group)
{
  LogModule(3, TSREADER, "Resetting stats for filter group %s", group->name);
  pthread_mutex_lock(&group->tsReader->mutex);
  group->packetFilters = ((struct TSPacketFilter_t *)NULL);
  group->sectionFilters = ((struct TSSectionFilter_t *)NULL);
  pthread_mutex_unlock(&group->tsReader->mutex);
}

// TSReaderBitrateCallback
// file ts.c line 908
static void TSReaderBitrateCallback(struct ev_loop *loop, struct ev_timer *w, signed int revents)
{
  struct TSReader_t *reader = (struct TSReader_t *)w->data;
  reader->bitrate = (unsigned long int)((reader->totalPackets - reader->prevTotalPackets) * (unsigned long int)(188 * 8));
  reader->prevTotalPackets = reader->totalPackets;
}

// TSReaderCreate
// file ../include/ts.h line 299
struct TSReader_t * TSReaderCreate(struct DVBAdapter_s *adapter)
{
  struct TSReader_t *result;
  struct ev_loop *inputLoop;
  ObjectRegisterClass("TSReader_t", (unsigned int)sizeof(struct TSReader_t) /*69600ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("TSFilterGroup_t", (unsigned int)sizeof(struct TSFilterGroup_t) /*72ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("TSSectionFilter_t", (unsigned int)sizeof(struct TSSectionFilter_t) /*32ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("TSSectionFilterList_t", (unsigned int)sizeof(struct TSSectionFilterList_t) /*48ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("TSPacketFilter_t", (unsigned int)sizeof(struct TSPacketFilter_t) /*48ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("TSReaderStats_t", (unsigned int)sizeof(struct TSReaderStats_t) /*24ul*/ , TSReaderStatsDestructor);
  ObjectRegisterClass("TSFilterGroupTypeStats_t", (unsigned int)sizeof(struct TSFilterGroupTypeStats_t) /*24ul*/ , (void (*)(void *))(void *)0);
  ObjectRegisterClass("TSFilterGroupStats_t", (unsigned int)sizeof(struct TSFilterGroupStats_t) /*32ul*/ , (void (*)(void *))(void *)0);
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("TSReader_t", "ts.c", 116);
  result = (struct TSReader_t *)return_value_ObjectCreateImpl_1;
  if(!(result == ((struct TSReader_t *)NULL)))
  {
    union anonymous_38 mutexAttr;
    result->adapter = adapter;
    DVBDemuxSetBufferSize(adapter, (unsigned long int)(20 * 188));
    result->groups=ListCreate();
    result->activeSectionFilters=ListCreate();
    result->sectionFilters=ListCreate();
    result->currentlyProcessingPid = (unsigned short int)0xffff;
    pthread_mutexattr_init(&mutexAttr);
    pthread_mutexattr_settype(&mutexAttr, 1);
    pthread_mutex_init(&result->mutex, &mutexAttr);
    pthread_mutexattr_destroy(&mutexAttr);
    inputLoop=DispatchersGetInput();
    do
    {

    __CPROVER_DUMP_L1:
      ;
      ((struct ev_watcher *)(void *)&result->dvrWatcher)->pending = 0;
      ((struct ev_watcher *)(void *)&result->dvrWatcher)->active = ((struct ev_watcher *)(void *)&result->dvrWatcher)->pending;
      ((struct ev_watcher *)(void *)&result->dvrWatcher)->priority = 0;
      (&result->dvrWatcher)->cb = TSReaderDVRCallback;
      memmove((void *)&((struct ev_watcher *)&result->dvrWatcher)->cb, (const void *)&(&result->dvrWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_io *, signed int)) /*8ul*/ );
      do
      {
        (&result->dvrWatcher)->fd=DVBDVRGetFD(adapter);
        (&result->dvrWatcher)->events = 1 | 128;
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L3:
      ;
      ((struct ev_watcher *)(void *)&result->bitrateWatcher)->pending = 0;
      ((struct ev_watcher *)(void *)&result->bitrateWatcher)->active = ((struct ev_watcher *)(void *)&result->bitrateWatcher)->pending;
      ((struct ev_watcher *)(void *)&result->bitrateWatcher)->priority = 0;
      (&result->bitrateWatcher)->cb = TSReaderBitrateCallback;
      memmove((void *)&((struct ev_watcher *)&result->bitrateWatcher)->cb, (const void *)&(&result->bitrateWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_timer *, signed int)) /*8ul*/ );
      do
      {
        ((struct ev_watcher_time *)&result->bitrateWatcher)->at = 1.0;
        (&result->bitrateWatcher)->repeat = 1.0;
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L5:
      ;
      ((struct ev_watcher *)(void *)&result->notificationWatcher)->pending = 0;
      ((struct ev_watcher *)(void *)&result->notificationWatcher)->active = ((struct ev_watcher *)(void *)&result->notificationWatcher)->pending;
      ((struct ev_watcher *)(void *)&result->notificationWatcher)->priority = 0;
      (&result->notificationWatcher)->cb = TSReaderNotificationCallback;
      memmove((void *)&((struct ev_watcher *)&result->notificationWatcher)->cb, (const void *)&(&result->notificationWatcher)->cb, sizeof(void (*)(struct ev_loop *, struct ev_async *, signed int)) /*8ul*/ );
    }
    while((_Bool)0);
    result->dvrWatcher.data = (void *)result;
    result->bitrateWatcher.data = (void *)result;
    result->notificationWatcher.data = (void *)result;
    ev_io_start(inputLoop, &result->dvrWatcher);
    ev_timer_start(inputLoop, &result->bitrateWatcher);
    ev_async_start(inputLoop, &result->notificationWatcher);
  }

  return result;
}

// TSReaderCreateFilterGroup
// file ts.c line 264
struct TSFilterGroup_t * TSReaderCreateFilterGroup(struct TSReader_t *reader, const char *name, const char *type, void (*callback)(void *, struct TSFilterGroup_t *, enum TSFilterEventType_e, void *), void *userArg)
{
  struct TSFilterGroup_t *group;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("TSFilterGroup_t", "ts.c", 266);
  group = (struct TSFilterGroup_t *)return_value_ObjectCreateImpl_1;
  if(!(group == ((struct TSFilterGroup_t *)NULL)))
  {
    group->name = (char *)name;
    group->type = (char *)type;
    group->eventCallback = callback;
    group->userArg = userArg;
    group->tsReader = reader;
    pthread_mutex_lock(&reader->mutex);
    ListAdd(reader->groups, (void *)group);
    pthread_mutex_unlock(&reader->mutex);
  }

  return group;
}

// TSReaderDVRCallback
// file ts.c line 875
static void TSReaderDVRCallback(struct ev_loop *loop, struct ev_io *w, signed int revents)
{
  struct TSReader_t *reader = (struct TSReader_t *)w->data;
  struct DVBAdapter_s *adapter = reader->adapter;
  signed int count;
  signed int p;
  signed int return_value_DVBDVRGetFD_1;
  return_value_DVBDVRGetFD_1=DVBDVRGetFD(adapter);
  signed long int return_value_read_2;
  return_value_read_2=read(return_value_DVBDVRGetFD_1, (void *)(char *)reader->buffer, sizeof(struct TSPacket_t [20l]) /*3760ul*/ );
  count = (signed int)return_value_read_2;
  _Bool return_value_DVBFrontEndIsLocked_3;
  return_value_DVBFrontEndIsLocked_3=DVBFrontEndIsLocked(adapter);
  _Bool tmp_if_expr_4;
  if(return_value_DVBFrontEndIsLocked_3 == (_Bool)0)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = !(reader->enabled != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(!tmp_if_expr_4)
  {
    pthread_mutex_lock(&reader->mutex);
    p = 0;
    do
    {
      if(!(p >= count / 188))
        tmp_if_expr_5 = reader->enabled != (_Bool)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(!tmp_if_expr_5)
        break;

      if((0x80 & (signed int)reader->buffer[(signed long int)p].header[1l]) == 0x00)
      {
        ProcessPacket(reader, &reader->buffer[(signed long int)p]);
        if(!(reader->tsStructureChanged == (_Bool)0))
        {
          InformTSStructureChanged(reader);
          reader->tsStructureChanged = (_Bool)0;
        }

      }

      p = p + 1;
    }
    while((_Bool)1);
    pthread_mutex_unlock(&reader->mutex);
  }

}

// TSReaderDestroy
// file ../include/ts.h line 305
void TSReaderDestroy(struct TSReader_t *reader)
{
  signed int i;
  struct ev_loop *inputLoop;
  inputLoop=DispatchersGetInput();
  ev_io_stop(inputLoop, &reader->dvrWatcher);
  ev_timer_stop(inputLoop, &reader->bitrateWatcher);
  SectionFilterListDescheduleFilters(reader);
  pthread_mutex_destroy(&reader->mutex);
  ListFree(reader->groups, (void (*)(void *))TSFilterGroupDestroy);
  i = 0;
  for( ; !(i >= 8193); i = i + 1)
    if(reader->packetFilters[(signed long int)i] == ((struct TSPacketFilter_t *)NULL))
    {
      struct TSPacketFilter_t *cur;
      struct TSPacketFilter_t *next;
      DVBDemuxReleaseFilter(reader->adapter, (unsigned short int)i);
      cur = reader->packetFilters[(signed long int)i];
      for( ; !(cur == ((struct TSPacketFilter_t *)NULL)); cur = next)
      {
        next = cur->next;
        if(!(cur->group == ((struct TSFilterGroup_t *)NULL)))
          ObjectRefDecImpl((void *)cur, "ts.c", 167);

      }
    }

  ListFree(reader->activeSectionFilters, (void (*)(void *))(void *)0);
  ListFree(reader->sectionFilters, (void (*)(void *))(void *)0);
  ObjectRefDecImpl((void *)reader, "ts.c", 175);
}

// TSReaderEnable
// file ../include/ts.h line 312
void TSReaderEnable(struct TSReader_t *reader, _Bool enable)
{
  pthread_mutex_lock(&reader->mutex);
  reader->enabled = enable;
  pthread_mutex_unlock(&reader->mutex);
}

// TSReaderExtractStats
// file ts.c line 186
struct TSReaderStats_t * TSReaderExtractStats(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  struct TSReaderStats_t *stats;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("TSReaderStats_t", "ts.c", 189);
  stats = (struct TSReaderStats_t *)return_value_ObjectCreateImpl_1;
  pthread_mutex_lock(&reader->mutex);
  stats->totalPackets = reader->totalPackets;
  stats->bitrate = reader->bitrate;
  iterator.current = reader->groups->head;
  iterator.list = reader->groups;
  struct ListEntry_s *tmp_if_expr_2;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_2)
  {
    struct TSFilterGroup_t *group = (struct TSFilterGroup_t *)iterator.current->data;
    struct TSFilterGroupStats_t *filterGroupStats;
    void *return_value_ObjectCreateImpl_3;
    return_value_ObjectCreateImpl_3=ObjectCreateImpl("TSFilterGroupStats_t", "ts.c", 200);
    filterGroupStats = (struct TSFilterGroupStats_t *)return_value_ObjectCreateImpl_3;
    filterGroupStats->name = group->name;
    filterGroupStats->packetsProcessed = group->packetsProcessed;
    filterGroupStats->sectionsProcessed = group->sectionsProcessed;
    StatsAddFilterGroupStats(stats, group->type, filterGroupStats);
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_2 = iterator.current->next;

    else
      tmp_if_expr_2 = (struct ListEntry_s *)(void *)0;
  }
  pthread_mutex_unlock(&reader->mutex);
  return stats;
}

// TSReaderFindFilterGroup
// file ts.c line 282
struct TSFilterGroup_t * TSReaderFindFilterGroup(struct TSReader_t *reader, const char *name, const char *type)
{
  struct ListIterator_s iterator;
  struct TSFilterGroup_t *result = (struct TSFilterGroup_t *)(void *)0;
  pthread_mutex_lock(&reader->mutex);
  iterator.current = reader->groups->head;
  iterator.list = reader->groups;
  signed int return_value_strcmp_2;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSFilterGroup_t *group = (struct TSFilterGroup_t *)iterator.current->data;
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(group->name, name);
    if(return_value_strcmp_3 == 0)
    {
      return_value_strcmp_2=strcmp(group->type, type);
      if(return_value_strcmp_2 == 0)
      {
        result = group;
        break;
      }

    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  pthread_mutex_unlock(&reader->mutex);
  return result;
}

// TSReaderMultiplexChanged
// file ../include/ts.h line 334
void TSReaderMultiplexChanged(struct TSReader_t *reader, struct Multiplex_s *newmultiplex)
{
  struct ev_loop *inputLoop;
  inputLoop=DispatchersGetInput();
  reader->multiplexChanged = (_Bool)1;
  reader->multiplex = newmultiplex;
  LogModule(1, TSREADER, "Notifying mux changed!");
  ev_async_send(inputLoop, &reader->notificationWatcher);
}

// TSReaderNotificationCallback
// file ts.c line 915
static void TSReaderNotificationCallback(struct ev_loop *loop, struct ev_async *w, signed int revents)
{
  struct TSReader_t *reader = (struct TSReader_t *)w->data;
  if(!(reader->multiplexChanged == (_Bool)0))
  {
    LogModule(1, TSREADER, "Informing mux changed!");
    InformMultiplexChanged(reader);
    reader->multiplexChanged = (_Bool)0;
  }

}

// TSReaderSectionFilterOverridePriority
// file ts.c line 238
void TSReaderSectionFilterOverridePriority(struct TSReader_t *reader, unsigned short int pid, signed int priority)
{
  struct TSSectionFilterList_t *sfList;
  pthread_mutex_lock(&reader->mutex);
  sfList=SectionFilterListFind(reader, pid);
  if(!(sfList == ((struct TSSectionFilterList_t *)NULL)))
  {
    sfList->priority = priority;
    sfList->flags = sfList->flags | (unsigned int)2;
  }

  pthread_mutex_unlock(&reader->mutex);
}

// TSReaderSectionFilterResetPriority
// file ts.c line 251
void TSReaderSectionFilterResetPriority(struct TSReader_t *reader, unsigned short int pid)
{
  struct TSSectionFilterList_t *sfList;
  pthread_mutex_lock(&reader->mutex);
  sfList=SectionFilterListFind(reader, pid);
  if(!(sfList == ((struct TSSectionFilterList_t *)NULL)))
  {
    SectionFilterListUpdatePriority(sfList);
    sfList->flags = sfList->flags & (unsigned int)~2;
  }

  pthread_mutex_unlock(&reader->mutex);
}

// TSReaderStatsDestructor
// file ts.c line 467
static void TSReaderStatsDestructor(void *ptr)
{
  struct TSReaderStats_t *stats = (struct TSReaderStats_t *)ptr;
  struct TSFilterGroupTypeStats_t *typeStats;
  struct TSFilterGroupTypeStats_t *typeStatsNext;
  typeStats = stats->types;
  for( ; !(typeStats == ((struct TSFilterGroupTypeStats_t *)NULL)); typeStats = typeStatsNext)
  {
    struct TSFilterGroupStats_t *groupStats;
    struct TSFilterGroupStats_t *groupStatsNext;
    groupStats = typeStats->groups;
    for( ; !(groupStats == ((struct TSFilterGroupStats_t *)NULL)); groupStats = groupStatsNext)
    {
      groupStatsNext = groupStats->next;
      ObjectRefDecImpl((void *)groupStats, "ts.c", 479);
    }
    typeStatsNext = typeStats->next;
    ObjectRefDecImpl((void *)typeStats, "ts.c", 482);
  }
}

// TSReaderZeroStats
// file ../include/ts.h line 327
void TSReaderZeroStats(struct TSReader_t *reader)
{
  struct ListIterator_s iterator;
  pthread_mutex_lock(&reader->mutex);
  reader->totalPackets = (volatile unsigned long long int)0;
  reader->bitrate = (volatile unsigned long int)0;
  iterator.current = reader->groups->head;
  iterator.list = reader->groups;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct TSFilterGroup_t *group = (struct TSFilterGroup_t *)iterator.current->data;
    group->packetsProcessed = (volatile unsigned long long int)0;
    group->sectionsProcessed = (volatile unsigned long long int)0;
    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
  pthread_mutex_unlock(&reader->mutex);
}

// TableEventCallback
// file pluginmgr.c line 487
static void TableEventCallback(void *arg, struct Event_s *event, void *details)
{
  void (*callback)(void *) = (void (*)(void *))arg;
  callback(details);
}

// TimeoutWatcher
// file commands/cmd_scanning.c line 1571
static void TimeoutWatcher(struct ev_loop *loop, struct ev_timer *w, signed int revents)
{
  ScanStateMachine((enum ScanEvent_e)ScanEvent_TimerTick);
  ev_timer_again(loop, w);
}

// Tokenise
// file commands.c line 501
static char ** Tokenise(char *arguments, signed int *argc)
{
  signed int currentarg = 0;
  char *start = arguments;
  char *end;
  char t;
  char **args;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(char *) /*8ul*/ , (unsigned long int)10);
  args = (char **)return_value_calloc_1;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_2;
  const unsigned short int **return_value___ctype_b_loc_4;
  while(!(*start == 0))
  {
    _Bool doubleQuotesOpen = (_Bool)0;
    _Bool singleQuotesOpen = (_Bool)0;
    do
    {
      if(!(*start == 0))
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        tmp_if_expr_3 = ((signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*start] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      start = start + 1l;
    }
    while((_Bool)1);
    if((signed int)*start == 34)
    {
      doubleQuotesOpen = (_Bool)1;
      start = start + 1l;
    }

    if((signed int)*start == 39)
    {
      singleQuotesOpen = (_Bool)1;
      start = start + 1l;
    }

    end = start;
    for( ; !(*end == 0); end = end + 1l)
      if(!(doubleQuotesOpen == (_Bool)0))
      {
        if((signed int)*end == 34)
          break;

      }

      else
        if(!(singleQuotesOpen == (_Bool)0))
        {
          if((signed int)*end == 39)
            break;

        }

        else
        {
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*end]) == 0))
            break;

        }
    t = end[(signed long int)0];
    end[(signed long int)0] = (char)0;
    args[(signed long int)currentarg]=strdup(start);
    end[(signed long int)0] = t;
    start = end;
    if(!(doubleQuotesOpen == (_Bool)0) || !(singleQuotesOpen == (_Bool)0))
      start = start + 1l;

    currentarg = currentarg + 1;
    if(currentarg >= 10)
      break;

  }
  *argc = currentarg;
  return args;
}

// TransponderEntryDestructor
// file commands/cmd_scanning.c line 1877
static void TransponderEntryDestructor(void *ptr)
{
  struct TransponderEntry_s *entry = (struct TransponderEntry_s *)ptr;
  if(!(entry->tuningParams == ((char *)NULL)))
    free((void *)entry->tuningParams);

}

// TryTuneDVBC
// file commands/cmd_scanning.c line 804
static void TryTuneDVBC(struct MultiplexList_s *muxList, struct MuxFrequencies_s *muxFreqList, unsigned int freq, char *inversion, char *code_rate, unsigned int *symbolRates, signed int nrofSymbolRates, char **modulations, signed int nrofModulations)
{
  struct Multiplex_s *mux;
  struct TuningParamDocs_s *docs;
  signed int s;
  signed int m;
  mux=FindMultiplexFrequency(muxList, muxFreqList, (unsigned long int)freq, 0, (char *)(void *)0, 0);
  if(!(mux == ((struct Multiplex_s *)NULL)))
    ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_DVBC, mux, (struct TuningParamDocs_s *)(void *)0);

  else
  {
    struct ObjectCollection_s *return_value_ObjectCollectionCreateImpl_1;
    return_value_ObjectCollectionCreateImpl_1=ObjectCollectionCreateImpl("TuningParamDocs_t", (unsigned int)(nrofSymbolRates * nrofModulations), "commands/cmd_scanning.c", 819);
    docs = (struct TuningParamDocs_s *)return_value_ObjectCollectionCreateImpl_1;
    s = 0;
    for( ; !(s >= nrofSymbolRates); s = s + 1)
    {
      m = 0;
      for( ; !(m >= nrofModulations); m = m + 1)
      {
        asprintf(&docs->docs[(signed long int)(s * m)], "Frequency: %u\nInversion: %s\nFEC: %s\nSymbol Rate: %u\nModulation: %s\n", freq, inversion, code_rate, symbolRates[(signed long int)s], modulations[(signed long int)m]);
        ScanListAddEntry((enum DVBDeliverySystem_e)DELSYS_DVBC, (struct Multiplex_s *)(void *)0, docs);
      }
    }
  }
}

// TuneMultiplex
// file tuning.c line 243
static void TuneMultiplex(struct Multiplex_s *multiplex)
{
  struct DVBAdapter_s *dvbAdapter;
  dvbAdapter=MainDVBAdapterGet();
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  do
    if(!(CurrentMultiplex == ((struct Multiplex_s *)NULL)))
      ObjectRefDecImpl((void *)CurrentMultiplex, "tuning.c", 248);

  while((_Bool)0);
  LogModule(4, TUNING, "Caching Services\n");
  CacheLoad(multiplex);
  do
    if(!(multiplex == ((struct Multiplex_s *)NULL)))
      ObjectRefIncImpl((void *)multiplex, "tuning.c", 253);

  while((_Bool)0);
  CurrentMultiplex = multiplex;
  LogModule(4, TUNING, "Tuning\n");
  signed int return_value_DVBFrontEndTune_1;
  return_value_DVBFrontEndTune_1=DVBFrontEndTune(dvbAdapter, multiplex->deliverySystem, multiplex->tuningParams);
  if(!(return_value_DVBFrontEndTune_1 == 0))
    LogModule(0, TUNING, "Tuning failed!\n");

  LogModule(4, TUNING, "Informing TSReader multiplex has changed!\n");
  TSReaderMultiplexChanged(reader, CurrentMultiplex);
  EventsFireEventListeners(mulitplexChangedEvent, (void *)multiplex);
}

// TuningCurrentMultiplexGet
// file tuning.c line 208
struct Multiplex_s * TuningCurrentMultiplexGet(void)
{
  do
    if(!(CurrentMultiplex == ((struct Multiplex_s *)NULL)))
      ObjectRefIncImpl((void *)CurrentMultiplex, "tuning.c", 210);

  while((_Bool)0);
  return CurrentMultiplex;
}

// TuningCurrentMultiplexSet
// file tuning.c line 214
void TuningCurrentMultiplexSet(struct Multiplex_s *multiplex)
{
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  pthread_mutex_lock(&reader->mutex);
  LogModule(3, TUNING, "Writing changes back to database.\n");
  CacheWriteback();
  pthread_mutex_unlock(&reader->mutex);
  LogModule(4, TUNING, "Disabling filters\n");
  TSReaderEnable(reader, (_Bool)0);
  TuneMultiplex(multiplex);
  TSReaderZeroStats(reader);
  EventsFireEventListeners(serviceChangedEvent, (void *)0);
  LogModule(4, TUNING, "Enabling filters\n");
  TSReaderEnable(reader, (_Bool)1);
}

// TuningCurrentServiceGet
// file tuning.c line 107
struct Service_t * TuningCurrentServiceGet(void)
{
  do
    if(!(CurrentService == ((struct Service_t *)NULL)))
      ObjectRefIncImpl((void *)CurrentService, "tuning.c", 109);

  while((_Bool)0);
  return CurrentService;
}

// TuningCurrentServiceIsLocked
// file tuning.c line 98
_Bool TuningCurrentServiceIsLocked(void)
{
  _Bool r;
  pthread_mutex_lock(&lockMutex);
  r = locked;
  pthread_mutex_unlock(&lockMutex);
  return r;
}

// TuningCurrentServiceLock
// file tuning.c line 78
_Bool TuningCurrentServiceLock(void)
{
  _Bool r = (_Bool)0;
  pthread_mutex_lock(&lockMutex);
  if(locked == (_Bool)0)
  {
    locked = (_Bool)1;
    r = (_Bool)1;
  }

  pthread_mutex_unlock(&lockMutex);
  return r;
}

// TuningCurrentServiceRetune
// file tuning.c line 172
void TuningCurrentServiceRetune(void)
{
  struct Multiplex_s *multiplex;
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  _Bool tmp_if_expr_1;
  if(!(CurrentService == ((struct Service_t *)NULL)))
  {
    LogModule(4, TUNING, "Disabling filters\n");
    TSReaderEnable(reader, (_Bool)0);
    multiplex=MultiplexFindUID(CurrentService->multiplexUID);
    if(!(CurrentMultiplex == ((struct Multiplex_s *)NULL)))
      tmp_if_expr_1 = multiplex->uid == CurrentMultiplex->uid ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      LogModule(4, TUNING, "Same multiplex\n");
      ObjectRefDecImpl((void *)multiplex, "tuning.c", 187);
      multiplex = CurrentMultiplex;
      ObjectRefIncImpl((void *)multiplex, "tuning.c", 189);
    }

    else
      LogModule(3, TUNING, "New Multiplex UID = %d (%04x.%04x)\n", multiplex->uid, multiplex->networkId & 0xffff, multiplex->tsId & 0xffff);
    TuneMultiplex(multiplex);
    TSReaderZeroStats(reader);
    do
      if(!(multiplex == ((struct Multiplex_s *)NULL)))
        ObjectRefDecImpl((void *)multiplex, "tuning.c", 201);

    while((_Bool)0);
    LogModule(4, TUNING, "Enabling filters\n");
    TSReaderEnable(reader, (_Bool)1);
  }

}

// TuningCurrentServiceSet
// file tuning.c line 113
_Bool TuningCurrentServiceSet(struct Service_t *service)
{
  struct Multiplex_s *multiplex;
  struct TSReader_t *reader;
  reader=MainTSReaderGet();
  struct ServiceFilter_s *primaryServiceFilter;
  primaryServiceFilter=MainServiceFilterGetPrimary();
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(service == ((struct Service_t *)NULL))
    return (_Bool)0;

  else
  {
    _Bool return_value_TuningCurrentServiceIsLocked_1;
    return_value_TuningCurrentServiceIsLocked_1=TuningCurrentServiceIsLocked();
    if(!(return_value_TuningCurrentServiceIsLocked_1 == (_Bool)0))
      return (_Bool)0;

    else
    {
      if(CurrentService == ((struct Service_t *)NULL))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        if(service->multiplexUID == CurrentService->multiplexUID)
          tmp_if_expr_3 = service->id == CurrentService->id ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        tmp_if_expr_4 = !tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
      {
        LogModule(4, TUNING, "Disabling filters\n");
        TSReaderEnable(reader, (_Bool)0);
        multiplex=MultiplexFindUID(service->multiplexUID);
        if(!(CurrentMultiplex == ((struct Multiplex_s *)NULL)))
          tmp_if_expr_2 = multiplex->uid == CurrentMultiplex->uid ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          LogModule(4, TUNING, "Same multiplex\n");

        else
        {
          LogModule(3, TUNING, "New Multiplex UID = %d (%04x.%04x)\n", multiplex->uid, multiplex->networkId & 0xffff, multiplex->tsId & 0xffff);
          TuneMultiplex(multiplex);
          TSReaderZeroStats(reader);
        }
        do
          if(!(multiplex == ((struct Multiplex_s *)NULL)))
            ObjectRefDecImpl((void *)multiplex, "tuning.c", 150);

        while((_Bool)0);
        if(!(CurrentService == ((struct Service_t *)NULL)))
          do
            if(!(CurrentService == ((struct Service_t *)NULL)))
              ObjectRefDecImpl((void *)CurrentService, "tuning.c", 154);

          while((_Bool)0);

        CurrentService=CacheServiceFindId(service->id);
        ServiceFilterServiceSet(primaryServiceFilter, CurrentService);
        EventsFireEventListeners(serviceChangedEvent, (void *)CurrentService);
        LogModule(4, TUNING, "Enabling filters\n");
        TSReaderEnable(reader, (_Bool)1);
      }

      return (_Bool)1;
    }
  }
}

// TuningCurrentServiceUnlock
// file tuning.c line 91
void TuningCurrentServiceUnlock(void)
{
  pthread_mutex_lock(&lockMutex);
  locked = (_Bool)0;
  pthread_mutex_unlock(&lockMutex);
}

// TuningDeInit
// file ../include/tuning.h line 68
signed int TuningDeInit(void)
{
  do
    if(!(CurrentMultiplex == ((struct Multiplex_s *)NULL)))
      ObjectRefDecImpl((void *)CurrentMultiplex, "tuning.c", 68);

  while((_Bool)0);
  do
    if(!(CurrentService == ((struct Service_t *)NULL)))
      ObjectRefDecImpl((void *)CurrentService, "tuning.c", 69);

  while((_Bool)0);
  EventsUnregisterSource(tuningSource);
  return 0;
}

// TuningInit
// file ../include/tuning.h line 63
signed int TuningInit(void)
{
  tuningSource=EventsRegisterSource("Tuning");
  serviceChangedEvent=EventsRegisterEvent(tuningSource, "ServiceChanged", ServiceEventToString);
  mulitplexChangedEvent=EventsRegisterEvent(tuningSource, "MultiplexChanged", MultiplexEventToString);
  return 0;
}

// TuningParamDocsDestructor
// file commands/cmd_scanning.c line 1886
static void TuningParamDocsDestructor(void *ptr)
{
  struct TuningParamDocs_s *docs = (struct TuningParamDocs_s *)ptr;
  signed int i = 0;
  for( ; !(i >= docs->nrofDocs); i = i + 1)
    if(!(docs->docs[(signed long int)i] == ((char *)NULL)))
      free((void *)docs->docs[(signed long int)i]);

}

// UTF8_charnum
// file utf8.c line 191
signed int UTF8_charnum(char *s, signed int offset)
{
  signed int charnum = 0;
  signed int offs = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; !(offs >= offset); charnum = charnum + 1)
  {
    if(s[(signed long int)offs] == 0)
      break;

    offs = offs + 1;
    if(!((0xC0 & (signed int)s[(signed long int)offs]) == 0x80))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      offs = offs + 1;
      tmp_if_expr_1 = ((signed int)s[(signed long int)offs] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      offs = offs + 1;
      tmp_if_expr_2 = ((signed int)s[(signed long int)offs] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      (_Bool)1;

    else
    {
      offs = offs + 1;
      if(!(offs == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }
  }
  return charnum;
}

// UTF8_dec
// file utf8.c line 237
void UTF8_dec(char *s, signed int *i)
{
  *i = *i - 1;
  _Bool tmp_if_expr_1;
  if(!((0xC0 & (signed int)s[(signed long int)*i]) == 0x80))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    *i = *i - 1;
    tmp_if_expr_1 = ((signed int)s[(signed long int)*i] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    *i = *i - 1;
    tmp_if_expr_2 = ((signed int)s[(signed long int)*i] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    (_Bool)1;

  else
  {
    *i = *i - 1;
    if(!(*i == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }
}

// UTF8_escape
// file utf8.c line 369
signed int UTF8_escape(char *buf, signed int sz, char *src, signed int escape_quotes)
{
  signed int c = 0;
  signed int i = 0;
  signed int amt;
  _Bool tmp_if_expr_2;
  for( ; !(src[(signed long int)i] == 0); buf = buf + (signed long int)amt)
  {
    if(c >= sz)
      break;

    if(!(escape_quotes == 0))
      tmp_if_expr_2 = (signed int)src[(signed long int)i] == 34 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
    {
      amt=snprintf(buf, (unsigned long int)(sz - c), "\\\"");
      i = i + 1;
    }

    else
    {
      unsigned int return_value_UTF8_nextchar_1;
      return_value_UTF8_nextchar_1=UTF8_nextchar(src, &i);
      amt=UTF8_escape_wchar(buf, sz - c, return_value_UTF8_nextchar_1);
    }
    c = c + amt;
  }
  if(!(c >= sz))
    *buf = (char)0;

  return c;
}

// UTF8_escape_wchar
// file utf8.c line 341
signed int UTF8_escape_wchar(char *buf, signed int sz, unsigned int ch)
{
  signed int return_value_snprintf_1;
  signed int return_value_snprintf_2;
  signed int return_value_snprintf_3;
  signed int return_value_snprintf_4;
  signed int return_value_snprintf_5;
  signed int return_value_snprintf_6;
  signed int return_value_snprintf_7;
  signed int return_value_snprintf_8;
  signed int return_value_snprintf_9;
  signed int return_value_snprintf_10;
  signed int return_value_snprintf_11;
  if(ch == 10u)
  {
    return_value_snprintf_1=snprintf(buf, (unsigned long int)sz, "\\n");
    return return_value_snprintf_1;
  }

  else
    if(ch == 9u)
    {
      return_value_snprintf_2=snprintf(buf, (unsigned long int)sz, "\\t");
      return return_value_snprintf_2;
    }

    else
      if(ch == 13u)
      {
        return_value_snprintf_3=snprintf(buf, (unsigned long int)sz, "\\r");
        return return_value_snprintf_3;
      }

      else
        if(ch == 8u)
        {
          return_value_snprintf_4=snprintf(buf, (unsigned long int)sz, "\\b");
          return return_value_snprintf_4;
        }

        else
          if(ch == 12u)
          {
            return_value_snprintf_5=snprintf(buf, (unsigned long int)sz, "\\f");
            return return_value_snprintf_5;
          }

          else
            if(ch == 11u)
            {
              return_value_snprintf_6=snprintf(buf, (unsigned long int)sz, "\\v");
              return return_value_snprintf_6;
            }

            else
              if(ch == 7u)
              {
                return_value_snprintf_7=snprintf(buf, (unsigned long int)sz, "\\a");
                return return_value_snprintf_7;
              }

              else
                if(ch == 92u)
                {
                  return_value_snprintf_8=snprintf(buf, (unsigned long int)sz, "\\\\");
                  return return_value_snprintf_8;
                }

                else
                  if(ch == 127u || !(ch >= 32u))
                  {
                    return_value_snprintf_9=snprintf(buf, (unsigned long int)sz, "\\x%hhX", (unsigned char)ch);
                    return return_value_snprintf_9;
                  }

                  else
                    if(ch >= 65536u)
                    {
                      return_value_snprintf_10=snprintf(buf, (unsigned long int)sz, "\\U%.8X", (unsigned int)ch);
                      return return_value_snprintf_10;
                    }

                    else
                      if(ch >= 128u && !(ch >= 65536u))
                      {
                        return_value_snprintf_11=snprintf(buf, (unsigned long int)sz, "\\u%.4hX", (unsigned short int)ch);
                        return return_value_snprintf_11;
                      }

  signed int return_value_snprintf_12;
  return_value_snprintf_12=snprintf(buf, (unsigned long int)sz, "%c", (char)ch);
  return return_value_snprintf_12;
}

// UTF8_inc
// file utf8.c line 231
void UTF8_inc(char *s, signed int *i)
{
  *i = *i + 1;
  _Bool tmp_if_expr_1;
  if(!((0xC0 & (signed int)s[(signed long int)*i]) == 0x80))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    *i = *i + 1;
    tmp_if_expr_1 = ((signed int)s[(signed long int)*i] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    *i = *i + 1;
    tmp_if_expr_2 = ((signed int)s[(signed long int)*i] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    (_Bool)1;

  else
  {
    *i = *i + 1;
    if(!(*i == 0))
      (_Bool)1;

    else
      (_Bool)0;
  }
}

// UTF8_is_locale_utf8
// file utf8.c line 431
signed int UTF8_is_locale_utf8(char *locale)
{
  const char *cp = locale;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_8;
  signed int return_value_strncmp_7;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_10;
  signed int return_value_strncmp_9;
  do
  {
    if(!((signed int)*cp == 0))
      tmp_if_expr_1 = (signed int)*cp != 64 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (signed int)*cp != 43 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (signed int)*cp != 44 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    if((signed int)*cp == 46)
    {
      const char *encoding;
      cp = cp + 1l;
      encoding = cp;
      do
      {
        if(!((signed int)*cp == 0))
          tmp_if_expr_4 = (signed int)*cp != 64 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          tmp_if_expr_5 = (signed int)*cp != 43 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = (signed int)*cp != 44 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(!tmp_if_expr_6)
          break;

        cp = cp + 1l;
      }
      while((_Bool)1);
      if(cp - encoding == 5l)
      {
        return_value_strncmp_7=strncmp(encoding, "UTF-8", (unsigned long int)5);
        tmp_if_expr_8 = !(return_value_strncmp_7 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        if(cp - encoding == 4l)
        {
          return_value_strncmp_9=strncmp(encoding, "utf8", (unsigned long int)4);
          tmp_if_expr_10 = !(return_value_strncmp_9 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        return 1;

      break;
    }

    cp = cp + 1l;
  }
  while((_Bool)1);
  return 0;
}

// UTF8_memchr
// file utf8.c line 406
char * UTF8_memchr(char *s, unsigned int ch, unsigned long int sz, signed int *charn)
{
  signed int i = 0;
  signed int lasti = 0;
  unsigned int c;
  signed int csz;
  *charn = 0;
  signed int tmp_post_2;
  _Bool tmp_if_expr_1;
  for( ; !((unsigned long int)i >= sz); *charn = *charn + 1)
  {
    csz = 0;
    c = (unsigned int)csz;
    do
    {
      c = c << 6;
      tmp_post_2 = i;
      i = i + 1;
      c = c + (unsigned int)(unsigned char)s[(signed long int)tmp_post_2];
      csz = csz + 1;
      if(!((unsigned long int)i >= sz))
        tmp_if_expr_1 = !(((signed int)s[(signed long int)i] & 0xC0) != 0x80) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
    }
    while(tmp_if_expr_1);
    c = c - offsetsFromUTF8[(signed long int)(csz - 1)];
    if(c == ch)
      return &s[(signed long int)lasti];

    lasti = i;
  }
  return (char *)(void *)0;
}

// UTF8_nextchar
// file ../include/utf8.h line 25
unsigned int UTF8_nextchar(char *s, signed int *i)
{
  unsigned int ch = (unsigned int)0;
  signed int sz = 0;
  signed int tmp_post_2;
  _Bool tmp_if_expr_1;
  do
  {
    ch = ch << 6;
    tmp_post_2 = *i;
    *i = *i + 1;
    ch = ch + (unsigned int)(unsigned char)s[(signed long int)tmp_post_2];
    sz = sz + 1;
    if(!(s[(signed long int)*i] == 0))
      tmp_if_expr_1 = !(((signed int)s[(signed long int)*i] & 0xC0) != 0x80) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
  }
  while(tmp_if_expr_1);
  ch = ch - offsetsFromUTF8[(signed long int)(sz - 1)];
  return ch;
}

// UTF8_offset
// file utf8.c line 178
signed int UTF8_offset(char *str, signed int charnum)
{
  signed int offs = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; charnum >= 1; charnum = charnum - 1)
  {
    if(str[(signed long int)offs] == 0)
      break;

    offs = offs + 1;
    if(!((0xC0 & (signed int)str[(signed long int)offs]) == 0x80))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      offs = offs + 1;
      tmp_if_expr_1 = ((signed int)str[(signed long int)offs] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      offs = offs + 1;
      tmp_if_expr_2 = ((signed int)str[(signed long int)offs] & 0xC0) != 0x80 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      (_Bool)1;

    else
    {
      offs = offs + 1;
      if(!(offs == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }
  }
  return offs;
}

// UTF8_printf
// file utf8.c line 471
signed int UTF8_printf(char *fmt, ...)
{
  signed int cnt;
  void **args = (void **)&fmt;
  cnt=UTF8_vprintf(fmt, args);
  args = ((void **)NULL);
  return cnt;
}

// UTF8_read_escape_sequence
// file utf8.c line 257
signed int UTF8_read_escape_sequence(char *str, unsigned int *dest)
{
  unsigned int ch;
  char digs[9l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int dno = 0;
  signed int i = 1;
  ch = (unsigned int)str[(signed long int)0];
  signed int return_value_octal_digit_17;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int return_value_octal_digit_1;
  signed int return_value_hex_digit_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed long int return_value_strtol_8;
  signed int return_value_hex_digit_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed long int return_value_strtol_12;
  signed int return_value_hex_digit_13;
  signed int tmp_post_14;
  signed int tmp_post_15;
  signed long int return_value_strtol_16;
  if((signed int)*str == 110)
    ch = (unsigned int)10;

  else
    if((signed int)*str == 116)
      ch = (unsigned int)9;

    else
      if((signed int)*str == 114)
        ch = (unsigned int)13;

      else
        if((signed int)*str == 98)
          ch = (unsigned int)8;

        else
          if((signed int)*str == 102)
            ch = (unsigned int)12;

          else
            if((signed int)*str == 118)
              ch = (unsigned int)11;

            else
              if((signed int)*str == 97)
                ch = (unsigned int)7;

              else
              {
                return_value_octal_digit_17=octal_digit(str[(signed long int)0]);
                if(!(return_value_octal_digit_17 == 0))
                {
                  i = 0;
                  do
                  {
                    tmp_post_2 = dno;
                    dno = dno + 1;
                    tmp_post_3 = i;
                    i = i + 1;
                    digs[(signed long int)tmp_post_2] = str[(signed long int)tmp_post_3];
                    return_value_octal_digit_1=octal_digit(str[(signed long int)i]);
                  }
                  while(!(return_value_octal_digit_1 == 0) && !(dno >= 3));
                  signed long int return_value_strtol_4;
                  return_value_strtol_4=strtol(digs, (char ** restrict )(void *)0, 8);
                  ch = (unsigned int)return_value_strtol_4;
                }

                else
                  if((signed int)*str == 120)
                  {
                    do
                    {
                      return_value_hex_digit_5=hex_digit(str[(signed long int)i]);
                      if(return_value_hex_digit_5 == 0)
                        break;

                      if(dno >= 2)
                        break;

                      tmp_post_6 = dno;
                      dno = dno + 1;
                      tmp_post_7 = i;
                      i = i + 1;
                      digs[(signed long int)tmp_post_6] = str[(signed long int)tmp_post_7];
                    }
                    while((_Bool)1);
                    if(dno >= 1)
                    {
                      return_value_strtol_8=strtol(digs, (char ** restrict )(void *)0, 16);
                      ch = (unsigned int)return_value_strtol_8;
                    }

                  }

                  else
                    if((signed int)*str == 117)
                    {
                      do
                      {
                        return_value_hex_digit_9=hex_digit(str[(signed long int)i]);
                        if(return_value_hex_digit_9 == 0)
                          break;

                        if(dno >= 4)
                          break;

                        tmp_post_10 = dno;
                        dno = dno + 1;
                        tmp_post_11 = i;
                        i = i + 1;
                        digs[(signed long int)tmp_post_10] = str[(signed long int)tmp_post_11];
                      }
                      while((_Bool)1);
                      if(dno >= 1)
                      {
                        return_value_strtol_12=strtol(digs, (char ** restrict )(void *)0, 16);
                        ch = (unsigned int)return_value_strtol_12;
                      }

                    }

                    else
                      if((signed int)*str == 85)
                      {
                        do
                        {
                          return_value_hex_digit_13=hex_digit(str[(signed long int)i]);
                          if(return_value_hex_digit_13 == 0)
                            break;

                          if(dno >= 8)
                            break;

                          tmp_post_14 = dno;
                          dno = dno + 1;
                          tmp_post_15 = i;
                          i = i + 1;
                          digs[(signed long int)tmp_post_14] = str[(signed long int)tmp_post_15];
                        }
                        while((_Bool)1);
                        if(dno >= 1)
                        {
                          return_value_strtol_16=strtol(digs, (char ** restrict )(void *)0, 16);
                          ch = (unsigned int)return_value_strtol_16;
                        }

                      }

              }
  *dest = ch;
  return i;
}

// UTF8_seqlen
// file utf8.c line 49
signed int UTF8_seqlen(char *s)
{
  return (signed int)trailingBytesForUTF8[(signed long int)(unsigned int)(unsigned char)s[(signed long int)0]] + 1;
}

// UTF8_strchr
// file utf8.c line 389
char * UTF8_strchr(char *s, unsigned int ch, signed int *charn)
{
  signed int i = 0;
  signed int lasti = 0;
  unsigned int c;
  *charn = 0;
  for( ; !(s[(signed long int)i] == 0); *charn = *charn + 1)
  {
    c=UTF8_nextchar(s, &i);
    if(c == ch)
      return &s[(signed long int)lasti];

    lasti = i;
  }
  return (char *)(void *)0;
}

// UTF8_strlen
// file utf8.c line 204
signed int UTF8_strlen(char *s)
{
  signed int count = 0;
  signed int i = 0;
  unsigned int return_value_UTF8_nextchar_1;
  do
  {
    return_value_UTF8_nextchar_1=UTF8_nextchar(s, &i);
    if(return_value_UTF8_nextchar_1 == 0u)
      break;

    count = count + 1;
  }
  while((_Bool)1);
  return count;
}

// UTF8_toucs
// file utf8.c line 64
signed int UTF8_toucs(unsigned int *dest, signed int sz, char *src, signed int srcsz)
{
  unsigned int ch;
  char *src_end = src + (signed long int)srcsz;
  signed int nb;
  signed int i = 0;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  signed int tmp_post_5;
  for( ; !(i >= sz + -1); dest[(signed long int)tmp_post_5] = ch)
  {
    nb = (signed int)trailingBytesForUTF8[(signed long int)(unsigned char)*src];
    if(srcsz == -1)
    {
      if((signed int)*src == 0)
        break;

    }

    else
      if(src + (signed long int)nb >= src_end)
        break;

    ch = (unsigned int)0;
    switch(nb)
    {
      case 3:
      {
        tmp_post_1 = src;
        src = src + 1l;
        ch = ch + (unsigned int)(unsigned char)*tmp_post_1;
        ch = ch << 6;
      }
      case 2:
      {
        tmp_post_2 = src;
        src = src + 1l;
        ch = ch + (unsigned int)(unsigned char)*tmp_post_2;
        ch = ch << 6;
      }
      case 1:
      {
        tmp_post_3 = src;
        src = src + 1l;
        ch = ch + (unsigned int)(unsigned char)*tmp_post_3;
        ch = ch << 6;
      }
      case 0:
      {
        tmp_post_4 = src;
        src = src + 1l;
        ch = ch + (unsigned int)(unsigned char)*tmp_post_4;
      }
    }
    ch = ch - offsetsFromUTF8[(signed long int)nb];
    tmp_post_5 = i;
    i = i + 1;
  }

done_toucs:
  ;
  dest[(signed long int)i] = (unsigned int)0;
  return i;
}

// UTF8_toutf8
// file utf8.c line 109
signed int UTF8_toutf8(char *dest, signed int sz, unsigned int *src, signed int srcsz)
{
  unsigned int ch;
  signed int i = 0;
  char *dest_end = dest + (signed long int)sz;
  signed int tmp_if_expr_1;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_9;
  char *tmp_post_10;
  char *tmp_post_11;
  do
  {
    if(!(srcsz >= 0))
      tmp_if_expr_1 = (signed int)(src[(signed long int)i] != (unsigned int)0);

    else
      tmp_if_expr_1 = (signed int)(i < srcsz);
    if(tmp_if_expr_1 == 0)
      break;

    ch = src[(signed long int)i];
    if(!(ch >= 128u))
    {
      if(dest >= dest_end)
        return i;

      tmp_post_2 = dest;
      dest = dest + 1l;
      *tmp_post_2 = (char)ch;
    }

    else
      if(!(ch >= 2048u))
      {
        if(dest >= dest_end + -1l)
          return i;

        tmp_post_3 = dest;
        dest = dest + 1l;
        *tmp_post_3 = (char)(ch >> 6 | (unsigned int)0xC0);
        tmp_post_4 = dest;
        dest = dest + 1l;
        *tmp_post_4 = (char)(ch & (unsigned int)0x3F | (unsigned int)0x80);
      }

      else
        if(!(ch >= 65536u))
        {
          if(dest >= dest_end + -2l)
            return i;

          tmp_post_5 = dest;
          dest = dest + 1l;
          *tmp_post_5 = (char)(ch >> 12 | (unsigned int)0xE0);
          tmp_post_6 = dest;
          dest = dest + 1l;
          *tmp_post_6 = (char)(ch >> 6 & (unsigned int)0x3F | (unsigned int)0x80);
          tmp_post_7 = dest;
          dest = dest + 1l;
          *tmp_post_7 = (char)(ch & (unsigned int)0x3F | (unsigned int)0x80);
        }

        else
          if(!(ch >= 1114112u))
          {
            if(dest >= dest_end + -3l)
              return i;

            tmp_post_8 = dest;
            dest = dest + 1l;
            *tmp_post_8 = (char)(ch >> 18 | (unsigned int)0xF0);
            tmp_post_9 = dest;
            dest = dest + 1l;
            *tmp_post_9 = (char)(ch >> 12 & (unsigned int)0x3F | (unsigned int)0x80);
            tmp_post_10 = dest;
            dest = dest + 1l;
            *tmp_post_10 = (char)(ch >> 6 & (unsigned int)0x3F | (unsigned int)0x80);
            tmp_post_11 = dest;
            dest = dest + 1l;
            *tmp_post_11 = (char)(ch & (unsigned int)0x3F | (unsigned int)0x80);
          }

    i = i + 1;
  }
  while((_Bool)1);
  if(!(dest >= dest_end))
    *dest = (char)0;

  return i;
}

// UTF8_unescape
// file utf8.c line 314
signed int UTF8_unescape(char *buf, signed int sz, char *src)
{
  signed int c = 0;
  signed int amt;
  unsigned int ch;
  char temp[4l];
  for( ; !(*src == 0); c = c + amt)
  {
    if(c >= sz)
      break;

    if((signed int)*src == 92)
    {
      src = src + 1l;
      amt=UTF8_read_escape_sequence(src, &ch);
    }

    else
    {
      ch = (unsigned int)*src;
      amt = 1;
    }
    src = src + (signed long int)amt;
    amt=UTF8_wc_toutf8(temp, ch);
    if(!(sz + -c >= amt))
      break;

    memcpy((void *)&buf[(signed long int)c], (const void *)temp, (unsigned long int)amt);
  }
  if(!(c >= sz))
    buf[(signed long int)c] = (char)0;

  return c;
}

// UTF8_vprintf
// file utf8.c line 450
signed int UTF8_vprintf(char *fmt, void **ap)
{
  signed int cnt;
  signed int sz = 0;
  char *buf;
  unsigned int *wcs;
  sz = 512;
  void *return_value___builtin_alloca_1;
  return_value___builtin_alloca_1=__builtin_alloca((unsigned long int)sz);
  buf = (char *)return_value___builtin_alloca_1;
  void *return_value___builtin_alloca_2;
  do
  {

  try_print:
    ;
    cnt=vsnprintf(buf, (unsigned long int)sz, fmt, ap);
    if(!(cnt >= sz))
      break;

    return_value___builtin_alloca_2=__builtin_alloca((unsigned long int)((cnt - sz) + 1));
    buf = (char *)return_value___builtin_alloca_2;
    sz = cnt + 1;
  }
  while((_Bool)1);
  void *return_value___builtin_alloca_3;
  return_value___builtin_alloca_3=__builtin_alloca((unsigned long int)(cnt + 1) * sizeof(unsigned int) /*4ul*/ );
  wcs = (unsigned int *)return_value___builtin_alloca_3;
  cnt=UTF8_toucs(wcs, cnt + 1, buf, cnt);
  printf("%ls", (signed int *)wcs);
  return cnt;
}

// UTF8_wc_toutf8
// file ../include/utf8.h line 16
signed int UTF8_wc_toutf8(char *dest, unsigned int ch)
{
  if(!(ch >= 128u))
  {
    dest[(signed long int)0] = (char)ch;
    return 1;
  }

  else
    if(!(ch >= 2048u))
    {
      dest[(signed long int)0] = (char)(ch >> 6 | (unsigned int)0xC0);
      dest[(signed long int)1] = (char)(ch & (unsigned int)0x3F | (unsigned int)0x80);
      return 2;
    }

    else
      if(!(ch >= 65536u))
      {
        dest[(signed long int)0] = (char)(ch >> 12 | (unsigned int)0xE0);
        dest[(signed long int)1] = (char)(ch >> 6 & (unsigned int)0x3F | (unsigned int)0x80);
        dest[(signed long int)2] = (char)(ch & (unsigned int)0x3F | (unsigned int)0x80);
        return 3;
      }

      else
        if(!(ch >= 1114112u))
        {
          dest[(signed long int)0] = (char)(ch >> 18 | (unsigned int)0xF0);
          dest[(signed long int)1] = (char)(ch >> 12 & (unsigned int)0x3F | (unsigned int)0x80);
          dest[(signed long int)2] = (char)(ch >> 6 & (unsigned int)0x3F | (unsigned int)0x80);
          dest[(signed long int)3] = (char)(ch & (unsigned int)0x3F | (unsigned int)0x80);
          return 4;
        }

        else
          return 0;
}

// UnRegisterEventListener
// file events.c line 432
static void UnRegisterEventListener(struct List_s *listenerList, void (*callback)(void *, struct Event_s *, void *), void *arg)
{
  struct ListIterator_s iterator;
  iterator.current = listenerList->head;
  iterator.list = listenerList;
  struct ListEntry_s *tmp_if_expr_1;
  for( ; !(iterator.current == ((struct ListEntry_s *)NULL)); iterator.current = tmp_if_expr_1)
  {
    struct EventListenerDetails_s *details = (struct EventListenerDetails_s *)iterator.current->data;
    if(details->callback == callback)
    {
      if(details->arg == arg)
      {
        ListRemoveCurrent(&iterator);
        ObjectRefDecImpl((void *)details, "events.c", 442);
        break;
      }

    }

    if(!(iterator.current == ((struct ListEntry_s *)NULL)))
      tmp_if_expr_1 = iterator.current->next;

    else
      tmp_if_expr_1 = (struct ListEntry_s *)(void *)0;
  }
}

// UnRollDescriptors
// file pids.c line 262
static struct dvbpsi_descriptor_s * UnRollDescriptors(unsigned char *descriptors, signed int size)
{
  struct dvbpsi_descriptor_s *result = (struct dvbpsi_descriptor_s *)(void *)0;
  struct dvbpsi_descriptor_s *current = (struct dvbpsi_descriptor_s *)(void *)0;
  struct dvbpsi_descriptor_s *prev = (struct dvbpsi_descriptor_s *)(void *)0;
  signed int pos;
  if(size == 0)
    return (struct dvbpsi_descriptor_s *)(void *)0;

  else
  {
    pos = 0;
    for( ; !(pos >= size); pos = pos + 2 + (signed int)current->i_length)
    {
      current=dvbpsi_NewDescriptor(descriptors[(signed long int)pos], descriptors[(signed long int)(pos + 1)], &descriptors[(signed long int)(pos + 2)]);
      if(!(result == ((struct dvbpsi_descriptor_s *)NULL)))
      {
        prev->p_next = current;
        prev = current;
      }

      else
      {
        result = current;
        prev = result;
      }
    }
    return result;
  }
}

// UpdateDatabase
// file main.c line 568
void UpdateDatabase()
{
  pthread_mutex_lock(&TSReader->mutex);
  CacheWriteback();
  pthread_mutex_unlock(&TSReader->mutex);
}

// UserNetDispatcher
// file dispatchers.c line 144
static void * UserNetDispatcher(void *arg)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  LogRegisterThread(return_value_pthread_self_1, "NetDispatcher");
  LogModule(2, DISPATCHERS, "Network dispatcher started");
  ev_loop(UserNetEventLoop, 0);
  LogModule(2, DISPATCHERS, "Network dispatcher finished");
  return (void *)0;
}

// VCTEventListener
// file commands/cmd_scanning.c line 1419
static void VCTEventListener(void *arg, struct Event_s *event, void *payload)
{
  if((signed int)currentScanState == ScanState_WaitingForTables)
    ScanStateMachine((enum ScanEvent_e)ScanEvent_SDTReceived);

}

// YamlUtils_AddStringSection
// file yamlutils.c line 186
static void YamlUtils_AddStringSection(struct StringOutput_s *output)
{
  struct YUStringSection_s *result;
  void *return_value_ObjectCreateImpl_1;
  return_value_ObjectCreateImpl_1=ObjectCreateImpl("YUStringSection_t", "yamlutils.c", 188);
  result = (struct YUStringSection_s *)return_value_ObjectCreateImpl_1;
  if(output->sections == ((struct YUStringSection_s *)NULL))
    output->sections = result;

  else
    output->sectionsEnd->next = result;
  output->sectionsEnd = result;
  output->currentSection = result;
  output->currentSectionPos = 0;
}

// YamlUtils_DocumentToString
// file ../include/yamlutils.h line 69
signed int YamlUtils_DocumentToString(struct yaml_document_s *document, _Bool removeDocStartEnd, char **outputStr)
{
  struct StringOutput_s output;
  char *current;
  struct YUStringSection_s *section;
  unsigned long int left;
  struct yaml_emitter_s emitter;
  signed int offset = 0;
  unsigned long int toCopy;
  ObjectRegisterClass("YUStringSection_t", (unsigned int)sizeof(struct YUStringSection_s) /*264ul*/ , (void (*)(void *))(void *)0);
  bzero((void *)&output, sizeof(struct StringOutput_s) /*40ul*/ );
  YamlUtils_AddStringSection(&output);
  yaml_emitter_initialize(&emitter);
  yaml_emitter_set_output(&emitter, YamlUtils_OutputToStringSections, (void *)&output);
  yaml_emitter_dump(&emitter, document);
  if(!(removeDocStartEnd == (_Bool)0))
  {
    output.written = output.written - (unsigned long int)8;
    offset = 4;
  }

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(output.written + (unsigned long int)1);
  *outputStr = (char *)return_value_malloc_1;
  current = *outputStr;
  section = output.sections;
  left = output.written;
  for( ; !(section == ((struct YUStringSection_s *)NULL)) && !(left == 0ul); left = left - toCopy)
  {
    toCopy = (unsigned long int)(256 - offset);
    if(!(left >= toCopy))
      toCopy = left;

    memcpy((void *)current, (const void *)(section->buffer + (signed long int)offset), toCopy);
    offset = 0;
    current = current + (signed long int)toCopy;
    section = section->next;
  }
  *current = (char)0;
  section = output.sections;
  while(!(section == ((struct YUStringSection_s *)NULL)))
  {
    struct YUStringSection_s *prev = section;
    section = prev->next;
    ObjectRefDecImpl((void *)prev, "yamlutils.c", 154);
  }
  return (signed int)output.written;
}

// YamlUtils_MappingAdd
// file ../include/yamlutils.h line 60
signed int YamlUtils_MappingAdd(struct yaml_document_s *document, signed int mapping, const char *key, const char *value)
{
  signed int keyId;
  signed int valueId;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(key);
  keyId=yaml_document_add_scalar(document, (unsigned char *)"tag:yaml.org,2002:str", (unsigned char *)key, (signed int)return_value_strlen_1, (enum yaml_scalar_style_e)YAML_ANY_SCALAR_STYLE);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(value);
  valueId=yaml_document_add_scalar(document, (unsigned char *)"tag:yaml.org,2002:str", (unsigned char *)value, (signed int)return_value_strlen_2, (enum yaml_scalar_style_e)YAML_ANY_SCALAR_STYLE);
  signed int return_value_yaml_document_append_mapping_pair_3;
  return_value_yaml_document_append_mapping_pair_3=yaml_document_append_mapping_pair(document, mapping, keyId, valueId);
  return return_value_yaml_document_append_mapping_pair_3;
}

// YamlUtils_MappingFind
// file ../include/yamlutils.h line 43
struct yaml_node_s * YamlUtils_MappingFind(struct yaml_document_s *document, struct yaml_node_s *node, const char *key)
{
  struct yaml_node_pair_s *pair;
  struct yaml_node_s *keyNode;
  _Bool tmp_if_expr_1;
  if(!((signed int)node->type == YAML_MAPPING_NODE))
  {
    LogModule(0, YAMLUTILS, "Node was not a mapping node!");
    return (struct yaml_node_s *)(void *)0;
  }

  else
  {
    pair = node->data.mapping.pairs.start;
    do
    {
      if(!(pair == ((struct yaml_node_pair_s *)NULL)))
        tmp_if_expr_1 = pair != node->data.mapping.pairs.top ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      keyNode=yaml_document_get_node(document, pair->key);
      if(!(keyNode == ((struct yaml_node_s *)NULL)))
      {
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp((char *)keyNode->data.scalar.value, key);
        if(return_value_strcmp_3 == 0)
        {
          struct yaml_node_s *return_value_yaml_document_get_node_2;
          return_value_yaml_document_get_node_2=yaml_document_get_node(document, pair->value);
          return return_value_yaml_document_get_node_2;
        }

      }

      pair = pair + 1l;
    }
    while((_Bool)1);
    return (struct yaml_node_s *)(void *)0;
  }
}

// YamlUtils_OutputToStringSections
// file yamlutils.c line 160
static signed int YamlUtils_OutputToStringSections(void *data, unsigned char *buffer, unsigned long int size)
{
  struct StringOutput_s *output = (struct StringOutput_s *)data;
  signed int offset = 0;
  unsigned long int left = size;
  while(!(left == 0ul))
  {
    unsigned long int available = (unsigned long int)(256 - output->currentSectionPos);
    if(!(available >= left))
    {
      memcpy((void *)(output->currentSection->buffer + (signed long int)output->currentSectionPos), (const void *)(buffer + (signed long int)offset), available);
      YamlUtils_AddStringSection(output);
      left = left - available;
      offset = offset + (signed int)available;
    }

    else
    {
      memcpy((void *)(output->currentSection->buffer + (signed long int)output->currentSectionPos), (const void *)(buffer + (signed long int)offset), left);
      output->currentSectionPos = output->currentSectionPos + (signed int)left;
      left = (unsigned long int)0;
    }
  }
  output->written = output->written + size;
  return 1;
}

// YamlUtils_Parse
// file ../include/yamlutils.h line 34
signed int YamlUtils_Parse(char *str, struct yaml_document_s *document)
{
  signed int r;
  struct yaml_parser_s parser;
  yaml_parser_initialize(&parser);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  yaml_parser_set_input_string(&parser, (const unsigned char *)str, return_value_strlen_1);
  r=yaml_parser_load(&parser, document);
  yaml_parser_delete(&parser);
  return r;
}

// ev_loop
// file /usr/include/ev.h line 835
static inline void ev_loop(struct ev_loop *loop, signed int flags)
{
  ev_run(loop, flags);
}

// ev_unloop
// file /usr/include/ev.h line 836
static inline void ev_unloop(struct ev_loop *loop, signed int how)
{
  ev_break(loop, how);
}

// hex_digit
// file utf8.c line 248
static signed int hex_digit(char c)
{
  return (signed int)((signed int)c >= 48 && (signed int)c <= 57 || (signed int)c >= 65 && (signed int)c <= 70 || (signed int)c >= 97 && (signed int)c <= 102);
}

// installsighandler
// file main.c line 744
static void installsighandler(void)
{
  rl_catch_signals = 0;
  signal(15, sighandler);
  signal(2, sighandler);
  signal(3, sighandler);
  signal(13, (void (*)(signed int))1);
}

// main
// file main.c line 141
signed int main(signed int argc, char **argv)
{
  char *startupFile = (char *)(void *)0;
  signed int adapterNumber = 0;
  signed int scanAll = 0;
  signed int logLevel = 0;
  char *username = "dvbstreamer";
  char *password = "control";
  char *serverName = (char *)(void *)0;
  char *bindAddress = (char *)(void *)0;
  char *primaryMRL = "null://";
  _Bool remoteInterface = (_Bool)0;
  _Bool disableConsoleInput = (_Bool)0;
  _Bool hwRestricted = (_Bool)0;
  _Bool forceISDB = (_Bool)0;
  struct LNBInfo_s lnbInfo;
  struct DeliveryMethodInstance_t *dmInstance;
  char logFilename[4096l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("HOME");
  sprintf(DataDirectory, "%s/.dvbstreamer", return_value_getenv_1);
  mkdir(DataDirectory, (unsigned int)(0400 | 0200 | 0100));
  installsighandler();
  while(ExitProgram == (_Bool)0)
  {
    signed int c;
    c=getopt(argc, argv, "vVdDro:a:f:u:p:n:F:i:RL:I");
    if(c == -1)
      break;

    switch(c)
    {
      case 118:
      {
        logLevel = logLevel + 1;
        break;
      }
      case 76:
      {
        strcpy(logFilename, optarg);
        break;
      }
      case 86:
      {
        version();
        exit(0);
        break;
      }
      case 111:
      {
        primaryMRL = optarg;
        break;
      }
      case 97:
      {
        adapterNumber=atoi(optarg);
        break;
      }
      case 82:
      {
        hwRestricted = (_Bool)1;
        break;
      }
      case 102:
      {
        startupFile = optarg;
        break;
      }
      case 100:
      {
        DaemonMode = (_Bool)1;
        break;
      }
      case 114:
      {
        remoteInterface = (_Bool)1;
        break;
      }
      case 68:
      {
        disableConsoleInput = (_Bool)1;
        remoteInterface = (_Bool)1;
        break;
      }
      case 117:
      {
        username = optarg;
        break;
      }
      case 112:
      {
        password = optarg;
        break;
      }
      case 110:
      {
        serverName = optarg;
        break;
      }
      case 105:
      {
        bindAddress = optarg;
        break;
      }
      case 73:
      {
        forceISDB = (_Bool)1;
        break;
      }
      default:
      {
        usage(argv[(signed long int)0]);
        exit(1);
      }
    }
  }
  if(!(ExitProgram == (_Bool)0))
    exit(1);

  signed int return_value_strcmp_2;
  if(!(logFilename[0l] == 0))
  {
    if(!(DaemonMode == (_Bool)0))
    {
      return_value_strcmp_2=strcmp(logFilename, "-");
      if(return_value_strcmp_2 == 0)
      {
        fprintf(stderr, "Cannot use STDERR for logging when running as a daemon!");
        exit(1);
      }

    }

    signed int return_value_LoggingInitFile_3;
    return_value_LoggingInitFile_3=LoggingInitFile(logFilename, logLevel);
    if(!(return_value_LoggingInitFile_3 == 0))
    {
      perror("Could not open user specified log file:");
      exit(1);
    }

  }

  else
  {
    sprintf(logFilename, "dvbstreamer-%d.log", adapterNumber);
    signed int return_value_LoggingInit_4;
    return_value_LoggingInit_4=LoggingInit(logFilename, logLevel);
    if(!(return_value_LoggingInit_4 == 0))
    {
      perror("Couldn't initialising logging module:");
      exit(1);
    }

  }
  sprintf(logFilename, "%s/levels-%d.log", (const void *)DataDirectory, adapterNumber);
  LogLoadModuleLevels(logFilename);
  if(!(DaemonMode == (_Bool)0))
  {
    if(!(startupFile == ((char *)NULL)))
    {
      if(!((signed int)*startupFile == 47))
      {
        char *cwd;
        cwd=getcwd((char *)(void *)0, (unsigned long int)0);
        signed int return_value_asprintf_5;
        return_value_asprintf_5=asprintf(&startupFile, "%s/%s", cwd, startupFile);
        if(return_value_asprintf_5 == -1)
          LogModule(0, MAIN, "Failed to allocate memory for startup file path!\n");

        free((void *)cwd);
      }

    }

    InitDaemon(adapterNumber);
  }

  StartTime=time((signed long int *)(void *)0);
  unsigned long int return_value_pthread_self_6;
  return_value_pthread_self_6=pthread_self();
  LogRegisterThread(return_value_pthread_self_6, "Main");
  LogModule(1, MAIN, "DVBStreamer starting");
  LogModule(2, MAIN, "Using adapter %d\n", adapterNumber);
  if(!(startupFile == ((char *)NULL)))
    LogModule(2, MAIN, "Using startup script %s\n", startupFile);

  if(primaryMRL == ((char *)NULL))
  {
    LogModule(0, MAIN, "No output set!\n");
    usage(argv[(signed long int)0]);
    exit(1);
  }

  do
  {
    signed int return_value_ObjectInit_7;
    return_value_ObjectInit_7=ObjectInit();
    if(!(return_value_ObjectInit_7 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"objects");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"objects");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_EventsInit_8;
    return_value_EventsInit_8=EventsInit();
    if(!(return_value_EventsInit_8 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"events");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"events");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_PropertiesInit_9;
    return_value_PropertiesInit_9=PropertiesInit();
    if(!(return_value_PropertiesInit_9 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"properties");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"properties");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_DBaseInit_10;
    return_value_DBaseInit_10=DBaseInit(adapterNumber);
    if(!(return_value_DBaseInit_10 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"database");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"database");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_EPGTypesInit_11;
    return_value_EPGTypesInit_11=EPGTypesInit();
    if(!(return_value_EPGTypesInit_11 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"EPG types");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"EPG types");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_EPGChannelInit_12;
    return_value_EPGChannelInit_12=EPGChannelInit();
    if(!(return_value_EPGChannelInit_12 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"EPG channel");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"EPG channel");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_MultiplexInit_13;
    return_value_MultiplexInit_13=MultiplexInit();
    if(!(return_value_MultiplexInit_13 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"multiplex");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"multiplex");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_ServiceInit_14;
    return_value_ServiceInit_14=ServiceInit();
    if(!(return_value_ServiceInit_14 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"service");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"service");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_DispatchersInit_15;
    return_value_DispatchersInit_15=DispatchersInit();
    if(!(return_value_DispatchersInit_15 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"dispatchers");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"dispatchers");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_CacheInit_16;
    return_value_CacheInit_16=CacheInit();
    if(!(return_value_CacheInit_16 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"cache");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"cache");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_DeliveryMethodManagerInit_17;
    return_value_DeliveryMethodManagerInit_17=DeliveryMethodManagerInit();
    if(!(return_value_DeliveryMethodManagerInit_17 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"delivery method manager");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"delivery method manager");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_DeferredProcessingInit_18;
    return_value_DeferredProcessingInit_18=DeferredProcessingInit();
    if(!(return_value_DeferredProcessingInit_18 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"deferred processing");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"deferred processing");
  }
  while((_Bool)0);
  signed int return_value_DBaseCount_19;
  return_value_DBaseCount_19=DBaseCount("Services", (char *)(void *)0);
  signed int return_value_DBaseCount_20;
  return_value_DBaseCount_20=DBaseCount("Multiplexes", (char *)(void *)0);
  LogModule(1, MAIN, "%d Services available on %d Multiplexes\n", return_value_DBaseCount_19, return_value_DBaseCount_20);
  DVBAdapter=DVBInit(adapterNumber, hwRestricted, forceISDB);
  if(DVBAdapter == ((struct DVBAdapter_s *)NULL))
  {
    printf("Could not open dvb adapter %d!\n", adapterNumber);
    exit(1);
  }

  signed int i;
  struct DVBSupportedDeliverySys_s *supportedSystems;
  supportedSystems=DVBFrontEndGetDeliverySystems(DVBAdapter);
  i = 0;
  _Bool tmp_if_expr_22;
  for( ; !(i >= supportedSystems->nrofSystems); i = i + 1)
  {
    if((signed int)supportedSystems->systems[(signed long int)i] == DELSYS_DVBS)
      tmp_if_expr_22 = (_Bool)1;

    else
      tmp_if_expr_22 = (signed int)supportedSystems->systems[(signed long int)i] == DELSYS_DVBS2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_22)
    {
      char *lnb;
      signed int return_value_DBaseMetadataGet_21;
      return_value_DBaseMetadataGet_21=DBaseMetadataGet("lnb", &lnb);
      if(!(return_value_DBaseMetadataGet_21 == 0))
      {
        memset((void *)&lnbInfo, 0, sizeof(struct LNBInfo_s) /*40ul*/ );
        DBaseMetadataGetInt("lnb.lowfreq", (signed int *)&lnbInfo.lowFrequency);
        DBaseMetadataGetInt("lnb.highfreq", (signed int *)&lnbInfo.highFrequency);
        DBaseMetadataGetInt("lnb.switchfreq", (signed int *)&lnbInfo.switchFrequency);
      }

      else
      {
        LNBDecode(lnb, &lnbInfo);
        free((void *)lnb);
      }
      DVBFrontEndLNBInfoSet(DVBAdapter, &lnbInfo);
      break;
    }

  }
  do
  {
    TSReader=TSReaderCreate(DVBAdapter);
    if(TSReader == ((struct TSReader_t *)NULL))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"TS reader");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"TS reader");
  }
  while((_Bool)0);
  _Bool return_value_MainIsDVB_24;
  return_value_MainIsDVB_24=MainIsDVB();
  if(!(return_value_MainIsDVB_24 == (_Bool)0))
  {
    LogModule(1, MAIN, "Starting DVB filters\n");
    do
    {
      signed int return_value_DVBStandardInit_23;
      return_value_DVBStandardInit_23=DVBStandardInit(TSReader);
      if(!(return_value_DVBStandardInit_23 == 0))
      {
        LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"DVB Filters");
        if(!(DaemonMode == (_Bool)0))
          unlink(PidFile);

        exit(1);
      }

      LogModule(4, MAIN, "Initialised %s.\n", (const void *)"DVB Filters");
    }
    while((_Bool)0);
  }

  _Bool return_value_MainIsATSC_26;
  return_value_MainIsATSC_26=MainIsATSC();
  if(!(return_value_MainIsATSC_26 == (_Bool)0))
  {
    LogModule(1, MAIN, "Starting ATSC filters\n");
    do
    {
      signed int return_value_ATSCStandardInit_25;
      return_value_ATSCStandardInit_25=ATSCStandardInit(TSReader);
      if(!(return_value_ATSCStandardInit_25 == 0))
      {
        LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"ATSC Filters");
        if(!(DaemonMode == (_Bool)0))
          unlink(PidFile);

        exit(1);
      }

      LogModule(4, MAIN, "Initialised %s.\n", (const void *)"ATSC Filters");
    }
    while((_Bool)0);
  }

  _Bool return_value_MainIsISDB_28;
  return_value_MainIsISDB_28=MainIsISDB();
  if(!(return_value_MainIsISDB_28 == (_Bool)0))
  {
    LogModule(1, MAIN, "Starting ISDB filters\n");
    do
    {
      signed int return_value_MPEG2StandardInit_27;
      return_value_MPEG2StandardInit_27=MPEG2StandardInit(TSReader);
      if(!(return_value_MPEG2StandardInit_27 == 0))
      {
        LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"ISDB Filters");
        if(!(DaemonMode == (_Bool)0))
          unlink(PidFile);

        exit(1);
      }

      LogModule(4, MAIN, "Initialised %s.\n", (const void *)"ISDB Filters");
    }
    while((_Bool)0);
  }

  do
  {
    signed int return_value_ServiceFilterInit_29;
    return_value_ServiceFilterInit_29=ServiceFilterInit();
    if(!(return_value_ServiceFilterInit_29 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"service filter");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"service filter");
  }
  while((_Bool)0);
  do
  {
    signed int return_value_CommandInit_30;
    return_value_CommandInit_30=CommandInit();
    if(!(return_value_CommandInit_30 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"commands");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"commands");
  }
  while((_Bool)0);
  CommandInstallServiceFilter();
  CommandInstallInfo();
  CommandInstallScanning();
  CommandInstallEPG();
  do
  {
    signed int return_value_TuningInit_31;
    return_value_TuningInit_31=TuningInit();
    if(!(return_value_TuningInit_31 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"tuning");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"tuning");
  }
  while((_Bool)0);
  InstallSysProperties();
  do
  {
    signed int return_value_PluginManagerInit_32;
    return_value_PluginManagerInit_32=PluginManagerInit();
    if(!(return_value_PluginManagerInit_32 == 0))
    {
      LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"plugin manager");
      if(!(DaemonMode == (_Bool)0))
        unlink(PidFile);

      exit(1);
    }

    LogModule(4, MAIN, "Initialised %s.\n", (const void *)"plugin manager");
  }
  while((_Bool)0);
  PrimaryServiceFilter=ServiceFilterCreate(TSReader, (char *)PrimaryService);
  if(PrimaryServiceFilter == ((struct ServiceFilter_s *)NULL))
  {
    LogModule(0, MAIN, "Failed to create primary service filter\n");
    exit(1);
  }

  dmInstance=DeliveryMethodCreate(primaryMRL);
  if(dmInstance == ((struct DeliveryMethodInstance_t *)NULL))
  {
    signed int return_value_strcmp_33;
    return_value_strcmp_33=strcmp(primaryMRL, "null://");
    if(!(return_value_strcmp_33 == 0))
    {
      printf("Failed to create delivery method for mrl (%s) falling back to null://\n", primaryMRL);
      dmInstance=DeliveryMethodCreate("null://");
    }

    if(dmInstance == ((struct DeliveryMethodInstance_t *)NULL))
    {
      fprintf(stderr, "Failed to create fallback (null://) delivery method\nCheck that you have installed dvbstreamer plugins to the correct place!\nPlugin path: %s\n", (const void *)"/usr/lib/dvbstreamer/plugins");
      exit(1);
    }

  }

  ServiceFilterDeliveryMethodSet(PrimaryServiceFilter, dmInstance);
  if(!(DaemonMode == (_Bool)0) || !(remoteInterface == (_Bool)0))
  {
    char serverNameBuffer[40l];
    if(serverName == ((char *)NULL))
    {
      sprintf(serverNameBuffer, "DVBStreamer Adapter %d", adapterNumber);
      serverName = serverNameBuffer;
    }

    do
    {
      signed int return_value_RemoteInterfaceInit_34;
      return_value_RemoteInterfaceInit_34=RemoteInterfaceInit(adapterNumber, serverName, bindAddress, username, password);
      if(!(return_value_RemoteInterfaceInit_34 == 0))
      {
        LogModule(0, MAIN, "Failed to initialise %s.\n", (const void *)"remote interface");
        if(!(DaemonMode == (_Bool)0))
          unlink(PidFile);

        exit(1);
      }

      LogModule(4, MAIN, "Initialised %s.\n", (const void *)"remote interface");
    }
    while((_Bool)0);
  }

  if(!(startupFile == ((char *)NULL)))
  {
    signed int return_value_CommandProcessFile_35;
    return_value_CommandProcessFile_35=CommandProcessFile(startupFile);
    if(!(return_value_CommandProcessFile_35 == 0))
      LogModule(0, MAIN, "%s not found!\n", startupFile);

    LogModule(4, MAIN, "Startup file processed\n");
  }

  signed int return_value_DBaseMetadataGetInt_37;
  return_value_DBaseMetadataGetInt_37=DBaseMetadataGetInt("scan.all", &scanAll);
  if(return_value_DBaseMetadataGetInt_37 == 0)
  {
    if(forceISDB == (_Bool)0 && !(scanAll == 0))
    {
      printf("New setup, performing initial scan to fill in missing details.\n");
      _Bool return_value_CommandExecuteConsole_36;
      return_value_CommandExecuteConsole_36=CommandExecuteConsole("scan all");
      if(return_value_CommandExecuteConsole_36 == (_Bool)0)
        printf("Failed to find scan command\n");

      printf("Initial scan finished.\n");
    }

    DBaseMetadataDelete("scan.all");
  }

  LogModule(1, MAIN, "DVBStreamer ready.");
  if(!(DaemonMode == (_Bool)0))
  {
    DispatchersStart((_Bool)1);
    LogModule(4, MAIN, "Remote interface finished, shutting down\n");
    RemoteInterfaceDeInit();
  }

  else
  {
    if(!(disableConsoleInput == (_Bool)0))
      DispatchersStart((_Bool)1);

    else
    {
      DispatchersStart((_Bool)0);
      CommandLoop();
      LogModule(4, MAIN, "Command loop finished, shutting down\n");
      ExitProgram = (volatile _Bool)1;
    }
    if(!(remoteInterface == (_Bool)0))
      RemoteInterfaceDeInit();

  }
  DispatchersStop();
  TSReaderEnable(TSReader, (_Bool)0);
  ServiceFilterDestroyAll(TSReader);
  do
  {
    DeferredProcessingDeinit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"deferred processing");
  }
  while((_Bool)0);
  DeliveryMethodDestroyAll();
  do
  {
    PluginManagerDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"plugin manager");
  }
  while((_Bool)0);
  do
  {
    DeliveryMethodManagerDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"delivery method manager");
  }
  while((_Bool)0);
  do
  {
    TuningDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"tuning");
  }
  while((_Bool)0);
  CommandUnInstallEPG();
  CommandUnInstallServiceFilter();
  CommandUnInstallInfo();
  CommandUnInstallScanning();
  do
  {
    CommandDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"commands");
  }
  while((_Bool)0);
  do
  {
    ServiceFilterDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"service filter");
  }
  while((_Bool)0);
  _Bool return_value_MainIsDVB_38;
  return_value_MainIsDVB_38=MainIsDVB();
  if(!(return_value_MainIsDVB_38 == (_Bool)0))
    DVBStandardDeinit(TSReader);

  _Bool return_value_MainIsATSC_39;
  return_value_MainIsATSC_39=MainIsATSC();
  if(!(return_value_MainIsATSC_39 == (_Bool)0))
    ATSCStandardDeinit(TSReader);

  _Bool return_value_MainIsISDB_40;
  return_value_MainIsISDB_40=MainIsISDB();
  if(!(return_value_MainIsISDB_40 == (_Bool)0))
    MPEG2StandardDeinit(TSReader);

  LogModule(4, MAIN, "Processors destroyed\n");
  do
  {
    TSReaderDestroy(TSReader);
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"TS filter");
  }
  while((_Bool)0);
  DVBFrontEndLNBInfoGet(DVBAdapter, &lnbInfo);
  if(!(lnbInfo.name == ((char *)NULL)))
    DBaseMetadataSet("lnb", lnbInfo.name);

  else
  {
    DBaseMetadataDelete("lnb");
    DBaseMetadataSetInt("lnb.lowfreq", (signed int)lnbInfo.lowFrequency);
    DBaseMetadataSetInt("lnb.highfreq", (signed int)lnbInfo.highFrequency);
    DBaseMetadataSetInt("lnb.switchfreq", (signed int)lnbInfo.switchFrequency);
  }
  do
  {
    DVBDispose(DVBAdapter);
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"DVB adapter");
  }
  while((_Bool)0);
  do
  {
    CacheDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"cache");
  }
  while((_Bool)0);
  do
  {
    DispatchersDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"dispatchers");
  }
  while((_Bool)0);
  do
  {
    ServiceDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"service");
  }
  while((_Bool)0);
  do
  {
    MultiplexDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"multiplex");
  }
  while((_Bool)0);
  do
  {
    EPGChannelDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"EPG channel");
  }
  while((_Bool)0);
  do
  {
    EPGTypesDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"EPG types");
  }
  while((_Bool)0);
  do
  {
    DBaseDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"database");
  }
  while((_Bool)0);
  do
  {
    PropertiesDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"properties");
  }
  while((_Bool)0);
  do
  {
    EventsDeInit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"events");
  }
  while((_Bool)0);
  do
  {
    ObjectDeinit();
    LogModule(4, MAIN, "Deinitialised %s\n", (const void *)"objects");
  }
  while((_Bool)0);
  if(!(DaemonMode == (_Bool)0))
    DeInitDaemon();

  LogModule(1, MAIN, "DVBStreamer finished.");
  LoggingDeInit();
  return 0;
}

// octal_digit
// file utf8.c line 243
static signed int octal_digit(char c)
{
  return (signed int)((signed int)c >= 48 && (signed int)c <= 55);
}

// removeControlCodes
// file standard/dvb/sdtprocessor.c line 289
static void removeControlCodes(char *str)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  len = (signed int)(return_value_strlen_1 + (unsigned long int)1);
  signed int i = 0;
  signed int prev_i = 0;
  unsigned int ch;
  do
  {
    signed int return_value_UTF8_nextchar_2;
    return_value_UTF8_nextchar_2=UTF8_nextchar(str, &i);
    ch = (unsigned int)return_value_UTF8_nextchar_2;
    if(ch >= 128u && !(ch >= 160u))
    {
      memmove((void *)&str[(signed long int)prev_i], (const void *)&str[(signed long int)i], (unsigned long int)(len - i));
      len = len - (i - prev_i);
      i = prev_i;
    }

    else
      prev_i = i;
  }
  while(!(ch == 0u));
}

// sighandler
// file main.c line 753
static void sighandler(signed int signum)
{
  if(DaemonMode == (_Bool)0)
    switch(signum)
    {
      case 2:

      case 3:
        rl_free_line_state();
      case 15:
      {
        rl_cleanup_after_signal();
        if(!(rl_instream == ((struct _IO_FILE *)NULL)))
          fclose(rl_instream);

      }
    }

  LogModule(3, MAIN, "Got signal %d exiting\n", signum);
  ExitProgram = (volatile _Bool)1;
  DispatchersExitLoop();
}

// usage
// file main.c line 701
static void usage(char *appname)
{
  fprintf(stderr, "Usage:%s <options>\n      Options:\n      -v            : Increase the amount of debug output, can be used multiple\n                      times for more output\n      -L <file>     : Set the location of the log file.\n      -V            : Print version information then exit\n      -o <mrl>      : Output primary service to the specified mrl.\n      -a <adapter>  : Use adapter number (ie /dev/dvb/adapter<adapter>/...)\n      -f <file>     : Run startup script file before starting the command prompt\n      -d            : Run as a daemon.\n      -R            : Use hardware PID filters, only 1 service filter supported.\n      -I            : Force use of ISDB-T delivery system\n\n      Remote Interface Options\n      -r            : Start remote interface as well as console shell.\n      -D            : Start remote interface but disable console shell.\n      -u <username> : Username used to login remotely to control this instance.\n      -p <password> : Password used to login remotely to control this instance.\n      -n <name>     : Informational name for this instance.\n      -i <address>  : IP address to bind to.\n", appname);
}

// version
// file main.c line 730
static void version(void)
{
  printf("%s - %s (Compiled %s %s)\nWritten by Adam Charrett (charrea6@users.sourceforge.net).\n\nCopyright 2006 Adam Charrett\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", (const void *)"dvbstreamer", (const void *)"2.1.0", (const void *)"Jan 24 2016", (const void *)"02:52:51");
}

