// #anon_enum_ATK_LAYER_INVALID=0_ATK_LAYER_BACKGROUND=1_ATK_LAYER_CANVAS=2_ATK_LAYER_WIDGET=3_ATK_LAYER_MDI=4_ATK_LAYER_POPUP=5_ATK_LAYER_OVERLAY=6_ATK_LAYER_WINDOW=7
// file /usr/include/atk-1.0/atk/atkobject.h line 376
enum anonymous_73 { ATK_LAYER_INVALID=0, ATK_LAYER_BACKGROUND=1, ATK_LAYER_CANVAS=2, ATK_LAYER_WIDGET=3, ATK_LAYER_MDI=4, ATK_LAYER_POPUP=5, ATK_LAYER_OVERLAY=6, ATK_LAYER_WINDOW=7 };

// #anon_enum_ATK_ROLE_INVALID=0_ATK_ROLE_ACCEL_LABEL=1_ATK_ROLE_ALERT=2_ATK_ROLE_ANIMATION=3_ATK_ROLE_ARROW=4_ATK_ROLE_CALENDAR=5_ATK_ROLE_CANVAS=6_ATK_ROLE_CHECK_BOX=7_ATK_ROLE_CHECK_MENU_ITEM=8_ATK_ROLE_COLOR_CHOOSER=9_ATK_ROLE_COLUMN_HEADER=10_ATK_ROLE_COMBO_BOX=11_ATK_ROLE_DATE_EDITOR=12_ATK_ROLE_DESKTOP_ICON=13_ATK_ROLE_DESKTOP_FRAME=14_ATK_ROLE_DIAL=15_ATK_ROLE_DIALOG=16_ATK_ROLE_DIRECTORY_PANE=17_ATK_ROLE_DRAWING_AREA=18_ATK_ROLE_FILE_CHOOSER=19_ATK_ROLE_FILLER=20_ATK_ROLE_FONT_CHOOSER=21_ATK_ROLE_FRAME=22_ATK_ROLE_GLASS_PANE=23_ATK_ROLE_HTML_CONTAINER=24_ATK_ROLE_ICON=25_ATK_ROLE_IMAGE=26_ATK_ROLE_INTERNAL_FRAME=27_ATK_ROLE_LABEL=28_ATK_ROLE_LAYERED_PANE=29_ATK_ROLE_LIST=30_ATK_ROLE_LIST_ITEM=31_ATK_ROLE_MENU=32_ATK_ROLE_MENU_BAR=33_ATK_ROLE_MENU_ITEM=34_ATK_ROLE_OPTION_PANE=35_ATK_ROLE_PAGE_TAB=36_ATK_ROLE_PAGE_TAB_LIST=37_ATK_ROLE_PANEL=38_ATK_ROLE_PASSWORD_TEXT=39_ATK_ROLE_POPUP_MENU=40_ATK_ROLE_PROGRESS_BAR=41_ATK_ROLE_PUSH_BUTTON=42_ATK_ROLE_RADIO_BUTTON=43_ATK_ROLE_RADIO_MENU_ITEM=44_ATK_ROLE_ROOT_PANE=45_ATK_ROLE_ROW_HEADER=46_ATK_ROLE_SCROLL_BAR=47_ATK_ROLE_SCROLL_PANE=48_ATK_ROLE_SEPARATOR=49_ATK_ROLE_SLIDER=50_ATK_ROLE_SPLIT_PANE=51_ATK_ROLE_SPIN_BUTTON=52_ATK_ROLE_STATUSBAR=53_ATK_ROLE_TABLE=54_ATK_ROLE_TABLE_CELL=55_ATK_ROLE_TABLE_COLUMN_HEADER=56_ATK_ROLE_TABLE_ROW_HEADER=57_ATK_ROLE_TEAR_OFF_MENU_ITEM=58_ATK_ROLE_TERMINAL=59_ATK_ROLE_TEXT=60_ATK_ROLE_TOGGLE_BUTTON=61_ATK_ROLE_TOOL_BAR=62_ATK_ROLE_TOOL_TIP=63_ATK_ROLE_TREE=64_ATK_ROLE_TREE_TABLE=65_ATK_ROLE_UNKNOWN=66_ATK_ROLE_VIEWPORT=67_ATK_ROLE_WINDOW=68_ATK_ROLE_HEADER=69_ATK_ROLE_FOOTER=70_ATK_ROLE_PARAGRAPH=71_ATK_ROLE_RULER=72_ATK_ROLE_APPLICATION=73_ATK_ROLE_AUTOCOMPLETE=74_ATK_ROLE_EDITBAR=75_ATK_ROLE_EMBEDDED=76_ATK_ROLE_ENTRY=77_ATK_ROLE_CHART=78_ATK_ROLE_CAPTION=79_ATK_ROLE_DOCUMENT_FRAME=80_ATK_ROLE_HEADING=81_ATK_ROLE_PAGE=82_ATK_ROLE_SECTION=83_ATK_ROLE_REDUNDANT_OBJECT=84_ATK_ROLE_FORM=85_ATK_ROLE_LINK=86_ATK_ROLE_INPUT_METHOD_WINDOW=87_ATK_ROLE_TABLE_ROW=88_ATK_ROLE_TREE_ITEM=89_ATK_ROLE_DOCUMENT_SPREADSHEET=90_ATK_ROLE_DOCUMENT_PRESENTATION=91_ATK_ROLE_DOCUMENT_TEXT=92_ATK_ROLE_DOCUMENT_WEB=93_ATK_ROLE_DOCUMENT_EMAIL=94_ATK_ROLE_COMMENT=95_ATK_ROLE_LIST_BOX=96_ATK_ROLE_GROUPING=97_ATK_ROLE_IMAGE_MAP=98_ATK_ROLE_NOTIFICATION=99_ATK_ROLE_INFO_BAR=100_ATK_ROLE_LEVEL_BAR=101_ATK_ROLE_TITLE_BAR=102_ATK_ROLE_BLOCK_QUOTE=103_ATK_ROLE_AUDIO=104_ATK_ROLE_VIDEO=105_ATK_ROLE_DEFINITION=106_ATK_ROLE_ARTICLE=107_ATK_ROLE_LANDMARK=108_ATK_ROLE_LOG=109_ATK_ROLE_MARQUEE=110_ATK_ROLE_MATH=111_ATK_ROLE_RATING=112_ATK_ROLE_TIMER=113_ATK_ROLE_DESCRIPTION_LIST=114_ATK_ROLE_DESCRIPTION_TERM=115_ATK_ROLE_DESCRIPTION_VALUE=116_ATK_ROLE_STATIC=117_ATK_ROLE_MATH_FRACTION=118_ATK_ROLE_MATH_ROOT=119_ATK_ROLE_SUBSCRIPT=120_ATK_ROLE_SUPERSCRIPT=121_ATK_ROLE_LAST_DEFINED=122
// file /usr/include/atk-1.0/atk/atkobject.h line 232
enum anonymous_72 { ATK_ROLE_INVALID=0, ATK_ROLE_ACCEL_LABEL=1, ATK_ROLE_ALERT=2, ATK_ROLE_ANIMATION=3, ATK_ROLE_ARROW=4, ATK_ROLE_CALENDAR=5, ATK_ROLE_CANVAS=6, ATK_ROLE_CHECK_BOX=7, ATK_ROLE_CHECK_MENU_ITEM=8, ATK_ROLE_COLOR_CHOOSER=9, ATK_ROLE_COLUMN_HEADER=10, ATK_ROLE_COMBO_BOX=11, ATK_ROLE_DATE_EDITOR=12, ATK_ROLE_DESKTOP_ICON=13, ATK_ROLE_DESKTOP_FRAME=14, ATK_ROLE_DIAL=15, ATK_ROLE_DIALOG=16, ATK_ROLE_DIRECTORY_PANE=17, ATK_ROLE_DRAWING_AREA=18, ATK_ROLE_FILE_CHOOSER=19, ATK_ROLE_FILLER=20, ATK_ROLE_FONT_CHOOSER=21, ATK_ROLE_FRAME=22, ATK_ROLE_GLASS_PANE=23, ATK_ROLE_HTML_CONTAINER=24, ATK_ROLE_ICON=25, ATK_ROLE_IMAGE=26, ATK_ROLE_INTERNAL_FRAME=27, ATK_ROLE_LABEL=28, ATK_ROLE_LAYERED_PANE=29, ATK_ROLE_LIST=30, ATK_ROLE_LIST_ITEM=31, ATK_ROLE_MENU=32, ATK_ROLE_MENU_BAR=33, ATK_ROLE_MENU_ITEM=34, ATK_ROLE_OPTION_PANE=35, ATK_ROLE_PAGE_TAB=36, ATK_ROLE_PAGE_TAB_LIST=37, ATK_ROLE_PANEL=38, ATK_ROLE_PASSWORD_TEXT=39, ATK_ROLE_POPUP_MENU=40, ATK_ROLE_PROGRESS_BAR=41, ATK_ROLE_PUSH_BUTTON=42, ATK_ROLE_RADIO_BUTTON=43, ATK_ROLE_RADIO_MENU_ITEM=44, ATK_ROLE_ROOT_PANE=45, ATK_ROLE_ROW_HEADER=46, ATK_ROLE_SCROLL_BAR=47, ATK_ROLE_SCROLL_PANE=48, ATK_ROLE_SEPARATOR=49, ATK_ROLE_SLIDER=50, ATK_ROLE_SPLIT_PANE=51, ATK_ROLE_SPIN_BUTTON=52, ATK_ROLE_STATUSBAR=53, ATK_ROLE_TABLE=54, ATK_ROLE_TABLE_CELL=55, ATK_ROLE_TABLE_COLUMN_HEADER=56, ATK_ROLE_TABLE_ROW_HEADER=57, ATK_ROLE_TEAR_OFF_MENU_ITEM=58, ATK_ROLE_TERMINAL=59, ATK_ROLE_TEXT=60, ATK_ROLE_TOGGLE_BUTTON=61, ATK_ROLE_TOOL_BAR=62, ATK_ROLE_TOOL_TIP=63, ATK_ROLE_TREE=64, ATK_ROLE_TREE_TABLE=65, ATK_ROLE_UNKNOWN=66, ATK_ROLE_VIEWPORT=67, ATK_ROLE_WINDOW=68, ATK_ROLE_HEADER=69, ATK_ROLE_FOOTER=70, ATK_ROLE_PARAGRAPH=71, ATK_ROLE_RULER=72, ATK_ROLE_APPLICATION=73, ATK_ROLE_AUTOCOMPLETE=74, ATK_ROLE_EDITBAR=75, ATK_ROLE_EMBEDDED=76, ATK_ROLE_ENTRY=77, ATK_ROLE_CHART=78, ATK_ROLE_CAPTION=79, ATK_ROLE_DOCUMENT_FRAME=80, ATK_ROLE_HEADING=81, ATK_ROLE_PAGE=82, ATK_ROLE_SECTION=83, ATK_ROLE_REDUNDANT_OBJECT=84, ATK_ROLE_FORM=85, ATK_ROLE_LINK=86, ATK_ROLE_INPUT_METHOD_WINDOW=87, ATK_ROLE_TABLE_ROW=88, ATK_ROLE_TREE_ITEM=89, ATK_ROLE_DOCUMENT_SPREADSHEET=90, ATK_ROLE_DOCUMENT_PRESENTATION=91, ATK_ROLE_DOCUMENT_TEXT=92, ATK_ROLE_DOCUMENT_WEB=93, ATK_ROLE_DOCUMENT_EMAIL=94, ATK_ROLE_COMMENT=95, ATK_ROLE_LIST_BOX=96, ATK_ROLE_GROUPING=97, ATK_ROLE_IMAGE_MAP=98, ATK_ROLE_NOTIFICATION=99, ATK_ROLE_INFO_BAR=100, ATK_ROLE_LEVEL_BAR=101, ATK_ROLE_TITLE_BAR=102, ATK_ROLE_BLOCK_QUOTE=103, ATK_ROLE_AUDIO=104, ATK_ROLE_VIDEO=105, ATK_ROLE_DEFINITION=106, ATK_ROLE_ARTICLE=107, ATK_ROLE_LANDMARK=108, ATK_ROLE_LOG=109, ATK_ROLE_MARQUEE=110, ATK_ROLE_MATH=111, ATK_ROLE_RATING=112, ATK_ROLE_TIMER=113, ATK_ROLE_DESCRIPTION_LIST=114, ATK_ROLE_DESCRIPTION_TERM=115, ATK_ROLE_DESCRIPTION_VALUE=116, ATK_ROLE_STATIC=117, ATK_ROLE_MATH_FRACTION=118, ATK_ROLE_MATH_ROOT=119, ATK_ROLE_SUBSCRIPT=120, ATK_ROLE_SUPERSCRIPT=121, ATK_ROLE_LAST_DEFINED=122 };

// #anon_enum_GDK_ACTION_DEFAULT=1_GDK_ACTION_COPY=2_GDK_ACTION_MOVE=4_GDK_ACTION_LINK=8_GDK_ACTION_PRIVATE=16_GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous_37 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum_GDK_AXIS_IGNORE=0_GDK_AXIS_X=1_GDK_AXIS_Y=2_GDK_AXIS_PRESSURE=3_GDK_AXIS_XTILT=4_GDK_AXIS_YTILT=5_GDK_AXIS_WHEEL=6_GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous_41 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum_GDK_CROSSING_NORMAL=0_GDK_CROSSING_GRAB=1_GDK_CROSSING_UNGRAB=2_GDK_CROSSING_GTK_GRAB=3_GDK_CROSSING_GTK_UNGRAB=4_GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous_46 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum_GDK_DRAG_PROTO_MOTIF=0_GDK_DRAG_PROTO_XDND=1_GDK_DRAG_PROTO_ROOTWIN=2_GDK_DRAG_PROTO_NONE=3_GDK_DRAG_PROTO_WIN32_DROPFILES=4_GDK_DRAG_PROTO_OLE2=5_GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous_38 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum_GDK_FONT_FONT=0_GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous_53 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum_GDK_LSB_FIRST=0_GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous_35 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum_GDK_MODE_DISABLED=0_GDK_MODE_SCREEN=1_GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous_40 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum_GDK_NOTHING=-1_GDK_DELETE=0_GDK_DESTROY=1_GDK_EXPOSE=2_GDK_MOTION_NOTIFY=3_GDK_BUTTON_PRESS=4_GDK_2BUTTON_PRESS=5_GDK_3BUTTON_PRESS=6_GDK_BUTTON_RELEASE=7_GDK_KEY_PRESS=8_GDK_KEY_RELEASE=9_GDK_ENTER_NOTIFY=10_GDK_LEAVE_NOTIFY=11_GDK_FOCUS_CHANGE=12_GDK_CONFIGURE=13_GDK_MAP=14_GDK_UNMAP=15_GDK_PROPERTY_NOTIFY=16_GDK_SELECTION_CLEAR=17_GDK_SELECTION_REQUEST=18_GDK_SELECTION_NOTIFY=19_GDK_PROXIMITY_IN=20_GDK_PROXIMITY_OUT=21_GDK_DRAG_ENTER=22_GDK_DRAG_LEAVE=23_GDK_DRAG_MOTION=24_GDK_DRAG_STATUS=25_GDK_DROP_START=26_GDK_DROP_FINISHED=27_GDK_CLIENT_EVENT=28_GDK_VISIBILITY_NOTIFY=29_GDK_NO_EXPOSE=30_GDK_SCROLL=31_GDK_WINDOW_STATE=32_GDK_SETTING=33_GDK_OWNER_CHANGE=34_GDK_GRAB_BROKEN=35_GDK_DAMAGE=36_GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous_42 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum_GDK_NOTIFY_ANCESTOR=0_GDK_NOTIFY_VIRTUAL=1_GDK_NOTIFY_INFERIOR=2_GDK_NOTIFY_NONLINEAR=3_GDK_NOTIFY_NONLINEAR_VIRTUAL=4_GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous_45 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum_GDK_OWNER_CHANGE_NEW_OWNER=0_GDK_OWNER_CHANGE_DESTROY=1_GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous_49 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum_GDK_SCROLL_UP=0_GDK_SCROLL_DOWN=1_GDK_SCROLL_LEFT=2_GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous_44 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum_GDK_SETTING_ACTION_NEW=0_GDK_SETTING_ACTION_CHANGED=1_GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous_48 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum_GDK_SHIFT_MASK=1_GDK_LOCK_MASK=2_GDK_CONTROL_MASK=4_GDK_MOD1_MASK=8_GDK_MOD2_MASK=16_GDK_MOD3_MASK=32_GDK_MOD4_MASK=64_GDK_MOD5_MASK=128_GDK_BUTTON1_MASK=256_GDK_BUTTON2_MASK=512_GDK_BUTTON3_MASK=1024_GDK_BUTTON4_MASK=2048_GDK_BUTTON5_MASK=4096_GDK_SUPER_MASK=67108864_GDK_HYPER_MASK=134217728_GDK_META_MASK=268435456_GDK_RELEASE_MASK=1073741824_GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous_36 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum_GDK_SOURCE_MOUSE=0_GDK_SOURCE_PEN=1_GDK_SOURCE_ERASER=2_GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous_39 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum_GDK_VISIBILITY_UNOBSCURED=0_GDK_VISIBILITY_PARTIAL=1_GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous_43 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum_GDK_VISUAL_STATIC_GRAY=0_GDK_VISUAL_GRAYSCALE=1_GDK_VISUAL_STATIC_COLOR=2_GDK_VISUAL_PSEUDO_COLOR=3_GDK_VISUAL_TRUE_COLOR=4_GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous_62 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum_GDK_WINDOW_STATE_WITHDRAWN=1_GDK_WINDOW_STATE_ICONIFIED=2_GDK_WINDOW_STATE_MAXIMIZED=4_GDK_WINDOW_STATE_STICKY=8_GDK_WINDOW_STATE_FULLSCREEN=16_GDK_WINDOW_STATE_ABOVE=32_GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous_47 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum_GDK_X_CURSOR=0_GDK_ARROW=2_GDK_BASED_ARROW_DOWN=4_GDK_BASED_ARROW_UP=6_GDK_BOAT=8_GDK_BOGOSITY=10_GDK_BOTTOM_LEFT_CORNER=12_GDK_BOTTOM_RIGHT_CORNER=14_GDK_BOTTOM_SIDE=16_GDK_BOTTOM_TEE=18_GDK_BOX_SPIRAL=20_GDK_CENTER_PTR=22_GDK_CIRCLE=24_GDK_CLOCK=26_GDK_COFFEE_MUG=28_GDK_CROSS=30_GDK_CROSS_REVERSE=32_GDK_CROSSHAIR=34_GDK_DIAMOND_CROSS=36_GDK_DOT=38_GDK_DOTBOX=40_GDK_DOUBLE_ARROW=42_GDK_DRAFT_LARGE=44_GDK_DRAFT_SMALL=46_GDK_DRAPED_BOX=48_GDK_EXCHANGE=50_GDK_FLEUR=52_GDK_GOBBLER=54_GDK_GUMBY=56_GDK_HAND1=58_GDK_HAND2=60_GDK_HEART=62_GDK_ICON=64_GDK_IRON_CROSS=66_GDK_LEFT_PTR=68_GDK_LEFT_SIDE=70_GDK_LEFT_TEE=72_GDK_LEFTBUTTON=74_GDK_LL_ANGLE=76_GDK_LR_ANGLE=78_GDK_MAN=80_GDK_MIDDLEBUTTON=82_GDK_MOUSE=84_GDK_PENCIL=86_GDK_PIRATE=88_GDK_PLUS=90_GDK_QUESTION_ARROW=92_GDK_RIGHT_PTR=94_GDK_RIGHT_SIDE=96_GDK_RIGHT_TEE=98_GDK_RIGHTBUTTON=100_GDK_RTL_LOGO=102_GDK_SAILBOAT=104_GDK_SB_DOWN_ARROW=106_GDK_SB_H_DOUBLE_ARROW=108_GDK_SB_LEFT_ARROW=110_GDK_SB_RIGHT_ARROW=112_GDK_SB_UP_ARROW=114_GDK_SB_V_DOUBLE_ARROW=116_GDK_SHUTTLE=118_GDK_SIZING=120_GDK_SPIDER=122_GDK_SPRAYCAN=124_GDK_STAR=126_GDK_TARGET=128_GDK_TCROSS=130_GDK_TOP_LEFT_ARROW=132_GDK_TOP_LEFT_CORNER=134_GDK_TOP_RIGHT_CORNER=136_GDK_TOP_SIDE=138_GDK_TOP_TEE=140_GDK_TREK=142_GDK_UL_ANGLE=144_GDK_UMBRELLA=146_GDK_UR_ANGLE=148_GDK_WATCH=150_GDK_XTERM=152_GDK_LAST_CURSOR=153_GDK_BLANK_CURSOR=-2_GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 43
enum anonymous_17 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum_GTK_CLIST_DRAG_NONE=0_GTK_CLIST_DRAG_BEFORE=1_GTK_CLIST_DRAG_INTO=2_GTK_CLIST_DRAG_AFTER=3
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 70
enum anonymous_16 { GTK_CLIST_DRAG_NONE=0, GTK_CLIST_DRAG_BEFORE=1, GTK_CLIST_DRAG_INTO=2, GTK_CLIST_DRAG_AFTER=3 };

// #anon_enum_GTK_DELETE_CHARS=0_GTK_DELETE_WORD_ENDS=1_GTK_DELETE_WORDS=2_GTK_DELETE_DISPLAY_LINES=3_GTK_DELETE_DISPLAY_LINE_ENDS=4_GTK_DELETE_PARAGRAPH_ENDS=5_GTK_DELETE_PARAGRAPHS=6_GTK_DELETE_WHITESPACE=7
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 107
enum anonymous_64 { GTK_DELETE_CHARS=0, GTK_DELETE_WORD_ENDS=1, GTK_DELETE_WORDS=2, GTK_DELETE_DISPLAY_LINES=3, GTK_DELETE_DISPLAY_LINE_ENDS=4, GTK_DELETE_PARAGRAPH_ENDS=5, GTK_DELETE_PARAGRAPHS=6, GTK_DELETE_WHITESPACE=7 };

// #anon_enum_GTK_DEST_DEFAULT_MOTION=1_GTK_DEST_DEFAULT_HIGHLIGHT=2_GTK_DEST_DEFAULT_DROP=4_GTK_DEST_DEFAULT_ALL=7
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 42
enum anonymous_11 { GTK_DEST_DEFAULT_MOTION=1, GTK_DEST_DEFAULT_HIGHLIGHT=2, GTK_DEST_DEFAULT_DROP=4, GTK_DEST_DEFAULT_ALL=7 };

// #anon_enum_GTK_DIR_TAB_FORWARD=0_GTK_DIR_TAB_BACKWARD=1_GTK_DIR_UP=2_GTK_DIR_DOWN=3_GTK_DIR_LEFT=4_GTK_DIR_RIGHT=5
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 122
enum anonymous_65 { GTK_DIR_TAB_FORWARD=0, GTK_DIR_TAB_BACKWARD=1, GTK_DIR_UP=2, GTK_DIR_DOWN=3, GTK_DIR_LEFT=4, GTK_DIR_RIGHT=5 };

// #anon_enum_GTK_EXPAND=1_GTK_SHRINK=2_GTK_FILL=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 79
enum anonymous_63 { GTK_EXPAND=1, GTK_SHRINK=2, GTK_FILL=4 };

// #anon_enum_GTK_ICON_SIZE_INVALID=0_GTK_ICON_SIZE_MENU=1_GTK_ICON_SIZE_SMALL_TOOLBAR=2_GTK_ICON_SIZE_LARGE_TOOLBAR=3_GTK_ICON_SIZE_BUTTON=4_GTK_ICON_SIZE_DND=5_GTK_ICON_SIZE_DIALOG=6
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 142
enum anonymous_61 { GTK_ICON_SIZE_INVALID=0, GTK_ICON_SIZE_MENU=1, GTK_ICON_SIZE_SMALL_TOOLBAR=2, GTK_ICON_SIZE_LARGE_TOOLBAR=3, GTK_ICON_SIZE_BUTTON=4, GTK_ICON_SIZE_DND=5, GTK_ICON_SIZE_DIALOG=6 };

// #anon_enum_GTK_JUSTIFY_LEFT=0_GTK_JUSTIFY_RIGHT=1_GTK_JUSTIFY_CENTER=2_GTK_JUSTIFY_FILL=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 181
enum anonymous_32 { GTK_JUSTIFY_LEFT=0, GTK_JUSTIFY_RIGHT=1, GTK_JUSTIFY_CENTER=2, GTK_JUSTIFY_FILL=3 };

// #anon_enum_GTK_MOVEMENT_LOGICAL_POSITIONS=0_GTK_MOVEMENT_VISUAL_POSITIONS=1_GTK_MOVEMENT_WORDS=2_GTK_MOVEMENT_DISPLAY_LINES=3_GTK_MOVEMENT_DISPLAY_LINE_ENDS=4_GTK_MOVEMENT_PARAGRAPHS=5_GTK_MOVEMENT_PARAGRAPH_ENDS=6_GTK_MOVEMENT_PAGES=7_GTK_MOVEMENT_BUFFER_ENDS=8_GTK_MOVEMENT_HORIZONTAL_PAGES=9
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 237
enum anonymous_67 { GTK_MOVEMENT_LOGICAL_POSITIONS=0, GTK_MOVEMENT_VISUAL_POSITIONS=1, GTK_MOVEMENT_WORDS=2, GTK_MOVEMENT_DISPLAY_LINES=3, GTK_MOVEMENT_DISPLAY_LINE_ENDS=4, GTK_MOVEMENT_PARAGRAPHS=5, GTK_MOVEMENT_PARAGRAPH_ENDS=6, GTK_MOVEMENT_PAGES=7, GTK_MOVEMENT_BUFFER_ENDS=8, GTK_MOVEMENT_HORIZONTAL_PAGES=9 };

// #anon_enum_GTK_ORIENTATION_HORIZONTAL=0_GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 262
enum anonymous_59 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum_GTK_POLICY_ALWAYS=0_GTK_POLICY_AUTOMATIC=1_GTK_POLICY_NEVER=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 305
enum anonymous_19 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2 };

// #anon_enum_GTK_POS_LEFT=0_GTK_POS_RIGHT=1_GTK_POS_TOP=2_GTK_POS_BOTTOM=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 312
enum anonymous_18 { GTK_POS_LEFT=0, GTK_POS_RIGHT=1, GTK_POS_TOP=2, GTK_POS_BOTTOM=3 };

// #anon_enum_GTK_RC_FG=1_GTK_RC_BG=2_GTK_RC_TEXT=4_GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous_54 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum_GTK_RELIEF_NORMAL=0_GTK_RELIEF_HALF=1_GTK_RELIEF_NONE=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 329
enum anonymous_68 { GTK_RELIEF_NORMAL=0, GTK_RELIEF_HALF=1, GTK_RELIEF_NONE=2 };

// #anon_enum_GTK_SELECTION_NONE=0_GTK_SELECTION_SINGLE=1_GTK_SELECTION_BROWSE=2_GTK_SELECTION_MULTIPLE=3_GTK_SELECTION_EXTENDED=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 379
enum anonymous_14 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3, GTK_SELECTION_EXTENDED=3 };

// #anon_enum_GTK_SHADOW_NONE=0_GTK_SHADOW_IN=1_GTK_SHADOW_OUT=2_GTK_SHADOW_ETCHED_IN=3_GTK_SHADOW_ETCHED_OUT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 389
enum anonymous_13 { GTK_SHADOW_NONE=0, GTK_SHADOW_IN=1, GTK_SHADOW_OUT=2, GTK_SHADOW_ETCHED_IN=3, GTK_SHADOW_ETCHED_OUT=4 };

// #anon_enum_GTK_SORT_ASCENDING=0_GTK_SORT_DESCENDING=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 476
enum anonymous_15 { GTK_SORT_ASCENDING=0, GTK_SORT_DESCENDING=1 };

// #anon_enum_GTK_STATE_NORMAL=0_GTK_STATE_ACTIVE=1_GTK_STATE_PRELIGHT=2_GTK_STATE_SELECTED=3_GTK_STATE_INSENSITIVE=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 399
enum anonymous_69 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4 };

// #anon_enum_GTK_TEXT_DIR_NONE=0_GTK_TEXT_DIR_LTR=1_GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 173
enum anonymous_66 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum_GTK_TEXT_SEARCH_VISIBLE_ONLY=1_GTK_TEXT_SEARCH_TEXT_ONLY=2
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 39
enum anonymous_0 { GTK_TEXT_SEARCH_VISIBLE_ONLY=1, GTK_TEXT_SEARCH_TEXT_ONLY=2 };

// #anon_enum_GTK_TEXT_WINDOW_PRIVATE=0_GTK_TEXT_WINDOW_WIDGET=1_GTK_TEXT_WINDOW_TEXT=2_GTK_TEXT_WINDOW_LEFT=3_GTK_TEXT_WINDOW_RIGHT=4_GTK_TEXT_WINDOW_TOP=5_GTK_TEXT_WINDOW_BOTTOM=6
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 48
enum anonymous_34 { GTK_TEXT_WINDOW_PRIVATE=0, GTK_TEXT_WINDOW_WIDGET=1, GTK_TEXT_WINDOW_TEXT=2, GTK_TEXT_WINDOW_LEFT=3, GTK_TEXT_WINDOW_RIGHT=4, GTK_TEXT_WINDOW_TOP=5, GTK_TEXT_WINDOW_BOTTOM=6 };

// #anon_enum_GTK_TOOLBAR_ICONS=0_GTK_TOOLBAR_TEXT=1_GTK_TOOLBAR_BOTH=2_GTK_TOOLBAR_BOTH_HORIZ=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 425
enum anonymous_60 { GTK_TOOLBAR_ICONS=0, GTK_TOOLBAR_TEXT=1, GTK_TOOLBAR_BOTH=2, GTK_TOOLBAR_BOTH_HORIZ=3 };

// #anon_enum_GTK_WIDGET_HELP_TOOLTIP=0_GTK_WIDGET_HELP_WHATS_THIS=1
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 127
enum anonymous { GTK_WIDGET_HELP_TOOLTIP=0, GTK_WIDGET_HELP_WHATS_THIS=1 };

// #anon_enum_GTK_WINDOW_TOPLEVEL=0_GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous_70 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum_GTK_WRAP_NONE=0_GTK_WRAP_CHAR=1_GTK_WRAP_WORD=2_GTK_WRAP_WORD_CHAR=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 467
enum anonymous_31 { GTK_WRAP_NONE=0, GTK_WRAP_CHAR=1, GTK_WRAP_WORD=2, GTK_WRAP_WORD_CHAR=3 };

// #anon_enum_G_PARAM_READABLE=1_G_PARAM_WRITABLE=2_G_PARAM_READWRITE=3_G_PARAM_CONSTRUCT=4_G_PARAM_CONSTRUCT_ONLY=8_G_PARAM_LAX_VALIDATION=16_G_PARAM_STATIC_NAME=32_G_PARAM_PRIVATE=32_G_PARAM_STATIC_NICK=64_G_PARAM_STATIC_BLURB=128_G_PARAM_EXPLICIT_NOTIFY=1073741824_G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous_57 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum_JU_ERRNO_NONE=0_JU_ERRNO_FULL=1_JU_ERRNO_NFMAX=1_JU_ERRNO_NOMEM=2_JU_ERRNO_NULLPPARRAY=3_JU_ERRNO_NONNULLPARRAY=10_JU_ERRNO_NULLPINDEX=4_JU_ERRNO_NULLPVALUE=11_JU_ERRNO_NOTJUDY1=5_JU_ERRNO_NOTJUDYL=6_JU_ERRNO_NOTJUDYSL=7_JU_ERRNO_UNSORTED=12_JU_ERRNO_OVERRUN=8_JU_ERRNO_CORRUPT=9
// file /usr/include/Judy.h line 110
enum anonymous_12 { JU_ERRNO_NONE=0, JU_ERRNO_FULL=1, JU_ERRNO_NFMAX=1, JU_ERRNO_NOMEM=2, JU_ERRNO_NULLPPARRAY=3, JU_ERRNO_NONNULLPARRAY=10, JU_ERRNO_NULLPINDEX=4, JU_ERRNO_NULLPVALUE=11, JU_ERRNO_NOTJUDY1=5, JU_ERRNO_NOTJUDYL=6, JU_ERRNO_NOTJUDYSL=7, JU_ERRNO_UNSORTED=12, JU_ERRNO_OVERRUN=8, JU_ERRNO_CORRUPT=9 };

// #anon_enum_LZMA_MF_HC3=3_LZMA_MF_HC4=4_LZMA_MF_BT2=18_LZMA_MF_BT3=19_LZMA_MF_BT4=20
// file /usr/include/lzma/lzma.h line 58
enum anonymous_3 { LZMA_MF_HC3=3, LZMA_MF_HC4=4, LZMA_MF_BT2=18, LZMA_MF_BT3=19, LZMA_MF_BT4=20 };

// #anon_enum_LZMA_MODE_FAST=1_LZMA_MODE_NORMAL=2
// file /usr/include/lzma/lzma.h line 138
enum anonymous_2 { LZMA_MODE_FAST=1, LZMA_MODE_NORMAL=2 };

// #anon_enum_LZMA_OK=0_LZMA_STREAM_END=1_LZMA_NO_CHECK=2_LZMA_UNSUPPORTED_CHECK=3_LZMA_GET_CHECK=4_LZMA_MEM_ERROR=5_LZMA_MEMLIMIT_ERROR=6_LZMA_FORMAT_ERROR=7_LZMA_OPTIONS_ERROR=8_LZMA_DATA_ERROR=9_LZMA_BUF_ERROR=10_LZMA_PROG_ERROR=11
// file /usr/include/lzma/base.h line 57
enum anonymous_8 { LZMA_OK=0, LZMA_STREAM_END=1, LZMA_NO_CHECK=2, LZMA_UNSUPPORTED_CHECK=3, LZMA_GET_CHECK=4, LZMA_MEM_ERROR=5, LZMA_MEMLIMIT_ERROR=6, LZMA_FORMAT_ERROR=7, LZMA_OPTIONS_ERROR=8, LZMA_DATA_ERROR=9, LZMA_BUF_ERROR=10, LZMA_PROG_ERROR=11 };

// #anon_enum_LZMA_RESERVED_ENUM=0
// file /usr/include/lzma/base.h line 44
enum anonymous_4 { LZMA_RESERVED_ENUM=0 };

// #anon_enum_LZMA_RUN=0_LZMA_SYNC_FLUSH=1_LZMA_FULL_FLUSH=2_LZMA_FINISH=3
// file /usr/include/lzma/base.h line 250
enum anonymous_10 { LZMA_RUN=0, LZMA_SYNC_FLUSH=1, LZMA_FULL_FLUSH=2, LZMA_FINISH=3 };

// #anon_enum_byPtr=0_byU32=1_byU16=2
// file ./../../src/helpers/fst/lz4.c line 445
enum anonymous_20 { byPtr=0, byU32=1, byU16=2 };

// #anon_enum_noDict=0_withPrefix64k=1_usingExtDict=2
// file ./../../src/helpers/fst/lz4.c line 447
enum anonymous_21 { noDict=0, withPrefix64k=1, usingExtDict=2 };

// #anon_enum_noDictIssue=0_dictSmall=1
// file ./../../src/helpers/fst/lz4.c line 448
enum anonymous_22 { noDictIssue=0, dictSmall=1 };

// #anon_enum_notLimited=0_limitedOutput=1
// file ./../../src/helpers/fst/lz4.c line 444
enum anonymous_24 { notLimited=0, limitedOutput=1 };

// tag-#anon#ST[*{*{V}_V_(*{V}_V_|U64|U64)->*{V}_V_}_*{V}_V_(*{V}_V_|U64|U64)->*{V}_V__'alloc'||*{V(*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|*{V}_V_)->V_'free'||*{V}_V_'opaque'|]
// file /usr/include/lzma/base.h line 349
struct anonymous_6;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'toplevel_under_pointer'||*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'window_under_pointer'||F64'toplevel_x'||F64'toplevel_y'||U32'state'||U32'button'||U64'motion_hint_serial'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 63
struct anonymous_52;

// tag-#anon#ST[*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'window'||*{SYM#tag-_GdkDrawable#}_SYM#tag-_GdkDrawable#_'native_window'||U64'serial'||S32'owner_events'||U32'time'|]
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 47
struct anonymous_51;

// tag-#anon#ST[*{U8}_U8_'externalDict'||U64'extDictSize'||*{U8}_U8_'prefixEnd'||U64'prefixSize'|]
// file ./../../src/helpers/fst/lz4.c line 1139
struct anonymous_28;

// tag-#anon#ST[*{V()->V}_V()->V_'f'||*{V}_V_'d'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 165
struct anonymous_71;

// tag-#anon#ST[*{cU8}_cU8_'next_in'||U64'avail_in'||U64'total_in'||*{U8}_U8_'next_out'||U64'avail_out'||U64'total_out'||*{SYM#tag-#anon#ST[*{*{V}_V_(*{V}_V_|U64|U64)->*{V}_V_}_*{V}_V_(*{V}_V_|U64|U64)->*{V}_V__'alloc'||*{V(*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|*{V}_V_)->V_'free'||*{V}_V_'opaque'|]#}_SYM#tag-#anon#ST[*{*{V}_V_(*{V}_V_|U64|U64)->*{V}_V_}_*{V}_V_(*{V}_V_|U64|U64)->*{V}_V__'alloc'||*{V(*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|*{V}_V_)->V_'free'||*{V}_V_'opaque'|]#_'allocator'||*{SYM#tag-lzma_internal_s#}_SYM#tag-lzma_internal_s#_'internal'||*{V}_V_'reserved_ptr1'||*{V}_V_'reserved_ptr2'||*{V}_V_'reserved_ptr3'||*{V}_V_'reserved_ptr4'||U64'reserved_int1'||U64'reserved_int2'||U64'reserved_int3'||U64'reserved_int4'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum1'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum2'|]
// file /usr/include/lzma/base.h line 461
struct anonymous_7;

// tag-#anon#ST[ARR2052{S64}_S64_'table'|]
// file ./../../src/helpers/fst/lz4.h line 184
struct anonymous_25;

// tag-#anon#ST[ARR4096{U32}_U32_'hashTable'||U32'currentOffset'||U32'initCheck'||*{cU8}_cU8_'dictionary'||*{cU8}_cU8_'bufferStart'||U32'dictSize'||U32'_pad0'|]
// file ./../../src/helpers/fst/lz4.c line 435
struct anonymous_23;

// tag-#anon#ST[ARR4{U64}_U64_'table'|]
// file ./../../src/helpers/fst/lz4.h line 242
struct anonymous_27;

// tag-#anon#ST[U32'dict_size'||U32'_pad0'||*{cU8}_cU8_'preset_dict'||U32'preset_dict_size'||U32'lc'||U32'lp'||U32'pb'||EN#anon_enum_LZMA_MODE_FAST=1_LZMA_MODE_NORMAL=2#{U32}_U32_'mode'||U32'nice_len'||EN#anon_enum_LZMA_MF_HC3=3_LZMA_MF_HC4=4_LZMA_MF_BT2=18_LZMA_MF_BT3=19_LZMA_MF_BT4=20#{U32}_U32_'mf'||U32'depth'||U32'reserved_int1'||U32'reserved_int2'||U32'reserved_int3'||U32'reserved_int4'||U32'reserved_int5'||U32'reserved_int6'||U32'reserved_int7'||U32'reserved_int8'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum1'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum2'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum3'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum4'||*{V}_V_'reserved_ptr1'||*{V}_V_'reserved_ptr2'|]
// file /usr/include/lzma/lzma.h line 185
struct anonymous_5;

// tag-#anon#UN[ARR20{S8}_S8_'b'||ARR10{S16}_S16_'s'||ARR5{S64}_S64_'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous_50;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_58;

// tag-#anon#UN[S32'i'||S64'l'||F32'f'||F64'd'||*{V}_V_'v'||*{S8}_S8_'s'||S8'c'||U8'uc'||S16'sh'||U16'ush'||U32'ui'||ARR2{S32}_S32_'iarray'||ARR2{F32}_F32_'farray'||ARR8{S8}_S8_'carray'||ARR8{U8}_U8_'ucarray'|]
// file jrb.h line 6
union anonymous_26;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}_V_'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous_56;

// tag-#anon#UN[S8'char_data'||U8'uchar_data'||S32'bool_data'||S32'int_data'||U32'uint_data'||S64'long_data'||U64'ulong_data'||F32'float_data'||F64'double_data'||*{S8}_S8_'string_data'||*{SYM#tag-_GtkObject#}_SYM#tag-_GtkObject#_'object_data'||*{V}_V_'pointer_data'||SYM#tag-#anon#ST[*{V()->V}_V()->V_'f'||*{V}_V_'d'|]#'signal_data'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 149
union anonymous_33;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_9;

// tag-#anon#UN[SYM#tag-fstHierScope#'scope'||SYM#tag-fstHierVar#'var'||SYM#tag-fstHierAttr#'attr'|]
// file ./../../src/helpers/fst/fstapi.h line 286
union anonymous_29;

// tag-J_UDY_ERROR_STRUCT
// file /usr/include/Judy.h line 181
struct J_UDY_ERROR_STRUCT;

// tag-XDR
// file /usr/include/rpc/xdr.h line 109
struct XDR;

// tag-_AtkObject
// file /usr/include/atk-1.0/atk/atkobject.h line 440
struct _AtkObject;

// tag-_AtkRelationSet
// file /usr/include/atk-1.0/atk/atkobject.h line 442
struct _AtkRelationSet;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GPtrArray
// file /usr/include/glib-2.0/glib/garray.h line 39
struct _GPtrArray;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GTimeVal
// file /usr/include/glib-2.0/glib/gtypes.h line 449
struct _GTimeVal;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkCursor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 104
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDisplay
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 115
struct _GdkDisplay;

// tag-_GdkDisplayPointerHooks
// file /usr/include/gtk-2.0/gdk/gdkdisplay.h line 37
struct _GdkDisplayPointerHooks;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GtkAccelGroup
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 60
struct _GtkAccelGroup;

// tag-_GtkAccelGroupEntry
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 63
struct _GtkAccelGroupEntry;

// tag-_GtkAccelKey
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 62
struct _GtkAccelKey;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkArg
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 48
struct _GtkArg;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkCList
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 117
struct _GtkCList;

// tag-_GtkCListCellInfo
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 132
struct _GtkCListCellInfo;

// tag-_GtkCListColumn
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 119
struct _GtkCListColumn;

// tag-_GtkCTree
// file /usr/include/gtk-2.0/gtk/gtkctree.h line 88
struct _GtkCTree;

// tag-_GtkCTreeNode
// file /usr/include/gtk-2.0/gtk/gtkctree.h line 91
struct _GtkCTreeNode;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkContainerClass
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 52
struct _GtkContainerClass;

// tag-_GtkEntry
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 63
struct _GtkEntry;

// tag-_GtkIMContext
// file /usr/include/gtk-2.0/gtk/gtkimcontext.h line 42
struct _GtkIMContext;

// tag-_GtkMenu
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 49
struct _GtkMenu;

// tag-_GtkMenuShell
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 48
struct _GtkMenuShell;

// tag-_GtkNotebook
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 55
struct _GtkNotebook;

// tag-_GtkNotebookPage
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 58
struct _GtkNotebookPage;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkObjectClass
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 104
struct _GtkObjectClass;

// tag-_GtkPaned
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 46
struct _GtkPaned;

// tag-_GtkPanedPrivate
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 48
struct _GtkPanedPrivate;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSelectionData
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 479
struct _GtkSelectionData;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkTable
// file /usr/include/gtk-2.0/gtk/gtktable.h line 48
struct _GtkTable;

// tag-_GtkTableRowCol
// file /usr/include/gtk-2.0/gtk/gtktable.h line 51
struct _GtkTableRowCol;

// tag-_GtkTargetEntry
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 42
struct _GtkTargetEntry;

// tag-_GtkTextAppearance
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 170
struct _GtkTextAppearance;

// tag-_GtkTextAttributes
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 70
struct _GtkTextAttributes;

// tag-_GtkTextBTree
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 61
struct _GtkTextBTree;

// tag-_GtkTextBuffer
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 51
struct _GtkTextBuffer;

// tag-_GtkTextIter
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 67
struct _GtkTextIter;

// tag-_GtkTextLayout
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 72
struct _GtkTextLayout;

// tag-_GtkTextLogAttrCache
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 63
struct _GtkTextLogAttrCache;

// tag-_GtkTextMark
// file /usr/include/gtk-2.0/gtk/gtktextmark.h line 61
struct _GtkTextMark;

// tag-_GtkTextPendingScroll
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 66
struct _GtkTextPendingScroll;

// tag-_GtkTextTag
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 81
struct _GtkTextTag;

// tag-_GtkTextTagTable
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 68
struct _GtkTextTagTable;

// tag-_GtkTextView
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 61
struct _GtkTextView;

// tag-_GtkTextViewClass
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 62
struct _GtkTextViewClass;

// tag-_GtkTextWindow
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 65
struct _GtkTextWindow;

// tag-_GtkToggleButton
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 48
struct _GtkToggleButton;

// tag-_GtkToolbar
// file /usr/include/gtk-2.0/gtk/gtktoolbar.h line 89
struct _GtkToolbar;

// tag-_GtkTooltip
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 484
struct _GtkTooltip;

// tag-_GtkTooltips
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 46
struct _GtkTooltips;

// tag-_GtkTooltipsData
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 48
struct _GtkTooltipsData;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWidgetClass
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 480
struct _GtkWidgetClass;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLanguage
// file /usr/include/pango-1.0/pango/pango-language.h line 30
struct _PangoLanguage;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-_PangoTabArray
// file /usr/include/pango-1.0/pango/pango-tabs.h line 29
struct _PangoTabArray;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-alloc_bytechain
// file fgetdynamic.h line 16
struct alloc_bytechain;

// tag-ds_component
// file splay.h line 20
struct ds_component;

// tag-ds_tree_node
// file splay.h line 8
struct ds_tree_node;

// tag-fstAttrType
// file ./../../src/helpers/fst/fstapi.h line 174
enum fstAttrType { FST_AT_MIN=0, FST_AT_MISC=0, FST_AT_ARRAY=1, FST_AT_ENUM=2, FST_AT_PACK=3, FST_AT_MAX=3 };

// tag-fstBlackoutChain
// file ./../../src/helpers/fst/fstapi.c line 698
struct fstBlackoutChain;

// tag-fstCurrHier
// file ./../../src/helpers/fst/fstapi.c line 3011
struct fstCurrHier;

// tag-fstFileType
// file ./../../src/helpers/fst/fstapi.h line 49
enum fstFileType { FST_FT_MIN=0, FST_FT_VERILOG=0, FST_FT_VHDL=1, FST_FT_VERILOG_VHDL=2, FST_FT_MAX=2 };

// tag-fstHier
// file ./../../src/helpers/fst/fstapi.h line 282
struct fstHier;

// tag-fstHierAttr
// file ./../../src/helpers/fst/fstapi.h line 311
struct fstHierAttr;

// tag-fstHierScope
// file ./../../src/helpers/fst/fstapi.h line 288
struct fstHierScope;

// tag-fstHierVar
// file ./../../src/helpers/fst/fstapi.h line 297
struct fstHierVar;

// tag-fstReaderContext
// file ./../../src/helpers/fst/fstapi.c line 3019
struct fstReaderContext;

// tag-fstScopeType
// file ./../../src/helpers/fst/fstapi.h line 74
enum fstScopeType { FST_ST_MIN=0, FST_ST_VCD_MODULE=0, FST_ST_VCD_TASK=1, FST_ST_VCD_FUNCTION=2, FST_ST_VCD_BEGIN=3, FST_ST_VCD_FORK=4, FST_ST_VCD_GENERATE=5, FST_ST_VCD_STRUCT=6, FST_ST_VCD_UNION=7, FST_ST_VCD_CLASS=8, FST_ST_VCD_INTERFACE=9, FST_ST_VCD_PACKAGE=10, FST_ST_VCD_PROGRAM=11, FST_ST_VHDL_ARCHITECTURE=12, FST_ST_VHDL_PROCEDURE=13, FST_ST_VHDL_FUNCTION=14, FST_ST_VHDL_RECORD=15, FST_ST_VHDL_PROCESS=16, FST_ST_VHDL_BLOCK=17, FST_ST_VHDL_FOR_GENERATE=18, FST_ST_VHDL_IF_GENERATE=19, FST_ST_VHDL_GENERATE=20, FST_ST_VHDL_PACKAGE=21, FST_ST_MAX=21, FST_ST_GEN_ATTRBEGIN=252, FST_ST_GEN_ATTREND=253, FST_ST_VCD_SCOPE=254, FST_ST_VCD_UPSCOPE=255 };

// tag-fstSupplementalDataType
// file ./../../src/helpers/fst/fstapi.h line 253
enum fstSupplementalDataType { FST_SDT_MIN=0, FST_SDT_NONE=0, FST_SDT_VHDL_BOOLEAN=1, FST_SDT_VHDL_BIT=2, FST_SDT_VHDL_BIT_VECTOR=3, FST_SDT_VHDL_STD_ULOGIC=4, FST_SDT_VHDL_STD_ULOGIC_VECTOR=5, FST_SDT_VHDL_STD_LOGIC=6, FST_SDT_VHDL_STD_LOGIC_VECTOR=7, FST_SDT_VHDL_UNSIGNED=8, FST_SDT_VHDL_SIGNED=9, FST_SDT_VHDL_INTEGER=10, FST_SDT_VHDL_REAL=11, FST_SDT_VHDL_NATURAL=12, FST_SDT_VHDL_POSITIVE=13, FST_SDT_VHDL_TIME=14, FST_SDT_VHDL_CHARACTER=15, FST_SDT_VHDL_STRING=16, FST_SDT_MAX=16, FST_SDT_SVT_SHIFT_COUNT=10, FST_SDT_ABS_MAX=1023 };

// tag-fstSupplementalVarType
// file ./../../src/helpers/fst/fstapi.h line 239
enum fstSupplementalVarType { FST_SVT_MIN=0, FST_SVT_NONE=0, FST_SVT_VHDL_SIGNAL=1, FST_SVT_VHDL_VARIABLE=2, FST_SVT_VHDL_CONSTANT=3, FST_SVT_VHDL_FILE=4, FST_SVT_VHDL_MEMORY=5, FST_SVT_MAX=5 };

// tag-fstVarDir
// file ./../../src/helpers/fst/fstapi.h line 149
enum fstVarDir { FST_VD_MIN=0, FST_VD_IMPLICIT=0, FST_VD_INPUT=1, FST_VD_OUTPUT=2, FST_VD_INOUT=3, FST_VD_BUFFER=4, FST_VD_LINKAGE=5, FST_VD_MAX=5 };

// tag-fstVarType
// file ./../../src/helpers/fst/fstapi.h line 110
enum fstVarType { FST_VT_MIN=0, FST_VT_VCD_EVENT=0, FST_VT_VCD_INTEGER=1, FST_VT_VCD_PARAMETER=2, FST_VT_VCD_REAL=3, FST_VT_VCD_REAL_PARAMETER=4, FST_VT_VCD_REG=5, FST_VT_VCD_SUPPLY0=6, FST_VT_VCD_SUPPLY1=7, FST_VT_VCD_TIME=8, FST_VT_VCD_TRI=9, FST_VT_VCD_TRIAND=10, FST_VT_VCD_TRIOR=11, FST_VT_VCD_TRIREG=12, FST_VT_VCD_TRI0=13, FST_VT_VCD_TRI1=14, FST_VT_VCD_WAND=15, FST_VT_VCD_WIRE=16, FST_VT_VCD_WOR=17, FST_VT_VCD_PORT=18, FST_VT_VCD_SPARRAY=19, FST_VT_VCD_REALTIME=20, FST_VT_GEN_STRING=21, FST_VT_SV_BIT=22, FST_VT_SV_LOGIC=23, FST_VT_SV_INT=24, FST_VT_SV_SHORTINT=25, FST_VT_SV_LONGINT=26, FST_VT_SV_BYTE=27, FST_VT_SV_ENUM=28, FST_VT_SV_SHORTREAL=29, FST_VT_MAX=29 };

// tag-fstWriterContext
// file ./../../src/helpers/fst/fstapi.c line 706
struct fstWriterContext;

// tag-fstWriterPackType
// file ./../../src/helpers/fst/fstapi.h line 43
enum fstWriterPackType { FST_WR_PT_ZLIB=0, FST_WR_PT_FASTLZ=1, FST_WR_PT_LZ4=2 };

// tag-gtkwave_annotate_ipc_t
// file ../../src/debug.h line 148
struct gtkwave_annotate_ipc_t;

// tag-gzFile_s
// file /usr/include/zlib.h line 1224
struct gzFile_s;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-jrb_chain
// file jrb.h line 24
struct jrb_chain;

// tag-jrb_node
// file jrb.h line 35
struct jrb_node;

// tag-logfile_context_t
// file logfile.c line 50
struct logfile_context_t;

// tag-lxt2_rd_block
// file ../../src/helpers/lxt2_read.h line 174
struct lxt2_rd_block;

// tag-lxt2_rd_facname_cache
// file ../../src/helpers/lxt2_read.h line 204
struct lxt2_rd_facname_cache;

// tag-lxt2_rd_geometry
// file ../../src/helpers/lxt2_read.h line 196
struct lxt2_rd_geometry;

// tag-lxt2_rd_trace
// file ../../src/helpers/lxt2_read.h line 213
struct lxt2_rd_trace;

// tag-lzma_handle_t
// file ./../../src/liblzma/LzmaLib.c line 42
struct lzma_handle_t;

// tag-lzma_internal_s
// file /usr/include/lzma/base.h line 419
struct lzma_internal_s;

// tag-lzma_state_t
// file ./../../src/liblzma/LzmaLib.c line 39
enum lzma_state_t { LZMA_STATE_WRITE=0, LZMA_STATE_READ_ERROR=1, LZMA_STATE_READ_INIT=2, LZMA_STATE_READ_GETBLOCK=3, LZMA_STATE_READ_GETBYTES=4 };

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 309
union pthread_attr_t;

// tag-text_find_t
// file logfile.c line 61
struct text_find_t;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-vzt_ncycle_autosort
// file ./../../src/helpers/vzt_read.c line 55
struct vzt_ncycle_autosort;

// tag-vzt_pth_args
// file ./../../src/helpers/vzt_read.c line 60
struct vzt_pth_args;

// tag-vzt_rd_block
// file ../../src/helpers/vzt_read.h line 147
struct vzt_rd_block;

// tag-vzt_rd_facname_cache
// file ../../src/helpers/vzt_read.h line 189
struct vzt_rd_facname_cache;

// tag-vzt_rd_geometry
// file ../../src/helpers/vzt_read.h line 181
struct vzt_rd_geometry;

// tag-vzt_rd_trace
// file ../../src/helpers/vzt_read.h line 198
struct vzt_rd_trace;

// tag-vzt_synvec_chain
// file ./../../src/helpers/vzt_read.c line 66
struct vzt_synvec_chain;

// tag-wave_logfile_lines_t
// file logfile.c line 43
struct wave_logfile_lines_t;

// tag-xdr_op
// file /usr/include/rpc/xdr.h line 81
enum xdr_op { XDR_ENCODE=0, XDR_DECODE=1, XDR_FREE=2 };

// tag-xdr_ops
// file /usr/include/rpc/xdr.h line 113
struct xdr_ops;

// tag-yy_buffer_state
// file vlex.c line 99
struct yy_buffer_state;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// BZ2_bzclose
// file /usr/include/bzlib.h line 264
extern void BZ2_bzclose(void *);
// BZ2_bzdopen
// file /usr/include/bzlib.h line 243
extern void * BZ2_bzdopen(signed int, const char *);
// BZ2_bzread
// file /usr/include/bzlib.h line 248
extern signed int BZ2_bzread(void *, void *, signed int);
// DNDBeginCB
// file logfile.c line 780
static void DNDBeginCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, void *data);
// DNDBeginCB_link1
// file tcl_helper.c line 684
static void DNDBeginCB_link1(struct _GtkWidget *widget_link1, struct _GdkDragContext *dc_link1, void *data_link1);
// DNDDataDeleteCB
// file logfile.c line 802
static void DNDDataDeleteCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, void *data);
// DNDDataReceivedCB
// file tcl_helper.c line 711
static void DNDDataReceivedCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, signed int x, signed int y, struct _GtkSelectionData *selection_data, unsigned int info, unsigned int t, void *data);
// DNDDataRequestCB
// file logfile.c line 813
static void DNDDataRequestCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, struct _GtkSelectionData *selection_data, unsigned int info, unsigned int t, void *data);
// DNDDragMotionCB
// file tcl_helper.c line 640
static signed int DNDDragMotionCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, signed int xx, signed int yy, unsigned int tt, void *data);
// DNDEndCB
// file logfile.c line 791
static void DNDEndCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, void *data);
// DNDEndCB_link1
// file tcl_helper.c line 693
static void DNDEndCB_link1(struct _GtkWidget *widget_link1, struct _GdkDragContext *dc_link1, void *data_link1);
// JudyHSFreeArray
// file /usr/include/Judy.h line 289
extern unsigned long int JudyHSFreeArray(void **, struct J_UDY_ERROR_STRUCT *);
// JudyHSIns
// file /usr/include/Judy.h line 287
extern void ** JudyHSIns(void **, void *, unsigned long int, struct J_UDY_ERROR_STRUCT *);
// LZ4_64bits
// file ./../../src/helpers/fst/lz4.c line 178
static unsigned int LZ4_64bits(void);
// LZ4_NbCommonBytes
// file ./../../src/helpers/fst/lz4.c line 327
static unsigned int LZ4_NbCommonBytes(unsigned long int val);
// LZ4_compress
// file ./../../src/helpers/fst/lz4.c line 710
signed int LZ4_compress(const char *source, char *dest, signed int inputSize);
// LZ4_compressBound
// file ./../../src/helpers/fst/lz4.c line 429
signed int LZ4_compressBound(signed int isize);
// LZ4_compress_continue
// file ./../../src/helpers/fst/lz4.c line 883
signed int LZ4_compress_continue(struct anonymous_25 *LZ4_stream, const char *source, char *dest, signed int inputSize);
// LZ4_compress_continue_generic
// file ./../../src/helpers/fst/lz4.c line 833
static inline signed int LZ4_compress_continue_generic(void *LZ4_stream, const char *source, char *dest, signed int inputSize, signed int maxOutputSize, enum anonymous_24 limit);
// LZ4_compress_forceExtDict
// file ./../../src/helpers/fst/lz4.c line 895
signed int LZ4_compress_forceExtDict(struct anonymous_25 *LZ4_dict, const char *source, char *dest, signed int inputSize);
// LZ4_compress_generic
// file ./../../src/helpers/fst/lz4.c line 498
static signed int LZ4_compress_generic(void *ctx, const char *source, char *dest, signed int inputSize, signed int maxOutputSize, enum anonymous_24 outputLimited, enum anonymous_20 tableType, enum anonymous_21 dict, enum anonymous_22 dictIssue);
// LZ4_compress_limitedOutput
// file ./../../src/helpers/fst/lz4.c line 730
signed int LZ4_compress_limitedOutput(const char *source, char *dest, signed int inputSize, signed int maxOutputSize);
// LZ4_compress_limitedOutput_continue
// file ./../../src/helpers/fst/lz4.c line 888
signed int LZ4_compress_limitedOutput_continue(struct anonymous_25 *LZ4_stream, const char *source, char *dest, signed int inputSize, signed int maxOutputSize);
// LZ4_compress_limitedOutput_withState
// file ./../../src/helpers/fst/lz4.c line 1343
signed int LZ4_compress_limitedOutput_withState(void *state, const char *source, char *dest, signed int inputSize, signed int maxOutputSize);
// LZ4_compress_withState
// file ./../../src/helpers/fst/lz4.c line 1332
signed int LZ4_compress_withState(void *state, const char *source, char *dest, signed int inputSize);
// LZ4_copy4
// file ./../../src/helpers/fst/lz4.c line 259
static void LZ4_copy4(void *dstPtr, const void *srcPtr);
// LZ4_copy8
// file ./../../src/helpers/fst/lz4.c line 269
static void LZ4_copy8(void *dstPtr, const void *srcPtr);
// LZ4_count
// file ./../../src/helpers/fst/lz4.c line 394
static unsigned int LZ4_count(const unsigned char *pIn, const unsigned char *pMatch, const unsigned char *pInLimit);
// LZ4_create
// file ./../../src/helpers/fst/lz4.c line 1314
void * LZ4_create(const char *inputBuffer);
// LZ4_createStream
// file ./../../src/helpers/fst/lz4.c line 765
struct anonymous_25 * LZ4_createStream(void);
// LZ4_createStreamDecode
// file ./../../src/helpers/fst/lz4.c line 1152
struct anonymous_27 * LZ4_createStreamDecode(void);
// LZ4_decompress_fast
// file ./../../src/helpers/fst/lz4.c line 1131
signed int LZ4_decompress_fast(const char *source, char *dest, signed int originalSize);
// LZ4_decompress_fast_continue
// file ./../../src/helpers/fst/lz4.c line 1217
signed int LZ4_decompress_fast_continue(struct anonymous_27 *LZ4_streamDecode, const char *source, char *dest, signed int originalSize);
// LZ4_decompress_fast_usingDict
// file ./../../src/helpers/fst/lz4.c line 1272
signed int LZ4_decompress_fast_usingDict(const char *source, char *dest, signed int originalSize, const char *dictStart, signed int dictSize);
// LZ4_decompress_fast_withPrefix64k
// file ./../../src/helpers/fst/lz4.c line 1361
signed int LZ4_decompress_fast_withPrefix64k(const char *source, char *dest, signed int originalSize);
// LZ4_decompress_generic
// file ./../../src/helpers/fst/lz4.c line 942
static inline signed int LZ4_decompress_generic(const char * const source, char * const dest, signed int inputSize, signed int outputSize, signed int endOnInput, signed int partialDecoding, signed int targetOutputSize, signed int dict, const unsigned char * const lowPrefix, const unsigned char * const dictStart, const unsigned long int dictSize);
// LZ4_decompress_safe
// file ./../../src/helpers/fst/lz4.c line 1121
signed int LZ4_decompress_safe(const char *source, char *dest, signed int compressedSize, signed int maxDecompressedSize);
// LZ4_decompress_safe_continue
// file ./../../src/helpers/fst/lz4.c line 1188
signed int LZ4_decompress_safe_continue(struct anonymous_27 *LZ4_streamDecode, const char *source, char *dest, signed int compressedSize, signed int maxOutputSize);
// LZ4_decompress_safe_forceExtDict
// file ./../../src/helpers/fst/lz4.c line 1278
signed int LZ4_decompress_safe_forceExtDict(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize, const char *dictStart, signed int dictSize);
// LZ4_decompress_safe_partial
// file ./../../src/helpers/fst/lz4.c line 1126
signed int LZ4_decompress_safe_partial(const char *source, char *dest, signed int compressedSize, signed int targetOutputSize, signed int maxDecompressedSize);
// LZ4_decompress_safe_usingDict
// file ./../../src/helpers/fst/lz4.c line 1267
signed int LZ4_decompress_safe_usingDict(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize, const char *dictStart, signed int dictSize);
// LZ4_decompress_safe_withPrefix64k
// file ./../../src/helpers/fst/lz4.c line 1356
signed int LZ4_decompress_safe_withPrefix64k(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize);
// LZ4_decompress_usingDict_generic
// file ./../../src/helpers/fst/lz4.c line 1254
static inline signed int LZ4_decompress_usingDict_generic(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize, signed int safe, const char *dictStart, signed int dictSize);
// LZ4_freeStream
// file ./../../src/helpers/fst/lz4.c line 773
signed int LZ4_freeStream(struct anonymous_25 *LZ4_stream);
// LZ4_freeStreamDecode
// file ./../../src/helpers/fst/lz4.c line 1158
signed int LZ4_freeStreamDecode(struct anonymous_27 *LZ4_stream);
// LZ4_getPosition
// file ./../../src/helpers/fst/lz4.c line 492
static const unsigned char * LZ4_getPosition(const unsigned char *p, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase);
// LZ4_getPositionOnHash
// file ./../../src/helpers/fst/lz4.c line 485
static const unsigned char * LZ4_getPositionOnHash(unsigned int h, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase);
// LZ4_hashPosition
// file ./../../src/helpers/fst/lz4.c line 467
static unsigned int LZ4_hashPosition(const unsigned char *p, enum anonymous_20 tableType);
// LZ4_hashSequence
// file ./../../src/helpers/fst/lz4.c line 459
static unsigned int LZ4_hashSequence(unsigned int sequence, enum anonymous_20 tableType);
// LZ4_init
// file ./../../src/helpers/fst/lz4.c line 1301
static void LZ4_init(struct anonymous_23 *lz4ds, const unsigned char *base);
// LZ4_isLittleEndian
// file ./../../src/helpers/fst/lz4.c line 180
static unsigned int LZ4_isLittleEndian(void);
// LZ4_loadDict
// file ./../../src/helpers/fst/lz4.c line 780
signed int LZ4_loadDict(struct anonymous_25 *LZ4_dict, const char *dictionary, signed int dictSize);
// LZ4_putPosition
// file ./../../src/helpers/fst/lz4.c line 479
static void LZ4_putPosition(const unsigned char *p, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase);
// LZ4_putPositionOnHash
// file ./../../src/helpers/fst/lz4.c line 469
static void LZ4_putPositionOnHash(const unsigned char *p, unsigned int h, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase);
// LZ4_read16
// file ./../../src/helpers/fst/lz4.c line 214
static unsigned short int LZ4_read16(const void *memPtr);
// LZ4_read32
// file ./../../src/helpers/fst/lz4.c line 226
static unsigned int LZ4_read32(const void *memPtr);
// LZ4_read64
// file ./../../src/helpers/fst/lz4.c line 238
static unsigned long int LZ4_read64(const void *memPtr);
// LZ4_readLE16
// file ./../../src/helpers/fst/lz4.c line 187
static unsigned short int LZ4_readLE16(const void *memPtr);
// LZ4_read_ARCH
// file ./../../src/helpers/fst/lz4.c line 250
static unsigned long int LZ4_read_ARCH(const void *p);
// LZ4_renormDictT
// file ./../../src/helpers/fst/lz4.c line 812
static void LZ4_renormDictT(struct anonymous_23 *LZ4_dict, const unsigned char *src);
// LZ4_resetStream
// file ./../../src/helpers/fst/lz4.c line 760
void LZ4_resetStream(struct anonymous_25 *LZ4_stream);
// LZ4_resetStreamState
// file ./../../src/helpers/fst/lz4.c line 1307
signed int LZ4_resetStreamState(void *state, const char *inputBuffer);
// LZ4_saveDict
// file ./../../src/helpers/fst/lz4.c line 915
signed int LZ4_saveDict(struct anonymous_25 *LZ4_dict, char *safeBuffer, signed int dictSize);
// LZ4_setStreamDecode
// file ./../../src/helpers/fst/lz4.c line 1171
signed int LZ4_setStreamDecode(struct anonymous_27 *LZ4_streamDecode, const char *dictionary, signed int dictSize);
// LZ4_sizeofState
// file ./../../src/helpers/fst/lz4.c line 1330
signed int LZ4_sizeofState(void);
// LZ4_sizeofStreamState
// file ./../../src/helpers/fst/lz4.c line 1299
signed int LZ4_sizeofStreamState(void);
// LZ4_slideInputBuffer
// file ./../../src/helpers/fst/lz4.c line 1321
char * LZ4_slideInputBuffer(void *LZ4_Data);
// LZ4_uncompress
// file ./../../src/helpers/fst/lz4.c line 1293
signed int LZ4_uncompress(const char *source, char *dest, signed int outputSize);
// LZ4_uncompress_unknownOutputSize
// file ./../../src/helpers/fst/lz4.c line 1294
signed int LZ4_uncompress_unknownOutputSize(const char *source, char *dest, signed int isize, signed int maxOutputSize);
// LZ4_versionNumber
// file ./../../src/helpers/fst/lz4.c line 428
signed int LZ4_versionNumber(void);
// LZ4_wildCopy
// file ./../../src/helpers/fst/lz4.c line 286
static void LZ4_wildCopy(void *dstPtr, const void *srcPtr, void *dstEnd);
// LZ4_writeLE16
// file ./../../src/helpers/fst/lz4.c line 198
static void LZ4_writeLE16(void *memPtr, unsigned short int value);
// LZMA_close
// file ./../../src/liblzma/LzmaLib.h line 33
void LZMA_close(void *handle);
// LZMA_fdopen
// file ./../../src/liblzma/LzmaLib.h line 32
void * LZMA_fdopen(signed int fd, const char *mode);
// LZMA_flush
// file ./../../src/liblzma/LzmaLib.c line 208
unsigned long int LZMA_flush(void *handle);
// LZMA_read
// file ./../../src/liblzma/LzmaLib.h line 36
unsigned long int LZMA_read(void *handle, void *mem, unsigned long int len);
// LZMA_read_varint
// file ./../../src/liblzma/LzmaLib.c line 73
static unsigned long int LZMA_read_varint(struct lzma_handle_t *h);
// LZMA_write
// file ./../../src/liblzma/LzmaLib.c line 244
unsigned long int LZMA_write(void *handle, void *mem, unsigned long int len);
// LZMA_write_compress
// file ./../../src/liblzma/LzmaLib.c line 97
static unsigned long int LZMA_write_compress(struct lzma_handle_t *h, unsigned char *mem, unsigned long int len);
// LZMA_write_varint
// file ./../../src/liblzma/LzmaLib.c line 54
static void LZMA_write_varint(struct lzma_handle_t *h, unsigned long int v);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// asctime
// file /usr/include/time.h line 261
extern char * asctime(struct tm *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// button_press_event
// file logfile.c line 111
static signed int button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event);
// button_release_event
// file logfile.c line 1168
static signed int button_release_event(struct _GtkWidget *text, struct _GdkEventButton *event);
// bwlogbox
// file logfile.c line 1639
void bwlogbox(char *title, signed int width, struct ds_tree_node *t, signed int display_mode);
// bwlogbox_2
// file logfile.c line 1855
void bwlogbox_2(struct logfile_context_t *ctx, struct _GtkWidget *window, struct _GtkWidget *button, struct _GtkWidget *text);
// bwmaketree
// file tree_widget.c line 23
void bwmaketree(void);
// bwsigcmp
// file stem_recurse.c line 49
static signed int bwsigcmp(char *s1, char *s2);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cleanup_object
//
void cleanup_object(void);
// clearerr
// file /usr/include/stdio.h line 826
extern void clearerr(struct _IO_FILE *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// compar_comp_array_bsearch
// file stem_recurse.c line 91
static signed int compar_comp_array_bsearch(const void *s1, const void *s2);
// compress2
// file /usr/include/zlib.h line 1174
extern signed int compress2(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int, signed int);
// compressBound
// file /usr/include/zlib.h line 1190
extern unsigned long int compressBound(unsigned long int);
// create_log_text
// file logfile.c line 1357
static struct _GtkWidget * create_log_text(struct _GtkWidget **textpnt);
// create_toolbar
// file logfile.c line 518
void create_toolbar(struct _GtkWidget *table);
// delete_item
// file jrb.c line 63
static void delete_item(struct jrb_node *item);
// destroy_callback
// file logfile.c line 1551
static void destroy_callback(struct _GtkWidget *widget, void *dummy);
// destroy_callback_link1
// file tree_widget.c line 87
static void destroy_callback_link1(struct _GtkWidget *widget_link1, struct _GtkWidget *nothing);
// destroy_via_closebutton_release
// file logfile.c line 1624
static signed int destroy_via_closebutton_release(struct _GtkWidget *widget, struct _GdkEventButton *event);
// ds_delete
// file splay.c line 127
struct ds_tree_node * ds_delete(char *i, struct ds_tree_node *t);
// ds_insert
// file splay.c line 94
struct ds_tree_node * ds_insert(char *i, struct ds_tree_node *t);
// ds_splay
// file splay.c line 49
struct ds_tree_node * ds_splay(char *i, struct ds_tree_node *t);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expose_event_local
// file logfile.c line 121
static signed int expose_event_local(struct _GtkWidget *widget, struct _GdkEventExpose *event);
// fastlz1_compress
// file ./../../src/helpers/fst/fastlz.c line 162
static inline signed int fastlz1_compress(const void *input, signed int length, void *output);
// fastlz1_decompress
// file ./../../src/helpers/fst/fastlz.c line 416
static inline signed int fastlz1_decompress(const void *input, signed int length, void *output, signed int maxout);
// fastlz2_compress
// file ./../../src/helpers/fst/fastlz.c line 162
static inline signed int fastlz2_compress(const void *input, signed int length, void *output);
// fastlz2_decompress
// file ./../../src/helpers/fst/fastlz.c line 416
static inline signed int fastlz2_decompress(const void *input, signed int length, void *output, signed int maxout);
// fastlz_compress
// file ./../../src/helpers/fst/fastlz.c line 126
signed int fastlz_compress(const void *input, signed int length, void *output);
// fastlz_compress_level
// file ./../../src/helpers/fst/fastlz.c line 150
signed int fastlz_compress_level(signed int level, const void *input, signed int length, void *output);
// fastlz_decompress
// file ./../../src/helpers/fst/fastlz.c line 136
signed int fastlz_decompress(const void *input, signed int length, void *output, signed int maxout);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgetmalloc
// file fgetdynamic.c line 31
char * fgetmalloc(struct _IO_FILE *handle);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_edit_cb
// file logfile.c line 473
static signed int find_edit_cb(struct _GtkWidget *widget, struct _GdkEventKey *ev, void **data);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// forward_chars_with_skipping
// file logfile.c line 174
static void forward_chars_with_skipping(struct _GtkTextIter *iter, signed int count);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseeko
// file /usr/include/stdio.h line 773
extern signed int fseeko(struct _IO_FILE *, signed long int, signed int);
// fstCopyVarint32ToLeft
// file ./../../src/helpers/fst/fstapi.c line 458
static unsigned char * fstCopyVarint32ToLeft(unsigned char *pnt, unsigned int v);
// fstCopyVarint64ToRight
// file ./../../src/helpers/fst/fstapi.c line 486
static unsigned char * fstCopyVarint64ToRight(unsigned char *pnt, unsigned long int v);
// fstDestroyMmaps
// file ./../../src/helpers/fst/fstapi.c line 981
static void fstDestroyMmaps(struct fstWriterContext *xc, signed int is_closing);
// fstDetermineBreakSize
// file ./../../src/helpers/fst/fstapi.c line 1018
static void fstDetermineBreakSize(struct fstWriterContext *xc);
// fstExtractRvatDataFromFrame
// file ./../../src/helpers/fst/fstapi.c line 5637
static char * fstExtractRvatDataFromFrame(struct fstReaderContext *xc, unsigned int facidx, char *buf);
// fstFread
// file ./../../src/helpers/fst/fstapi.c line 260
static unsigned long int fstFread(void *buf, unsigned long int siz, unsigned long int cnt, struct _IO_FILE *fp);
// fstFtruncate
// file ./../../src/helpers/fst/fstapi.c line 270
static signed int fstFtruncate(signed int fd, signed long int length);
// fstFwrite
// file ./../../src/helpers/fst/fstapi.c line 265
static unsigned long int fstFwrite(const void *buf, unsigned long int siz, unsigned long int cnt, struct _IO_FILE *fp);
// fstGetSVarint64
// file ./../../src/helpers/fst/fstapi.c line 635
static signed long int fstGetSVarint64(unsigned char *mem, signed int *skiplen);
// fstGetVarint32
// file ./../../src/helpers/fst/fstapi.c line 396
static unsigned int fstGetVarint32(unsigned char *mem, signed int *skiplen);
// fstGetVarint32Length
// file ./../../src/helpers/fst/fstapi.c line 421
static unsigned int fstGetVarint32Length(unsigned char *mem);
// fstGetVarint32NoSkip
// file ./../../src/helpers/fst/fstapi.c line 434
static unsigned int fstGetVarint32NoSkip(unsigned char *mem);
// fstGetVarint64
// file ./../../src/helpers/fst/fstapi.c line 501
static unsigned long int fstGetVarint64(unsigned char *mem, signed int *skiplen);
// fstReaderClose
// file ./../../src/helpers/fst/fstapi.c line 4608
void fstReaderClose(void *ctx);
// fstReaderClrFacProcessMask
// file ./../../src/helpers/fst/fstapi.c line 3343
void fstReaderClrFacProcessMask(void *ctx, unsigned int facidx);
// fstReaderClrFacProcessMaskAll
// file ./../../src/helpers/fst/fstapi.c line 3372
void fstReaderClrFacProcessMaskAll(void *ctx);
// fstReaderDeallocateRvatData
// file ./../../src/helpers/fst/fstapi.c line 4592
static void fstReaderDeallocateRvatData(void *ctx);
// fstReaderDeallocateScopeData
// file ./../../src/helpers/fst/fstapi.c line 3167
static void fstReaderDeallocateScopeData(struct fstReaderContext *xc);
// fstReaderFseeko
// file ./../../src/helpers/fst/fstapi.c line 3112
signed int fstReaderFseeko(struct fstReaderContext *xc, struct _IO_FILE *stream, signed long int offset, signed int whence);
// fstReaderGetAliasCount
// file ./../../src/helpers/fst/fstapi.c line 3435
unsigned long int fstReaderGetAliasCount(void *ctx);
// fstReaderGetCurrentFlatScope
// file ./../../src/helpers/fst/fstapi.h line 373
const char * fstReaderGetCurrentFlatScope(void *ctx);
// fstReaderGetCurrentScopeLen
// file ./../../src/helpers/fst/fstapi.c line 3278
signed int fstReaderGetCurrentScopeLen(void *ctx);
// fstReaderGetCurrentScopeUserInfo
// file ./../../src/helpers/fst/fstapi.c line 3195
void * fstReaderGetCurrentScopeUserInfo(void *ctx);
// fstReaderGetDateString
// file ./../../src/helpers/fst/fstapi.c line 3463
const char * fstReaderGetDateString(void *ctx);
// fstReaderGetDoubleEndianMatchState
// file ./../../src/helpers/fst/fstapi.c line 3449
signed int fstReaderGetDoubleEndianMatchState(void *ctx);
// fstReaderGetDumpActivityChangeTime
// file ./../../src/helpers/fst/fstapi.c line 3491
unsigned long int fstReaderGetDumpActivityChangeTime(void *ctx, unsigned int idx);
// fstReaderGetDumpActivityChangeValue
// file ./../../src/helpers/fst/fstapi.c line 3506
unsigned char fstReaderGetDumpActivityChangeValue(void *ctx, unsigned int idx);
// fstReaderGetEndTime
// file ./../../src/helpers/fst/fstapi.c line 3400
unsigned long int fstReaderGetEndTime(void *ctx);
// fstReaderGetFacProcessMask
// file ./../../src/helpers/fst/fstapi.c line 3306
signed int fstReaderGetFacProcessMask(void *ctx, unsigned int facidx);
// fstReaderGetFileType
// file ./../../src/helpers/fst/fstapi.c line 3470
signed int fstReaderGetFileType(void *ctx);
// fstReaderGetFseekFailed
// file ./../../src/helpers/fst/fstapi.c line 3291
signed int fstReaderGetFseekFailed(void *ctx);
// fstReaderGetMaxHandle
// file ./../../src/helpers/fst/fstapi.c line 3428
unsigned int fstReaderGetMaxHandle(void *ctx);
// fstReaderGetMemoryUsedByWriter
// file ./../../src/helpers/fst/fstapi.c line 3407
unsigned long int fstReaderGetMemoryUsedByWriter(void *ctx);
// fstReaderGetNumberDumpActivityChanges
// file ./../../src/helpers/fst/fstapi.c line 3484
unsigned int fstReaderGetNumberDumpActivityChanges(void *ctx);
// fstReaderGetScopeCount
// file ./../../src/helpers/fst/fstapi.c line 3414
unsigned long int fstReaderGetScopeCount(void *ctx);
// fstReaderGetStartTime
// file ./../../src/helpers/fst/fstapi.c line 3393
unsigned long int fstReaderGetStartTime(void *ctx);
// fstReaderGetTimescale
// file ./../../src/helpers/fst/fstapi.c line 3386
signed char fstReaderGetTimescale(void *ctx);
// fstReaderGetTimezero
// file ./../../src/helpers/fst/fstapi.c line 3477
signed long int fstReaderGetTimezero(void *ctx);
// fstReaderGetValueChangeSectionCount
// file ./../../src/helpers/fst/fstapi.c line 3442
unsigned long int fstReaderGetValueChangeSectionCount(void *ctx);
// fstReaderGetValueFromHandleAtTime
// file ./../../src/helpers/fst/fstapi.h line 392
char * fstReaderGetValueFromHandleAtTime(void *ctx, unsigned long int tim, unsigned int facidx, char *buf);
// fstReaderGetVarCount
// file ./../../src/helpers/fst/fstapi.h line 393
unsigned long int fstReaderGetVarCount(void *ctx);
// fstReaderGetVersionString
// file ./../../src/helpers/fst/fstapi.c line 3456
const char * fstReaderGetVersionString(void *ctx);
// fstReaderInit
// file ./../../src/helpers/fst/fstapi.c line 4223
signed int fstReaderInit(struct fstReaderContext *xc);
// fstReaderIterBlocks
// file ./../../src/helpers/fst/fstapi.c line 4651
signed int fstReaderIterBlocks(void *ctx, void (*value_change_callback)(void *, unsigned long int, unsigned int, const unsigned char *), void *user_callback_data_pointer, struct _IO_FILE *fv);
// fstReaderIterBlocks2
// file ./../../src/helpers/fst/fstapi.c line 4659
signed int fstReaderIterBlocks2(void *ctx, void (*value_change_callback)(void *, unsigned long int, unsigned int, const unsigned char *), void (*value_change_callback_varlen)(void *, unsigned long int, unsigned int, const unsigned char *, unsigned int), void *user_callback_data_pointer, struct _IO_FILE *fv);

//


//


//

// fstReaderIterBlocksSetNativeDoublesOnCallback
// file ./../../src/helpers/fst/fstapi.c line 3556
void fstReaderIterBlocksSetNativeDoublesOnCallback(void *ctx, signed int enable);
// fstReaderIterateHier
// file ./../../src/helpers/fst/fstapi.h line 395
struct fstHier * fstReaderIterateHier(void *ctx);
// fstReaderIterateHierRewind
// file ./../../src/helpers/fst/fstapi.h line 396
signed int fstReaderIterateHierRewind(void *ctx);
// fstReaderOpen
// file ./../../src/helpers/fst/fstapi.c line 4549
void * fstReaderOpen(const char *nam);
// fstReaderOpenForUtilitiesOnly
// file ./../../src/helpers/fst/fstapi.c line 4541
void * fstReaderOpenForUtilitiesOnly(void);
// fstReaderPopScope
// file ./../../src/helpers/fst/fstapi.h line 407
const char * fstReaderPopScope(void *ctx);
// fstReaderProcessHier
// file ./../../src/helpers/fst/fstapi.c line 3940
signed int fstReaderProcessHier(void *ctx, struct _IO_FILE *fv);
// fstReaderPushScope
// file ./../../src/helpers/fst/fstapi.h line 409
const char * fstReaderPushScope(void *ctx, const char *nam, void *user_info);
// fstReaderRecreateHierFile
// file ./../../src/helpers/fst/fstapi.c line 3599
static signed int fstReaderRecreateHierFile(struct fstReaderContext *xc);
// fstReaderResetScope
// file ./../../src/helpers/fst/fstapi.h line 410
void fstReaderResetScope(void *ctx);
// fstReaderSetFacProcessMask
// file ./../../src/helpers/fst/fstapi.c line 3325
void fstReaderSetFacProcessMask(void *ctx, unsigned int facidx);
// fstReaderSetFacProcessMaskAll
// file ./../../src/helpers/fst/fstapi.c line 3361
void fstReaderSetFacProcessMaskAll(void *ctx);
// fstReaderSetLimitTimeRange
// file ./../../src/helpers/fst/fstapi.c line 3521
void fstReaderSetLimitTimeRange(void *ctx, unsigned long int start_time, unsigned long int end_time);
// fstReaderSetUnlimitedTimeRange
// file ./../../src/helpers/fst/fstapi.c line 3534
void fstReaderSetUnlimitedTimeRange(void *ctx);
// fstReaderSetVcdExtensions
// file ./../../src/helpers/fst/fstapi.c line 3545
void fstReaderSetVcdExtensions(void *ctx, signed int enable);
// fstReaderUint64
// file ./../../src/helpers/fst/fstapi.c line 379
static unsigned long int fstReaderUint64(struct _IO_FILE *f);
// fstReaderVarint32
// file ./../../src/helpers/fst/fstapi.c line 526
static unsigned int fstReaderVarint32(struct _IO_FILE *f);
// fstReaderVarint32WithSkip
// file ./../../src/helpers/fst/fstapi.c line 555
static unsigned int fstReaderVarint32WithSkip(struct _IO_FILE *f, unsigned int *skiplen);
// fstReaderVarint64
// file ./../../src/helpers/fst/fstapi.c line 585
static unsigned long int fstReaderVarint64(struct _IO_FILE *f);
// fstRealpath
// file ./../../src/helpers/fst/fstapi.c line 279
static char * fstRealpath(const char *path, char *resolved_path);
// fstUtilityBinToEsc
// file ./../../src/helpers/fst/fstapi.c line 6439
signed int fstUtilityBinToEsc(unsigned char *d, unsigned char *s, signed int len);
// fstUtilityEscToBin
// file ./../../src/helpers/fst/fstapi.c line 6484
signed int fstUtilityEscToBin(unsigned char *d, unsigned char *s, signed int len);
// fstVcdID
// file ./../../src/helpers/fst/fstapi.c line 3568
static void fstVcdID(char *buf, unsigned int value);
// fstVcdIDForFwrite
// file ./../../src/helpers/fst/fstapi.c line 3583
static signed int fstVcdIDForFwrite(char *buf, unsigned int value);
// fstWriterClose
// file ./../../src/helpers/fst/fstapi.c line 1857
void fstWriterClose(void *ctx);
// fstWriterCreate
// file ./../../src/helpers/fst/fstapi.c line 1105
void * fstWriterCreate(const char *nam, signed int use_compressed_hier);
// fstWriterCreateMmaps
// file ./../../src/helpers/fst/fstapi.c line 949
static void fstWriterCreateMmaps(struct fstWriterContext *xc);
// fstWriterCreateVar
// file ./../../src/helpers/fst/fstapi.c line 2536
unsigned int fstWriterCreateVar(void *ctx, enum fstVarType vt, enum fstVarDir vd, unsigned int len, const char *nam, unsigned int aliasHandle);
// fstWriterCreateVar2
// file ./../../src/helpers/fst/fstapi.c line 2527
unsigned int fstWriterCreateVar2(void *ctx, enum fstVarType vt, enum fstVarDir vd, unsigned int len, const char *nam, unsigned int aliasHandle, const char *type, enum fstSupplementalVarType svt, enum fstSupplementalDataType sdt);
// fstWriterEmitDumpActive
// file ./../../src/helpers/fst/fstapi.c line 2944
void fstWriterEmitDumpActive(void *ctx, signed int enable);
// fstWriterEmitHdrBytes
// file ./../../src/helpers/fst/fstapi.c line 881
static void fstWriterEmitHdrBytes(struct fstWriterContext *xc);
// fstWriterEmitSectionHeader
// file ./../../src/helpers/fst/fstapi.c line 1170
static void fstWriterEmitSectionHeader(void *ctx);
// fstWriterEmitTimeChange
// file ./../../src/helpers/fst/fstapi.c line 2889
void fstWriterEmitTimeChange(void *ctx, unsigned long int tim);
// fstWriterEmitValueChange
// file ./../../src/helpers/fst/fstapi.c line 2728
void fstWriterEmitValueChange(void *ctx, unsigned int handle, const void *val);
// fstWriterEmitVariableLengthValueChange
// file ./../../src/helpers/fst/fstapi.c line 2846
void fstWriterEmitVariableLengthValueChange(void *ctx, unsigned int handle, const void *val, unsigned int len);
// fstWriterFlushContext
// file ./../../src/helpers/fst/fstapi.c line 1841
void fstWriterFlushContext(void *ctx);
// fstWriterFlushContextPrivate
// file ./../../src/helpers/fst/fstapi.c line 1776
static void fstWriterFlushContextPrivate(void *ctx);
// fstWriterFlushContextPrivate1
// file ./../../src/helpers/fst/fstapi.c line 1756
static void * fstWriterFlushContextPrivate1(void *ctx);
// fstWriterFlushContextPrivate2
// file ./../../src/helpers/fst/fstapi.c line 1225
static void fstWriterFlushContextPrivate2(void *ctx);
// fstWriterFseeko
// file ./../../src/helpers/fst/fstapi.c line 797
static signed int fstWriterFseeko(struct fstWriterContext *xc, struct _IO_FILE *stream, signed long int offset, signed int whence);
// fstWriterGetDumpSizeLimitReached
// file ./../../src/helpers/fst/fstapi.c line 2498
signed int fstWriterGetDumpSizeLimitReached(void *ctx);
// fstWriterGetFseekFailed
// file ./../../src/helpers/fst/fstapi.c line 2510
signed int fstWriterGetFseekFailed(void *ctx);
// fstWriterSVarint
// file ./../../src/helpers/fst/fstapi.c line 662
static signed int fstWriterSVarint(struct _IO_FILE *handle, signed long int v);
// fstWriterSetAttrBegin
// file ./../../src/helpers/fst/fstapi.c line 2677
void fstWriterSetAttrBegin(void *ctx, enum fstAttrType attrtype, signed int subtype, const char *attrname, unsigned long int arg);
// fstWriterSetAttrDoubleArgGeneric
// file ./../../src/helpers/fst/fstapi.c line 2254
static void fstWriterSetAttrDoubleArgGeneric(void *ctx, signed int typ, unsigned long int arg1, unsigned long int arg2);
// fstWriterSetAttrEnd
// file ./../../src/helpers/fst/fstapi.c line 2713
void fstWriterSetAttrEnd(void *ctx);
// fstWriterSetAttrGeneric
// file ./../../src/helpers/fst/fstapi.c line 2271
static void fstWriterSetAttrGeneric(void *ctx, const char *comm, signed int typ, unsigned long int arg);
// fstWriterSetComment
// file ./../../src/helpers/fst/fstapi.c line 2359
void fstWriterSetComment(void *ctx, const char *comm);
// fstWriterSetDate
// file ./../../src/helpers/fst/fstapi.c line 2196
void fstWriterSetDate(void *ctx, const char *dat);
// fstWriterSetDumpSizeLimit
// file ./../../src/helpers/fst/fstapi.c line 2488
void fstWriterSetDumpSizeLimit(void *ctx, unsigned long int numbytes);
// fstWriterSetEnvVar
// file ./../../src/helpers/fst/fstapi.c line 2371
void fstWriterSetEnvVar(void *ctx, const char *envvar);
// fstWriterSetFileType
// file ./../../src/helpers/fst/fstapi.c line 2234
void fstWriterSetFileType(void *ctx, enum fstFileType filetype);
// fstWriterSetPackType
// file ./../../src/helpers/fst/fstapi.c line 2449
void fstWriterSetPackType(void *ctx, enum fstWriterPackType typ);
// fstWriterSetParallelMode
// file ./../../src/helpers/fst/fstapi.c line 2470
void fstWriterSetParallelMode(void *ctx, signed int enable);
// fstWriterSetRepackOnClose
// file ./../../src/helpers/fst/fstapi.c line 2460
void fstWriterSetRepackOnClose(void *ctx, signed int enable);
// fstWriterSetScope
// file ./../../src/helpers/fst/fstapi.c line 2636
void fstWriterSetScope(void *ctx, enum fstScopeType scopetype, const char *scopename, const char *scopecomp);
// fstWriterSetSourceInstantiationStem
// file ./../../src/helpers/fst/fstapi.c line 2353
void fstWriterSetSourceInstantiationStem(void *ctx, const char *path, unsigned int line, unsigned int use_realpath);
// fstWriterSetSourceStem
// file ./../../src/helpers/fst/fstapi.c line 2347
void fstWriterSetSourceStem(void *ctx, const char *path, unsigned int line, unsigned int use_realpath);
// fstWriterSetSourceStem_2
// file ./../../src/helpers/fst/fstapi.c line 2291
static void fstWriterSetSourceStem_2(void *ctx, const char *path, unsigned int line, unsigned int use_realpath, signed int typ);
// fstWriterSetTimescale
// file ./../../src/helpers/fst/fstapi.c line 2377
void fstWriterSetTimescale(void *ctx, signed int ts);
// fstWriterSetTimescaleFromString
// file ./../../src/helpers/fst/fstapi.c line 2391
void fstWriterSetTimescaleFromString(void *ctx, const char *s);
// fstWriterSetTimezero
// file ./../../src/helpers/fst/fstapi.c line 2435
void fstWriterSetTimezero(void *ctx, signed long int tim);
// fstWriterSetUpscope
// file ./../../src/helpers/fst/fstapi.c line 2665
void fstWriterSetUpscope(void *ctx);
// fstWriterSetValueList
// file ./../../src/helpers/fst/fstapi.c line 2365
void fstWriterSetValueList(void *ctx, const char *vl);
// fstWriterSetVersion
// file ./../../src/helpers/fst/fstapi.c line 2215
void fstWriterSetVersion(void *ctx, const char *vers);
// fstWriterUint32WithVarint32
// file ./../../src/helpers/fst/fstapi.c line 814
static unsigned int fstWriterUint32WithVarint32(struct fstWriterContext *xc, unsigned int *u, unsigned int v, const void *dbuf, unsigned int siz);
// fstWriterUint32WithVarint32AndLength
// file ./../../src/helpers/fst/fstapi.c line 841
static unsigned int fstWriterUint32WithVarint32AndLength(struct fstWriterContext *xc, unsigned int *u, unsigned int v, const void *dbuf, unsigned int siz);
// fstWriterUint64
// file ./../../src/helpers/fst/fstapi.c line 363
static signed int fstWriterUint64(struct _IO_FILE *handle, unsigned long int v);
// fstWriterVarint
// file ./../../src/helpers/fst/fstapi.c line 614
static signed int fstWriterVarint(struct _IO_FILE *handle, unsigned long int v);
// fstWritex
// file ./../../src/helpers/fst/fstapi.c line 3130
static void fstWritex(struct fstReaderContext *xc, void *v, signed int len);
// fst_alpha_strcmpeq
// file logfile.c line 730
signed int fst_alpha_strcmpeq(const char *s1, const char *s2);
// ftello
// file /usr/include/stdio.h line 778
extern signed long int ftello(struct _IO_FILE *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_utf8_strlen
// file /usr/include/glib-2.0/glib/gunicode.h line 717
extern signed long int g_utf8_strlen(const char *, signed long int);
// gdk_drag_status
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 128
void gdk_drag_status(struct _GdkDragContext *, enum anonymous_37, unsigned int);
// gdk_window_raise
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 377
void gdk_window_raise(struct _GdkDrawable *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gtk_adjustment_get_page_increment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 104
double gtk_adjustment_get_page_increment(struct _GtkAdjustment *);
// gtk_adjustment_get_step_increment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 101
double gtk_adjustment_get_step_increment(struct _GtkAdjustment *);
// gtk_adjustment_get_type
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 78
unsigned long int gtk_adjustment_get_type(void);
// gtk_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 104
unsigned long int gtk_box_get_type(void);
// gtk_box_pack_start
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 109
void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 91
unsigned long int gtk_button_get_type(void);
// gtk_button_new
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 92
struct _GtkWidget * gtk_button_new(void);
// gtk_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 93
struct _GtkWidget * gtk_button_new_with_label(const char *);
// gtk_button_set_focus_on_click
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 118
void gtk_button_set_focus_on_click(struct _GtkButton *, signed int);
// gtk_button_set_relief
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 106
void gtk_button_set_relief(struct _GtkButton *, enum anonymous_68);
// gtk_check_button_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkcheckbutton.h line 73
struct _GtkWidget * gtk_check_button_new_with_label(const char *);
// gtk_clist_clear
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 733
void gtk_clist_clear(struct _GtkCList *);
// gtk_clist_freeze
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 481
void gtk_clist_freeze(struct _GtkCList *);
// gtk_clist_get_row_data
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 708
void * gtk_clist_get_row_data(struct _GtkCList *, signed int);
// gtk_clist_get_type
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 443
unsigned long int gtk_clist_get_type(void);
// gtk_clist_set_column_auto_resize
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 533
void gtk_clist_set_column_auto_resize(struct _GtkCList *, signed int, signed int);
// gtk_clist_thaw
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 482
void gtk_clist_thaw(struct _GtkCList *);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_ctree_get_type
// file /usr/include/gtk-2.0/gtk/gtkctree.h line 175
unsigned long int gtk_ctree_get_type(void);
// gtk_ctree_insert_node
// file /usr/include/gtk-2.0/gtk/gtkctree.h line 181
struct _GtkCTreeNode * gtk_ctree_insert_node(struct _GtkCTree *, struct _GtkCTreeNode *, struct _GtkCTreeNode *, char **, unsigned char, struct _GdkDrawable *, struct _GdkDrawable *, struct _GdkDrawable *, struct _GdkDrawable *, signed int, signed int);
// gtk_ctree_new
// file /usr/include/gtk-2.0/gtk/gtkctree.h line 179
struct _GtkWidget * gtk_ctree_new(signed int, signed int);
// gtk_ctree_node_set_row_data
// file /usr/include/gtk-2.0/gtk/gtkctree.h line 389
void gtk_ctree_node_set_row_data(struct _GtkCTree *, struct _GtkCTreeNode *, void *);
// gtk_drag_dest_set
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 74
void gtk_drag_dest_set(struct _GtkWidget *, enum anonymous_11, const struct _GtkTargetEntry *, signed int, enum anonymous_37);
// gtk_drag_get_source_widget
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 69
struct _GtkWidget * gtk_drag_get_source_widget(struct _GdkDragContext *);
// gtk_drag_source_set
// file /usr/include/gtk-2.0/gtk/gtkdnd.h line 103
void gtk_drag_source_set(struct _GtkWidget *, enum anonymous_36, const struct _GtkTargetEntry *, signed int, enum anonymous_37);
// gtk_entry_get_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 216
const char * gtk_entry_get_text(struct _GtkEntry *);
// gtk_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 166
unsigned long int gtk_entry_get_type(void);
// gtk_entry_new
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 167
struct _GtkWidget * gtk_entry_new(void);
// gtk_hbox_new
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 63
struct _GtkWidget * gtk_hbox_new(signed int, signed int);
// gtk_hpaned_new
// file /usr/include/gtk-2.0/gtk/gtkhpaned.h line 61
struct _GtkWidget * gtk_hpaned_new(void);
// gtk_hseparator_new
// file /usr/include/gtk-2.0/gtk/gtkhseparator.h line 63
struct _GtkWidget * gtk_hseparator_new(void);
// gtk_image_new_from_stock
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 199
struct _GtkWidget * gtk_image_new_from_stock(const char *, enum anonymous_61);
// gtk_init_check
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 97
signed int gtk_init_check(signed int *, char ***);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_notebook_append_page_menu
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 156
signed int gtk_notebook_append_page_menu(struct _GtkNotebook *, struct _GtkWidget *, struct _GtkWidget *, struct _GtkWidget *);
// gtk_notebook_get_type
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 151
unsigned long int gtk_notebook_get_type(void);
// gtk_notebook_new
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 152
struct _GtkWidget * gtk_notebook_new(void);
// gtk_notebook_popup_enable
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 251
void gtk_notebook_popup_enable(struct _GtkNotebook *);
// gtk_notebook_set_current_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 211
void gtk_notebook_set_current_page(struct _GtkNotebook *, signed int);
// gtk_notebook_set_scrollable
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 241
void gtk_notebook_set_scrollable(struct _GtkNotebook *, signed int);
// gtk_notebook_set_show_border
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 220
void gtk_notebook_set_show_border(struct _GtkNotebook *, signed int);
// gtk_notebook_set_show_tabs
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 223
void gtk_notebook_set_show_tabs(struct _GtkNotebook *, signed int);
// gtk_notebook_set_tab_pos
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 226
void gtk_notebook_set_tab_pos(struct _GtkNotebook *, enum anonymous_18);
// gtk_object_get_type
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 146
unsigned long int gtk_object_get_type(void);
// gtk_paned_get_type
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 109
unsigned long int gtk_paned_get_type(void);
// gtk_paned_pack1
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 114
void gtk_paned_pack1(struct _GtkPaned *, struct _GtkWidget *, signed int, signed int);
// gtk_paned_pack2
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 118
void gtk_paned_pack2(struct _GtkPaned *, struct _GtkWidget *, signed int, signed int);
// gtk_rc_style_new
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 173
struct _GtkRcStyle * gtk_rc_style_new(void);
// gtk_rc_style_unref
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 178
void gtk_rc_style_unref(struct _GtkRcStyle *);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_new
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 103
struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 113
void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous_19, enum anonymous_19);
// gtk_selection_data_set
// file /usr/include/gtk-2.0/gtk/gtkselection.h line 159
void gtk_selection_data_set(struct _GtkSelectionData *, struct _GdkAtom *, signed int, const unsigned char *, signed int);
// gtk_signal_connect_full
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 121
unsigned long int gtk_signal_connect_full(struct _GtkObject *, const char *, void (*)(void), void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *), void *, void (*)(void *), signed int, signed int);
// gtk_signal_emit_by_name
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 135
void gtk_signal_emit_by_name(struct _GtkObject *, const char *, ...);
// gtk_table_attach
// file /usr/include/gtk-2.0/gtk/gtktable.h line 109
void gtk_table_attach(struct _GtkTable *, struct _GtkWidget *, unsigned int, unsigned int, unsigned int, unsigned int, enum anonymous_63, enum anonymous_63, unsigned int, unsigned int);
// gtk_table_get_type
// file /usr/include/gtk-2.0/gtk/gtktable.h line 102
unsigned long int gtk_table_get_type(void);
// gtk_table_new
// file /usr/include/gtk-2.0/gtk/gtktable.h line 103
struct _GtkWidget * gtk_table_new(unsigned int, unsigned int, signed int);
// gtk_text_buffer_create_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 314
struct _GtkTextTag * gtk_text_buffer_create_tag(struct _GtkTextBuffer *, const char *, const char *, ...);
// gtk_text_buffer_delete
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 218
void gtk_text_buffer_delete(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_get_end_iter
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 338
void gtk_text_buffer_get_end_iter(struct _GtkTextBuffer *, struct _GtkTextIter *);
// gtk_text_buffer_get_insert
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 277
struct _GtkTextMark * gtk_text_buffer_get_insert(struct _GtkTextBuffer *);
// gtk_text_buffer_get_iter_at_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 343
void gtk_text_buffer_get_iter_at_mark(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextMark *);
// gtk_text_buffer_get_selection_bounds
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 381
signed int gtk_text_buffer_get_selection_bounds(struct _GtkTextBuffer *, struct _GtkTextIter *, struct _GtkTextIter *);
// gtk_text_buffer_get_start_iter
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 336
void gtk_text_buffer_get_start_iter(struct _GtkTextBuffer *, struct _GtkTextIter *);
// gtk_text_buffer_get_text
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 231
char * gtk_text_buffer_get_text(struct _GtkTextBuffer *, const struct _GtkTextIter *, const struct _GtkTextIter *, signed int);
// gtk_text_buffer_insert_with_tags
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 203
void gtk_text_buffer_insert_with_tags(struct _GtkTextBuffer *, struct _GtkTextIter *, const char *, signed int, struct _GtkTextTag *, ...);
// gtk_text_buffer_place_cursor
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 281
void gtk_text_buffer_place_cursor(struct _GtkTextBuffer *, const struct _GtkTextIter *);
// gtk_text_buffer_select_range
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 283
void gtk_text_buffer_select_range(struct _GtkTextBuffer *, const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_backward_char
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 178
signed int gtk_text_iter_backward_char(struct _GtkTextIter *);
// gtk_text_iter_backward_search
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 280
signed int gtk_text_iter_backward_search(const struct _GtkTextIter *, const char *, enum anonymous_0, struct _GtkTextIter *, struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_compare
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 293
signed int gtk_text_iter_compare(const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_equal
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 291
signed int gtk_text_iter_equal(const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_forward_char
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 177
signed int gtk_text_iter_forward_char(struct _GtkTextIter *);
// gtk_text_iter_forward_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 183
signed int gtk_text_iter_forward_line(struct _GtkTextIter *);
// gtk_text_iter_forward_search
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 273
signed int gtk_text_iter_forward_search(const struct _GtkTextIter *, const char *, enum anonymous_0, struct _GtkTextIter *, struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_get_char
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 108
unsigned int gtk_text_iter_get_char(const struct _GtkTextIter *);
// gtk_text_iter_get_chars_in_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 164
signed int gtk_text_iter_get_chars_in_line(const struct _GtkTextIter *);
// gtk_text_iter_get_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 97
signed int gtk_text_iter_get_line(const struct _GtkTextIter *);
// gtk_text_iter_get_line_offset
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 98
signed int gtk_text_iter_get_line_offset(const struct _GtkTextIter *);
// gtk_text_iter_get_visible_text
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 122
char * gtk_text_iter_get_visible_text(const struct _GtkTextIter *, const struct _GtkTextIter *);
// gtk_text_iter_is_start
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 171
signed int gtk_text_iter_is_start(const struct _GtkTextIter *);
// gtk_text_iter_set_line
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 238
void gtk_text_iter_set_line(struct _GtkTextIter *, signed int);
// gtk_text_iter_set_line_offset
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 240
void gtk_text_iter_set_line_offset(struct _GtkTextIter *, signed int);
// gtk_text_view_get_buffer
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 222
struct _GtkTextBuffer * gtk_text_view_get_buffer(struct _GtkTextView *);
// gtk_text_view_get_iter_at_position
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 254
void gtk_text_view_get_iter_at_position(struct _GtkTextView *, struct _GtkTextIter *, signed int *, signed int, signed int);
// gtk_text_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 217
unsigned long int gtk_text_view_get_type(void);
// gtk_text_view_new
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 218
struct _GtkWidget * gtk_text_view_new(void);
// gtk_text_view_scroll_to_iter
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 223
signed int gtk_text_view_scroll_to_iter(struct _GtkTextView *, struct _GtkTextIter *, double, signed int, double, double);
// gtk_text_view_set_editable
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 337
void gtk_text_view_set_editable(struct _GtkTextView *, signed int);
// gtk_text_view_set_wrap_mode
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 334
void gtk_text_view_set_wrap_mode(struct _GtkTextView *, enum anonymous_31);
// gtk_text_view_window_to_buffer_coords
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 275
void gtk_text_view_window_to_buffer_coords(struct _GtkTextView *, enum anonymous_34, signed int, signed int, signed int *, signed int *);
// gtk_toggle_button_get_type
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 74
unsigned long int gtk_toggle_button_get_type(void);
// gtk_toggle_button_set_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 82
void gtk_toggle_button_set_active(struct _GtkToggleButton *, signed int);
// gtk_toolbar_get_type
// file /usr/include/gtk-2.0/gtk/gtktoolbar.h line 141
unsigned long int gtk_toolbar_get_type(void);
// gtk_toolbar_insert_stock
// file /usr/include/gtk-2.0/gtk/gtktoolbar.h line 221
struct _GtkWidget * gtk_toolbar_insert_stock(struct _GtkToolbar *, const char *, const char *, const char *, void (*)(void), void *, signed int);
// gtk_toolbar_new
// file /usr/include/gtk-2.0/gtk/gtktoolbar.h line 142
struct _GtkWidget * gtk_toolbar_new(void);
// gtk_toolbar_set_style
// file /usr/include/gtk-2.0/gtk/gtktoolbar.h line 159
void gtk_toolbar_set_style(struct _GtkToolbar *, enum anonymous_60);
// gtk_vbox_new
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 63
struct _GtkWidget * gtk_vbox_new(signed int, signed int);
// gtk_vscrollbar_new
// file /usr/include/gtk-2.0/gtk/gtkvscrollbar.h line 70
struct _GtkWidget * gtk_vscrollbar_new(struct _GtkAdjustment *);
// gtk_widget_destroy
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 837
void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_get_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1141
struct _GtkStyle * gtk_widget_get_style(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_grab_default
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 948
void gtk_widget_grab_default(struct _GtkWidget *);
// gtk_widget_modify_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1143
void gtk_widget_modify_style(struct _GtkWidget *, struct _GtkRcStyle *);
// gtk_widget_set_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1138
void gtk_widget_set_style(struct _GtkWidget *, struct _GtkStyle *);
// gtk_widget_set_usize
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1037
void gtk_widget_set_usize(struct _GtkWidget *, signed int, signed int);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous_70);
// gtk_window_set_default_size
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 367
void gtk_window_set_default_size(struct _GtkWindow *, signed int, signed int);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// gzclose
// file /usr/include/zlib.h line 1511
extern signed int gzclose(struct gzFile_s *);
// gzdopen
// file /usr/include/zlib.h line 1264
extern struct gzFile_s * gzdopen(signed int, const char *);
// gzread
// file /usr/include/zlib.h line 1313
extern signed int gzread(struct gzFile_s *, void *, unsigned int);
// gzwrite
// file /usr/include/zlib.h line 1341
extern signed int gzwrite(struct gzFile_s *, const void *, unsigned int);
// hexify
// file logfile.c line 640
static char * hexify(char *s);
// import_doubleclick
// file logfile.c line 1132
static void import_doubleclick(struct _GtkWidget *text, char *s);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// insert
// file jrb.c line 51
static void insert(struct jrb_node *item, struct jrb_node *list);
// is_big_endian
// file ./../../src/helpers/vzt_read.c line 41
static signed int is_big_endian(void);
// is_builtin_define
// file vlex.h line 28
const char * is_builtin_define(const char *, unsigned int);
// is_identifier
// file logfile.c line 632
static signed int is_identifier(char ch);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// iter_backward_search_caseins
// file logfile.c line 338
static signed int iter_backward_search_caseins(const struct _GtkTextIter *iter, char *str, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end);
// iter_forward_search_caseins
// file logfile.c line 198
static signed int iter_forward_search_caseins(const struct _GtkTextIter *iter, char *str, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end);
// jrb_delete_node
// file jrb.c line 403
extern void jrb_delete_node(struct jrb_node *n);
// jrb_find_gen
// file jrb.c line 272
extern struct jrb_node * jrb_find_gen(struct jrb_node *n, union anonymous_26 key, signed int (*fxn)(union anonymous_26, union anonymous_26));
// jrb_find_gen::fxn_object
//
signed int fxn_object(union anonymous_26, union anonymous_26);
// jrb_find_gte_gen
// file jrb.c line 244
extern struct jrb_node * jrb_find_gte_gen(struct jrb_node *n, union anonymous_26 key, signed int (*fxn)(union anonymous_26, union anonymous_26), signed int *fnd);
// jrb_find_gte_gen::fxn_object
//
signed int fxn_object(union anonymous_26, union anonymous_26);
// jrb_find_gte_int
// file jrb.c line 178
extern struct jrb_node * jrb_find_gte_int(struct jrb_node *n, signed int ikey, signed int *fnd);
// jrb_find_gte_str
// file jrb.c line 142
extern struct jrb_node * jrb_find_gte_str(struct jrb_node *n, char *key, signed int *fnd);
// jrb_find_gte_vptr
// file jrb.c line 211
extern struct jrb_node * jrb_find_gte_vptr(struct jrb_node *n, void *vkey, signed int *fnd);
// jrb_find_int
// file jrb.h line 66
extern struct jrb_node * jrb_find_int(struct jrb_node *n, signed int ikey);
// jrb_find_str
// file jrb.h line 65
extern struct jrb_node * jrb_find_str(struct jrb_node *n, char *key);
// jrb_find_vptr
// file jrb.c line 235
extern struct jrb_node * jrb_find_vptr(struct jrb_node *n, void *vkey);
// jrb_free_tree
// file jrb.h line 88
extern void jrb_free_tree(struct jrb_node *n);
// jrb_insert_b
// file jrb.c line 281
static struct jrb_node * jrb_insert_b(struct jrb_node *n, union anonymous_26 key, union anonymous_26 val);
// jrb_insert_gen
// file jrb.c line 601
extern struct jrb_node * jrb_insert_gen(struct jrb_node *tree, union anonymous_26 key, union anonymous_26 val, signed int (*func)(union anonymous_26, union anonymous_26));

//

// jrb_insert_int
// file jrb.h line 58
extern struct jrb_node * jrb_insert_int(struct jrb_node *tree, signed int ikey, union anonymous_26 val);
// jrb_insert_str
// file jrb.h line 57
extern struct jrb_node * jrb_insert_str(struct jrb_node *tree, char *key, union anonymous_26 val);
// jrb_insert_vptr
// file jrb.c line 592
extern struct jrb_node * jrb_insert_vptr(struct jrb_node *tree, void *vkey, union anonymous_26 val);
// jrb_nblack
// file jrb.c line 524
extern signed int jrb_nblack(struct jrb_node *n);
// jrb_plength
// file jrb.c line 540
signed int jrb_plength(struct jrb_node *n);
// jrb_val
// file jrb.c line 569
extern union anonymous_26 jrb_val(struct jrb_node *n);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// log_realize_text
// file logfile.c line 1096
static void log_realize_text(struct _GtkWidget *text, void *data);
// log_text
// file logfile.c line 1047
void log_text(struct _GtkWidget *text, struct _GdkFont *font, char *str);
// log_text_active
// file logfile.c line 1071
void log_text_active(struct _GtkWidget *text, struct _GdkFont *font, char *str);
// log_text_bold
// file logfile.c line 1059
void log_text_bold(struct _GtkWidget *text, struct _GdkFont *font, char *str);
// log_text_prelight
// file logfile.c line 1083
void log_text_prelight(struct _GtkWidget *text, struct _GdkFont *font, char *str);
// lprev
// file jrb.c line 109
static struct jrb_node * lprev(struct jrb_node *n);
// lx2_iter_fn
// file logfile.c line 1108
static void lx2_iter_fn(struct lxt2_rd_trace **lt, unsigned long int *pnt_time, unsigned int *pnt_facidx, char **pnt_value);
// lxt2_rd_build_radix
// file ./../../src/helpers/lxt2_read.c line 474
static void lxt2_rd_build_radix(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b, signed int granule, unsigned int strtfac, unsigned int endfac);
// lxt2_rd_close
// file ./../../src/helpers/lxt2_read.c line 1027
void lxt2_rd_close(struct lxt2_rd_trace *lt);
// lxt2_rd_clr_fac_process_mask_all
// file ../../src/helpers/lxt2_read.h line 292
signed int lxt2_rd_clr_fac_process_mask_all(struct lxt2_rd_trace *);
// lxt2_rd_expand_bits_to_integer
// file ./../../src/helpers/lxt2_read.c line 154
unsigned int lxt2_rd_expand_bits_to_integer(signed int len, char *s);
// lxt2_rd_expand_integer_to_bits
// file ./../../src/helpers/lxt2_read.c line 137
static char * lxt2_rd_expand_integer_to_bits(signed int len, unsigned int value);
// lxt2_rd_get_16
// file ./../../src/helpers/lxt2_read.c line 53
static unsigned int lxt2_rd_get_16(void *mm, signed int offset);
// lxt2_rd_get_24
// file ./../../src/helpers/lxt2_read.c line 61
static unsigned int lxt2_rd_get_24(void *mm, signed int offset);
// lxt2_rd_get_32
// file ./../../src/helpers/lxt2_read.c line 70
static unsigned int lxt2_rd_get_32(void *mm, signed int offset);
// lxt2_rd_get_64
// file ./../../src/helpers/lxt2_read.c line 80
static unsigned long int lxt2_rd_get_64(void *mm, signed int offset);
// lxt2_rd_get_alias_root
// file ../../src/helpers/lxt2_read.h line 281
unsigned int lxt2_rd_get_alias_root(struct lxt2_rd_trace *, unsigned int);
// lxt2_rd_get_fac_geometry
// file ./../../src/helpers/lxt2_read.c line 1103
struct lxt2_rd_geometry * lxt2_rd_get_fac_geometry(struct lxt2_rd_trace *lt, unsigned int facidx);
// lxt2_rd_get_facname
// file ../../src/helpers/lxt2_read.h line 274
char * lxt2_rd_get_facname(struct lxt2_rd_trace *lt, unsigned int facidx);
// lxt2_rd_get_num_active_blocks
// file ./../../src/helpers/lxt2_read.c line 1431
unsigned int lxt2_rd_get_num_active_blocks(struct lxt2_rd_trace *lt);
// lxt2_rd_get_num_facs
// file ../../src/helpers/lxt2_read.h line 273
unsigned int lxt2_rd_get_num_facs(struct lxt2_rd_trace *);
// lxt2_rd_init
// file ../../src/helpers/lxt2_read.h line 265
struct lxt2_rd_trace * lxt2_rd_init(const char *name);
// lxt2_rd_iter_blocks
// file ../../src/helpers/lxt2_read.h line 295
signed int lxt2_rd_iter_blocks(struct lxt2_rd_trace *lt, void (*value_change_callback)(struct lxt2_rd_trace **, unsigned long int *, unsigned int *, char **), void *user_callback_data_pointer);

//

// lxt2_rd_iter_radix
// file ./../../src/helpers/lxt2_read.c line 175
void lxt2_rd_iter_radix(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b);
// lxt2_rd_iter_radix0
// file ./../../src/helpers/lxt2_read.c line 298
void lxt2_rd_iter_radix0(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b, unsigned int idx);
// lxt2_rd_limit_time_range
// file ../../src/helpers/lxt2_read.h line 301
unsigned int lxt2_rd_limit_time_range(struct lxt2_rd_trace *lt, unsigned long int strt_time, unsigned long int end_time);
// lxt2_rd_null_callback
// file ./../../src/helpers/lxt2_read.c line 746
void lxt2_rd_null_callback(struct lxt2_rd_trace **lt, unsigned long int *pnt_time, unsigned int *pnt_facidx, char **pnt_value);
// lxt2_rd_ones_cnt
// file ./../../src/helpers/lxt2_read.c line 98
static inline unsigned long int lxt2_rd_ones_cnt(unsigned long int x);
// lxt2_rd_process_block
// file ./../../src/helpers/lxt2_read.c line 560
signed int lxt2_rd_process_block(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b);
// lxt2_rd_regenerate_process_mask
// file ./../../src/helpers/lxt2_read.c line 516
static void lxt2_rd_regenerate_process_mask(struct lxt2_rd_trace *lt);
// lxt2_rd_set_fac_process_mask
// file ../../src/helpers/lxt2_read.h line 289
signed int lxt2_rd_set_fac_process_mask(struct lxt2_rd_trace *, unsigned int);
// lxt2_rd_tzc
// file ./../../src/helpers/lxt2_read.c line 127
static inline unsigned long int lxt2_rd_tzc(unsigned long int x);
// lxt2_rd_unlimit_time_range
// file ../../src/helpers/lxt2_read.h line 302
unsigned int lxt2_rd_unlimit_time_range(struct lxt2_rd_trace *lt);
// lzma_alone_decoder
// file /usr/include/lzma/container.h line 377
extern enum anonymous_8 lzma_alone_decoder(struct anonymous_7 *, unsigned long int);
// lzma_alone_encoder
// file /usr/include/lzma/container.h line 213
extern enum anonymous_8 lzma_alone_encoder(struct anonymous_7 *, const struct anonymous_5 *);
// lzma_code
// file /usr/include/lzma/base.h line 537
extern enum anonymous_8 lzma_code(struct anonymous_7 *, enum anonymous_10);
// lzma_end
// file /usr/include/lzma/base.h line 554
extern void lzma_end(struct anonymous_7 *);
// lzma_lzma_preset
// file /usr/include/lzma/lzma.h line 419
extern unsigned char lzma_lzma_preset(struct anonymous_5 *, unsigned int);
// main_2r
// file stem_recurse.c line 238
signed int main_2r(signed int argc, char **argv);
// make_jrb
// file jrb.h line 50
extern struct jrb_node * make_jrb(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mk_new_int
// file jrb.c line 78
static void mk_new_int(struct jrb_node *l, struct jrb_node *r, struct jrb_node *p, signed int il);
// mkstemp
// file /usr/include/stdlib.h line 619
extern signed int mkstemp(char *);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// ok_callback
// file logfile.c line 1443
static void ok_callback(struct _GtkWidget *widget, struct logfile_context_t *ctx);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// press_callback
// file logfile.c line 506
static void press_callback(struct _GtkWidget *widget, void **data);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_9 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_9 *, const union anonymous_58 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_9 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_9 *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_insert_position
// file logfile.c line 145
void read_insert_position(struct text_find_t *tr);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// rec_tree
// file stem_recurse.c line 201
void rec_tree(struct ds_tree_node *t, signed int *cnt);
// rec_tree_populate
// file stem_recurse.c line 218
void rec_tree_populate(struct ds_tree_node *t, signed int *cnt, struct ds_tree_node **list_root);
// recolor
// file jrb.c line 314
static void recolor(struct jrb_node *n);
// recurse_into_modules
// file stem_recurse.c line 102
struct _GtkCTreeNode * recurse_into_modules(char *compname_build, char *compname, struct ds_tree_node *t, signed int depth, struct _GtkCTreeNode *subtree, struct _GtkCTreeNode *sibling);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// rprev
// file jrb.c line 119
static struct jrb_node * rprev(struct jrb_node *n);
// scroll_event
// file logfile.c line 1319
static signed int scroll_event(struct _GtkWidget *widget, struct _GdkEventScroll *event, void *text);
// search_backward
// file logfile.c line 453
static void search_backward(struct _GtkWidget *widget, void *data);
// search_forward
// file logfile.c line 462
static void search_forward(struct _GtkWidget *widget, void *data);
// select_row_callback
// file tree_widget.c line 32
static void select_row_callback(struct _GtkWidget *widget, signed int row, signed int column, struct _GdkEventButton *event, void *data);
// set_insert_position
// file logfile.c line 157
void set_insert_position(struct text_find_t *tr);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// setup_dnd
// file tcl_helper.c line 840
void setup_dnd(struct _GtkWidget *wid);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// single_rotate
// file jrb.c line 359
static void single_rotate(struct jrb_node *y, signed int l);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// tclBackslash
// file tcl_helper.c line 40
static char tclBackslash(const char *src, signed int *readPtr);
// tclConvertElement
// file tcl_helper.c line 485
static signed int tclConvertElement(const char *src, char *dst, signed int flags);
// tclCopyAndCollapse
// file tcl_helper.c line 265
static void tclCopyAndCollapse(signed int count, const char *src, char *dst);
// tclFindElement
// file tcl_helper.c line 131
static signed int tclFindElement(const char *list, const char **elementPtr, const char **nextPtr, signed int *sizePtr, signed int *bracePtr);
// tclScanElement
// file tcl_helper.c line 406
static signed int tclScanElement(const char *string, signed int *flagPtr);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tmpfile
// file /usr/include/stdio.h line 195
extern struct _IO_FILE * tmpfile(void);
// tmpfile_close
// file ./../../src/helpers/fst/fstapi.c line 235
static void tmpfile_close(struct _IO_FILE **f, char **nam);
// tmpfile_open
// file ./../../src/helpers/fst/fstapi.c line 225
static struct _IO_FILE * tmpfile_open(char **nam);
// tmpnam_rtlbrowse
// file logfile.c line 591
static char * tmpnam_rtlbrowse(char *s, signed int *fd);
// toggle_callback
// file logfile.c line 496
static void toggle_callback(struct _GtkWidget *widget, struct _GtkWidget *nothing);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// tr_search_backward
// file logfile.c line 379
void tr_search_backward(char *str);
// tr_search_forward
// file logfile.c line 263
void tr_search_forward(char *str, signed int noskip);
// treebox
// file tree_widget.c line 102
void treebox(char *title, void (*func)(void), struct _GtkWidget *old_window);

//

// treebox_is_active
// file tree_widget.c line 74
signed int treebox_is_active(void);
// uncompress
// file /usr/include/zlib.h line 1197
extern signed int uncompress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unlink_fopen
// file ./../../src/helpers/fst/fstapi.c line 170
static struct _IO_FILE * unlink_fopen(const char *nam, const char *mode);
// unselect_row_callback
// file tree_widget.c line 61
static void unselect_row_callback(struct _GtkWidget *widget, signed int row, signed int column, struct _GdkEventButton *event, void *data);
// unsetenv
// file /usr/include/stdlib.h line 588
extern signed int unsetenv(const char *);
// update_ctx_when_idle
// file logfile.c line 1451
signed int update_ctx_when_idle(void *textview_or_dummy);
// v_preproc
// file vlex.l line 33
static signed int v_preproc(char *buf, signed int max_size);
// vzt_rd_block_vch_decode
// file ./../../src/helpers/vzt_read.c line 307
static void vzt_rd_block_vch_decode(struct vzt_rd_trace *lt, struct vzt_rd_block *b);
// vzt_rd_block_vch_free
// file ./../../src/helpers/vzt_read.c line 475
static signed int vzt_rd_block_vch_free(struct vzt_rd_trace *lt, struct vzt_rd_block *b, signed int killed);
// vzt_rd_close
// file ./../../src/helpers/vzt_read.c line 2204
void vzt_rd_close(struct vzt_rd_trace *lt);
// vzt_rd_decompress_blk
// file ./../../src/helpers/vzt_read.c line 1363
static void vzt_rd_decompress_blk(struct vzt_rd_trace *lt, struct vzt_rd_block *b, signed int reopen);
// vzt_rd_decompress_blk_pth
// file ./../../src/helpers/vzt_read.c line 1438
static void vzt_rd_decompress_blk_pth(struct vzt_rd_trace *lt, struct vzt_rd_block *b);
// vzt_rd_decompress_blk_pth_actual
// file ./../../src/helpers/vzt_read.c line 1428
static void * vzt_rd_decompress_blk_pth_actual(void *args);
// vzt_rd_det_gzip_type
// file ./../../src/helpers/vzt_read.c line 1340
static signed int vzt_rd_det_gzip_type(struct _IO_FILE *handle);
// vzt_rd_double_xdr
// file ./../../src/helpers/vzt_read.c line 673
static void vzt_rd_double_xdr(char *pnt, char *buf);
// vzt_rd_expand_bits_to_integer
// file ./../../src/helpers/vzt_read.c line 287
unsigned int vzt_rd_expand_bits_to_integer(signed int len, char *s);
// vzt_rd_fac_value
// file ./../../src/helpers/vzt_read.c line 589
signed int vzt_rd_fac_value(struct vzt_rd_trace *lt, struct vzt_rd_block *b, unsigned int time_offset, unsigned int facidx, char *value);
// vzt_rd_get_16
// file ./../../src/helpers/vzt_read.c line 135
static unsigned int vzt_rd_get_16(void *mm, signed int offset);
// vzt_rd_get_32
// file ./../../src/helpers/vzt_read.c line 143
static unsigned int vzt_rd_get_32(void *mm, signed int offset);
// vzt_rd_get_32r
// file ./../../src/helpers/vzt_read.c line 163
static unsigned int vzt_rd_get_32r(void *mm, signed int offset);
// vzt_rd_get_64
// file ./../../src/helpers/vzt_read.c line 153
static unsigned long int vzt_rd_get_64(void *mm, signed int offset);
// vzt_rd_get_alias_root
// file ../../src/helpers/vzt_read.h line 267
unsigned int vzt_rd_get_alias_root(struct vzt_rd_trace *, unsigned int);
// vzt_rd_get_alias_root_link1
// file ./../../src/helpers/vzt_read.c line 1060
static inline unsigned int vzt_rd_get_alias_root_link1(struct vzt_rd_trace *lt, unsigned int facidx);
// vzt_rd_get_block_mem_usage
// file ./../../src/helpers/vzt_read.c line 1293
unsigned long int vzt_rd_get_block_mem_usage(struct vzt_rd_trace *lt);
// vzt_rd_get_fac_geometry
// file ./../../src/helpers/vzt_read.c line 974
struct vzt_rd_geometry * vzt_rd_get_fac_geometry(struct vzt_rd_trace *lt, unsigned int facidx);
// vzt_rd_get_facname
// file ../../src/helpers/vzt_read.h line 260
char * vzt_rd_get_facname(struct vzt_rd_trace *lt, unsigned int facidx);
// vzt_rd_get_num_active_blocks
// file ./../../src/helpers/vzt_read.c line 1316
unsigned int vzt_rd_get_num_active_blocks(struct vzt_rd_trace *lt);
// vzt_rd_get_num_facs
// file ../../src/helpers/vzt_read.h line 259
unsigned int vzt_rd_get_num_facs(struct vzt_rd_trace *);
// vzt_rd_get_v32
// file ./../../src/helpers/vzt_read.c line 174
static unsigned int vzt_rd_get_v32(char **mmx);
// vzt_rd_get_v64
// file ./../../src/helpers/vzt_read.c line 205
static unsigned long int vzt_rd_get_v64(char **mmx);
// vzt_rd_init
// file ../../src/helpers/vzt_read.h line 250
struct vzt_rd_trace * vzt_rd_init(const char *name);
// vzt_rd_init_smp
// file ./../../src/helpers/vzt_read.c line 1675
struct vzt_rd_trace * vzt_rd_init_smp(const char *name, unsigned int num_cpus);
// vzt_rd_iter_blocks
// file ./../../src/helpers/vzt_read.c line 1452
signed int vzt_rd_iter_blocks(struct vzt_rd_trace *lt, void (*value_change_callback)(struct vzt_rd_trace **, unsigned long int *, unsigned int *, char **), void *user_callback_data_pointer);

//

// vzt_rd_limit_time_range
// file ./../../src/helpers/vzt_read.c line 1571
unsigned int vzt_rd_limit_time_range(struct vzt_rd_trace *lt, unsigned long int strt_time, unsigned long int end_time);
// vzt_rd_make_sindex
// file ./../../src/helpers/vzt_read.c line 720
static unsigned int vzt_rd_make_sindex(char *pnt);
// vzt_rd_next_value_chg_time
// file ./../../src/helpers/vzt_read.c line 500
unsigned int vzt_rd_next_value_chg_time(struct vzt_rd_trace *lt, struct vzt_rd_block *b, unsigned int time_offset, unsigned int facidx);
// vzt_rd_null_callback
// file ./../../src/helpers/vzt_read.c line 950
void vzt_rd_null_callback(struct vzt_rd_trace **lt, unsigned long int *pnt_time, unsigned int *pnt_facidx, char **pnt_value);
// vzt_rd_ones_cnt
// file ./../../src/helpers/vzt_read.c line 262
static inline unsigned int vzt_rd_ones_cnt(unsigned int x);
// vzt_rd_process_block
// file ./../../src/helpers/vzt_read.c line 805
signed int vzt_rd_process_block(struct vzt_rd_trace *lt, struct vzt_rd_block *b);
// vzt_rd_process_block_linear
// file ./../../src/helpers/vzt_read.c line 738
signed int vzt_rd_process_block_linear(struct vzt_rd_trace *lt, struct vzt_rd_block *b);
// vzt_rd_process_block_single_factime
// file ./../../src/helpers/vzt_read.c line 2260
static char * vzt_rd_process_block_single_factime(struct vzt_rd_trace *lt, struct vzt_rd_block *b, unsigned long int simtime, unsigned int idx);
// vzt_rd_process_blocks_linearly
// file ./../../src/helpers/vzt_read.c line 1661
void vzt_rd_process_blocks_linearly(struct vzt_rd_trace *lt, signed int doit);
// vzt_rd_pthread_create
// file ./../../src/helpers/vzt_read.c line 95
static inline void vzt_rd_pthread_create(struct vzt_rd_trace *lt, unsigned long int *thread, union pthread_attr_t *attr, void * (*start_routine)(void *), void *arg);
// vzt_rd_pthread_create::start_routine_object
//
void * start_routine_object(void *);
// vzt_rd_pthread_mutex_destroy
// file ./../../src/helpers/vzt_read.c line 90
static inline void vzt_rd_pthread_mutex_destroy(struct vzt_rd_trace *lt, union anonymous_9 *mutex);
// vzt_rd_pthread_mutex_init
// file ./../../src/helpers/vzt_read.c line 74
static inline signed int vzt_rd_pthread_mutex_init(struct vzt_rd_trace *lt, union anonymous_9 *mutex, const union anonymous_58 *mutexattr);
// vzt_rd_pthread_mutex_lock
// file ./../../src/helpers/vzt_read.c line 80
static inline void vzt_rd_pthread_mutex_lock(struct vzt_rd_trace *lt, union anonymous_9 *mx);
// vzt_rd_pthread_mutex_unlock
// file ./../../src/helpers/vzt_read.c line 85
static inline void vzt_rd_pthread_mutex_unlock(struct vzt_rd_trace *lt, union anonymous_9 *mx);
// vzt_rd_tzc
// file ./../../src/helpers/vzt_read.c line 277
static inline unsigned int vzt_rd_tzc(unsigned int x);
// vzt_rd_unlimit_time_range
// file ./../../src/helpers/vzt_read.c line 1633
unsigned int vzt_rd_unlimit_time_range(struct vzt_rd_trace *lt);
// vzt_rd_value
// file ../../src/helpers/vzt_read.h line 292
char * vzt_rd_value(struct vzt_rd_trace *lt, unsigned long int simtime, unsigned int idx);
// vzt_rd_vectorize
// file ./../../src/helpers/vzt_read.c line 2005
void vzt_rd_vectorize(struct vzt_rd_trace *lt);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xdr_double
// file /usr/include/rpc/xdr.h line 323
extern signed int xdr_double(struct XDR *, double *);
// xdrmem_create
// file /usr/include/rpc/xdr.h line 350
extern void xdrmem_create(struct XDR *, char *, unsigned int, enum xdr_op);
// yy_create_buffer
// file vlex.c line 2447
struct yy_buffer_state * yy_create_buffer(struct _IO_FILE *file, signed int size);
// yy_delete_buffer
// file vlex.c line 2478
void yy_delete_buffer(struct yy_buffer_state *b);
// yy_fatal_error
// file vlex.c line 2706
static void yy_fatal_error(const char *msg);
// yy_flex_alloc
// file vlex.c line 2770
static void * yy_flex_alloc(unsigned int size);
// yy_flex_free
// file vlex.c line 2798
static void yy_flex_free(void *ptr);
// yy_flex_realloc
// file vlex.c line 2780
static void * yy_flex_realloc(void *ptr, unsigned int size);
// yy_flush_buffer
// file vlex.c line 2526
void yy_flush_buffer(struct yy_buffer_state *b);
// yy_get_next_buffer
// file vlex.c line 2074
static signed int yy_get_next_buffer(void);
// yy_get_previous_state
// file vlex.c line 2206
static signed int yy_get_previous_state(void);
// yy_init_buffer
// file vlex.c line 2499
void yy_init_buffer(struct yy_buffer_state *b, struct _IO_FILE *file);
// yy_load_buffer_state
// file vlex.c line 2434
void yy_load_buffer_state(void);
// yy_scan_buffer
// file vlex.c line 2557
struct yy_buffer_state * yy_scan_buffer(char *base, unsigned int size);
// yy_scan_bytes
// file vlex.c line 2612
struct yy_buffer_state * yy_scan_bytes(const char *bytes, signed int len);
// yy_scan_string
// file vlex.c line 2595
struct yy_buffer_state * yy_scan_string(const char *yy_str);
// yy_switch_to_buffer
// file vlex.c line 2404
void yy_switch_to_buffer(struct yy_buffer_state *new_buffer);
// yy_try_NUL_trans
// file vlex.c line 2241
static signed int yy_try_NUL_trans(signed int yy_current_state);
// yylex
// file vlex.h line 24
signed int yylex(void);
// yyrestart
// file vlex.c line 2389
void yyrestart(struct _IO_FILE *input_file);
// yywrap
// file vlex.l line 24
static signed int yywrap(void);
// zMergeTclList
// file tcl_helper.c line 594
char * zMergeTclList(signed int argc, const char **argv);
// zSplitTclList
// file tcl_helper.c line 304
char ** zSplitTclList(const char *list, signed int *argcPtr);

struct anonymous_6
{
  // alloc
  void * (*alloc)(void *, unsigned long int, unsigned long int);
  // free
  void (*free)(void *, void *);
  // opaque
  void *opaque;
};

struct anonymous_52
{
  // toplevel_under_pointer
  struct _GdkDrawable *toplevel_under_pointer;
  // window_under_pointer
  struct _GdkDrawable *window_under_pointer;
  // toplevel_x
  double toplevel_x;
  // toplevel_y
  double toplevel_y;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // motion_hint_serial
  unsigned long int motion_hint_serial;
};

struct anonymous_51
{
  // window
  struct _GdkDrawable *window;
  // native_window
  struct _GdkDrawable *native_window;
  // serial
  unsigned long int serial;
  // owner_events
  signed int owner_events;
  // time
  unsigned int time;
};

struct anonymous_28
{
  // externalDict
  unsigned char *externalDict;
  // extDictSize
  unsigned long int extDictSize;
  // prefixEnd
  unsigned char *prefixEnd;
  // prefixSize
  unsigned long int prefixSize;
};

struct anonymous_71
{
  // f
  void (*f)(void);
  // d
  void *d;
};

struct anonymous_7
{
  // next_in
  const unsigned char *next_in;
  // avail_in
  unsigned long int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned long int avail_out;
  // total_out
  unsigned long int total_out;
  // allocator
  struct anonymous_6 *allocator;
  // internal
  struct lzma_internal_s *internal;
  // reserved_ptr1
  void *reserved_ptr1;
  // reserved_ptr2
  void *reserved_ptr2;
  // reserved_ptr3
  void *reserved_ptr3;
  // reserved_ptr4
  void *reserved_ptr4;
  // reserved_int1
  unsigned long int reserved_int1;
  // reserved_int2
  unsigned long int reserved_int2;
  // reserved_int3
  unsigned long int reserved_int3;
  // reserved_int4
  unsigned long int reserved_int4;
  // reserved_enum1
  enum anonymous_4 reserved_enum1;
  // reserved_enum2
  enum anonymous_4 reserved_enum2;
};

struct anonymous_25
{
  // table
  signed long long int table[2052l];
};

struct anonymous_23
{
  // hashTable
  unsigned int hashTable[4096l];
  // currentOffset
  unsigned int currentOffset;
  // initCheck
  unsigned int initCheck;
  // dictionary
  const unsigned char *dictionary;
  // bufferStart
  const unsigned char *bufferStart;
  // dictSize
  unsigned int dictSize;
};

struct anonymous_27
{
  // table
  unsigned long long int table[4l];
};

struct anonymous_5
{
  // dict_size
  unsigned int dict_size;
  // preset_dict
  const unsigned char *preset_dict;
  // preset_dict_size
  unsigned int preset_dict_size;
  // lc
  unsigned int lc;
  // lp
  unsigned int lp;
  // pb
  unsigned int pb;
  // mode
  enum anonymous_2 mode;
  // nice_len
  unsigned int nice_len;
  // mf
  enum anonymous_3 mf;
  // depth
  unsigned int depth;
  // reserved_int1
  unsigned int reserved_int1;
  // reserved_int2
  unsigned int reserved_int2;
  // reserved_int3
  unsigned int reserved_int3;
  // reserved_int4
  unsigned int reserved_int4;
  // reserved_int5
  unsigned int reserved_int5;
  // reserved_int6
  unsigned int reserved_int6;
  // reserved_int7
  unsigned int reserved_int7;
  // reserved_int8
  unsigned int reserved_int8;
  // reserved_enum1
  enum anonymous_4 reserved_enum1;
  // reserved_enum2
  enum anonymous_4 reserved_enum2;
  // reserved_enum3
  enum anonymous_4 reserved_enum3;
  // reserved_enum4
  enum anonymous_4 reserved_enum4;
  // reserved_ptr1
  void *reserved_ptr1;
  // reserved_ptr2
  void *reserved_ptr2;
};

union anonymous_50
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

union anonymous_58
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_26
{
  // i
  signed int i;
  // l
  signed long int l;
  // f
  float f;
  // d
  double d;
  // v
  void *v;
  // s
  char *s;
  // c
  char c;
  // uc
  unsigned char uc;
  // sh
  signed short int sh;
  // ush
  unsigned short int ush;
  // ui
  unsigned int ui;
  // iarray
  signed int iarray[2l];
  // farray
  float farray[2l];
  // carray
  char carray[8l];
  // ucarray
  unsigned char ucarray[8l];
};

union anonymous_56
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

union anonymous_33
{
  // char_data
  char char_data;
  // uchar_data
  unsigned char uchar_data;
  // bool_data
  signed int bool_data;
  // int_data
  signed int int_data;
  // uint_data
  unsigned int uint_data;
  // long_data
  signed long int long_data;
  // ulong_data
  unsigned long int ulong_data;
  // float_data
  float float_data;
  // double_data
  double double_data;
  // string_data
  char *string_data;
  // object_data
  struct _GtkObject *object_data;
  // pointer_data
  void *pointer_data;
  // signal_data
  struct anonymous_71 signal_data;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_9
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct fstHierScope
{
  // typ
  unsigned char typ;
  // name
  const char *name;
  // component
  const char *component;
  // name_length
  unsigned int name_length;
  // component_length
  unsigned int component_length;
};

struct fstHierVar
{
  // typ
  unsigned char typ;
  // direction
  unsigned char direction;
  // svt_workspace
  unsigned char svt_workspace;
  // sdt_workspace
  unsigned char sdt_workspace;
  // sxt_workspace
  unsigned int sxt_workspace;
  // name
  const char *name;
  // length
  unsigned int length;
  // handle
  unsigned int handle;
  // name_length
  unsigned int name_length;
  // is_alias
  unsigned int is_alias : 1;
};

struct fstHierAttr
{
  // typ
  unsigned char typ;
  // subtype
  unsigned char subtype;
  // name
  const char *name;
  // arg
  unsigned long int arg;
  // arg_from_name
  unsigned long int arg_from_name;
  // name_length
  unsigned int name_length;
};

union anonymous_29
{
  // scope
  struct fstHierScope scope;
  // var
  struct fstHierVar var;
  // attr
  struct fstHierAttr attr;
};

struct J_UDY_ERROR_STRUCT
{
  // je_Errno
  enum anonymous_12 je_Errno;
  // je_ErrID
  signed int je_ErrID;
  // je_reserved
  unsigned long int je_reserved[4l];
};

struct XDR
{
  // x_op
  enum xdr_op x_op;
  // x_ops
  struct xdr_ops *x_ops;
  // x_public
  char *x_public;
  // x_private
  char *x_private;
  // x_base
  char *x_base;
  // x_handy
  unsigned int x_handy;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _AtkObject
{
  // parent
  struct _GObject parent;
  // description
  char *description;
  // name
  char *name;
  // accessible_parent
  struct _AtkObject *accessible_parent;
  // role
  enum anonymous_72 role;
  // relation_set
  struct _AtkRelationSet *relation_set;
  // layer
  enum anonymous_73 layer;
};

struct _AtkRelationSet
{
  // parent
  struct _GObject parent;
  // relations
  struct _GPtrArray *relations;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous_57 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GPtrArray
{
  // pdata
  void **pdata;
  // len
  unsigned int len;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GTimeVal
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous_56 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkCursor
{
  // type
  enum anonymous_17 type;
  // ref_count
  unsigned int ref_count;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous_39 source;
  // mode
  enum anonymous_40 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous_41 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous_36 modifiers;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkDisplay
{
  // parent_instance
  struct _GObject parent_instance;
  // queued_events
  struct _GList *queued_events;
  // queued_tail
  struct _GList *queued_tail;
  // button_click_time
  unsigned int button_click_time[2l];
  // button_window
  struct _GdkDrawable *button_window[2l];
  // button_number
  signed int button_number[2l];
  // double_click_time
  unsigned int double_click_time;
  // core_pointer
  struct _GdkDevice *core_pointer;
  // pointer_hooks
  const struct _GdkDisplayPointerHooks *pointer_hooks;
  // closed
  unsigned int closed : 1;
  // ignore_core_events
  unsigned int ignore_core_events : 1;
  // double_click_distance
  unsigned int double_click_distance;
  // button_x
  signed int button_x[2l];
  // button_y
  signed int button_y[2l];
  // pointer_grabs
  struct _GList *pointer_grabs;
  // keyboard_grab
  struct anonymous_51 keyboard_grab;
  // pointer_info
  struct anonymous_52 pointer_info;
  // last_event_time
  unsigned int last_event_time;
};

struct _GdkDisplayPointerHooks
{
  // get_pointer
  void (*get_pointer)(struct _GdkDisplay *, struct _GdkScreen **, signed int *, signed int *, enum anonymous_36 *);
  // window_get_pointer
  struct _GdkDrawable * (*window_get_pointer)(struct _GdkDisplay *, struct _GdkDrawable *, signed int *, signed int *, enum anonymous_36 *);
  // window_at_pointer
  struct _GdkDrawable * (*window_at_pointer)(struct _GdkDisplay *, signed int *, signed int *);
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous_38 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous_37 actions;
  // suggested_action
  enum anonymous_37 suggested_action;
  // action
  enum anonymous_37 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkEventAny
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventExpose
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous_43 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous_44 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous_46 mode;
  // detail
  enum anonymous_45 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous_49 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous_50 data;
};

struct _GdkEventDND
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous_47 changed_mask;
  // new_window_state
  enum anonymous_47 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous_48 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous_42 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous_42 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous_53 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous_62 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous_35 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GtkAccelGroup
{
  // parent
  struct _GObject parent;
  // lock_count
  unsigned int lock_count;
  // modifier_mask
  enum anonymous_36 modifier_mask;
  // acceleratables
  struct _GSList *acceleratables;
  // n_accels
  unsigned int n_accels;
  // priv_accels
  struct _GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelKey
{
  // accel_key
  unsigned int accel_key;
  // accel_mods
  enum anonymous_36 accel_mods;
  // accel_flags
  unsigned int accel_flags : 16;
};

struct _GtkAccelGroupEntry
{
  // key
  struct _GtkAccelKey key;
  // closure
  struct _GClosure *closure;
  // accel_path_quark
  unsigned int accel_path_quark;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkArg
{
  // type
  unsigned long int type;
  // name
  char *name;
  // d
  union anonymous_33 d;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkCListCellInfo
{
  // row
  signed int row;
  // column
  signed int column;
};

struct _GtkCList
{
  // container
  struct _GtkContainer container;
  // flags
  unsigned short int flags;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
  // freeze_count
  unsigned int freeze_count;
  // internal_allocation
  struct _GdkRectangle internal_allocation;
  // rows
  signed int rows;
  // row_height
  signed int row_height;
  // row_list
  struct _GList *row_list;
  // row_list_end
  struct _GList *row_list_end;
  // columns
  signed int columns;
  // column_title_area
  struct _GdkRectangle column_title_area;
  // title_window
  struct _GdkDrawable *title_window;
  // column
  struct _GtkCListColumn *column;
  // clist_window
  struct _GdkDrawable *clist_window;
  // clist_window_width
  signed int clist_window_width;
  // clist_window_height
  signed int clist_window_height;
  // hoffset
  signed int hoffset;
  // voffset
  signed int voffset;
  // shadow_type
  enum anonymous_13 shadow_type;
  // selection_mode
  enum anonymous_14 selection_mode;
  // selection
  struct _GList *selection;
  // selection_end
  struct _GList *selection_end;
  // undo_selection
  struct _GList *undo_selection;
  // undo_unselection
  struct _GList *undo_unselection;
  // undo_anchor
  signed int undo_anchor;
  // button_actions
  unsigned char button_actions[5l];
  // drag_button
  unsigned char drag_button;
  // click_cell
  struct _GtkCListCellInfo click_cell;
  // hadjustment
  struct _GtkAdjustment *hadjustment;
  // vadjustment
  struct _GtkAdjustment *vadjustment;
  // xor_gc
  struct _GdkGC *xor_gc;
  // fg_gc
  struct _GdkGC *fg_gc;
  // bg_gc
  struct _GdkGC *bg_gc;
  // cursor_drag
  struct _GdkCursor *cursor_drag;
  // x_drag
  signed int x_drag;
  // focus_row
  signed int focus_row;
  // focus_header_column
  signed int focus_header_column;
  // anchor
  signed int anchor;
  // anchor_state
  enum anonymous_69 anchor_state;
  // drag_pos
  signed int drag_pos;
  // htimer
  signed int htimer;
  // vtimer
  signed int vtimer;
  // sort_type
  enum anonymous_15 sort_type;
  // compare
  signed int (*compare)(struct _GtkCList *, const void *, const void *);
  // sort_column
  signed int sort_column;
  // drag_highlight_row
  signed int drag_highlight_row;
  // drag_highlight_pos
  enum anonymous_16 drag_highlight_pos;
};

struct _GtkCListColumn
{
  // title
  char *title;
  // area
  struct _GdkRectangle area;
  // button
  struct _GtkWidget *button;
  // window
  struct _GdkDrawable *window;
  // width
  signed int width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // justification
  enum anonymous_32 justification;
  // visible
  unsigned int visible : 1;
  // width_set
  unsigned int width_set : 1;
  // resizeable
  unsigned int resizeable : 1;
  // auto_resize
  unsigned int auto_resize : 1;
  // button_passive
  unsigned int button_passive : 1;
};

struct _GtkCTree
{
  // clist
  struct _GtkCList clist;
  // lines_gc
  struct _GdkGC *lines_gc;
  // tree_indent
  signed int tree_indent;
  // tree_spacing
  signed int tree_spacing;
  // tree_column
  signed int tree_column;
  // line_style
  unsigned int line_style : 2;
  // expander_style
  unsigned int expander_style : 2;
  // show_stub
  unsigned int show_stub : 1;
  // drag_compare
  signed int (*drag_compare)(struct _GtkCTree *, struct _GtkCTreeNode *, struct _GtkCTreeNode *, struct _GtkCTreeNode *);
};

struct _GtkCTreeNode
{
  // list
  struct _GList list;
};

struct _GtkObjectClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // set_arg
  void (*set_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // get_arg
  void (*get_arg)(struct _GtkObject *, struct _GtkArg *, unsigned int);
  // destroy
  void (*destroy)(struct _GtkObject *);
};

struct _GtkWidgetClass
{
  // parent_class
  struct _GtkObjectClass parent_class;
  // activate_signal
  unsigned int activate_signal;
  // set_scroll_adjustments_signal
  unsigned int set_scroll_adjustments_signal;
  // dispatch_child_properties_changed
  void (*dispatch_child_properties_changed)(struct _GtkWidget *, unsigned int, struct _GParamSpec **);
  // show
  void (*show)(struct _GtkWidget *);
  // show_all
  void (*show_all)(struct _GtkWidget *);
  // hide
  void (*hide)(struct _GtkWidget *);
  // hide_all
  void (*hide_all)(struct _GtkWidget *);
  // map
  void (*map)(struct _GtkWidget *);
  // unmap
  void (*unmap)(struct _GtkWidget *);
  // realize
  void (*realize)(struct _GtkWidget *);
  // unrealize
  void (*unrealize)(struct _GtkWidget *);
  // size_request
  void (*size_request)(struct _GtkWidget *, struct _GtkRequisition *);
  // size_allocate
  void (*size_allocate)(struct _GtkWidget *, struct _GdkRectangle *);
  // state_changed
  void (*state_changed)(struct _GtkWidget *, enum anonymous_69);
  // parent_set
  void (*parent_set)(struct _GtkWidget *, struct _GtkWidget *);
  // hierarchy_changed
  void (*hierarchy_changed)(struct _GtkWidget *, struct _GtkWidget *);
  // style_set
  void (*style_set)(struct _GtkWidget *, struct _GtkStyle *);
  // direction_changed
  void (*direction_changed)(struct _GtkWidget *, enum anonymous_66);
  // grab_notify
  void (*grab_notify)(struct _GtkWidget *, signed int);
  // child_notify
  void (*child_notify)(struct _GtkWidget *, struct _GParamSpec *);
  // mnemonic_activate
  signed int (*mnemonic_activate)(struct _GtkWidget *, signed int);
  // grab_focus
  void (*grab_focus)(struct _GtkWidget *);
  // focus
  signed int (*focus)(struct _GtkWidget *, enum anonymous_65);
  // event
  signed int (*event)(struct _GtkWidget *, union _GdkEvent *);
  // button_press_event
  signed int (*button_press_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // button_release_event
  signed int (*button_release_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // scroll_event
  signed int (*scroll_event)(struct _GtkWidget *, struct _GdkEventScroll *);
  // motion_notify_event
  signed int (*motion_notify_event)(struct _GtkWidget *, struct _GdkEventMotion *);
  // delete_event
  signed int (*delete_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // destroy_event
  signed int (*destroy_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // expose_event
  signed int (*expose_event)(struct _GtkWidget *, struct _GdkEventExpose *);
  // key_press_event
  signed int (*key_press_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // key_release_event
  signed int (*key_release_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // enter_notify_event
  signed int (*enter_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // leave_notify_event
  signed int (*leave_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // configure_event
  signed int (*configure_event)(struct _GtkWidget *, struct _GdkEventConfigure *);
  // focus_in_event
  signed int (*focus_in_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // focus_out_event
  signed int (*focus_out_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // map_event
  signed int (*map_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // unmap_event
  signed int (*unmap_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // property_notify_event
  signed int (*property_notify_event)(struct _GtkWidget *, struct _GdkEventProperty *);
  // selection_clear_event
  signed int (*selection_clear_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_request_event
  signed int (*selection_request_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_notify_event
  signed int (*selection_notify_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // proximity_in_event
  signed int (*proximity_in_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // proximity_out_event
  signed int (*proximity_out_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // visibility_notify_event
  signed int (*visibility_notify_event)(struct _GtkWidget *, struct _GdkEventVisibility *);
  // client_event
  signed int (*client_event)(struct _GtkWidget *, struct _GdkEventClient *);
  // no_expose_event
  signed int (*no_expose_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // window_state_event
  signed int (*window_state_event)(struct _GtkWidget *, struct _GdkEventWindowState *);
  // selection_get
  void (*selection_get)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // selection_received
  void (*selection_received)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int);
  // drag_begin
  void (*drag_begin)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_end
  void (*drag_end)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_data_get
  void (*drag_data_get)(struct _GtkWidget *, struct _GdkDragContext *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_data_delete
  void (*drag_data_delete)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_leave
  void (*drag_leave)(struct _GtkWidget *, struct _GdkDragContext *, unsigned int);
  // drag_motion
  signed int (*drag_motion)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_drop
  signed int (*drag_drop)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_data_received
  void (*drag_data_received)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, struct _GtkSelectionData *, unsigned int, unsigned int);
  // popup_menu
  signed int (*popup_menu)(struct _GtkWidget *);
  // show_help
  signed int (*show_help)(struct _GtkWidget *, enum anonymous);
  // get_accessible
  struct _AtkObject * (*get_accessible)(struct _GtkWidget *);
  // screen_changed
  void (*screen_changed)(struct _GtkWidget *, struct _GdkScreen *);
  // can_activate_accel
  signed int (*can_activate_accel)(struct _GtkWidget *, unsigned int);
  // grab_broken_event
  signed int (*grab_broken_event)(struct _GtkWidget *, struct _GdkEventGrabBroken *);
  // composited_changed
  void (*composited_changed)(struct _GtkWidget *);
  // query_tooltip
  signed int (*query_tooltip)(struct _GtkWidget *, signed int, signed int, signed int, struct _GtkTooltip *);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _GtkContainerClass
{
  // parent_class
  struct _GtkWidgetClass parent_class;
  // add
  void (*add)(struct _GtkContainer *, struct _GtkWidget *);
  // remove
  void (*remove)(struct _GtkContainer *, struct _GtkWidget *);
  // check_resize
  void (*check_resize)(struct _GtkContainer *);
  // forall
  void (*forall)(struct _GtkContainer *, signed int, void (*)(struct _GtkWidget *, void *), void *);
  // set_focus_child
  void (*set_focus_child)(struct _GtkContainer *, struct _GtkWidget *);
  // child_type
  unsigned long int (*child_type)(struct _GtkContainer *);
  // composite_name
  char * (*composite_name)(struct _GtkContainer *, struct _GtkWidget *);
  // set_child_property
  void (*set_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_child_property
  void (*get_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GtkEntry
{
  // widget
  struct _GtkWidget widget;
  // text
  char *text;
  // editable
  unsigned int editable : 1;
  // visible
  unsigned int visible : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // in_drag
  unsigned int in_drag : 1;
  // text_length
  unsigned short int text_length;
  // text_max_length
  unsigned short int text_max_length;
  // text_area
  struct _GdkDrawable *text_area;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // current_pos
  signed int current_pos;
  // selection_bound
  signed int selection_bound;
  // cached_layout
  struct _PangoLayout *cached_layout;
  // cache_includes_preedit
  unsigned int cache_includes_preedit : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // has_frame
  unsigned int has_frame : 1;
  // activates_default
  unsigned int activates_default : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // in_click
  unsigned int in_click : 1;
  // is_cell_renderer
  unsigned int is_cell_renderer : 1;
  // editing_canceled
  unsigned int editing_canceled : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // select_words
  unsigned int select_words : 1;
  // select_lines
  unsigned int select_lines : 1;
  // resolved_dir
  unsigned int resolved_dir : 4;
  // truncate_multiline
  unsigned int truncate_multiline : 1;
  // button
  unsigned int button;
  // blink_timeout
  unsigned int blink_timeout;
  // recompute_idle
  unsigned int recompute_idle;
  // scroll_offset
  signed int scroll_offset;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // x_text_size
  unsigned short int x_text_size;
  // x_n_bytes
  unsigned short int x_n_bytes;
  // preedit_length
  unsigned short int preedit_length;
  // preedit_cursor
  unsigned short int preedit_cursor;
  // dnd_position
  signed int dnd_position;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // invisible_char
  unsigned int invisible_char;
  // width_chars
  signed int width_chars;
};

struct _GtkIMContext
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GtkMenuShell
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // active_menu_item
  struct _GtkWidget *active_menu_item;
  // parent_menu_shell
  struct _GtkWidget *parent_menu_shell;
  // button
  unsigned int button;
  // activate_time
  unsigned int activate_time;
  // active
  unsigned int active : 1;
  // have_grab
  unsigned int have_grab : 1;
  // have_xgrab
  unsigned int have_xgrab : 1;
  // ignore_leave
  unsigned int ignore_leave : 1;
  // menu_flag
  unsigned int menu_flag : 1;
  // ignore_enter
  unsigned int ignore_enter : 1;
  // keyboard_mode
  unsigned int keyboard_mode : 1;
};

struct _GtkMenu
{
  // menu_shell
  struct _GtkMenuShell menu_shell;
  // parent_menu_item
  struct _GtkWidget *parent_menu_item;
  // old_active_menu_item
  struct _GtkWidget *old_active_menu_item;
  // accel_group
  struct _GtkAccelGroup *accel_group;
  // accel_path
  char *accel_path;
  // position_func
  void (*position_func)(struct _GtkMenu *, signed int *, signed int *, signed int *, void *);
  // position_func_data
  void *position_func_data;
  // toggle_size
  unsigned int toggle_size;
  // toplevel
  struct _GtkWidget *toplevel;
  // tearoff_window
  struct _GtkWidget *tearoff_window;
  // tearoff_hbox
  struct _GtkWidget *tearoff_hbox;
  // tearoff_scrollbar
  struct _GtkWidget *tearoff_scrollbar;
  // tearoff_adjustment
  struct _GtkAdjustment *tearoff_adjustment;
  // view_window
  struct _GdkDrawable *view_window;
  // bin_window
  struct _GdkDrawable *bin_window;
  // scroll_offset
  signed int scroll_offset;
  // saved_scroll_offset
  signed int saved_scroll_offset;
  // scroll_step
  signed int scroll_step;
  // timeout_id
  unsigned int timeout_id;
  // navigation_region
  struct _GdkRegion *navigation_region;
  // navigation_timeout
  unsigned int navigation_timeout;
  // needs_destruction_ref_count
  unsigned int needs_destruction_ref_count : 1;
  // torn_off
  unsigned int torn_off : 1;
  // tearoff_active
  unsigned int tearoff_active : 1;
  // scroll_fast
  unsigned int scroll_fast : 1;
  // upper_arrow_visible
  unsigned int upper_arrow_visible : 1;
  // lower_arrow_visible
  unsigned int lower_arrow_visible : 1;
  // upper_arrow_prelight
  unsigned int upper_arrow_prelight : 1;
  // lower_arrow_prelight
  unsigned int lower_arrow_prelight : 1;
};

struct _GtkNotebook
{
  // container
  struct _GtkContainer container;
  // cur_page
  struct _GtkNotebookPage *cur_page;
  // children
  struct _GList *children;
  // first_tab
  struct _GList *first_tab;
  // focus_tab
  struct _GList *focus_tab;
  // menu
  struct _GtkWidget *menu;
  // event_window
  struct _GdkDrawable *event_window;
  // timer
  unsigned int timer;
  // tab_hborder
  unsigned short int tab_hborder;
  // tab_vborder
  unsigned short int tab_vborder;
  // show_tabs
  unsigned int show_tabs : 1;
  // homogeneous
  unsigned int homogeneous : 1;
  // show_border
  unsigned int show_border : 1;
  // tab_pos
  unsigned int tab_pos : 2;
  // scrollable
  unsigned int scrollable : 1;
  // in_child
  unsigned int in_child : 3;
  // click_child
  unsigned int click_child : 3;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // child_has_focus
  unsigned int child_has_focus : 1;
  // have_visible_child
  unsigned int have_visible_child : 1;
  // focus_out
  unsigned int focus_out : 1;
  // has_before_previous
  unsigned int has_before_previous : 1;
  // has_before_next
  unsigned int has_before_next : 1;
  // has_after_previous
  unsigned int has_after_previous : 1;
  // has_after_next
  unsigned int has_after_next : 1;
};

struct _GtkPaned
{
  // container
  struct _GtkContainer container;
  // child1
  struct _GtkWidget *child1;
  // child2
  struct _GtkWidget *child2;
  // handle
  struct _GdkDrawable *handle;
  // xor_gc
  struct _GdkGC *xor_gc;
  // cursor_type
  enum anonymous_17 cursor_type;
  // handle_pos
  struct _GdkRectangle handle_pos;
  // child1_size
  signed int child1_size;
  // last_allocation
  signed int last_allocation;
  // min_position
  signed int min_position;
  // max_position
  signed int max_position;
  // position_set
  unsigned int position_set : 1;
  // in_drag
  unsigned int in_drag : 1;
  // child1_shrink
  unsigned int child1_shrink : 1;
  // child1_resize
  unsigned int child1_resize : 1;
  // child2_shrink
  unsigned int child2_shrink : 1;
  // child2_resize
  unsigned int child2_resize : 1;
  // orientation
  unsigned int orientation : 1;
  // in_recursion
  unsigned int in_recursion : 1;
  // handle_prelit
  unsigned int handle_prelit : 1;
  // last_child1_focus
  struct _GtkWidget *last_child1_focus;
  // last_child2_focus
  struct _GtkWidget *last_child2_focus;
  // priv
  struct _GtkPanedPrivate *priv;
  // drag_pos
  signed int drag_pos;
  // original_position
  signed int original_position;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous_54 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSelectionData
{
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // type
  struct _GdkAtom *type;
  // format
  signed int format;
  // data
  unsigned char *data;
  // length
  signed int length;
  // display
  struct _GdkDisplay *display;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTable
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // rows
  struct _GtkTableRowCol *rows;
  // cols
  struct _GtkTableRowCol *cols;
  // nrows
  unsigned short int nrows;
  // ncols
  unsigned short int ncols;
  // column_spacing
  unsigned short int column_spacing;
  // row_spacing
  unsigned short int row_spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkTableRowCol
{
  // requisition
  unsigned short int requisition;
  // allocation
  unsigned short int allocation;
  // spacing
  unsigned short int spacing;
  // need_expand
  unsigned int need_expand : 1;
  // need_shrink
  unsigned int need_shrink : 1;
  // expand
  unsigned int expand : 1;
  // shrink
  unsigned int shrink : 1;
  // empty
  unsigned int empty : 1;
};

struct _GtkTargetEntry
{
  // target
  char *target;
  // flags
  unsigned int flags;
  // info
  unsigned int info;
};

struct _GtkTextAppearance
{
  // bg_color
  struct _GdkColor bg_color;
  // fg_color
  struct _GdkColor fg_color;
  // bg_stipple
  struct _GdkDrawable *bg_stipple;
  // fg_stipple
  struct _GdkDrawable *fg_stipple;
  // rise
  signed int rise;
  // padding1
  void *padding1;
  // underline
  unsigned int underline : 4;
  // strikethrough
  unsigned int strikethrough : 1;
  // draw_bg
  unsigned int draw_bg : 1;
  // inside_selection
  unsigned int inside_selection : 1;
  // is_text
  unsigned int is_text : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextAttributes
{
  // refcount
  unsigned int refcount;
  // appearance
  struct _GtkTextAppearance appearance;
  // justification
  enum anonymous_32 justification;
  // direction
  enum anonymous_66 direction;
  // font
  struct _PangoFontDescription *font;
  // font_scale
  double font_scale;
  // left_margin
  signed int left_margin;
  // indent
  signed int indent;
  // right_margin
  signed int right_margin;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // tabs
  struct _PangoTabArray *tabs;
  // wrap_mode
  enum anonymous_31 wrap_mode;
  // language
  struct _PangoLanguage *language;
  // pg_bg_color
  struct _GdkColor *pg_bg_color;
  // invisible
  unsigned int invisible : 1;
  // bg_full_height
  unsigned int bg_full_height : 1;
  // editable
  unsigned int editable : 1;
  // realized
  unsigned int realized : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextBuffer
{
  // parent_instance
  struct _GObject parent_instance;
  // tag_table
  struct _GtkTextTagTable *tag_table;
  // btree
  struct _GtkTextBTree *btree;
  // clipboard_contents_buffers
  struct _GSList *clipboard_contents_buffers;
  // selection_clipboards
  struct _GSList *selection_clipboards;
  // log_attr_cache
  struct _GtkTextLogAttrCache *log_attr_cache;
  // user_action_count
  unsigned int user_action_count;
  // modified
  unsigned int modified : 1;
  // has_selection
  unsigned int has_selection : 1;
};

struct _GtkTextIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  signed int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  void *dummy9;
  // dummy10
  void *dummy10;
  // dummy11
  signed int dummy11;
  // dummy12
  signed int dummy12;
  // dummy13
  signed int dummy13;
  // dummy14
  void *dummy14;
};

struct _GtkTextMark
{
  // parent_instance
  struct _GObject parent_instance;
  // segment
  void *segment;
};

struct _GtkTextTag
{
  // parent_instance
  struct _GObject parent_instance;
  // table
  struct _GtkTextTagTable *table;
  // name
  char *name;
  // priority
  signed int priority;
  // values
  struct _GtkTextAttributes *values;
  // bg_color_set
  unsigned int bg_color_set : 1;
  // bg_stipple_set
  unsigned int bg_stipple_set : 1;
  // fg_color_set
  unsigned int fg_color_set : 1;
  // scale_set
  unsigned int scale_set : 1;
  // fg_stipple_set
  unsigned int fg_stipple_set : 1;
  // justification_set
  unsigned int justification_set : 1;
  // left_margin_set
  unsigned int left_margin_set : 1;
  // indent_set
  unsigned int indent_set : 1;
  // rise_set
  unsigned int rise_set : 1;
  // strikethrough_set
  unsigned int strikethrough_set : 1;
  // right_margin_set
  unsigned int right_margin_set : 1;
  // pixels_above_lines_set
  unsigned int pixels_above_lines_set : 1;
  // pixels_below_lines_set
  unsigned int pixels_below_lines_set : 1;
  // pixels_inside_wrap_set
  unsigned int pixels_inside_wrap_set : 1;
  // tabs_set
  unsigned int tabs_set : 1;
  // underline_set
  unsigned int underline_set : 1;
  // wrap_mode_set
  unsigned int wrap_mode_set : 1;
  // bg_full_height_set
  unsigned int bg_full_height_set : 1;
  // invisible_set
  unsigned int invisible_set : 1;
  // editable_set
  unsigned int editable_set : 1;
  // language_set
  unsigned int language_set : 1;
  // pg_bg_color_set
  unsigned int pg_bg_color_set : 1;
  // accumulative_margin
  unsigned int accumulative_margin : 1;
  // pad1
  unsigned int pad1 : 1;
};

struct _GtkTextTagTable
{
  // parent_instance
  struct _GObject parent_instance;
  // hash
  struct _GHashTable *hash;
  // anonymous
  struct _GSList *anonymous;
  // anon_count
  signed int anon_count;
  // buffers
  struct _GSList *buffers;
};

struct _GtkTextView
{
  // parent_instance
  struct _GtkContainer parent_instance;
  // layout
  struct _GtkTextLayout *layout;
  // buffer
  struct _GtkTextBuffer *buffer;
  // selection_drag_handler
  unsigned int selection_drag_handler;
  // scroll_timeout
  unsigned int scroll_timeout;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // wrap_mode
  enum anonymous_31 wrap_mode;
  // justify
  enum anonymous_32 justify;
  // left_margin
  signed int left_margin;
  // right_margin
  signed int right_margin;
  // indent
  signed int indent;
  // tabs
  struct _PangoTabArray *tabs;
  // editable
  unsigned int editable : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // accepts_tab
  unsigned int accepts_tab : 1;
  // width_changed
  unsigned int width_changed : 1;
  // onscreen_validated
  unsigned int onscreen_validated : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // text_window
  struct _GtkTextWindow *text_window;
  // left_window
  struct _GtkTextWindow *left_window;
  // right_window
  struct _GtkTextWindow *right_window;
  // top_window
  struct _GtkTextWindow *top_window;
  // bottom_window
  struct _GtkTextWindow *bottom_window;
  // hadjustment
  struct _GtkAdjustment *hadjustment;
  // vadjustment
  struct _GtkAdjustment *vadjustment;
  // xoffset
  signed int xoffset;
  // yoffset
  signed int yoffset;
  // width
  signed int width;
  // height
  signed int height;
  // virtual_cursor_x
  signed int virtual_cursor_x;
  // virtual_cursor_y
  signed int virtual_cursor_y;
  // first_para_mark
  struct _GtkTextMark *first_para_mark;
  // first_para_pixels
  signed int first_para_pixels;
  // dnd_mark
  struct _GtkTextMark *dnd_mark;
  // blink_timeout
  unsigned int blink_timeout;
  // first_validate_idle
  unsigned int first_validate_idle;
  // incremental_validate_idle
  unsigned int incremental_validate_idle;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // children
  struct _GSList *children;
  // pending_scroll
  struct _GtkTextPendingScroll *pending_scroll;
  // pending_place_cursor_button
  signed int pending_place_cursor_button;
};

struct _GtkTextViewClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
  // set_scroll_adjustments
  void (*set_scroll_adjustments)(struct _GtkTextView *, struct _GtkAdjustment *, struct _GtkAdjustment *);
  // populate_popup
  void (*populate_popup)(struct _GtkTextView *, struct _GtkMenu *);
  // move_cursor
  void (*move_cursor)(struct _GtkTextView *, enum anonymous_67, signed int, signed int);
  // page_horizontally
  void (*page_horizontally)(struct _GtkTextView *, signed int, signed int);
  // set_anchor
  void (*set_anchor)(struct _GtkTextView *);
  // insert_at_cursor
  void (*insert_at_cursor)(struct _GtkTextView *, const char *);
  // delete_from_cursor
  void (*delete_from_cursor)(struct _GtkTextView *, enum anonymous_64, signed int);
  // backspace
  void (*backspace)(struct _GtkTextView *);
  // cut_clipboard
  void (*cut_clipboard)(struct _GtkTextView *);
  // copy_clipboard
  void (*copy_clipboard)(struct _GtkTextView *);
  // paste_clipboard
  void (*paste_clipboard)(struct _GtkTextView *);
  // toggle_overwrite
  void (*toggle_overwrite)(struct _GtkTextView *);
  // move_focus
  void (*move_focus)(struct _GtkTextView *, enum anonymous_65);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _GtkToggleButton
{
  // button
  struct _GtkButton button;
  // active
  unsigned int active : 1;
  // draw_indicator
  unsigned int draw_indicator : 1;
  // inconsistent
  unsigned int inconsistent : 1;
};

struct _GtkToolbar
{
  // container
  struct _GtkContainer container;
  // num_children
  signed int num_children;
  // children
  struct _GList *children;
  // orientation
  enum anonymous_59 orientation;
  // style
  enum anonymous_60 style;
  // icon_size
  enum anonymous_61 icon_size;
  // tooltips
  struct _GtkTooltips *tooltips;
  // button_maxw
  signed int button_maxw;
  // button_maxh
  signed int button_maxh;
  // _gtk_reserved1
  unsigned int _gtk_reserved1;
  // _gtk_reserved2
  unsigned int _gtk_reserved2;
  // style_set
  unsigned int style_set : 1;
  // icon_size_set
  unsigned int icon_size_set : 1;
};

struct _GtkTooltips
{
  // parent_instance
  struct _GtkObject parent_instance;
  // tip_window
  struct _GtkWidget *tip_window;
  // tip_label
  struct _GtkWidget *tip_label;
  // active_tips_data
  struct _GtkTooltipsData *active_tips_data;
  // tips_data_list
  struct _GList *tips_data_list;
  // delay
  unsigned int delay : 30;
  // enabled
  unsigned int enabled : 1;
  // have_grab
  unsigned int have_grab : 1;
  // use_sticky_delay
  unsigned int use_sticky_delay : 1;
  // timer_tag
  signed int timer_tag;
  // last_popdown
  struct _GTimeVal last_popdown;
};

struct _GtkTooltipsData
{
  // tooltips
  struct _GtkTooltips *tooltips;
  // widget
  struct _GtkWidget *widget;
  // tip_text
  char *tip_text;
  // tip_private
  char *tip_private;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous_36 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct alloc_bytechain
{
  // val
  char val;
  // next
  struct alloc_bytechain *next;
};

struct ds_component
{
  // next
  struct ds_component *next;
  // compname
  char *compname;
  // module
  struct ds_tree_node *module;
};

struct ds_tree_node
{
  // left
  struct ds_tree_node *left;
  // right
  struct ds_tree_node *right;
  // next_flat
  struct ds_tree_node *next_flat;
  // item
  char *item;
  // filename
  char *filename;
  // s_line
  signed int s_line;
  // e_line
  signed int e_line;
  // fullname
  char *fullname;
  // refcnt
  signed int refcnt;
  // comp
  struct ds_component *comp;
  // resolved
  unsigned int resolved : 1;
  // dnd_to_import
  unsigned int dnd_to_import : 1;
};

struct fstBlackoutChain
{
  // next
  struct fstBlackoutChain *next;
  // tim
  unsigned long int tim;
  // active
  unsigned int active : 1;
};

struct fstCurrHier
{
  // prev
  struct fstCurrHier *prev;
  // user_info
  void *user_info;
  // len
  signed int len;
};

struct fstHier
{
  // htyp
  unsigned char htyp;
  // u
  union anonymous_29 u;
};

struct fstReaderContext
{
  // f
  struct _IO_FILE *f;
  // fh
  struct _IO_FILE *fh;
  // start_time
  unsigned long int start_time;
  // end_time
  unsigned long int end_time;
  // mem_used_by_writer
  unsigned long int mem_used_by_writer;
  // scope_count
  unsigned long int scope_count;
  // var_count
  unsigned long int var_count;
  // maxhandle
  unsigned int maxhandle;
  // num_alias
  unsigned long int num_alias;
  // vc_section_count
  unsigned long int vc_section_count;
  // signal_lens
  unsigned int *signal_lens;
  // signal_typs
  unsigned char *signal_typs;
  // process_mask
  unsigned char *process_mask;
  // longest_signal_value_len
  unsigned int longest_signal_value_len;
  // temp_signal_value_buf
  unsigned char *temp_signal_value_buf;
  // timescale
  signed char timescale;
  // filetype
  unsigned char filetype;
  // use_vcd_extensions
  unsigned int use_vcd_extensions : 1;
  // double_endian_match
  unsigned int double_endian_match : 1;
  // native_doubles_for_cb
  unsigned int native_doubles_for_cb : 1;
  // contains_geom_section
  unsigned int contains_geom_section : 1;
  // contains_hier_section
  unsigned int contains_hier_section : 1;
  // contains_hier_section_lz4duo
  unsigned int contains_hier_section_lz4duo : 1;
  // contains_hier_section_lz4
  unsigned int contains_hier_section_lz4 : 1;
  // limit_range_valid
  unsigned int limit_range_valid : 1;
  // version
  char version[129l];
  // date
  char date[120l];
  // timezero
  signed long int timezero;
  // filename
  char *filename;
  // filename_unpacked
  char *filename_unpacked;
  // hier_pos
  signed long int hier_pos;
  // num_blackouts
  unsigned int num_blackouts;
  // blackout_times
  unsigned long int *blackout_times;
  // blackout_activity
  unsigned char *blackout_activity;
  // limit_range_start
  unsigned long int limit_range_start;
  // limit_range_end
  unsigned long int limit_range_end;
  // rvat_data_valid
  unsigned int rvat_data_valid : 1;
  // rvat_time_table
  unsigned long int *rvat_time_table;
  // rvat_beg_tim
  unsigned long int rvat_beg_tim;
  // rvat_end_tim
  unsigned long int rvat_end_tim;
  // rvat_frame_data
  unsigned char *rvat_frame_data;
  // rvat_frame_maxhandle
  unsigned long int rvat_frame_maxhandle;
  // rvat_chain_table
  signed long int *rvat_chain_table;
  // rvat_chain_table_lengths
  unsigned int *rvat_chain_table_lengths;
  // rvat_vc_maxhandle
  unsigned long int rvat_vc_maxhandle;
  // rvat_vc_start
  signed long int rvat_vc_start;
  // rvat_sig_offs
  unsigned int *rvat_sig_offs;
  // rvat_chain_len
  unsigned int rvat_chain_len;
  // rvat_chain_mem
  unsigned char *rvat_chain_mem;
  // rvat_chain_facidx
  unsigned int rvat_chain_facidx;
  // rvat_chain_pos_tidx
  unsigned int rvat_chain_pos_tidx;
  // rvat_chain_pos_idx
  unsigned int rvat_chain_pos_idx;
  // rvat_chain_pos_time
  unsigned long int rvat_chain_pos_time;
  // rvat_chain_pos_valid
  unsigned int rvat_chain_pos_valid : 1;
  // hier
  struct fstHier hier;
  // curr_hier
  struct fstCurrHier *curr_hier;
  // current_handle
  unsigned int current_handle;
  // curr_flat_hier_nam
  char *curr_flat_hier_nam;
  // flat_hier_alloc_len
  signed int flat_hier_alloc_len;
  // do_rewind
  unsigned int do_rewind : 1;
  // str_scope_nam
  char str_scope_nam[513l];
  // str_scope_comp
  char str_scope_comp[513l];
  // fseek_failed
  unsigned int fseek_failed : 1;
  // writex_pos
  signed int writex_pos;
  // writex_fd
  signed int writex_fd;
  // writex_buf
  unsigned char writex_buf[65536l];
  // f_nam
  char *f_nam;
  // fh_nam
  char *fh_nam;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct fstWriterContext
{
  // handle
  struct _IO_FILE *handle;
  // hier_handle
  struct _IO_FILE *hier_handle;
  // geom_handle
  struct _IO_FILE *geom_handle;
  // valpos_handle
  struct _IO_FILE *valpos_handle;
  // curval_handle
  struct _IO_FILE *curval_handle;
  // tchn_handle
  struct _IO_FILE *tchn_handle;
  // vchg_mem
  unsigned char *vchg_mem;
  // hier_file_len
  signed long int hier_file_len;
  // valpos_mem
  unsigned int *valpos_mem;
  // curval_mem
  unsigned char *curval_mem;
  // filename
  char *filename;
  // maxhandle
  unsigned int maxhandle;
  // numsigs
  unsigned int numsigs;
  // maxvalpos
  unsigned int maxvalpos;
  // vc_emitted
  unsigned int vc_emitted : 1;
  // is_initial_time
  unsigned int is_initial_time : 1;
  // fourpack
  unsigned int fourpack : 1;
  // fastpack
  unsigned int fastpack : 1;
  // timezero
  signed long int timezero;
  // section_header_truncpos
  signed long int section_header_truncpos;
  // tchn_cnt
  unsigned int tchn_cnt;
  // tchn_idx
  unsigned int tchn_idx;
  // curtime
  unsigned long int curtime;
  // firsttime
  unsigned long int firsttime;
  // vchg_siz
  unsigned int vchg_siz;
  // vchg_alloc_siz
  unsigned int vchg_alloc_siz;
  // secnum
  unsigned int secnum;
  // section_start
  signed long int section_start;
  // numscopes
  unsigned int numscopes;
  // nan
  double nan;
  // blackout_head
  struct fstBlackoutChain *blackout_head;
  // blackout_curr
  struct fstBlackoutChain *blackout_curr;
  // num_blackouts
  unsigned int num_blackouts;
  // dump_size_limit
  unsigned long int dump_size_limit;
  // filetype
  unsigned char filetype;
  // compress_hier
  unsigned int compress_hier : 1;
  // repack_on_close
  unsigned int repack_on_close : 1;
  // skip_writing_section_hdr
  unsigned int skip_writing_section_hdr : 1;
  // size_limit_locked
  unsigned int size_limit_locked : 1;
  // section_header_only
  unsigned int section_header_only : 1;
  // flush_context_pending
  unsigned int flush_context_pending : 1;
  // parallel_enabled
  unsigned int parallel_enabled : 1;
  // parallel_was_enabled
  unsigned int parallel_was_enabled : 1;
  // already_in_flush
  unsigned char already_in_flush;
  // already_in_close
  unsigned char already_in_close;
  // mutex
  union anonymous_9 mutex;
  // thread
  unsigned long int thread;
  // thread_attr
  union pthread_attr_t thread_attr;
  // xc_parent
  struct fstWriterContext *xc_parent;
  // fst_orig_break_size
  unsigned long int fst_orig_break_size;
  // fst_orig_break_add_size
  unsigned long int fst_orig_break_add_size;
  // fst_break_size
  unsigned long int fst_break_size;
  // fst_break_add_size
  unsigned long int fst_break_add_size;
  // fst_huge_break_size
  unsigned long int fst_huge_break_size;
  // next_huge_break
  unsigned int next_huge_break;
  // path_array
  void *path_array;
  // path_array_count
  unsigned int path_array_count;
  // fseek_failed
  unsigned int fseek_failed : 1;
  // geom_handle_nam
  char *geom_handle_nam;
  // valpos_handle_nam
  char *valpos_handle_nam;
  // curval_handle_nam
  char *curval_handle_nam;
  // tchn_handle_nam
  char *tchn_handle_nam;
};

struct gtkwave_annotate_ipc_t
{
  // matchword
  char matchword[4l];
  // time_string
  char time_string[40l];
  // gtkwave_process
  signed int gtkwave_process;
  // browser_process
  signed int browser_process;
  // marker
  signed long int marker;
  // marker_set
  unsigned int marker_set : 1;
  // cygwin_remote_kill
  unsigned int cygwin_remote_kill : 1;
  // aet_type
  signed int aet_type;
  // aet_name
  char aet_name[4097l];
  // stems_name
  char stems_name[4097l];
};

struct gzFile_s
{
  // have
  unsigned int have;
  // next
  unsigned char *next;
  // pos
  signed long int pos;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct jrb_chain
{
  // next
  struct jrb_chain *next;
  // val
  union anonymous_26 val;
};

struct jrb_node
{
  // red
  unsigned char red;
  // internal
  unsigned char internal;
  // left
  unsigned char left;
  // roothead
  unsigned char roothead;
  // flink
  struct jrb_node *flink;
  // blink
  struct jrb_node *blink;
  // parent
  struct jrb_node *parent;
  // jval_chain
  struct jrb_chain *jval_chain;
  // key
  union anonymous_26 key;
  // val
  union anonymous_26 val;
  // val2
  union anonymous_26 val2;
};

struct logfile_context_t
{
  // which
  struct ds_tree_node *which;
  // title
  char *title;
  // display_mode
  signed int display_mode;
  // width
  signed int width;
  // varnames
  struct jrb_node *varnames;
  // resolved
  signed int resolved;
};

struct lxt2_rd_block
{
  // mem
  char *mem;
  // next
  struct lxt2_rd_block *next;
  // uncompressed_siz
  unsigned int uncompressed_siz;
  // compressed_siz
  unsigned int compressed_siz;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // num_map_entries
  unsigned int num_map_entries;
  // num_dict_entries
  unsigned int num_dict_entries;
  // map_start
  char *map_start;
  // dict_start
  char *dict_start;
  // string_pointers
  char **string_pointers;
  // string_lens
  unsigned int *string_lens;
  // filepos
  signed long int filepos;
  // short_read_ignore
  unsigned int short_read_ignore : 1;
  // exclude_block
  unsigned int exclude_block : 1;
};

struct lxt2_rd_facname_cache
{
  // n
  char *n;
  // bufprev
  char *bufprev;
  // bufcurr
  char *bufcurr;
  // old_facidx
  unsigned int old_facidx;
};

struct lxt2_rd_geometry
{
  // rows
  unsigned int rows;
  // msb
  signed int msb;
  // lsb
  signed int lsb;
  // flags
  unsigned int flags;
  // len
  unsigned int len;
};

struct lxt2_rd_trace
{
  // rows
  unsigned int *rows;
  // msb
  signed int *msb;
  // lsb
  signed int *lsb;
  // flags
  unsigned int *flags;
  // len
  unsigned int *len;
  // value
  char **value;
  // fac_map
  unsigned long int *fac_map;
  // fac_curpos
  char **fac_curpos;
  // process_mask
  char *process_mask;
  // process_mask_compressed
  char *process_mask_compressed;
  // radix_sort
  void **radix_sort[65l];
  // next_radix
  void **next_radix;
  // value_change_callback
  void (*value_change_callback)(struct lxt2_rd_trace **, unsigned long int *, unsigned int *, char **);
  // user_callback_data_pointer
  void *user_callback_data_pointer;
  // fac_map_index_width
  unsigned char fac_map_index_width;
  // fac_curpos_width
  unsigned char fac_curpos_width;
  // granule_size
  unsigned char granule_size;
  // numfacs
  unsigned int numfacs;
  // numrealfacs
  unsigned int numrealfacs;
  // numfacbytes
  unsigned int numfacbytes;
  // longestname
  unsigned int longestname;
  // zfacnamesize
  unsigned int zfacnamesize;
  // zfacname_predec_size
  unsigned int zfacname_predec_size;
  // zfacgeometrysize
  unsigned int zfacgeometrysize;
  // timescale
  unsigned char timescale;
  // timezero
  signed long int timezero;
  // prev_time
  unsigned long int prev_time;
  // num_time_table_entries
  unsigned char num_time_table_entries;
  // time_table
  unsigned long int time_table[64l];
  // zfacnames
  char *zfacnames;
  // numblocks
  unsigned int numblocks;
  // block_head
  struct lxt2_rd_block *block_head;
  // block_curr
  struct lxt2_rd_block *block_curr;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // geometry
  struct lxt2_rd_geometry geometry;
  // faccache
  struct lxt2_rd_facname_cache *faccache;
  // handle
  struct _IO_FILE *handle;
  // zhandle
  struct gzFile_s *zhandle;
  // block_mem_consumed
  unsigned long int block_mem_consumed;
  // block_mem_max
  unsigned long int block_mem_max;
  // process_mask_dirty
  unsigned int process_mask_dirty : 1;
};

struct lzma_handle_t
{
  // fd
  signed int fd;
  // offs
  unsigned int offs;
  // blklen
  unsigned int blklen;
  // depth
  unsigned int depth;
  // state
  enum lzma_state_t state;
  // blksiz
  unsigned int blksiz;
  // mem
  unsigned char *mem;
  // dmem
  unsigned char *dmem;
  // write_cnt
  unsigned long int write_cnt;
  // read_cnt
  unsigned long int read_cnt;
};

struct text_find_t
{
  // next
  struct text_find_t *next;
  // text
  struct _GtkWidget *text;
  // window
  struct _GtkWidget *window;
  // button
  struct _GtkWidget *button;
  // ctx
  struct logfile_context_t *ctx;
  // line
  signed int line;
  // offs
  signed int offs;
  // srch_line
  signed int srch_line;
  // srch_offs
  signed int srch_offs;
  // bold_tag
  struct _GtkTextTag *bold_tag;
  // dgray_tag
  struct _GtkTextTag *dgray_tag;
  // lgray_tag
  struct _GtkTextTag *lgray_tag;
  // blue_tag
  struct _GtkTextTag *blue_tag;
  // fwht_tag
  struct _GtkTextTag *fwht_tag;
  // mono_tag
  struct _GtkTextTag *mono_tag;
  // size_tag
  struct _GtkTextTag *size_tag;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct vzt_ncycle_autosort
{
  // next
  struct vzt_ncycle_autosort *next;
};

struct vzt_pth_args
{
  // lt
  struct vzt_rd_trace *lt;
  // b
  struct vzt_rd_block *b;
};

struct vzt_rd_block
{
  // mem
  char *mem;
  // next
  struct vzt_rd_block *next;
  // prev
  struct vzt_rd_block *prev;
  // uncompressed_siz
  unsigned int uncompressed_siz;
  // compressed_siz
  unsigned int compressed_siz;
  // num_rle_bytes
  unsigned int num_rle_bytes;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // vindex
  unsigned int *vindex;
  // times
  unsigned long int *times;
  // change_dict
  unsigned int *change_dict;
  // val_dict
  unsigned int *val_dict;
  // sindex
  char **sindex;
  // num_time_ticks
  unsigned int num_time_ticks;
  // num_sections
  unsigned int num_sections;
  // num_dict_entries
  unsigned int num_dict_entries;
  // num_str_entries
  unsigned int num_str_entries;
  // filepos
  signed long int filepos;
  // short_read_ignore
  unsigned int short_read_ignore : 1;
  // exclude_block
  unsigned int exclude_block : 1;
  // multi_state
  unsigned int multi_state : 1;
  // killed
  unsigned int killed : 1;
  // ztype
  unsigned int ztype : 2;
  // rle
  unsigned int rle : 1;
  // pth
  unsigned long int pth;
  // pth_attr
  union pthread_attr_t pth_attr;
  // mutex
  union anonymous_9 mutex;
  // last_rd_value_simtime
  unsigned long int last_rd_value_simtime;
  // last_rd_value_idx
  unsigned int last_rd_value_idx;
};

struct vzt_rd_facname_cache
{
  // n
  char *n;
  // bufprev
  char *bufprev;
  // bufcurr
  char *bufcurr;
  // old_facidx
  unsigned int old_facidx;
};

struct vzt_rd_geometry
{
  // rows
  unsigned int rows;
  // msb
  signed int msb;
  // lsb
  signed int lsb;
  // flags
  unsigned int flags;
  // len
  unsigned int len;
};

struct vzt_rd_trace
{
  // rows
  unsigned int *rows;
  // msb
  signed int *msb;
  // lsb
  signed int *lsb;
  // flags
  unsigned int *flags;
  // len
  unsigned int *len;
  // vindex_offset
  unsigned int *vindex_offset;
  // timezero
  signed long int timezero;
  // value_current_sector
  char *value_current_sector;
  // value_previous_sector
  char *value_previous_sector;
  // longest_len
  unsigned int longest_len;
  // total_values
  unsigned int total_values;
  // process_mask
  char *process_mask;
  // value_change_callback
  void (*value_change_callback)(struct vzt_rd_trace **, unsigned long int *, unsigned int *, char **);
  // user_callback_data_pointer
  void *user_callback_data_pointer;
  // granule_size
  unsigned char granule_size;
  // numfacs
  unsigned int numfacs;
  // numrealfacs
  unsigned int numrealfacs;
  // numfacbytes
  unsigned int numfacbytes;
  // longestname
  unsigned int longestname;
  // zfacnamesize
  unsigned int zfacnamesize;
  // zfacname_predec_size
  unsigned int zfacname_predec_size;
  // zfacgeometrysize
  unsigned int zfacgeometrysize;
  // timescale
  unsigned char timescale;
  // zfacnames
  char *zfacnames;
  // numblocks
  unsigned int numblocks;
  // block_head
  struct vzt_rd_block *block_head;
  // block_curr
  struct vzt_rd_block *block_curr;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // geometry
  struct vzt_rd_geometry geometry;
  // faccache
  struct vzt_rd_facname_cache *faccache;
  // last_rd_value_simtime
  unsigned long int last_rd_value_simtime;
  // last_rd_value_block
  struct vzt_rd_block *last_rd_value_block;
  // filename
  char *filename;
  // handle
  struct _IO_FILE *handle;
  // zhandle
  void *zhandle;
  // block_mem_consumed
  unsigned long int block_mem_consumed;
  // block_mem_max
  unsigned long int block_mem_max;
  // mutex
  union anonymous_9 mutex;
  // pthreads
  unsigned int pthreads;
  // process_linear
  unsigned int process_linear : 1;
  // vectorize
  unsigned int vectorize : 1;
};

struct vzt_synvec_chain
{
  // num_entries
  unsigned int num_entries;
  // chain
  unsigned int chain[1l];
};

struct wave_logfile_lines_t
{
  // next
  struct wave_logfile_lines_t *next;
  // line_no
  signed int line_no;
  // tok
  signed int tok;
  // text
  char *text;
};

struct xdr_ops
{
  // x_getlong
  signed int (*x_getlong)(struct XDR *, signed long int *);
  // x_putlong
  signed int (*x_putlong)(struct XDR *, const signed long int *);
  // x_getbytes
  signed int (*x_getbytes)(struct XDR *, char *, unsigned int);
  // x_putbytes
  signed int (*x_putbytes)(struct XDR *, const char *, unsigned int);
  // x_getpostn
  unsigned int (*x_getpostn)(const struct XDR *);
  // x_setpostn
  signed int (*x_setpostn)(struct XDR *, unsigned int);
  // x_inline
  signed int * (*x_inline)(struct XDR *, unsigned int);
  // x_destroy
  void (*x_destroy)(struct XDR *);
  // x_getint32
  signed int (*x_getint32)(struct XDR *, signed int *);
  // x_putint32
  signed int (*x_putint32)(struct XDR *, const signed int *);
};

struct yy_buffer_state
{
  // yy_input_file
  struct _IO_FILE *yy_input_file;
  // yy_ch_buf
  char *yy_ch_buf;
  // yy_buf_pos
  char *yy_buf_pos;
  // yy_buf_size
  unsigned int yy_buf_size;
  // yy_n_chars
  signed int yy_n_chars;
  // yy_is_our_buffer
  signed int yy_is_our_buffer;
  // yy_is_interactive
  signed int yy_is_interactive;
  // yy_at_bol
  signed int yy_at_bol;
  // yy_fill_buffer
  signed int yy_fill_buffer;
  // yy_buffer_status
  signed int yy_buffer_status;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// LZ4_64Klimit
// file ./../../src/helpers/fst/lz4.c line 421
static const signed int LZ4_64Klimit = 64 * (1 << 10) + ((8 + 4) - 1);
// LZ4_minLength
// file ./../../src/helpers/fst/lz4.c line 303
static const signed int LZ4_minLength = 8 + 4 + 1;
// LZ4_skipTrigger
// file ./../../src/helpers/fst/lz4.c line 422
static const unsigned int LZ4_skipTrigger = (const unsigned int)6;
// anno_ctx
// file stem_recurse.c line 38
struct gtkwave_annotate_ipc_t *anno_ctx = (struct gtkwave_annotate_ipc_t *)(void *)0;
// arraytypes
// file ./../../src/helpers/fst/fstapi.c line 2997
static const char *arraytypes[4l] = { "none", "unpacked", "packed", "sparse" };
// attrtypes
// file ./../../src/helpers/fst/fstapi.c line 2993
static const char *attrtypes[4l] = { "misc", "array", "enum", "class" };
// blue_tag
// file logfile.c line 103
static struct _GtkTextTag *blue_tag = (struct _GtkTextTag *)(void *)0;
// bold_tag
// file logfile.c line 101
static struct _GtkTextTag *bold_tag = (struct _GtkTextTag *)(void *)0;
// cleanup
// file tree_widget.c line 84
static void (*cleanup)(void);
// ctree_main
// file tree_widget.c line 30
struct _GtkCTree *ctree_main = (struct _GtkCTree *)(void *)0;
// dgray_tag
// file logfile.c line 102
static struct _GtkTextTag *dgray_tag = (struct _GtkTextTag *)(void *)0;
// enumvaluetypes
// file ./../../src/helpers/fst/fstapi.c line 3001
static const char *enumvaluetypes[14l] = { "integer", "bit", "logic", "int", "shortint", "longint", "byte", "unsigned_integer", "unsigned_bit", "unsigned_logic", "unsigned_int", "unsigned_shortint", "unsigned_longint", "unsigned_byte" };
// fgetmalloc_len
// file fgetdynamic.c line 29
signed int fgetmalloc_len;
// flattened_mod_list_root
// file stem_recurse.c line 36
struct ds_tree_node *flattened_mod_list_root = (struct ds_tree_node *)(void *)0;
// fontname_logfile
// file logfile.c line 90
static char *fontname_logfile = (char *)(void *)0;
// fontx
// file logfile.c line 97
static struct _GdkFont *fontx = (struct _GdkFont *)(void *)0;
// forward_noskip
// file logfile.c line 461
static signed int forward_noskip = 0;
// fst
// file stem_recurse.c line 41
void *fst = (void *)0;
// fwht_tag
// file logfile.c line 103
static struct _GtkTextTag *fwht_tag = (struct _GtkTextTag *)(void *)0;
// is_active
// file tree_widget.c line 29
static signed int is_active = 0;
// iterx
// file logfile.c line 100
static struct _GtkTextIter iterx;
// lgray_tag
// file logfile.c line 102
static struct _GtkTextTag *lgray_tag = (struct _GtkTextTag *)(void *)0;
// lx2
// file stem_recurse.c line 40
struct lxt2_rd_trace *lx2 = (struct lxt2_rd_trace *)(void *)0;
// lx2vals
// file logfile.c line 1106
static struct jrb_node *lx2vals = (struct jrb_node *)(void *)0;
// matchcase_active
// file logfile.c line 88
static signed int matchcase_active = 0;
// matchcase_checkbutton
// file logfile.c line 87
static struct _GtkWidget *matchcase_checkbutton = (struct _GtkWidget *)(void *)0;
// mod_cnt
// file stem_recurse.c line 34
signed int mod_cnt;
// mod_list
// file stem_recurse.c line 35
struct ds_tree_node **mod_list;
// modtypes
// file ./../../src/helpers/fst/fstapi.c line 2988
static const char *modtypes[22l] = { "module", "task", "function", "begin", "fork", "generate", "struct", "union", "class", "interface", "package", "program", "vhdl_architecture", "vhdl_procedure", "vhdl_function", "vhdl_record", "vhdl_process", "vhdl_block", "vhdl_for_generate", "vhdl_if_generate", "vhdl_generate", "vhdl_package" };
// mono_tag
// file logfile.c line 104
static struct _GtkTextTag *mono_tag = (struct _GtkTextTag *)(void *)0;
// my_yylineno
// file vlex.l line 22
signed int my_yylineno = 0;
// notebook
// file tree_widget.c line 21
struct _GtkWidget *notebook = (struct _GtkWidget *)(void *)0;
// old_marker
// file logfile.c line 32
signed long int old_marker = (signed long int)0;
// old_marker_set
// file logfile.c line 33
unsigned int old_marker_set = (unsigned int)0;
// packtypes
// file ./../../src/helpers/fst/fstapi.c line 3006
static const char *packtypes[4l] = { "none", "unpacked", "packed", "tagged_packed" };
// pressWindow
// file logfile.c line 107
static void *pressWindow = (void *)0;
// pressX
// file logfile.c line 108
static signed int pressX = 0;
// pressY
// file logfile.c line 109
static signed int pressY = 0;
// search_string
// file logfile.c line 451
static char *search_string = (char *)(void *)0;
// selected_text_via_tab
// file logfile.c line 85
static struct text_find_t *selected_text_via_tab = (struct text_find_t *)(void *)0;
// selectedtree
// file tree_widget.c line 27
static struct ds_tree_node *selectedtree = (struct ds_tree_node *)(void *)0;
// size_tag
// file logfile.c line 105
static struct _GtkTextTag *size_tag = (struct _GtkTextTag *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// text_root
// file logfile.c line 84
static struct text_find_t *text_root = (struct text_find_t *)(void *)0;
// timezero
// file stem_recurse.c line 42
signed long int timezero = (signed long int)0;
// tree
// file tree_widget.c line 83
static struct _GtkWidget *tree;
// v_preproc_initialized
// file vlex.l line 29
static signed int v_preproc_initialized = 0;
// v_preproc_name
// file vlex.l line 30
char *v_preproc_name = (char *)(void *)0;
// vartypes
// file ./../../src/helpers/fst/fstapi.c line 2979
static const char *vartypes[30l] = { "event", "integer", "parameter", "real", "real_parameter", "reg", "supply0", "supply1", "time", "tri", "triand", "trior", "trireg", "tri0", "tri1", "wand", "wire", "wor", "port", "sparray", "realtime", "string", "bit", "logic", "int", "shortint", "longint", "byte", "enum", "shortreal" };
// verilog_2005
// file stem_recurse.c line 32
signed int verilog_2005 = 0;
// vzt
// file stem_recurse.c line 39
struct vzt_rd_trace *vzt = (struct vzt_rd_trace *)(void *)0;
// window
// file tree_widget.c line 82
static struct _GtkWidget *window;
// yy_accept
// file vlex.c line 296
static const signed short int yy_accept[599l] = { (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)151, (const signed short int)149, (const signed short int)145, (const signed short int)146, (const signed short int)149, (const signed short int)149, (const signed short int)149, (const signed short int)149, (const signed short int)149, (const signed short int)149, (const signed short int)139, (const signed short int)136, (const signed short int)149, (const signed short int)149, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)4, (const signed short int)6, (const signed short int)5, (const signed short int)5, (const signed short int)5, (const signed short int)131, (const signed short int)132, (const signed short int)145, (const signed short int)0, (const signed short int)148, (const signed short int)135, (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)144, (const signed short int)138, (const signed short int)1, (const signed short int)147, (const signed short int)139, (const signed short int)136, (const signed short int)0, (const signed short int)134, (const signed short int)133, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)33, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)48, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)4, (const signed short int)3, (const signed short int)2, (const signed short int)131, (const signed short int)135, (const signed short int)0, (const signed short int)141, (const signed short int)0, (const signed short int)140, (const signed short int)0, (const signed short int)143, (const signed short int)0, (const signed short int)142, (const signed short int)138, (const signed short int)147, (const signed short int)137, (const signed short int)133, (const signed short int)136, (const signed short int)8, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)11, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)24, (const signed short int)136, (const signed short int)27, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)44, (const signed short int)136, (const signed short int)45, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)60, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)79, (const signed short int)136, (const signed short int)124, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)92, (const signed short int)136, (const signed short int)94, (const signed short int)141, (const signed short int)140, (const signed short int)143, (const signed short int)142, (const signed short int)137, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)14, (const signed short int)104, (const signed short int)17, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)22, (const signed short int)23, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)30, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)38, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)41, (const signed short int)136, (const signed short int)43, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)51, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)58, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)95, (const signed short int)75, (const signed short int)76, (const signed short int)80, (const signed short int)81, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)86, (const signed short int)87, (const signed short int)136, (const signed short int)136, (const signed short int)91, (const signed short int)93, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)10, (const signed short int)136, (const signed short int)15, (const signed short int)16, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)26, (const signed short int)28, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)35, (const signed short int)36, (const signed short int)136, (const signed short int)136, (const signed short int)39, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)53, (const signed short int)54, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)57, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)63, (const signed short int)64, (const signed short int)65, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)69, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)99, (const signed short int)136, (const signed short int)136, (const signed short int)83, (const signed short int)136, (const signed short int)136, (const signed short int)125, (const signed short int)136, (const signed short int)88, (const signed short int)89, (const signed short int)90, (const signed short int)7, (const signed short int)9, (const signed short int)136, (const signed short int)12, (const signed short int)13, (const signed short int)105, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)106, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)114, (const signed short int)31, (const signed short int)32, (const signed short int)109, (const signed short int)110, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)40, (const signed short int)127, (const signed short int)136, (const signed short int)136, (const signed short int)46, (const signed short int)47, (const signed short int)49, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)56, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)62, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)123, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)82, (const signed short int)84, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)19, (const signed short int)136, (const signed short int)21, (const signed short int)25, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)96, (const signed short int)29, (const signed short int)136, (const signed short int)136, (const signed short int)111, (const signed short int)34, (const signed short int)136, (const signed short int)37, (const signed short int)115, (const signed short int)116, (const signed short int)136, (const signed short int)136, (const signed short int)42, (const signed short int)136, (const signed short int)136, (const signed short int)52, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)61, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)101, (const signed short int)136, (const signed short int)71, (const signed short int)72, (const signed short int)73, (const signed short int)74, (const signed short int)77, (const signed short int)78, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)18, (const signed short int)20, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)100, (const signed short int)97, (const signed short int)113, (const signed short int)112, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)55, (const signed short int)136, (const signed short int)59, (const signed short int)66, (const signed short int)67, (const signed short int)68, (const signed short int)136, (const signed short int)136, (const signed short int)121, (const signed short int)85, (const signed short int)103, (const signed short int)107, (const signed short int)136, (const signed short int)136, (const signed short int)129, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)50, (const signed short int)128, (const signed short int)136, (const signed short int)136, (const signed short int)70, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)102, (const signed short int)117, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)98, (const signed short int)108, (const signed short int)136, (const signed short int)126, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)130, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)122, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)118, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)119, (const signed short int)120, (const signed short int)0 };
// yy_base
// file vlex.c line 407
static const signed short int yy_base[617l] = { (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)48, (const signed short int)49, (const signed short int)1320, (const signed short int)1319, (const signed short int)1321, (const signed short int)1324, (const signed short int)51, (const signed short int)1324, (const signed short int)1315, (const signed short int)0, (const signed short int)56, (const signed short int)1309, (const signed short int)0, (const signed short int)52, (const signed short int)52, (const signed short int)1309, (const signed short int)0, (const signed short int)0, (const signed short int)45, (const signed short int)61, (const signed short int)69, (const signed short int)70, (const signed short int)83, (const signed short int)58, (const signed short int)71, (const signed short int)52, (const signed short int)66, (const signed short int)78, (const signed short int)85, (const signed short int)84, (const signed short int)104, (const signed short int)93, (const signed short int)107, (const signed short int)118, (const signed short int)154, (const signed short int)127, (const signed short int)117, (const signed short int)128, (const signed short int)141, (const signed short int)145, (const signed short int)0, (const signed short int)1324, (const signed short int)1307, (const signed short int)1308, (const signed short int)1324, (const signed short int)0, (const signed short int)1324, (const signed short int)113, (const signed short int)1310, (const signed short int)1324, (const signed short int)0, (const signed short int)168, (const signed short int)189, (const signed short int)1312, (const signed short int)195, (const signed short int)1324, (const signed short int)0, (const signed short int)1324, (const signed short int)0, (const signed short int)198, (const signed short int)1304, (const signed short int)0, (const signed short int)0, (const signed short int)0, (const signed short int)119, (const signed short int)112, (const signed short int)122, (const signed short int)99, (const signed short int)123, (const signed short int)142, (const signed short int)177, (const signed short int)131, (const signed short int)184, (const signed short int)180, (const signed short int)195, (const signed short int)185, (const signed short int)204, (const signed short int)187, (const signed short int)196, (const signed short int)205, (const signed short int)130, (const signed short int)213, (const signed short int)214, (const signed short int)218, (const signed short int)220, (const signed short int)223, (const signed short int)206, (const signed short int)228, (const signed short int)222, (const signed short int)230, (const signed short int)232, (const signed short int)225, (const signed short int)233, (const signed short int)235, (const signed short int)224, (const signed short int)237, (const signed short int)238, (const signed short int)1303, (const signed short int)239, (const signed short int)246, (const signed short int)252, (const signed short int)256, (const signed short int)259, (const signed short int)260, (const signed short int)262, (const signed short int)264, (const signed short int)266, (const signed short int)269, (const signed short int)267, (const signed short int)263, (const signed short int)270, (const signed short int)276, (const signed short int)277, (const signed short int)282, (const signed short int)275, (const signed short int)278, (const signed short int)286, (const signed short int)285, (const signed short int)302, (const signed short int)289, (const signed short int)297, (const signed short int)305, (const signed short int)293, (const signed short int)306, (const signed short int)307, (const signed short int)309, (const signed short int)311, (const signed short int)313, (const signed short int)316, (const signed short int)315, (const signed short int)0, (const signed short int)1324, (const signed short int)1324, (const signed short int)0, (const signed short int)0, (const signed short int)336, (const signed short int)348, (const signed short int)362, (const signed short int)354, (const signed short int)1309, (const signed short int)0, (const signed short int)369, (const signed short int)377, (const signed short int)0, (const signed short int)0, (const signed short int)1301, (const signed short int)0, (const signed short int)326, (const signed short int)1300, (const signed short int)328, (const signed short int)321, (const signed short int)335, (const signed short int)345, (const signed short int)374, (const signed short int)340, (const signed short int)378, (const signed short int)376, (const signed short int)383, (const signed short int)388, (const signed short int)384, (const signed short int)385, (const signed short int)386, (const signed short int)393, (const signed short int)421, (const signed short int)394, (const signed short int)404, (const signed short int)322, (const signed short int)401, (const signed short int)391, (const signed short int)396, (const signed short int)406, (const signed short int)397, (const signed short int)399, (const signed short int)400, (const signed short int)411, (const signed short int)428, (const signed short int)403, (const signed short int)419, (const signed short int)429, (const signed short int)413, (const signed short int)437, (const signed short int)439, (const signed short int)441, (const signed short int)317, (const signed short int)445, (const signed short int)447, (const signed short int)1299, (const signed short int)448, (const signed short int)451, (const signed short int)452, (const signed short int)454, (const signed short int)458, (const signed short int)459, (const signed short int)460, (const signed short int)463, (const signed short int)465, (const signed short int)467, (const signed short int)1298, (const signed short int)461, (const signed short int)469, (const signed short int)468, (const signed short int)473, (const signed short int)483, (const signed short int)474, (const signed short int)475, (const signed short int)478, (const signed short int)479, (const signed short int)486, (const signed short int)485, (const signed short int)487, (const signed short int)493, (const signed short int)488, (const signed short int)501, (const signed short int)494, (const signed short int)509, (const signed short int)498, (const signed short int)1297, (const signed short int)503, (const signed short int)506, (const signed short int)510, (const signed short int)514, (const signed short int)517, (const signed short int)518, (const signed short int)527, (const signed short int)1296, (const signed short int)520, (const signed short int)1295, (const signed short int)548, (const signed short int)528, (const signed short int)0, (const signed short int)553, (const signed short int)1294, (const signed short int)525, (const signed short int)529, (const signed short int)535, (const signed short int)528, (const signed short int)537, (const signed short int)538, (const signed short int)1293, (const signed short int)1292, (const signed short int)547, (const signed short int)539, (const signed short int)549, (const signed short int)567, (const signed short int)560, (const signed short int)562, (const signed short int)1291, (const signed short int)1290, (const signed short int)569, (const signed short int)570, (const signed short int)574, (const signed short int)571, (const signed short int)575, (const signed short int)578, (const signed short int)576, (const signed short int)581, (const signed short int)582, (const signed short int)588, (const signed short int)1289, (const signed short int)591, (const signed short int)590, (const signed short int)596, (const signed short int)597, (const signed short int)598, (const signed short int)599, (const signed short int)601, (const signed short int)604, (const signed short int)605, (const signed short int)607, (const signed short int)614, (const signed short int)609, (const signed short int)1288, (const signed short int)612, (const signed short int)611, (const signed short int)617, (const signed short int)615, (const signed short int)618, (const signed short int)619, (const signed short int)620, (const signed short int)1287, (const signed short int)621, (const signed short int)1286, (const signed short int)622, (const signed short int)630, (const signed short int)627, (const signed short int)635, (const signed short int)1285, (const signed short int)639, (const signed short int)644, (const signed short int)654, (const signed short int)645, (const signed short int)646, (const signed short int)647, (const signed short int)650, (const signed short int)651, (const signed short int)658, (const signed short int)660, (const signed short int)661, (const signed short int)662, (const signed short int)665, (const signed short int)672, (const signed short int)670, (const signed short int)671, (const signed short int)675, (const signed short int)673, (const signed short int)676, (const signed short int)1284, (const signed short int)1283, (const signed short int)677, (const signed short int)1282, (const signed short int)1281, (const signed short int)678, (const signed short int)681, (const signed short int)683, (const signed short int)686, (const signed short int)685, (const signed short int)687, (const signed short int)1280, (const signed short int)1279, (const signed short int)710, (const signed short int)695, (const signed short int)1278, (const signed short int)1277, (const signed short int)688, (const signed short int)689, (const signed short int)700, (const signed short int)1276, (const signed short int)721, (const signed short int)1275, (const signed short int)1274, (const signed short int)707, (const signed short int)711, (const signed short int)699, (const signed short int)715, (const signed short int)720, (const signed short int)725, (const signed short int)726, (const signed short int)728, (const signed short int)729, (const signed short int)731, (const signed short int)732, (const signed short int)737, (const signed short int)733, (const signed short int)738, (const signed short int)1273, (const signed short int)1272, (const signed short int)734, (const signed short int)739, (const signed short int)740, (const signed short int)735, (const signed short int)741, (const signed short int)742, (const signed short int)745, (const signed short int)746, (const signed short int)765, (const signed short int)1271, (const signed short int)1270, (const signed short int)747, (const signed short int)749, (const signed short int)1269, (const signed short int)751, (const signed short int)767, (const signed short int)769, (const signed short int)773, (const signed short int)774, (const signed short int)771, (const signed short int)775, (const signed short int)776, (const signed short int)781, (const signed short int)780, (const signed short int)786, (const signed short int)787, (const signed short int)788, (const signed short int)1268, (const signed short int)1267, (const signed short int)789, (const signed short int)779, (const signed short int)790, (const signed short int)1266, (const signed short int)791, (const signed short int)793, (const signed short int)794, (const signed short int)1265, (const signed short int)1264, (const signed short int)796, (const signed short int)795, (const signed short int)805, (const signed short int)797, (const signed short int)1263, (const signed short int)804, (const signed short int)808, (const signed short int)809, (const signed short int)799, (const signed short int)1262, (const signed short int)812, (const signed short int)813, (const signed short int)1261, (const signed short int)818, (const signed short int)806, (const signed short int)1260, (const signed short int)819, (const signed short int)1259, (const signed short int)1258, (const signed short int)1257, (const signed short int)1256, (const signed short int)1255, (const signed short int)830, (const signed short int)1254, (const signed short int)1253, (const signed short int)1252, (const signed short int)831, (const signed short int)835, (const signed short int)838, (const signed short int)1251, (const signed short int)837, (const signed short int)840, (const signed short int)842, (const signed short int)843, (const signed short int)845, (const signed short int)844, (const signed short int)846, (const signed short int)848, (const signed short int)849, (const signed short int)847, (const signed short int)850, (const signed short int)851, (const signed short int)853, (const signed short int)1250, (const signed short int)1249, (const signed short int)1248, (const signed short int)1247, (const signed short int)1246, (const signed short int)857, (const signed short int)856, (const signed short int)860, (const signed short int)859, (const signed short int)863, (const signed short int)868, (const signed short int)869, (const signed short int)871, (const signed short int)1245, (const signed short int)1244, (const signed short int)872, (const signed short int)876, (const signed short int)1243, (const signed short int)1242, (const signed short int)1241, (const signed short int)881, (const signed short int)873, (const signed short int)885, (const signed short int)887, (const signed short int)1240, (const signed short int)889, (const signed short int)890, (const signed short int)891, (const signed short int)1239, (const signed short int)896, (const signed short int)899, (const signed short int)897, (const signed short int)1238, (const signed short int)900, (const signed short int)901, (const signed short int)903, (const signed short int)911, (const signed short int)926, (const signed short int)1232, (const signed short int)1229, (const signed short int)909, (const signed short int)915, (const signed short int)907, (const signed short int)917, (const signed short int)1222, (const signed short int)904, (const signed short int)1221, (const signed short int)1208, (const signed short int)921, (const signed short int)922, (const signed short int)923, (const signed short int)931, (const signed short int)935, (const signed short int)937, (const signed short int)942, (const signed short int)1201, (const signed short int)1200, (const signed short int)938, (const signed short int)943, (const signed short int)1196, (const signed short int)1195, (const signed short int)944, (const signed short int)1194, (const signed short int)1193, (const signed short int)1192, (const signed short int)939, (const signed short int)941, (const signed short int)1186, (const signed short int)949, (const signed short int)948, (const signed short int)1185, (const signed short int)945, (const signed short int)950, (const signed short int)951, (const signed short int)952, (const signed short int)1175, (const signed short int)974, (const signed short int)955, (const signed short int)967, (const signed short int)1167, (const signed short int)953, (const signed short int)1164, (const signed short int)1151, (const signed short int)1150, (const signed short int)1149, (const signed short int)1142, (const signed short int)1127, (const signed short int)958, (const signed short int)979, (const signed short int)971, (const signed short int)1126, (const signed short int)1099, (const signed short int)981, (const signed short int)983, (const signed short int)984, (const signed short int)985, (const signed short int)954, (const signed short int)987, (const signed short int)1098, (const signed short int)1097, (const signed short int)1096, (const signed short int)1095, (const signed short int)988, (const signed short int)992, (const signed short int)993, (const signed short int)994, (const signed short int)995, (const signed short int)1091, (const signed short int)996, (const signed short int)1090, (const signed short int)1089, (const signed short int)1088, (const signed short int)1087, (const signed short int)997, (const signed short int)1000, (const signed short int)1086, (const signed short int)1085, (const signed short int)1084, (const signed short int)1081, (const signed short int)1002, (const signed short int)1003, (const signed short int)1080, (const signed short int)1007, (const signed short int)1010, (const signed short int)1011, (const signed short int)998, (const signed short int)1012, (const signed short int)1071, (const signed short int)1070, (const signed short int)1013, (const signed short int)1014, (const signed short int)1067, (const signed short int)1015, (const signed short int)1020, (const signed short int)1017, (const signed short int)333, (const signed short int)332, (const signed short int)1022, (const signed short int)1025, (const signed short int)1021, (const signed short int)1019, (const signed short int)325, (const signed short int)169, (const signed short int)1030, (const signed short int)168, (const signed short int)1035, (const signed short int)1037, (const signed short int)1039, (const signed short int)167, (const signed short int)1044, (const signed short int)1048, (const signed short int)1049, (const signed short int)1052, (const signed short int)1055, (const signed short int)114, (const signed short int)1057, (const signed short int)1053, (const signed short int)1056, (const signed short int)72, (const signed short int)1059, (const signed short int)1058, (const signed short int)1061, (const signed short int)1062, (const signed short int)1064, (const signed short int)1065, (const signed short int)1066, (const signed short int)60, (const signed short int)59, (const signed short int)1324, (const signed short int)1110, (const signed short int)1121, (const signed short int)1132, (const signed short int)1135, (const signed short int)1138, (const signed short int)1145, (const signed short int)1156, (const signed short int)1159, (const signed short int)1170, (const signed short int)1181, (const signed short int)1188, (const signed short int)1198, (const signed short int)1203, (const signed short int)1214, (const signed short int)1217, (const signed short int)1224, (const signed short int)1228, (const signed short int)1235 };
// yy_c_buf_p
// file vlex.c line 228
static char *yy_c_buf_p = (char *)0;
// yy_chk
// file vlex.c line 706
static const signed short int yy_chk[1375l] = { (const signed short int)0, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)1, (const signed short int)3, (const signed short int)4, (const signed short int)9, (const signed short int)21, (const signed short int)9, (const signed short int)3, (const signed short int)4, (const signed short int)3, (const signed short int)4, (const signed short int)16, (const signed short int)28, (const signed short int)16, (const signed short int)17, (const signed short int)17, (const signed short int)17, (const signed short int)17, (const signed short int)26, (const signed short int)597, (const signed short int)596, (const signed short int)22, (const signed short int)3, (const signed short int)4, (const signed short int)13, (const signed short int)13, (const signed short int)29, (const signed short int)13, (const signed short int)13, (const signed short int)23, (const signed short int)24, (const signed short int)27, (const signed short int)588, (const signed short int)21, (const signed short int)13, (const signed short int)21, (const signed short int)13, (const signed short int)28, (const signed short int)30, (const signed short int)21, (const signed short int)13, (const signed short int)21, (const signed short int)22, (const signed short int)25, (const signed short int)32, (const signed short int)31, (const signed short int)23, (const signed short int)13, (const signed short int)29, (const signed short int)26, (const signed short int)23, (const signed short int)24, (const signed short int)27, (const signed short int)34, (const signed short int)26, (const signed short int)24, (const signed short int)29, (const signed short int)22, (const signed short int)23, (const signed short int)70, (const signed short int)23, (const signed short int)32, (const signed short int)31, (const signed short int)25, (const signed short int)33, (const signed short int)32, (const signed short int)50, (const signed short int)35, (const signed short int)50, (const signed short int)30, (const signed short int)31, (const signed short int)25, (const signed short int)68, (const signed short int)25, (const signed short int)584, (const signed short int)32, (const signed short int)31, (const signed short int)39, (const signed short int)36, (const signed short int)67, (const signed short int)25, (const signed short int)33, (const signed short int)69, (const signed short int)71, (const signed short int)35, (const signed short int)33, (const signed short int)34, (const signed short int)38, (const signed short int)40, (const signed short int)34, (const signed short int)83, (const signed short int)74, (const signed short int)68, (const signed short int)33, (const signed short int)70, (const signed short int)33, (const signed short int)35, (const signed short int)36, (const signed short int)35, (const signed short int)36, (const signed short int)35, (const signed short int)41, (const signed short int)72, (const signed short int)35, (const signed short int)38, (const signed short int)42, (const signed short int)71, (const signed short int)39, (const signed short int)36, (const signed short int)40, (const signed short int)36, (const signed short int)39, (const signed short int)38, (const signed short int)36, (const signed short int)37, (const signed short int)39, (const signed short int)69, (const signed short int)67, (const signed short int)41, (const signed short int)74, (const signed short int)38, (const signed short int)54, (const signed short int)41, (const signed short int)83, (const signed short int)72, (const signed short int)41, (const signed short int)41, (const signed short int)578, (const signed short int)574, (const signed short int)572, (const signed short int)54, (const signed short int)54, (const signed short int)41, (const signed short int)37, (const signed short int)54, (const signed short int)42, (const signed short int)42, (const signed short int)73, (const signed short int)37, (const signed short int)37, (const signed short int)76, (const signed short int)54, (const signed short int)55, (const signed short int)37, (const signed short int)75, (const signed short int)78, (const signed short int)37, (const signed short int)80, (const signed short int)57, (const signed short int)37, (const signed short int)37, (const signed short int)55, (const signed short int)55, (const signed short int)55, (const signed short int)55, (const signed short int)77, (const signed short int)81, (const signed short int)57, (const signed short int)57, (const signed short int)57, (const signed short int)62, (const signed short int)62, (const signed short int)62, (const signed short int)62, (const signed short int)79, (const signed short int)82, (const signed short int)89, (const signed short int)54, (const signed short int)57, (const signed short int)54, (const signed short int)76, (const signed short int)73, (const signed short int)77, (const signed short int)84, (const signed short int)85, (const signed short int)75, (const signed short int)81, (const signed short int)77, (const signed short int)86, (const signed short int)78, (const signed short int)87, (const signed short int)80, (const signed short int)91, (const signed short int)88, (const signed short int)97, (const signed short int)94, (const signed short int)82, (const signed short int)79, (const signed short int)90, (const signed short int)77, (const signed short int)92, (const signed short int)89, (const signed short int)93, (const signed short int)95, (const signed short int)57, (const signed short int)96, (const signed short int)57, (const signed short int)98, (const signed short int)99, (const signed short int)101, (const signed short int)91, (const signed short int)86, (const signed short int)88, (const signed short int)84, (const signed short int)85, (const signed short int)94, (const signed short int)102, (const signed short int)97, (const signed short int)88, (const signed short int)92, (const signed short int)87, (const signed short int)93, (const signed short int)103, (const signed short int)95, (const signed short int)88, (const signed short int)88, (const signed short int)104, (const signed short int)88, (const signed short int)88, (const signed short int)105, (const signed short int)106, (const signed short int)90, (const signed short int)107, (const signed short int)112, (const signed short int)108, (const signed short int)96, (const signed short int)109, (const signed short int)111, (const signed short int)98, (const signed short int)110, (const signed short int)113, (const signed short int)99, (const signed short int)99, (const signed short int)99, (const signed short int)101, (const signed short int)117, (const signed short int)114, (const signed short int)115, (const signed short int)118, (const signed short int)102, (const signed short int)112, (const signed short int)108, (const signed short int)116, (const signed short int)103, (const signed short int)105, (const signed short int)120, (const signed short int)119, (const signed short int)108, (const signed short int)106, (const signed short int)122, (const signed short int)104, (const signed short int)107, (const signed short int)108, (const signed short int)125, (const signed short int)115, (const signed short int)109, (const signed short int)108, (const signed short int)123, (const signed short int)110, (const signed short int)114, (const signed short int)111, (const signed short int)113, (const signed short int)121, (const signed short int)116, (const signed short int)119, (const signed short int)124, (const signed short int)126, (const signed short int)127, (const signed short int)117, (const signed short int)128, (const signed short int)118, (const signed short int)129, (const signed short int)125, (const signed short int)130, (const signed short int)120, (const signed short int)132, (const signed short int)131, (const signed short int)186, (const signed short int)123, (const signed short int)121, (const signed short int)119, (const signed short int)153, (const signed short int)169, (const signed short int)122, (const signed short int)127, (const signed short int)571, (const signed short int)150, (const signed short int)121, (const signed short int)152, (const signed short int)138, (const signed short int)124, (const signed short int)126, (const signed short int)566, (const signed short int)565, (const signed short int)128, (const signed short int)154, (const signed short int)126, (const signed short int)186, (const signed short int)138, (const signed short int)138, (const signed short int)157, (const signed short int)169, (const signed short int)138, (const signed short int)150, (const signed short int)129, (const signed short int)155, (const signed short int)130, (const signed short int)131, (const signed short int)132, (const signed short int)138, (const signed short int)139, (const signed short int)139, (const signed short int)153, (const signed short int)152, (const signed short int)139, (const signed short int)140, (const signed short int)141, (const signed short int)141, (const signed short int)141, (const signed short int)141, (const signed short int)154, (const signed short int)139, (const signed short int)144, (const signed short int)139, (const signed short int)140, (const signed short int)140, (const signed short int)140, (const signed short int)140, (const signed short int)157, (const signed short int)141, (const signed short int)155, (const signed short int)144, (const signed short int)144, (const signed short int)144, (const signed short int)156, (const signed short int)138, (const signed short int)159, (const signed short int)138, (const signed short int)158, (const signed short int)145, (const signed short int)145, (const signed short int)145, (const signed short int)144, (const signed short int)160, (const signed short int)162, (const signed short int)163, (const signed short int)164, (const signed short int)139, (const signed short int)161, (const signed short int)139, (const signed short int)145, (const signed short int)171, (const signed short int)145, (const signed short int)165, (const signed short int)167, (const signed short int)156, (const signed short int)172, (const signed short int)174, (const signed short int)159, (const signed short int)175, (const signed short int)176, (const signed short int)170, (const signed short int)163, (const signed short int)179, (const signed short int)168, (const signed short int)161, (const signed short int)173, (const signed short int)164, (const signed short int)144, (const signed short int)162, (const signed short int)144, (const signed short int)177, (const signed short int)158, (const signed short int)182, (const signed short int)165, (const signed short int)171, (const signed short int)145, (const signed short int)160, (const signed short int)145, (const signed short int)180, (const signed short int)161, (const signed short int)166, (const signed short int)170, (const signed short int)168, (const signed short int)167, (const signed short int)168, (const signed short int)173, (const signed short int)172, (const signed short int)178, (const signed short int)181, (const signed short int)182, (const signed short int)168, (const signed short int)174, (const signed short int)179, (const signed short int)173, (const signed short int)175, (const signed short int)176, (const signed short int)183, (const signed short int)170, (const signed short int)184, (const signed short int)166, (const signed short int)185, (const signed short int)180, (const signed short int)166, (const signed short int)166, (const signed short int)187, (const signed short int)177, (const signed short int)188, (const signed short int)190, (const signed short int)178, (const signed short int)166, (const signed short int)191, (const signed short int)192, (const signed short int)166, (const signed short int)193, (const signed short int)166, (const signed short int)166, (const signed short int)181, (const signed short int)194, (const signed short int)195, (const signed short int)196, (const signed short int)201, (const signed short int)181, (const signed short int)197, (const signed short int)184, (const signed short int)198, (const signed short int)187, (const signed short int)199, (const signed short int)203, (const signed short int)202, (const signed short int)183, (const signed short int)193, (const signed short int)190, (const signed short int)204, (const signed short int)206, (const signed short int)207, (const signed short int)191, (const signed short int)185, (const signed short int)208, (const signed short int)209, (const signed short int)195, (const signed short int)188, (const signed short int)201, (const signed short int)205, (const signed short int)192, (const signed short int)211, (const signed short int)210, (const signed short int)212, (const signed short int)214, (const signed short int)196, (const signed short int)202, (const signed short int)197, (const signed short int)194, (const signed short int)213, (const signed short int)216, (const signed short int)199, (const signed short int)198, (const signed short int)197, (const signed short int)218, (const signed short int)203, (const signed short int)205, (const signed short int)215, (const signed short int)206, (const signed short int)220, (const signed short int)204, (const signed short int)210, (const signed short int)221, (const signed short int)209, (const signed short int)208, (const signed short int)217, (const signed short int)222, (const signed short int)217, (const signed short int)217, (const signed short int)207, (const signed short int)223, (const signed short int)214, (const signed short int)211, (const signed short int)224, (const signed short int)225, (const signed short int)212, (const signed short int)228, (const signed short int)213, (const signed short int)215, (const signed short int)218, (const signed short int)216, (const signed short int)235, (const signed short int)217, (const signed short int)226, (const signed short int)238, (const signed short int)236, (const signed short int)231, (const signed short int)231, (const signed short int)231, (const signed short int)231, (const signed short int)223, (const signed short int)237, (const signed short int)220, (const signed short int)239, (const signed short int)240, (const signed short int)244, (const signed short int)217, (const signed short int)221, (const signed short int)217, (const signed short int)231, (const signed short int)224, (const signed short int)222, (const signed short int)225, (const signed short int)243, (const signed short int)226, (const signed short int)245, (const signed short int)230, (const signed short int)230, (const signed short int)236, (const signed short int)228, (const signed short int)230, (const signed short int)233, (const signed short int)233, (const signed short int)233, (const signed short int)238, (const signed short int)239, (const signed short int)247, (const signed short int)230, (const signed short int)248, (const signed short int)230, (const signed short int)237, (const signed short int)235, (const signed short int)233, (const signed short int)246, (const signed short int)233, (const signed short int)251, (const signed short int)252, (const signed short int)254, (const signed short int)243, (const signed short int)244, (const signed short int)253, (const signed short int)255, (const signed short int)257, (const signed short int)240, (const signed short int)256, (const signed short int)240, (const signed short int)248, (const signed short int)258, (const signed short int)259, (const signed short int)247, (const signed short int)246, (const signed short int)245, (const signed short int)251, (const signed short int)230, (const signed short int)260, (const signed short int)230, (const signed short int)263, (const signed short int)262, (const signed short int)233, (const signed short int)257, (const signed short int)233, (const signed short int)253, (const signed short int)264, (const signed short int)265, (const signed short int)266, (const signed short int)267, (const signed short int)251, (const signed short int)268, (const signed short int)254, (const signed short int)259, (const signed short int)269, (const signed short int)270, (const signed short int)252, (const signed short int)271, (const signed short int)255, (const signed short int)273, (const signed short int)256, (const signed short int)276, (const signed short int)275, (const signed short int)264, (const signed short int)272, (const signed short int)278, (const signed short int)258, (const signed short int)277, (const signed short int)279, (const signed short int)280, (const signed short int)281, (const signed short int)283, (const signed short int)285, (const signed short int)263, (const signed short int)267, (const signed short int)260, (const signed short int)262, (const signed short int)287, (const signed short int)266, (const signed short int)269, (const signed short int)286, (const signed short int)272, (const signed short int)273, (const signed short int)275, (const signed short int)277, (const signed short int)288, (const signed short int)276, (const signed short int)268, (const signed short int)265, (const signed short int)290, (const signed short int)270, (const signed short int)283, (const signed short int)271, (const signed short int)278, (const signed short int)291, (const signed short int)293, (const signed short int)294, (const signed short int)295, (const signed short int)281, (const signed short int)279, (const signed short int)296, (const signed short int)297, (const signed short int)286, (const signed short int)285, (const signed short int)292, (const signed short int)280, (const signed short int)292, (const signed short int)292, (const signed short int)298, (const signed short int)290, (const signed short int)299, (const signed short int)300, (const signed short int)301, (const signed short int)287, (const signed short int)288, (const signed short int)302, (const signed short int)293, (const signed short int)296, (const signed short int)297, (const signed short int)291, (const signed short int)304, (const signed short int)305, (const signed short int)303, (const signed short int)307, (const signed short int)292, (const signed short int)306, (const signed short int)308, (const signed short int)311, (const signed short int)314, (const signed short int)301, (const signed short int)294, (const signed short int)315, (const signed short int)295, (const signed short int)316, (const signed short int)302, (const signed short int)318, (const signed short int)317, (const signed short int)319, (const signed short int)326, (const signed short int)327, (const signed short int)292, (const signed short int)300, (const signed short int)298, (const signed short int)303, (const signed short int)299, (const signed short int)323, (const signed short int)305, (const signed short int)308, (const signed short int)304, (const signed short int)335, (const signed short int)328, (const signed short int)307, (const signed short int)311, (const signed short int)305, (const signed short int)316, (const signed short int)306, (const signed short int)318, (const signed short int)333, (const signed short int)314, (const signed short int)317, (const signed short int)322, (const signed short int)334, (const signed short int)322, (const signed short int)322, (const signed short int)315, (const signed short int)336, (const signed short int)323, (const signed short int)328, (const signed short int)319, (const signed short int)327, (const signed short int)337, (const signed short int)330, (const signed short int)326, (const signed short int)330, (const signed short int)330, (const signed short int)338, (const signed short int)339, (const signed short int)335, (const signed short int)340, (const signed short int)341, (const signed short int)333, (const signed short int)342, (const signed short int)343, (const signed short int)345, (const signed short int)349, (const signed short int)352, (const signed short int)334, (const signed short int)344, (const signed short int)346, (const signed short int)350, (const signed short int)351, (const signed short int)353, (const signed short int)354, (const signed short int)353, (const signed short int)353, (const signed short int)355, (const signed short int)356, (const signed short int)360, (const signed short int)336, (const signed short int)361, (const signed short int)337, (const signed short int)363, (const signed short int)343, (const signed short int)338, (const signed short int)345, (const signed short int)349, (const signed short int)346, (const signed short int)351, (const signed short int)340, (const signed short int)341, (const signed short int)339, (const signed short int)342, (const signed short int)344, (const signed short int)354, (const signed short int)350, (const signed short int)357, (const signed short int)356, (const signed short int)364, (const signed short int)352, (const signed short int)365, (const signed short int)361, (const signed short int)368, (const signed short int)346, (const signed short int)366, (const signed short int)367, (const signed short int)369, (const signed short int)370, (const signed short int)360, (const signed short int)355, (const signed short int)379, (const signed short int)372, (const signed short int)371, (const signed short int)357, (const signed short int)371, (const signed short int)371, (const signed short int)363, (const signed short int)373, (const signed short int)374, (const signed short int)375, (const signed short int)378, (const signed short int)380, (const signed short int)382, (const signed short int)368, (const signed short int)383, (const signed short int)384, (const signed short int)388, (const signed short int)387, (const signed short int)390, (const signed short int)369, (const signed short int)395, (const signed short int)364, (const signed short int)365, (const signed short int)366, (const signed short int)367, (const signed short int)392, (const signed short int)389, (const signed short int)401, (const signed short int)373, (const signed short int)393, (const signed short int)394, (const signed short int)374, (const signed short int)379, (const signed short int)397, (const signed short int)398, (const signed short int)370, (const signed short int)372, (const signed short int)382, (const signed short int)390, (const signed short int)400, (const signed short int)403, (const signed short int)378, (const signed short int)387, (const signed short int)389, (const signed short int)375, (const signed short int)380, (const signed short int)393, (const signed short int)392, (const signed short int)383, (const signed short int)388, (const signed short int)384, (const signed short int)409, (const signed short int)413, (const signed short int)394, (const signed short int)398, (const signed short int)397, (const signed short int)414, (const signed short int)401, (const signed short int)417, (const signed short int)415, (const signed short int)395, (const signed short int)418, (const signed short int)400, (const signed short int)419, (const signed short int)420, (const signed short int)422, (const signed short int)421, (const signed short int)423, (const signed short int)426, (const signed short int)424, (const signed short int)425, (const signed short int)427, (const signed short int)428, (const signed short int)403, (const signed short int)429, (const signed short int)413, (const signed short int)415, (const signed short int)436, (const signed short int)435, (const signed short int)417, (const signed short int)438, (const signed short int)437, (const signed short int)418, (const signed short int)420, (const signed short int)439, (const signed short int)419, (const signed short int)409, (const signed short int)421, (const signed short int)424, (const signed short int)440, (const signed short int)441, (const signed short int)414, (const signed short int)442, (const signed short int)445, (const signed short int)451, (const signed short int)426, (const signed short int)423, (const signed short int)446, (const signed short int)425, (const signed short int)435, (const signed short int)437, (const signed short int)422, (const signed short int)450, (const signed short int)428, (const signed short int)427, (const signed short int)436, (const signed short int)452, (const signed short int)441, (const signed short int)453, (const signed short int)429, (const signed short int)455, (const signed short int)456, (const signed short int)457, (const signed short int)438, (const signed short int)445, (const signed short int)451, (const signed short int)446, (const signed short int)459, (const signed short int)461, (const signed short int)439, (const signed short int)460, (const signed short int)463, (const signed short int)464, (const signed short int)442, (const signed short int)465, (const signed short int)475, (const signed short int)465, (const signed short int)465, (const signed short int)472, (const signed short int)440, (const signed short int)470, (const signed short int)452, (const signed short int)466, (const signed short int)457, (const signed short int)466, (const signed short int)466, (const signed short int)471, (const signed short int)450, (const signed short int)473, (const signed short int)459, (const signed short int)456, (const signed short int)460, (const signed short int)478, (const signed short int)479, (const signed short int)480, (const signed short int)455, (const signed short int)453, (const signed short int)467, (const signed short int)461, (const signed short int)467, (const signed short int)467, (const signed short int)470, (const signed short int)481, (const signed short int)472, (const signed short int)475, (const signed short int)464, (const signed short int)482, (const signed short int)471, (const signed short int)483, (const signed short int)487, (const signed short int)495, (const signed short int)463, (const signed short int)496, (const signed short int)484, (const signed short int)488, (const signed short int)491, (const signed short int)501, (const signed short int)478, (const signed short int)473, (const signed short int)499, (const signed short int)498, (const signed short int)502, (const signed short int)503, (const signed short int)504, (const signed short int)510, (const signed short int)526, (const signed short int)507, (const signed short int)480, (const signed short int)479, (const signed short int)517, (const signed short int)481, (const signed short int)482, (const signed short int)496, (const signed short int)483, (const signed short int)484, (const signed short int)488, (const signed short int)491, (const signed short int)498, (const signed short int)508, (const signed short int)487, (const signed short int)499, (const signed short int)510, (const signed short int)519, (const signed short int)495, (const signed short int)504, (const signed short int)506, (const signed short int)507, (const signed short int)506, (const signed short int)506, (const signed short int)517, (const signed short int)518, (const signed short int)502, (const signed short int)522, (const signed short int)501, (const signed short int)523, (const signed short int)524, (const signed short int)525, (const signed short int)508, (const signed short int)527, (const signed short int)532, (const signed short int)526, (const signed short int)519, (const signed short int)503, (const signed short int)533, (const signed short int)534, (const signed short int)535, (const signed short int)536, (const signed short int)538, (const signed short int)543, (const signed short int)555, (const signed short int)518, (const signed short int)544, (const signed short int)524, (const signed short int)549, (const signed short int)550, (const signed short int)522, (const signed short int)532, (const signed short int)525, (const signed short int)552, (const signed short int)523, (const signed short int)527, (const signed short int)553, (const signed short int)554, (const signed short int)556, (const signed short int)559, (const signed short int)560, (const signed short int)562, (const signed short int)536, (const signed short int)564, (const signed short int)543, (const signed short int)570, (const signed short int)563, (const signed short int)569, (const signed short int)567, (const signed short int)534, (const signed short int)538, (const signed short int)568, (const signed short int)555, (const signed short int)535, (const signed short int)533, (const signed short int)544, (const signed short int)573, (const signed short int)556, (const signed short int)552, (const signed short int)549, (const signed short int)559, (const signed short int)575, (const signed short int)569, (const signed short int)576, (const signed short int)550, (const signed short int)577, (const signed short int)554, (const signed short int)563, (const signed short int)560, (const signed short int)567, (const signed short int)579, (const signed short int)562, (const signed short int)568, (const signed short int)570, (const signed short int)580, (const signed short int)581, (const signed short int)553, (const signed short int)573, (const signed short int)582, (const signed short int)586, (const signed short int)564, (const signed short int)583, (const signed short int)587, (const signed short int)585, (const signed short int)590, (const signed short int)589, (const signed short int)577, (const signed short int)591, (const signed short int)592, (const signed short int)575, (const signed short int)593, (const signed short int)594, (const signed short int)595, (const signed short int)561, (const signed short int)576, (const signed short int)581, (const signed short int)558, (const signed short int)557, (const signed short int)579, (const signed short int)582, (const signed short int)586, (const signed short int)583, (const signed short int)583, (const signed short int)585, (const signed short int)580, (const signed short int)590, (const signed short int)551, (const signed short int)548, (const signed short int)591, (const signed short int)593, (const signed short int)547, (const signed short int)546, (const signed short int)545, (const signed short int)542, (const signed short int)541, (const signed short int)540, (const signed short int)539, (const signed short int)537, (const signed short int)592, (const signed short int)587, (const signed short int)589, (const signed short int)531, (const signed short int)530, (const signed short int)529, (const signed short int)528, (const signed short int)521, (const signed short int)594, (const signed short int)595, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)599, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)600, (const signed short int)601, (const signed short int)601, (const signed short int)520, (const signed short int)516, (const signed short int)601, (const signed short int)601, (const signed short int)601, (const signed short int)601, (const signed short int)601, (const signed short int)601, (const signed short int)601, (const signed short int)602, (const signed short int)602, (const signed short int)602, (const signed short int)603, (const signed short int)603, (const signed short int)603, (const signed short int)604, (const signed short int)515, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)605, (const signed short int)514, (const signed short int)513, (const signed short int)512, (const signed short int)605, (const signed short int)605, (const signed short int)605, (const signed short int)605, (const signed short int)605, (const signed short int)605, (const signed short int)605, (const signed short int)606, (const signed short int)606, (const signed short int)606, (const signed short int)607, (const signed short int)607, (const signed short int)511, (const signed short int)607, (const signed short int)607, (const signed short int)509, (const signed short int)607, (const signed short int)607, (const signed short int)607, (const signed short int)607, (const signed short int)607, (const signed short int)608, (const signed short int)608, (const signed short int)505, (const signed short int)608, (const signed short int)608, (const signed short int)608, (const signed short int)608, (const signed short int)608, (const signed short int)608, (const signed short int)608, (const signed short int)608, (const signed short int)609, (const signed short int)500, (const signed short int)497, (const signed short int)609, (const signed short int)609, (const signed short int)609, (const signed short int)609, (const signed short int)610, (const signed short int)494, (const signed short int)493, (const signed short int)492, (const signed short int)490, (const signed short int)489, (const signed short int)610, (const signed short int)610, (const signed short int)611, (const signed short int)486, (const signed short int)485, (const signed short int)611, (const signed short int)611, (const signed short int)611, (const signed short int)611, (const signed short int)612, (const signed short int)612, (const signed short int)477, (const signed short int)612, (const signed short int)612, (const signed short int)612, (const signed short int)612, (const signed short int)612, (const signed short int)612, (const signed short int)612, (const signed short int)612, (const signed short int)613, (const signed short int)613, (const signed short int)613, (const signed short int)614, (const signed short int)476, (const signed short int)474, (const signed short int)614, (const signed short int)614, (const signed short int)614, (const signed short int)614, (const signed short int)615, (const signed short int)615, (const signed short int)469, (const signed short int)615, (const signed short int)616, (const signed short int)468, (const signed short int)616, (const signed short int)616, (const signed short int)616, (const signed short int)616, (const signed short int)616, (const signed short int)462, (const signed short int)458, (const signed short int)454, (const signed short int)449, (const signed short int)448, (const signed short int)447, (const signed short int)444, (const signed short int)443, (const signed short int)434, (const signed short int)433, (const signed short int)432, (const signed short int)431, (const signed short int)430, (const signed short int)416, (const signed short int)412, (const signed short int)411, (const signed short int)410, (const signed short int)408, (const signed short int)407, (const signed short int)406, (const signed short int)405, (const signed short int)404, (const signed short int)402, (const signed short int)399, (const signed short int)396, (const signed short int)391, (const signed short int)386, (const signed short int)385, (const signed short int)381, (const signed short int)377, (const signed short int)376, (const signed short int)362, (const signed short int)359, (const signed short int)358, (const signed short int)348, (const signed short int)347, (const signed short int)332, (const signed short int)331, (const signed short int)329, (const signed short int)325, (const signed short int)324, (const signed short int)321, (const signed short int)320, (const signed short int)313, (const signed short int)312, (const signed short int)310, (const signed short int)309, (const signed short int)289, (const signed short int)284, (const signed short int)282, (const signed short int)274, (const signed short int)261, (const signed short int)250, (const signed short int)249, (const signed short int)242, (const signed short int)241, (const signed short int)234, (const signed short int)229, (const signed short int)227, (const signed short int)219, (const signed short int)200, (const signed short int)189, (const signed short int)151, (const signed short int)148, (const signed short int)142, (const signed short int)100, (const signed short int)63, (const signed short int)56, (const signed short int)51, (const signed short int)46, (const signed short int)45, (const signed short int)18, (const signed short int)14, (const signed short int)11, (const signed short int)7, (const signed short int)6, (const signed short int)5, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598 };
// yy_current_buffer
// file vlex.c line 210
static struct yy_buffer_state *yy_current_buffer = ((struct yy_buffer_state *)NULL);
// yy_def
// file vlex.c line 479
static const signed short int yy_def[617l] = { (const signed short int)0, (const signed short int)598, (const signed short int)1, (const signed short int)599, (const signed short int)599, (const signed short int)600, (const signed short int)600, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)601, (const signed short int)602, (const signed short int)598, (const signed short int)598, (const signed short int)603, (const signed short int)598, (const signed short int)598, (const signed short int)604, (const signed short int)605, (const signed short int)606, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)607, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)608, (const signed short int)598, (const signed short int)598, (const signed short int)601, (const signed short int)598, (const signed short int)609, (const signed short int)598, (const signed short int)598, (const signed short int)610, (const signed short int)598, (const signed short int)598, (const signed short int)611, (const signed short int)598, (const signed short int)612, (const signed short int)598, (const signed short int)604, (const signed short int)613, (const signed short int)605, (const signed short int)614, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)607, (const signed short int)598, (const signed short int)598, (const signed short int)608, (const signed short int)609, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)610, (const signed short int)615, (const signed short int)598, (const signed short int)598, (const signed short int)611, (const signed short int)612, (const signed short int)616, (const signed short int)614, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)598, (const signed short int)598, (const signed short int)615, (const signed short int)598, (const signed short int)616, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)604, (const signed short int)0, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598 };
// yy_did_buffer_switch_on_eof
// file vlex.c line 235
static signed int yy_did_buffer_switch_on_eof;
// yy_ec
// file vlex.c line 366
static const signed int yy_ec[256l] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 5, 1, 6, 1, 1, 7, 1, 1, 8, 1, 1, 1, 9, 10, 11, 12, 13, 13, 13, 13, 13, 13, 14, 14, 1, 1, 1, 1, 1, 15, 1, 16, 17, 16, 18, 16, 16, 19, 20, 19, 19, 19, 19, 19, 19, 21, 19, 19, 19, 19, 19, 19, 19, 19, 22, 19, 22, 1, 23, 1, 1, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 19, 42, 43, 44, 45, 46, 47, 48, 49, 50, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
// yy_hold_char
// file vlex.c line 220
static char yy_hold_char;
// yy_init
// file vlex.c line 229
static signed int yy_init = 1;
// yy_last_accepting_cpos
// file vlex.c line 862
static char *yy_last_accepting_cpos;
// yy_last_accepting_state
// file vlex.c line 861
static signed int yy_last_accepting_state;
// yy_meta
// file vlex.c line 398
static const signed int yy_meta[51l] = { 0, 1, 2, 3, 4, 1, 5, 1, 6, 7, 6, 8, 8, 8, 8, 1, 9, 9, 9, 10, 10, 10, 9, 6, 11, 1, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 9 };
// yy_n_chars
// file vlex.c line 222
static signed int yy_n_chars;
// yy_nxt
// file vlex.c line 551
static const signed short int yy_nxt[1375l] = { (const signed short int)0, (const signed short int)8, (const signed short int)9, (const signed short int)10, (const signed short int)9, (const signed short int)11, (const signed short int)12, (const signed short int)13, (const signed short int)14, (const signed short int)15, (const signed short int)16, (const signed short int)17, (const signed short int)17, (const signed short int)17, (const signed short int)17, (const signed short int)8, (const signed short int)18, (const signed short int)18, (const signed short int)18, (const signed short int)18, (const signed short int)18, (const signed short int)18, (const signed short int)18, (const signed short int)19, (const signed short int)18, (const signed short int)20, (const signed short int)21, (const signed short int)22, (const signed short int)23, (const signed short int)24, (const signed short int)25, (const signed short int)26, (const signed short int)27, (const signed short int)28, (const signed short int)29, (const signed short int)30, (const signed short int)18, (const signed short int)31, (const signed short int)32, (const signed short int)33, (const signed short int)34, (const signed short int)35, (const signed short int)36, (const signed short int)37, (const signed short int)38, (const signed short int)39, (const signed short int)40, (const signed short int)41, (const signed short int)42, (const signed short int)18, (const signed short int)18, (const signed short int)44, (const signed short int)44, (const signed short int)50, (const signed short int)64, (const signed short int)50, (const signed short int)45, (const signed short int)45, (const signed short int)46, (const signed short int)46, (const signed short int)60, (const signed short int)64, (const signed short int)61, (const signed short int)62, (const signed short int)62, (const signed short int)62, (const signed short int)62, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)47, (const signed short int)47, (const signed short int)54, (const signed short int)55, (const signed short int)64, (const signed short int)56, (const signed short int)57, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)67, (const signed short int)54, (const signed short int)68, (const signed short int)55, (const signed short int)86, (const signed short int)64, (const signed short int)69, (const signed short int)56, (const signed short int)70, (const signed short int)71, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)73, (const signed short int)57, (const signed short int)87, (const signed short int)83, (const signed short int)74, (const signed short int)77, (const signed short int)85, (const signed short int)64, (const signed short int)84, (const signed short int)78, (const signed short int)88, (const signed short int)72, (const signed short int)75, (const signed short int)64, (const signed short int)76, (const signed short int)93, (const signed short int)90, (const signed short int)79, (const signed short int)64, (const signed short int)94, (const signed short int)50, (const signed short int)64, (const signed short int)50, (const signed short int)89, (const signed short int)91, (const signed short int)80, (const signed short int)64, (const signed short int)81, (const signed short int)64, (const signed short int)95, (const signed short int)92, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)82, (const signed short int)96, (const signed short int)64, (const signed short int)64, (const signed short int)102, (const signed short int)97, (const signed short int)100, (const signed short int)64, (const signed short int)64, (const signed short int)101, (const signed short int)64, (const signed short int)64, (const signed short int)151, (const signed short int)98, (const signed short int)153, (const signed short int)99, (const signed short int)103, (const signed short int)107, (const signed short int)104, (const signed short int)108, (const signed short int)105, (const signed short int)64, (const signed short int)64, (const signed short int)106, (const signed short int)119, (const signed short int)64, (const signed short int)154, (const signed short int)122, (const signed short int)109, (const signed short int)125, (const signed short int)110, (const signed short int)123, (const signed short int)120, (const signed short int)111, (const signed short int)64, (const signed short int)124, (const signed short int)152, (const signed short int)150, (const signed short int)126, (const signed short int)157, (const signed short int)121, (const signed short int)138, (const signed short int)127, (const signed short int)168, (const signed short int)155, (const signed short int)128, (const signed short int)129, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)139, (const signed short int)139, (const signed short int)130, (const signed short int)112, (const signed short int)139, (const signed short int)131, (const signed short int)132, (const signed short int)64, (const signed short int)113, (const signed short int)114, (const signed short int)64, (const signed short int)139, (const signed short int)140, (const signed short int)115, (const signed short int)64, (const signed short int)64, (const signed short int)116, (const signed short int)64, (const signed short int)144, (const signed short int)117, (const signed short int)118, (const signed short int)141, (const signed short int)141, (const signed short int)141, (const signed short int)141, (const signed short int)64, (const signed short int)64, (const signed short int)145, (const signed short int)145, (const signed short int)145, (const signed short int)62, (const signed short int)62, (const signed short int)62, (const signed short int)62, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)139, (const signed short int)145, (const signed short int)139, (const signed short int)159, (const signed short int)156, (const signed short int)160, (const signed short int)64, (const signed short int)64, (const signed short int)158, (const signed short int)166, (const signed short int)161, (const signed short int)64, (const signed short int)163, (const signed short int)64, (const signed short int)165, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)167, (const signed short int)164, (const signed short int)64, (const signed short int)162, (const signed short int)64, (const signed short int)179, (const signed short int)64, (const signed short int)64, (const signed short int)145, (const signed short int)64, (const signed short int)145, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)181, (const signed short int)171, (const signed short int)173, (const signed short int)169, (const signed short int)170, (const signed short int)184, (const signed short int)64, (const signed short int)187, (const signed short int)174, (const signed short int)182, (const signed short int)172, (const signed short int)183, (const signed short int)64, (const signed short int)185, (const signed short int)175, (const signed short int)176, (const signed short int)64, (const signed short int)177, (const signed short int)178, (const signed short int)64, (const signed short int)64, (const signed short int)180, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)186, (const signed short int)64, (const signed short int)64, (const signed short int)188, (const signed short int)64, (const signed short int)64, (const signed short int)189, (const signed short int)190, (const signed short int)191, (const signed short int)192, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)193, (const signed short int)206, (const signed short int)199, (const signed short int)64, (const signed short int)194, (const signed short int)196, (const signed short int)64, (const signed short int)64, (const signed short int)200, (const signed short int)197, (const signed short int)64, (const signed short int)195, (const signed short int)198, (const signed short int)201, (const signed short int)64, (const signed short int)209, (const signed short int)203, (const signed short int)202, (const signed short int)64, (const signed short int)204, (const signed short int)208, (const signed short int)205, (const signed short int)207, (const signed short int)64, (const signed short int)210, (const signed short int)213, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)211, (const signed short int)64, (const signed short int)212, (const signed short int)64, (const signed short int)221, (const signed short int)64, (const signed short int)215, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)219, (const signed short int)216, (const signed short int)214, (const signed short int)64, (const signed short int)64, (const signed short int)218, (const signed short int)224, (const signed short int)64, (const signed short int)64, (const signed short int)217, (const signed short int)64, (const signed short int)138, (const signed short int)220, (const signed short int)222, (const signed short int)64, (const signed short int)64, (const signed short int)225, (const signed short int)64, (const signed short int)223, (const signed short int)282, (const signed short int)139, (const signed short int)139, (const signed short int)64, (const signed short int)262, (const signed short int)139, (const signed short int)235, (const signed short int)226, (const signed short int)64, (const signed short int)227, (const signed short int)228, (const signed short int)229, (const signed short int)139, (const signed short int)230, (const signed short int)230, (const signed short int)237, (const signed short int)236, (const signed short int)230, (const signed short int)140, (const signed short int)231, (const signed short int)231, (const signed short int)231, (const signed short int)231, (const signed short int)238, (const signed short int)230, (const signed short int)144, (const signed short int)230, (const signed short int)141, (const signed short int)141, (const signed short int)141, (const signed short int)141, (const signed short int)241, (const signed short int)231, (const signed short int)239, (const signed short int)145, (const signed short int)145, (const signed short int)145, (const signed short int)64, (const signed short int)139, (const signed short int)64, (const signed short int)139, (const signed short int)64, (const signed short int)233, (const signed short int)233, (const signed short int)233, (const signed short int)145, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)230, (const signed short int)64, (const signed short int)230, (const signed short int)233, (const signed short int)64, (const signed short int)233, (const signed short int)64, (const signed short int)64, (const signed short int)240, (const signed short int)64, (const signed short int)64, (const signed short int)243, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)248, (const signed short int)64, (const signed short int)64, (const signed short int)245, (const signed short int)64, (const signed short int)249, (const signed short int)145, (const signed short int)247, (const signed short int)145, (const signed short int)64, (const signed short int)242, (const signed short int)64, (const signed short int)250, (const signed short int)265, (const signed short int)233, (const signed short int)244, (const signed short int)233, (const signed short int)64, (const signed short int)246, (const signed short int)64, (const signed short int)263, (const signed short int)259, (const signed short int)258, (const signed short int)260, (const signed short int)267, (const signed short int)266, (const signed short int)64, (const signed short int)64, (const signed short int)278, (const signed short int)261, (const signed short int)269, (const signed short int)274, (const signed short int)268, (const signed short int)270, (const signed short int)271, (const signed short int)64, (const signed short int)264, (const signed short int)64, (const signed short int)251, (const signed short int)64, (const signed short int)275, (const signed short int)252, (const signed short int)253, (const signed short int)64, (const signed short int)272, (const signed short int)64, (const signed short int)64, (const signed short int)273, (const signed short int)254, (const signed short int)64, (const signed short int)64, (const signed short int)255, (const signed short int)64, (const signed short int)256, (const signed short int)257, (const signed short int)276, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)277, (const signed short int)64, (const signed short int)280, (const signed short int)64, (const signed short int)283, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)279, (const signed short int)288, (const signed short int)285, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)286, (const signed short int)281, (const signed short int)64, (const signed short int)64, (const signed short int)290, (const signed short int)284, (const signed short int)296, (const signed short int)64, (const signed short int)287, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)291, (const signed short int)297, (const signed short int)292, (const signed short int)289, (const signed short int)64, (const signed short int)64, (const signed short int)295, (const signed short int)294, (const signed short int)293, (const signed short int)64, (const signed short int)298, (const signed short int)300, (const signed short int)64, (const signed short int)301, (const signed short int)64, (const signed short int)299, (const signed short int)305, (const signed short int)64, (const signed short int)304, (const signed short int)303, (const signed short int)64, (const signed short int)64, (const signed short int)312, (const signed short int)313, (const signed short int)302, (const signed short int)64, (const signed short int)309, (const signed short int)306, (const signed short int)64, (const signed short int)64, (const signed short int)307, (const signed short int)64, (const signed short int)308, (const signed short int)310, (const signed short int)317, (const signed short int)311, (const signed short int)64, (const signed short int)314, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)231, (const signed short int)231, (const signed short int)231, (const signed short int)231, (const signed short int)321, (const signed short int)64, (const signed short int)318, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)315, (const signed short int)319, (const signed short int)316, (const signed short int)231, (const signed short int)322, (const signed short int)320, (const signed short int)323, (const signed short int)64, (const signed short int)324, (const signed short int)64, (const signed short int)230, (const signed short int)230, (const signed short int)327, (const signed short int)325, (const signed short int)230, (const signed short int)233, (const signed short int)233, (const signed short int)233, (const signed short int)329, (const signed short int)330, (const signed short int)64, (const signed short int)230, (const signed short int)64, (const signed short int)230, (const signed short int)328, (const signed short int)326, (const signed short int)233, (const signed short int)64, (const signed short int)233, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)333, (const signed short int)334, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)331, (const signed short int)64, (const signed short int)332, (const signed short int)338, (const signed short int)64, (const signed short int)64, (const signed short int)337, (const signed short int)336, (const signed short int)335, (const signed short int)339, (const signed short int)230, (const signed short int)64, (const signed short int)230, (const signed short int)64, (const signed short int)64, (const signed short int)233, (const signed short int)346, (const signed short int)233, (const signed short int)342, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)340, (const signed short int)64, (const signed short int)343, (const signed short int)348, (const signed short int)64, (const signed short int)64, (const signed short int)341, (const signed short int)64, (const signed short int)344, (const signed short int)64, (const signed short int)345, (const signed short int)64, (const signed short int)64, (const signed short int)352, (const signed short int)64, (const signed short int)64, (const signed short int)347, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)351, (const signed short int)355, (const signed short int)349, (const signed short int)350, (const signed short int)64, (const signed short int)354, (const signed short int)357, (const signed short int)64, (const signed short int)360, (const signed short int)361, (const signed short int)362, (const signed short int)364, (const signed short int)64, (const signed short int)363, (const signed short int)356, (const signed short int)353, (const signed short int)64, (const signed short int)358, (const signed short int)369, (const signed short int)359, (const signed short int)365, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)368, (const signed short int)366, (const signed short int)64, (const signed short int)64, (const signed short int)371, (const signed short int)370, (const signed short int)64, (const signed short int)367, (const signed short int)376, (const signed short int)377, (const signed short int)64, (const signed short int)374, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)372, (const signed short int)373, (const signed short int)64, (const signed short int)380, (const signed short int)383, (const signed short int)384, (const signed short int)375, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)378, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)388, (const signed short int)381, (const signed short int)64, (const signed short int)382, (const signed short int)64, (const signed short int)389, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)379, (const signed short int)387, (const signed short int)385, (const signed short int)390, (const signed short int)386, (const signed short int)64, (const signed short int)392, (const signed short int)396, (const signed short int)391, (const signed short int)64, (const signed short int)64, (const signed short int)395, (const signed short int)397, (const signed short int)393, (const signed short int)400, (const signed short int)394, (const signed short int)402, (const signed short int)64, (const signed short int)398, (const signed short int)401, (const signed short int)64, (const signed short int)64, (const signed short int)404, (const signed short int)405, (const signed short int)399, (const signed short int)64, (const signed short int)406, (const signed short int)409, (const signed short int)403, (const signed short int)408, (const signed short int)64, (const signed short int)64, (const signed short int)407, (const signed short int)410, (const signed short int)411, (const signed short int)64, (const signed short int)64, (const signed short int)414, (const signed short int)64, (const signed short int)64, (const signed short int)412, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)413, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)431, (const signed short int)432, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)415, (const signed short int)64, (const signed short int)416, (const signed short int)64, (const signed short int)422, (const signed short int)417, (const signed short int)424, (const signed short int)427, (const signed short int)425, (const signed short int)429, (const signed short int)419, (const signed short int)420, (const signed short int)418, (const signed short int)421, (const signed short int)423, (const signed short int)433, (const signed short int)428, (const signed short int)64, (const signed short int)435, (const signed short int)64, (const signed short int)430, (const signed short int)64, (const signed short int)438, (const signed short int)64, (const signed short int)426, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)437, (const signed short int)434, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)436, (const signed short int)447, (const signed short int)448, (const signed short int)439, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)444, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)445, (const signed short int)64, (const signed short int)440, (const signed short int)441, (const signed short int)442, (const signed short int)443, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)450, (const signed short int)64, (const signed short int)64, (const signed short int)451, (const signed short int)454, (const signed short int)64, (const signed short int)64, (const signed short int)446, (const signed short int)449, (const signed short int)456, (const signed short int)462, (const signed short int)64, (const signed short int)64, (const signed short int)453, (const signed short int)459, (const signed short int)461, (const signed short int)452, (const signed short int)455, (const signed short int)464, (const signed short int)463, (const signed short int)457, (const signed short int)460, (const signed short int)458, (const signed short int)64, (const signed short int)64, (const signed short int)465, (const signed short int)468, (const signed short int)467, (const signed short int)64, (const signed short int)470, (const signed short int)64, (const signed short int)64, (const signed short int)466, (const signed short int)64, (const signed short int)469, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)471, (const signed short int)64, (const signed short int)473, (const signed short int)475, (const signed short int)64, (const signed short int)64, (const signed short int)476, (const signed short int)64, (const signed short int)64, (const signed short int)477, (const signed short int)479, (const signed short int)64, (const signed short int)478, (const signed short int)472, (const signed short int)480, (const signed short int)483, (const signed short int)64, (const signed short int)64, (const signed short int)474, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)485, (const signed short int)482, (const signed short int)64, (const signed short int)484, (const signed short int)489, (const signed short int)491, (const signed short int)481, (const signed short int)64, (const signed short int)487, (const signed short int)486, (const signed short int)490, (const signed short int)64, (const signed short int)495, (const signed short int)64, (const signed short int)488, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)492, (const signed short int)497, (const signed short int)500, (const signed short int)498, (const signed short int)64, (const signed short int)64, (const signed short int)493, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)496, (const signed short int)64, (const signed short int)64, (const signed short int)511, (const signed short int)512, (const signed short int)64, (const signed short int)494, (const signed short int)64, (const signed short int)501, (const signed short int)64, (const signed short int)505, (const signed short int)513, (const signed short int)514, (const signed short int)64, (const signed short int)499, (const signed short int)64, (const signed short int)506, (const signed short int)504, (const signed short int)507, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)503, (const signed short int)502, (const signed short int)64, (const signed short int)508, (const signed short int)515, (const signed short int)516, (const signed short int)517, (const signed short int)64, (const signed short int)519, (const signed short int)521, (const signed short int)510, (const signed short int)64, (const signed short int)518, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)509, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)522, (const signed short int)520, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)524, (const signed short int)523, (const signed short int)64, (const signed short int)525, (const signed short int)526, (const signed short int)533, (const signed short int)527, (const signed short int)528, (const signed short int)530, (const signed short int)531, (const signed short int)534, (const signed short int)64, (const signed short int)529, (const signed short int)535, (const signed short int)544, (const signed short int)64, (const signed short int)532, (const signed short int)539, (const signed short int)64, (const signed short int)542, (const signed short int)540, (const signed short int)541, (const signed short int)545, (const signed short int)64, (const signed short int)537, (const signed short int)64, (const signed short int)536, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)543, (const signed short int)64, (const signed short int)64, (const signed short int)552, (const signed short int)547, (const signed short int)538, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)546, (const signed short int)64, (const signed short int)550, (const signed short int)64, (const signed short int)64, (const signed short int)548, (const signed short int)554, (const signed short int)551, (const signed short int)64, (const signed short int)549, (const signed short int)553, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)558, (const signed short int)64, (const signed short int)560, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)556, (const signed short int)559, (const signed short int)64, (const signed short int)567, (const signed short int)557, (const signed short int)555, (const signed short int)561, (const signed short int)64, (const signed short int)568, (const signed short int)564, (const signed short int)562, (const signed short int)569, (const signed short int)64, (const signed short int)576, (const signed short int)64, (const signed short int)563, (const signed short int)64, (const signed short int)566, (const signed short int)572, (const signed short int)570, (const signed short int)574, (const signed short int)64, (const signed short int)571, (const signed short int)575, (const signed short int)577, (const signed short int)64, (const signed short int)64, (const signed short int)565, (const signed short int)578, (const signed short int)64, (const signed short int)64, (const signed short int)573, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)581, (const signed short int)64, (const signed short int)64, (const signed short int)579, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)580, (const signed short int)584, (const signed short int)64, (const signed short int)64, (const signed short int)582, (const signed short int)585, (const signed short int)589, (const signed short int)586, (const signed short int)587, (const signed short int)588, (const signed short int)583, (const signed short int)592, (const signed short int)64, (const signed short int)64, (const signed short int)593, (const signed short int)595, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)594, (const signed short int)590, (const signed short int)591, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)596, (const signed short int)597, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)43, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)48, (const signed short int)51, (const signed short int)51, (const signed short int)64, (const signed short int)64, (const signed short int)51, (const signed short int)51, (const signed short int)51, (const signed short int)51, (const signed short int)51, (const signed short int)51, (const signed short int)51, (const signed short int)53, (const signed short int)53, (const signed short int)53, (const signed short int)59, (const signed short int)59, (const signed short int)59, (const signed short int)63, (const signed short int)64, (const signed short int)63, (const signed short int)63, (const signed short int)63, (const signed short int)63, (const signed short int)63, (const signed short int)65, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)65, (const signed short int)65, (const signed short int)65, (const signed short int)65, (const signed short int)65, (const signed short int)65, (const signed short int)65, (const signed short int)66, (const signed short int)66, (const signed short int)66, (const signed short int)133, (const signed short int)133, (const signed short int)64, (const signed short int)133, (const signed short int)133, (const signed short int)64, (const signed short int)133, (const signed short int)133, (const signed short int)133, (const signed short int)133, (const signed short int)133, (const signed short int)136, (const signed short int)136, (const signed short int)64, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)136, (const signed short int)137, (const signed short int)64, (const signed short int)64, (const signed short int)137, (const signed short int)137, (const signed short int)137, (const signed short int)137, (const signed short int)143, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)143, (const signed short int)143, (const signed short int)146, (const signed short int)64, (const signed short int)64, (const signed short int)146, (const signed short int)146, (const signed short int)146, (const signed short int)146, (const signed short int)147, (const signed short int)147, (const signed short int)64, (const signed short int)147, (const signed short int)147, (const signed short int)147, (const signed short int)147, (const signed short int)147, (const signed short int)147, (const signed short int)147, (const signed short int)147, (const signed short int)148, (const signed short int)148, (const signed short int)148, (const signed short int)149, (const signed short int)64, (const signed short int)64, (const signed short int)149, (const signed short int)149, (const signed short int)149, (const signed short int)149, (const signed short int)232, (const signed short int)232, (const signed short int)64, (const signed short int)232, (const signed short int)234, (const signed short int)64, (const signed short int)234, (const signed short int)234, (const signed short int)234, (const signed short int)234, (const signed short int)234, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)64, (const signed short int)142, (const signed short int)64, (const signed short int)64, (const signed short int)142, (const signed short int)52, (const signed short int)135, (const signed short int)134, (const signed short int)64, (const signed short int)58, (const signed short int)52, (const signed short int)598, (const signed short int)49, (const signed short int)49, (const signed short int)7, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598, (const signed short int)598 };
// yy_start
// file vlex.c line 230
static signed int yy_start = 0;
// yyin
// file vlex.c line 274
struct _IO_FILE *yyin = (struct _IO_FILE *)0;
// yyleng
// file vlex.c line 225
signed int yyleng;
// yyout
// file vlex.c line 274
struct _IO_FILE *yyout = (struct _IO_FILE *)0;
// yytext
// file vlex.c line 871
char *yytext;

// DNDBeginCB
// file logfile.c line 780
static void DNDBeginCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, void *data)
{
  (void)widget;
  (void)dc;
  (void)data;
}

// DNDBeginCB_link1
// file tcl_helper.c line 684
static void DNDBeginCB_link1(struct _GtkWidget *widget_link1, struct _GdkDragContext *dc_link1, void *data_link1)
{
  (void)widget_link1;
  (void)dc_link1;
  (void)data_link1;
}

// DNDDataDeleteCB
// file logfile.c line 802
static void DNDDataDeleteCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, void *data)
{
  (void)widget;
  (void)dc;
  (void)data;
}

// DNDDataReceivedCB
// file tcl_helper.c line 711
static void DNDDataReceivedCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, signed int x, signed int y, struct _GtkSelectionData *selection_data, unsigned int info, unsigned int t, void *data)
{
  (void)x;
  (void)y;
  (void)t;
  signed int same;
  struct _GtkWidget *source_widget;
  _Bool tmp_if_expr_5;
  signed int return_value_strncmp_4;
  signed int tmp_post_7;
  if(!(data == NULL) && !(dc == ((struct _GdkDragContext *)NULL)) && !(widget == ((struct _GtkWidget *)NULL)))
  {
    if(!(selection_data == ((struct _GtkSelectionData *)NULL)))
    {
      if(selection_data->length >= 0)
      {
        source_widget=gtk_drag_get_source_widget(dc);
        same = source_widget == widget ? (signed int)!(0 != 0) : 0;
        if(same == 0)
        {
          if(info == 0u || info == 1u || info == 2u)
          {
            signed int impcnt = 0;
            struct ds_tree_node *ft = (struct ds_tree_node *)(void *)0;
            signed int argc = 0;
            char **zs;
            zs=zSplitTclList((const char *)selection_data->data, &argc);
            if(!(zs == ((char **)NULL)))
            {
              signed int DNDDataReceivedCB__1__2__1__i = 0;
              for( ; !(DNDDataReceivedCB__1__2__1__i >= argc); DNDDataReceivedCB__1__2__1__i = DNDDataReceivedCB__1__2__1__i + 1)
              {
                signed int return_value_strncmp_3;
                return_value_strncmp_3=strncmp("net ", zs[(signed long int)DNDDataReceivedCB__1__2__1__i], (unsigned long int)4);
                if(return_value_strncmp_3 == 0)
                  tmp_if_expr_5 = (_Bool)1;

                else
                {
                  return_value_strncmp_4=strncmp("netBus ", zs[(signed long int)DNDDataReceivedCB__1__2__1__i], (unsigned long int)7);
                  tmp_if_expr_5 = !(return_value_strncmp_4 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_5)
                {
                  char *stemp;
                  stemp=strdup(zs[(signed long int)DNDDataReceivedCB__1__2__1__i]);
                  char *ss;
                  char *return_value_strchr_1;
                  return_value_strchr_1=strchr(stemp, 32);
                  ss = return_value_strchr_1 + (signed long int)1;
                  char *sl;
                  sl=strrchr(stemp, 32);
                  char *pnt = ss;
                  if(!(sl == ((char *)NULL)))
                  {
                    *sl = (char)0;
                    for( ; !(*pnt == 0); pnt = pnt + 1l)
                      if((signed int)*pnt == 32)
                        *pnt = (char)46;

                  }

                  ft = flattened_mod_list_root;
                  while(!(ft == ((struct ds_tree_node *)NULL)))
                  {
                    signed int return_value_strcmp_2;
                    return_value_strcmp_2=strcmp(ss, ft->fullname);
                    if(return_value_strcmp_2 == 0)
                    {
                      if(ft->dnd_to_import == 0u)
                      {
                        ft->dnd_to_import = (unsigned int)1;
                        impcnt = impcnt + 1;
                      }

                      break;
                    }

                    ft = ft->next_flat;
                  }
                  free((void *)stemp);
                }

              }
              free((void *)zs);
            }

            if(!(impcnt == 0))
            {
              struct ds_tree_node **fta;
              void *return_value_calloc_6;
              return_value_calloc_6=calloc((unsigned long int)impcnt, sizeof(struct ds_tree_node *) /*8ul*/ );
              fta = (struct ds_tree_node **)return_value_calloc_6;
              signed int i = 0;
              for( ; !(ft == ((struct ds_tree_node *)NULL)); ft = ft->next_flat)
                if(!(ft->dnd_to_import == 0u))
                {
                  ft->dnd_to_import = (unsigned int)0;
                  tmp_post_7 = i;
                  i = i + 1;
                  fta[(signed long int)tmp_post_7] = ft;
                  if(i == impcnt)
                    break;

                }

              i = impcnt - 1;
              for( ; i >= 0; i = i - 1)
                if(!(fta[(signed long int)i] == ((struct ds_tree_node *)NULL)))
                  bwlogbox(fta[(signed long int)i]->fullname, 640 + 8 * 8, fta[(signed long int)i], 0);

              free((void *)fta);
            }

          }

        }

      }

    }

  }

}

// DNDDataRequestCB
// file logfile.c line 813
static void DNDDataRequestCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, struct _GtkSelectionData *selection_data, unsigned int info, unsigned int t, void *data)
{
  (void)dc;
  (void)t;
  (void)info;
  struct logfile_context_t *ctx = (struct logfile_context_t *)data;
  struct _GtkWidget *text = (struct _GtkWidget *)widget;
  char *sel = (char *)(void *)0;
  char *sel2 = (char *)(void *)0;
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  signed int ok = 0;
  char ch;
  unsigned long int return_value_strlen_18;
  signed int return_value_gtk_text_iter_backward_char_8;
  if(!(text == ((struct _GtkWidget *)NULL)) && !(ctx == ((struct logfile_context_t *)NULL)))
  {
    unsigned long int return_value_gtk_text_view_get_type_3;
    return_value_gtk_text_view_get_type_3=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_3);
    signed int return_value_gtk_text_buffer_get_selection_bounds_5;
    return_value_gtk_text_buffer_get_selection_bounds_5=gtk_text_buffer_get_selection_bounds(((struct _GtkTextView *)return_value_g_type_check_instance_cast_4)->buffer, &start, &end);
    if(!(return_value_gtk_text_buffer_get_selection_bounds_5 == 0))
      ok = 1;

    else
      if((void *)widget->window == pressWindow)
      {
        struct _GtkTextView *text_view;
        unsigned long int return_value_gtk_text_view_get_type_1;
        return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
        return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
        text_view = (struct _GtkTextView *)return_value_g_type_check_instance_cast_2;
        signed int buffer_x;
        signed int buffer_y;
        signed int s_trailing;
        signed int e_trailing;
        gtk_text_view_window_to_buffer_coords(text_view, (enum anonymous_34)GTK_TEXT_WINDOW_WIDGET, pressX, pressY, &buffer_x, &buffer_y);
        gtk_text_view_get_iter_at_position(text_view, &start, &s_trailing, buffer_x, buffer_y);
        gtk_text_view_get_iter_at_position(text_view, &end, &e_trailing, buffer_x, buffer_y);
        gtk_text_iter_forward_char(&end);
        ok = 1;
      }

    pressWindow = (void *)0;
    if(!(ok == 0))
    {
      signed int return_value_gtk_text_iter_compare_19;
      return_value_gtk_text_iter_compare_19=gtk_text_iter_compare(&start, &end);
      if(!(return_value_gtk_text_iter_compare_19 >= 0))
      {
        unsigned long int return_value_gtk_text_view_get_type_6;
        return_value_gtk_text_view_get_type_6=gtk_text_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
        return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_6);
        sel=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_7)->buffer, &start, &end, 0);
        if(!(sel == ((char *)NULL)))
        {
          return_value_strlen_18=strlen(sel);
          if(!(return_value_strlen_18 == 0ul))
          {
            do
            {
              return_value_gtk_text_iter_backward_char_8=gtk_text_iter_backward_char(&start);
              if(return_value_gtk_text_iter_backward_char_8 == 0)
                break;

              unsigned long int return_value_gtk_text_view_get_type_9;
              return_value_gtk_text_view_get_type_9=gtk_text_view_get_type();
              struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
              return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_9);
              sel2=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_10)->buffer, &start, &end, 0);
              if(sel2 == ((char *)NULL))
                break;

              ch = *sel2;
              g_free((void *)sel2);
              signed int return_value_is_identifier_11;
              return_value_is_identifier_11=is_identifier(ch);
              if(return_value_is_identifier_11 == 0)
              {
                gtk_text_iter_forward_char(&start);
                break;
              }

            }
            while((_Bool)1);
            gtk_text_iter_backward_char(&end);
            do
            {
              gtk_text_iter_forward_char(&end);
              unsigned long int return_value_gtk_text_view_get_type_12;
              return_value_gtk_text_view_get_type_12=gtk_text_view_get_type();
              struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
              return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_12);
              sel2=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_13)->buffer, &start, &end, 0);
              if(sel2 == ((char *)NULL))
                break;

              unsigned long int return_value_strlen_14;
              return_value_strlen_14=strlen(sel2);
              ch = *((sel2 + (signed long int)return_value_strlen_14) - (signed long int)1);
              g_free((void *)sel2);
              signed int return_value_is_identifier_15;
              return_value_is_identifier_15=is_identifier(ch);
              if(return_value_is_identifier_15 == 0)
              {
                gtk_text_iter_backward_char(&end);
                break;
              }

            }
            while((_Bool)1);
            unsigned long int return_value_gtk_text_view_get_type_16;
            return_value_gtk_text_view_get_type_16=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
            return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_16);
            sel2=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_17)->buffer, &start, &end, 0);
            g_free((void *)sel);
            sel = sel2;
            sel2 = (char *)(void *)0;
          }

        }

      }

    }

    if(!(sel == ((char *)NULL)))
    {
      struct jrb_node *strs;
      struct jrb_node *node;
      signed int fd;
      char *fname;
      fname=tmpnam_rtlbrowse("rtlbrowse", &fd);
      struct _IO_FILE *handle;
      handle=fopen(fname, "wb");
      signed int lx;
      signed int degate = 0;
      signed int cnt = 0;
      if(handle == ((struct _IO_FILE *)NULL))
      {
        fprintf(stderr, "Could not open cutpaste file '%s'\n", fname);
        goto __CPROVER_DUMP_L36;
      }

      fprintf(handle, "%s", sel);
      fclose(handle);
      if(fd >= 0)
        close(fd);

      v_preproc_name = fname;
      strs=make_jrb();
      do
      {
        lx=yylex();
        if(lx == 0)
          break;

        char *pnt = yytext;
        if(verilog_2005 == 0)
        {
          if(lx == 15)
            lx = 2;

        }

        if(lx == 2)
        {
          if(degate == 0)
          {
            struct jrb_node *str;
            str=jrb_find_str(strs, pnt);
            union anonymous_26 jv;
            jv.v = (void *)0;
            if(str == ((struct jrb_node *)NULL))
            {
              char *return_value_strdup_20;
              return_value_strdup_20=strdup(pnt);
              jrb_insert_str(strs, return_value_strdup_20, jv);
              cnt = cnt + 1;
            }

          }

        }

        else
          if(lx == 1)
          {
            if((signed int)*pnt == 91)
              degate = 1;

            else
              if((signed int)*pnt == 93)
                degate = 0;

          }

      }
      while((_Bool)1);
      unlink(fname);
      free((void *)fname);
      if(!(cnt == 0))
      {
        signed int title_len;
        unsigned long int return_value_strlen_21;
        return_value_strlen_21=strlen(ctx->title);
        title_len = (signed int)((unsigned long int)5 + return_value_strlen_21 + (unsigned long int)1);
        char *tpnt;
        void *return_value_calloc_22;
        return_value_calloc_22=calloc((unsigned long int)1, (unsigned long int)(title_len + 1));
        tpnt = (char *)return_value_calloc_22;
        char *op = ctx->title;
        char *np = tpnt;
        char *mlist = (char *)(void *)0;
        signed int mlen = 0;
        strcpy(np, "{net ");
        np = np + (signed long int)5;
        for( ; !(*op == 0); np = np + 1l)
        {
          if((signed int)*op == 46)
            *np = (char)32;

          else
            *np = *op;
          op = op + 1l;
        }
        *np = (char)32;
        node = strs->flink;
        for( ; !(node == strs); node = node->flink)
        {
          signed int slen;
          unsigned long int return_value_strlen_23;
          return_value_strlen_23=strlen(node->key.s);
          slen = (signed int)return_value_strlen_23;
          signed int singlen = title_len + slen + 2;
          char *singlist;
          void *return_value_calloc_24;
          return_value_calloc_24=calloc((unsigned long int)1, (unsigned long int)(singlen + 1));
          singlist = (char *)return_value_calloc_24;
          memcpy((void *)singlist, (const void *)tpnt, (unsigned long int)title_len);
          strcpy(singlist + (signed long int)title_len, node->key.s);
          strcpy(singlist + (signed long int)title_len + (signed long int)slen, "} ");
          if(!(mlist == ((char *)NULL)))
          {
            void *return_value_realloc_25;
            return_value_realloc_25=realloc((void *)mlist, (unsigned long int)(mlen + singlen + 1));
            mlist = (char *)return_value_realloc_25;
            strcpy(mlist + (signed long int)mlen, singlist);
            mlen = mlen + singlen;
          }

          else
          {
            mlist=strdup(singlist);
            mlen = singlen;
          }
          free((void *)singlist);
          free((void *)node->key.s);
        }
        gtk_selection_data_set(selection_data, (struct _GdkAtom *)(void *)(unsigned long int)31, 8, (unsigned char *)mlist, mlen);
        free((void *)mlist);
        update_ctx_when_idle((void *)text);
        free((void *)tpnt);
      }

      else
        update_ctx_when_idle((void *)text);
      jrb_free_tree(strs);
      g_free((void *)sel);
    }

  }


__CPROVER_DUMP_L36:
  ;
}

// DNDDragMotionCB
// file tcl_helper.c line 640
static signed int DNDDragMotionCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, signed int xx, signed int yy, unsigned int tt, void *data)
{
  (void)widget;
  (void)xx;
  (void)yy;
  (void)data;
  enum anonymous_37 suggested_action = (enum anonymous_37)GDK_ACTION_MOVE;
  if((signed int)dc->actions == GDK_ACTION_MOVE)
    gdk_drag_status(dc, (enum anonymous_37)GDK_ACTION_MOVE, tt);

  else
    if((signed int)dc->actions == GDK_ACTION_COPY)
      gdk_drag_status(dc, (enum anonymous_37)GDK_ACTION_COPY, tt);

    else
      if((signed int)dc->actions == GDK_ACTION_LINK)
        gdk_drag_status(dc, (enum anonymous_37)GDK_ACTION_LINK, tt);

      else
        if(!(((signed int)dc->actions & (signed int)suggested_action) == 0))
          gdk_drag_status(dc, suggested_action, tt);

        else
          gdk_drag_status(dc, (enum anonymous_37)0, tt);
  return 0;
}

// DNDEndCB
// file logfile.c line 791
static void DNDEndCB(struct _GtkWidget *widget, struct _GdkDragContext *dc, void *data)
{
  (void)widget;
  (void)dc;
  (void)data;
}

// DNDEndCB_link1
// file tcl_helper.c line 693
static void DNDEndCB_link1(struct _GtkWidget *widget_link1, struct _GdkDragContext *dc_link1, void *data_link1)
{
  (void)widget_link1;
  (void)dc_link1;
  (void)data_link1;
}

// LZ4_64bits
// file ./../../src/helpers/fst/lz4.c line 178
static unsigned int LZ4_64bits(void)
{
  return (unsigned int)(sizeof(void *) /*8ul*/  == (unsigned long int)8);
}

// LZ4_NbCommonBytes
// file ./../../src/helpers/fst/lz4.c line 327
static unsigned int LZ4_NbCommonBytes(unsigned long int val)
{
  unsigned int return_value_LZ4_isLittleEndian_7;
  return_value_LZ4_isLittleEndian_7=LZ4_isLittleEndian();
  if(!(return_value_LZ4_isLittleEndian_7 == 0u))
  {
    unsigned int return_value_LZ4_64bits_3;
    return_value_LZ4_64bits_3=LZ4_64bits();
    if(!(return_value_LZ4_64bits_3 == 0u))
    {
      signed int return_value___builtin_ctzll_1;
      return_value___builtin_ctzll_1=__builtin_ctzll((unsigned long int)val);
      return (unsigned int)(return_value___builtin_ctzll_1 >> 3);
    }

    else
    {
      signed int return_value___builtin_ctz_2;
      return_value___builtin_ctz_2=__builtin_ctz((unsigned int)val);
      return (unsigned int)(return_value___builtin_ctz_2 >> 3);
    }
  }

  else
  {
    unsigned int return_value_LZ4_64bits_6;
    return_value_LZ4_64bits_6=LZ4_64bits();
    if(!(return_value_LZ4_64bits_6 == 0u))
    {
      signed int return_value___builtin_clzll_4;
      return_value___builtin_clzll_4=__builtin_clzll(val);
      return (unsigned int)(return_value___builtin_clzll_4 >> 3);
    }

    else
    {
      signed int return_value___builtin_clz_5;
      return_value___builtin_clz_5=__builtin_clz((unsigned int)val);
      return (unsigned int)(return_value___builtin_clz_5 >> 3);
    }
  }
}

// LZ4_compress
// file ./../../src/helpers/fst/lz4.c line 710
signed int LZ4_compress(const char *source, char *dest, signed int inputSize)
{
  unsigned long int ctx[2052l] = { (unsigned long int)0, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul };
  signed int result;
  unsigned int return_value_LZ4_64bits_1;
  if(!(inputSize >= LZ4_64Klimit))
    result=LZ4_compress_generic((void *)ctx, source, dest, inputSize, 0, (enum anonymous_24)notLimited, (enum anonymous_20)byU16, (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);

  else
  {
    return_value_LZ4_64bits_1=LZ4_64bits();
    result=LZ4_compress_generic((void *)ctx, source, dest, inputSize, 0, (enum anonymous_24)notLimited, (enum anonymous_20)(return_value_LZ4_64bits_1 != 0u ? byU32 : byPtr), (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);
  }
  return result;
}

// LZ4_compressBound
// file ./../../src/helpers/fst/lz4.c line 429
signed int LZ4_compressBound(signed int isize)
{
  return (unsigned int)isize > (unsigned int)0x7E000000 ? 0 : isize + isize / 255 + 16;
}

// LZ4_compress_continue
// file ./../../src/helpers/fst/lz4.c line 883
signed int LZ4_compress_continue(struct anonymous_25 *LZ4_stream, const char *source, char *dest, signed int inputSize)
{
  signed int return_value_LZ4_compress_continue_generic_1;
  return_value_LZ4_compress_continue_generic_1=LZ4_compress_continue_generic((void *)LZ4_stream, source, dest, inputSize, 0, (enum anonymous_24)notLimited);
  return return_value_LZ4_compress_continue_generic_1;
}

// LZ4_compress_continue_generic
// file ./../../src/helpers/fst/lz4.c line 833
static inline signed int LZ4_compress_continue_generic(void *LZ4_stream, const char *source, char *dest, signed int inputSize, signed int maxOutputSize, enum anonymous_24 limit)
{
  struct anonymous_23 *streamPtr = (struct anonymous_23 *)LZ4_stream;
  const unsigned char * const dictEnd = streamPtr->dictionary + (signed long int)streamPtr->dictSize;
  const unsigned char *smallest = (const unsigned char *)source;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(streamPtr->initCheck == 0u))
    return 0;

  else
  {
    if(streamPtr->dictSize >= 1u)
    {
      if(!(dictEnd >= smallest))
        smallest = dictEnd;

    }

    LZ4_renormDictT(streamPtr, smallest);
    const unsigned char *sourceEnd = (const unsigned char *)source + (signed long int)inputSize;
    if(!(streamPtr->dictionary >= sourceEnd))
    {
      if(!(sourceEnd >= dictEnd))
      {
        streamPtr->dictSize = (unsigned int)(dictEnd - sourceEnd);
        if(streamPtr->dictSize >= 65537u)
          streamPtr->dictSize = (unsigned int)(64 * (1 << 10));

        if(!(streamPtr->dictSize >= 4u))
          streamPtr->dictSize = (unsigned int)0;

        streamPtr->dictionary = dictEnd - (signed long int)streamPtr->dictSize;
      }

    }

    if(dictEnd == (const unsigned char *)source)
    {
      signed int result;
      if(!(streamPtr->dictSize >= 65536u))
        tmp_if_expr_1 = streamPtr->dictSize < streamPtr->currentOffset ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        result=LZ4_compress_generic(LZ4_stream, source, dest, inputSize, maxOutputSize, limit, (enum anonymous_20)byU32, (enum anonymous_21)withPrefix64k, (enum anonymous_22)dictSmall);

      else
        result=LZ4_compress_generic(LZ4_stream, source, dest, inputSize, maxOutputSize, limit, (enum anonymous_20)byU32, (enum anonymous_21)withPrefix64k, (enum anonymous_22)noDictIssue);
      streamPtr->dictSize = streamPtr->dictSize + (unsigned int)inputSize;
      streamPtr->currentOffset = streamPtr->currentOffset + (unsigned int)inputSize;
      return result;
    }

    signed int LZ4_compress_continue_generic__1__3__result;
    if(!(streamPtr->dictSize >= 65536u))
      tmp_if_expr_2 = streamPtr->dictSize < streamPtr->currentOffset ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      LZ4_compress_continue_generic__1__3__result=LZ4_compress_generic(LZ4_stream, source, dest, inputSize, maxOutputSize, limit, (enum anonymous_20)byU32, (enum anonymous_21)usingExtDict, (enum anonymous_22)dictSmall);

    else
      LZ4_compress_continue_generic__1__3__result=LZ4_compress_generic(LZ4_stream, source, dest, inputSize, maxOutputSize, limit, (enum anonymous_20)byU32, (enum anonymous_21)usingExtDict, (enum anonymous_22)noDictIssue);
    streamPtr->dictionary = (const unsigned char *)source;
    streamPtr->dictSize = (unsigned int)inputSize;
    streamPtr->currentOffset = streamPtr->currentOffset + (unsigned int)inputSize;
    return LZ4_compress_continue_generic__1__3__result;
  }
}

// LZ4_compress_forceExtDict
// file ./../../src/helpers/fst/lz4.c line 895
signed int LZ4_compress_forceExtDict(struct anonymous_25 *LZ4_dict, const char *source, char *dest, signed int inputSize)
{
  struct anonymous_23 *streamPtr = (struct anonymous_23 *)LZ4_dict;
  signed int result;
  const unsigned char * const dictEnd = streamPtr->dictionary + (signed long int)streamPtr->dictSize;
  const unsigned char *smallest = dictEnd;
  if(!((const unsigned char *)source >= smallest))
    smallest = (const unsigned char *)source;

  LZ4_renormDictT((struct anonymous_23 *)LZ4_dict, smallest);
  result=LZ4_compress_generic((void *)LZ4_dict, source, dest, inputSize, 0, (enum anonymous_24)notLimited, (enum anonymous_20)byU32, (enum anonymous_21)usingExtDict, (enum anonymous_22)noDictIssue);
  streamPtr->dictionary = (const unsigned char *)source;
  streamPtr->dictSize = (unsigned int)inputSize;
  streamPtr->currentOffset = streamPtr->currentOffset + (unsigned int)inputSize;
  return result;
}

// LZ4_compress_generic
// file ./../../src/helpers/fst/lz4.c line 498
static signed int LZ4_compress_generic(void *ctx, const char *source, char *dest, signed int inputSize, signed int maxOutputSize, enum anonymous_24 outputLimited, enum anonymous_20 tableType, enum anonymous_21 dict, enum anonymous_22 dictIssue)
{
  struct anonymous_23 * const dictPtr = (struct anonymous_23 *)ctx;
  const unsigned char *ip = (const unsigned char *)source;
  const unsigned char *base;
  const unsigned char *lowLimit;
  const unsigned char * const lowRefLimit = ip - (signed long int)dictPtr->dictSize;
  const unsigned char * const dictionary = dictPtr->dictionary;
  const unsigned char * const dictEnd = dictionary + (signed long int)dictPtr->dictSize;
  const unsigned long int dictDelta = (const unsigned long int)(dictEnd - (const unsigned char *)source);
  const unsigned char *anchor = (const unsigned char *)source;
  const unsigned char * const iend = ip + (signed long int)inputSize;
  const unsigned char * const mflimit = iend - (signed long int)(8 + 4);
  const unsigned char * const matchlimit = iend - (signed long int)5;
  unsigned char *op = (unsigned char *)dest;
  unsigned char * const olimit = op + (signed long int)maxOutputSize;
  unsigned int forwardH;
  unsigned long int refDelta = (unsigned long int)0;
  unsigned int tmp_post_4;
  _Bool tmp_if_expr_3;
  unsigned int return_value_LZ4_read32_1;
  unsigned int return_value_LZ4_read32_2;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned int return_value_LZ4_read32_13;
  unsigned int return_value_LZ4_read32_14;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  if((unsigned int)inputSize >= 2113929217u)
    return 0;

  else
  {
    switch((signed int)dict)
    {
      case noDict:
      {
        base = (const unsigned char *)source;
        lowLimit = (const unsigned char *)source;
        break;
      }
      case withPrefix64k:
      {
        base = (const unsigned char *)source - (signed long int)dictPtr->currentOffset;
        lowLimit = (const unsigned char *)source - (signed long int)dictPtr->dictSize;
        break;
      }
      case usingExtDict:
      {
        base = (const unsigned char *)source - (signed long int)dictPtr->currentOffset;
        lowLimit = (const unsigned char *)source;
      }
    }
    if((signed int)tableType == byU16 && inputSize >= LZ4_64Klimit)
      return 0;

    else
    {
      if(inputSize >= LZ4_minLength)
      {
        LZ4_putPosition(ip, ctx, tableType, base);
        ip = ip + 1l;
        forwardH=LZ4_hashPosition(ip, tableType);
        do
        {
          const unsigned char *match;
          unsigned char *token;
          const unsigned char *forwardIp = ip;
          unsigned int step = (unsigned int)1;
          unsigned int searchMatchNb = 1U << LZ4_skipTrigger;
          do
          {
            unsigned int h = forwardH;
            ip = forwardIp;
            forwardIp = forwardIp + (signed long int)step;
            tmp_post_4 = searchMatchNb;
            searchMatchNb = searchMatchNb + 1u;
            step = tmp_post_4 >> LZ4_skipTrigger;
            if(!(mflimit >= forwardIp))
              goto _last_literals;

            match=LZ4_getPositionOnHash(h, ctx, tableType, base);
            if((signed int)dict == usingExtDict)
            {
              if(!(match >= (const unsigned char *)source))
              {
                refDelta = dictDelta;
                lowLimit = dictionary;
              }

              else
              {
                refDelta = (unsigned long int)0;
                lowLimit = (const unsigned char *)source;
              }
            }

            forwardH=LZ4_hashPosition(forwardIp, tableType);
            LZ4_putPositionOnHash(ip, h, ctx, tableType, base);
            if((signed int)dictIssue == dictSmall && !(match >= lowRefLimit) || !((signed int)tableType == byU16) && !(match + 65535l >= ip))
              tmp_if_expr_3 = (_Bool)1;

            else
            {
              return_value_LZ4_read32_1=LZ4_read32((const void *)(match + (signed long int)refDelta));
              return_value_LZ4_read32_2=LZ4_read32((const void *)ip);
              tmp_if_expr_3 = return_value_LZ4_read32_1 != return_value_LZ4_read32_2 ? (_Bool)1 : (_Bool)0;
            }
          }
          while(tmp_if_expr_3);
          for( ; !(anchor >= ip); match = match - 1l)
          {
            if(lowLimit >= match + (signed long int)refDelta)
              break;

            if(!(ip[-1l] == match[-1l + (signed long int)refDelta]))
              break;

            ip = ip - 1l;
          }
          unsigned int litLength = (unsigned int)(ip - anchor);
          tmp_post_5 = op;
          op = op + 1l;
          token = tmp_post_5;
          if(!(olimit >= op + (signed long int)litLength + 8l + (signed long int)(litLength / 255u)) && !(outputLimited == /*enum*/notLimited))
            return 0;

          if(litLength >= 15u)
          {
            signed int len = (signed int)((unsigned int)(signed int)litLength - ((1U << 8 - 4) - (unsigned int)1));
            *token = (unsigned char)((1U << 8 - 4) - (unsigned int)1 << 4);
            for( ; len >= 255; len = len - 255)
            {
              tmp_post_6 = op;
              op = op + 1l;
              *tmp_post_6 = (unsigned char)255;
            }
            tmp_post_7 = op;
            op = op + 1l;
            *tmp_post_7 = (unsigned char)len;
          }

          else
            *token = (unsigned char)(litLength << 4);
          LZ4_wildCopy((void *)op, (const void *)anchor, (void *)(op + (signed long int)litLength));
          op = op + (signed long int)litLength;
          do
          {

          _next_match:
            ;
            LZ4_writeLE16((void *)op, (unsigned short int)(ip - match));
            op = op + (signed long int)2;
            unsigned int matchLength;
            if(lowLimit == dictionary && (signed int)dict == usingExtDict)
            {
              const unsigned char *limit;
              match = match + (signed long int)refDelta;
              limit = ip + (dictEnd - match);
              if(!(matchlimit >= limit))
                limit = matchlimit;

              matchLength=LZ4_count(ip + (signed long int)4, match + (signed long int)4, limit);
              ip = ip + (signed long int)((unsigned int)4 + matchLength);
              if(ip == limit)
              {
                unsigned int more;
                more=LZ4_count(ip, (const unsigned char *)source, matchlimit);
                matchLength = matchLength + more;
                ip = ip + (signed long int)more;
              }

            }

            else
            {
              matchLength=LZ4_count(ip + (signed long int)4, match + (signed long int)4, matchlimit);
              ip = ip + (signed long int)((unsigned int)4 + matchLength);
            }
            if(!(olimit >= op + 6l + (signed long int)(matchLength >> 8)) && !(outputLimited == /*enum*/notLimited))
              return 0;

            if(matchLength >= 15u)
            {
              *token = *token + (unsigned char)((1U << 4) - (unsigned int)1);
              matchLength = matchLength - ((1U << 4) - (unsigned int)1);
              for( ; matchLength >= 510u; matchLength = matchLength - (unsigned int)510)
              {
                tmp_post_8 = op;
                op = op + 1l;
                *tmp_post_8 = (unsigned char)255;
                tmp_post_9 = op;
                op = op + 1l;
                *tmp_post_9 = (unsigned char)255;
              }
              if(matchLength >= 255u)
              {
                matchLength = matchLength - (unsigned int)255;
                tmp_post_10 = op;
                op = op + 1l;
                *tmp_post_10 = (unsigned char)255;
              }

              tmp_post_11 = op;
              op = op + 1l;
              *tmp_post_11 = (unsigned char)matchLength;
            }

            else
              *token = *token + (unsigned char)matchLength;
            anchor = ip;
            if(!(mflimit >= ip))
              goto _last_literals;

            LZ4_putPosition(ip - (signed long int)2, ctx, tableType, base);
            match=LZ4_getPosition(ip, ctx, tableType, base);
            if((signed int)dict == usingExtDict)
            {
              if(!(match >= (const unsigned char *)source))
              {
                refDelta = dictDelta;
                lowLimit = dictionary;
              }

              else
              {
                refDelta = (unsigned long int)0;
                lowLimit = (const unsigned char *)source;
              }
            }

            LZ4_putPosition(ip, ctx, tableType, base);
            if(!(match + 65535l >= ip) || !(match >= lowRefLimit) && (signed int)dictIssue == dictSmall)
              break;

            return_value_LZ4_read32_13=LZ4_read32((const void *)(match + (signed long int)refDelta));
            return_value_LZ4_read32_14=LZ4_read32((const void *)ip);
            if(!(return_value_LZ4_read32_13 == return_value_LZ4_read32_14))
              break;

            tmp_post_12 = op;
            op = op + 1l;
            token = tmp_post_12;
            *token = (unsigned char)0;
          }
          while((_Bool)1);
          ip = ip + 1l;
          forwardH=LZ4_hashPosition(ip, tableType);
        }
        while((_Bool)1);
      }


    _last_literals:
      ;
      signed int lastRun = (signed int)(iend - anchor);
      if(!((signed long int)(unsigned int)maxOutputSize >= ((char *)op - dest) + 1l + (signed long int)((255u + (unsigned int)lastRun + 4294967281u) / 255u) + (signed long int)lastRun) && !(outputLimited == /*enum*/notLimited))
        return 0;

      else
      {
        if(lastRun >= 15)
        {
          tmp_post_15 = op;
          op = op + 1l;
          *tmp_post_15 = (unsigned char)((1U << 8 - 4) - (unsigned int)1 << 4);
          lastRun = lastRun - (signed int)((1U << 8 - 4) - (unsigned int)1);
          for( ; lastRun >= 255; lastRun = lastRun - 255)
          {
            tmp_post_16 = op;
            op = op + 1l;
            *tmp_post_16 = (unsigned char)255;
          }
          tmp_post_17 = op;
          op = op + 1l;
          *tmp_post_17 = (unsigned char)lastRun;
        }

        else
        {
          tmp_post_18 = op;
          op = op + 1l;
          *tmp_post_18 = (unsigned char)(lastRun << 4);
        }
        memcpy((void *)op, (const void *)anchor, (unsigned long int)(iend - anchor));
        op = op + (iend - anchor);
        return (signed int)((char *)op - dest);
      }
    }
  }
}

// LZ4_compress_limitedOutput
// file ./../../src/helpers/fst/lz4.c line 730
signed int LZ4_compress_limitedOutput(const char *source, char *dest, signed int inputSize, signed int maxOutputSize)
{
  unsigned long int ctx[2052l] = { (unsigned long int)0, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul };
  signed int result;
  unsigned int return_value_LZ4_64bits_1;
  if(!(inputSize >= LZ4_64Klimit))
    result=LZ4_compress_generic((void *)ctx, source, dest, inputSize, maxOutputSize, (enum anonymous_24)limitedOutput, (enum anonymous_20)byU16, (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);

  else
  {
    return_value_LZ4_64bits_1=LZ4_64bits();
    result=LZ4_compress_generic((void *)ctx, source, dest, inputSize, maxOutputSize, (enum anonymous_24)limitedOutput, (enum anonymous_20)(return_value_LZ4_64bits_1 != 0u ? byU32 : byPtr), (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);
  }
  return result;
}

// LZ4_compress_limitedOutput_continue
// file ./../../src/helpers/fst/lz4.c line 888
signed int LZ4_compress_limitedOutput_continue(struct anonymous_25 *LZ4_stream, const char *source, char *dest, signed int inputSize, signed int maxOutputSize)
{
  signed int return_value_LZ4_compress_continue_generic_1;
  return_value_LZ4_compress_continue_generic_1=LZ4_compress_continue_generic((void *)LZ4_stream, source, dest, inputSize, maxOutputSize, (enum anonymous_24)limitedOutput);
  return return_value_LZ4_compress_continue_generic_1;
}

// LZ4_compress_limitedOutput_withState
// file ./../../src/helpers/fst/lz4.c line 1343
signed int LZ4_compress_limitedOutput_withState(void *state, const char *source, char *dest, signed int inputSize, signed int maxOutputSize)
{
  signed int return_value_LZ4_compress_generic_1;
  unsigned int return_value_LZ4_64bits_2;
  signed int return_value_LZ4_compress_generic_3;
  if(!((3ul & (unsigned long int)state) == 0ul))
    return 0;

  else
  {
    memset(state, 0, (unsigned long int)((1 << 14 - 3) + 4) * sizeof(signed long long int) /*8ul*/ );
    if(!(inputSize >= LZ4_64Klimit))
    {
      return_value_LZ4_compress_generic_1=LZ4_compress_generic(state, source, dest, inputSize, maxOutputSize, (enum anonymous_24)limitedOutput, (enum anonymous_20)byU16, (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);
      return return_value_LZ4_compress_generic_1;
    }

    else
    {
      return_value_LZ4_64bits_2=LZ4_64bits();
      return_value_LZ4_compress_generic_3=LZ4_compress_generic(state, source, dest, inputSize, maxOutputSize, (enum anonymous_24)limitedOutput, (enum anonymous_20)(return_value_LZ4_64bits_2 != 0u ? byU32 : byPtr), (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);
      return return_value_LZ4_compress_generic_3;
    }
  }
}

// LZ4_compress_withState
// file ./../../src/helpers/fst/lz4.c line 1332
signed int LZ4_compress_withState(void *state, const char *source, char *dest, signed int inputSize)
{
  signed int return_value_LZ4_compress_generic_1;
  unsigned int return_value_LZ4_64bits_2;
  signed int return_value_LZ4_compress_generic_3;
  if(!((3ul & (unsigned long int)state) == 0ul))
    return 0;

  else
  {
    memset(state, 0, (unsigned long int)((1 << 14 - 3) + 4) * sizeof(signed long long int) /*8ul*/ );
    if(!(inputSize >= LZ4_64Klimit))
    {
      return_value_LZ4_compress_generic_1=LZ4_compress_generic(state, source, dest, inputSize, 0, (enum anonymous_24)notLimited, (enum anonymous_20)byU16, (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);
      return return_value_LZ4_compress_generic_1;
    }

    else
    {
      return_value_LZ4_64bits_2=LZ4_64bits();
      return_value_LZ4_compress_generic_3=LZ4_compress_generic(state, source, dest, inputSize, 0, (enum anonymous_24)notLimited, (enum anonymous_20)(return_value_LZ4_64bits_2 != 0u ? byU32 : byPtr), (enum anonymous_21)noDict, (enum anonymous_22)noDictIssue);
      return return_value_LZ4_compress_generic_3;
    }
  }
}

// LZ4_copy4
// file ./../../src/helpers/fst/lz4.c line 259
static void LZ4_copy4(void *dstPtr, const void *srcPtr)
{
  *((unsigned int *)dstPtr) = *((unsigned int *)srcPtr);
}

// LZ4_copy8
// file ./../../src/helpers/fst/lz4.c line 269
static void LZ4_copy8(void *dstPtr, const void *srcPtr)
{
  {
    unsigned int return_value_LZ4_64bits_1;
    return_value_LZ4_64bits_1=LZ4_64bits();
    if(!(return_value_LZ4_64bits_1 == 0u))
      *((unsigned long int *)dstPtr) = *((unsigned long int *)srcPtr);

    else
    {
      ((unsigned int *)dstPtr)[(signed long int)0] = ((unsigned int *)srcPtr)[(signed long int)0];
      ((unsigned int *)dstPtr)[(signed long int)1] = ((unsigned int *)srcPtr)[(signed long int)1];
    }
    goto __CPROVER_DUMP_L4;
  }
  memcpy(dstPtr, srcPtr, (unsigned long int)8);

__CPROVER_DUMP_L4:
  ;
}

// LZ4_count
// file ./../../src/helpers/fst/lz4.c line 394
static unsigned int LZ4_count(const unsigned char *pIn, const unsigned char *pMatch, const unsigned char *pInLimit)
{
  const unsigned char * const pStart = pIn;
  while(!(pIn >= pInLimit + -7l))
  {
    unsigned long int diff;
    unsigned long int return_value_LZ4_read_ARCH_1;
    return_value_LZ4_read_ARCH_1=LZ4_read_ARCH((const void *)pMatch);
    unsigned long int return_value_LZ4_read_ARCH_2;
    return_value_LZ4_read_ARCH_2=LZ4_read_ARCH((const void *)pIn);
    diff = return_value_LZ4_read_ARCH_1 ^ return_value_LZ4_read_ARCH_2;
    if(diff == 0ul)
    {
      pIn = pIn + (signed long int)sizeof(unsigned long int) /*8ul*/ ;
      pMatch = pMatch + (signed long int)sizeof(unsigned long int) /*8ul*/ ;
    }

    else
    {
      unsigned int return_value_LZ4_NbCommonBytes_3;
      return_value_LZ4_NbCommonBytes_3=LZ4_NbCommonBytes(diff);
      pIn = pIn + (signed long int)return_value_LZ4_NbCommonBytes_3;
      return (unsigned int)(pIn - pStart);
    }
  }
  unsigned int return_value_LZ4_64bits_6;
  return_value_LZ4_64bits_6=LZ4_64bits();
  unsigned int return_value_LZ4_read32_4;
  unsigned int return_value_LZ4_read32_5;
  if(!(return_value_LZ4_64bits_6 == 0u))
  {
    if(!(pIn >= pInLimit + -3l))
    {
      return_value_LZ4_read32_4=LZ4_read32((const void *)pMatch);
      return_value_LZ4_read32_5=LZ4_read32((const void *)pIn);
      if(return_value_LZ4_read32_4 == return_value_LZ4_read32_5)
      {
        pIn = pIn + (signed long int)4;
        pMatch = pMatch + (signed long int)4;
      }

    }

  }

  unsigned short int return_value_LZ4_read16_7;
  unsigned short int return_value_LZ4_read16_8;
  if(!(pIn >= pInLimit + -1l))
  {
    return_value_LZ4_read16_7=LZ4_read16((const void *)pMatch);
    return_value_LZ4_read16_8=LZ4_read16((const void *)pIn);
    if(return_value_LZ4_read16_7 == return_value_LZ4_read16_8)
    {
      pIn = pIn + (signed long int)2;
      pMatch = pMatch + (signed long int)2;
    }

  }

  if(!(pIn >= pInLimit))
  {
    if(*pMatch == *pIn)
      pIn = pIn + 1l;

  }

  return (unsigned int)(pIn - pStart);
}

// LZ4_create
// file ./../../src/helpers/fst/lz4.c line 1314
void * LZ4_create(const char *inputBuffer)
{
  void *lz4ds;
  lz4ds=calloc((unsigned long int)8, (unsigned long int)((1 << 14 - 3) + 4));
  LZ4_init((struct anonymous_23 *)lz4ds, (const unsigned char *)inputBuffer);
  return lz4ds;
}

// LZ4_createStream
// file ./../../src/helpers/fst/lz4.c line 765
struct anonymous_25 * LZ4_createStream(void)
{
  struct anonymous_25 *lz4s;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)8, (unsigned long int)((1 << 14 - 3) + 4));
  lz4s = (struct anonymous_25 *)return_value_calloc_1;
  LZ4_resetStream(lz4s);
  return lz4s;
}

// LZ4_createStreamDecode
// file ./../../src/helpers/fst/lz4.c line 1152
struct anonymous_27 * LZ4_createStreamDecode(void)
{
  struct anonymous_27 *lz4s;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(unsigned long int) /*8ul*/ , (unsigned long int)4);
  lz4s = (struct anonymous_27 *)return_value_calloc_1;
  return lz4s;
}

// LZ4_decompress_fast
// file ./../../src/helpers/fst/lz4.c line 1131
signed int LZ4_decompress_fast(const char *source, char *dest, signed int originalSize)
{
  signed int return_value_LZ4_decompress_generic_1;
  return_value_LZ4_decompress_generic_1=LZ4_decompress_generic(source, dest, 0, originalSize, 0, 0, 0, withPrefix64k, (unsigned char *)(dest - (signed long int)(64 * (1 << 10))), (const unsigned char *)(void *)0, (const unsigned long int)(64 * (1 << 10)));
  return return_value_LZ4_decompress_generic_1;
}

// LZ4_decompress_fast_continue
// file ./../../src/helpers/fst/lz4.c line 1217
signed int LZ4_decompress_fast_continue(struct anonymous_27 *LZ4_streamDecode, const char *source, char *dest, signed int originalSize)
{
  struct anonymous_28 *lz4sd = (struct anonymous_28 *)LZ4_streamDecode;
  signed int result;
  if(lz4sd->prefixEnd == (unsigned char *)dest)
  {
    result=LZ4_decompress_generic(source, dest, 0, originalSize, 0, 0, 0, usingExtDict, lz4sd->prefixEnd - (signed long int)lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
    if(!(result >= 1))
      return result;

    lz4sd->prefixSize = lz4sd->prefixSize + (unsigned long int)originalSize;
    lz4sd->prefixEnd = lz4sd->prefixEnd + (signed long int)originalSize;
  }

  else
  {
    lz4sd->extDictSize = lz4sd->prefixSize;
    lz4sd->externalDict = (unsigned char *)dest - (signed long int)lz4sd->extDictSize;
    result=LZ4_decompress_generic(source, dest, 0, originalSize, 0, 0, 0, usingExtDict, (unsigned char *)dest, lz4sd->externalDict, lz4sd->extDictSize);
    if(!(result >= 1))
      return result;

    lz4sd->prefixSize = (unsigned long int)originalSize;
    lz4sd->prefixEnd = (unsigned char *)dest + (signed long int)originalSize;
  }
  return result;
}

// LZ4_decompress_fast_usingDict
// file ./../../src/helpers/fst/lz4.c line 1272
signed int LZ4_decompress_fast_usingDict(const char *source, char *dest, signed int originalSize, const char *dictStart, signed int dictSize)
{
  signed int return_value_LZ4_decompress_usingDict_generic_1;
  return_value_LZ4_decompress_usingDict_generic_1=LZ4_decompress_usingDict_generic(source, dest, 0, originalSize, 0, dictStart, dictSize);
  return return_value_LZ4_decompress_usingDict_generic_1;
}

// LZ4_decompress_fast_withPrefix64k
// file ./../../src/helpers/fst/lz4.c line 1361
signed int LZ4_decompress_fast_withPrefix64k(const char *source, char *dest, signed int originalSize)
{
  signed int return_value_LZ4_decompress_generic_1;
  return_value_LZ4_decompress_generic_1=LZ4_decompress_generic(source, dest, 0, originalSize, 0, 0, 0, withPrefix64k, (unsigned char *)dest - (signed long int)(64 * (1 << 10)), (const unsigned char *)(void *)0, (const unsigned long int)(64 * (1 << 10)));
  return return_value_LZ4_decompress_generic_1;
}

// LZ4_decompress_generic
// file ./../../src/helpers/fst/lz4.c line 942
static inline signed int LZ4_decompress_generic(const char * const source, char * const dest, signed int inputSize, signed int outputSize, signed int endOnInput, signed int partialDecoding, signed int targetOutputSize, signed int dict, const unsigned char * const lowPrefix, const unsigned char * const dictStart, const unsigned long int dictSize)
{
  const unsigned char * restrict ip = (const unsigned char *)source;
  const unsigned char * const iend = ip + (signed long int)inputSize;
  unsigned char *op = (unsigned char *)dest;
  unsigned char * const oend = op + (signed long int)outputSize;
  unsigned char *cpy;
  unsigned char *oexit = op + (signed long int)targetOutputSize;
  const unsigned char * const lowLimit = lowPrefix - (signed long int)dictSize;
  const unsigned char * const dictEnd = (const unsigned char *)dictStart + (signed long int)dictSize;
  const unsigned long int dec32table[8l] = { (const unsigned long int)4, (const unsigned long int)1, (const unsigned long int)2, (const unsigned long int)1, (const unsigned long int)4, (const unsigned long int)4, (const unsigned long int)4, (const unsigned long int)4 };
  const unsigned long int dec64table[8l] = { (const unsigned long int)0, (const unsigned long int)0, (const unsigned long int)0, (unsigned long int)-1, (const unsigned long int)0, (const unsigned long int)1, (const unsigned long int)2, (const unsigned long int)3 };
  const signed int safeDecode = (const signed int)(endOnInput == 1);
  const signed int checkOffset = (const signed int)(safeDecode != 0 && dictSize < (unsigned long int)(signed int)(64 * (1 << 10)));
  if(!(partialDecoding == 0) && !(oend + -12l >= oexit))
    oexit = oend - (signed long int)(8 + 4);

  _Bool tmp_if_expr_1;
  const unsigned char * restrict tmp_post_2;
  const unsigned char * restrict tmp_post_3;
  const unsigned char * restrict tmp_post_5;
  unsigned char *tmp_post_6;
  const unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  const unsigned char *tmp_post_9;
  if(outputSize == 0 && !(endOnInput == 0))
  {
    if(inputSize == 1)
      tmp_if_expr_1 = (signed int)*ip == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    return tmp_if_expr_1 ? 0 : -1;
  }

  else
    if(endOnInput == 0 && outputSize == 0)
      return (signed int)*ip == 0 ? 1 : -1;

    else
    {
      while((_Bool)1)
      {
        unsigned int token;
        unsigned long int length;
        const unsigned char *match;
        tmp_post_2 = ip;
        ip = ip + 1l;
        token = (unsigned int)*tmp_post_2;
        length = (unsigned long int)(token >> 4);
        if(length == 15ul)
        {
          unsigned int s;
          do
          {
            tmp_post_3 = ip;
            ip = ip + 1l;
            s = (unsigned int)*tmp_post_3;
            length = length + (unsigned long int)s;
          }
          while(s == 255u && (endOnInput == 0 || !(ip >= iend + -15l)));
          if(!(safeDecode == 0) && !((unsigned long int)(op + (signed long int)length) >= (unsigned long int)op))
            goto _output_error;

          if(!(safeDecode == 0) && !((unsigned long int)(ip + (signed long int)length) >= (unsigned long int)ip))
            goto _output_error;

        }

        cpy = op + (signed long int)length;
        if(endOnInput == 0 && !(oend + -8l >= cpy) || !(endOnInput == 0) && (!(iend + -8l >= ip + (signed long int)length) || !(partialDecoding == 0 ? oend + -12l >= cpy : oexit >= cpy)))
        {
          if(!(partialDecoding == 0))
          {
            if(!(oend >= cpy))
              goto _output_error;

            if(!(endOnInput == 0) && !(iend >= ip + (signed long int)length))
              goto _output_error;

          }

          else
          {
            if(endOnInput == 0 && !(cpy == oend))
              goto _output_error;

            if(!(endOnInput == 0) && (!(ip + (signed long int)length == iend) || !(oend >= cpy)))
              goto _output_error;

          }
          memcpy((void *)op, (const void *)ip, length);
          ip = ip + (signed long int)length;
          op = op + (signed long int)length;
          break;
        }

        LZ4_wildCopy((void *)op, (const void *)ip, (void *)cpy);
        ip = ip + (signed long int)length;
        op = cpy;
        unsigned short int return_value_LZ4_readLE16_4;
        return_value_LZ4_readLE16_4=LZ4_readLE16((const void *)ip);
        match = cpy - (signed long int)return_value_LZ4_readLE16_4;
        ip = ip + (signed long int)2;
        if(!(checkOffset == 0) && !(match >= lowLimit))
          goto _output_error;

        length = (unsigned long int)(token & (1U << 4) - (unsigned int)1);
        if(length == 15ul)
        {
          unsigned int LZ4_decompress_generic__1__1__3__s;
          while((_Bool)1)
          {
            if(!(endOnInput == 0) && !(iend + -5l >= ip))
              goto _output_error;

            tmp_post_5 = ip;
            ip = ip + 1l;
            LZ4_decompress_generic__1__1__3__s = (unsigned int)*tmp_post_5;
            length = length + (unsigned long int)LZ4_decompress_generic__1__1__3__s;
            if(!(LZ4_decompress_generic__1__1__3__s == 255u))
              break;

          }
          if(!(safeDecode == 0) && !((unsigned long int)(op + (signed long int)length) >= (unsigned long int)op))
            goto _output_error;

        }

        length = length + (unsigned long int)4;
        if(dict == usingExtDict && !(match >= lowPrefix))
        {
          if(!(oend + -5l >= op + (signed long int)length))
            goto _output_error;

          if((unsigned long int)(lowPrefix - match) >= length)
          {
            match = dictEnd - (lowPrefix - match);
            memcpy((void *)op, (const void *)match, length);
            op = op + (signed long int)length;
          }

          else
          {
            unsigned long int copySize = (unsigned long int)(lowPrefix - match);
            memcpy((void *)op, (const void *)(dictEnd - (signed long int)copySize), copySize);
            op = op + (signed long int)copySize;
            copySize = length - copySize;
            if(!((unsigned long int)(op - lowPrefix) >= copySize))
            {
              unsigned char * const endOfMatch = op + (signed long int)copySize;
              const unsigned char *copyFrom = lowPrefix;
              for( ; !(op >= endOfMatch); *tmp_post_6 = *tmp_post_7)
              {
                tmp_post_6 = op;
                op = op + 1l;
                tmp_post_7 = copyFrom;
                copyFrom = copyFrom + 1l;
              }
            }

            else
            {
              memcpy((void *)op, (const void *)lowPrefix, copySize);
              op = op + (signed long int)copySize;
            }
          }
        }

        else
        {
          cpy = op + (signed long int)length;
          if(!(op - match >= 8l))
          {
            const unsigned long int dec64 = dec64table[op - match];
            op[(signed long int)0] = match[(signed long int)0];
            op[(signed long int)1] = match[(signed long int)1];
            op[(signed long int)2] = match[(signed long int)2];
            op[(signed long int)3] = match[(signed long int)3];
            match = match + (signed long int)dec32table[op - match];
            LZ4_copy4((void *)(op + (signed long int)4), (const void *)match);
            op = op + (signed long int)8;
            match = match - (signed long int)dec64;
          }

          else
          {
            LZ4_copy8((void *)op, (const void *)match);
            op = op + (signed long int)8;
            match = match + (signed long int)8;
          }
          if(!(oend + -12l >= cpy))
          {
            if(!(oend + -5l >= cpy))
              goto _output_error;

            if(!(op >= oend + -8l))
            {
              LZ4_wildCopy((void *)op, (const void *)match, (void *)(oend - (signed long int)8));
              match = match + ((oend - (signed long int)8) - op);
              op = oend - (signed long int)8;
            }

            for( ; !(op >= cpy); *tmp_post_8 = *tmp_post_9)
            {
              tmp_post_8 = op;
              op = op + 1l;
              tmp_post_9 = match;
              match = match + 1l;
            }
          }

          else
            LZ4_wildCopy((void *)op, (const void *)match, (void *)cpy);
          op = cpy;
        }
      }
      if(!(endOnInput == 0))
        return (signed int)((char *)op - dest);

      else
        return (signed int)((char *)ip - source);

    _output_error:
      ;
      return (signed int)-((char *)ip - source) - 1;
    }
}

// LZ4_decompress_safe
// file ./../../src/helpers/fst/lz4.c line 1121
signed int LZ4_decompress_safe(const char *source, char *dest, signed int compressedSize, signed int maxDecompressedSize)
{
  signed int return_value_LZ4_decompress_generic_1;
  return_value_LZ4_decompress_generic_1=LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize, 1, 0, 0, noDict, (unsigned char *)dest, (const unsigned char *)(void *)0, (const unsigned long int)0);
  return return_value_LZ4_decompress_generic_1;
}

// LZ4_decompress_safe_continue
// file ./../../src/helpers/fst/lz4.c line 1188
signed int LZ4_decompress_safe_continue(struct anonymous_27 *LZ4_streamDecode, const char *source, char *dest, signed int compressedSize, signed int maxOutputSize)
{
  struct anonymous_28 *lz4sd = (struct anonymous_28 *)LZ4_streamDecode;
  signed int result;
  if(lz4sd->prefixEnd == (unsigned char *)dest)
  {
    result=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, 1, 0, 0, usingExtDict, lz4sd->prefixEnd - (signed long int)lz4sd->prefixSize, lz4sd->externalDict, lz4sd->extDictSize);
    if(!(result >= 1))
      return result;

    lz4sd->prefixSize = lz4sd->prefixSize + (unsigned long int)result;
    lz4sd->prefixEnd = lz4sd->prefixEnd + (signed long int)result;
  }

  else
  {
    lz4sd->extDictSize = lz4sd->prefixSize;
    lz4sd->externalDict = lz4sd->prefixEnd - (signed long int)lz4sd->extDictSize;
    result=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, 1, 0, 0, usingExtDict, (unsigned char *)dest, lz4sd->externalDict, lz4sd->extDictSize);
    if(!(result >= 1))
      return result;

    lz4sd->prefixSize = (unsigned long int)result;
    lz4sd->prefixEnd = (unsigned char *)dest + (signed long int)result;
  }
  return result;
}

// LZ4_decompress_safe_forceExtDict
// file ./../../src/helpers/fst/lz4.c line 1278
signed int LZ4_decompress_safe_forceExtDict(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize, const char *dictStart, signed int dictSize)
{
  signed int return_value_LZ4_decompress_generic_1;
  return_value_LZ4_decompress_generic_1=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, 1, 0, 0, usingExtDict, (unsigned char *)dest, (unsigned char *)dictStart, (const unsigned long int)dictSize);
  return return_value_LZ4_decompress_generic_1;
}

// LZ4_decompress_safe_partial
// file ./../../src/helpers/fst/lz4.c line 1126
signed int LZ4_decompress_safe_partial(const char *source, char *dest, signed int compressedSize, signed int targetOutputSize, signed int maxDecompressedSize)
{
  signed int return_value_LZ4_decompress_generic_1;
  return_value_LZ4_decompress_generic_1=LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize, 1, 1, targetOutputSize, noDict, (unsigned char *)dest, (const unsigned char *)(void *)0, (const unsigned long int)0);
  return return_value_LZ4_decompress_generic_1;
}

// LZ4_decompress_safe_usingDict
// file ./../../src/helpers/fst/lz4.c line 1267
signed int LZ4_decompress_safe_usingDict(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize, const char *dictStart, signed int dictSize)
{
  signed int return_value_LZ4_decompress_usingDict_generic_1;
  return_value_LZ4_decompress_usingDict_generic_1=LZ4_decompress_usingDict_generic(source, dest, compressedSize, maxOutputSize, 1, dictStart, dictSize);
  return return_value_LZ4_decompress_usingDict_generic_1;
}

// LZ4_decompress_safe_withPrefix64k
// file ./../../src/helpers/fst/lz4.c line 1356
signed int LZ4_decompress_safe_withPrefix64k(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize)
{
  signed int return_value_LZ4_decompress_generic_1;
  return_value_LZ4_decompress_generic_1=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, 1, 0, 0, withPrefix64k, (unsigned char *)dest - (signed long int)(64 * (1 << 10)), (const unsigned char *)(void *)0, (const unsigned long int)(64 * (1 << 10)));
  return return_value_LZ4_decompress_generic_1;
}

// LZ4_decompress_usingDict_generic
// file ./../../src/helpers/fst/lz4.c line 1254
static inline signed int LZ4_decompress_usingDict_generic(const char *source, char *dest, signed int compressedSize, signed int maxOutputSize, signed int safe, const char *dictStart, signed int dictSize)
{
  signed int return_value_LZ4_decompress_generic_1;
  signed int return_value_LZ4_decompress_generic_2;
  if(dictSize == 0)
  {
    return_value_LZ4_decompress_generic_1=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, safe, 0, 0, noDict, (unsigned char *)dest, (const unsigned char *)(void *)0, (const unsigned long int)0);
    return return_value_LZ4_decompress_generic_1;
  }

  else
  {
    if(dictStart + (signed long int)dictSize == dest)
    {
      if(dictSize >= 64)
      {
        return_value_LZ4_decompress_generic_2=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, safe, 0, 0, withPrefix64k, (unsigned char *)dest - (signed long int)(64 * (1 << 10)), (const unsigned char *)(void *)0, (const unsigned long int)0);
        return return_value_LZ4_decompress_generic_2;
      }

      signed int return_value_LZ4_decompress_generic_3;
      return_value_LZ4_decompress_generic_3=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, safe, 0, 0, noDict, (unsigned char *)dest - (signed long int)dictSize, (const unsigned char *)(void *)0, (const unsigned long int)0);
      return return_value_LZ4_decompress_generic_3;
    }

    signed int return_value_LZ4_decompress_generic_4;
    return_value_LZ4_decompress_generic_4=LZ4_decompress_generic(source, dest, compressedSize, maxOutputSize, safe, 0, 0, usingExtDict, (unsigned char *)dest, (unsigned char *)dictStart, (const unsigned long int)dictSize);
    return return_value_LZ4_decompress_generic_4;
  }
}

// LZ4_freeStream
// file ./../../src/helpers/fst/lz4.c line 773
signed int LZ4_freeStream(struct anonymous_25 *LZ4_stream)
{
  free((void *)LZ4_stream);
  return 0;
}

// LZ4_freeStreamDecode
// file ./../../src/helpers/fst/lz4.c line 1158
signed int LZ4_freeStreamDecode(struct anonymous_27 *LZ4_stream)
{
  free((void *)LZ4_stream);
  return 0;
}

// LZ4_getPosition
// file ./../../src/helpers/fst/lz4.c line 492
static const unsigned char * LZ4_getPosition(const unsigned char *p, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase)
{
  unsigned int h;
  h=LZ4_hashPosition(p, tableType);
  const unsigned char *return_value_LZ4_getPositionOnHash_1;
  return_value_LZ4_getPositionOnHash_1=LZ4_getPositionOnHash(h, tableBase, tableType, srcBase);
  return return_value_LZ4_getPositionOnHash_1;
}

// LZ4_getPositionOnHash
// file ./../../src/helpers/fst/lz4.c line 485
static const unsigned char * LZ4_getPositionOnHash(unsigned int h, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase)
{
  if((signed int)tableType == byPtr)
  {
    const unsigned char **hashTable = (const unsigned char **)tableBase;
    return hashTable[(signed long int)h];
  }

  if((signed int)tableType == byU32)
  {
    unsigned int *LZ4_getPositionOnHash__1__2__hashTable = (unsigned int *)tableBase;
    return (signed long int)LZ4_getPositionOnHash__1__2__hashTable[(signed long int)h] + srcBase;
  }

  unsigned short int *LZ4_getPositionOnHash__1__3__hashTable = (unsigned short int *)tableBase;
  return (signed long int)LZ4_getPositionOnHash__1__3__hashTable[(signed long int)h] + srcBase;
}

// LZ4_hashPosition
// file ./../../src/helpers/fst/lz4.c line 467
static unsigned int LZ4_hashPosition(const unsigned char *p, enum anonymous_20 tableType)
{
  unsigned int return_value_LZ4_read32_1;
  return_value_LZ4_read32_1=LZ4_read32((const void *)p);
  unsigned int return_value_LZ4_hashSequence_2;
  return_value_LZ4_hashSequence_2=LZ4_hashSequence(return_value_LZ4_read32_1, tableType);
  return return_value_LZ4_hashSequence_2;
}

// LZ4_hashSequence
// file ./../../src/helpers/fst/lz4.c line 459
static unsigned int LZ4_hashSequence(unsigned int sequence, enum anonymous_20 tableType)
{
  if((signed int)tableType == byU16)
    return sequence * 2654435761U >> 4 * 8 - ((14 - 2) + 1);

  else
    return sequence * 2654435761U >> 4 * 8 - (14 - 2);
}

// LZ4_init
// file ./../../src/helpers/fst/lz4.c line 1301
static void LZ4_init(struct anonymous_23 *lz4ds, const unsigned char *base)
{
  memset((void *)lz4ds, 0, (unsigned long int)((1 << 14 - 3) + 4) * sizeof(signed long long int) /*8ul*/ );
  lz4ds->bufferStart = base;
}

// LZ4_isLittleEndian
// file ./../../src/helpers/fst/lz4.c line 180
static unsigned int LZ4_isLittleEndian(void)
{
  /* tag-#anon#clUN[U32'i'||lARR4{U8}_U8_'c'|] */
union anonymous_30
{
  // i
  unsigned int i;
  // c
  unsigned char c[4l];
};

/* */
  ;
  union anonymous_30 one = { .i=(unsigned int)1 };
  return (unsigned int)one.c[(signed long int)0];
}

// LZ4_loadDict
// file ./../../src/helpers/fst/lz4.c line 780
signed int LZ4_loadDict(struct anonymous_25 *LZ4_dict, const char *dictionary, signed int dictSize)
{
  struct anonymous_23 *dict = (struct anonymous_23 *)LZ4_dict;
  const unsigned char *p = (const unsigned char *)dictionary;
  const unsigned char * const dictEnd = p + (signed long int)dictSize;
  const unsigned char *base;
  if(!(dict->initCheck == 0u))
    LZ4_resetStream(LZ4_dict);

  if(!(dictSize >= 4))
  {
    dict->dictionary = (const unsigned char *)(void *)0;
    dict->dictSize = (unsigned int)0;
    return 0;
  }

  else
  {
    if(dictEnd + -65536l >= p)
      p = dictEnd - (signed long int)(64 * (1 << 10));

    base = p - (signed long int)dict->currentOffset;
    dict->dictionary = p;
    dict->dictSize = (unsigned int)(dictEnd - p);
    dict->currentOffset = dict->currentOffset + dict->dictSize;
    for( ; dictEnd + -4l >= p; p = p + (signed long int)3)
      LZ4_putPosition(p, (void *)dict, (enum anonymous_20)byU32, base);
    return (signed int)dict->dictSize;
  }
}

// LZ4_putPosition
// file ./../../src/helpers/fst/lz4.c line 479
static void LZ4_putPosition(const unsigned char *p, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase)
{
  unsigned int h;
  h=LZ4_hashPosition(p, tableType);
  LZ4_putPositionOnHash(p, h, tableBase, tableType, srcBase);
}

// LZ4_putPositionOnHash
// file ./../../src/helpers/fst/lz4.c line 469
static void LZ4_putPositionOnHash(const unsigned char *p, unsigned int h, void *tableBase, enum anonymous_20 tableType, const unsigned char *srcBase)
{
  const unsigned char **hashTable;
  unsigned int *LZ4_putPositionOnHash__1__1__2__hashTable;
  unsigned short int *LZ4_putPositionOnHash__1__1__3__hashTable;
  switch((signed int)tableType)
  {
    case byPtr:
    {
      hashTable = (const unsigned char **)tableBase;
      hashTable[(signed long int)h] = p;
      break;
    }
    case byU32:
    {
      LZ4_putPositionOnHash__1__1__2__hashTable = (unsigned int *)tableBase;
      LZ4_putPositionOnHash__1__1__2__hashTable[(signed long int)h] = (unsigned int)(p - srcBase);
      break;
    }
    case byU16:
    {
      LZ4_putPositionOnHash__1__1__3__hashTable = (unsigned short int *)tableBase;
      LZ4_putPositionOnHash__1__1__3__hashTable[(signed long int)h] = (unsigned short int)(p - srcBase);
    }
  }
}

// LZ4_read16
// file ./../../src/helpers/fst/lz4.c line 214
static unsigned short int LZ4_read16(const void *memPtr)
{
  return *((unsigned short int *)memPtr);
}

// LZ4_read32
// file ./../../src/helpers/fst/lz4.c line 226
static unsigned int LZ4_read32(const void *memPtr)
{
  return *((unsigned int *)memPtr);
}

// LZ4_read64
// file ./../../src/helpers/fst/lz4.c line 238
static unsigned long int LZ4_read64(const void *memPtr)
{
  return *((unsigned long int *)memPtr);
}

// LZ4_readLE16
// file ./../../src/helpers/fst/lz4.c line 187
static unsigned short int LZ4_readLE16(const void *memPtr)
{
  unsigned int return_value_LZ4_isLittleEndian_1;
  return_value_LZ4_isLittleEndian_1=LZ4_isLittleEndian();
  if(!(return_value_LZ4_isLittleEndian_1 == 0u))
    return *((unsigned short int *)memPtr);

  else
  {
    const unsigned char *p = (const unsigned char *)memPtr;
    return (unsigned short int)((signed int)(unsigned short int)p[(signed long int)0] + ((signed int)p[(signed long int)1] << 8));
  }
}

// LZ4_read_ARCH
// file ./../../src/helpers/fst/lz4.c line 250
static unsigned long int LZ4_read_ARCH(const void *p)
{
  unsigned int return_value_LZ4_64bits_3;
  return_value_LZ4_64bits_3=LZ4_64bits();
  unsigned long int return_value_LZ4_read64_1;
  unsigned int return_value_LZ4_read32_2;
  if(!(return_value_LZ4_64bits_3 == 0u))
  {
    return_value_LZ4_read64_1=LZ4_read64(p);
    return (unsigned long int)return_value_LZ4_read64_1;
  }

  else
  {
    return_value_LZ4_read32_2=LZ4_read32(p);
    return (unsigned long int)return_value_LZ4_read32_2;
  }
}

// LZ4_renormDictT
// file ./../../src/helpers/fst/lz4.c line 812
static void LZ4_renormDictT(struct anonymous_23 *LZ4_dict, const unsigned char *src)
{
  _Bool tmp_if_expr_1;
  if(LZ4_dict->currentOffset >= 2147483649u)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (unsigned long int)LZ4_dict->currentOffset > (unsigned long int)src ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    unsigned int delta = LZ4_dict->currentOffset - (unsigned int)(64 * (1 << 10));
    const unsigned char *dictEnd = LZ4_dict->dictionary + (signed long int)LZ4_dict->dictSize;
    signed int i = 0;
    for( ; !(i >= 4096); i = i + 1)
      if(!(LZ4_dict->hashTable[(signed long int)i] >= delta))
        LZ4_dict->hashTable[(signed long int)i] = (unsigned int)0;

      else
        LZ4_dict->hashTable[(signed long int)i] = LZ4_dict->hashTable[(signed long int)i] - delta;
    LZ4_dict->currentOffset = (unsigned int)(64 * (1 << 10));
    if(LZ4_dict->dictSize >= 65537u)
      LZ4_dict->dictSize = (unsigned int)(64 * (1 << 10));

    LZ4_dict->dictionary = dictEnd - (signed long int)LZ4_dict->dictSize;
  }

}

// LZ4_resetStream
// file ./../../src/helpers/fst/lz4.c line 760
void LZ4_resetStream(struct anonymous_25 *LZ4_stream)
{
  memset((void *)LZ4_stream, 0, sizeof(struct anonymous_25) /*16416ul*/ );
}

// LZ4_resetStreamState
// file ./../../src/helpers/fst/lz4.c line 1307
signed int LZ4_resetStreamState(void *state, const char *inputBuffer)
{
  if(!((3ul & (unsigned long int)state) == 0ul))
    return 1;

  else
  {
    LZ4_init((struct anonymous_23 *)state, (const unsigned char *)inputBuffer);
    return 0;
  }
}

// LZ4_saveDict
// file ./../../src/helpers/fst/lz4.c line 915
signed int LZ4_saveDict(struct anonymous_25 *LZ4_dict, char *safeBuffer, signed int dictSize)
{
  struct anonymous_23 *dict = (struct anonymous_23 *)LZ4_dict;
  const unsigned char *previousDictEnd = dict->dictionary + (signed long int)dict->dictSize;
  if((unsigned int)dictSize >= 65537u)
    dictSize = 64 * (1 << 10);

  if(!(dict->dictSize >= (unsigned int)dictSize))
    dictSize = (signed int)dict->dictSize;

  memmove((void *)safeBuffer, (const void *)(previousDictEnd - (signed long int)dictSize), (unsigned long int)dictSize);
  dict->dictionary = (const unsigned char *)safeBuffer;
  dict->dictSize = (unsigned int)dictSize;
  return dictSize;
}

// LZ4_setStreamDecode
// file ./../../src/helpers/fst/lz4.c line 1171
signed int LZ4_setStreamDecode(struct anonymous_27 *LZ4_streamDecode, const char *dictionary, signed int dictSize)
{
  struct anonymous_28 *lz4sd = (struct anonymous_28 *)LZ4_streamDecode;
  lz4sd->prefixSize = (unsigned long int)dictSize;
  lz4sd->prefixEnd = (unsigned char *)dictionary + (signed long int)dictSize;
  lz4sd->externalDict = (unsigned char *)(void *)0;
  lz4sd->extDictSize = (unsigned long int)0;
  return 1;
}

// LZ4_sizeofState
// file ./../../src/helpers/fst/lz4.c line 1330
signed int LZ4_sizeofState(void)
{
  return (signed int)((unsigned long int)((1 << 14 - 3) + 4) * sizeof(signed long long int) /*8ul*/ );
}

// LZ4_sizeofStreamState
// file ./../../src/helpers/fst/lz4.c line 1299
signed int LZ4_sizeofStreamState(void)
{
  return (signed int)((unsigned long int)((1 << 14 - 3) + 4) * sizeof(signed long long int) /*8ul*/ );
}

// LZ4_slideInputBuffer
// file ./../../src/helpers/fst/lz4.c line 1321
char * LZ4_slideInputBuffer(void *LZ4_Data)
{
  struct anonymous_23 *ctx = (struct anonymous_23 *)LZ4_Data;
  signed int dictSize;
  dictSize=LZ4_saveDict((struct anonymous_25 *)ctx, (char *)ctx->bufferStart, 64 * (1 << 10));
  return (char *)(ctx->bufferStart + (signed long int)dictSize);
}

// LZ4_uncompress
// file ./../../src/helpers/fst/lz4.c line 1293
signed int LZ4_uncompress(const char *source, char *dest, signed int outputSize)
{
  signed int return_value_LZ4_decompress_fast_1;
  return_value_LZ4_decompress_fast_1=LZ4_decompress_fast(source, dest, outputSize);
  return return_value_LZ4_decompress_fast_1;
}

// LZ4_uncompress_unknownOutputSize
// file ./../../src/helpers/fst/lz4.c line 1294
signed int LZ4_uncompress_unknownOutputSize(const char *source, char *dest, signed int isize, signed int maxOutputSize)
{
  signed int return_value_LZ4_decompress_safe_1;
  return_value_LZ4_decompress_safe_1=LZ4_decompress_safe(source, dest, isize, maxOutputSize);
  return return_value_LZ4_decompress_safe_1;
}

// LZ4_versionNumber
// file ./../../src/helpers/fst/lz4.c line 428
signed int LZ4_versionNumber(void)
{
  return 1 * 100 * 100 + 5 * 100 + 0;
}

// LZ4_wildCopy
// file ./../../src/helpers/fst/lz4.c line 286
static void LZ4_wildCopy(void *dstPtr, const void *srcPtr, void *dstEnd)
{
  unsigned char *d = (unsigned char *)dstPtr;
  const unsigned char *s = (const unsigned char *)srcPtr;
  unsigned char *e = (unsigned char *)dstEnd;
  do
  {
    LZ4_copy8((void *)d, (const void *)s);
    d = d + (signed long int)8;
    s = s + (signed long int)8;
  }
  while(!(d >= e));
}

// LZ4_writeLE16
// file ./../../src/helpers/fst/lz4.c line 198
static void LZ4_writeLE16(void *memPtr, unsigned short int value)
{
  unsigned int return_value_LZ4_isLittleEndian_1;
  return_value_LZ4_isLittleEndian_1=LZ4_isLittleEndian();
  if(!(return_value_LZ4_isLittleEndian_1 == 0u))
  {
    *((unsigned short int *)memPtr) = value;
    goto __CPROVER_DUMP_L3;
  }

  else
  {
    unsigned char *p = (unsigned char *)memPtr;
    p[(signed long int)0] = (unsigned char)value;
    p[(signed long int)1] = (unsigned char)((signed int)value >> 8);
  }

__CPROVER_DUMP_L3:
  ;
}

// LZMA_close
// file ./../../src/liblzma/LzmaLib.h line 33
void LZMA_close(void *handle)
{
  struct lzma_handle_t *h = (struct lzma_handle_t *)handle;
  if(!(h == ((struct lzma_handle_t *)NULL)))
  {
    if((signed int)h->state == LZMA_STATE_WRITE)
    {
      LZMA_flush((void *)h);
      LZMA_write_varint(h, (unsigned long int)0);
    }

    if(!(h->dmem == ((unsigned char *)NULL)))
      free((void *)h->dmem);

    if(!(h->mem == ((unsigned char *)NULL)))
      free((void *)h->mem);

    close(h->fd);
    free((void *)h);
  }

}

// LZMA_fdopen
// file ./../../src/liblzma/LzmaLib.h line 32
void * LZMA_fdopen(signed int fd, const char *mode)
{
  struct lzma_handle_t *h;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct lzma_handle_t) /*56ul*/ );
  h = (struct lzma_handle_t *)return_value_calloc_1;
  h->fd = fd;
  h->offs = (unsigned int)0;
  h->depth = (unsigned int)4;
  if((signed int)*mode == 119)
  {
    h->blksiz = (unsigned int)(4 * 1024 * 1024);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)h->blksiz);
    h->mem = (unsigned char *)return_value_malloc_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)h->blksiz);
    h->dmem = (unsigned char *)return_value_malloc_3;
    if(!(mode[1l] == 0))
    {
      const unsigned short int **return_value___ctype_b_loc_5;
      return_value___ctype_b_loc_5=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)mode[1l]]) == 0))
        h->depth = (unsigned int)((signed int)mode[(signed long int)1] - 48);

      else
        if(!(mode[2l] == 0))
        {
          const unsigned short int **return_value___ctype_b_loc_4;
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)mode[2l]]) == 0))
            h->depth = (unsigned int)((signed int)mode[(signed long int)2] - 48);

        }

    }

    h->state = (enum lzma_state_t)LZMA_STATE_WRITE;
    signed long int return_value_write_6;
    static const char z7[3l] = { 'z', '7', 0 };
    return_value_write_6=write(h->fd, (const void *)z7, (unsigned long int)2);
    h->write_cnt = h->write_cnt + (unsigned long int)return_value_write_6;
    return (void *)h;
  }

  else
    if((signed int)*mode == 114)
    {
      h->blksiz = (unsigned int)0;
      h->mem = (unsigned char *)(void *)0;
      h->dmem = (unsigned char *)(void *)0;
      h->state = (enum lzma_state_t)LZMA_STATE_READ_INIT;
      return (void *)h;
    }

    else
    {
      close(h->fd);
      free((void *)h->dmem);
      free((void *)h->mem);
      free((void *)h);
      return (void *)0;
    }
}

// LZMA_flush
// file ./../../src/liblzma/LzmaLib.c line 208
unsigned long int LZMA_flush(void *handle)
{
  struct lzma_handle_t *h = (struct lzma_handle_t *)handle;
  if(!(h == ((struct lzma_handle_t *)NULL)))
  {
    if(!(h->offs == 0u))
    {
      LZMA_write_compress(h, h->mem, (unsigned long int)h->offs);
      h->offs = (unsigned int)0;
    }

  }

  return (unsigned long int)0;
}

// LZMA_read
// file ./../../src/liblzma/LzmaLib.h line 36
unsigned long int LZMA_read(void *handle, void *mem, unsigned long int len)
{
  struct lzma_handle_t *h = (struct lzma_handle_t *)handle;
  unsigned long int rc = (unsigned long int)0;
  char hdr[2l] = { (char)0, (char)0 };
  unsigned long int srclen;
  unsigned long int dstlen;
  signed long int return_value_read_1;
  _Bool tmp_if_expr_2;
  struct anonymous_7 strm;
  enum anonymous_8 lrc;
  signed long int return_value_read_6;
  if(!(h == ((struct lzma_handle_t *)NULL)))
  {

  top:
    ;
    for( ; (_Bool)1; h->state = (enum lzma_state_t)LZMA_STATE_READ_ERROR)
    {
      if(!((signed int)h->state == LZMA_STATE_READ_INIT))
      {
        if((signed int)h->state == LZMA_STATE_READ_GETBLOCK)
          goto __CPROVER_DUMP_L7;

        if((signed int)h->state == LZMA_STATE_READ_GETBYTES)
          goto __CPROVER_DUMP_L19;

        if((signed int)h->state == LZMA_STATE_READ_ERROR)
          goto __CPROVER_DUMP_L23;

        goto __CPROVER_DUMP_L23;
      }

      return_value_read_1=read(h->fd, (void *)hdr, (unsigned long int)2);
      h->read_cnt = h->read_cnt + (unsigned long int)return_value_read_1;
      if((signed int)hdr[0l] == 122)
        tmp_if_expr_2 = (signed int)hdr[(signed long int)1] == 55 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        h->state = (enum lzma_state_t)LZMA_STATE_READ_GETBLOCK;

      else
        h->state = (enum lzma_state_t)LZMA_STATE_READ_ERROR;
      goto top;

    __CPROVER_DUMP_L7:
      ;
      dstlen=LZMA_read_varint(h);
      if(dstlen == 0ul)
        return (unsigned long int)0;

      if(!((unsigned long int)h->blksiz >= dstlen))
      {
        if(!(h->dmem == ((unsigned char *)NULL)))
          free((void *)h->dmem);

        if(!(h->mem == ((unsigned char *)NULL)))
          free((void *)h->mem);

        h->blksiz = (unsigned int)dstlen;
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)h->blksiz);
        h->mem = (unsigned char *)return_value_malloc_3;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc((unsigned long int)h->blksiz);
        h->dmem = (unsigned char *)return_value_malloc_4;
      }

      srclen=LZMA_read_varint(h);
      if(srclen == 0ul)
      {
        signed long int return_value_read_5;
        return_value_read_5=read(h->fd, (void *)h->mem, dstlen);
        rc = (unsigned long int)return_value_read_5;
        h->read_cnt = h->read_cnt + rc;
        h->blklen = (unsigned int)rc;
        h->offs = (unsigned int)0;
        goto __CPROVER_DUMP_L16;
      }

      strm = (struct anonymous_7){ .next_in=(const unsigned char *)(void *)0, .avail_in=(unsigned long int)0,
    .total_in=(unsigned long int)0, .next_out=(unsigned char *)(void *)0,
    .avail_out=(unsigned long int)0,
    .total_out=(unsigned long int)0, .allocator=(struct anonymous_6 *)(void *)0,
    .internal=(struct lzma_internal_s *)(void *)0,
    .reserved_ptr1=(void *)0,
    .reserved_ptr2=(void *)0, .reserved_ptr3=(void *)0,
    .reserved_ptr4=(void *)0, .reserved_int1=(unsigned long int)0,
    .reserved_int2=(unsigned long int)0,
    .reserved_int3=(unsigned long int)0,
    .reserved_int4=(unsigned long int)0,
    .reserved_enum1=(enum anonymous_4)LZMA_RESERVED_ENUM,
    .reserved_enum2=(enum anonymous_4)LZMA_RESERVED_ENUM };
      return_value_read_6=read(h->fd, (void *)h->dmem, srclen);
      rc = (unsigned long int)return_value_read_6;
      h->read_cnt = h->read_cnt + rc;
      lrc=lzma_alone_decoder(&strm, (unsigned long int)(256 * 1024 * 1024));
      if(!((signed int)lrc == LZMA_OK))
      {
        fprintf(stderr, "Error in lzma_alone_decoder(), exiting!\n");
        exit(255);
      }

      strm.next_in = h->dmem;
      strm.avail_in = srclen;
      strm.next_out = h->mem;
      strm.avail_out = (unsigned long int)h->blksiz;
      lrc=lzma_code(&strm, (enum anonymous_10)LZMA_RUN);
      lzma_end(&strm);
      if((signed int)lrc == LZMA_OK || (signed int)lrc == LZMA_STREAM_END)
      {
        dstlen = strm.total_out;
        h->blklen = (unsigned int)dstlen;
        h->offs = (unsigned int)0;
        break;
      }

    }

  __CPROVER_DUMP_L16:
    ;
    if(dstlen >= len)
    {
      memcpy(mem, (const void *)h->mem, len);
      h->offs = (unsigned int)len;
      rc = len;
      h->state = (enum lzma_state_t)LZMA_STATE_READ_GETBYTES;
    }

    else
    {
      memcpy(mem, (const void *)h->mem, dstlen);
      unsigned long int return_value_LZMA_read_7;
      return_value_LZMA_read_7=LZMA_read((void *)h, (void *)((char *)mem + (signed long int)dstlen), len - dstlen);
      rc = dstlen + return_value_LZMA_read_7;
    }
    goto __CPROVER_DUMP_L24;

  __CPROVER_DUMP_L19:
    ;
    if(!(len + (unsigned long int)h->offs >= (unsigned long int)h->blklen))
    {
      memcpy(mem, (const void *)(h->mem + (signed long int)h->offs), len);
      h->offs = h->offs + (unsigned int)len;
      rc = len;
    }

    else
      if(len + (unsigned long int)h->offs == (unsigned long int)h->blklen)
      {
        memcpy(mem, (const void *)(h->mem + (signed long int)h->offs), len);
        h->offs = (unsigned int)0;
        rc = len;
        h->state = (enum lzma_state_t)LZMA_STATE_READ_GETBLOCK;
      }

      else
      {
        unsigned long int cpylen = (unsigned long int)(h->blklen - h->offs);
        memcpy(mem, (const void *)(h->mem + (signed long int)h->offs), cpylen);
        h->state = (enum lzma_state_t)LZMA_STATE_READ_GETBLOCK;
        unsigned long int return_value_LZMA_read_8;
        return_value_LZMA_read_8=LZMA_read((void *)h, (void *)((char *)mem + (signed long int)cpylen), len - cpylen);
        rc = cpylen + return_value_LZMA_read_8;
      }
    goto __CPROVER_DUMP_L24;

  __CPROVER_DUMP_L23:
    ;
    goto __CPROVER_DUMP_L24;
  }


__CPROVER_DUMP_L24:
  ;
  return rc;
}

// LZMA_read_varint
// file ./../../src/liblzma/LzmaLib.c line 73
static unsigned long int LZMA_read_varint(struct lzma_handle_t *h)
{
  unsigned char buf[16l];
  signed int idx = 0;
  unsigned long int rc = (unsigned long int)0;
  signed int tmp_post_2;
  do
  {
    signed long int return_value_read_1;
    return_value_read_1=read(h->fd, (void *)(buf + (signed long int)idx), (unsigned long int)1);
    h->read_cnt = h->read_cnt + (unsigned long int)return_value_read_1;
    tmp_post_2 = idx;
    idx = idx + 1;
    if(!((0x80 & (signed int)buf[(signed long int)tmp_post_2]) == 0))
      break;

  }
  while((_Bool)1);
  do
  {
    idx = idx - 1;
    rc = rc << 7;
    rc = rc | (unsigned long int)((signed int)buf[(signed long int)idx] & 0x7f);
  }
  while(!(idx == 0));
  return rc;
}

// LZMA_write
// file ./../../src/liblzma/LzmaLib.c line 244
unsigned long int LZMA_write(void *handle, void *mem, unsigned long int len)
{
  struct lzma_handle_t *h = (struct lzma_handle_t *)handle;
  if((signed int)h->state == LZMA_STATE_WRITE)
    while(!(h == ((struct lzma_handle_t *)NULL)) && !(len == 0ul))
      if((unsigned long int)h->blksiz >= len + (unsigned long int)h->offs)
      {
        memcpy((void *)(h->mem + (signed long int)h->offs), mem, len);
        h->offs = h->offs + (unsigned int)len;
        break;
      }

      else
      {
        unsigned long int new_len = (unsigned long int)(h->blksiz - h->offs);
        if(!(new_len == 0ul))
          memcpy((void *)(h->mem + (signed long int)h->offs), mem, new_len);

        LZMA_write_compress(h, h->mem, (unsigned long int)h->blksiz);
        h->offs = (unsigned int)0;
        len = len - new_len;
        mem = (void *)((char *)mem + (signed long int)new_len);
      }

  return len;
}

// LZMA_write_compress
// file ./../../src/liblzma/LzmaLib.c line 97
static unsigned long int LZMA_write_compress(struct lzma_handle_t *h, unsigned char *mem, unsigned long int len)
{
  unsigned long int srclen = len;
  unsigned long int destlen = (unsigned long int)h->blksiz;
  struct anonymous_7 strm = { .next_in=(const unsigned char *)(void *)0, .avail_in=(unsigned long int)0,
    .total_in=(unsigned long int)0, .next_out=(unsigned char *)(void *)0,
    .avail_out=(unsigned long int)0,
    .total_out=(unsigned long int)0, .allocator=(struct anonymous_6 *)(void *)0,
    .internal=(struct lzma_internal_s *)(void *)0,
    .reserved_ptr1=(void *)0,
    .reserved_ptr2=(void *)0, .reserved_ptr3=(void *)0,
    .reserved_ptr4=(void *)0, .reserved_int1=(unsigned long int)0,
    .reserved_int2=(unsigned long int)0,
    .reserved_int3=(unsigned long int)0,
    .reserved_int4=(unsigned long int)0,
    .reserved_enum1=(enum anonymous_4)LZMA_RESERVED_ENUM,
    .reserved_enum2=(enum anonymous_4)LZMA_RESERVED_ENUM };
  struct anonymous_5 preset;
  enum anonymous_8 lrc;
  unsigned long int wcnt;
  lzma_lzma_preset(&preset, h->depth);
  lrc=lzma_alone_encoder(&strm, &preset);
  if(!((signed int)lrc == LZMA_OK))
  {
    fprintf(stderr, "Error in lzma_alone_encoder(), exiting!\n");
    exit(255);
  }

  strm.next_in = mem;
  strm.avail_in = len;
  strm.next_out = h->dmem;
  strm.avail_out = destlen;
  lrc=lzma_code(&strm, (enum anonymous_10)LZMA_FINISH);
  lzma_end(&strm);
  if(!(strm.total_out >= srclen) && ((signed int)lrc == LZMA_OK || (signed int)lrc == LZMA_STREAM_END))
  {
    LZMA_write_varint(h, srclen);
    LZMA_write_varint(h, strm.total_out);
    signed long int return_value_write_1;
    return_value_write_1=write(h->fd, (const void *)h->dmem, strm.total_out);
    wcnt = (unsigned long int)return_value_write_1;
    h->write_cnt = h->write_cnt + wcnt;
    return wcnt;
  }

  else
  {
    LZMA_write_varint(h, srclen);
    LZMA_write_varint(h, (unsigned long int)0);
    signed long int return_value_write_2;
    return_value_write_2=write(h->fd, (const void *)mem, len);
    wcnt = (unsigned long int)return_value_write_2;
    h->write_cnt = h->write_cnt + wcnt;
    return wcnt;
  }
}

// LZMA_write_varint
// file ./../../src/liblzma/LzmaLib.c line 54
static void LZMA_write_varint(struct lzma_handle_t *h, unsigned long int v)
{
  unsigned long int nxt;
  unsigned char buf[16l];
  unsigned char *pnt = buf;
  unsigned char *tmp_post_1;
  do
  {
    nxt = v >> 7;
    if(nxt == 0ul)
      break;

    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = (unsigned char)(v & (unsigned long int)0x7f);
    v = nxt;
  }
  while((_Bool)1);
  unsigned char *tmp_post_2 = pnt;
  pnt = pnt + 1l;
  *tmp_post_2 = (unsigned char)(v & (unsigned long int)0x7f | (unsigned long int)0x80);
  signed long int return_value_write_3;
  return_value_write_3=write(h->fd, (const void *)buf, (unsigned long int)(pnt - buf));
  h->write_cnt = h->write_cnt + (unsigned long int)return_value_write_3;
}

// button_press_event
// file logfile.c line 111
static signed int button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event)
{
  pressWindow = (void *)widget->window;
  pressX = (signed int)event->x;
  pressY = (signed int)event->y;
  return 0;
}

// button_release_event
// file logfile.c line 1168
static signed int button_release_event(struct _GtkWidget *text, struct _GdkEventButton *event)
{
  (void)event;
  char *sel;
  struct _GtkTextIter start;
  struct _GtkTextIter end;
  unsigned long int return_value_gtk_text_view_get_type_17;
  return_value_gtk_text_view_get_type_17=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_17);
  signed int return_value_gtk_text_buffer_get_selection_bounds_19;
  return_value_gtk_text_buffer_get_selection_bounds_19=gtk_text_buffer_get_selection_bounds(((struct _GtkTextView *)return_value_g_type_check_instance_cast_18)->buffer, &start, &end);
  signed int return_value_gtk_text_iter_backward_char_5;
  if(!(return_value_gtk_text_buffer_get_selection_bounds_19 == 0))
  {
    signed int return_value_gtk_text_iter_compare_16;
    return_value_gtk_text_iter_compare_16=gtk_text_iter_compare(&start, &end);
    if(!(return_value_gtk_text_iter_compare_16 >= 0))
    {
      unsigned long int return_value_gtk_text_view_get_type_1;
      return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
      sel=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer, &start, &end, 0);
      if(!(sel == ((char *)NULL)))
      {
        unsigned long int return_value_strlen_15;
        return_value_strlen_15=strlen(sel);
        if(!(return_value_strlen_15 == 0ul))
        {
          signed int i;
          signed int len;
          unsigned long int return_value_strlen_3;
          return_value_strlen_3=strlen(sel);
          len = (signed int)return_value_strlen_3;
          char *sel2;
          char ch;
          i = 0;
          for( ; !(i >= len); i = i + 1)
          {
            signed int return_value_is_identifier_4;
            return_value_is_identifier_4=is_identifier(sel[(signed long int)i]);
            if(return_value_is_identifier_4 == 0)
              goto bail;

          }
          do
          {
            return_value_gtk_text_iter_backward_char_5=gtk_text_iter_backward_char(&start);
            if(return_value_gtk_text_iter_backward_char_5 == 0)
              break;

            unsigned long int return_value_gtk_text_view_get_type_6;
            return_value_gtk_text_view_get_type_6=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
            return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_6);
            sel2=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_7)->buffer, &start, &end, 0);
            if(sel2 == ((char *)NULL))
              break;

            ch = *sel2;
            g_free((void *)sel2);
            signed int return_value_is_identifier_8;
            return_value_is_identifier_8=is_identifier(ch);
            if(return_value_is_identifier_8 == 0)
            {
              gtk_text_iter_forward_char(&start);
              break;
            }

          }
          while((_Bool)1);
          gtk_text_iter_backward_char(&end);
          do
          {
            gtk_text_iter_forward_char(&end);
            unsigned long int return_value_gtk_text_view_get_type_9;
            return_value_gtk_text_view_get_type_9=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
            return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_9);
            sel2=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_10)->buffer, &start, &end, 0);
            if(sel2 == ((char *)NULL))
              break;

            unsigned long int return_value_strlen_11;
            return_value_strlen_11=strlen(sel2);
            ch = *((sel2 + (signed long int)return_value_strlen_11) - (signed long int)1);
            g_free((void *)sel2);
            signed int return_value_is_identifier_12;
            return_value_is_identifier_12=is_identifier(ch);
            if(return_value_is_identifier_12 == 0)
            {
              gtk_text_iter_backward_char(&end);
              break;
            }

          }
          while((_Bool)1);
          unsigned long int return_value_gtk_text_view_get_type_13;
          return_value_gtk_text_view_get_type_13=gtk_text_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
          return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_13);
          sel2=gtk_text_buffer_get_text(((struct _GtkTextView *)return_value_g_type_check_instance_cast_14)->buffer, &start, &end, 0);
          import_doubleclick(text, sel2);
          g_free((void *)sel2);
        }


      bail:
        ;
        g_free((void *)sel);
      }

    }

  }

  return 0;
}

// bwlogbox
// file logfile.c line 1639
void bwlogbox(char *title, signed int width, struct ds_tree_node *t, signed int display_mode)
{
  struct _GtkWidget *bwlogbox__1__window;
  struct _GtkWidget *vbox;
  struct _GtkWidget *hbox;
  struct _GtkWidget *button1;
  struct _GtkWidget *label;
  struct _GtkWidget *separator;
  struct _GtkWidget *ctext;
  struct _GtkWidget *text;
  struct _GtkWidget *close_button = (struct _GtkWidget *)(void *)0;
  signed int pagenum = 0;
  struct _IO_FILE *handle;
  struct logfile_context_t *ctx;
  char *default_text = t->filename;
  handle=fopen(default_text, "rb");
  if(handle == ((struct _IO_FILE *)NULL))
    fprintf(stderr, "Could not open sourcefile '%s'\n", default_text);

  else
  {
    fclose(handle);
    if(notebook == ((struct _GtkWidget *)NULL))
    {
      bwlogbox__1__window=gtk_window_new((enum anonymous_70)GTK_WINDOW_TOPLEVEL);
      if(!(fontname_logfile == ((char *)NULL)))
      {
        unsigned long int return_value_gtk_window_get_type_1;
        return_value_gtk_window_get_type_1=gtk_window_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
        return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)bwlogbox__1__window, return_value_gtk_window_get_type_1);
        gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, (signed int)((double)width * 1.8), 640);
      }

      else
      {
        unsigned long int return_value_gtk_window_get_type_3;
        return_value_gtk_window_get_type_3=gtk_window_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
        return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)bwlogbox__1__window, return_value_gtk_window_get_type_3);
        gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, width, 640);
      }
      unsigned long int return_value_gtk_window_get_type_5;
      return_value_gtk_window_get_type_5=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)bwlogbox__1__window, return_value_gtk_window_get_type_5);
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, title);
    }

    else
    {
      struct _GtkWidget *tbox;
      struct _GtkWidget *l1;
      struct _GtkWidget *image;
      struct _GtkRcStyle *rcstyle;
      bwlogbox__1__window=gtk_hpaned_new();
      tbox=gtk_hbox_new(0, 0);
      l1=gtk_label_new(title);
      close_button=gtk_button_new();
      unsigned long int return_value_gtk_button_get_type_7;
      return_value_gtk_button_get_type_7=gtk_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
      return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)close_button, return_value_gtk_button_get_type_7);
      gtk_button_set_relief((struct _GtkButton *)return_value_g_type_check_instance_cast_8, (enum anonymous_68)GTK_RELIEF_NONE);
      unsigned long int return_value_gtk_button_get_type_9;
      return_value_gtk_button_get_type_9=gtk_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
      return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)close_button, return_value_gtk_button_get_type_9);
      gtk_button_set_focus_on_click((struct _GtkButton *)return_value_g_type_check_instance_cast_10, 0);
      rcstyle=gtk_rc_style_new();
      rcstyle->ythickness = 0;
      rcstyle->xthickness = rcstyle->ythickness;
      gtk_widget_modify_style(close_button, rcstyle);
      gtk_rc_style_unref(rcstyle);
      image=gtk_image_new_from_stock("gtk-close", (enum anonymous_61)GTK_ICON_SIZE_MENU);
      unsigned long int return_value_gtk_container_get_type_11;
      return_value_gtk_container_get_type_11=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
      return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)close_button, return_value_gtk_container_get_type_11);
      gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_12, image);
      gtk_widget_show(image);
      gtk_widget_show(close_button);
      unsigned long int return_value_gtk_box_get_type_13;
      return_value_gtk_box_get_type_13=gtk_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
      return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)tbox, return_value_gtk_box_get_type_13);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_14, l1, 0, 0, (unsigned int)0);
      unsigned long int return_value_gtk_box_get_type_15;
      return_value_gtk_box_get_type_15=gtk_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
      return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)tbox, return_value_gtk_box_get_type_15);
      gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_16, close_button, 0, 0, (unsigned int)0);
      gtk_widget_show(l1);
      gtk_widget_show(tbox);
      unsigned long int return_value_gtk_notebook_get_type_17;
      return_value_gtk_notebook_get_type_17=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
      return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type_17);
      struct _GtkWidget *return_value_gtk_label_new_19;
      return_value_gtk_label_new_19=gtk_label_new(title);
      pagenum=gtk_notebook_append_page_menu((struct _GtkNotebook *)return_value_g_type_check_instance_cast_18, bwlogbox__1__window, tbox, return_value_gtk_label_new_19);
      unsigned long int return_value_gtk_object_get_type_20;
      return_value_gtk_object_get_type_20=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
      return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)close_button, return_value_gtk_object_get_type_20);
      gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_21, "button_release_event", (void (*)(void))destroy_via_closebutton_release, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
    }
    vbox=gtk_vbox_new(0, 0);
    unsigned long int return_value_gtk_container_get_type_22;
    return_value_gtk_container_get_type_22=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
    return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)bwlogbox__1__window, return_value_gtk_container_get_type_22);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_23, vbox);
    gtk_widget_show(vbox);
    label=gtk_label_new(default_text);
    unsigned long int return_value_gtk_box_get_type_24;
    return_value_gtk_box_get_type_24=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
    return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_24);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_25, label, 0, 0, (unsigned int)0);
    gtk_widget_show(label);
    separator=gtk_hseparator_new();
    unsigned long int return_value_gtk_box_get_type_26;
    return_value_gtk_box_get_type_26=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
    return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_26);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_27, separator, 0, (signed int)!(0 != 0), (unsigned int)0);
    gtk_widget_show(separator);
    ctext=create_log_text(&text);
    unsigned long int return_value_gtk_box_get_type_28;
    return_value_gtk_box_get_type_28=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
    return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_28);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_29, ctext, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
    gtk_widget_show(ctext);
    unsigned long int return_value_gtk_object_get_type_30;
    return_value_gtk_object_get_type_30=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
    return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_object_get_type_30);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_31, "button_press_event", (void (*)(void))button_press_event, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
    separator=gtk_hseparator_new();
    unsigned long int return_value_gtk_box_get_type_32;
    return_value_gtk_box_get_type_32=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
    return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_32);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_33, separator, 0, (signed int)!(0 != 0), (unsigned int)0);
    gtk_widget_show(separator);
    hbox=gtk_hbox_new(0, 1);
    unsigned long int return_value_gtk_box_get_type_34;
    return_value_gtk_box_get_type_34=gtk_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_35;
    return_value_g_type_check_instance_cast_35=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type_34);
    gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_35, hbox, 0, 0, (unsigned int)0);
    gtk_widget_show(hbox);
    void *return_value_calloc_36;
    return_value_calloc_36=calloc((unsigned long int)1, sizeof(struct logfile_context_t) /*40ul*/ );
    ctx = (struct logfile_context_t *)return_value_calloc_36;
    ctx->which = t;
    ctx->display_mode = display_mode;
    ctx->width = width;
    ctx->title=strdup(title);
    unsigned long int return_value_gtk_object_get_type_37;
    return_value_gtk_object_get_type_37=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_38;
    return_value_g_type_check_instance_cast_38=g_type_check_instance_cast((struct _GTypeInstance *)bwlogbox__1__window, return_value_gtk_object_get_type_37);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_38, "expose_event", (void (*)(void))expose_event_local, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
    button1=gtk_button_new_with_label(display_mode != 0 ? "View Design Unit Only" : "View Full File");
    gtk_widget_set_usize(button1, 100, -1);
    unsigned long int return_value_gtk_object_get_type_39;
    return_value_gtk_object_get_type_39=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
    return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)button1, return_value_gtk_object_get_type_39);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_40, "clicked", (void (*)(void))ok_callback, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ctx, (void (*)(void *))(void *)0, 0, 0);
    gtk_widget_show(button1);
    unsigned long int return_value_gtk_container_get_type_41;
    return_value_gtk_container_get_type_41=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_42;
    return_value_g_type_check_instance_cast_42=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_container_get_type_41);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_42, button1);
    do
    {
      unsigned long int return_value_gtk_object_get_type_43;
      return_value_gtk_object_get_type_43=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_44;
      return_value_g_type_check_instance_cast_44=g_type_check_instance_cast((struct _GTypeInstance *)button1, return_value_gtk_object_get_type_43);
      ((struct _GtkObject *)return_value_g_type_check_instance_cast_44)->flags = ((struct _GtkObject *)return_value_g_type_check_instance_cast_44)->flags | (unsigned int)8192;
    }
    while((_Bool)0);
    unsigned long int return_value_gtk_object_get_type_45;
    return_value_gtk_object_get_type_45=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_46;
    return_value_g_type_check_instance_cast_46=g_type_check_instance_cast((struct _GTypeInstance *)button1, return_value_gtk_object_get_type_45);
    unsigned long int return_value_gtk_object_get_type_47;
    return_value_gtk_object_get_type_47=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_48;
    return_value_g_type_check_instance_cast_48=g_type_check_instance_cast((struct _GTypeInstance *)button1, return_value_gtk_object_get_type_47);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_46, "realize", (void (*)(void))gtk_widget_grab_default, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)(struct _GtkObject *)return_value_g_type_check_instance_cast_48, (void (*)(void *))(void *)0, 1, 0);
    gtk_widget_show(bwlogbox__1__window);
    bwlogbox_2(ctx, bwlogbox__1__window, close_button, text);
    if(!(text == ((struct _GtkWidget *)NULL)))
    {
      struct _GtkWidget *src = text;
      struct _GtkTargetEntry target_entry[3l];
      target_entry[(signed long int)0].target = "text/plain";
      target_entry[(signed long int)0].flags = (unsigned int)0;
      target_entry[(signed long int)0].info = (unsigned int)0;
      target_entry[(signed long int)1].target = "text/uri-list";
      target_entry[(signed long int)1].flags = (unsigned int)0;
      target_entry[(signed long int)1].info = (unsigned int)1;
      target_entry[(signed long int)2].target = "STRING";
      target_entry[(signed long int)2].flags = (unsigned int)0;
      target_entry[(signed long int)2].info = (unsigned int)2;
      gtk_drag_source_set(src, (enum anonymous_36)GDK_BUTTON2_MASK, target_entry, (signed int)(sizeof(struct _GtkTargetEntry [3l]) /*48ul*/  / sizeof(struct _GtkTargetEntry) /*16ul*/ ), (enum anonymous_37)(GDK_ACTION_COPY | GDK_ACTION_MOVE));
      unsigned long int return_value_gtk_object_get_type_49;
      return_value_gtk_object_get_type_49=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_50;
      return_value_g_type_check_instance_cast_50=g_type_check_instance_cast((struct _GTypeInstance *)src, return_value_gtk_object_get_type_49);
      gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_50, "drag_begin", (void (*)(void))DNDBeginCB, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ctx, (void (*)(void *))(void *)0, 0, 0);
      unsigned long int return_value_gtk_object_get_type_51;
      return_value_gtk_object_get_type_51=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_52;
      return_value_g_type_check_instance_cast_52=g_type_check_instance_cast((struct _GTypeInstance *)src, return_value_gtk_object_get_type_51);
      gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_52, "drag_end", (void (*)(void))DNDEndCB, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ctx, (void (*)(void *))(void *)0, 0, 0);
      unsigned long int return_value_gtk_object_get_type_53;
      return_value_gtk_object_get_type_53=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_54;
      return_value_g_type_check_instance_cast_54=g_type_check_instance_cast((struct _GTypeInstance *)src, return_value_gtk_object_get_type_53);
      gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_54, "drag_data_get", (void (*)(void))DNDDataRequestCB, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ctx, (void (*)(void *))(void *)0, 0, 0);
      unsigned long int return_value_gtk_object_get_type_55;
      return_value_gtk_object_get_type_55=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_56;
      return_value_g_type_check_instance_cast_56=g_type_check_instance_cast((struct _GTypeInstance *)src, return_value_gtk_object_get_type_55);
      gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_56, "drag_data_delete", (void (*)(void))DNDDataDeleteCB, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)ctx, (void (*)(void *))(void *)0, 0, 0);
    }

    if(!(notebook == ((struct _GtkWidget *)NULL)))
    {
      unsigned long int return_value_gtk_notebook_get_type_57;
      return_value_gtk_notebook_get_type_57=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_58;
      return_value_g_type_check_instance_cast_58=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type_57);
      gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast_58, pagenum);
    }

  }
}

// bwlogbox_2
// file logfile.c line 1855
void bwlogbox_2(struct logfile_context_t *ctx, struct _GtkWidget *window, struct _GtkWidget *button, struct _GtkWidget *text)
{
  struct ds_tree_node *t = ctx->which;
  signed int display_mode = ctx->display_mode;
  char *title = ctx->title;
  struct _IO_FILE *handle;
  signed int lx;
  signed int lx_module_line = 0;
  signed int lx_module_line_locked = 0;
  signed int lx_endmodule_line_locked = 0;
  struct wave_logfile_lines_t *wlog_head = (struct wave_logfile_lines_t *)(void *)0;
  struct wave_logfile_lines_t *wlog_curr = (struct wave_logfile_lines_t *)(void *)0;
  signed int wlog_size = 0;
  signed int line_no;
  signed int s_line_find = -1;
  signed int e_line_find = -1;
  struct text_find_t *text_curr;
  char *default_text = t->filename;
  char *design_unit = t->item;
  signed int s_line = t->s_line;
  signed int e_line = t->e_line;
  handle=fopen(default_text, "rb");
  char *tmp_if_expr_4;
  signed int tmp_if_expr_14;
  unsigned long int tmp_if_expr_18;
  unsigned long int return_value_strlen_17;
  unsigned long int tmp_if_expr_20;
  unsigned long int return_value_strlen_19;
  signed int tmp_post_22;
  unsigned long int return_value_strlen_26;
  void *return_value_malloc_27;
  signed int tmp_if_expr_37;
  unsigned long int tmp_if_expr_41;
  unsigned long int return_value_strlen_40;
  unsigned long int tmp_if_expr_43;
  unsigned long int return_value_strlen_42;
  signed int tmp_post_45;
  unsigned long int return_value_strlen_49;
  void *return_value_malloc_50;
  char *tmp_if_expr_60;
  signed int tmp_if_expr_61;
  unsigned long int tmp_if_expr_65;
  unsigned long int return_value_strlen_64;
  char *tmp_if_expr_66;
  unsigned long int tmp_if_expr_68;
  unsigned long int return_value_strlen_67;
  signed int tmp_post_70;
  _Bool tmp_if_expr_76;
  _Bool tmp_if_expr_75;
  if(handle == ((struct _IO_FILE *)NULL))
    fprintf(stderr, "Could not open sourcefile '%s'\n", default_text);

  else
  {
    fclose(handle);
    v_preproc_name = default_text;
    do
    {
      lx=yylex();
      if(lx == 0)
        break;

      char *bwlogbox_2__1__2__pnt = yytext;
      struct wave_logfile_lines_t *w;
      line_no = my_yylineno;
      if(verilog_2005 == 0)
      {
        if(lx == 15)
          lx = 2;

      }

      if(lx_module_line_locked == 0)
      {
        if(lx == 4)
          lx_module_line = line_no;

        else
          if(lx == 2 && !(lx_module_line == 0))
          {
            signed int return_value_strcmp_1;
            return_value_strcmp_1=strcmp(bwlogbox_2__1__2__pnt, design_unit);
            if(return_value_strcmp_1 == 0)
            {
              lx_module_line_locked = 1;
              s_line_find = lx_module_line;
            }

          }

          else
            if(!(lx == 7) && !(lx_module_line == 0))
              lx_module_line = 0;

      }

      else
        if(lx == 5 && lx_endmodule_line_locked == 0)
        {
          e_line_find = line_no;
          lx_endmodule_line_locked = 1;
        }

      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct wave_logfile_lines_t) /*24ul*/ );
      w = (struct wave_logfile_lines_t *)return_value_calloc_2;
      w->line_no = line_no;
      w->tok = lx;
      wlog_size = wlog_size + yyleng;
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)(yyleng + 1));
      w->text = (char *)return_value_malloc_3;
      strcpy(w->text, bwlogbox_2__1__2__pnt);
      if(wlog_curr == ((struct wave_logfile_lines_t *)NULL))
      {
        wlog_curr = w;
        wlog_head = wlog_curr;
      }

      else
      {
        wlog_curr->next = w;
        wlog_curr = w;
      }
    }
    while((_Bool)1);
    log_text(text, (struct _GdkFont *)(void *)0, "Design unit ");
    log_text_bold(text, (struct _GdkFont *)(void *)0, design_unit);
    char buf[128l];
    s_line = s_line_find > 0 ? s_line_find : s_line;
    e_line = e_line_find > 0 ? e_line_find : e_line;
    sprintf(buf, " occupies lines %d - %d.\n", s_line, e_line);
    log_text(text, (struct _GdkFont *)(void *)0, buf);
    if(!(anno_ctx == ((struct gtkwave_annotate_ipc_t *)NULL)))
    {
      if(!(anno_ctx->marker_set == 0u))
        tmp_if_expr_4 = anno_ctx->time_string;

      else
        tmp_if_expr_4 = "not set";
      sprintf(buf, "Marker time for '%s' is %s.\n", (const void *)anno_ctx->aet_name, tmp_if_expr_4);
      log_text(text, (struct _GdkFont *)(void *)0, buf);
    }

    log_text(text, (struct _GdkFont *)(void *)0, "\n");
    if(!(wlog_curr == ((struct wave_logfile_lines_t *)NULL)))
    {
      struct wave_logfile_lines_t *bwlogbox_2__1__4__w = wlog_head;
      struct wave_logfile_lines_t *wt;
      char *pnt;
      void *return_value_malloc_5;
      return_value_malloc_5=malloc((unsigned long int)(wlog_size + 1));
      pnt = (char *)return_value_malloc_5;
      char *pnt2 = pnt;
      struct jrb_node *varnames = (struct jrb_node *)(void *)0;
      struct jrb_node *node;
      signed int numvars = 0;
      if(display_mode == 0)
      {
        if(ctx->varnames == ((struct jrb_node *)NULL))
        {
          varnames=make_jrb();
          for( ; !(bwlogbox_2__1__4__w == ((struct wave_logfile_lines_t *)NULL)); bwlogbox_2__1__4__w = bwlogbox_2__1__4__w->next)
            if(bwlogbox_2__1__4__w->tok == 2)
            {
              if(bwlogbox_2__1__4__w->line_no >= s_line)
              {
                if(e_line >= bwlogbox_2__1__4__w->line_no)
                {
                  signed int return_value_strcmp_7;
                  return_value_strcmp_7=strcmp(bwlogbox_2__1__4__w->text, design_unit);
                  if(!(return_value_strcmp_7 == 0))
                  {
                    node=jrb_find_str(varnames, bwlogbox_2__1__4__w->text);
                    if(node == ((struct jrb_node *)NULL))
                    {
                      union anonymous_26 dummy;
                      dummy.v = (void *)0;
                      char *return_value_strdup_6;
                      return_value_strdup_6=strdup(bwlogbox_2__1__4__w->text);
                      jrb_insert_str(varnames, return_value_strdup_6, dummy);
                      numvars = numvars + 1;
                    }

                  }

                }

              }

            }

        }

      }

      if(!(anno_ctx == ((struct gtkwave_annotate_ipc_t *)NULL)))
      {
        if(!(anno_ctx->marker_set == 0u))
        {
          if(display_mode == 0)
          {
            signed int resolved = 0;
            if(!(fst == NULL))
            {
              signed int numfacs;
              unsigned long int return_value_fstReaderGetVarCount_8;
              return_value_fstReaderGetVarCount_8=fstReaderGetVarCount(fst);
              numfacs = (signed int)return_value_fstReaderGetVarCount_8;
              signed int bwlogbox_2__1__4__2__1__i;
              const char *scp_nam = (const char *)(void *)0;
              unsigned int fh = (unsigned int)0;
              signed int new_scope_encountered = 1;
              signed int good_scope = 0;
              if(ctx->varnames == ((struct jrb_node *)NULL))
              {
                node = varnames->flink;
                for( ; !(node == varnames); node = node->flink)
                  node->val.i = -1;
                fstReaderIterateHierRewind(fst);
                fstReaderResetScope(fst);
                bwlogbox_2__1__4__2__1__i = 0;
                for( ; !(bwlogbox_2__1__4__2__1__i >= numfacs); bwlogbox_2__1__4__2__1__i = bwlogbox_2__1__4__2__1__i + 1)
                {
                  struct fstHier *h;
                  new_scope_encountered = 0;
                  do
                  {
                    h=fstReaderIterateHier(fst);
                    if(h == ((struct fstHier *)NULL))
                      break;

                    signed int do_brk = 0;
                    switch((signed int)h->htyp)
                    {
                      case 0:
                      {
                        scp_nam=fstReaderPushScope(fst, h->u.scope.name, (void *)0);
                        new_scope_encountered = 1;
                        break;
                      }
                      case 1:
                      {
                        scp_nam=fstReaderPopScope(fst);
                        new_scope_encountered = 1;
                        break;
                      }
                      case 2:
                      {
                        scp_nam=fstReaderGetCurrentFlatScope(fst);
                        if(h->u.var.is_alias == 0u)
                          fh = fh + 1u;

                        do_brk = 1;
                      }
                    }
                    if(!(do_brk == 0))
                      break;

                  }
                  while((_Bool)1);
                  if(h == ((struct fstHier *)NULL))
                    break;

                  if(new_scope_encountered == 0)
                  {
                    if(good_scope == 0)
                      goto __CPROVER_DUMP_L46;

                  }

                  else
                  {
                    signed int return_value_strcmp_9;
                    return_value_strcmp_9=strcmp(scp_nam, title);
                    good_scope = (signed int)!(return_value_strcmp_9 != 0);
                  }
                  if(good_scope == 0)
                  {
                    if(resolved == numvars)
                      break;

                  }

                  else
                  {
                    node = varnames->flink;
                    for( ; !(node == varnames); node = node->flink)
                      if(!(node->val.i >= 0))
                      {
                        signed int return_value_fst_alpha_strcmpeq_10;
                        return_value_fst_alpha_strcmpeq_10=fst_alpha_strcmpeq(h->u.var.name, node->key.s);
                        if(return_value_fst_alpha_strcmpeq_10 == 0)
                        {
                          resolved = resolved + 1;
                          if(!(h->u.var.is_alias == 0u))
                            node->val.i = (signed int)h->u.var.handle;

                          else
                            node->val.i = (signed int)fh;
                        }

                      }

                      else
                      {
                        signed int return_value_fst_alpha_strcmpeq_13;
                        return_value_fst_alpha_strcmpeq_13=fst_alpha_strcmpeq(h->u.var.name, node->key.s);
                        if(return_value_fst_alpha_strcmpeq_13 == 0)
                        {
                          struct jrb_chain *bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc = node->jval_chain;
                          if(!(bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc == ((struct jrb_chain *)NULL)))
                          {
                            for( ; !(bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc->next == ((struct jrb_chain *)NULL)); bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc = bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc->next)
                              ;
                            void *return_value_calloc_11;
                            return_value_calloc_11=calloc((unsigned long int)1, sizeof(struct jrb_chain) /*16ul*/ );
                            bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc->next = (struct jrb_chain *)return_value_calloc_11;
                            bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc = bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc->next;
                          }

                          else
                          {
                            void *return_value_calloc_12;
                            return_value_calloc_12=calloc((unsigned long int)1, sizeof(struct jrb_chain) /*16ul*/ );
                            bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc = (struct jrb_chain *)return_value_calloc_12;
                            node->jval_chain = bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc;
                          }
                          if(!(h->u.var.is_alias == 0u))
                            bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc->val.i = (signed int)h->u.var.is_alias;

                          else
                            bwlogbox_2__1__4__2__1__2__1__5__1__1__2__1__jvc->val.i = (signed int)fh;
                        }

                      }
                  }

                __CPROVER_DUMP_L46:
                  ;
                }
                ctx->varnames = varnames;
                ctx->resolved = resolved;
              }


            skip_resolved_fst:
              ;
              varnames = ctx->varnames;
              resolved = ctx->resolved;
              node = varnames->flink;
              for( ; !(node == varnames); node = node->flink)
                if(node->val.i >= 0)
                {
                  char rcb[65537l];
                  char *rc;
                  struct jrb_chain *bwlogbox_2__1__4__2__1__3__1__1__jvc = node->jval_chain;
                  char bwlogbox_2__1__4__2__1__3__1__1__first_char;
                  rc=fstReaderGetValueFromHandleAtTime(fst, (unsigned long int)anno_ctx->marker, (unsigned int)node->val.i, rcb);
                  if(!(rc == ((char *)NULL)))
                    tmp_if_expr_14 = (signed int)rc[(signed long int)0];

                  else
                    tmp_if_expr_14 = 63;
                  bwlogbox_2__1__4__2__1__3__1__1__first_char = (char)tmp_if_expr_14;
                  if(bwlogbox_2__1__4__2__1__3__1__1__jvc == ((struct jrb_chain *)NULL))
                  {
                    if(!(rc == ((char *)NULL)))
                    {
                      char *return_value_strdup_15;
                      return_value_strdup_15=strdup(rc);
                      char *return_value_hexify_16;
                      return_value_hexify_16=hexify(return_value_strdup_15);
                      node->val2.v = (void *)return_value_hexify_16;
                    }

                    else
                      node->val2.v = (void *)0;
                  }

                  else
                  {
                    char *bwlogbox_2__1__4__2__1__3__1__1__2__rc2;
                    signed int bwlogbox_2__1__4__2__1__3__1__1__2__len;
                    if(!(rc == ((char *)NULL)))
                    {
                      return_value_strlen_17=strlen(rc);
                      tmp_if_expr_18 = return_value_strlen_17;
                    }

                    else
                      tmp_if_expr_18 = (unsigned long int)0;
                    bwlogbox_2__1__4__2__1__3__1__1__2__len = (signed int)tmp_if_expr_18;
                    signed int bwlogbox_2__1__4__2__1__3__1__1__2__iter = 1;
                    while(!(bwlogbox_2__1__4__2__1__3__1__1__jvc == ((struct jrb_chain *)NULL)))
                    {
                      fstReaderGetValueFromHandleAtTime(fst, (unsigned long int)anno_ctx->marker, (unsigned int)bwlogbox_2__1__4__2__1__3__1__1__jvc->val.i, rc);
                      if(!(rc == ((char *)NULL)))
                      {
                        return_value_strlen_19=strlen(rc);
                        tmp_if_expr_20 = return_value_strlen_19;
                      }

                      else
                        tmp_if_expr_20 = (unsigned long int)0;
                      bwlogbox_2__1__4__2__1__3__1__1__2__len = bwlogbox_2__1__4__2__1__3__1__1__2__len + (signed int)tmp_if_expr_20;
                      bwlogbox_2__1__4__2__1__3__1__1__2__iter = bwlogbox_2__1__4__2__1__3__1__1__2__iter + 1;
                      bwlogbox_2__1__4__2__1__3__1__1__jvc = bwlogbox_2__1__4__2__1__3__1__1__jvc->next;
                    }
                    if(bwlogbox_2__1__4__2__1__3__1__1__2__iter == bwlogbox_2__1__4__2__1__3__1__1__2__len)
                    {
                      signed int bwlogbox_2__1__4__2__1__3__1__1__2__2__pos = 1;
                      bwlogbox_2__1__4__2__1__3__1__1__jvc = node->jval_chain;
                      void *return_value_calloc_21;
                      return_value_calloc_21=calloc((unsigned long int)1, (unsigned long int)(bwlogbox_2__1__4__2__1__3__1__1__2__len + 1));
                      bwlogbox_2__1__4__2__1__3__1__1__2__rc2 = (char *)return_value_calloc_21;
                      bwlogbox_2__1__4__2__1__3__1__1__2__rc2[(signed long int)0] = bwlogbox_2__1__4__2__1__3__1__1__first_char;
                      while(!(bwlogbox_2__1__4__2__1__3__1__1__jvc == ((struct jrb_chain *)NULL)))
                      {
                        char bwlogbox_2__1__4__2__1__3__1__1__2__2__1__rcv[65537l];
                        fstReaderGetValueFromHandleAtTime(fst, (unsigned long int)anno_ctx->marker, (unsigned int)bwlogbox_2__1__4__2__1__3__1__1__jvc->val.i, bwlogbox_2__1__4__2__1__3__1__1__2__2__1__rcv);
                        tmp_post_22 = bwlogbox_2__1__4__2__1__3__1__1__2__2__pos;
                        bwlogbox_2__1__4__2__1__3__1__1__2__2__pos = bwlogbox_2__1__4__2__1__3__1__1__2__2__pos + 1;
                        bwlogbox_2__1__4__2__1__3__1__1__2__rc2[(signed long int)tmp_post_22] = bwlogbox_2__1__4__2__1__3__1__1__2__2__1__rcv[0l];
                        bwlogbox_2__1__4__2__1__3__1__1__jvc = bwlogbox_2__1__4__2__1__3__1__1__jvc->next;
                      }
                      char *return_value_strdup_23;
                      return_value_strdup_23=strdup(bwlogbox_2__1__4__2__1__3__1__1__2__rc2);
                      char *return_value_hexify_24;
                      return_value_hexify_24=hexify(return_value_strdup_23);
                      node->val2.v = (void *)return_value_hexify_24;
                      free((void *)bwlogbox_2__1__4__2__1__3__1__1__2__rc2);
                    }

                    else
                      node->val2.v = (void *)0;
                  }
                }

                else
                  node->val2.v = (void *)0;
            }

            else
              if(!(vzt == ((struct vzt_rd_trace *)NULL)))
              {
                signed int bwlogbox_2__1__4__2__2__numfacs;
                unsigned int return_value_vzt_rd_get_num_facs_25;
                return_value_vzt_rd_get_num_facs_25=vzt_rd_get_num_facs(vzt);
                bwlogbox_2__1__4__2__2__numfacs = (signed int)return_value_vzt_rd_get_num_facs_25;
                signed int bwlogbox_2__1__4__2__2__i;
                signed int bwlogbox_2__1__4__2__2__tlen;
                char *bwlogbox_2__1__4__2__2__pfx = (char *)(void *)0;
                if(ctx->varnames == ((struct jrb_node *)NULL))
                {
                  return_value_strlen_26=strlen(title);
                  bwlogbox_2__1__4__2__2__tlen = (signed int)return_value_strlen_26;
                  return_value_malloc_27=malloc((unsigned long int)(bwlogbox_2__1__4__2__2__tlen + 1 + 1));
                  bwlogbox_2__1__4__2__2__pfx = (char *)return_value_malloc_27;
                  strcpy(bwlogbox_2__1__4__2__2__pfx, title);
                  strcat(bwlogbox_2__1__4__2__2__pfx + (signed long int)bwlogbox_2__1__4__2__2__tlen, ".");
                  bwlogbox_2__1__4__2__2__tlen = bwlogbox_2__1__4__2__2__tlen + 1;
                  node = varnames->flink;
                  for( ; !(node == varnames); node = node->flink)
                    node->val.i = -1;
                  bwlogbox_2__1__4__2__2__i = 0;
                  for( ; !(bwlogbox_2__1__4__2__2__i >= bwlogbox_2__1__4__2__2__numfacs); bwlogbox_2__1__4__2__2__i = bwlogbox_2__1__4__2__2__i + 1)
                  {
                    char *bwlogbox_2__1__4__2__2__2__1__fnam;
                    bwlogbox_2__1__4__2__2__2__1__fnam=vzt_rd_get_facname(vzt, (unsigned int)bwlogbox_2__1__4__2__2__i);
                    signed int return_value_strncmp_36;
                    return_value_strncmp_36=strncmp(bwlogbox_2__1__4__2__2__2__1__fnam, bwlogbox_2__1__4__2__2__pfx, (unsigned long int)bwlogbox_2__1__4__2__2__tlen);
                    if(return_value_strncmp_36 == 0)
                    {
                      char *return_value_strchr_35;
                      return_value_strchr_35=strchr(bwlogbox_2__1__4__2__2__2__1__fnam + (signed long int)bwlogbox_2__1__4__2__2__tlen, 46);
                      if(return_value_strchr_35 == ((char *)NULL))
                      {
                        node = varnames->flink;
                        for( ; !(node == varnames); node = node->flink)
                        {
                          signed int bwlogbox_2__1__4__2__2__2__1__1__1__1__1__mat = 0;
                          if(!(node->val.i >= 0))
                          {
                            signed int return_value_strcmp_29;
                            return_value_strcmp_29=strcmp(bwlogbox_2__1__4__2__2__2__1__fnam + (signed long int)bwlogbox_2__1__4__2__2__tlen, node->key.s);
                            if(return_value_strcmp_29 == 0)
                            {
                              bwlogbox_2__1__4__2__2__2__1__1__1__1__1__mat = 1;
                              if(!((8u & vzt->flags[(signed long int)bwlogbox_2__1__4__2__2__i]) == 0u))
                              {
                                unsigned int return_value_vzt_rd_get_alias_root_28;
                                return_value_vzt_rd_get_alias_root_28=vzt_rd_get_alias_root(vzt, (unsigned int)bwlogbox_2__1__4__2__2__i);
                                node->val.i = (signed int)return_value_vzt_rd_get_alias_root_28;
                              }

                              else
                                node->val.i = bwlogbox_2__1__4__2__2__i;
                            }

                          }

                          else
                          {
                            signed int return_value_strcmp_33;
                            return_value_strcmp_33=strcmp(bwlogbox_2__1__4__2__2__2__1__fnam + (signed long int)bwlogbox_2__1__4__2__2__tlen, node->key.s);
                            if(return_value_strcmp_33 == 0)
                            {
                              struct jrb_chain *bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc = node->jval_chain;
                              bwlogbox_2__1__4__2__2__2__1__1__1__1__1__mat = 1;
                              if(!(bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc == ((struct jrb_chain *)NULL)))
                              {
                                for( ; !(bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc->next == ((struct jrb_chain *)NULL)); bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc = bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc->next)
                                  ;
                                void *return_value_calloc_30;
                                return_value_calloc_30=calloc((unsigned long int)1, sizeof(struct jrb_chain) /*16ul*/ );
                                bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc->next = (struct jrb_chain *)return_value_calloc_30;
                                bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc = bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc->next;
                              }

                              else
                              {
                                void *return_value_calloc_31;
                                return_value_calloc_31=calloc((unsigned long int)1, sizeof(struct jrb_chain) /*16ul*/ );
                                bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc = (struct jrb_chain *)return_value_calloc_31;
                                node->jval_chain = bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc;
                              }
                              if(!((8u & vzt->flags[(signed long int)bwlogbox_2__1__4__2__2__i]) == 0u))
                              {
                                unsigned int return_value_vzt_rd_get_alias_root_32;
                                return_value_vzt_rd_get_alias_root_32=vzt_rd_get_alias_root(vzt, (unsigned int)bwlogbox_2__1__4__2__2__i);
                                bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc->val.i = (signed int)return_value_vzt_rd_get_alias_root_32;
                              }

                              else
                                bwlogbox_2__1__4__2__2__2__1__1__1__1__1__2__1__jvc->val.i = bwlogbox_2__1__4__2__2__i;
                            }

                          }
                          if(!(bwlogbox_2__1__4__2__2__2__1__1__1__1__1__mat == 0))
                          {
                            if(bwlogbox_2__1__4__2__2__i == bwlogbox_2__1__4__2__2__numfacs + -1)
                              resolved = resolved + 1;

                            else
                            {
                              char *bwlogbox_2__1__4__2__2__2__1__1__1__1__1__3__2__fnam2;
                              bwlogbox_2__1__4__2__2__2__1__1__1__1__1__3__2__fnam2=vzt_rd_get_facname(vzt, (unsigned int)(bwlogbox_2__1__4__2__2__i + 1));
                              signed int return_value_strcmp_34;
                              return_value_strcmp_34=strcmp(bwlogbox_2__1__4__2__2__2__1__fnam, bwlogbox_2__1__4__2__2__2__1__1__1__1__1__3__2__fnam2);
                              if(!(return_value_strcmp_34 == 0))
                              {
                                resolved = resolved + 1;
                                if(resolved == numvars)
                                  goto resolved_vzt;

                              }

                            }
                          }

                        }
                      }

                    }

                  }

                resolved_vzt:
                  ;
                  free((void *)bwlogbox_2__1__4__2__2__pfx);
                  ctx->varnames = varnames;
                  ctx->resolved = resolved;
                }


              skip_resolved_vzt:
                ;
                varnames = ctx->varnames;
                resolved = ctx->resolved;
                node = varnames->flink;
                for( ; !(node == varnames); node = node->flink)
                  if(node->val.i >= 0)
                  {
                    char *bwlogbox_2__1__4__2__2__3__1__1__rc;
                    bwlogbox_2__1__4__2__2__3__1__1__rc=vzt_rd_value(vzt, (unsigned long int)anno_ctx->marker, (unsigned int)node->val.i);
                    struct jrb_chain *jvc = node->jval_chain;
                    char first_char;
                    if(!(bwlogbox_2__1__4__2__2__3__1__1__rc == ((char *)NULL)))
                      tmp_if_expr_37 = (signed int)bwlogbox_2__1__4__2__2__3__1__1__rc[(signed long int)0];

                    else
                      tmp_if_expr_37 = 63;
                    first_char = (char)tmp_if_expr_37;
                    if(jvc == ((struct jrb_chain *)NULL))
                    {
                      if(!(bwlogbox_2__1__4__2__2__3__1__1__rc == ((char *)NULL)))
                      {
                        char *return_value_strdup_38;
                        return_value_strdup_38=strdup(bwlogbox_2__1__4__2__2__3__1__1__rc);
                        char *return_value_hexify_39;
                        return_value_hexify_39=hexify(return_value_strdup_38);
                        node->val2.v = (void *)return_value_hexify_39;
                      }

                      else
                        node->val2.v = (void *)0;
                    }

                    else
                    {
                      char *rc2;
                      signed int len;
                      if(!(bwlogbox_2__1__4__2__2__3__1__1__rc == ((char *)NULL)))
                      {
                        return_value_strlen_40=strlen(bwlogbox_2__1__4__2__2__3__1__1__rc);
                        tmp_if_expr_41 = return_value_strlen_40;
                      }

                      else
                        tmp_if_expr_41 = (unsigned long int)0;
                      len = (signed int)tmp_if_expr_41;
                      signed int bwlogbox_2__1__4__2__2__3__1__1__2__iter = 1;
                      while(!(jvc == ((struct jrb_chain *)NULL)))
                      {
                        bwlogbox_2__1__4__2__2__3__1__1__rc=vzt_rd_value(vzt, (unsigned long int)anno_ctx->marker, (unsigned int)jvc->val.i);
                        if(!(bwlogbox_2__1__4__2__2__3__1__1__rc == ((char *)NULL)))
                        {
                          return_value_strlen_42=strlen(bwlogbox_2__1__4__2__2__3__1__1__rc);
                          tmp_if_expr_43 = return_value_strlen_42;
                        }

                        else
                          tmp_if_expr_43 = (unsigned long int)0;
                        len = len + (signed int)tmp_if_expr_43;
                        bwlogbox_2__1__4__2__2__3__1__1__2__iter = bwlogbox_2__1__4__2__2__3__1__1__2__iter + 1;
                        jvc = jvc->next;
                      }
                      if(bwlogbox_2__1__4__2__2__3__1__1__2__iter == len)
                      {
                        signed int bwlogbox_2__1__4__2__2__3__1__1__2__2__pos = 1;
                        jvc = node->jval_chain;
                        void *return_value_calloc_44;
                        return_value_calloc_44=calloc((unsigned long int)1, (unsigned long int)(len + 1));
                        rc2 = (char *)return_value_calloc_44;
                        rc2[(signed long int)0] = first_char;
                        while(!(jvc == ((struct jrb_chain *)NULL)))
                        {
                          char *rcv;
                          rcv=vzt_rd_value(vzt, (unsigned long int)anno_ctx->marker, (unsigned int)jvc->val.i);
                          tmp_post_45 = bwlogbox_2__1__4__2__2__3__1__1__2__2__pos;
                          bwlogbox_2__1__4__2__2__3__1__1__2__2__pos = bwlogbox_2__1__4__2__2__3__1__1__2__2__pos + 1;
                          rc2[(signed long int)tmp_post_45] = *rcv;
                          jvc = jvc->next;
                        }
                        char *return_value_strdup_46;
                        return_value_strdup_46=strdup(rc2);
                        char *return_value_hexify_47;
                        return_value_hexify_47=hexify(return_value_strdup_46);
                        node->val2.v = (void *)return_value_hexify_47;
                        free((void *)rc2);
                      }

                      else
                        node->val2.v = (void *)0;
                    }
                  }

                  else
                    node->val2.v = (void *)0;
              }

              else
                if(!(lx2 == ((struct lxt2_rd_trace *)NULL)))
                {
                  signed int bwlogbox_2__1__4__2__3__numfacs;
                  unsigned int return_value_lxt2_rd_get_num_facs_48;
                  return_value_lxt2_rd_get_num_facs_48=lxt2_rd_get_num_facs(lx2);
                  bwlogbox_2__1__4__2__3__numfacs = (signed int)return_value_lxt2_rd_get_num_facs_48;
                  signed int i;
                  signed int tlen;
                  char *pfx = (char *)(void *)0;
                  if(ctx->varnames == ((struct jrb_node *)NULL))
                  {
                    return_value_strlen_49=strlen(title);
                    tlen = (signed int)return_value_strlen_49;
                    return_value_malloc_50=malloc((unsigned long int)(tlen + 1 + 1));
                    pfx = (char *)return_value_malloc_50;
                    strcpy(pfx, title);
                    strcat(pfx + (signed long int)tlen, ".");
                    tlen = tlen + 1;
                    lxt2_rd_clr_fac_process_mask_all(lx2);
                    node = varnames->flink;
                    for( ; !(node == varnames); node = node->flink)
                      node->val.i = -1;
                    i = 0;
                    for( ; !(i >= bwlogbox_2__1__4__2__3__numfacs); i = i + 1)
                    {
                      char *fnam;
                      fnam=lxt2_rd_get_facname(lx2, (unsigned int)i);
                      signed int return_value_strncmp_59;
                      return_value_strncmp_59=strncmp(fnam, pfx, (unsigned long int)tlen);
                      if(return_value_strncmp_59 == 0)
                      {
                        char *return_value_strchr_58;
                        return_value_strchr_58=strchr(fnam + (signed long int)tlen, 46);
                        if(return_value_strchr_58 == ((char *)NULL))
                        {
                          node = varnames->flink;
                          for( ; !(node == varnames); node = node->flink)
                          {
                            signed int mat = 0;
                            if(!(node->val.i >= 0))
                            {
                              signed int return_value_strcmp_52;
                              return_value_strcmp_52=strcmp(fnam + (signed long int)tlen, node->key.s);
                              if(return_value_strcmp_52 == 0)
                              {
                                mat = 1;
                                if(!((8u & lx2->flags[(signed long int)i]) == 0u))
                                {
                                  unsigned int return_value_lxt2_rd_get_alias_root_51;
                                  return_value_lxt2_rd_get_alias_root_51=lxt2_rd_get_alias_root(lx2, (unsigned int)i);
                                  node->val.i = (signed int)return_value_lxt2_rd_get_alias_root_51;
                                }

                                else
                                  node->val.i = i;
                                lxt2_rd_set_fac_process_mask(lx2, (unsigned int)node->val.i);
                              }

                            }

                            else
                            {
                              signed int return_value_strcmp_56;
                              return_value_strcmp_56=strcmp(fnam + (signed long int)tlen, node->key.s);
                              if(return_value_strcmp_56 == 0)
                              {
                                struct jrb_chain *bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc = node->jval_chain;
                                mat = 1;
                                if(!(bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc == ((struct jrb_chain *)NULL)))
                                {
                                  for( ; !(bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc->next == ((struct jrb_chain *)NULL)); bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc = bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc->next)
                                    ;
                                  void *return_value_calloc_53;
                                  return_value_calloc_53=calloc((unsigned long int)1, sizeof(struct jrb_chain) /*16ul*/ );
                                  bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc->next = (struct jrb_chain *)return_value_calloc_53;
                                  bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc = bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc->next;
                                }

                                else
                                {
                                  void *return_value_calloc_54;
                                  return_value_calloc_54=calloc((unsigned long int)1, sizeof(struct jrb_chain) /*16ul*/ );
                                  bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc = (struct jrb_chain *)return_value_calloc_54;
                                  node->jval_chain = bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc;
                                }
                                if(!((8u & lx2->flags[(signed long int)i]) == 0u))
                                {
                                  unsigned int return_value_lxt2_rd_get_alias_root_55;
                                  return_value_lxt2_rd_get_alias_root_55=lxt2_rd_get_alias_root(lx2, (unsigned int)i);
                                  bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc->val.i = (signed int)return_value_lxt2_rd_get_alias_root_55;
                                }

                                else
                                  bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc->val.i = i;
                                lxt2_rd_set_fac_process_mask(lx2, (unsigned int)bwlogbox_2__1__4__2__3__2__1__1__1__1__1__2__1__jvc->val.i);
                              }

                            }
                            if(!(mat == 0))
                            {
                              if(i == bwlogbox_2__1__4__2__3__numfacs + -1)
                                resolved = resolved + 1;

                              else
                              {
                                char *fnam2;
                                fnam2=lxt2_rd_get_facname(lx2, (unsigned int)(i + 1));
                                signed int return_value_strcmp_57;
                                return_value_strcmp_57=strcmp(fnam, fnam2);
                                if(!(return_value_strcmp_57 == 0))
                                {
                                  resolved = resolved + 1;
                                  if(resolved == numvars)
                                    goto resolved_lxt2;

                                }

                              }
                            }

                          }
                        }

                      }

                    }

                  resolved_lxt2:
                    ;
                    free((void *)pfx);
                    ctx->varnames = varnames;
                    ctx->resolved = resolved;
                  }


                skip_resolved_lxt2:
                  ;
                  varnames = ctx->varnames;
                  resolved = ctx->resolved;
                  lx2vals=make_jrb();
                  lxt2_rd_unlimit_time_range(lx2);
                  lxt2_rd_limit_time_range(lx2, (unsigned long int)anno_ctx->marker, (unsigned long int)anno_ctx->marker);
                  lxt2_rd_iter_blocks(lx2, lx2_iter_fn, (void *)0);
                  node = varnames->flink;
                  for( ; !(node == varnames); node = node->flink)
                  {
                    struct jrb_chain *bwlogbox_2__1__4__2__3__3__1__jvc = node->jval_chain;
                    if(node->val.i >= 0)
                    {
                      struct jrb_node *srch;
                      srch=jrb_find_int(lx2vals, node->val.i);
                      char *bwlogbox_2__1__4__2__3__3__1__1__rc;
                      if(!(srch == ((struct jrb_node *)NULL)))
                        tmp_if_expr_60 = srch->val.s;

                      else
                        tmp_if_expr_60 = (char *)(void *)0;
                      bwlogbox_2__1__4__2__3__3__1__1__rc = tmp_if_expr_60;
                      char bwlogbox_2__1__4__2__3__3__1__1__first_char;
                      if(!(bwlogbox_2__1__4__2__3__3__1__1__rc == ((char *)NULL)))
                        tmp_if_expr_61 = (signed int)bwlogbox_2__1__4__2__3__3__1__1__rc[(signed long int)0];

                      else
                        tmp_if_expr_61 = 63;
                      bwlogbox_2__1__4__2__3__3__1__1__first_char = (char)tmp_if_expr_61;
                      if(bwlogbox_2__1__4__2__3__3__1__jvc == ((struct jrb_chain *)NULL))
                      {
                        if(!(bwlogbox_2__1__4__2__3__3__1__1__rc == ((char *)NULL)))
                        {
                          char *return_value_strdup_62;
                          return_value_strdup_62=strdup(bwlogbox_2__1__4__2__3__3__1__1__rc);
                          char *return_value_hexify_63;
                          return_value_hexify_63=hexify(return_value_strdup_62);
                          node->val2.v = (void *)return_value_hexify_63;
                        }

                        else
                          node->val2.v = (void *)0;
                      }

                      else
                      {
                        char *bwlogbox_2__1__4__2__3__3__1__1__2__rc2;
                        signed int bwlogbox_2__1__4__2__3__3__1__1__2__len;
                        if(!(bwlogbox_2__1__4__2__3__3__1__1__rc == ((char *)NULL)))
                        {
                          return_value_strlen_64=strlen(bwlogbox_2__1__4__2__3__3__1__1__rc);
                          tmp_if_expr_65 = return_value_strlen_64;
                        }

                        else
                          tmp_if_expr_65 = (unsigned long int)0;
                        bwlogbox_2__1__4__2__3__3__1__1__2__len = (signed int)tmp_if_expr_65;
                        signed int iter = 1;
                        while(!(bwlogbox_2__1__4__2__3__3__1__jvc == ((struct jrb_chain *)NULL)))
                        {
                          srch=jrb_find_int(lx2vals, bwlogbox_2__1__4__2__3__3__1__jvc->val.i);
                          if(!(srch == ((struct jrb_node *)NULL)))
                            tmp_if_expr_66 = srch->val.s;

                          else
                            tmp_if_expr_66 = (char *)(void *)0;
                          bwlogbox_2__1__4__2__3__3__1__1__rc = tmp_if_expr_66;
                          if(!(bwlogbox_2__1__4__2__3__3__1__1__rc == ((char *)NULL)))
                          {
                            return_value_strlen_67=strlen(bwlogbox_2__1__4__2__3__3__1__1__rc);
                            tmp_if_expr_68 = return_value_strlen_67;
                          }

                          else
                            tmp_if_expr_68 = (unsigned long int)0;
                          bwlogbox_2__1__4__2__3__3__1__1__2__len = bwlogbox_2__1__4__2__3__3__1__1__2__len + (signed int)tmp_if_expr_68;
                          iter = iter + 1;
                          bwlogbox_2__1__4__2__3__3__1__jvc = bwlogbox_2__1__4__2__3__3__1__jvc->next;
                        }
                        if(iter == bwlogbox_2__1__4__2__3__3__1__1__2__len)
                        {
                          signed int pos = 1;
                          bwlogbox_2__1__4__2__3__3__1__jvc = node->jval_chain;
                          void *return_value_calloc_69;
                          return_value_calloc_69=calloc((unsigned long int)1, (unsigned long int)(bwlogbox_2__1__4__2__3__3__1__1__2__len + 1));
                          bwlogbox_2__1__4__2__3__3__1__1__2__rc2 = (char *)return_value_calloc_69;
                          bwlogbox_2__1__4__2__3__3__1__1__2__rc2[(signed long int)0] = bwlogbox_2__1__4__2__3__3__1__1__first_char;
                          for( ; !(bwlogbox_2__1__4__2__3__3__1__jvc == ((struct jrb_chain *)NULL)); bwlogbox_2__1__4__2__3__3__1__jvc = bwlogbox_2__1__4__2__3__3__1__jvc->next)
                          {
                            srch=jrb_find_int(lx2vals, bwlogbox_2__1__4__2__3__3__1__jvc->val.i);
                            bwlogbox_2__1__4__2__3__3__1__1__rc = srch->val.s;
                            tmp_post_70 = pos;
                            pos = pos + 1;
                            bwlogbox_2__1__4__2__3__3__1__1__2__rc2[(signed long int)tmp_post_70] = *bwlogbox_2__1__4__2__3__3__1__1__rc;
                          }
                          char *return_value_strdup_71;
                          return_value_strdup_71=strdup(bwlogbox_2__1__4__2__3__3__1__1__2__rc2);
                          char *return_value_hexify_72;
                          return_value_hexify_72=hexify(return_value_strdup_71);
                          node->val2.v = (void *)return_value_hexify_72;
                          free((void *)bwlogbox_2__1__4__2__3__3__1__1__2__rc2);
                        }

                        else
                          node->val2.v = (void *)0;
                      }
                    }

                    else
                      node->val2.v = (void *)0;
                  }
                  node = lx2vals->flink;
                  for( ; !(node == lx2vals); node = node->flink)
                    if(!(node->val.s == ((char *)NULL)))
                      free((void *)node->val.s);

                  jrb_free_tree(lx2vals);
                  lx2vals = (struct jrb_node *)(void *)0;
                }

            if(resolved >= 1)
            {
              bwlogbox_2__1__4__w = wlog_head;
              while(!(bwlogbox_2__1__4__w == ((struct wave_logfile_lines_t *)NULL)))
              {
                if(bwlogbox_2__1__4__w->line_no >= s_line)
                {
                  if(e_line >= bwlogbox_2__1__4__w->line_no)
                  {
                    if(bwlogbox_2__1__4__w->tok == 2)
                    {
                      signed int return_value_strcmp_73;
                      return_value_strcmp_73=strcmp(bwlogbox_2__1__4__w->text, design_unit);
                      if(!(return_value_strcmp_73 == 0))
                      {
                        node=jrb_find_str(varnames, bwlogbox_2__1__4__w->text);
                        if(!(node == ((struct jrb_node *)NULL)))
                        {
                          if(!(node->val2.v == NULL))
                          {
                            log_text(text, fontx, bwlogbox_2__1__4__w->text);
                            log_text_bold(text, fontx, "[");
                            log_text_bold(text, fontx, (char *)node->val2.v);
                            log_text_bold(text, fontx, "]");
                            goto iter_free;
                          }

                        }

                      }

                    }

                    switch(bwlogbox_2__1__4__w->tok)
                    {
                      case 9:
                      {
                        log_text_active(text, fontx, bwlogbox_2__1__4__w->text);
                        break;
                      }
                      case 6:

                      case 12:

                      case 13:

                      case 8:
                      {
                        log_text_prelight(text, fontx, bwlogbox_2__1__4__w->text);
                        break;
                      }
                      default:
                        log_text(text, fontx, bwlogbox_2__1__4__w->text);
                    }
                  }

                }


              iter_free:
                ;
                free((void *)bwlogbox_2__1__4__w->text);
                wt = bwlogbox_2__1__4__w;
                bwlogbox_2__1__4__w = bwlogbox_2__1__4__w->next;
                free((void *)wt);
              }
              free((void *)pnt);
              wlog_curr = (struct wave_logfile_lines_t *)(void *)0;
              goto free_vars;
            }

          }

        }

      }

      bwlogbox_2__1__4__w = wlog_head;
      while(!(bwlogbox_2__1__4__w == ((struct wave_logfile_lines_t *)NULL)))
      {
        if(!(display_mode == 0))
          tmp_if_expr_76 = (_Bool)1;

        else
        {
          if(bwlogbox_2__1__4__w->line_no >= s_line)
            tmp_if_expr_75 = bwlogbox_2__1__4__w->line_no <= e_line ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_75 = (_Bool)0;
          tmp_if_expr_76 = tmp_if_expr_75 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_76)
        {
          signed int bwlogbox_2__1__4__3__1__len;
          unsigned long int return_value_strlen_74;
          return_value_strlen_74=strlen(bwlogbox_2__1__4__w->text);
          bwlogbox_2__1__4__3__1__len = (signed int)return_value_strlen_74;
          memcpy((void *)pnt2, (const void *)bwlogbox_2__1__4__w->text, (unsigned long int)bwlogbox_2__1__4__3__1__len);
          pnt2 = pnt2 + (signed long int)bwlogbox_2__1__4__3__1__len;
        }

        free((void *)bwlogbox_2__1__4__w->text);
        wt = bwlogbox_2__1__4__w;
        bwlogbox_2__1__4__w = bwlogbox_2__1__4__w->next;
        free((void *)wt);
      }
      wlog_curr = (struct wave_logfile_lines_t *)(void *)0;
      *pnt2 = (char)0;
      log_text(text, fontx, pnt);
      free((void *)pnt);

    free_vars:
      ;
      if(!(window == ((struct _GtkWidget *)NULL)))
      {
        void *return_value_calloc_77;
        return_value_calloc_77=calloc((unsigned long int)1, sizeof(struct text_find_t) /*112ul*/ );
        text_curr = (struct text_find_t *)return_value_calloc_77;
        text_curr->window = window;
        text_curr->button = button;
        text_curr->text = text;
        text_curr->ctx = ctx;
        text_curr->next = text_root;
        text_root = text_curr;
        text_curr->bold_tag = bold_tag;
        text_curr->dgray_tag = dgray_tag;
        text_curr->lgray_tag = lgray_tag;
        text_curr->blue_tag = blue_tag;
        text_curr->fwht_tag = fwht_tag;
        text_curr->mono_tag = mono_tag;
        text_curr->size_tag = size_tag;
      }

    }

  }
}

// bwmaketree
// file tree_widget.c line 23
void bwmaketree(void)
{
  signed int i = 0;
  for( ; !(i >= mod_cnt); i = i + 1)
  {
    struct ds_tree_node *t = mod_list[(signed long int)i];
    if(t->refcnt == 0)
      recurse_into_modules((char *)(void *)0, (char *)(void *)0, t, 0, (struct _GtkCTreeNode *)(void *)0, (struct _GtkCTreeNode *)(void *)0);

  }
}

// bwsigcmp
// file stem_recurse.c line 49
static signed int bwsigcmp(char *s1, char *s2)
{
  unsigned char c1;
  unsigned char c2;
  signed int u1;
  signed int u2;
  char *tmp_post_1;
  char *tmp_post_2;
  do
  {
    tmp_post_1 = s1;
    s1 = s1 + 1l;
    c1 = (unsigned char)*tmp_post_1;
    tmp_post_2 = s2;
    s2 = s2 + 1l;
    c2 = (unsigned char)*tmp_post_2;
    if(c1 == 0 && c2 == 0)
      return 0;

    if((signed int)c1 >= 48 && (signed int)c2 >= 48 && !((signed int)c1 >= 58) && !((signed int)c2 >= 58))
    {
      u1 = (signed int)((signed int)c1 & 15);
      u2 = (signed int)((signed int)c2 & 15);
      do
      {
        c2 = (unsigned char)*s2;
        if(!((signed int)c2 >= 48))
          break;

        if((signed int)c2 >= 58)
          break;

        u2 = u2 * 10;
        u2 = u2 + (signed int)(unsigned int)((signed int)c2 & 15);
        s2 = s2 + 1l;
      }
      while((_Bool)1);
      do
      {
        c2 = (unsigned char)*s1;
        if(!((signed int)c2 >= 48))
          break;

        if((signed int)c2 >= 58)
          break;

        u1 = u1 * 10;
        u1 = u1 + (signed int)(unsigned int)((signed int)c2 & 15);
        s1 = s1 + 1l;
      }
      while((_Bool)1);
      if(u1 == u2)
        continue;

      else
        return (signed int)u1 - (signed int)u2;
    }

    else
      if(!(c1 == c2))
        return (signed int)c1 - (signed int)c2;

  }
  while((_Bool)1);
}

// compar_comp_array_bsearch
// file stem_recurse.c line 91
static signed int compar_comp_array_bsearch(const void *s1, const void *s2)
{
  char *key;
  char *obj;
  key = (*((struct ds_component **)s1))->compname;
  obj = (*((struct ds_component **)s2))->compname;
  signed int return_value_bwsigcmp_1;
  return_value_bwsigcmp_1=bwsigcmp(key, obj);
  return return_value_bwsigcmp_1;
}

// create_log_text
// file logfile.c line 1357
static struct _GtkWidget * create_log_text(struct _GtkWidget **textpnt)
{
  struct _GtkWidget *text;
  struct _GtkWidget *table;
  struct _GtkWidget *vscrollbar;
  table=gtk_table_new((unsigned int)1, (unsigned int)16, 0);
  text=gtk_text_view_new();
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
  struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer_3;
  return_value_gtk_text_view_get_buffer_3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast_2);
  gtk_text_buffer_get_start_iter(return_value_gtk_text_view_get_buffer_3, &iterx);
  unsigned long int return_value_gtk_text_view_get_type_4;
  return_value_gtk_text_view_get_type_4=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_4);
  bold_tag=gtk_text_buffer_create_tag(((struct _GtkTextView *)return_value_g_type_check_instance_cast_5)->buffer, "bold", "weight", 700, (void *)0);
  unsigned long int return_value_gtk_text_view_get_type_6;
  return_value_gtk_text_view_get_type_6=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
  return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_6);
  dgray_tag=gtk_text_buffer_create_tag(((struct _GtkTextView *)return_value_g_type_check_instance_cast_7)->buffer, "dk_gray_background", "background", (const void *)"dark gray", (void *)0);
  unsigned long int return_value_gtk_text_view_get_type_8;
  return_value_gtk_text_view_get_type_8=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
  return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_8);
  lgray_tag=gtk_text_buffer_create_tag(((struct _GtkTextView *)return_value_g_type_check_instance_cast_9)->buffer, "lt_gray_background", "background", (const void *)"light gray", (void *)0);
  unsigned long int return_value_gtk_text_view_get_type_10;
  return_value_gtk_text_view_get_type_10=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
  return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_10);
  fwht_tag=gtk_text_buffer_create_tag(((struct _GtkTextView *)return_value_g_type_check_instance_cast_11)->buffer, "white_foreground", "foreground", (const void *)"white", (void *)0);
  unsigned long int return_value_gtk_text_view_get_type_12;
  return_value_gtk_text_view_get_type_12=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
  return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_12);
  blue_tag=gtk_text_buffer_create_tag(((struct _GtkTextView *)return_value_g_type_check_instance_cast_13)->buffer, "blue_background", "background", (const void *)"blue", (void *)0);
  unsigned long int return_value_gtk_text_view_get_type_14;
  return_value_gtk_text_view_get_type_14=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
  return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_14);
  mono_tag=gtk_text_buffer_create_tag(((struct _GtkTextView *)return_value_g_type_check_instance_cast_15)->buffer, "monospace", "family", (const void *)"monospace", (void *)0);
  unsigned long int return_value_gtk_text_view_get_type_16;
  return_value_gtk_text_view_get_type_16=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
  return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_16);
  size_tag=gtk_text_buffer_create_tag(((struct _GtkTextView *)return_value_g_type_check_instance_cast_17)->buffer, "fsiz", "size", 8 * 1024, (void *)0);
  *textpnt = text;
  unsigned long int return_value_gtk_table_get_type_18;
  return_value_gtk_table_get_type_18=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_19;
  return_value_g_type_check_instance_cast_19=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type_18);
  gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast_19, text, (unsigned int)0, (unsigned int)14, (unsigned int)0, (unsigned int)1, (enum anonymous_63)(GTK_FILL | GTK_EXPAND), (enum anonymous_63)(GTK_FILL | GTK_SHRINK | GTK_EXPAND), (unsigned int)0, (unsigned int)0);
  unsigned long int return_value_gtk_widget_get_type_20;
  return_value_gtk_widget_get_type_20=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_widget_get_type_20);
  gtk_widget_set_usize((struct _GtkWidget *)return_value_g_type_check_instance_cast_21, 100, 100);
  unsigned long int return_value_gtk_text_view_get_type_22;
  return_value_gtk_text_view_get_type_22=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
  return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_22);
  gtk_text_view_set_editable((struct _GtkTextView *)return_value_g_type_check_instance_cast_23, 0);
  gtk_widget_show(text);
  struct _GtkTextViewClass *tc;
  unsigned long int return_value_gtk_object_get_type_24;
  return_value_gtk_object_get_type_24=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
  return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_object_get_type_24);
  tc = (struct _GtkTextViewClass *)(struct _GtkObjectClass *)((struct _GTypeInstance *)(struct _GtkObject *)return_value_g_type_check_instance_cast_25)->g_class;
  unsigned long int return_value_gtk_text_view_get_type_26;
  return_value_gtk_text_view_get_type_26=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
  return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_26);
  tc->set_scroll_adjustments((struct _GtkTextView *)return_value_g_type_check_instance_cast_27, (struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_text_view_get_type_28;
  return_value_gtk_text_view_get_type_28=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
  return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_28);
  vscrollbar=gtk_vscrollbar_new(((struct _GtkTextView *)return_value_g_type_check_instance_cast_29)->vadjustment);
  unsigned long int return_value_gtk_table_get_type_30;
  return_value_gtk_table_get_type_30=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
  return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type_30);
  gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast_31, vscrollbar, (unsigned int)15, (unsigned int)16, (unsigned int)0, (unsigned int)1, (enum anonymous_63)GTK_FILL, (enum anonymous_63)(GTK_FILL | GTK_SHRINK | GTK_EXPAND), (unsigned int)0, (unsigned int)0);
  gtk_widget_show(vscrollbar);
  unsigned long int return_value_gtk_object_get_type_32;
  return_value_gtk_object_get_type_32=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
  return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_object_get_type_32);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_33, "realize", (void (*)(void))log_realize_text, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_34;
  return_value_gtk_object_get_type_34=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_35;
  return_value_g_type_check_instance_cast_35=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_object_get_type_34);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_35, "button_release_event", (void (*)(void))button_release_event, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_36;
  return_value_gtk_object_get_type_36=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_object_get_type_36);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_37, "scroll_event", (void (*)(void))scroll_event, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)text, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_text_view_get_type_38;
  return_value_gtk_text_view_get_type_38=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
  return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_38);
  gtk_text_view_set_wrap_mode((struct _GtkTextView *)return_value_g_type_check_instance_cast_39, (enum anonymous_31)GTK_WRAP_CHAR);
  return table;
}

// create_toolbar
// file logfile.c line 518
void create_toolbar(struct _GtkWidget *table)
{
  struct _GtkWidget *find_label;
  struct _GtkWidget *find_entry;
  struct _GtkWidget *tb;
  struct _GtkWidget *stock;
  struct _GtkStyle *style;
  struct _GtkWidget *hbox;
  signed int tb_pos = 0;
  hbox=gtk_hbox_new(0, 1);
  gtk_widget_show(hbox);
  unsigned long int return_value_gtk_table_get_type_1;
  return_value_gtk_table_get_type_1=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type_1);
  gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast_2, hbox, (unsigned int)0, (unsigned int)1, (unsigned int)255, (unsigned int)256, (enum anonymous_63)(GTK_FILL | GTK_EXPAND), (enum anonymous_63)(GTK_FILL | GTK_EXPAND | GTK_SHRINK), (unsigned int)1, (unsigned int)1);
  find_label=gtk_label_new("Find:");
  gtk_widget_show(find_label);
  unsigned long int return_value_gtk_box_get_type_3;
  return_value_gtk_box_get_type_3=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type_3);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_4, find_label, 0, 0, (unsigned int)0);
  find_entry=gtk_entry_new();
  gtk_widget_show(find_entry);
  unsigned long int return_value_gtk_object_get_type_5;
  return_value_gtk_object_get_type_5=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)find_entry, return_value_gtk_object_get_type_5);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_6, "changed", (void (*)(void))press_callback, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_7;
  return_value_gtk_object_get_type_7=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)find_entry, return_value_gtk_object_get_type_7);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_8, "key_press_event", (void (*)(void))find_edit_cb, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_box_get_type_9;
  return_value_gtk_box_get_type_9=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type_9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_10, find_entry, 0, 0, (unsigned int)0);
  tb=gtk_toolbar_new();
  style=gtk_widget_get_style(tb);
  style->ythickness = 0;
  style->xthickness = style->ythickness;
  gtk_widget_set_style(tb, style);
  gtk_widget_show(tb);
  unsigned long int return_value_gtk_toolbar_get_type_11;
  return_value_gtk_toolbar_get_type_11=gtk_toolbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)tb, return_value_gtk_toolbar_get_type_11);
  gtk_toolbar_set_style((struct _GtkToolbar *)return_value_g_type_check_instance_cast_12, (enum anonymous_60)GTK_TOOLBAR_ICONS);
  unsigned long int return_value_gtk_toolbar_get_type_13;
  return_value_gtk_toolbar_get_type_13=gtk_toolbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)tb, return_value_gtk_toolbar_get_type_13);
  signed int tmp_post_15 = tb_pos;
  tb_pos = tb_pos + 1;
  stock=gtk_toolbar_insert_stock((struct _GtkToolbar *)return_value_g_type_check_instance_cast_14, "gtk-go-back", "Search Back", (const char *)(void *)0, (void (*)(void))search_backward, (void *)0, tmp_post_15);
  style=gtk_widget_get_style(stock);
  style->ythickness = 0;
  style->xthickness = style->ythickness;
  gtk_widget_set_style(stock, style);
  gtk_widget_show(stock);
  unsigned long int return_value_gtk_toolbar_get_type_16;
  return_value_gtk_toolbar_get_type_16=gtk_toolbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
  return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)tb, return_value_gtk_toolbar_get_type_16);
  stock=gtk_toolbar_insert_stock((struct _GtkToolbar *)return_value_g_type_check_instance_cast_17, "gtk-go-forward", "Search Forward", (const char *)(void *)0, (void (*)(void))search_forward, (void *)0, tb_pos);
  style=gtk_widget_get_style(stock);
  style->ythickness = 0;
  style->xthickness = style->ythickness;
  gtk_widget_set_style(stock, style);
  gtk_widget_show(stock);
  unsigned long int return_value_gtk_box_get_type_18;
  return_value_gtk_box_get_type_18=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_19;
  return_value_g_type_check_instance_cast_19=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type_18);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_19, tb, 0, 0, (unsigned int)0);
  matchcase_checkbutton=gtk_check_button_new_with_label("Match case");
  unsigned long int return_value_gtk_toggle_button_get_type_20;
  return_value_gtk_toggle_button_get_type_20=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)matchcase_checkbutton, return_value_gtk_toggle_button_get_type_20);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_21, matchcase_active);
  unsigned long int return_value_gtk_object_get_type_22;
  return_value_gtk_object_get_type_22=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
  return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)matchcase_checkbutton, return_value_gtk_object_get_type_22);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_23, "toggled", (void (*)(void))toggle_callback, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
  gtk_widget_show(matchcase_checkbutton);
  unsigned long int return_value_gtk_box_get_type_24;
  return_value_gtk_box_get_type_24=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
  return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)hbox, return_value_gtk_box_get_type_24);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_25, matchcase_checkbutton, 0, 0, (unsigned int)0);
}

// delete_item
// file jrb.c line 63
static void delete_item(struct jrb_node *item)
{
  item->flink->blink = item->blink;
  item->blink->flink = item->flink;
}

// destroy_callback
// file logfile.c line 1551
static void destroy_callback(struct _GtkWidget *widget, void *dummy)
{
  (void)dummy;
  struct text_find_t *t = text_root;
  struct text_find_t *tprev = (struct text_find_t *)(void *)0;
  struct logfile_context_t *ctx = (struct logfile_context_t *)(void *)0;
  signed int which = (signed int)(notebook != (struct _GtkWidget *)(void *)0);
  struct _GtkWidget *matched = (struct _GtkWidget *)(void *)0;
  struct _GtkWidget *tmp_if_expr_1;
  for( ; !(t == ((struct text_find_t *)NULL)); t = t->next)
  {
    if(!(which == 0))
      tmp_if_expr_1 = t->button;

    else
      tmp_if_expr_1 = t->window;
    if(tmp_if_expr_1 == widget)
    {
      matched = t->window;
      if(t == selected_text_via_tab)
        selected_text_via_tab = (struct text_find_t *)(void *)0;

      if(!(tprev == ((struct text_find_t *)NULL)))
      {
        tprev->next = t->next;
        ctx = t->ctx;
        free((void *)t);
        break;
      }

      else
      {
        text_root = t->next;
        ctx = t->ctx;
        free((void *)t);
        break;
      }
    }

    tprev = t;
  }
  if(!(matched == ((struct _GtkWidget *)NULL)))
    gtk_widget_destroy(matched);

  if(!(ctx == ((struct logfile_context_t *)NULL)))
  {
    struct jrb_node *node;
    struct jrb_node *varnames = ctx->varnames;
    if(!(ctx->title == ((char *)NULL)))
      free((void *)ctx->title);

    if(varnames == ((struct jrb_node *)NULL))
      goto __CPROVER_DUMP_L19;

    node = varnames->flink;
    for( ; !(node == varnames); node = node->flink)
    {
      if(!(node->val2.v == NULL))
        free(node->val2.v);

      free((void *)node->key.s);
    }
    node = varnames->flink;
    for( ; !(node == varnames); node = node->flink)
    {
      struct jrb_chain *jvc = node->jval_chain;
      while(!(jvc == ((struct jrb_chain *)NULL)))
      {
        struct jrb_chain *jvcn = jvc->next;
        free((void *)jvc);
        jvc = jvcn;
      }
    }
    jrb_free_tree(varnames);
    free((void *)ctx);
  }


__CPROVER_DUMP_L19:
  ;
}

// destroy_callback_link1
// file tree_widget.c line 87
static void destroy_callback_link1(struct _GtkWidget *widget_link1, struct _GtkWidget *nothing)
{
  (void)widget_link1;
  (void)nothing;
  is_active = 0;
  gtk_widget_destroy(window);
  gtk_main_quit();
}

// destroy_via_closebutton_release
// file logfile.c line 1624
static signed int destroy_via_closebutton_release(struct _GtkWidget *widget, struct _GdkEventButton *event)
{
  _Bool tmp_if_expr_1;
  if(event->x < 0.000000)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = event->x >= (double)widget->allocation.width ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = event->y < (double)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = event->y >= (double)widget->allocation.height ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_3)
    destroy_callback(widget, (void *)0);

  return (signed int)!(0 != 0);
}

// ds_delete
// file splay.c line 127
struct ds_tree_node * ds_delete(char *i, struct ds_tree_node *t)
{
  struct ds_tree_node *x;
  if(t == ((struct ds_tree_node *)NULL))
    return (struct ds_tree_node *)(void *)0;

  else
  {
    t=ds_splay(i, t);
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(i, t->item);
    if(return_value_strcmp_1 == 0)
    {
      if(t->left == ((struct ds_tree_node *)NULL))
        x = t->right;

      else
      {
        x=ds_splay(i, t->left);
        x->right = t->right;
      }
      free((void *)t);
      return x;
    }

    else
      return t;
  }
}

// ds_insert
// file splay.c line 94
struct ds_tree_node * ds_insert(char *i, struct ds_tree_node *t)
{
  struct ds_tree_node *n;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct ds_tree_node) /*80ul*/ );
  n = (struct ds_tree_node *)return_value_calloc_1;
  if(n == ((struct ds_tree_node *)NULL))
  {
    fprintf(stderr, "ds_insert: ran out of memory, exiting.\n");
    exit(255);
  }

  n->item = i;
  signed int return_value_strcmp_2;
  if(t == ((struct ds_tree_node *)NULL))
  {
    n->right = (struct ds_tree_node *)(void *)0;
    n->left = n->right;
    return n;
  }

  else
  {
    t=ds_splay(i, t);
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(i, t->item);
    if(!(return_value_strcmp_3 >= 0))
    {
      n->left = t->left;
      n->right = t;
      t->left = (struct ds_tree_node *)(void *)0;
      return n;
    }

    else
    {
      return_value_strcmp_2=strcmp(i, t->item);
      if(return_value_strcmp_2 >= 1)
      {
        n->right = t->right;
        n->left = t;
        t->right = (struct ds_tree_node *)(void *)0;
        return n;
      }

      else
      {
        free((void *)n);
        return t;
      }
    }
  }
}

// ds_splay
// file splay.c line 49
struct ds_tree_node * ds_splay(char *i, struct ds_tree_node *t)
{
  struct ds_tree_node N;
  struct ds_tree_node *l;
  struct ds_tree_node *r;
  struct ds_tree_node *y;
  signed int return_value_strcmp_3;
  if(t == ((struct ds_tree_node *)NULL))
    return t;

  else
  {
    N.right = (struct ds_tree_node *)(void *)0;
    N.left = N.right;
    r = &N;
    l = r;
    do
    {
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(i, t->item);
      if(!(return_value_strcmp_4 >= 0))
      {
        if(t->left == ((struct ds_tree_node *)NULL))
          break;

        signed int return_value_strcmp_1;
        return_value_strcmp_1=strcmp(i, t->left->item);
        if(!(return_value_strcmp_1 >= 0))
        {
          y = t->left;
          t->left = y->right;
          y->right = t;
          t = y;
          if(t->left == ((struct ds_tree_node *)NULL))
            break;

        }

        r->left = t;
        r = t;
        t = t->left;
      }

      else
      {
        return_value_strcmp_3=strcmp(i, t->item);
        if(return_value_strcmp_3 >= 1)
        {
          if(t->right == ((struct ds_tree_node *)NULL))
            break;

          signed int return_value_strcmp_2;
          return_value_strcmp_2=strcmp(i, t->right->item);
          if(return_value_strcmp_2 >= 1)
          {
            y = t->right;
            t->right = y->left;
            y->left = t;
            t = y;
            if(t->right == ((struct ds_tree_node *)NULL))
              break;

          }

          l->right = t;
          l = t;
          t = t->right;
        }

        else
          break;
      }
    }
    while((_Bool)1);
    l->right = t->left;
    r->left = t->right;
    t->left = N.right;
    t->right = N.left;
    return t;
  }
}

// expose_event_local
// file logfile.c line 121
static signed int expose_event_local(struct _GtkWidget *widget, struct _GdkEventExpose *event)
{
  (void)event;
  struct text_find_t *tr = text_root;
  for( ; !(tr == ((struct text_find_t *)NULL)); tr = tr->next)
    if(tr->window == widget)
    {
      if(!(selected_text_via_tab == tr))
        selected_text_via_tab = tr;

      return 0;
    }

  selected_text_via_tab = (struct text_find_t *)(void *)0;
  return 0;
}

// fastlz1_compress
// file ./../../src/helpers/fst/fastlz.c line 162
static inline signed int fastlz1_compress(const void *input, signed int length, void *output)
{
  const unsigned char *ip = (const unsigned char *)input;
  const unsigned char *ip_bound = (ip + (signed long int)length) - (signed long int)2;
  const unsigned char *ip_limit = (ip + (signed long int)length) - (signed long int)12;
  unsigned char *op = (unsigned char *)output;
  const unsigned char *htab[8192l];
  const unsigned char **hslot;
  unsigned int hval;
  unsigned int copy;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  const unsigned char *tmp_post_8;
  _Bool tmp_if_expr_11;
  const unsigned char *tmp_post_9;
  const unsigned char *tmp_post_10;
  _Bool tmp_if_expr_14;
  const unsigned char *tmp_post_12;
  const unsigned char *tmp_post_13;
  _Bool tmp_if_expr_17;
  const unsigned char *tmp_post_15;
  const unsigned char *tmp_post_16;
  const unsigned char *tmp_post_18;
  const unsigned char *tmp_post_19;
  const unsigned char *tmp_post_20;
  const unsigned char *tmp_post_21;
  const unsigned char *tmp_post_22;
  const unsigned char *tmp_post_23;
  const unsigned char *tmp_post_24;
  const unsigned char *tmp_post_25;
  const unsigned char *tmp_post_26;
  const unsigned char *tmp_post_27;
  const unsigned char *tmp_post_28;
  const unsigned char *tmp_post_29;
  const unsigned char *tmp_post_30;
  const unsigned char *tmp_post_31;
  const unsigned char *tmp_post_32;
  const unsigned char *tmp_post_33;
  const unsigned char *tmp_post_34;
  const unsigned char *tmp_post_35;
  const unsigned char *tmp_post_36;
  unsigned char *tmp_post_37;
  unsigned char *tmp_post_38;
  unsigned char *tmp_post_39;
  unsigned char *tmp_post_40;
  unsigned char *tmp_post_41;
  unsigned char *tmp_post_42;
  unsigned char *tmp_post_43;
  unsigned char *tmp_post_44;
  const unsigned char *tmp_post_45;
  const unsigned char *tmp_post_46;
  unsigned char *tmp_post_47;
  unsigned char *tmp_post_48;
  const unsigned char *tmp_post_49;
  unsigned char *tmp_post_50;
  unsigned char *tmp_post_51;
  const unsigned char *tmp_post_52;
  unsigned char *tmp_post_53;
  if(!(length >= 4))
  {
    if(!(length == 0))
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned char)(length - 1);
      ip_bound = ip_bound + 1l;
      for( ; ip_bound >= ip; *tmp_post_2 = *tmp_post_3)
      {
        tmp_post_2 = op;
        op = op + 1l;
        tmp_post_3 = ip;
        ip = ip + 1l;
      }
      return length + 1;
    }

    return 0;
  }

  else
  {
    hslot = htab;
    for( ; !(hslot >= htab + 8192l); hslot = hslot + 1l)
      *hslot = ip;
    copy = (unsigned int)2;
    tmp_post_4 = op;
    op = op + 1l;
    *tmp_post_4 = (unsigned char)(32 - 1);
    tmp_post_5 = op;
    op = op + 1l;
    tmp_post_6 = ip;
    ip = ip + 1l;
    *tmp_post_5 = *tmp_post_6;
    tmp_post_7 = op;
    op = op + 1l;
    tmp_post_8 = ip;
    ip = ip + 1l;
    *tmp_post_7 = *tmp_post_8;
    while(!(ip >= ip_limit))
    {
      const unsigned char *ref;
      unsigned int distance;
      unsigned int len = (unsigned int)3;
      const unsigned char *anchor = ip;
      hval = (unsigned int)*((const unsigned short int *)ip);
      hval = hval ^ (unsigned int)*((const unsigned short int *)(ip + (signed long int)1)) ^ hval >> 16 - 13;
      hval = hval & (unsigned int)((1 << 13) - 1);
      hslot = htab + (signed long int)hval;
      ref = htab[(signed long int)hval];
      distance = (unsigned int)(anchor - ref);
      *hslot = anchor;
      if(distance == 0u || distance >= 8192u)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        tmp_post_9 = ref;
        ref = ref + 1l;
        tmp_post_10 = ip;
        ip = ip + 1l;
        tmp_if_expr_11 = *tmp_post_9 != *tmp_post_10 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        tmp_post_12 = ref;
        ref = ref + 1l;
        tmp_post_13 = ip;
        ip = ip + 1l;
        tmp_if_expr_14 = *tmp_post_12 != *tmp_post_13 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_14)
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        tmp_post_15 = ref;
        ref = ref + 1l;
        tmp_post_16 = ip;
        ip = ip + 1l;
        tmp_if_expr_17 = *tmp_post_15 != *tmp_post_16 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_17)
      {
        ip = anchor + (signed long int)len;
        distance = distance - 1u;
        if(distance == 0u)
        {
          unsigned char x = ip[(signed long int)-1];
          while(!(ip >= ip_bound))
          {
            tmp_post_18 = ref;
            ref = ref + 1l;
            if(!(*tmp_post_18 == x))
              break;

            else
              ip = ip + 1l;
          }
        }

        else
        {
          tmp_post_19 = ref;
          ref = ref + 1l;
          tmp_post_20 = ip;
          ip = ip + 1l;
          if(*tmp_post_19 == *tmp_post_20)
          {
            tmp_post_21 = ref;
            ref = ref + 1l;
            tmp_post_22 = ip;
            ip = ip + 1l;
            if(*tmp_post_21 == *tmp_post_22)
            {
              tmp_post_23 = ref;
              ref = ref + 1l;
              tmp_post_24 = ip;
              ip = ip + 1l;
              if(*tmp_post_23 == *tmp_post_24)
              {
                tmp_post_25 = ref;
                ref = ref + 1l;
                tmp_post_26 = ip;
                ip = ip + 1l;
                if(*tmp_post_25 == *tmp_post_26)
                {
                  tmp_post_27 = ref;
                  ref = ref + 1l;
                  tmp_post_28 = ip;
                  ip = ip + 1l;
                  if(*tmp_post_27 == *tmp_post_28)
                  {
                    tmp_post_29 = ref;
                    ref = ref + 1l;
                    tmp_post_30 = ip;
                    ip = ip + 1l;
                    if(*tmp_post_29 == *tmp_post_30)
                    {
                      tmp_post_31 = ref;
                      ref = ref + 1l;
                      tmp_post_32 = ip;
                      ip = ip + 1l;
                      if(*tmp_post_31 == *tmp_post_32)
                      {
                        tmp_post_33 = ref;
                        ref = ref + 1l;
                        tmp_post_34 = ip;
                        ip = ip + 1l;
                        if(*tmp_post_33 == *tmp_post_34)
                          while(!(ip >= ip_bound))
                          {
                            tmp_post_35 = ref;
                            ref = ref + 1l;
                            tmp_post_36 = ip;
                            ip = ip + 1l;
                            if(!(*tmp_post_35 == *tmp_post_36))
                              break;

                          }

                      }

                    }

                  }

                }

              }

            }

          }

        }
        if(!(copy == 0u))
          *((op - (signed long int)copy) - (signed long int)1) = (unsigned char)(copy - (unsigned int)1);

        else
          op = op - 1l;
        copy = (unsigned int)0;
        ip = ip - (signed long int)3;
        len = (unsigned int)(ip - anchor);
        if(len >= 263u)
          for( ; len >= 263u; len = len - (unsigned int)(264 - 2))
          {
            tmp_post_37 = op;
            op = op + 1l;
            *tmp_post_37 = (unsigned char)((unsigned int)(7 << 5) + (distance >> 8));
            tmp_post_38 = op;
            op = op + 1l;
            *tmp_post_38 = (unsigned char)(((264 - 2) - 7) - 2);
            tmp_post_39 = op;
            op = op + 1l;
            *tmp_post_39 = (unsigned char)(distance & (unsigned int)255);
          }

        if(!(len >= 7u))
        {
          tmp_post_40 = op;
          op = op + 1l;
          *tmp_post_40 = (unsigned char)((len << 5) + (distance >> 8));
          tmp_post_41 = op;
          op = op + 1l;
          *tmp_post_41 = (unsigned char)(distance & (unsigned int)255);
        }

        else
        {
          tmp_post_42 = op;
          op = op + 1l;
          *tmp_post_42 = (unsigned char)((unsigned int)(7 << 5) + (distance >> 8));
          tmp_post_43 = op;
          op = op + 1l;
          *tmp_post_43 = (unsigned char)(len - (unsigned int)7);
          tmp_post_44 = op;
          op = op + 1l;
          *tmp_post_44 = (unsigned char)(distance & (unsigned int)255);
        }
        hval = (unsigned int)*((const unsigned short int *)ip);
        hval = hval ^ (unsigned int)*((const unsigned short int *)(ip + (signed long int)1)) ^ hval >> 16 - 13;
        hval = hval & (unsigned int)((1 << 13) - 1);
        tmp_post_45 = ip;
        ip = ip + 1l;
        htab[(signed long int)hval] = tmp_post_45;
        hval = (unsigned int)*((const unsigned short int *)ip);
        hval = hval ^ (unsigned int)*((const unsigned short int *)(ip + (signed long int)1)) ^ hval >> 16 - 13;
        hval = hval & (unsigned int)((1 << 13) - 1);
        tmp_post_46 = ip;
        ip = ip + 1l;
        htab[(signed long int)hval] = tmp_post_46;
        tmp_post_47 = op;
        op = op + 1l;
        *tmp_post_47 = (unsigned char)(32 - 1);
      }

      else
      {

      literal:
        ;
        tmp_post_48 = op;
        op = op + 1l;
        tmp_post_49 = anchor;
        anchor = anchor + 1l;
        *tmp_post_48 = *tmp_post_49;
        ip = anchor;
        copy = copy + 1u;
        if(copy == 32u)
        {
          copy = (unsigned int)0;
          tmp_post_50 = op;
          op = op + 1l;
          *tmp_post_50 = (unsigned char)(32 - 1);
        }

      }
    }
    ip_bound = ip_bound + 1l;
    while(ip_bound >= ip)
    {
      tmp_post_51 = op;
      op = op + 1l;
      tmp_post_52 = ip;
      ip = ip + 1l;
      *tmp_post_51 = *tmp_post_52;
      copy = copy + 1u;
      if(copy == 32u)
      {
        copy = (unsigned int)0;
        tmp_post_53 = op;
        op = op + 1l;
        *tmp_post_53 = (unsigned char)(32 - 1);
      }

    }
    if(!(copy == 0u))
      *((op - (signed long int)copy) - (signed long int)1) = (unsigned char)(copy - (unsigned int)1);

    else
      op = op - 1l;
    return (signed int)(op - (unsigned char *)output);
  }
}

// fastlz1_decompress
// file ./../../src/helpers/fst/fastlz.c line 416
static inline signed int fastlz1_decompress(const void *input, signed int length, void *output, signed int maxout)
{
  const unsigned char *ip = (const unsigned char *)input;
  const unsigned char *ip_limit = ip + (signed long int)length;
  unsigned char *op = (unsigned char *)output;
  unsigned char *op_limit = op + (signed long int)maxout;
  unsigned int ctrl;
  const unsigned char *tmp_post_1 = ip;
  ip = ip + 1l;
  ctrl = (unsigned int)((signed int)*tmp_post_1 & 31);
  signed int loop = 1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  const unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  const unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  const unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  const unsigned char *tmp_post_16;
  unsigned short int *tmp_post_17;
  const unsigned short int *tmp_post_18;
  unsigned short int *tmp_post_19;
  const unsigned short int *tmp_post_20;
  unsigned short int *tmp_post_21;
  const unsigned short int *tmp_post_22;
  unsigned short int *tmp_post_23;
  const unsigned short int *tmp_post_24;
  unsigned short int *tmp_post_25;
  const unsigned short int *tmp_post_26;
  unsigned char *tmp_post_27;
  const unsigned char *tmp_post_28;
  unsigned char *tmp_post_29;
  const unsigned char *tmp_post_30;
  const unsigned char *tmp_post_31;
  do
  {
    const unsigned char *ref = op;
    unsigned int len = ctrl >> 5;
    unsigned int ofs = (ctrl & (unsigned int)31) << 8;
    if(ctrl >= 32u)
    {
      len = len - 1u;
      ref = ref - (signed long int)ofs;
      if(len == 6u)
      {
        tmp_post_2 = ip;
        ip = ip + 1l;
        len = len + (unsigned int)*tmp_post_2;
      }

      tmp_post_3 = ip;
      ip = ip + 1l;
      ref = ref - (signed long int)*tmp_post_3;
      if(!(op_limit >= op + (signed long int)len + 3l))
        return 0;

      if(!(ref + -1l >= (unsigned char *)output))
        return 0;

      if(!(ip >= ip_limit))
      {
        tmp_post_4 = ip;
        ip = ip + 1l;
        ctrl = (unsigned int)*tmp_post_4;
      }

      else
        loop = 0;
      if(ref == op)
      {
        unsigned char b = ref[(signed long int)-1];
        tmp_post_5 = op;
        op = op + 1l;
        *tmp_post_5 = b;
        tmp_post_6 = op;
        op = op + 1l;
        *tmp_post_6 = b;
        tmp_post_7 = op;
        op = op + 1l;
        *tmp_post_7 = b;
        for( ; !(len == 0u); len = len - 1u)
        {
          tmp_post_8 = op;
          op = op + 1l;
          *tmp_post_8 = b;
        }
      }

      else
      {
        const unsigned short int *p;
        unsigned short int *q;
        ref = ref - 1l;
        tmp_post_9 = op;
        op = op + 1l;
        tmp_post_10 = ref;
        ref = ref + 1l;
        *tmp_post_9 = *tmp_post_10;
        tmp_post_11 = op;
        op = op + 1l;
        tmp_post_12 = ref;
        ref = ref + 1l;
        *tmp_post_11 = *tmp_post_12;
        tmp_post_13 = op;
        op = op + 1l;
        tmp_post_14 = ref;
        ref = ref + 1l;
        *tmp_post_13 = *tmp_post_14;
        if(!((1u & len) == 0u))
        {
          tmp_post_15 = op;
          op = op + 1l;
          tmp_post_16 = ref;
          ref = ref + 1l;
          *tmp_post_15 = *tmp_post_16;
          len = len - 1u;
        }

        q = (unsigned short int *)op;
        op = op + (signed long int)len;
        p = (const unsigned short int *)ref;
        len = len >> 1;
        for( ; len >= 5u; len = len - (unsigned int)4)
        {
          tmp_post_17 = q;
          q = q + 1l;
          tmp_post_18 = p;
          p = p + 1l;
          *tmp_post_17 = *tmp_post_18;
          tmp_post_19 = q;
          q = q + 1l;
          tmp_post_20 = p;
          p = p + 1l;
          *tmp_post_19 = *tmp_post_20;
          tmp_post_21 = q;
          q = q + 1l;
          tmp_post_22 = p;
          p = p + 1l;
          *tmp_post_21 = *tmp_post_22;
          tmp_post_23 = q;
          q = q + 1l;
          tmp_post_24 = p;
          p = p + 1l;
          *tmp_post_23 = *tmp_post_24;
        }
        for( ; !(len == 0u); len = len - 1u)
        {
          tmp_post_25 = q;
          q = q + 1l;
          tmp_post_26 = p;
          p = p + 1l;
          *tmp_post_25 = *tmp_post_26;
        }
      }
    }

    else
    {
      ctrl = ctrl + 1u;
      if(!(op_limit >= op + (signed long int)ctrl))
        return 0;

      if(!(ip_limit >= ip + (signed long int)ctrl))
        return 0;

      tmp_post_27 = op;
      op = op + 1l;
      tmp_post_28 = ip;
      ip = ip + 1l;
      *tmp_post_27 = *tmp_post_28;
      ctrl = ctrl - 1u;
      for( ; !(ctrl == 0u); ctrl = ctrl - 1u)
      {
        tmp_post_29 = op;
        op = op + 1l;
        tmp_post_30 = ip;
        ip = ip + 1l;
        *tmp_post_29 = *tmp_post_30;
      }
      loop = (signed int)(signed long int)(ip < ip_limit);
      if(!(loop == 0))
      {
        tmp_post_31 = ip;
        ip = ip + 1l;
        ctrl = (unsigned int)*tmp_post_31;
      }

    }
  }
  while(!((signed long int)loop == 0l));
  return (signed int)(op - (unsigned char *)output);
}

// fastlz2_compress
// file ./../../src/helpers/fst/fastlz.c line 162
static inline signed int fastlz2_compress(const void *input, signed int length, void *output)
{
  const unsigned char *ip = (const unsigned char *)input;
  const unsigned char *ip_bound = (ip + (signed long int)length) - (signed long int)2;
  const unsigned char *ip_limit = (ip + (signed long int)length) - (signed long int)12;
  unsigned char *op = (unsigned char *)output;
  const unsigned char *htab[8192l];
  const unsigned char **hslot;
  unsigned int hval;
  unsigned int copy;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  const unsigned char *tmp_post_8;
  _Bool tmp_if_expr_11;
  const unsigned char *tmp_post_9;
  const unsigned char *tmp_post_10;
  _Bool tmp_if_expr_14;
  const unsigned char *tmp_post_12;
  const unsigned char *tmp_post_13;
  _Bool tmp_if_expr_17;
  const unsigned char *tmp_post_15;
  const unsigned char *tmp_post_16;
  const unsigned char *tmp_post_18;
  const unsigned char *tmp_post_19;
  _Bool tmp_if_expr_22;
  const unsigned char *tmp_post_20;
  const unsigned char *tmp_post_21;
  const unsigned char *tmp_post_23;
  const unsigned char *tmp_post_24;
  const unsigned char *tmp_post_25;
  const unsigned char *tmp_post_26;
  const unsigned char *tmp_post_27;
  const unsigned char *tmp_post_28;
  const unsigned char *tmp_post_29;
  const unsigned char *tmp_post_30;
  const unsigned char *tmp_post_31;
  const unsigned char *tmp_post_32;
  const unsigned char *tmp_post_33;
  const unsigned char *tmp_post_34;
  const unsigned char *tmp_post_35;
  const unsigned char *tmp_post_36;
  const unsigned char *tmp_post_37;
  const unsigned char *tmp_post_38;
  const unsigned char *tmp_post_39;
  const unsigned char *tmp_post_40;
  const unsigned char *tmp_post_41;
  unsigned char *tmp_post_42;
  unsigned char *tmp_post_43;
  unsigned char *tmp_post_44;
  unsigned char *tmp_post_45;
  unsigned char *tmp_post_46;
  unsigned char *tmp_post_47;
  unsigned char *tmp_post_48;
  unsigned char *tmp_post_49;
  unsigned char *tmp_post_50;
  unsigned char *tmp_post_51;
  unsigned char *tmp_post_52;
  unsigned char *tmp_post_53;
  unsigned char *tmp_post_54;
  unsigned char *tmp_post_55;
  unsigned char *tmp_post_56;
  unsigned char *tmp_post_57;
  const unsigned char *tmp_post_58;
  const unsigned char *tmp_post_59;
  unsigned char *tmp_post_60;
  unsigned char *tmp_post_61;
  const unsigned char *tmp_post_62;
  unsigned char *tmp_post_63;
  unsigned char *tmp_post_64;
  const unsigned char *tmp_post_65;
  unsigned char *tmp_post_66;
  if(!(length >= 4))
  {
    if(!(length == 0))
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned char)(length - 1);
      ip_bound = ip_bound + 1l;
      for( ; ip_bound >= ip; *tmp_post_2 = *tmp_post_3)
      {
        tmp_post_2 = op;
        op = op + 1l;
        tmp_post_3 = ip;
        ip = ip + 1l;
      }
      return length + 1;
    }

    return 0;
  }

  else
  {
    hslot = htab;
    for( ; !(hslot >= htab + 8192l); hslot = hslot + 1l)
      *hslot = ip;
    copy = (unsigned int)2;
    tmp_post_4 = op;
    op = op + 1l;
    *tmp_post_4 = (unsigned char)(32 - 1);
    tmp_post_5 = op;
    op = op + 1l;
    tmp_post_6 = ip;
    ip = ip + 1l;
    *tmp_post_5 = *tmp_post_6;
    tmp_post_7 = op;
    op = op + 1l;
    tmp_post_8 = ip;
    ip = ip + 1l;
    *tmp_post_7 = *tmp_post_8;
    while(!(ip >= ip_limit))
    {
      const unsigned char *ref;
      unsigned int distance;
      unsigned int len = (unsigned int)3;
      const unsigned char *anchor = ip;
      if(*ip == ip[-1l])
      {
        if(!(*((const unsigned short int *)(ip + -1l)) == *((const unsigned short int *)(ip + 1l))))
          goto __CPROVER_DUMP_L8;

        distance = (unsigned int)1;
        ref = (anchor - (signed long int)1) + (signed long int)3;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        hval = (unsigned int)*((const unsigned short int *)ip);
        hval = hval ^ (unsigned int)*((const unsigned short int *)(ip + (signed long int)1)) ^ hval >> 16 - 13;
        hval = hval & (unsigned int)((1 << 13) - 1);
        hslot = htab + (signed long int)hval;
        ref = htab[(signed long int)hval];
        distance = (unsigned int)(anchor - ref);
        *hslot = anchor;
        if(distance == 0u || distance >= 73725u)
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          tmp_post_9 = ref;
          ref = ref + 1l;
          tmp_post_10 = ip;
          ip = ip + 1l;
          tmp_if_expr_11 = *tmp_post_9 != *tmp_post_10 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
          tmp_if_expr_14 = (_Bool)1;

        else
        {
          tmp_post_12 = ref;
          ref = ref + 1l;
          tmp_post_13 = ip;
          ip = ip + 1l;
          tmp_if_expr_14 = *tmp_post_12 != *tmp_post_13 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_14)
          tmp_if_expr_17 = (_Bool)1;

        else
        {
          tmp_post_15 = ref;
          ref = ref + 1l;
          tmp_post_16 = ip;
          ip = ip + 1l;
          tmp_if_expr_17 = *tmp_post_15 != *tmp_post_16 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_17)
          goto literal;

        if(distance >= 8191u)
        {
          tmp_post_18 = ip;
          ip = ip + 1l;
          tmp_post_19 = ref;
          ref = ref + 1l;
          if(!(*tmp_post_18 == *tmp_post_19))
            tmp_if_expr_22 = (_Bool)1;

          else
          {
            tmp_post_20 = ip;
            ip = ip + 1l;
            tmp_post_21 = ref;
            ref = ref + 1l;
            tmp_if_expr_22 = *tmp_post_20 != *tmp_post_21 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_22)
            goto literal;

          len = len + (unsigned int)2;
        }

      }

    match:
      ;
      ip = anchor + (signed long int)len;
      distance = distance - 1u;
      if(distance == 0u)
      {
        unsigned char x = ip[(signed long int)-1];
        while(!(ip >= ip_bound))
        {
          tmp_post_23 = ref;
          ref = ref + 1l;
          if(!(*tmp_post_23 == x))
            break;

          else
            ip = ip + 1l;
        }
      }

      else
      {
        tmp_post_24 = ref;
        ref = ref + 1l;
        tmp_post_25 = ip;
        ip = ip + 1l;
        if(*tmp_post_24 == *tmp_post_25)
        {
          tmp_post_26 = ref;
          ref = ref + 1l;
          tmp_post_27 = ip;
          ip = ip + 1l;
          if(*tmp_post_26 == *tmp_post_27)
          {
            tmp_post_28 = ref;
            ref = ref + 1l;
            tmp_post_29 = ip;
            ip = ip + 1l;
            if(*tmp_post_28 == *tmp_post_29)
            {
              tmp_post_30 = ref;
              ref = ref + 1l;
              tmp_post_31 = ip;
              ip = ip + 1l;
              if(*tmp_post_30 == *tmp_post_31)
              {
                tmp_post_32 = ref;
                ref = ref + 1l;
                tmp_post_33 = ip;
                ip = ip + 1l;
                if(*tmp_post_32 == *tmp_post_33)
                {
                  tmp_post_34 = ref;
                  ref = ref + 1l;
                  tmp_post_35 = ip;
                  ip = ip + 1l;
                  if(*tmp_post_34 == *tmp_post_35)
                  {
                    tmp_post_36 = ref;
                    ref = ref + 1l;
                    tmp_post_37 = ip;
                    ip = ip + 1l;
                    if(*tmp_post_36 == *tmp_post_37)
                    {
                      tmp_post_38 = ref;
                      ref = ref + 1l;
                      tmp_post_39 = ip;
                      ip = ip + 1l;
                      if(*tmp_post_38 == *tmp_post_39)
                        while(!(ip >= ip_bound))
                        {
                          tmp_post_40 = ref;
                          ref = ref + 1l;
                          tmp_post_41 = ip;
                          ip = ip + 1l;
                          if(!(*tmp_post_40 == *tmp_post_41))
                            break;

                        }

                    }

                  }

                }

              }

            }

          }

        }

      }
      if(!(copy == 0u))
        *((op - (signed long int)copy) - (signed long int)1) = (unsigned char)(copy - (unsigned int)1);

      else
        op = op - 1l;
      copy = (unsigned int)0;
      ip = ip - (signed long int)3;
      len = (unsigned int)(ip - anchor);
      if(!(distance >= 8191u))
      {
        if(!(len >= 7u))
        {
          tmp_post_42 = op;
          op = op + 1l;
          *tmp_post_42 = (unsigned char)((len << 5) + (distance >> 8));
          tmp_post_43 = op;
          op = op + 1l;
          *tmp_post_43 = (unsigned char)(distance & (unsigned int)255);
        }

        else
        {
          tmp_post_44 = op;
          op = op + 1l;
          *tmp_post_44 = (unsigned char)((unsigned int)(7 << 5) + (distance >> 8));
          len = len - (unsigned int)7;
          for( ; len >= 255u; len = len - (unsigned int)255)
          {
            tmp_post_45 = op;
            op = op + 1l;
            *tmp_post_45 = (unsigned char)255;
          }
          tmp_post_46 = op;
          op = op + 1l;
          *tmp_post_46 = (unsigned char)len;
          tmp_post_47 = op;
          op = op + 1l;
          *tmp_post_47 = (unsigned char)(distance & (unsigned int)255);
        }
      }

      else
        if(!(len >= 7u))
        {
          distance = distance - (unsigned int)8191;
          tmp_post_48 = op;
          op = op + 1l;
          *tmp_post_48 = (unsigned char)((len << 5) + (unsigned int)31);
          tmp_post_49 = op;
          op = op + 1l;
          *tmp_post_49 = (unsigned char)255;
          tmp_post_50 = op;
          op = op + 1l;
          *tmp_post_50 = (unsigned char)(distance >> 8);
          tmp_post_51 = op;
          op = op + 1l;
          *tmp_post_51 = (unsigned char)(distance & (unsigned int)255);
        }

        else
        {
          distance = distance - (unsigned int)8191;
          tmp_post_52 = op;
          op = op + 1l;
          *tmp_post_52 = (unsigned char)((7 << 5) + 31);
          len = len - (unsigned int)7;
          for( ; len >= 255u; len = len - (unsigned int)255)
          {
            tmp_post_53 = op;
            op = op + 1l;
            *tmp_post_53 = (unsigned char)255;
          }
          tmp_post_54 = op;
          op = op + 1l;
          *tmp_post_54 = (unsigned char)len;
          tmp_post_55 = op;
          op = op + 1l;
          *tmp_post_55 = (unsigned char)255;
          tmp_post_56 = op;
          op = op + 1l;
          *tmp_post_56 = (unsigned char)(distance >> 8);
          tmp_post_57 = op;
          op = op + 1l;
          *tmp_post_57 = (unsigned char)(distance & (unsigned int)255);
        }
      hval = (unsigned int)*((const unsigned short int *)ip);
      hval = hval ^ (unsigned int)*((const unsigned short int *)(ip + (signed long int)1)) ^ hval >> 16 - 13;
      hval = hval & (unsigned int)((1 << 13) - 1);
      tmp_post_58 = ip;
      ip = ip + 1l;
      htab[(signed long int)hval] = tmp_post_58;
      hval = (unsigned int)*((const unsigned short int *)ip);
      hval = hval ^ (unsigned int)*((const unsigned short int *)(ip + (signed long int)1)) ^ hval >> 16 - 13;
      hval = hval & (unsigned int)((1 << 13) - 1);
      tmp_post_59 = ip;
      ip = ip + 1l;
      htab[(signed long int)hval] = tmp_post_59;
      tmp_post_60 = op;
      op = op + 1l;
      *tmp_post_60 = (unsigned char)(32 - 1);
      continue;

    literal:
      ;
      tmp_post_61 = op;
      op = op + 1l;
      tmp_post_62 = anchor;
      anchor = anchor + 1l;
      *tmp_post_61 = *tmp_post_62;
      ip = anchor;
      copy = copy + 1u;
      if(copy == 32u)
      {
        copy = (unsigned int)0;
        tmp_post_63 = op;
        op = op + 1l;
        *tmp_post_63 = (unsigned char)(32 - 1);
      }

    }
    ip_bound = ip_bound + 1l;
    while(ip_bound >= ip)
    {
      tmp_post_64 = op;
      op = op + 1l;
      tmp_post_65 = ip;
      ip = ip + 1l;
      *tmp_post_64 = *tmp_post_65;
      copy = copy + 1u;
      if(copy == 32u)
      {
        copy = (unsigned int)0;
        tmp_post_66 = op;
        op = op + 1l;
        *tmp_post_66 = (unsigned char)(32 - 1);
      }

    }
    if(!(copy == 0u))
      *((op - (signed long int)copy) - (signed long int)1) = (unsigned char)(copy - (unsigned int)1);

    else
      op = op - 1l;
    *((unsigned char *)output) = *((unsigned char *)output) | (unsigned char)(1 << 5);
    return (signed int)(op - (unsigned char *)output);
  }
}

// fastlz2_decompress
// file ./../../src/helpers/fst/fastlz.c line 416
static inline signed int fastlz2_decompress(const void *input, signed int length, void *output, signed int maxout)
{
  const unsigned char *ip = (const unsigned char *)input;
  const unsigned char *ip_limit = ip + (signed long int)length;
  unsigned char *op = (unsigned char *)output;
  unsigned char *op_limit = op + (signed long int)maxout;
  unsigned int ctrl;
  const unsigned char *tmp_post_1 = ip;
  ip = ip + 1l;
  ctrl = (unsigned int)((signed int)*tmp_post_1 & 31);
  signed int loop = 1;
  const unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  const unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  const unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  const unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  const unsigned char *tmp_post_18;
  unsigned short int *tmp_post_19;
  const unsigned short int *tmp_post_20;
  unsigned short int *tmp_post_21;
  const unsigned short int *tmp_post_22;
  unsigned short int *tmp_post_23;
  const unsigned short int *tmp_post_24;
  unsigned short int *tmp_post_25;
  const unsigned short int *tmp_post_26;
  unsigned short int *tmp_post_27;
  const unsigned short int *tmp_post_28;
  unsigned char *tmp_post_29;
  const unsigned char *tmp_post_30;
  unsigned char *tmp_post_31;
  const unsigned char *tmp_post_32;
  const unsigned char *tmp_post_33;
  do
  {
    const unsigned char *ref = op;
    unsigned int len = ctrl >> 5;
    unsigned int ofs = (ctrl & (unsigned int)31) << 8;
    if(ctrl >= 32u)
    {
      unsigned char code;
      len = len - 1u;
      ref = ref - (signed long int)ofs;
      if(len == 6u)
        do
        {
          tmp_post_2 = ip;
          ip = ip + 1l;
          code = *tmp_post_2;
          len = len + (unsigned int)code;
        }
        while((signed int)code == 255);

      tmp_post_3 = ip;
      ip = ip + 1l;
      code = *tmp_post_3;
      ref = ref - (signed long int)code;
      if((signed int)code == 255)
      {
        if(ofs == 7936u)
        {
          tmp_post_4 = ip;
          ip = ip + 1l;
          ofs = (unsigned int)((signed int)*tmp_post_4 << 8);
          tmp_post_5 = ip;
          ip = ip + 1l;
          ofs = ofs + (unsigned int)*tmp_post_5;
          ref = (op - (signed long int)ofs) - (signed long int)8191;
        }

      }

      if(!(op_limit >= op + (signed long int)len + 3l))
        return 0;

      if(!(ref + -1l >= (unsigned char *)output))
        return 0;

      if(!(ip >= ip_limit))
      {
        tmp_post_6 = ip;
        ip = ip + 1l;
        ctrl = (unsigned int)*tmp_post_6;
      }

      else
        loop = 0;
      if(ref == op)
      {
        unsigned char b = ref[(signed long int)-1];
        tmp_post_7 = op;
        op = op + 1l;
        *tmp_post_7 = b;
        tmp_post_8 = op;
        op = op + 1l;
        *tmp_post_8 = b;
        tmp_post_9 = op;
        op = op + 1l;
        *tmp_post_9 = b;
        for( ; !(len == 0u); len = len - 1u)
        {
          tmp_post_10 = op;
          op = op + 1l;
          *tmp_post_10 = b;
        }
      }

      else
      {
        const unsigned short int *p;
        unsigned short int *q;
        ref = ref - 1l;
        tmp_post_11 = op;
        op = op + 1l;
        tmp_post_12 = ref;
        ref = ref + 1l;
        *tmp_post_11 = *tmp_post_12;
        tmp_post_13 = op;
        op = op + 1l;
        tmp_post_14 = ref;
        ref = ref + 1l;
        *tmp_post_13 = *tmp_post_14;
        tmp_post_15 = op;
        op = op + 1l;
        tmp_post_16 = ref;
        ref = ref + 1l;
        *tmp_post_15 = *tmp_post_16;
        if(!((1u & len) == 0u))
        {
          tmp_post_17 = op;
          op = op + 1l;
          tmp_post_18 = ref;
          ref = ref + 1l;
          *tmp_post_17 = *tmp_post_18;
          len = len - 1u;
        }

        q = (unsigned short int *)op;
        op = op + (signed long int)len;
        p = (const unsigned short int *)ref;
        len = len >> 1;
        for( ; len >= 5u; len = len - (unsigned int)4)
        {
          tmp_post_19 = q;
          q = q + 1l;
          tmp_post_20 = p;
          p = p + 1l;
          *tmp_post_19 = *tmp_post_20;
          tmp_post_21 = q;
          q = q + 1l;
          tmp_post_22 = p;
          p = p + 1l;
          *tmp_post_21 = *tmp_post_22;
          tmp_post_23 = q;
          q = q + 1l;
          tmp_post_24 = p;
          p = p + 1l;
          *tmp_post_23 = *tmp_post_24;
          tmp_post_25 = q;
          q = q + 1l;
          tmp_post_26 = p;
          p = p + 1l;
          *tmp_post_25 = *tmp_post_26;
        }
        for( ; !(len == 0u); len = len - 1u)
        {
          tmp_post_27 = q;
          q = q + 1l;
          tmp_post_28 = p;
          p = p + 1l;
          *tmp_post_27 = *tmp_post_28;
        }
      }
    }

    else
    {
      ctrl = ctrl + 1u;
      if(!(op_limit >= op + (signed long int)ctrl))
        return 0;

      if(!(ip_limit >= ip + (signed long int)ctrl))
        return 0;

      tmp_post_29 = op;
      op = op + 1l;
      tmp_post_30 = ip;
      ip = ip + 1l;
      *tmp_post_29 = *tmp_post_30;
      ctrl = ctrl - 1u;
      for( ; !(ctrl == 0u); ctrl = ctrl - 1u)
      {
        tmp_post_31 = op;
        op = op + 1l;
        tmp_post_32 = ip;
        ip = ip + 1l;
        *tmp_post_31 = *tmp_post_32;
      }
      loop = (signed int)(signed long int)(ip < ip_limit);
      if(!(loop == 0))
      {
        tmp_post_33 = ip;
        ip = ip + 1l;
        ctrl = (unsigned int)*tmp_post_33;
      }

    }
  }
  while(!((signed long int)loop == 0l));
  return (signed int)(op - (unsigned char *)output);
}

// fastlz_compress
// file ./../../src/helpers/fst/fastlz.c line 126
signed int fastlz_compress(const void *input, signed int length, void *output)
{
  signed int return_value_fastlz1_compress_1;
  if(!(length >= 65536))
  {
    return_value_fastlz1_compress_1=fastlz1_compress(input, length, output);
    return return_value_fastlz1_compress_1;
  }

  else
  {
    signed int return_value_fastlz2_compress_2;
    return_value_fastlz2_compress_2=fastlz2_compress(input, length, output);
    return return_value_fastlz2_compress_2;
  }
}

// fastlz_compress_level
// file ./../../src/helpers/fst/fastlz.c line 150
signed int fastlz_compress_level(signed int level, const void *input, signed int length, void *output)
{
  signed int return_value_fastlz1_compress_1;
  signed int return_value_fastlz2_compress_2;
  if(level == 1)
  {
    return_value_fastlz1_compress_1=fastlz1_compress(input, length, output);
    return return_value_fastlz1_compress_1;
  }

  else
    if(level == 2)
    {
      return_value_fastlz2_compress_2=fastlz2_compress(input, length, output);
      return return_value_fastlz2_compress_2;
    }

    else
      return 0;
}

// fastlz_decompress
// file ./../../src/helpers/fst/fastlz.c line 136
signed int fastlz_decompress(const void *input, signed int length, void *output, signed int maxout)
{
  signed int level = ((signed int)*((const unsigned char *)input) >> 5) + 1;
  signed int return_value_fastlz1_decompress_1;
  signed int return_value_fastlz2_decompress_2;
  if(level == 1)
  {
    return_value_fastlz1_decompress_1=fastlz1_decompress(input, length, output, maxout);
    return return_value_fastlz1_decompress_1;
  }

  else
    if(level == 2)
    {
      return_value_fastlz2_decompress_2=fastlz2_decompress(input, length, output, maxout);
      return return_value_fastlz2_decompress_2;
    }

    else
      return 0;
}

// fgetmalloc
// file fgetdynamic.c line 31
char * fgetmalloc(struct _IO_FILE *handle)
{
  char *pnt;
  char *pnt2;
  struct alloc_bytechain *bytechain_root = (struct alloc_bytechain *)(void *)0;
  struct alloc_bytechain *bytechain_current = (struct alloc_bytechain *)(void *)0;
  signed int ch;
  fgetmalloc_len = 0;
  do
  {
    ch=fgetc(handle);
    if(ch == 0x00 || ch == 10 || ch == 13 || ch == -1)
      break;

    fgetmalloc_len = fgetmalloc_len + 1;
    if(!(bytechain_current == ((struct alloc_bytechain *)NULL)))
    {
      void *return_value___builtin_alloca_1;
      return_value___builtin_alloca_1=__builtin_alloca(sizeof(struct alloc_bytechain) /*16ul*/ );
      bytechain_current->next = (struct alloc_bytechain *)return_value___builtin_alloca_1;
      bytechain_current = bytechain_current->next;
      bytechain_current->val = (char)ch;
      bytechain_current->next = (struct alloc_bytechain *)(void *)0;
    }

    else
    {
      void *return_value___builtin_alloca_2;
      return_value___builtin_alloca_2=__builtin_alloca(sizeof(struct alloc_bytechain) /*16ul*/ );
      bytechain_current = (struct alloc_bytechain *)return_value___builtin_alloca_2;
      bytechain_root = bytechain_current;
      bytechain_current->val = (char)ch;
      bytechain_current->next = (struct alloc_bytechain *)(void *)0;
    }
  }
  while((_Bool)1);
  char *tmp_post_4;
  if(fgetmalloc_len == 0)
    return (char *)(void *)0;

  else
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)(fgetmalloc_len + 1));
    pnt2 = (char *)return_value_malloc_3;
    pnt = pnt2;
    for( ; !(bytechain_root == ((struct alloc_bytechain *)NULL)); bytechain_root = bytechain_root->next)
    {
      tmp_post_4 = pnt2;
      pnt2 = pnt2 + 1l;
      *tmp_post_4 = bytechain_root->val;
    }
    *pnt2 = (char)0;
    return pnt;
  }
}

// find_edit_cb
// file logfile.c line 473
static signed int find_edit_cb(struct _GtkWidget *widget, struct _GdkEventKey *ev, void **data)
{
  (void)data;
  _Bool tmp_if_expr_3;
  if(ev->keyval == 65293u)
  {
    const char *t;
    unsigned long int return_value_gtk_entry_get_type_1;
    return_value_gtk_entry_get_type_1=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_entry_get_type_1);
    t=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast_2);
    if(!(search_string == ((char *)NULL)))
    {
      free((void *)search_string);
      search_string = (char *)(void *)0;
    }

    if(t == ((const char *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*t == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_3)
      search_string=strdup(t);

    search_forward((struct _GtkWidget *)(void *)0, (void *)0);
  }

  return 0;
}

// forward_chars_with_skipping
// file logfile.c line 174
static void forward_chars_with_skipping(struct _GtkTextIter *iter, signed int count)
{
  signed int i;
  do
    if(!(count >= 0))
    {
      g_return_if_fail_warning((char *)0, (const char *)"forward_chars_with_skipping", "count >= 0");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  i = count;
  while(i >= 1)
  {
    signed int ignored = 0;
    unsigned int return_value_gtk_text_iter_get_char_1;
    return_value_gtk_text_iter_get_char_1=gtk_text_iter_get_char(iter);
    if(return_value_gtk_text_iter_get_char_1 == 65532u)
      ignored = (signed int)!(0 != 0);

    gtk_text_iter_forward_char(iter);
    if(ignored == 0)
      i = i - 1;

  }

__CPROVER_DUMP_L7:
  ;
}

// fstCopyVarint32ToLeft
// file ./../../src/helpers/fst/fstapi.c line 458
static unsigned char * fstCopyVarint32ToLeft(unsigned char *pnt, unsigned int v)
{
  unsigned char *spnt;
  unsigned int nxt = v;
  signed int cnt = 1;
  signed int i;
  do
  {
    nxt = nxt >> 7;
    if(nxt == 0u)
      break;

    cnt = cnt + 1;
  }
  while((_Bool)1);
  pnt = pnt - (signed long int)cnt;
  spnt = pnt;
  cnt = cnt - 1;
  i = 0;
  unsigned char *tmp_post_1;
  for( ; !(i >= cnt); i = i + 1)
  {
    nxt = v >> 7;
    tmp_post_1 = spnt;
    spnt = spnt + 1l;
    *tmp_post_1 = (unsigned char)((signed int)(unsigned char)v | 0x80);
    v = nxt;
  }
  *spnt = (unsigned char)v;
  return pnt;
}

// fstCopyVarint64ToRight
// file ./../../src/helpers/fst/fstapi.c line 486
static unsigned char * fstCopyVarint64ToRight(unsigned char *pnt, unsigned long int v)
{
  unsigned long int nxt;
  unsigned char *tmp_post_1;
  do
  {
    nxt = v >> 7;
    if(nxt == 0ul)
      break;

    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = (unsigned char)((signed int)(unsigned char)v | 0x80);
    v = nxt;
  }
  while((_Bool)1);
  unsigned char *tmp_post_2 = pnt;
  pnt = pnt + 1l;
  *tmp_post_2 = (unsigned char)v;
  return pnt;
}

// fstDestroyMmaps
// file ./../../src/helpers/fst/fstapi.c line 981
static void fstDestroyMmaps(struct fstWriterContext *xc, signed int is_closing)
{
  (void)is_closing;
  if(!(xc->valpos_mem == ((unsigned int *)NULL)))
    munmap((void *)xc->valpos_mem, (unsigned long int)(xc->maxhandle * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ );

  xc->valpos_mem = (unsigned int *)(void *)0;
  if(!(xc->curval_mem == ((unsigned char *)NULL)))
    munmap((void *)xc->curval_mem, (unsigned long int)xc->maxvalpos);

  xc->curval_mem = (unsigned char *)(void *)0;
}

// fstDetermineBreakSize
// file ./../../src/helpers/fst/fstapi.c line 1018
static void fstDetermineBreakSize(struct fstWriterContext *xc)
{
  signed int was_set = 0;
  struct _IO_FILE *f;
  f=fopen("/proc/meminfo", "rb");
  signed int return_value_feof_1;
  if(!(f == ((struct _IO_FILE *)NULL)))
  {
    char buf[257l];
    char *s;
    do
    {
      return_value_feof_1=feof(f);
      if(!(return_value_feof_1 == 0))
        break;

      buf[(signed long int)0] = (char)0;
      s=fgets(buf, 256, f);
      if(!(s == ((char *)NULL)))
      {
        if(!(*s == 0))
        {
          signed int return_value_strncmp_3;
          return_value_strncmp_3=strncmp(s, "MemTotal:", (unsigned long int)9);
          if(return_value_strncmp_3 == 0)
          {
            unsigned long int v;
            signed long int return_value_atol_2;
            return_value_atol_2=atol(s + (signed long int)10);
            v = (unsigned long int)return_value_atol_2;
            v = v * (unsigned long int)1024;
            v = v / (unsigned long int)8;
            if(v >= 134217729ul)
            {
              if(v >= 2147483649ul)
                v = 1UL << 31;

              xc->fst_huge_break_size = v;
              was_set = 1;
              break;
            }

          }

        }

      }

    }
    while((_Bool)1);
    fclose(f);
  }

  if(was_set == 0)
    xc->fst_huge_break_size = 1UL << 27;

  xc->fst_orig_break_size = 1UL << 27;
  xc->fst_break_size = xc->fst_orig_break_size;
  xc->fst_orig_break_add_size = 1UL << 22;
  xc->fst_break_add_size = xc->fst_orig_break_add_size;
  xc->next_huge_break = (unsigned int)1000000;
}

// fstExtractRvatDataFromFrame
// file ./../../src/helpers/fst/fstapi.c line 5637
static char * fstExtractRvatDataFromFrame(struct fstReaderContext *xc, unsigned int facidx, char *buf)
{
  if((unsigned long int)facidx >= xc->rvat_frame_maxhandle)
    return (char *)(void *)0;

  else
  {
    if(xc->signal_lens[(signed long int)facidx] == 1u)
    {
      buf[(signed long int)0] = (char)xc->rvat_frame_data[(signed long int)xc->rvat_sig_offs[(signed long int)facidx]];
      buf[(signed long int)1] = (char)0;
    }

    else
      if(!((signed int)xc->signal_typs[(signed long int)facidx] == FST_VT_VCD_REAL))
      {
        memcpy((void *)buf, (const void *)(xc->rvat_frame_data + (signed long int)xc->rvat_sig_offs[(signed long int)facidx]), (unsigned long int)xc->signal_lens[(signed long int)facidx]);
        buf[(signed long int)xc->signal_lens[(signed long int)facidx]] = (char)0;
      }

      else
      {
        double d;
        unsigned char *clone_d = (unsigned char *)&d;
        unsigned char *srcdata = xc->rvat_frame_data + (signed long int)xc->rvat_sig_offs[(signed long int)facidx];
        if(!(xc->double_endian_match == 0u))
          memcpy((void *)clone_d, (const void *)srcdata, (unsigned long int)8);

        else
        {
          signed int j = 0;
          for( ; !(j >= 8); j = j + 1)
            clone_d[(signed long int)j] = srcdata[(signed long int)(7 - j)];
        }
        sprintf((char *)buf, "%.16g", d);
      }
    return buf;
  }
}

// fstFread
// file ./../../src/helpers/fst/fstapi.c line 260
static unsigned long int fstFread(void *buf, unsigned long int siz, unsigned long int cnt, struct _IO_FILE *fp)
{
  unsigned long int return_value_fread_1;
  return_value_fread_1=fread(buf, siz, cnt, fp);
  return return_value_fread_1;
}

// fstFtruncate
// file ./../../src/helpers/fst/fstapi.c line 270
static signed int fstFtruncate(signed int fd, signed long int length)
{
  signed int return_value_ftruncate_1;
  return_value_ftruncate_1=ftruncate(fd, length);
  return return_value_ftruncate_1;
}

// fstFwrite
// file ./../../src/helpers/fst/fstapi.c line 265
static unsigned long int fstFwrite(const void *buf, unsigned long int siz, unsigned long int cnt, struct _IO_FILE *fp)
{
  unsigned long int return_value_fwrite_1;
  return_value_fwrite_1=fwrite(buf, siz, cnt, fp);
  return return_value_fwrite_1;
}

// fstGetSVarint64
// file ./../../src/helpers/fst/fstapi.c line 635
static signed long int fstGetSVarint64(unsigned char *mem, signed int *skiplen)
{
  unsigned char *mem_orig = mem;
  signed long int rc = (signed long int)0;
  const signed long int one = (const signed long int)1;
  const signed int siz = (const signed int)(sizeof(signed long int) /*8ul*/  * (unsigned long int)8);
  signed int shift = 0;
  unsigned char byt;
  unsigned char *tmp_post_1;
  do
  {
    tmp_post_1 = mem;
    mem = mem + 1l;
    byt = *tmp_post_1;
    rc = rc | (signed long int)((signed int)byt & 0x7f) << shift;
    shift = shift + 7;
  }
  while(!((0x80 & (signed int)byt) == 0));
  if(!((0x40 & (signed int)byt) == 0) && !(shift >= siz))
    rc = rc | -(one << shift);

  *skiplen = (signed int)(mem - mem_orig);
  return rc;
}

// fstGetVarint32
// file ./../../src/helpers/fst/fstapi.c line 396
static unsigned int fstGetVarint32(unsigned char *mem, signed int *skiplen)
{
  unsigned char *mem_orig = mem;
  unsigned int rc = (unsigned int)0;
  for( ; !((0x80 & (signed int)*mem) == 0); mem = mem + 1l)
    ;
  *skiplen = (signed int)((mem - mem_orig) + (signed long int)1);
  do
  {
    rc = rc << 7;
    rc = rc | (unsigned int)((signed int)*mem & 0x7f);
    if(mem == mem_orig)
      break;

    mem = mem - 1l;
  }
  while((_Bool)1);
  return rc;
}

// fstGetVarint32Length
// file ./../../src/helpers/fst/fstapi.c line 421
static unsigned int fstGetVarint32Length(unsigned char *mem)
{
  unsigned char *mem_orig = mem;
  for( ; !((0x80 & (signed int)*mem) == 0); mem = mem + 1l)
    ;
  return (unsigned int)((mem - mem_orig) + (signed long int)1);
}

// fstGetVarint32NoSkip
// file ./../../src/helpers/fst/fstapi.c line 434
static unsigned int fstGetVarint32NoSkip(unsigned char *mem)
{
  unsigned char *mem_orig = mem;
  unsigned int rc = (unsigned int)0;
  for( ; !((0x80 & (signed int)*mem) == 0); mem = mem + 1l)
    ;
  do
  {
    rc = rc << 7;
    rc = rc | (unsigned int)((signed int)*mem & 0x7f);
    if(mem == mem_orig)
      break;

    mem = mem - 1l;
  }
  while((_Bool)1);
  return rc;
}

// fstGetVarint64
// file ./../../src/helpers/fst/fstapi.c line 501
static unsigned long int fstGetVarint64(unsigned char *mem, signed int *skiplen)
{
  unsigned char *mem_orig = mem;
  unsigned long int rc = (unsigned long int)0;
  for( ; !((0x80 & (signed int)*mem) == 0); mem = mem + 1l)
    ;
  *skiplen = (signed int)((mem - mem_orig) + (signed long int)1);
  do
  {
    rc = rc << 7;
    rc = rc | (unsigned long int)((signed int)*mem & 0x7f);
    if(mem == mem_orig)
      break;

    mem = mem - 1l;
  }
  while((_Bool)1);
  return rc;
}

// fstReaderClose
// file ./../../src/helpers/fst/fstapi.c line 4608
void fstReaderClose(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    fstReaderDeallocateScopeData(xc);
    fstReaderDeallocateRvatData((void *)xc);
    free((void *)xc->rvat_sig_offs);
    xc->rvat_sig_offs = (unsigned int *)(void *)0;
    free((void *)xc->process_mask);
    xc->process_mask = (unsigned char *)(void *)0;
    free((void *)xc->blackout_times);
    xc->blackout_times = (unsigned long int *)(void *)0;
    free((void *)xc->blackout_activity);
    xc->blackout_activity = (unsigned char *)(void *)0;
    free((void *)xc->temp_signal_value_buf);
    xc->temp_signal_value_buf = (unsigned char *)(void *)0;
    free((void *)xc->signal_typs);
    xc->signal_typs = (unsigned char *)(void *)0;
    free((void *)xc->signal_lens);
    xc->signal_lens = (unsigned int *)(void *)0;
    free((void *)xc->filename);
    xc->filename = (char *)(void *)0;
    if(!(xc->fh == ((struct _IO_FILE *)NULL)))
      tmpfile_close(&xc->fh, &xc->fh_nam);

    if(!(xc->f == ((struct _IO_FILE *)NULL)))
    {
      tmpfile_close(&xc->f, &xc->f_nam);
      if(!(xc->filename_unpacked == ((char *)NULL)))
      {
        unlink(xc->filename_unpacked);
        free((void *)xc->filename_unpacked);
      }

    }

    free((void *)xc);
  }

}

// fstReaderClrFacProcessMask
// file ./../../src/helpers/fst/fstapi.c line 3343
void fstReaderClrFacProcessMask(void *ctx, unsigned int facidx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    facidx = facidx - 1u;
    if(!(facidx >= xc->maxhandle))
    {
      signed int idx = (signed int)(facidx / (unsigned int)8);
      signed int bitpos = (signed int)(facidx & (unsigned int)7);
      xc->process_mask[(signed long int)idx] = xc->process_mask[(signed long int)idx] & (unsigned char)~(1 << bitpos);
    }

  }

}

// fstReaderClrFacProcessMaskAll
// file ./../../src/helpers/fst/fstapi.c line 3372
void fstReaderClrFacProcessMaskAll(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    memset((void *)xc->process_mask, 0x00, (unsigned long int)((xc->maxhandle + (unsigned int)7) / (unsigned int)8));

}

// fstReaderDeallocateRvatData
// file ./../../src/helpers/fst/fstapi.c line 4592
static void fstReaderDeallocateRvatData(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    free((void *)xc->rvat_chain_mem);
    xc->rvat_chain_mem = (unsigned char *)(void *)0;
    free((void *)xc->rvat_frame_data);
    xc->rvat_frame_data = (unsigned char *)(void *)0;
    free((void *)xc->rvat_time_table);
    xc->rvat_time_table = (unsigned long int *)(void *)0;
    free((void *)xc->rvat_chain_table);
    xc->rvat_chain_table = (signed long int *)(void *)0;
    free((void *)xc->rvat_chain_table_lengths);
    xc->rvat_chain_table_lengths = (unsigned int *)(void *)0;
    xc->rvat_data_valid = (unsigned int)0;
  }

}

// fstReaderDeallocateScopeData
// file ./../../src/helpers/fst/fstapi.c line 3167
static void fstReaderDeallocateScopeData(struct fstReaderContext *xc)
{
  struct fstCurrHier *chp;
  free((void *)xc->curr_flat_hier_nam);
  xc->curr_flat_hier_nam = (char *)(void *)0;
  for( ; !(xc->curr_hier == ((struct fstCurrHier *)NULL)); xc->curr_hier = chp)
  {
    chp = xc->curr_hier->prev;
    free((void *)xc->curr_hier);
  }
}

// fstReaderFseeko
// file ./../../src/helpers/fst/fstapi.c line 3112
signed int fstReaderFseeko(struct fstReaderContext *xc, struct _IO_FILE *stream, signed long int offset, signed int whence)
{
  signed int rc;
  rc=fseeko(stream, offset, whence);
  if(!(rc >= 0))
    xc->fseek_failed = (unsigned int)1;

  return rc;
}

// fstReaderGetAliasCount
// file ./../../src/helpers/fst/fstapi.c line 3435
unsigned long int fstReaderGetAliasCount(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->num_alias;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetCurrentFlatScope
// file ./../../src/helpers/fst/fstapi.h line 373
const char * fstReaderGetCurrentFlatScope(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  char *tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    if(!(xc->curr_flat_hier_nam == ((char *)NULL)))
      tmp_if_expr_1 = xc->curr_flat_hier_nam;

    else
      tmp_if_expr_1 = "";
    return tmp_if_expr_1;
  }

  else
    return (const char *)(void *)0;
}

// fstReaderGetCurrentScopeLen
// file ./../../src/helpers/fst/fstapi.c line 3278
signed int fstReaderGetCurrentScopeLen(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    if(xc->curr_hier == ((struct fstCurrHier *)NULL))
      goto __CPROVER_DUMP_L1;

    return xc->curr_hier->len;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// fstReaderGetCurrentScopeUserInfo
// file ./../../src/helpers/fst/fstapi.c line 3195
void * fstReaderGetCurrentScopeUserInfo(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  void *tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    if(!(xc->curr_hier == ((struct fstCurrHier *)NULL)))
      tmp_if_expr_1 = xc->curr_hier->user_info;

    else
      tmp_if_expr_1 = (void *)0;
    return tmp_if_expr_1;
  }

  else
    return (void *)0;
}

// fstReaderGetDateString
// file ./../../src/helpers/fst/fstapi.c line 3463
const char * fstReaderGetDateString(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  char *tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->date;

  else
    tmp_if_expr_1 = (char *)(void *)0;
  return tmp_if_expr_1;
}

// fstReaderGetDoubleEndianMatchState
// file ./../../src/helpers/fst/fstapi.c line 3449
signed int fstReaderGetDoubleEndianMatchState(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = (signed int)xc->double_endian_match;

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// fstReaderGetDumpActivityChangeTime
// file ./../../src/helpers/fst/fstapi.c line 3491
unsigned long int fstReaderGetDumpActivityChangeTime(void *ctx, unsigned int idx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  _Bool tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = idx < xc->num_blackouts ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = xc->blackout_times != ((unsigned long int *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return xc->blackout_times[(signed long int)idx];

  else
    return (unsigned long int)0;
}

// fstReaderGetDumpActivityChangeValue
// file ./../../src/helpers/fst/fstapi.c line 3506
unsigned char fstReaderGetDumpActivityChangeValue(void *ctx, unsigned int idx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  _Bool tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = idx < xc->num_blackouts ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = xc->blackout_activity != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return xc->blackout_activity[(signed long int)idx];

  else
    return (unsigned char)0;
}

// fstReaderGetEndTime
// file ./../../src/helpers/fst/fstapi.c line 3400
unsigned long int fstReaderGetEndTime(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->end_time;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetFacProcessMask
// file ./../../src/helpers/fst/fstapi.c line 3306
signed int fstReaderGetFacProcessMask(void *ctx, unsigned int facidx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    facidx = facidx - 1u;
    if(!(facidx >= xc->maxhandle))
    {
      signed int process_idx = (signed int)(facidx / (unsigned int)8);
      signed int process_bit = (signed int)(facidx & (unsigned int)7);
      return (signed int)(((signed int)xc->process_mask[(signed long int)process_idx] & 1 << process_bit) != 0);
    }

  }

  return 0;
}

// fstReaderGetFileType
// file ./../../src/helpers/fst/fstapi.c line 3470
signed int fstReaderGetFileType(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = (signed int)xc->filetype;

  else
    tmp_if_expr_1 = FST_FT_VERILOG;
  return tmp_if_expr_1;
}

// fstReaderGetFseekFailed
// file ./../../src/helpers/fst/fstapi.c line 3291
signed int fstReaderGetFseekFailed(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    return (signed int)((signed int)xc->fseek_failed != 0);

  else
    return 0;
}

// fstReaderGetMaxHandle
// file ./../../src/helpers/fst/fstapi.c line 3428
unsigned int fstReaderGetMaxHandle(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->maxhandle;

  else
    tmp_if_expr_1 = (unsigned int)0;
  return tmp_if_expr_1;
}

// fstReaderGetMemoryUsedByWriter
// file ./../../src/helpers/fst/fstapi.c line 3407
unsigned long int fstReaderGetMemoryUsedByWriter(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->mem_used_by_writer;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetNumberDumpActivityChanges
// file ./../../src/helpers/fst/fstapi.c line 3484
unsigned int fstReaderGetNumberDumpActivityChanges(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->num_blackouts;

  else
    tmp_if_expr_1 = (unsigned int)0;
  return tmp_if_expr_1;
}

// fstReaderGetScopeCount
// file ./../../src/helpers/fst/fstapi.c line 3414
unsigned long int fstReaderGetScopeCount(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->scope_count;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetStartTime
// file ./../../src/helpers/fst/fstapi.c line 3393
unsigned long int fstReaderGetStartTime(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->start_time;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetTimescale
// file ./../../src/helpers/fst/fstapi.c line 3386
signed char fstReaderGetTimescale(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = (signed int)xc->timescale;

  else
    tmp_if_expr_1 = 0;
  return (signed char)tmp_if_expr_1;
}

// fstReaderGetTimezero
// file ./../../src/helpers/fst/fstapi.c line 3477
signed long int fstReaderGetTimezero(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->timezero;

  else
    tmp_if_expr_1 = (signed long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetValueChangeSectionCount
// file ./../../src/helpers/fst/fstapi.c line 3442
unsigned long int fstReaderGetValueChangeSectionCount(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->vc_section_count;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetValueFromHandleAtTime
// file ./../../src/helpers/fst/fstapi.h line 392
char * fstReaderGetValueFromHandleAtTime(void *ctx, unsigned long int tim, unsigned int facidx, char *buf)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed long int blkpos = (signed long int)0;
  signed long int prev_blkpos;
  unsigned long int beg_tim;
  unsigned long int end_tim;
  unsigned long int beg_tim2;
  unsigned long int end_tim2;
  signed int sectype;
  unsigned int secnum = (unsigned int)0;
  unsigned long int seclen;
  unsigned long int tsec_uclen = (unsigned long int)0;
  unsigned long int tsec_clen = (unsigned long int)0;
  unsigned long int tsec_nitems;
  unsigned long int frame_uclen;
  unsigned long int frame_clen;
  signed long int indx_pntr;
  signed long int indx_pos;
  signed long int chain_clen;
  unsigned char *chain_cmem;
  unsigned char *pnt;
  unsigned int idx;
  unsigned int pidx = (unsigned int)0;
  unsigned int i;
  unsigned long int pval;
  _Bool tmp_if_expr_1;
  if(xc == ((struct fstReaderContext *)NULL) || facidx == 0u)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = facidx > xc->maxhandle ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(buf == ((char *)NULL) || tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(xc->signal_lens[(signed long int)(facidx - (unsigned int)1)] != 0u) ? (_Bool)1 : (_Bool)0;
  unsigned int tmp_post_15;
  unsigned int tmp_post_16;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_23;
  if(tmp_if_expr_2)
    return (char *)(void *)0;

  else
  {
    if(xc->rvat_sig_offs == ((unsigned int *)NULL))
    {
      unsigned int cur_offs = (unsigned int)0;
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)xc->maxhandle, sizeof(unsigned int) /*4ul*/ );
      xc->rvat_sig_offs = (unsigned int *)return_value_calloc_3;
      i = (unsigned int)0;
      for( ; !(i >= xc->maxhandle); i = i + 1u)
      {
        xc->rvat_sig_offs[(signed long int)i] = cur_offs;
        cur_offs = cur_offs + xc->signal_lens[(signed long int)i];
      }
    }

    if(!(xc->rvat_data_valid == 0u))
    {
      if(tim >= xc->rvat_beg_tim)
      {
        if(xc->rvat_end_tim >= tim)
          goto process_value;

      }

      fstReaderDeallocateRvatData((void *)xc);
    }

    xc->rvat_chain_pos_valid = (unsigned int)0;
    do
    {
      prev_blkpos = blkpos;
      fstReaderFseeko(xc, xc->f, prev_blkpos, 0);
      sectype=fgetc(xc->f);
      seclen=fstReaderUint64(xc->f);
      if(sectype == 255 || sectype == -1 || seclen == 0ul)
        return (char *)(void *)0;

      blkpos = blkpos + 1l;
      if(!(sectype == 1) && !(sectype == 5) && !(sectype == 8))
        blkpos = blkpos + (signed long int)seclen;

      else
      {
        beg_tim=fstReaderUint64(xc->f);
        end_tim=fstReaderUint64(xc->f);
        if(end_tim >= tim && tim >= beg_tim)
        {
          if(tim == end_tim)
          {
            if(!(tim == xc->end_time))
            {
              signed long int cached_pos;
              cached_pos=ftello(xc->f);
              fstReaderFseeko(xc, xc->f, blkpos, 0);
              sectype=fgetc(xc->f);
              seclen=fstReaderUint64(xc->f);
              beg_tim2=fstReaderUint64(xc->f);
              end_tim2=fstReaderUint64(xc->f);
              if(seclen == 0ul || !(sectype == 1) && !(sectype == 5) && !(sectype == 8) || !(beg_tim2 == tim))
              {
                blkpos = prev_blkpos;
                break;
              }

              beg_tim = beg_tim2;
              end_tim = end_tim2;
              fstReaderFseeko(xc, xc->f, cached_pos, 0);
            }

          }

          break;
        }

        blkpos = blkpos + (signed long int)seclen;
        secnum = secnum + 1u;
      }
    }
    while((_Bool)1);
    xc->rvat_beg_tim = beg_tim;
    xc->rvat_end_tim = end_tim;
    fstReaderUint64(xc->f);
    unsigned char *ucdata;
    unsigned char *cdata;
    unsigned long int destlen;
    unsigned long int sourcelen;
    signed int rc;
    unsigned char *tpnt;
    unsigned long int tpval;
    unsigned int ti;
    fstReaderFseeko(xc, xc->f, (signed long int)(((unsigned long int)blkpos + seclen) - (unsigned long int)24), 0);
    tsec_uclen=fstReaderUint64(xc->f);
    tsec_clen=fstReaderUint64(xc->f);
    tsec_nitems=fstReaderUint64(xc->f);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(tsec_uclen);
    ucdata = (unsigned char *)return_value_malloc_4;
    destlen = tsec_uclen;
    sourcelen = tsec_clen;
    fstReaderFseeko(xc, xc->f, (signed long int)-24 - (signed long int)tsec_clen, 1);
    if(!(tsec_uclen == tsec_clen))
    {
      void *return_value_malloc_5;
      return_value_malloc_5=malloc(tsec_clen);
      cdata = (unsigned char *)return_value_malloc_5;
      fstFread((void *)cdata, tsec_clen, (unsigned long int)1, xc->f);
      rc=uncompress(ucdata, &destlen, cdata, sourcelen);
      if(!(rc == 0))
      {
        printf("tsec uncompress rc = %d\n", rc);
        exit(255);
      }

      free((void *)cdata);
    }

    else
      fstFread((void *)ucdata, tsec_uclen, (unsigned long int)1, xc->f);
    void *return_value_calloc_6;
    return_value_calloc_6=calloc(tsec_nitems, sizeof(unsigned long int) /*8ul*/ );
    xc->rvat_time_table = (unsigned long int *)return_value_calloc_6;
    tpnt = ucdata;
    tpval = (unsigned long int)0;
    ti = (unsigned int)0;
    for( ; !((unsigned long int)ti >= tsec_nitems); ti = ti + 1u)
    {
      signed int fstReaderGetValueFromHandleAtTime__1__5__3__1__skiplen;
      unsigned long int fstReaderGetValueFromHandleAtTime__1__5__3__1__val;
      fstReaderGetValueFromHandleAtTime__1__5__3__1__val=fstGetVarint64(tpnt, &fstReaderGetValueFromHandleAtTime__1__5__3__1__skiplen);
      xc->rvat_time_table[(signed long int)ti] = tpval + fstReaderGetValueFromHandleAtTime__1__5__3__1__val;
      tpval = xc->rvat_time_table[(signed long int)ti];
      tpnt = tpnt + (signed long int)fstReaderGetValueFromHandleAtTime__1__5__3__1__skiplen;
    }
    free((void *)ucdata);
    fstReaderFseeko(xc, xc->f, blkpos + (signed long int)32, 0);
    frame_uclen=fstReaderVarint64(xc->f);
    frame_clen=fstReaderVarint64(xc->f);
    xc->rvat_frame_maxhandle=fstReaderVarint64(xc->f);
    void *return_value_malloc_7;
    return_value_malloc_7=malloc(frame_uclen);
    xc->rvat_frame_data = (unsigned char *)return_value_malloc_7;
    if(frame_uclen == frame_clen)
      fstFread((void *)xc->rvat_frame_data, frame_uclen, (unsigned long int)1, xc->f);

    else
    {
      unsigned char *mc;
      void *return_value_malloc_8;
      return_value_malloc_8=malloc(frame_clen);
      mc = (unsigned char *)return_value_malloc_8;
      signed int fstReaderGetValueFromHandleAtTime__1__7__rc;
      unsigned long int fstReaderGetValueFromHandleAtTime__1__7__destlen = frame_uclen;
      unsigned long int fstReaderGetValueFromHandleAtTime__1__7__sourcelen = frame_clen;
      fstFread((void *)mc, fstReaderGetValueFromHandleAtTime__1__7__sourcelen, (unsigned long int)1, xc->f);
      fstReaderGetValueFromHandleAtTime__1__7__rc=uncompress(xc->rvat_frame_data, &fstReaderGetValueFromHandleAtTime__1__7__destlen, mc, fstReaderGetValueFromHandleAtTime__1__7__sourcelen);
      if(!(fstReaderGetValueFromHandleAtTime__1__7__rc == 0))
      {
        printf("decompress rc: %d\n", fstReaderGetValueFromHandleAtTime__1__7__rc);
        exit(255);
      }

      free((void *)mc);
    }
    xc->rvat_vc_maxhandle=fstReaderVarint64(xc->f);
    xc->rvat_vc_start=ftello(xc->f);
    indx_pntr = (signed long int)(((((unsigned long int)blkpos + seclen) - (unsigned long int)24) - tsec_clen) - (unsigned long int)8);
    fstReaderFseeko(xc, xc->f, indx_pntr, 0);
    unsigned long int return_value_fstReaderUint64_9;
    return_value_fstReaderUint64_9=fstReaderUint64(xc->f);
    chain_clen = (signed long int)return_value_fstReaderUint64_9;
    indx_pos = indx_pntr - chain_clen;
    void *return_value_malloc_10;
    return_value_malloc_10=malloc((unsigned long int)chain_clen);
    chain_cmem = (unsigned char *)return_value_malloc_10;
    fstReaderFseeko(xc, xc->f, indx_pos, 0);
    fstFread((void *)chain_cmem, (unsigned long int)chain_clen, (unsigned long int)1, xc->f);
    void *return_value_calloc_11;
    return_value_calloc_11=calloc(xc->rvat_vc_maxhandle + (unsigned long int)1, sizeof(signed long int) /*8ul*/ );
    xc->rvat_chain_table = (signed long int *)return_value_calloc_11;
    void *return_value_calloc_12;
    return_value_calloc_12=calloc(xc->rvat_vc_maxhandle + (unsigned long int)1, sizeof(unsigned int) /*4ul*/ );
    xc->rvat_chain_table_lengths = (unsigned int *)return_value_calloc_12;
    pnt = chain_cmem;
    idx = (unsigned int)0;
    pval = (unsigned long int)0;
    do
    {
      signed int skiplen;
      unsigned long int val;
      unsigned int return_value_fstGetVarint32_13;
      return_value_fstGetVarint32_13=fstGetVarint32(pnt, &skiplen);
      val = (unsigned long int)return_value_fstGetVarint32_13;
      if(val == 0ul)
      {
        pnt = pnt + (signed long int)skiplen;
        unsigned int return_value_fstGetVarint32_14;
        return_value_fstGetVarint32_14=fstGetVarint32(pnt, &skiplen);
        val = (unsigned long int)return_value_fstGetVarint32_14;
        xc->rvat_chain_table[(signed long int)idx] = (signed long int)0;
        xc->rvat_chain_table_lengths[(signed long int)idx] = (unsigned int)-val;
        idx = idx + 1u;
      }

      else
        if(!((1ul & val) == 0ul))
        {
          xc->rvat_chain_table[(signed long int)idx] = (signed long int)(pval + (val >> 1));
          pval = (unsigned long int)xc->rvat_chain_table[(signed long int)idx];
          if(!(idx == 0u))
            xc->rvat_chain_table_lengths[(signed long int)pidx] = (unsigned int)(pval - (unsigned long int)xc->rvat_chain_table[(signed long int)pidx]);

          tmp_post_15 = idx;
          idx = idx + 1u;
          pidx = tmp_post_15;
        }

        else
        {
          unsigned int loopcnt = (unsigned int)(val >> 1);
          i = (unsigned int)0;
          for( ; !(i >= loopcnt); i = i + 1u)
          {
            tmp_post_16 = idx;
            idx = idx + 1u;
            xc->rvat_chain_table[(signed long int)tmp_post_16] = (signed long int)0;
          }
        }
      pnt = pnt + (signed long int)skiplen;
    }
    while(!(pnt == chain_cmem + chain_clen));
    free((void *)chain_cmem);
    xc->rvat_chain_table[(signed long int)idx] = indx_pos - xc->rvat_vc_start;
    xc->rvat_chain_table_lengths[(signed long int)pidx] = (unsigned int)(xc->rvat_chain_table[(signed long int)idx] - xc->rvat_chain_table[(signed long int)pidx]);
    i = (unsigned int)0;
    for( ; !(i >= idx); i = i + 1u)
    {
      signed int v32 = (signed int)xc->rvat_chain_table_lengths[(signed long int)i];
      if(!(v32 >= 0))
      {
        if(xc->rvat_chain_table[(signed long int)i] == 0l)
        {
          v32 = -v32;
          v32 = v32 - 1;
          if(!((unsigned int)v32 >= i))
          {
            xc->rvat_chain_table[(signed long int)i] = xc->rvat_chain_table[(signed long int)v32];
            xc->rvat_chain_table_lengths[(signed long int)i] = xc->rvat_chain_table_lengths[(signed long int)v32];
          }

        }

      }

    }
    xc->rvat_data_valid = (unsigned int)1;

  process_value:
    ;
    if(!(xc->rvat_vc_maxhandle >= (unsigned long int)facidx))
      return (char *)(void *)0;

    else
    {
      facidx = facidx - 1u;
      if(tim == xc->rvat_beg_tim)
        tmp_if_expr_18 = !(xc->rvat_chain_table[(signed long int)facidx] != 0l) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_18 = (_Bool)0;
      if(tmp_if_expr_18)
        tmp_if_expr_19 = (_Bool)1;

      else
        tmp_if_expr_19 = !(xc->rvat_chain_table[(signed long int)facidx] != 0l) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_19)
      {
        char *return_value_fstExtractRvatDataFromFrame_17;
        return_value_fstExtractRvatDataFromFrame_17=fstExtractRvatDataFromFrame(xc, facidx, buf);
        return return_value_fstExtractRvatDataFromFrame_17;
      }

      if(!(facidx == xc->rvat_chain_facidx))
      {
        if(!(xc->rvat_chain_mem == ((unsigned char *)NULL)))
        {
          free((void *)xc->rvat_chain_mem);
          xc->rvat_chain_mem = (unsigned char *)(void *)0;
          xc->rvat_chain_pos_valid = (unsigned int)0;
        }

      }

      if(xc->rvat_chain_mem == ((unsigned char *)NULL))
      {
        unsigned int fstReaderGetValueFromHandleAtTime__1__13__skiplen;
        fstReaderFseeko(xc, xc->f, xc->rvat_vc_start + xc->rvat_chain_table[(signed long int)facidx], 0);
        xc->rvat_chain_len=fstReaderVarint32WithSkip(xc->f, &fstReaderGetValueFromHandleAtTime__1__13__skiplen);
        if(!(xc->rvat_chain_len == 0u))
        {
          unsigned char *mu;
          void *return_value_malloc_20;
          return_value_malloc_20=malloc((unsigned long int)xc->rvat_chain_len);
          mu = (unsigned char *)return_value_malloc_20;
          unsigned char *fstReaderGetValueFromHandleAtTime__1__13__1__mc;
          void *return_value_malloc_21;
          return_value_malloc_21=malloc((unsigned long int)xc->rvat_chain_table_lengths[(signed long int)facidx]);
          fstReaderGetValueFromHandleAtTime__1__13__1__mc = (unsigned char *)return_value_malloc_21;
          unsigned long int fstReaderGetValueFromHandleAtTime__1__13__1__destlen = (unsigned long int)xc->rvat_chain_len;
          unsigned long int fstReaderGetValueFromHandleAtTime__1__13__1__sourcelen = (unsigned long int)xc->rvat_chain_table_lengths[(signed long int)facidx];
          signed int fstReaderGetValueFromHandleAtTime__1__13__1__rc;
          fstFread((void *)fstReaderGetValueFromHandleAtTime__1__13__1__mc, (unsigned long int)xc->rvat_chain_table_lengths[(signed long int)facidx], (unsigned long int)1, xc->f);
          fstReaderGetValueFromHandleAtTime__1__13__1__rc=uncompress(mu, &fstReaderGetValueFromHandleAtTime__1__13__1__destlen, fstReaderGetValueFromHandleAtTime__1__13__1__mc, fstReaderGetValueFromHandleAtTime__1__13__1__sourcelen);
          free((void *)fstReaderGetValueFromHandleAtTime__1__13__1__mc);
          if(!(fstReaderGetValueFromHandleAtTime__1__13__1__rc == 0))
          {
            printf("\tclen: %d (rc=%d)\n", (signed int)xc->rvat_chain_len, fstReaderGetValueFromHandleAtTime__1__13__1__rc);
            exit(255);
          }

          xc->rvat_chain_mem = mu;
        }

        else
        {
          signed int fstReaderGetValueFromHandleAtTime__1__13__2__destlen = (signed int)(xc->rvat_chain_table_lengths[(signed long int)facidx] - fstReaderGetValueFromHandleAtTime__1__13__skiplen);
          unsigned char *fstReaderGetValueFromHandleAtTime__1__13__2__mu;
          xc->rvat_chain_len = (unsigned int)fstReaderGetValueFromHandleAtTime__1__13__2__destlen;
          void *return_value_malloc_22;
          return_value_malloc_22=malloc((unsigned long int)xc->rvat_chain_len);
          fstReaderGetValueFromHandleAtTime__1__13__2__mu = (unsigned char *)return_value_malloc_22;
          fstFread((void *)fstReaderGetValueFromHandleAtTime__1__13__2__mu, (unsigned long int)fstReaderGetValueFromHandleAtTime__1__13__2__destlen, (unsigned long int)1, xc->f);
          xc->rvat_chain_mem = fstReaderGetValueFromHandleAtTime__1__13__2__mu;
        }
        xc->rvat_chain_facidx = facidx;
      }

      unsigned int tidx = (unsigned int)0;
      unsigned int ptidx = (unsigned int)0;
      unsigned int tdelta;
      signed int fstReaderGetValueFromHandleAtTime__1__14__skiplen;
      unsigned int iprev = xc->rvat_chain_len;
      unsigned int pvli = (unsigned int)0;
      signed int pskip = 0;
      if(!(xc->rvat_chain_pos_valid == 0u))
        tmp_if_expr_23 = tim >= xc->rvat_chain_pos_time ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_23 = (_Bool)0;
      if(tmp_if_expr_23)
      {
        i = xc->rvat_chain_pos_idx;
        tidx = xc->rvat_chain_pos_tidx;
      }

      else
      {
        i = (unsigned int)0;
        tidx = (unsigned int)0;
        xc->rvat_chain_pos_time = xc->rvat_beg_tim;
      }
      if(xc->signal_lens[(signed long int)facidx] == 1u)
      {
        while(!(i >= xc->rvat_chain_len))
        {
          unsigned int vli;
          vli=fstGetVarint32(xc->rvat_chain_mem + (signed long int)i, &fstReaderGetValueFromHandleAtTime__1__14__skiplen);
          unsigned int shcnt = (unsigned int)(2 << (vli & (unsigned int)1));
          tdelta = vli >> shcnt;
          if(tim >= xc->rvat_time_table[(signed long int)(tdelta + tidx)])
          {
            iprev = i;
            pvli = vli;
            ptidx = tidx;
            tidx = tidx + tdelta;
            i = i + (unsigned int)fstReaderGetValueFromHandleAtTime__1__14__skiplen;
          }

          else
            break;
        }
        if(!(iprev == xc->rvat_chain_len))
        {
          xc->rvat_chain_pos_tidx = ptidx;
          xc->rvat_chain_pos_idx = iprev;
          xc->rvat_chain_pos_time = tim;
          xc->rvat_chain_pos_valid = (unsigned int)1;
          if((1u & pvli) == 0u)
            buf[(signed long int)0] = (char)(pvli >> 1 & (unsigned int)1 | (unsigned int)48);

          else
            buf[(signed long int)0] = "xzhuwl-?"[(signed long int)(pvli >> 1 & (unsigned int)7)];
          buf[(signed long int)1] = (char)0;
          return buf;
        }

        else
        {
          char *return_value_fstExtractRvatDataFromFrame_24;
          return_value_fstExtractRvatDataFromFrame_24=fstExtractRvatDataFromFrame(xc, facidx, buf);
          return return_value_fstExtractRvatDataFromFrame_24;
        }
      }

      else
      {
        while(!(i >= xc->rvat_chain_len))
        {
          unsigned int fstReaderGetValueFromHandleAtTime__1__14__4__1__vli;
          fstReaderGetValueFromHandleAtTime__1__14__4__1__vli=fstGetVarint32(xc->rvat_chain_mem + (signed long int)i, &fstReaderGetValueFromHandleAtTime__1__14__skiplen);
          tdelta = fstReaderGetValueFromHandleAtTime__1__14__4__1__vli >> 1;
          if(tim >= xc->rvat_time_table[(signed long int)(tdelta + tidx)])
          {
            iprev = i;
            pvli = fstReaderGetValueFromHandleAtTime__1__14__4__1__vli;
            ptidx = tidx;
            pskip = fstReaderGetValueFromHandleAtTime__1__14__skiplen;
            tidx = tidx + tdelta;
            i = i + (unsigned int)fstReaderGetValueFromHandleAtTime__1__14__skiplen;
            if((1u & pvli) == 0u)
              i = i + (xc->signal_lens[(signed long int)facidx] + (unsigned int)7) / (unsigned int)8;

            else
              i = i + xc->signal_lens[(signed long int)facidx];
          }

          else
            break;
        }
        if(!(iprev == xc->rvat_chain_len))
        {
          unsigned char *vdata = xc->rvat_chain_mem + (signed long int)iprev + (signed long int)pskip;
          xc->rvat_chain_pos_tidx = ptidx;
          xc->rvat_chain_pos_idx = iprev;
          xc->rvat_chain_pos_time = tim;
          xc->rvat_chain_pos_valid = (unsigned int)1;
          if(!((signed int)xc->signal_typs[(signed long int)facidx] == FST_VT_VCD_REAL))
          {
            if((1u & pvli) == 0u)
            {
              signed int byte = 0;
              signed int bit;
              unsigned int j = (unsigned int)0;
              for( ; !(j >= xc->signal_lens[(signed long int)facidx]); j = j + 1u)
              {
                unsigned char ch;
                byte = (signed int)(j / (unsigned int)8);
                bit = (signed int)((unsigned int)7 - (j & (unsigned int)7));
                ch = (unsigned char)((signed int)vdata[(signed long int)byte] >> bit & 1 | 48);
                buf[(signed long int)j] = (char)ch;
              }
              buf[(signed long int)j] = (char)0;
              return buf;
            }

            else
            {
              memcpy((void *)buf, (const void *)vdata, (unsigned long int)xc->signal_lens[(signed long int)facidx]);
              buf[(signed long int)xc->signal_lens[(signed long int)facidx]] = (char)0;
              return buf;
            }
          }

          else
          {
            double d;
            unsigned char *clone_d = (unsigned char *)&d;
            unsigned char bufd[8l];
            unsigned char *srcdata;
            if((1u & pvli) == 0u)
            {
              signed int fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__bit;
              signed int fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__j = 0;
              for( ; !(fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__j >= 8); fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__j = fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__j + 1)
              {
                unsigned char fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__1__1__ch;
                fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__bit = 7 - (fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__j & 7);
                fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__1__1__ch = (unsigned char)((signed int)vdata[(signed long int)0] >> fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__bit & 1 | 48);
                bufd[(signed long int)fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__j] = fstReaderGetValueFromHandleAtTime__1__14__4__2__2__1__1__1__ch;
              }
              srcdata = bufd;
            }

            else
              srcdata = vdata;
            if(!(xc->double_endian_match == 0u))
              memcpy((void *)clone_d, (const void *)srcdata, (unsigned long int)8);

            else
            {
              signed int fstReaderGetValueFromHandleAtTime__1__14__4__2__2__4__j = 0;
              for( ; !(fstReaderGetValueFromHandleAtTime__1__14__4__2__2__4__j >= 8); fstReaderGetValueFromHandleAtTime__1__14__4__2__2__4__j = fstReaderGetValueFromHandleAtTime__1__14__4__2__2__4__j + 1)
                clone_d[(signed long int)fstReaderGetValueFromHandleAtTime__1__14__4__2__2__4__j] = srcdata[(signed long int)(7 - fstReaderGetValueFromHandleAtTime__1__14__4__2__2__4__j)];
            }
            sprintf(buf, "r%.16g", d);
            return buf;
          }
        }

        else
        {
          char *return_value_fstExtractRvatDataFromFrame_25;
          return_value_fstExtractRvatDataFromFrame_25=fstExtractRvatDataFromFrame(xc, facidx, buf);
          return return_value_fstExtractRvatDataFromFrame_25;
        }
      }
    }
  }
}

// fstReaderGetVarCount
// file ./../../src/helpers/fst/fstapi.h line 393
unsigned long int fstReaderGetVarCount(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->var_count;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// fstReaderGetVersionString
// file ./../../src/helpers/fst/fstapi.c line 3456
const char * fstReaderGetVersionString(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  char *tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    tmp_if_expr_1 = xc->version;

  else
    tmp_if_expr_1 = (char *)(void *)0;
  return tmp_if_expr_1;
}

// fstReaderInit
// file ./../../src/helpers/fst/fstapi.c line 4223
signed int fstReaderInit(struct fstReaderContext *xc)
{
  signed long int blkpos = (signed long int)0;
  signed long int endfile;
  unsigned long int seclen;
  signed int sectype;
  unsigned long int vc_section_count_actual = (unsigned long int)0;
  signed int hdr_incomplete = 0;
  signed int hdr_seen = 0;
  signed int gzread_pass_status = 1;
  sectype=fgetc(xc->f);
  if(sectype == 254)
  {
    struct _IO_FILE *fcomp;
    signed long int offpnt;
    signed long int uclen;
    char gz_membuf[32768l];
    void *zhandle;
    signed int zfd;
    signed int flen;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(xc->filename);
    flen = (signed int)return_value_strlen_1;
    char *hf;
    seclen=fstReaderUint64(xc->f);
    unsigned long int return_value_fstReaderUint64_2;
    return_value_fstReaderUint64_2=fstReaderUint64(xc->f);
    uclen = (signed long int)return_value_fstReaderUint64_2;
    if(seclen == 0ul)
      return 0;

    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)(flen + 16 + 32 + 1));
    hf = (char *)return_value_calloc_3;
    signed int return_value_getpid_4;
    return_value_getpid_4=getpid();
    sprintf(hf, "%s.upk_%d_%p", xc->filename, return_value_getpid_4, (void *)xc);
    fcomp=fopen(hf, "w+b");
    if(fcomp == ((struct _IO_FILE *)NULL))
    {
      fcomp=tmpfile_open(&xc->f_nam);
      free((void *)hf);
      hf = (char *)(void *)0;
      if(fcomp == ((struct _IO_FILE *)NULL))
      {
        tmpfile_close(&fcomp, &xc->f_nam);
        return 0;
      }

    }

    if(!(hf == ((char *)NULL)))
    {
      unlink(hf);
      free((void *)hf);
    }

    fstReaderFseeko(xc, xc->f, (signed long int)(1 + 8 + 8), 0);
    fflush(xc->f);
    signed int return_value_fileno_5;
    return_value_fileno_5=fileno(xc->f);
    zfd=dup(return_value_fileno_5);
    struct gzFile_s *return_value_gzdopen_6;
    return_value_gzdopen_6=gzdopen(zfd, "rb");
    zhandle = (void *)return_value_gzdopen_6;
    if(!(zhandle == NULL))
    {
      offpnt = (signed long int)0;
      for( ; !(offpnt >= uclen); offpnt = offpnt + (signed long int)32768)
      {
        unsigned long int this_len = (unsigned long int)(uclen - offpnt > (signed long int)32768 ? (signed long int)32768 : uclen - offpnt);
        unsigned long int gzreadlen;
        signed int return_value_gzread_7;
        return_value_gzread_7=gzread((struct gzFile_s *)zhandle, (void *)gz_membuf, (unsigned int)this_len);
        gzreadlen = (unsigned long int)return_value_gzread_7;
        unsigned long int fwlen;
        if(!(gzreadlen == this_len))
        {
          gzread_pass_status = 0;
          break;
        }

        fwlen=fstFwrite((const void *)gz_membuf, this_len, (unsigned long int)1, fcomp);
        if(!(fwlen == 1ul))
        {
          gzread_pass_status = 0;
          break;
        }

      }
      gzclose((struct gzFile_s *)zhandle);
    }

    else
      close(zfd);
    fflush(fcomp);
    fclose(xc->f);
    xc->f = fcomp;
  }

  _Bool tmp_if_expr_8;
  if(!(gzread_pass_status == 0))
  {
    fstReaderFseeko(xc, xc->f, (signed long int)0, 2);
    endfile=ftello(xc->f);
    while(!(blkpos >= endfile))
    {
      fstReaderFseeko(xc, xc->f, blkpos, 0);
      sectype=fgetc(xc->f);
      seclen=fstReaderUint64(xc->f);
      if(sectype == -1)
        break;

      if(seclen == 0ul && !(hdr_incomplete == 0))
        break;

      if(hdr_seen == 0 && !(sectype == 0))
        break;

      blkpos = blkpos + 1l;
      if(sectype == 0)
      {
        if(hdr_seen == 0)
        {
          signed int ch;
          double dcheck;
          xc->start_time=fstReaderUint64(xc->f);
          xc->end_time=fstReaderUint64(xc->f);
          if(xc->start_time == 0ul)
            tmp_if_expr_8 = xc->end_time == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
          hdr_incomplete = (signed int)tmp_if_expr_8;
          fstFread((void *)&dcheck, (unsigned long int)8, (unsigned long int)1, xc->f);
          xc->double_endian_match = (unsigned int)IEEE_FLOAT_EQUAL(dcheck, 2.7182818284590452354);
          if(xc->double_endian_match == 0u)
          {
            /* tag-#anon#lUN[lARR8{U8}_U8_'rvs_buf'||F64'd'|] */
union anonymous_55
{
  // rvs_buf
  unsigned char rvs_buf[8l];
  // d
  double d;
};

/* */
            ;
            union anonymous_55 vu;
            unsigned char *dcheck_alias = (unsigned char *)&dcheck;
            signed int rvs_idx = 0;
            for( ; !(rvs_idx >= 8); rvs_idx = rvs_idx + 1)
              vu.rvs_buf[(signed long int)rvs_idx] = dcheck_alias[(signed long int)(7 - rvs_idx)];
            if(IEEE_FLOAT_NOTEQUAL(vu.d, 2.7182818284590452354))
              break;

          }

          hdr_seen = 1;
          xc->mem_used_by_writer=fstReaderUint64(xc->f);
          xc->scope_count=fstReaderUint64(xc->f);
          xc->var_count=fstReaderUint64(xc->f);
          unsigned long int return_value_fstReaderUint64_9;
          return_value_fstReaderUint64_9=fstReaderUint64(xc->f);
          xc->maxhandle = (unsigned int)return_value_fstReaderUint64_9;
          xc->num_alias = xc->var_count - (unsigned long int)xc->maxhandle;
          xc->vc_section_count=fstReaderUint64(xc->f);
          ch=fgetc(xc->f);
          xc->timescale = (signed char)ch;
          fstFread((void *)xc->version, (unsigned long int)128, (unsigned long int)1, xc->f);
          xc->version[(signed long int)128] = (char)0;
          fstFread((void *)xc->date, (unsigned long int)119, (unsigned long int)1, xc->f);
          xc->date[(signed long int)119] = (char)0;
          ch=fgetc(xc->f);
          xc->filetype = (unsigned char)ch;
          unsigned long int return_value_fstReaderUint64_10;
          return_value_fstReaderUint64_10=fstReaderUint64(xc->f);
          xc->timezero = (signed long int)return_value_fstReaderUint64_10;
        }

      }

      else
        if(sectype == 1 || sectype == 5 || sectype == 8)
        {
          if(!(hdr_incomplete == 0))
          {
            unsigned long int bt;
            bt=fstReaderUint64(xc->f);
            xc->end_time=fstReaderUint64(xc->f);
            if(vc_section_count_actual == 0ul)
              xc->start_time = bt;

          }

          vc_section_count_actual = vc_section_count_actual + 1ul;
        }

        else
          if(sectype == 3)
          {
            if(hdr_incomplete == 0)
            {
              unsigned long int clen = seclen - (unsigned long int)24;
              unsigned long int fstReaderInit__1__2__1__6__1__uclen;
              fstReaderInit__1__2__1__6__1__uclen=fstReaderUint64(xc->f);
              unsigned char *ucdata;
              void *return_value_malloc_11;
              return_value_malloc_11=malloc(fstReaderInit__1__2__1__6__1__uclen);
              ucdata = (unsigned char *)return_value_malloc_11;
              unsigned char *pnt = ucdata;
              unsigned int fstReaderInit__1__2__1__6__1__i;
              xc->contains_geom_section = (unsigned int)1;
              unsigned long int return_value_fstReaderUint64_12;
              return_value_fstReaderUint64_12=fstReaderUint64(xc->f);
              xc->maxhandle = (unsigned int)return_value_fstReaderUint64_12;
              xc->longest_signal_value_len = (unsigned int)32;
              free((void *)xc->process_mask);
              void *return_value_calloc_13;
              return_value_calloc_13=calloc((unsigned long int)1, (unsigned long int)((xc->maxhandle + (unsigned int)7) / (unsigned int)8));
              xc->process_mask = (unsigned char *)return_value_calloc_13;
              if(!(clen == fstReaderInit__1__2__1__6__1__uclen))
              {
                unsigned char *cdata;
                void *return_value_malloc_14;
                return_value_malloc_14=malloc(clen);
                cdata = (unsigned char *)return_value_malloc_14;
                unsigned long int destlen = fstReaderInit__1__2__1__6__1__uclen;
                unsigned long int sourcelen = clen;
                signed int rc;
                fstFread((void *)cdata, clen, (unsigned long int)1, xc->f);
                rc=uncompress(ucdata, &destlen, cdata, sourcelen);
                if(!(rc == 0))
                {
                  printf("geom uncompress rc = %d\n", rc);
                  exit(255);
                }

                free((void *)cdata);
              }

              else
                fstFread((void *)ucdata, fstReaderInit__1__2__1__6__1__uclen, (unsigned long int)1, xc->f);
              free((void *)xc->signal_lens);
              void *return_value_malloc_15;
              return_value_malloc_15=malloc(sizeof(unsigned int) /*4ul*/  * (unsigned long int)xc->maxhandle);
              xc->signal_lens = (unsigned int *)return_value_malloc_15;
              free((void *)xc->signal_typs);
              void *return_value_malloc_16;
              return_value_malloc_16=malloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)xc->maxhandle);
              xc->signal_typs = (unsigned char *)return_value_malloc_16;
              fstReaderInit__1__2__1__6__1__i = (unsigned int)0;
              for( ; !(fstReaderInit__1__2__1__6__1__i >= xc->maxhandle); fstReaderInit__1__2__1__6__1__i = fstReaderInit__1__2__1__6__1__i + 1u)
              {
                signed int skiplen;
                unsigned long int val;
                unsigned int return_value_fstGetVarint32_17;
                return_value_fstGetVarint32_17=fstGetVarint32(pnt, &skiplen);
                val = (unsigned long int)return_value_fstGetVarint32_17;
                pnt = pnt + (signed long int)skiplen;
                if(!(val == 0ul))
                {
                  xc->signal_lens[(signed long int)fstReaderInit__1__2__1__6__1__i] = (unsigned int)(val != (unsigned long int)0xFFFFFFFF ? val : (unsigned long int)0);
                  xc->signal_typs[(signed long int)fstReaderInit__1__2__1__6__1__i] = (unsigned char)FST_VT_VCD_WIRE;
                  if(!(xc->longest_signal_value_len >= xc->signal_lens[(signed long int)fstReaderInit__1__2__1__6__1__i]))
                    xc->longest_signal_value_len = xc->signal_lens[(signed long int)fstReaderInit__1__2__1__6__1__i];

                }

                else
                {
                  xc->signal_lens[(signed long int)fstReaderInit__1__2__1__6__1__i] = (unsigned int)8;
                  xc->signal_typs[(signed long int)fstReaderInit__1__2__1__6__1__i] = (unsigned char)FST_VT_VCD_REAL;
                }
              }
              free((void *)xc->temp_signal_value_buf);
              void *return_value_malloc_18;
              return_value_malloc_18=malloc((unsigned long int)(xc->longest_signal_value_len + (unsigned int)1));
              xc->temp_signal_value_buf = (unsigned char *)return_value_malloc_18;
              free((void *)ucdata);
            }

          }

          else
            if(sectype == 4)
            {
              xc->contains_hier_section = (unsigned int)1;
              xc->hier_pos=ftello(xc->f);
            }

            else
              if(sectype == 7)
              {
                xc->contains_hier_section_lz4 = (unsigned int)1;
                xc->contains_hier_section_lz4duo = (unsigned int)1;
                xc->hier_pos=ftello(xc->f);
              }

              else
                if(sectype == 6)
                {
                  xc->contains_hier_section_lz4 = (unsigned int)1;
                  xc->hier_pos=ftello(xc->f);
                }

                else
                  if(sectype == 2)
                  {
                    unsigned int i;
                    unsigned long int cur_bl = (unsigned long int)0;
                    unsigned long int delta;
                    xc->num_blackouts=fstReaderVarint32(xc->f);
                    free((void *)xc->blackout_times);
                    void *return_value_calloc_19;
                    return_value_calloc_19=calloc((unsigned long int)xc->num_blackouts, sizeof(unsigned long int) /*8ul*/ );
                    xc->blackout_times = (unsigned long int *)return_value_calloc_19;
                    free((void *)xc->blackout_activity);
                    void *return_value_calloc_20;
                    return_value_calloc_20=calloc((unsigned long int)xc->num_blackouts, sizeof(unsigned char) /*1ul*/ );
                    xc->blackout_activity = (unsigned char *)return_value_calloc_20;
                    i = (unsigned int)0;
                    for( ; !(i >= xc->num_blackouts); i = i + 1u)
                    {
                      signed int return_value_fgetc_21;
                      return_value_fgetc_21=fgetc(xc->f);
                      xc->blackout_activity[(signed long int)i] = (unsigned char)(return_value_fgetc_21 != 0);
                      delta=fstReaderVarint64(xc->f);
                      cur_bl = cur_bl + delta;
                      xc->blackout_times[(signed long int)i] = cur_bl;
                    }
                  }

      blkpos = blkpos + (signed long int)seclen;
      if(hdr_seen == 0)
        break;

    }
    if(!(hdr_seen == 0))
    {
      if(!(xc->vc_section_count == vc_section_count_actual))
        xc->vc_section_count = vc_section_count_actual;

      if(xc->contains_geom_section == 0u)
        fstReaderProcessHier((void *)xc, (struct _IO_FILE *)(void *)0);

    }

  }

  return hdr_seen;
}

// fstReaderIterBlocks
// file ./../../src/helpers/fst/fstapi.c line 4651
signed int fstReaderIterBlocks(void *ctx, void (*value_change_callback)(void *, unsigned long int, unsigned int, const unsigned char *), void *user_callback_data_pointer, struct _IO_FILE *fv)
{
  signed int return_value_fstReaderIterBlocks2_1;
  return_value_fstReaderIterBlocks2_1=fstReaderIterBlocks2(ctx, value_change_callback, (void (*)(void *, unsigned long int, unsigned int, const unsigned char *, unsigned int))(void *)0, user_callback_data_pointer, fv);
  return return_value_fstReaderIterBlocks2_1;
}

// fstReaderIterBlocks2
// file ./../../src/helpers/fst/fstapi.c line 4659
signed int fstReaderIterBlocks2(void *ctx, void (*value_change_callback)(void *, unsigned long int, unsigned int, const unsigned char *), void (*value_change_callback_varlen)(void *, unsigned long int, unsigned int, const unsigned char *, unsigned int), void *user_callback_data_pointer, struct _IO_FILE *fv)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  unsigned long int previous_time = 18446744073709551615UL;
  unsigned long int *time_table = (unsigned long int *)(void *)0;
  unsigned long int tsec_nitems;
  unsigned int secnum = (unsigned int)0;
  signed int blocks_skipped = 0;
  signed long int blkpos = (signed long int)0;
  unsigned long int seclen;
  unsigned long int beg_tim;
  unsigned long int frame_uclen;
  unsigned long int frame_clen;
  unsigned long int frame_maxhandle;
  unsigned long int vc_maxhandle;
  signed long int vc_start;
  signed long int indx_pntr;
  signed long int indx_pos;
  signed long int *chain_table = (signed long int *)(void *)0;
  unsigned int *chain_table_lengths = (unsigned int *)(void *)0;
  unsigned char *chain_cmem;
  unsigned char *pnt;
  signed long int chain_clen;
  unsigned int idx;
  unsigned int pidx = (unsigned int)0;
  unsigned int i;
  unsigned long int pval;
  unsigned long int vc_maxhandle_largest = (unsigned long int)0;
  unsigned long int tsec_uclen = (unsigned long int)0;
  unsigned long int tsec_clen = (unsigned long int)0;
  signed int sectype;
  unsigned long int mem_required_for_traversal;
  unsigned char *mem_for_traversal = (unsigned char *)(void *)0;
  unsigned int traversal_mem_offs;
  unsigned int *scatterptr;
  unsigned int *headptr;
  unsigned int *length_remaining;
  unsigned int cur_blackout = (unsigned int)0;
  signed int packtype;
  unsigned char *mc_mem = (unsigned char *)(void *)0;
  unsigned int mc_mem_len;
  unsigned int tmp_post_11;
  unsigned int tmp_post_18;
  unsigned int tmp_post_20;
  unsigned int tmp_post_23;
  unsigned int tmp_post_24;
  void *return_value_malloc_25;
  signed int return_value_LZ4_decompress_safe_partial_27;
  unsigned int tmp_post_28;
  if(xc == ((struct fstReaderContext *)NULL))
    return 0;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)xc->maxhandle, sizeof(unsigned int) /*4ul*/ );
    scatterptr = (unsigned int *)return_value_calloc_1;
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)xc->maxhandle, sizeof(unsigned int) /*4ul*/ );
    headptr = (unsigned int *)return_value_calloc_2;
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)xc->maxhandle, sizeof(unsigned int) /*4ul*/ );
    length_remaining = (unsigned int *)return_value_calloc_3;
    if(!(fv == ((struct _IO_FILE *)NULL)))
    {
      fprintf(fv, "_dumpvars\n");
      fflush(fv);
      setvbuf(fv, (char *)(void *)0, 2, (unsigned long int)0);
      xc->writex_fd=fileno(fv);
    }

    do
    {
      unsigned int *tc_head = (unsigned int *)(void *)0;
      traversal_mem_offs = (unsigned int)0;
      fstReaderFseeko(xc, xc->f, blkpos, 0);
      sectype=fgetc(xc->f);
      seclen=fstReaderUint64(xc->f);
      if(sectype == 255 || sectype == -1)
        break;

      blkpos = blkpos + 1l;
      if(!(sectype == 1) && !(sectype == 5) && !(sectype == 8))
        blkpos = blkpos + (signed long int)seclen;

      else
      {
        if(seclen == 0ul)
          break;

        beg_tim=fstReaderUint64(xc->f);
        fstReaderUint64(xc->f);
        if(!(xc->limit_range_valid == 0u))
        {
          if(!(beg_tim >= xc->limit_range_start))
          {
            blocks_skipped = blocks_skipped + 1;
            blkpos = blkpos + (signed long int)seclen;
            continue;
          }

          if(!(xc->limit_range_end >= beg_tim))
            break;

        }

        mem_required_for_traversal=fstReaderUint64(xc->f);
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(mem_required_for_traversal + (unsigned long int)66);
        mem_for_traversal = (unsigned char *)return_value_malloc_4;
        unsigned char *ucdata;
        unsigned char *cdata;
        unsigned long int fstReaderIterBlocks2__1__2__1__4__destlen;
        unsigned long int fstReaderIterBlocks2__1__2__1__4__sourcelen;
        signed int fstReaderIterBlocks2__1__2__1__4__rc;
        unsigned char *tpnt;
        unsigned long int tpval;
        unsigned int ti;
        signed int return_value_fstReaderFseeko_5;
        return_value_fstReaderFseeko_5=fstReaderFseeko(xc, xc->f, (signed long int)(((unsigned long int)blkpos + seclen) - (unsigned long int)24), 0);
        if(!(return_value_fstReaderFseeko_5 == 0))
          break;

        tsec_uclen=fstReaderUint64(xc->f);
        tsec_clen=fstReaderUint64(xc->f);
        tsec_nitems=fstReaderUint64(xc->f);
        if(!(seclen >= tsec_clen))
          break;

        void *return_value_malloc_6;
        return_value_malloc_6=malloc(tsec_uclen);
        ucdata = (unsigned char *)return_value_malloc_6;
        if(ucdata == ((unsigned char *)NULL))
          break;

        fstReaderIterBlocks2__1__2__1__4__destlen = tsec_uclen;
        fstReaderIterBlocks2__1__2__1__4__sourcelen = tsec_clen;
        fstReaderFseeko(xc, xc->f, (signed long int)-24 - (signed long int)tsec_clen, 1);
        if(!(tsec_uclen == tsec_clen))
        {
          void *return_value_malloc_7;
          return_value_malloc_7=malloc(tsec_clen);
          cdata = (unsigned char *)return_value_malloc_7;
          fstFread((void *)cdata, tsec_clen, (unsigned long int)1, xc->f);
          fstReaderIterBlocks2__1__2__1__4__rc=uncompress(ucdata, &fstReaderIterBlocks2__1__2__1__4__destlen, cdata, fstReaderIterBlocks2__1__2__1__4__sourcelen);
          if(!(fstReaderIterBlocks2__1__2__1__4__rc == 0))
          {
            printf("tsec uncompress rc = %d\n", fstReaderIterBlocks2__1__2__1__4__rc);
            exit(255);
          }

          free((void *)cdata);
        }

        else
          fstFread((void *)ucdata, tsec_uclen, (unsigned long int)1, xc->f);
        free((void *)time_table);
        void *return_value_calloc_8;
        return_value_calloc_8=calloc(tsec_nitems, sizeof(unsigned long int) /*8ul*/ );
        time_table = (unsigned long int *)return_value_calloc_8;
        tpnt = ucdata;
        tpval = (unsigned long int)0;
        ti = (unsigned int)0;
        for( ; !((unsigned long int)ti >= tsec_nitems); ti = ti + 1u)
        {
          signed int fstReaderIterBlocks2__1__2__1__4__3__1__skiplen;
          unsigned long int fstReaderIterBlocks2__1__2__1__4__3__1__val;
          fstReaderIterBlocks2__1__2__1__4__3__1__val=fstGetVarint64(tpnt, &fstReaderIterBlocks2__1__2__1__4__3__1__skiplen);
          time_table[(signed long int)ti] = tpval + fstReaderIterBlocks2__1__2__1__4__3__1__val;
          tpval = time_table[(signed long int)ti];
          tpnt = tpnt + (signed long int)fstReaderIterBlocks2__1__2__1__4__3__1__skiplen;
        }
        void *return_value_calloc_9;
        return_value_calloc_9=calloc(tsec_nitems != 0ul ? tsec_nitems : (unsigned long int)1, sizeof(unsigned int) /*4ul*/ );
        tc_head = (unsigned int *)return_value_calloc_9;
        free((void *)ucdata);
        fstReaderFseeko(xc, xc->f, blkpos + (signed long int)32, 0);
        frame_uclen=fstReaderVarint64(xc->f);
        frame_clen=fstReaderVarint64(xc->f);
        frame_maxhandle=fstReaderVarint64(xc->f);
        if(secnum == 0u)
        {
          if(!(blocks_skipped == 0) || !(beg_tim == *time_table))
          {
            unsigned char *fstReaderIterBlocks2__1__2__1__5__1__mu;
            void *return_value_malloc_10;
            return_value_malloc_10=malloc(frame_uclen);
            fstReaderIterBlocks2__1__2__1__5__1__mu = (unsigned char *)return_value_malloc_10;
            unsigned int sig_offs = (unsigned int)0;
            if(!(fv == ((struct _IO_FILE *)NULL)))
            {
              char fstReaderIterBlocks2__1__2__1__5__1__1__wx_buf[32l];
              signed int fstReaderIterBlocks2__1__2__1__5__1__1__wx_len;
              if(!(beg_tim == 0ul))
              {
                fstReaderIterBlocks2__1__2__1__5__1__1__wx_len=sprintf(fstReaderIterBlocks2__1__2__1__5__1__1__wx_buf, "#%lu\n", beg_tim);
                fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__5__1__1__wx_buf, fstReaderIterBlocks2__1__2__1__5__1__1__wx_len);
              }

              if(!(xc->num_blackouts == 0u))
              {
                if(!(cur_blackout == xc->num_blackouts))
                {
                  if(beg_tim == xc->blackout_times[(signed long int)cur_blackout])
                  {
                    tmp_post_11 = cur_blackout;
                    cur_blackout = cur_blackout + 1u;
                    fstReaderIterBlocks2__1__2__1__5__1__1__wx_len=sprintf(fstReaderIterBlocks2__1__2__1__5__1__1__wx_buf, "_dump%s _end\n", xc->blackout_activity[(signed long int)tmp_post_11] != 0 ? "on" : "off");
                    fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__5__1__1__wx_buf, fstReaderIterBlocks2__1__2__1__5__1__1__wx_len);
                  }

                }

              }

            }

            if(frame_uclen == frame_clen)
              fstFread((void *)fstReaderIterBlocks2__1__2__1__5__1__mu, frame_uclen, (unsigned long int)1, xc->f);

            else
            {
              unsigned char *mc;
              void *return_value_malloc_12;
              return_value_malloc_12=malloc(frame_clen);
              mc = (unsigned char *)return_value_malloc_12;
              signed int rc;
              unsigned long int destlen = frame_uclen;
              unsigned long int sourcelen = frame_clen;
              fstFread((void *)mc, sourcelen, (unsigned long int)1, xc->f);
              rc=uncompress(fstReaderIterBlocks2__1__2__1__5__1__mu, &destlen, mc, sourcelen);
              if(!(rc == 0))
              {
                printf("rc: %d\n", rc);
                exit(255);
              }

              free((void *)mc);
            }
            idx = (unsigned int)0;
            for( ; !((unsigned long int)idx >= frame_maxhandle); idx = idx + 1u)
            {
              signed int fstReaderIterBlocks2__1__2__1__5__1__4__1__process_idx = (signed int)(idx / (unsigned int)8);
              signed int fstReaderIterBlocks2__1__2__1__5__1__4__1__process_bit = (signed int)(idx & (unsigned int)7);
              if(!((1 << fstReaderIterBlocks2__1__2__1__5__1__4__1__process_bit & (signed int)xc->process_mask[(signed long int)fstReaderIterBlocks2__1__2__1__5__1__4__1__process_idx]) == 0))
              {
                if(!(xc->signal_lens[(signed long int)idx] >= 2u))
                {
                  if(xc->signal_lens[(signed long int)idx] == 1u)
                  {
                    unsigned char val = fstReaderIterBlocks2__1__2__1__5__1__mu[(signed long int)sig_offs];
                    if(!(value_change_callback == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *))NULL)))
                    {
                      xc->temp_signal_value_buf[(signed long int)0] = val;
                      xc->temp_signal_value_buf[(signed long int)1] = (unsigned char)0;
                      value_change_callback(user_callback_data_pointer, beg_tim, idx + (unsigned int)1, xc->temp_signal_value_buf);
                    }

                    else
                      if(!(fv == ((struct _IO_FILE *)NULL)))
                      {
                        char fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcd_id[16l];
                        signed int fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcdid_len;
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcdid_len=fstVcdIDForFwrite(fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcd_id + (signed long int)1, idx + (unsigned int)1);
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcd_id[(signed long int)0] = (char)val;
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcd_id[(signed long int)(fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcdid_len + 1)] = (char)10;
                        fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcd_id, fstReaderIterBlocks2__1__2__1__5__1__4__1__1__1__1__2__1__vcdid_len + 2);
                      }

                  }

                }

                else
                  if(!((signed int)xc->signal_typs[(signed long int)idx] == FST_VT_VCD_REAL))
                  {
                    if(!(value_change_callback == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *))NULL)))
                    {
                      memcpy((void *)xc->temp_signal_value_buf, (const void *)(fstReaderIterBlocks2__1__2__1__5__1__mu + (signed long int)sig_offs), (unsigned long int)xc->signal_lens[(signed long int)idx]);
                      xc->temp_signal_value_buf[(signed long int)xc->signal_lens[(signed long int)idx]] = (unsigned char)0;
                      value_change_callback(user_callback_data_pointer, beg_tim, idx + (unsigned int)1, xc->temp_signal_value_buf);
                    }

                    else
                      if(!(fv == ((struct _IO_FILE *)NULL)))
                      {
                        char fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcd_id[16l];
                        signed int fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcdid_len;
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcdid_len=fstVcdIDForFwrite(fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcd_id + (signed long int)1, idx + (unsigned int)1);
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcd_id[(signed long int)0] = (char)((signed int)xc->signal_typs[(signed long int)idx] != FST_VT_VCD_PORT ? 98 : 112);
                        fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcd_id, 1);
                        fstWritex(xc, (void *)(fstReaderIterBlocks2__1__2__1__5__1__mu + (signed long int)sig_offs), (signed int)xc->signal_lens[(signed long int)idx]);
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcd_id[(signed long int)0] = (char)32;
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcd_id[(signed long int)(fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcdid_len + 1)] = (char)10;
                        fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcd_id, fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__1__2__1__vcdid_len + 2);
                      }

                  }

                  else
                  {
                    double fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__d;
                    unsigned char *fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d;
                    unsigned char *fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__srcdata = fstReaderIterBlocks2__1__2__1__5__1__mu + (signed long int)sig_offs;
                    if(!(value_change_callback == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *))NULL)))
                    {
                      if(!(xc->native_doubles_for_cb == 0u))
                      {
                        if(!(xc->double_endian_match == 0u))
                          fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d = fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__srcdata;

                        else
                        {
                          signed int fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__1__1__2__j;
                          fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d = (unsigned char *)&fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__d;
                          fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__1__1__2__j = 0;
                          for( ; !(fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__1__1__2__j >= 8); fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__1__1__2__j = fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__1__1__2__j + 1)
                            fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d[(signed long int)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__1__1__2__j] = fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__srcdata[(signed long int)(7 - fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__1__1__2__j)];
                        }
                        value_change_callback(user_callback_data_pointer, beg_tim, idx + (unsigned int)1, fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d);
                      }

                      else
                      {
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d = (unsigned char *)&fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__d;
                        if(!(xc->double_endian_match == 0u))
                          memcpy((void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d, (const void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__srcdata, (unsigned long int)8);

                        else
                        {
                          signed int j = 0;
                          for( ; !(j >= 8); j = j + 1)
                            fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d[(signed long int)j] = fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__srcdata[(signed long int)(7 - j)];
                        }
                        sprintf((char *)xc->temp_signal_value_buf, "%.16g", fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__d);
                        value_change_callback(user_callback_data_pointer, beg_tim, idx + (unsigned int)1, xc->temp_signal_value_buf);
                      }
                    }

                    else
                      if(!(fv == ((struct _IO_FILE *)NULL)))
                      {
                        char vcdid_buf[16l];
                        char fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__wx_buf[64l];
                        signed int fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__wx_len;
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d = (unsigned char *)&fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__d;
                        if(!(xc->double_endian_match == 0u))
                          memcpy((void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d, (const void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__srcdata, (unsigned long int)8);

                        else
                        {
                          signed int fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__2__j = 0;
                          for( ; !(fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__2__j >= 8); fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__2__j = fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__2__j + 1)
                            fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__clone_d[(signed long int)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__2__j] = fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__srcdata[(signed long int)(7 - fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__2__j)];
                        }
                        fstVcdID(vcdid_buf, idx + (unsigned int)1);
                        fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__wx_len=sprintf(fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__wx_buf, "r%.16g %s\n", fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__d, (const void *)vcdid_buf);
                        fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__wx_buf, fstReaderIterBlocks2__1__2__1__5__1__4__1__1__2__2__2__1__wx_len);
                      }

                  }
              }

              sig_offs = sig_offs + xc->signal_lens[(signed long int)idx];
            }
            free((void *)fstReaderIterBlocks2__1__2__1__5__1__mu);
            fstReaderFseeko(xc, xc->f, -((signed long int)frame_clen), 1);
          }

        }

        fstReaderFseeko(xc, xc->f, (signed long int)frame_clen, 1);
        vc_maxhandle=fstReaderVarint64(xc->f);
        vc_start=ftello(xc->f);
        packtype=fgetc(xc->f);
        indx_pntr = (signed long int)(((((unsigned long int)blkpos + seclen) - (unsigned long int)24) - tsec_clen) - (unsigned long int)8);
        fstReaderFseeko(xc, xc->f, indx_pntr, 0);
        unsigned long int return_value_fstReaderUint64_13;
        return_value_fstReaderUint64_13=fstReaderUint64(xc->f);
        chain_clen = (signed long int)return_value_fstReaderUint64_13;
        indx_pos = indx_pntr - chain_clen;
        void *return_value_malloc_14;
        return_value_malloc_14=malloc((unsigned long int)chain_clen);
        chain_cmem = (unsigned char *)return_value_malloc_14;
        if(!(chain_cmem == ((unsigned char *)NULL)))
        {
          fstReaderFseeko(xc, xc->f, indx_pos, 0);
          fstFread((void *)chain_cmem, (unsigned long int)chain_clen, (unsigned long int)1, xc->f);
          if(!(vc_maxhandle_largest >= vc_maxhandle))
          {
            free((void *)chain_table);
            free((void *)chain_table_lengths);
            vc_maxhandle_largest = vc_maxhandle;
            void *return_value_calloc_15;
            return_value_calloc_15=calloc(vc_maxhandle + (unsigned long int)1, sizeof(signed long int) /*8ul*/ );
            chain_table = (signed long int *)return_value_calloc_15;
            void *return_value_calloc_16;
            return_value_calloc_16=calloc(vc_maxhandle + (unsigned long int)1, sizeof(unsigned int) /*4ul*/ );
            chain_table_lengths = (unsigned int *)return_value_calloc_16;
          }

          if(!(chain_table == ((signed long int *)NULL)) && !(chain_table_lengths == ((unsigned int *)NULL)))
          {
            pnt = chain_cmem;
            idx = (unsigned int)0;
            pval = (unsigned long int)0;
            if(sectype == 8)
            {
              unsigned int prev_alias = (unsigned int)0;
              do
              {
                signed int fstReaderIterBlocks2__1__2__1__7__1__skiplen;
                if(!((0x01 & (signed int)*pnt) == 0))
                {
                  signed long int shval;
                  signed long int return_value_fstGetSVarint64_17;
                  return_value_fstGetSVarint64_17=fstGetSVarint64(pnt, &fstReaderIterBlocks2__1__2__1__7__1__skiplen);
                  shval = return_value_fstGetSVarint64_17 >> 1;
                  if(shval >= 1l)
                  {
                    chain_table[(signed long int)idx] = (signed long int)(pval + (unsigned long int)shval);
                    pval = (unsigned long int)chain_table[(signed long int)idx];
                    if(!(idx == 0u))
                      chain_table_lengths[(signed long int)pidx] = (unsigned int)(pval - (unsigned long int)chain_table[(signed long int)pidx]);

                    tmp_post_18 = idx;
                    idx = idx + 1u;
                    pidx = tmp_post_18;
                  }

                  else
                    if(!(shval >= 0l))
                    {
                      chain_table[(signed long int)idx] = (signed long int)0;
                      prev_alias = (unsigned int)shval;
                      chain_table_lengths[(signed long int)idx] = prev_alias;
                      idx = idx + 1u;
                    }

                    else
                    {
                      chain_table[(signed long int)idx] = (signed long int)0;
                      chain_table_lengths[(signed long int)idx] = prev_alias;
                      idx = idx + 1u;
                    }
                }

                else
                {
                  unsigned long int fstReaderIterBlocks2__1__2__1__7__1__2__val;
                  unsigned int return_value_fstGetVarint32_19;
                  return_value_fstGetVarint32_19=fstGetVarint32(pnt, &fstReaderIterBlocks2__1__2__1__7__1__skiplen);
                  fstReaderIterBlocks2__1__2__1__7__1__2__val = (unsigned long int)return_value_fstGetVarint32_19;
                  unsigned int fstReaderIterBlocks2__1__2__1__7__1__2__loopcnt = (unsigned int)(fstReaderIterBlocks2__1__2__1__7__1__2__val >> 1);
                  i = (unsigned int)0;
                  for( ; !(i >= fstReaderIterBlocks2__1__2__1__7__1__2__loopcnt); i = i + 1u)
                  {
                    tmp_post_20 = idx;
                    idx = idx + 1u;
                    chain_table[(signed long int)tmp_post_20] = (signed long int)0;
                  }
                }
                pnt = pnt + (signed long int)fstReaderIterBlocks2__1__2__1__7__1__skiplen;
              }
              while(!(pnt == chain_cmem + chain_clen));
            }

            else
              do
              {
                signed int fstReaderIterBlocks2__1__2__1__8__1__skiplen;
                unsigned long int fstReaderIterBlocks2__1__2__1__8__1__val;
                unsigned int return_value_fstGetVarint32_21;
                return_value_fstGetVarint32_21=fstGetVarint32(pnt, &fstReaderIterBlocks2__1__2__1__8__1__skiplen);
                fstReaderIterBlocks2__1__2__1__8__1__val = (unsigned long int)return_value_fstGetVarint32_21;
                if(fstReaderIterBlocks2__1__2__1__8__1__val == 0ul)
                {
                  pnt = pnt + (signed long int)fstReaderIterBlocks2__1__2__1__8__1__skiplen;
                  unsigned int return_value_fstGetVarint32_22;
                  return_value_fstGetVarint32_22=fstGetVarint32(pnt, &fstReaderIterBlocks2__1__2__1__8__1__skiplen);
                  fstReaderIterBlocks2__1__2__1__8__1__val = (unsigned long int)return_value_fstGetVarint32_22;
                  chain_table[(signed long int)idx] = (signed long int)0;
                  chain_table_lengths[(signed long int)idx] = (unsigned int)-fstReaderIterBlocks2__1__2__1__8__1__val;
                  idx = idx + 1u;
                }

                else
                  if(!((1ul & fstReaderIterBlocks2__1__2__1__8__1__val) == 0ul))
                  {
                    chain_table[(signed long int)idx] = (signed long int)(pval + (fstReaderIterBlocks2__1__2__1__8__1__val >> 1));
                    pval = (unsigned long int)chain_table[(signed long int)idx];
                    if(!(idx == 0u))
                      chain_table_lengths[(signed long int)pidx] = (unsigned int)(pval - (unsigned long int)chain_table[(signed long int)pidx]);

                    tmp_post_23 = idx;
                    idx = idx + 1u;
                    pidx = tmp_post_23;
                  }

                  else
                  {
                    unsigned int loopcnt = (unsigned int)(fstReaderIterBlocks2__1__2__1__8__1__val >> 1);
                    i = (unsigned int)0;
                    for( ; !(i >= loopcnt); i = i + 1u)
                    {
                      tmp_post_24 = idx;
                      idx = idx + 1u;
                      chain_table[(signed long int)tmp_post_24] = (signed long int)0;
                    }
                  }
                pnt = pnt + (signed long int)fstReaderIterBlocks2__1__2__1__8__1__skiplen;
              }
              while(!(pnt == chain_cmem + chain_clen));
            chain_table[(signed long int)idx] = indx_pos - vc_start;
            chain_table_lengths[(signed long int)pidx] = (unsigned int)(chain_table[(signed long int)idx] - chain_table[(signed long int)pidx]);
            i = (unsigned int)0;
            for( ; !(i >= idx); i = i + 1u)
            {
              signed int v32 = (signed int)chain_table_lengths[(signed long int)i];
              if(!(v32 >= 0))
              {
                if(chain_table[(signed long int)i] == 0l)
                {
                  v32 = -v32;
                  v32 = v32 - 1;
                  if(!((unsigned int)v32 >= i))
                  {
                    chain_table[(signed long int)i] = chain_table[(signed long int)v32];
                    chain_table_lengths[(signed long int)i] = chain_table_lengths[(signed long int)v32];
                  }

                }

              }

            }
            mc_mem_len = (unsigned int)16384;
            return_value_malloc_25=malloc((unsigned long int)mc_mem_len);
            mc_mem = (unsigned char *)return_value_malloc_25;
            if(!(xc->maxhandle >= idx))
              idx = xc->maxhandle;

            i = (unsigned int)0;
            for( ; !(i >= idx); i = i + 1u)
              if(!(chain_table[(signed long int)i] == 0l))
              {
                signed int process_idx = (signed int)(i / (unsigned int)8);
                signed int process_bit = (signed int)(i & (unsigned int)7);
                if(!((1 << process_bit & (signed int)xc->process_mask[(signed long int)process_idx]) == 0))
                {
                  signed int fstReaderIterBlocks2__1__2__1__10__1__1__1__rc = 0;
                  unsigned int fstReaderIterBlocks2__1__2__1__10__1__1__1__val;
                  unsigned int skiplen;
                  unsigned int tdelta;
                  fstReaderFseeko(xc, xc->f, vc_start + chain_table[(signed long int)i], 0);
                  fstReaderIterBlocks2__1__2__1__10__1__1__1__val=fstReaderVarint32WithSkip(xc->f, &skiplen);
                  if(!(fstReaderIterBlocks2__1__2__1__10__1__1__1__val == 0u))
                  {
                    unsigned char *fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mu = mem_for_traversal + (signed long int)traversal_mem_offs;
                    unsigned char *fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mc;
                    unsigned long int fstReaderIterBlocks2__1__2__1__10__1__1__1__1__destlen = (unsigned long int)fstReaderIterBlocks2__1__2__1__10__1__1__1__val;
                    unsigned long int fstReaderIterBlocks2__1__2__1__10__1__1__1__1__sourcelen = (unsigned long int)chain_table_lengths[(signed long int)i];
                    if(!(mc_mem_len >= chain_table_lengths[(signed long int)i]))
                    {
                      free((void *)mc_mem);
                      mc_mem_len = chain_table_lengths[(signed long int)i];
                      void *return_value_malloc_26;
                      return_value_malloc_26=malloc((unsigned long int)mc_mem_len);
                      mc_mem = (unsigned char *)return_value_malloc_26;
                    }

                    fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mc = mc_mem;
                    fstFread((void *)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mc, (unsigned long int)chain_table_lengths[(signed long int)i], (unsigned long int)1, xc->f);
                    switch(packtype)
                    {
                      case 52:
                      {
                        return_value_LZ4_decompress_safe_partial_27=LZ4_decompress_safe_partial((char *)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mc, (char *)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mu, (signed int)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__sourcelen, (signed int)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__destlen, (signed int)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__destlen);
                        fstReaderIterBlocks2__1__2__1__10__1__1__1__rc = fstReaderIterBlocks2__1__2__1__10__1__1__1__1__destlen == (unsigned long int)return_value_LZ4_decompress_safe_partial_27 ? 0 : -3;
                        break;
                      }
                      case 70:
                      {
                        fastlz_decompress((const void *)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mc, (signed int)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__sourcelen, (void *)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mu, (signed int)fstReaderIterBlocks2__1__2__1__10__1__1__1__1__destlen);
                        break;
                      }
                      default:
                        fstReaderIterBlocks2__1__2__1__10__1__1__1__rc=uncompress(fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mu, &fstReaderIterBlocks2__1__2__1__10__1__1__1__1__destlen, fstReaderIterBlocks2__1__2__1__10__1__1__1__1__mc, fstReaderIterBlocks2__1__2__1__10__1__1__1__1__sourcelen);
                    }
                    headptr[(signed long int)i] = traversal_mem_offs;
                    length_remaining[(signed long int)i] = fstReaderIterBlocks2__1__2__1__10__1__1__1__val;
                    traversal_mem_offs = traversal_mem_offs + fstReaderIterBlocks2__1__2__1__10__1__1__1__val;
                  }

                  else
                  {
                    signed int fstReaderIterBlocks2__1__2__1__10__1__1__1__2__destlen = (signed int)(chain_table_lengths[(signed long int)i] - skiplen);
                    unsigned char *mu = mem_for_traversal + (signed long int)traversal_mem_offs;
                    fstFread((void *)mu, (unsigned long int)fstReaderIterBlocks2__1__2__1__10__1__1__1__2__destlen, (unsigned long int)1, xc->f);
                    headptr[(signed long int)i] = traversal_mem_offs;
                    length_remaining[(signed long int)i] = (unsigned int)fstReaderIterBlocks2__1__2__1__10__1__1__1__2__destlen;
                    traversal_mem_offs = traversal_mem_offs + (unsigned int)fstReaderIterBlocks2__1__2__1__10__1__1__1__2__destlen;
                  }
                  if(!(fstReaderIterBlocks2__1__2__1__10__1__1__1__rc == 0))
                  {
                    printf("\tfac: %d clen: %d (rc=%d)\n", (signed int)i, (signed int)fstReaderIterBlocks2__1__2__1__10__1__1__1__val, fstReaderIterBlocks2__1__2__1__10__1__1__1__rc);
                    exit(255);
                  }

                  if(xc->signal_lens[(signed long int)i] == 1u)
                  {
                    unsigned int fstReaderIterBlocks2__1__2__1__10__1__1__1__4__vli;
                    fstReaderIterBlocks2__1__2__1__10__1__1__1__4__vli=fstGetVarint32NoSkip(mem_for_traversal + (signed long int)headptr[(signed long int)i]);
                    unsigned int shcnt = (unsigned int)(2 << (fstReaderIterBlocks2__1__2__1__10__1__1__1__4__vli & (unsigned int)1));
                    tdelta = fstReaderIterBlocks2__1__2__1__10__1__1__1__4__vli >> shcnt;
                  }

                  else
                  {
                    unsigned int vli;
                    vli=fstGetVarint32NoSkip(mem_for_traversal + (signed long int)headptr[(signed long int)i]);
                    tdelta = vli >> 1;
                  }
                  scatterptr[(signed long int)i] = tc_head[(signed long int)tdelta];
                  tc_head[(signed long int)tdelta] = i + (unsigned int)1;
                }

              }

            free((void *)mc_mem);
            i = (unsigned int)0;
            for( ; !((unsigned long int)i >= tsec_nitems); i = i + 1u)
            {
              unsigned int fstReaderIterBlocks2__1__2__1__11__1__tdelta;
              signed int fstReaderIterBlocks2__1__2__1__11__1__skiplen;
              signed int skiplen2;
              unsigned int fstReaderIterBlocks2__1__2__1__11__1__vli;
              if(!(fv == ((struct _IO_FILE *)NULL)))
              {
                char wx_buf[32l];
                signed int wx_len;
                if(!(time_table[(signed long int)i] == previous_time))
                {
                  if(!(xc->limit_range_valid == 0u))
                  {
                    if(!(xc->limit_range_end >= time_table[(signed long int)i]))
                      break;

                  }

                  wx_len=sprintf(wx_buf, "#%lu\n", time_table[(signed long int)i]);
                  fstWritex(xc, (void *)wx_buf, wx_len);
                  if(!(xc->num_blackouts == 0u))
                  {
                    if(!(cur_blackout == xc->num_blackouts))
                    {
                      if(time_table[(signed long int)i] == xc->blackout_times[(signed long int)cur_blackout])
                      {
                        tmp_post_28 = cur_blackout;
                        cur_blackout = cur_blackout + 1u;
                        wx_len=sprintf(wx_buf, "_dump%s _end\n", xc->blackout_activity[(signed long int)tmp_post_28] != 0 ? "on" : "off");
                        fstWritex(xc, (void *)wx_buf, wx_len);
                      }

                    }

                  }

                  previous_time = time_table[(signed long int)i];
                }

              }

              while(!(tc_head[(signed long int)i] == 0u))
              {
                idx = tc_head[(signed long int)i] - (unsigned int)1;
                fstReaderIterBlocks2__1__2__1__11__1__vli=fstGetVarint32(mem_for_traversal + (signed long int)headptr[(signed long int)idx], &fstReaderIterBlocks2__1__2__1__11__1__skiplen);
                if(!(xc->signal_lens[(signed long int)idx] >= 2u))
                {
                  if(xc->signal_lens[(signed long int)idx] == 1u)
                  {
                    unsigned char fstReaderIterBlocks2__1__2__1__11__1__2__1__1__val;
                    if((1u & fstReaderIterBlocks2__1__2__1__11__1__vli) == 0u)
                      fstReaderIterBlocks2__1__2__1__11__1__2__1__1__val = (unsigned char)(fstReaderIterBlocks2__1__2__1__11__1__vli >> 1 & (unsigned int)1 | (unsigned int)48);

                    else
                      fstReaderIterBlocks2__1__2__1__11__1__2__1__1__val = (unsigned char)"xzhuwl-?"[(signed long int)(fstReaderIterBlocks2__1__2__1__11__1__vli >> 1 & (unsigned int)7)];
                    if(!(value_change_callback == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *))NULL)))
                    {
                      xc->temp_signal_value_buf[(signed long int)0] = fstReaderIterBlocks2__1__2__1__11__1__2__1__1__val;
                      xc->temp_signal_value_buf[(signed long int)1] = (unsigned char)0;
                      value_change_callback(user_callback_data_pointer, time_table[(signed long int)i], idx + (unsigned int)1, xc->temp_signal_value_buf);
                    }

                    else
                      if(!(fv == ((struct _IO_FILE *)NULL)))
                      {
                        char vcd_id[16l];
                        signed int fstReaderIterBlocks2__1__2__1__11__1__2__1__1__4__1__vcdid_len;
                        fstReaderIterBlocks2__1__2__1__11__1__2__1__1__4__1__vcdid_len=fstVcdIDForFwrite(vcd_id + (signed long int)1, idx + (unsigned int)1);
                        vcd_id[(signed long int)0] = (char)fstReaderIterBlocks2__1__2__1__11__1__2__1__1__val;
                        vcd_id[(signed long int)(fstReaderIterBlocks2__1__2__1__11__1__2__1__1__4__1__vcdid_len + 1)] = (char)10;
                        fstWritex(xc, (void *)vcd_id, fstReaderIterBlocks2__1__2__1__11__1__2__1__1__4__1__vcdid_len + 2);
                      }

                    headptr[(signed long int)idx] = headptr[(signed long int)idx] + (unsigned int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                    length_remaining[(signed long int)idx] = length_remaining[(signed long int)idx] - (unsigned int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                    tc_head[(signed long int)i] = scatterptr[(signed long int)idx];
                    scatterptr[(signed long int)idx] = (unsigned int)0;
                    if(!(length_remaining[(signed long int)idx] == 0u))
                    {
                      signed int shamt;
                      fstReaderIterBlocks2__1__2__1__11__1__vli=fstGetVarint32NoSkip(mem_for_traversal + (signed long int)headptr[(signed long int)idx]);
                      shamt = 2 << (fstReaderIterBlocks2__1__2__1__11__1__vli & (unsigned int)1);
                      fstReaderIterBlocks2__1__2__1__11__1__tdelta = fstReaderIterBlocks2__1__2__1__11__1__vli >> shamt;
                      scatterptr[(signed long int)idx] = tc_head[(signed long int)(i + fstReaderIterBlocks2__1__2__1__11__1__tdelta)];
                      tc_head[(signed long int)(i + fstReaderIterBlocks2__1__2__1__11__1__tdelta)] = idx + (unsigned int)1;
                    }

                  }

                  else
                  {
                    unsigned char *vdata;
                    unsigned int len;
                    fstReaderIterBlocks2__1__2__1__11__1__vli=fstGetVarint32(mem_for_traversal + (signed long int)headptr[(signed long int)idx], &fstReaderIterBlocks2__1__2__1__11__1__skiplen);
                    len=fstGetVarint32(mem_for_traversal + (signed long int)headptr[(signed long int)idx] + (signed long int)fstReaderIterBlocks2__1__2__1__11__1__skiplen, &skiplen2);
                    fstReaderIterBlocks2__1__2__1__11__1__skiplen = fstReaderIterBlocks2__1__2__1__11__1__skiplen + skiplen2;
                    vdata = mem_for_traversal + (signed long int)headptr[(signed long int)idx] + (signed long int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                    if((1u & fstReaderIterBlocks2__1__2__1__11__1__vli) == 0u)
                    {
                      if(!(value_change_callback_varlen == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *, unsigned int))NULL)))
                        value_change_callback_varlen(user_callback_data_pointer, time_table[(signed long int)i], idx + (unsigned int)1, vdata, len);

                      else
                        if(!(fv == ((struct _IO_FILE *)NULL)))
                        {
                          char fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcd_id[16l];
                          signed int fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcdid_len;
                          fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcd_id[(signed long int)0] = (char)115;
                          fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcd_id, 1);
                          fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcdid_len=fstVcdIDForFwrite(fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcd_id + (signed long int)1, idx + (unsigned int)1);
                          unsigned char *vesc;
                          void *return_value_malloc_29;
                          return_value_malloc_29=malloc((unsigned long int)(len * (unsigned int)4 + (unsigned int)1));
                          vesc = (unsigned char *)return_value_malloc_29;
                          signed int vlen;
                          vlen=fstUtilityBinToEsc(vesc, vdata, (signed int)len);
                          fstWritex(xc, (void *)vesc, vlen);
                          free((void *)vesc);
                          fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcd_id[(signed long int)0] = (char)32;
                          fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcd_id[(signed long int)(fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcdid_len + 1)] = (char)10;
                          fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcd_id, fstReaderIterBlocks2__1__2__1__11__1__2__1__2__1__2__1__vcdid_len + 2);
                        }

                    }

                    fstReaderIterBlocks2__1__2__1__11__1__skiplen = fstReaderIterBlocks2__1__2__1__11__1__skiplen + (signed int)len;
                    headptr[(signed long int)idx] = headptr[(signed long int)idx] + (unsigned int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                    length_remaining[(signed long int)idx] = length_remaining[(signed long int)idx] - (unsigned int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                    tc_head[(signed long int)i] = scatterptr[(signed long int)idx];
                    scatterptr[(signed long int)idx] = (unsigned int)0;
                    if(!(length_remaining[(signed long int)idx] == 0u))
                    {
                      fstReaderIterBlocks2__1__2__1__11__1__vli=fstGetVarint32NoSkip(mem_for_traversal + (signed long int)headptr[(signed long int)idx]);
                      fstReaderIterBlocks2__1__2__1__11__1__tdelta = fstReaderIterBlocks2__1__2__1__11__1__vli >> 1;
                      scatterptr[(signed long int)idx] = tc_head[(signed long int)(i + fstReaderIterBlocks2__1__2__1__11__1__tdelta)];
                      tc_head[(signed long int)(i + fstReaderIterBlocks2__1__2__1__11__1__tdelta)] = idx + (unsigned int)1;
                    }

                  }
                }

                else
                {
                  unsigned int fstReaderIterBlocks2__1__2__1__11__1__2__2__len = xc->signal_lens[(signed long int)idx];
                  unsigned char *fstReaderIterBlocks2__1__2__1__11__1__2__2__vdata;
                  fstReaderIterBlocks2__1__2__1__11__1__vli=fstGetVarint32(mem_for_traversal + (signed long int)headptr[(signed long int)idx], &fstReaderIterBlocks2__1__2__1__11__1__skiplen);
                  fstReaderIterBlocks2__1__2__1__11__1__2__2__vdata = mem_for_traversal + (signed long int)headptr[(signed long int)idx] + (signed long int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                  if(!((signed int)xc->signal_typs[(signed long int)idx] == FST_VT_VCD_REAL))
                  {
                    if((1u & fstReaderIterBlocks2__1__2__1__11__1__vli) == 0u)
                    {
                      signed int byte = 0;
                      signed int bit;
                      unsigned int fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j = (unsigned int)0;
                      for( ; !(fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j >= fstReaderIterBlocks2__1__2__1__11__1__2__2__len); fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j = fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j + 1u)
                      {
                        unsigned char ch;
                        byte = (signed int)(fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j / (unsigned int)8);
                        bit = (signed int)((unsigned int)7 - (fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j & (unsigned int)7));
                        ch = (unsigned char)((signed int)fstReaderIterBlocks2__1__2__1__11__1__2__2__vdata[(signed long int)byte] >> bit & 1 | 48);
                        xc->temp_signal_value_buf[(signed long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j] = ch;
                      }
                      xc->temp_signal_value_buf[(signed long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__j] = (unsigned char)0;
                      if(!(value_change_callback == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *))NULL)))
                        value_change_callback(user_callback_data_pointer, time_table[(signed long int)i], idx + (unsigned int)1, xc->temp_signal_value_buf);

                      else
                        if(!(fv == ((struct _IO_FILE *)NULL)))
                        {
                          unsigned char fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__3__1__ch_bp = (unsigned char)((signed int)xc->signal_typs[(signed long int)idx] != FST_VT_VCD_PORT ? 98 : 112);
                          fstWritex(xc, (void *)&fstReaderIterBlocks2__1__2__1__11__1__2__2__1__1__3__1__ch_bp, 1);
                          fstWritex(xc, (void *)xc->temp_signal_value_buf, (signed int)fstReaderIterBlocks2__1__2__1__11__1__2__2__len);
                        }

                      fstReaderIterBlocks2__1__2__1__11__1__2__2__len = (unsigned int)(byte + 1);
                    }

                    else
                      if(!(value_change_callback == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *))NULL)))
                      {
                        memcpy((void *)xc->temp_signal_value_buf, (const void *)fstReaderIterBlocks2__1__2__1__11__1__2__2__vdata, (unsigned long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__len);
                        xc->temp_signal_value_buf[(signed long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__len] = (unsigned char)0;
                        value_change_callback(user_callback_data_pointer, time_table[(signed long int)i], idx + (unsigned int)1, xc->temp_signal_value_buf);
                      }

                      else
                        if(!(fv == ((struct _IO_FILE *)NULL)))
                        {
                          unsigned char ch_bp = (unsigned char)((signed int)xc->signal_typs[(signed long int)idx] != FST_VT_VCD_PORT ? 98 : 112);
                          fstWritex(xc, (void *)&ch_bp, 1);
                          fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__11__1__2__2__vdata, (signed int)fstReaderIterBlocks2__1__2__1__11__1__2__2__len);
                        }

                  }

                  else
                  {
                    double d;
                    unsigned char *clone_d;
                    unsigned char buf[8l];
                    unsigned char *srcdata;
                    if((1u & fstReaderIterBlocks2__1__2__1__11__1__vli) == 0u)
                    {
                      signed int fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__bit;
                      signed int fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__j = 0;
                      for( ; !(fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__j >= 8); fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__j = fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__j + 1)
                      {
                        unsigned char fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__1__1__ch;
                        fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__bit = 7 - (fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__j & 7);
                        fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__1__1__ch = (unsigned char)((signed int)fstReaderIterBlocks2__1__2__1__11__1__2__2__vdata[(signed long int)0] >> fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__bit & 1 | 48);
                        buf[(signed long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__j] = fstReaderIterBlocks2__1__2__1__11__1__2__2__2__1__1__1__ch;
                      }
                      fstReaderIterBlocks2__1__2__1__11__1__2__2__len = (unsigned int)1;
                      srcdata = buf;
                    }

                    else
                      srcdata = fstReaderIterBlocks2__1__2__1__11__1__2__2__vdata;
                    if(!(value_change_callback == ((void (*)(void *, unsigned long int, unsigned int, const unsigned char *))NULL)))
                    {
                      if(!(xc->native_doubles_for_cb == 0u))
                      {
                        if(!(xc->double_endian_match == 0u))
                          clone_d = srcdata;

                        else
                        {
                          signed int fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__1__2__j;
                          clone_d = (unsigned char *)&d;
                          fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__1__2__j = 0;
                          for( ; !(fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__1__2__j >= 8); fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__1__2__j = fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__1__2__j + 1)
                            clone_d[(signed long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__1__2__j] = srcdata[(signed long int)(7 - fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__1__2__j)];
                        }
                        value_change_callback(user_callback_data_pointer, time_table[(signed long int)i], idx + (unsigned int)1, clone_d);
                      }

                      else
                      {
                        clone_d = (unsigned char *)&d;
                        if(!(xc->double_endian_match == 0u))
                          memcpy((void *)clone_d, (const void *)srcdata, (unsigned long int)8);

                        else
                        {
                          signed int fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__2__2__j = 0;
                          for( ; !(fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__2__2__j >= 8); fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__2__2__j = fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__2__2__j + 1)
                            clone_d[(signed long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__2__2__j] = srcdata[(signed long int)(7 - fstReaderIterBlocks2__1__2__1__11__1__2__2__2__3__2__2__j)];
                        }
                        sprintf((char *)xc->temp_signal_value_buf, "%.16g", d);
                        value_change_callback(user_callback_data_pointer, time_table[(signed long int)i], idx + (unsigned int)1, xc->temp_signal_value_buf);
                      }
                    }

                    else
                      if(!(fv == ((struct _IO_FILE *)NULL)))
                      {
                        char fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__wx_buf[32l];
                        signed int fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__wx_len;
                        clone_d = (unsigned char *)&d;
                        if(!(xc->double_endian_match == 0u))
                          memcpy((void *)clone_d, (const void *)srcdata, (unsigned long int)8);

                        else
                        {
                          signed int fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__2__j = 0;
                          for( ; !(fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__2__j >= 8); fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__2__j = fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__2__j + 1)
                            clone_d[(signed long int)fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__2__j] = srcdata[(signed long int)(7 - fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__2__j)];
                        }
                        fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__wx_len=sprintf(fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__wx_buf, "r%.16g", d);
                        fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__wx_buf, fstReaderIterBlocks2__1__2__1__11__1__2__2__2__4__1__wx_len);
                      }

                  }
                  if(!(fv == ((struct _IO_FILE *)NULL)))
                  {
                    char fstReaderIterBlocks2__1__2__1__11__1__2__2__3__vcd_id[16l];
                    signed int vcdid_len;
                    vcdid_len=fstVcdIDForFwrite(fstReaderIterBlocks2__1__2__1__11__1__2__2__3__vcd_id + (signed long int)1, idx + (unsigned int)1);
                    fstReaderIterBlocks2__1__2__1__11__1__2__2__3__vcd_id[(signed long int)0] = (char)32;
                    fstReaderIterBlocks2__1__2__1__11__1__2__2__3__vcd_id[(signed long int)(vcdid_len + 1)] = (char)10;
                    fstWritex(xc, (void *)fstReaderIterBlocks2__1__2__1__11__1__2__2__3__vcd_id, vcdid_len + 2);
                  }

                  fstReaderIterBlocks2__1__2__1__11__1__skiplen = fstReaderIterBlocks2__1__2__1__11__1__skiplen + (signed int)fstReaderIterBlocks2__1__2__1__11__1__2__2__len;
                  headptr[(signed long int)idx] = headptr[(signed long int)idx] + (unsigned int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                  length_remaining[(signed long int)idx] = length_remaining[(signed long int)idx] - (unsigned int)fstReaderIterBlocks2__1__2__1__11__1__skiplen;
                  tc_head[(signed long int)i] = scatterptr[(signed long int)idx];
                  scatterptr[(signed long int)idx] = (unsigned int)0;
                  if(!(length_remaining[(signed long int)idx] == 0u))
                  {
                    fstReaderIterBlocks2__1__2__1__11__1__vli=fstGetVarint32NoSkip(mem_for_traversal + (signed long int)headptr[(signed long int)idx]);
                    fstReaderIterBlocks2__1__2__1__11__1__tdelta = fstReaderIterBlocks2__1__2__1__11__1__vli >> 1;
                    scatterptr[(signed long int)idx] = tc_head[(signed long int)(i + fstReaderIterBlocks2__1__2__1__11__1__tdelta)];
                    tc_head[(signed long int)(i + fstReaderIterBlocks2__1__2__1__11__1__tdelta)] = idx + (unsigned int)1;
                  }

                }
              }
            }
          }

        }


      block_err:
        ;
        free((void *)tc_head);
        free((void *)chain_cmem);
        free((void *)mem_for_traversal);
        mem_for_traversal = (unsigned char *)(void *)0;
        secnum = secnum + 1u;
        if((unsigned long int)secnum == xc->vc_section_count)
          break;

        blkpos = blkpos + (signed long int)seclen;
      }
    }
    while((_Bool)1);
    if(!(mem_for_traversal == ((unsigned char *)NULL)))
      free((void *)mem_for_traversal);

    free((void *)length_remaining);
    free((void *)headptr);
    free((void *)scatterptr);
    if(!(chain_table == ((signed long int *)NULL)))
      free((void *)chain_table);

    if(!(chain_table_lengths == ((unsigned int *)NULL)))
      free((void *)chain_table_lengths);

    free((void *)time_table);
    if(!(fv == ((struct _IO_FILE *)NULL)))
      fstWritex(xc, (void *)0, 0);

    return 1;
  }
}

// fstReaderIterBlocksSetNativeDoublesOnCallback
// file ./../../src/helpers/fst/fstapi.c line 3556
void fstReaderIterBlocksSetNativeDoublesOnCallback(void *ctx, signed int enable)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    xc->native_doubles_for_cb = (unsigned int)(enable != 0);

}

// fstReaderIterateHier
// file ./../../src/helpers/fst/fstapi.h line 395
struct fstHier * fstReaderIterateHier(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed int isfeof;
  unsigned int alias;
  char *pnt;
  signed int ch;
  signed int return_value_fgetc_2;
  char *tmp_post_3;
  char *tmp_post_4;
  signed int return_value_fgetc_5;
  signed int return_value_fgetc_6;
  char *tmp_post_7;
  _Bool tmp_if_expr_8;
  signed int return_value_fgetc_9;
  char *tmp_post_10;
  struct fstHier *tmp_if_expr_11;
  if(xc == ((struct fstReaderContext *)NULL))
    return (struct fstHier *)(void *)0;

  else
  {
    if(xc->fh == ((struct _IO_FILE *)NULL))
    {
      signed int return_value_fstReaderRecreateHierFile_1;
      return_value_fstReaderRecreateHierFile_1=fstReaderRecreateHierFile(xc);
      if(return_value_fstReaderRecreateHierFile_1 == 0)
        return (struct fstHier *)(void *)0;

    }

    if(!(xc->do_rewind == 0u))
    {
      xc->do_rewind = (unsigned int)0;
      xc->current_handle = (unsigned int)0;
      fstReaderFseeko(xc, xc->fh, (signed long int)0, 0);
      clearerr(xc->fh);
    }

    isfeof=feof(xc->fh);
    if(isfeof == 0)
    {
      signed int tag;
      tag=fgetc(xc->fh);
      switch(tag)
      {
        case FST_ST_VCD_SCOPE:
        {
          xc->hier.htyp = (unsigned char)0;
          return_value_fgetc_2=fgetc(xc->fh);
          xc->hier.u.scope.typ = (unsigned char)return_value_fgetc_2;
          pnt = xc->str_scope_nam;
          xc->hier.u.scope.name = pnt;
          do
          {
            ch=fgetc(xc->fh);
            if(ch == 0)
              break;

            tmp_post_3 = pnt;
            pnt = pnt + 1l;
            *tmp_post_3 = (char)ch;
          }
          while((_Bool)1);
          *pnt = (char)0;
          xc->hier.u.scope.name_length = (unsigned int)(pnt - xc->hier.u.scope.name);
          pnt = xc->str_scope_comp;
          xc->hier.u.scope.component = pnt;
          do
          {
            ch=fgetc(xc->fh);
            if(ch == 0)
              break;

            tmp_post_4 = pnt;
            pnt = pnt + 1l;
            *tmp_post_4 = (char)ch;
          }
          while((_Bool)1);
          *pnt = (char)0;
          xc->hier.u.scope.component_length = (unsigned int)(pnt - xc->hier.u.scope.component);
          break;
        }
        case FST_ST_VCD_UPSCOPE:
        {
          xc->hier.htyp = (unsigned char)1;
          break;
        }
        case FST_ST_GEN_ATTRBEGIN:
        {
          xc->hier.htyp = (unsigned char)3;
          return_value_fgetc_5=fgetc(xc->fh);
          xc->hier.u.attr.typ = (unsigned char)return_value_fgetc_5;
          return_value_fgetc_6=fgetc(xc->fh);
          xc->hier.u.attr.subtype = (unsigned char)return_value_fgetc_6;
          pnt = xc->str_scope_nam;
          xc->hier.u.attr.name = pnt;
          do
          {
            ch=fgetc(xc->fh);
            if(ch == 0)
              break;

            tmp_post_7 = pnt;
            pnt = pnt + 1l;
            *tmp_post_7 = (char)ch;
          }
          while((_Bool)1);
          *pnt = (char)0;
          xc->hier.u.attr.name_length = (unsigned int)(pnt - xc->hier.u.scope.name);
          xc->hier.u.attr.arg=fstReaderVarint64(xc->fh);
          if((signed int)xc->hier.u.attr.typ == FST_AT_MISC)
          {
            if((signed int)xc->hier.u.attr.subtype == 4)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = (signed int)xc->hier.u.attr.subtype == 5 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_8)
            {
              signed int sidx_skiplen_dummy = 0;
              xc->hier.u.attr.arg_from_name=fstGetVarint64((unsigned char *)xc->str_scope_nam, &sidx_skiplen_dummy);
            }

          }

          break;
        }
        case FST_ST_GEN_ATTREND:
        {
          xc->hier.htyp = (unsigned char)4;
          break;
        }
        case FST_VT_VCD_EVENT:

        case FST_VT_VCD_INTEGER:

        case FST_VT_VCD_PARAMETER:

        case FST_VT_VCD_REAL:

        case FST_VT_VCD_REAL_PARAMETER:

        case FST_VT_VCD_REG:

        case FST_VT_VCD_SUPPLY0:

        case FST_VT_VCD_SUPPLY1:

        case FST_VT_VCD_TIME:

        case FST_VT_VCD_TRI:

        case FST_VT_VCD_TRIAND:

        case FST_VT_VCD_TRIOR:

        case FST_VT_VCD_TRIREG:

        case FST_VT_VCD_TRI0:

        case FST_VT_VCD_TRI1:

        case FST_VT_VCD_WAND:

        case FST_VT_VCD_WIRE:

        case FST_VT_VCD_WOR:

        case FST_VT_VCD_PORT:

        case FST_VT_VCD_SPARRAY:

        case FST_VT_VCD_REALTIME:

        case FST_VT_GEN_STRING:

        case FST_VT_SV_BIT:

        case FST_VT_SV_LOGIC:

        case FST_VT_SV_INT:

        case FST_VT_SV_SHORTINT:

        case FST_VT_SV_LONGINT:

        case FST_VT_SV_BYTE:

        case FST_VT_SV_ENUM:

        case FST_VT_SV_SHORTREAL:
        {
          xc->hier.htyp = (unsigned char)2;
          xc->hier.u.var.svt_workspace = (unsigned char)FST_SVT_NONE;
          xc->hier.u.var.sdt_workspace = (unsigned char)FST_SDT_NONE;
          xc->hier.u.var.sxt_workspace = (unsigned int)0;
          xc->hier.u.var.typ = (unsigned char)tag;
          return_value_fgetc_9=fgetc(xc->fh);
          xc->hier.u.var.direction = (unsigned char)return_value_fgetc_9;
          pnt = xc->str_scope_nam;
          xc->hier.u.var.name = pnt;
          do
          {
            ch=fgetc(xc->fh);
            if(ch == 0)
              break;

            tmp_post_10 = pnt;
            pnt = pnt + 1l;
            *tmp_post_10 = (char)ch;
          }
          while((_Bool)1);
          *pnt = (char)0;
          xc->hier.u.var.name_length = (unsigned int)(pnt - xc->hier.u.var.name);
          xc->hier.u.var.length=fstReaderVarint32(xc->fh);
          if(tag == FST_VT_VCD_PORT)
          {
            xc->hier.u.var.length = xc->hier.u.var.length - (unsigned int)2;
            xc->hier.u.var.length = xc->hier.u.var.length / (unsigned int)3;
          }

          alias=fstReaderVarint32(xc->fh);
          if(alias == 0u)
          {
            xc->current_handle = xc->current_handle + 1u;
            xc->hier.u.var.handle = xc->current_handle;
            xc->hier.u.var.is_alias = (unsigned int)0;
          }

          else
          {
            xc->hier.u.var.handle = alias;
            xc->hier.u.var.is_alias = (unsigned int)1;
          }
          break;
        }
        default:
          isfeof = 1;
      }
    }

    if(isfeof == 0)
      tmp_if_expr_11 = &xc->hier;

    else
      tmp_if_expr_11 = (struct fstHier *)(void *)0;
    return tmp_if_expr_11;
  }
}

// fstReaderIterateHierRewind
// file ./../../src/helpers/fst/fstapi.h line 396
signed int fstReaderIterateHierRewind(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed int pass_status = 0;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    pass_status = 1;
    if(xc->fh == ((struct _IO_FILE *)NULL))
      pass_status=fstReaderRecreateHierFile(xc);

    xc->do_rewind = (unsigned int)1;
  }

  return pass_status;
}

// fstReaderOpen
// file ./../../src/helpers/fst/fstapi.c line 4549
void * fstReaderOpen(const char *nam)
{
  struct fstReaderContext *xc;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct fstReaderContext) /*67248ul*/ );
  xc = (struct fstReaderContext *)return_value_calloc_1;
  _Bool tmp_if_expr_9;
  if(nam == ((const char *)NULL))
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    xc->f=fopen(nam, "rb");
    tmp_if_expr_9 = !(xc->f != ((struct _IO_FILE *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_9)
  {
    free((void *)xc);
    xc = (struct fstReaderContext *)(void *)0;
  }

  else
  {
    signed int flen;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(nam);
    flen = (signed int)return_value_strlen_2;
    char *hf;
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)(flen + 6));
    hf = (char *)return_value_calloc_3;
    signed int rc;
    memcpy((void *)hf, (const void *)nam, (unsigned long int)flen);
    strcpy(hf + (signed long int)flen, ".hier");
    xc->fh=fopen(hf, "rb");
    free((void *)hf);
    xc->filename=strdup(nam);
    rc=fstReaderInit(xc);
    if(!(rc == 0))
      tmp_if_expr_4 = xc->vc_section_count != 0ul ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = xc->maxhandle != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      if(!(xc->fh == ((struct _IO_FILE *)NULL)))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        if(!(xc->contains_hier_section == 0u))
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = xc->contains_hier_section_lz4 != 0u ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
      xc->do_rewind = (unsigned int)1;

    else
    {
      fstReaderClose((void *)xc);
      xc = (struct fstReaderContext *)(void *)0;
    }
  }
  return (void *)xc;
}

// fstReaderOpenForUtilitiesOnly
// file ./../../src/helpers/fst/fstapi.c line 4541
void * fstReaderOpenForUtilitiesOnly(void)
{
  struct fstReaderContext *xc;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct fstReaderContext) /*67248ul*/ );
  xc = (struct fstReaderContext *)return_value_calloc_1;
  return (void *)xc;
}

// fstReaderPopScope
// file ./../../src/helpers/fst/fstapi.h line 407
const char * fstReaderPopScope(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  char *tmp_if_expr_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    if(!(xc->curr_hier == ((struct fstCurrHier *)NULL)))
    {
      struct fstCurrHier *ch = xc->curr_hier;
      if(!(xc->curr_hier->prev == ((struct fstCurrHier *)NULL)))
        xc->curr_flat_hier_nam[(signed long int)xc->curr_hier->prev->len] = (char)0;

      else
        *xc->curr_flat_hier_nam = (char)0;
      xc->curr_hier = xc->curr_hier->prev;
      free((void *)ch);
      if(!(xc->curr_flat_hier_nam == ((char *)NULL)))
        tmp_if_expr_1 = xc->curr_flat_hier_nam;

      else
        tmp_if_expr_1 = "";
      return tmp_if_expr_1;
    }

  }

  return (const char *)(void *)0;
}

// fstReaderProcessHier
// file ./../../src/helpers/fst/fstapi.c line 3940
signed int fstReaderProcessHier(void *ctx, struct _IO_FILE *fv)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  char *str;
  char *pnt;
  signed int ch;
  signed int scopetype;
  signed int vartype;
  unsigned int len;
  unsigned int alias;
  unsigned int num_signal_dyn = (unsigned int)65536;
  signed int attrtype;
  signed int subtype;
  unsigned long int attrarg;
  unsigned int maxhandle_scanbuild;
  signed int return_value_feof_5;
  char *tmp_post_6;
  signed int return_value_fgetc_7;
  char *tmp_post_8;
  char *tmp_post_9;
  unsigned int tmp_if_expr_12;
  if(xc == ((struct fstReaderContext *)NULL))
    return 0;

  else
  {
    xc->longest_signal_value_len = (unsigned int)32;
    if(xc->fh == ((struct _IO_FILE *)NULL))
    {
      signed int return_value_fstReaderRecreateHierFile_1;
      return_value_fstReaderRecreateHierFile_1=fstReaderRecreateHierFile(xc);
      if(return_value_fstReaderRecreateHierFile_1 == 0)
        return 0;

    }

    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(65536 + 4096 + 1));
    str = (char *)return_value_malloc_2;
    if(!(fv == ((struct _IO_FILE *)NULL)))
    {
      char time_dimension[2l] = { (char)0, (char)0 };
      signed int time_scale = 1;
      fprintf(fv, "_date\n\t%s\n_end\n", (const void *)xc->date);
      fprintf(fv, "_version\n\t%s\n_end\n", (const void *)xc->version);
      if(!(xc->timezero == 0l))
        fprintf(fv, "_timezero\n\t%ld\n_end\n", xc->timezero);

      if(!((signed int)xc->timescale == 2))
      {
        if((signed int)xc->timescale == 1)
          goto __CPROVER_DUMP_L6;

        if((signed int)xc->timescale == 0)
          goto __CPROVER_DUMP_L7;

        if((signed int)xc->timescale == -1)
          goto __CPROVER_DUMP_L8;

        if((signed int)xc->timescale == -2)
          goto __CPROVER_DUMP_L9;

        if((signed int)xc->timescale == -3)
          goto __CPROVER_DUMP_L10;

        if((signed int)xc->timescale == -4)
          goto __CPROVER_DUMP_L11;

        if((signed int)xc->timescale == -5)
          goto __CPROVER_DUMP_L12;

        if((signed int)xc->timescale == -6)
          goto __CPROVER_DUMP_L13;

        if((signed int)xc->timescale == -10)
          goto __CPROVER_DUMP_L14;

        if((signed int)xc->timescale == -11)
          goto __CPROVER_DUMP_L15;

        if((signed int)xc->timescale == -12)
          goto __CPROVER_DUMP_L16;

        if((signed int)xc->timescale == -13)
          goto __CPROVER_DUMP_L17;

        if((signed int)xc->timescale == -14)
          goto __CPROVER_DUMP_L18;

        if((signed int)xc->timescale == -15)
          goto __CPROVER_DUMP_L19;

        if((signed int)xc->timescale == -16)
          goto __CPROVER_DUMP_L20;

        if((signed int)xc->timescale == -17)
          goto __CPROVER_DUMP_L21;

        if((signed int)xc->timescale == -18)
          goto __CPROVER_DUMP_L22;

        if((signed int)xc->timescale == -19)
          goto __CPROVER_DUMP_L23;

        if((signed int)xc->timescale == -20)
          goto __CPROVER_DUMP_L24;

        if((signed int)xc->timescale == -21)
          goto __CPROVER_DUMP_L25;

        if((signed int)xc->timescale == -7)
          goto __CPROVER_DUMP_L26;

        if((signed int)xc->timescale == -8)
          goto __CPROVER_DUMP_L27;

        if((signed int)xc->timescale == -9)
          goto __CPROVER_DUMP_L28;

      }

      else
      {
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)0;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L6:
        ;
        time_scale = 10;

      __CPROVER_DUMP_L7:
        ;
        time_dimension[(signed long int)0] = (char)0;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L8:
        ;
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)109;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L9:
        ;
        time_scale = 10;

      __CPROVER_DUMP_L10:
        ;
        time_dimension[(signed long int)0] = (char)109;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L11:
        ;
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)117;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L12:
        ;
        time_scale = 10;

      __CPROVER_DUMP_L13:
        ;
        time_dimension[(signed long int)0] = (char)117;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L14:
        ;
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)112;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L15:
        ;
        time_scale = 10;

      __CPROVER_DUMP_L16:
        ;
        time_dimension[(signed long int)0] = (char)112;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L17:
        ;
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)102;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L18:
        ;
        time_scale = 10;

      __CPROVER_DUMP_L19:
        ;
        time_dimension[(signed long int)0] = (char)102;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L20:
        ;
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)97;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L21:
        ;
        time_scale = 10;

      __CPROVER_DUMP_L22:
        ;
        time_dimension[(signed long int)0] = (char)97;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L23:
        ;
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)122;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L24:
        ;
        time_scale = 10;

      __CPROVER_DUMP_L25:
        ;
        time_dimension[(signed long int)0] = (char)122;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L26:
        ;
        time_scale = 100;
        time_dimension[(signed long int)0] = (char)110;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L27:
        ;
        time_scale = 10;
      }

    __CPROVER_DUMP_L28:
      ;
      time_dimension[(signed long int)0] = (char)110;

    __CPROVER_DUMP_L29:
      ;
      if(!(fv == ((struct _IO_FILE *)NULL)))
        fprintf(fv, "_timescale\n\t%d%ss\n_end\n", time_scale, (const void *)time_dimension);

    }

    xc->maxhandle = (unsigned int)0;
    xc->num_alias = (unsigned long int)0;
    free((void *)xc->signal_lens);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)num_signal_dyn * sizeof(unsigned int) /*4ul*/ );
    xc->signal_lens = (unsigned int *)return_value_malloc_3;
    free((void *)xc->signal_typs);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)num_signal_dyn * sizeof(unsigned char) /*1ul*/ );
    xc->signal_typs = (unsigned char *)return_value_malloc_4;
    fstReaderFseeko(xc, xc->fh, (signed long int)0, 0);
    do
    {
      return_value_feof_5=feof(xc->fh);
      if(!(return_value_feof_5 == 0))
        break;

      signed int tag;
      tag=fgetc(xc->fh);
      switch(tag)
      {
        case FST_ST_VCD_SCOPE:
        {
          scopetype=fgetc(xc->fh);
          if(scopetype >= 22 || !(scopetype >= FST_ST_MIN))
            scopetype = FST_ST_VCD_MODULE;

          pnt = str;
          do
          {
            ch=fgetc(xc->fh);
            if(ch == 0)
              break;

            tmp_post_6 = pnt;
            pnt = pnt + 1l;
            *tmp_post_6 = (char)ch;
          }
          while((_Bool)1);
          *pnt = (char)0;
          do
          {
            return_value_fgetc_7=fgetc(xc->fh);
            if(return_value_fgetc_7 == 0)
              break;

          }
          while((_Bool)1);
          if(!(fv == ((struct _IO_FILE *)NULL)))
            fprintf(fv, "_scope %s %s _end\n", modtypes[(signed long int)scopetype], str);

          break;
        }
        case FST_ST_VCD_UPSCOPE:
        {
          if(!(fv == ((struct _IO_FILE *)NULL)))
            fprintf(fv, "_upscope _end\n");

          break;
        }
        case FST_ST_GEN_ATTRBEGIN:
        {
          attrtype=fgetc(xc->fh);
          subtype=fgetc(xc->fh);
          pnt = str;
          do
          {
            ch=fgetc(xc->fh);
            if(ch == 0)
              break;

            tmp_post_8 = pnt;
            pnt = pnt + 1l;
            *tmp_post_8 = (char)ch;
          }
          while((_Bool)1);
          *pnt = (char)0;
          if(*str == 0)
            strcpy(str, "\"\"");

          attrarg=fstReaderVarint64(xc->fh);
          if(!(fv == ((struct _IO_FILE *)NULL)))
          {
            if(!(xc->use_vcd_extensions == 0u))
              switch(attrtype)
              {
                case FST_AT_ARRAY:
                {
                  if(subtype >= 4 || !(subtype >= 0))
                    subtype = 0;

                  fprintf(fv, "_attrbegin %s %s %s %ld _end\n", attrtypes[(signed long int)attrtype], arraytypes[(signed long int)subtype], str, attrarg);
                  break;
                }
                case FST_AT_ENUM:
                {
                  if(subtype >= 14 || !(subtype >= 0))
                    subtype = 0;

                  fprintf(fv, "_attrbegin %s %s %s %ld _end\n", attrtypes[(signed long int)attrtype], enumvaluetypes[(signed long int)subtype], str, attrarg);
                  break;
                }
                case FST_AT_PACK:
                {
                  if(subtype >= 4 || !(subtype >= 0))
                    subtype = 0;

                  fprintf(fv, "_attrbegin %s %s %s %ld _end\n", attrtypes[(signed long int)attrtype], packtypes[(signed long int)subtype], str, attrarg);
                  break;
                }
                case FST_AT_MISC:

                default:
                {
                  attrtype = FST_AT_MISC;
                  if(subtype == 0)
                    fprintf(fv, "_comment\n\t%s\n_end\n", str);

                  else
                    if(subtype == 4 || subtype == 5)
                    {
                      signed int sidx_skiplen_dummy = 0;
                      unsigned long int sidx;
                      sidx=fstGetVarint64((unsigned char *)str, &sidx_skiplen_dummy);
                      fprintf(fv, "_attrbegin %s %02x %ld %ld _end\n", attrtypes[(signed long int)attrtype], subtype, sidx, attrarg);
                    }

                    else
                      fprintf(fv, "_attrbegin %s %02x %s %ld _end\n", attrtypes[(signed long int)attrtype], subtype, str, attrarg);
                }
              }

          }

          break;
        }
        case FST_ST_GEN_ATTREND:
        {
          if(!(fv == ((struct _IO_FILE *)NULL)))
          {
            if(!(xc->use_vcd_extensions == 0u))
              fprintf(fv, "_attrend _end\n");

          }

          break;
        }
        case FST_VT_VCD_EVENT:

        case FST_VT_VCD_INTEGER:

        case FST_VT_VCD_PARAMETER:

        case FST_VT_VCD_REAL:

        case FST_VT_VCD_REAL_PARAMETER:

        case FST_VT_VCD_REG:

        case FST_VT_VCD_SUPPLY0:

        case FST_VT_VCD_SUPPLY1:

        case FST_VT_VCD_TIME:

        case FST_VT_VCD_TRI:

        case FST_VT_VCD_TRIAND:

        case FST_VT_VCD_TRIOR:

        case FST_VT_VCD_TRIREG:

        case FST_VT_VCD_TRI0:

        case FST_VT_VCD_TRI1:

        case FST_VT_VCD_WAND:

        case FST_VT_VCD_WIRE:

        case FST_VT_VCD_WOR:

        case FST_VT_VCD_PORT:

        case FST_VT_VCD_SPARRAY:

        case FST_VT_VCD_REALTIME:

        case FST_VT_GEN_STRING:

        case FST_VT_SV_BIT:

        case FST_VT_SV_LOGIC:

        case FST_VT_SV_INT:

        case FST_VT_SV_SHORTINT:

        case FST_VT_SV_LONGINT:

        case FST_VT_SV_BYTE:

        case FST_VT_SV_ENUM:

        case FST_VT_SV_SHORTREAL:
        {
          vartype = tag;
          fgetc(xc->fh);
          pnt = str;
          do
          {
            ch=fgetc(xc->fh);
            if(ch == 0)
              break;

            tmp_post_9 = pnt;
            pnt = pnt + 1l;
            *tmp_post_9 = (char)ch;
          }
          while((_Bool)1);
          *pnt = (char)0;
          len=fstReaderVarint32(xc->fh);
          alias=fstReaderVarint32(xc->fh);
          if(alias == 0u)
          {
            if(xc->maxhandle == num_signal_dyn)
            {
              num_signal_dyn = num_signal_dyn * (unsigned int)2;
              void *return_value_realloc_10;
              return_value_realloc_10=realloc((void *)xc->signal_lens, (unsigned long int)num_signal_dyn * sizeof(unsigned int) /*4ul*/ );
              xc->signal_lens = (unsigned int *)return_value_realloc_10;
              void *return_value_realloc_11;
              return_value_realloc_11=realloc((void *)xc->signal_typs, (unsigned long int)num_signal_dyn * sizeof(unsigned char) /*1ul*/ );
              xc->signal_typs = (unsigned char *)return_value_realloc_11;
            }

            xc->signal_lens[(signed long int)xc->maxhandle] = len;
            xc->signal_typs[(signed long int)xc->maxhandle] = (unsigned char)vartype;
            if(!(xc->longest_signal_value_len >= len))
              xc->longest_signal_value_len = len;

            if(vartype == FST_VT_VCD_REAL || vartype == FST_VT_VCD_REAL_PARAMETER || vartype == FST_VT_VCD_REALTIME || vartype == FST_VT_SV_SHORTREAL)
            {
              len = (unsigned int)(vartype != FST_VT_SV_SHORTREAL ? 64 : 32);
              xc->signal_typs[(signed long int)xc->maxhandle] = (unsigned char)FST_VT_VCD_REAL;
            }

            if(!(fv == ((struct _IO_FILE *)NULL)))
            {
              char vcdid_buf[16l];
              unsigned int modlen = vartype != FST_VT_VCD_PORT ? len : (len - (unsigned int)2) / (unsigned int)3;
              fstVcdID(vcdid_buf, xc->maxhandle + (unsigned int)1);
              fprintf(fv, "_var %s %u %s %s _end\n", vartypes[(signed long int)vartype], modlen, (const void *)vcdid_buf, str);
            }

            xc->maxhandle = xc->maxhandle + 1u;
          }

          else
          {
            if(vartype == FST_VT_VCD_REAL || vartype == FST_VT_VCD_REAL_PARAMETER || vartype == FST_VT_VCD_REALTIME || vartype == FST_VT_SV_SHORTREAL)
            {
              len = (unsigned int)(vartype != FST_VT_SV_SHORTREAL ? 64 : 32);
              xc->signal_typs[(signed long int)xc->maxhandle] = (unsigned char)FST_VT_VCD_REAL;
            }

            if(!(fv == ((struct _IO_FILE *)NULL)))
            {
              char fstReaderProcessHier__1__3__1__8__2__vcdid_buf[16l];
              unsigned int fstReaderProcessHier__1__3__1__8__2__modlen = vartype != FST_VT_VCD_PORT ? len : (len - (unsigned int)2) / (unsigned int)3;
              fstVcdID(fstReaderProcessHier__1__3__1__8__2__vcdid_buf, alias);
              fprintf(fv, "_var %s %u %s %s _end\n", vartypes[(signed long int)vartype], fstReaderProcessHier__1__3__1__8__2__modlen, (const void *)fstReaderProcessHier__1__3__1__8__2__vcdid_buf, str);
            }

            xc->num_alias = xc->num_alias + 1ul;
          }
          break;
        }
        default:
          ;
      }
    }
    while((_Bool)1);
    if(!(fv == ((struct _IO_FILE *)NULL)))
      fprintf(fv, "_enddefinitions _end\n");

    if(!(xc->maxhandle == 0u))
      tmp_if_expr_12 = xc->maxhandle;

    else
      tmp_if_expr_12 = (unsigned int)1;
    maxhandle_scanbuild = tmp_if_expr_12;
    void *return_value_realloc_13;
    return_value_realloc_13=realloc((void *)xc->signal_lens, (unsigned long int)maxhandle_scanbuild * sizeof(unsigned int) /*4ul*/ );
    xc->signal_lens = (unsigned int *)return_value_realloc_13;
    void *return_value_realloc_14;
    return_value_realloc_14=realloc((void *)xc->signal_typs, (unsigned long int)maxhandle_scanbuild * sizeof(unsigned char) /*1ul*/ );
    xc->signal_typs = (unsigned char *)return_value_realloc_14;
    free((void *)xc->process_mask);
    void *return_value_calloc_15;
    return_value_calloc_15=calloc((unsigned long int)1, (unsigned long int)((maxhandle_scanbuild + (unsigned int)7) / (unsigned int)8));
    xc->process_mask = (unsigned char *)return_value_calloc_15;
    free((void *)xc->temp_signal_value_buf);
    void *return_value_malloc_16;
    return_value_malloc_16=malloc((unsigned long int)(xc->longest_signal_value_len + (unsigned int)1));
    xc->temp_signal_value_buf = (unsigned char *)return_value_malloc_16;
    xc->var_count = (unsigned long int)xc->maxhandle + xc->num_alias;
    free((void *)str);
    return 1;
  }
}

// fstReaderPushScope
// file ./../../src/helpers/fst/fstapi.h line 409
const char * fstReaderPushScope(void *ctx, const char *nam, void *user_info)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  signed int tmp_if_expr_2;
  void *tmp_if_expr_6;
  void *return_value_realloc_4;
  void *return_value_malloc_5;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    struct fstCurrHier *ch;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct fstCurrHier) /*24ul*/ );
    ch = (struct fstCurrHier *)return_value_malloc_1;
    signed int chl;
    if(!(xc->curr_hier == ((struct fstCurrHier *)NULL)))
      tmp_if_expr_2 = xc->curr_hier->len;

    else
      tmp_if_expr_2 = 0;
    chl = tmp_if_expr_2;
    signed int len;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(nam);
    len = (signed int)((unsigned long int)(chl + 1) + return_value_strlen_3);
    if(len >= xc->flat_hier_alloc_len)
    {
      if(!(xc->curr_flat_hier_nam == ((char *)NULL)))
      {
        return_value_realloc_4=realloc((void *)xc->curr_flat_hier_nam, (unsigned long int)(len + 1));
        tmp_if_expr_6 = return_value_realloc_4;
      }

      else
      {
        return_value_malloc_5=malloc((unsigned long int)(len + 1));
        tmp_if_expr_6 = return_value_malloc_5;
      }
      xc->curr_flat_hier_nam = (char *)tmp_if_expr_6;
    }

    if(!(chl == 0))
    {
      xc->curr_flat_hier_nam[(signed long int)chl] = (char)46;
      strcpy(xc->curr_flat_hier_nam + (signed long int)chl + (signed long int)1, nam);
    }

    else
    {
      strcpy(xc->curr_flat_hier_nam, nam);
      len = len - 1;
    }
    ch->len = len;
    ch->prev = xc->curr_hier;
    ch->user_info = user_info;
    xc->curr_hier = ch;
    return xc->curr_flat_hier_nam;
  }

  return (const char *)(void *)0;
}

// fstReaderRecreateHierFile
// file ./../../src/helpers/fst/fstapi.c line 3599
static signed int fstReaderRecreateHierFile(struct fstReaderContext *xc)
{
  signed int pass_status = 1;
  _Bool tmp_if_expr_4;
  if(xc->fh == ((struct _IO_FILE *)NULL))
  {
    signed long int offs_cache;
    offs_cache=ftello(xc->f);
    char *fnam;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(xc->filename);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)6 + (unsigned long int)16 + (unsigned long int)32 + (unsigned long int)1);
    fnam = (char *)return_value_malloc_2;
    unsigned char *mem;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)32768);
    mem = (unsigned char *)return_value_malloc_3;
    signed long int hl;
    signed long int uclen;
    signed long int clen = (signed long int)0;
    struct gzFile_s *zhandle = (struct gzFile_s *)(void *)0;
    signed int zfd;
    signed int htyp = 255;
    if(xc->contains_hier_section_lz4 == 0u)
      tmp_if_expr_4 = xc->contains_hier_section != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      htyp = 4;

    else
      if(!(xc->contains_hier_section_lz4 == 0u))
      {
        if(xc->contains_hier_section == 0u)
          htyp = xc->contains_hier_section_lz4duo != 0u ? 7 : 6;

      }

    signed int return_value_getpid_5;
    return_value_getpid_5=getpid();
    sprintf(fnam, "%s.hier_%d_%p", xc->filename, return_value_getpid_5, (void *)xc);
    fstReaderFseeko(xc, xc->f, xc->hier_pos, 0);
    unsigned long int return_value_fstReaderUint64_6;
    return_value_fstReaderUint64_6=fstReaderUint64(xc->f);
    uclen = (signed long int)return_value_fstReaderUint64_6;
    fflush(xc->f);
    if(htyp == 4)
    {
      fstReaderFseeko(xc, xc->f, xc->hier_pos, 0);
      unsigned long int return_value_fstReaderUint64_7;
      return_value_fstReaderUint64_7=fstReaderUint64(xc->f);
      uclen = (signed long int)return_value_fstReaderUint64_7;
      fflush(xc->f);
      signed int return_value_fileno_8;
      return_value_fileno_8=fileno(xc->f);
      zfd=dup(return_value_fileno_8);
      zhandle=gzdopen(zfd, "rb");
      if(zhandle == ((struct gzFile_s *)NULL))
      {
        close(zfd);
        free((void *)mem);
        free((void *)fnam);
        return 0;
      }

    }

    else
      if(htyp == 6 || htyp == 7)
      {
        fstReaderFseeko(xc, xc->f, xc->hier_pos - (signed long int)8, 0);
        unsigned long int return_value_fstReaderUint64_9;
        return_value_fstReaderUint64_9=fstReaderUint64(xc->f);
        clen = (signed long int)(return_value_fstReaderUint64_9 - (unsigned long int)16);
        unsigned long int return_value_fstReaderUint64_10;
        return_value_fstReaderUint64_10=fstReaderUint64(xc->f);
        uclen = (signed long int)return_value_fstReaderUint64_10;
        fflush(xc->f);
      }

    xc->fh=fopen(fnam, "w+b");
    if(xc->fh == ((struct _IO_FILE *)NULL))
    {
      xc->fh=tmpfile_open(&xc->fh_nam);
      free((void *)fnam);
      fnam = (char *)(void *)0;
      if(xc->fh == ((struct _IO_FILE *)NULL))
      {
        tmpfile_close(&xc->fh, &xc->fh_nam);
        free((void *)mem);
        return 0;
      }

    }

    if(!(fnam == ((char *)NULL)))
      unlink(fnam);

    if(htyp == 4)
    {
      hl = (signed long int)0;
      for( ; !(hl >= uclen); hl = hl + (signed long int)32768)
      {
        unsigned long int len = (unsigned long int)(uclen - hl > (signed long int)32768 ? (signed long int)32768 : uclen - hl);
        unsigned long int gzreadlen;
        signed int return_value_gzread_11;
        return_value_gzread_11=gzread(zhandle, (void *)mem, (unsigned int)len);
        gzreadlen = (unsigned long int)return_value_gzread_11;
        unsigned long int fwlen;
        if(!(gzreadlen == len))
        {
          pass_status = 0;
          break;
        }

        fwlen=fstFwrite((const void *)mem, len, (unsigned long int)1, xc->fh);
        if(!(fwlen == 1ul))
        {
          pass_status = 0;
          break;
        }

      }
      gzclose(zhandle);
    }

    else
      if(htyp == 7)
      {
        unsigned char *fstReaderRecreateHierFile__1__1__7__lz4_cmem;
        void *return_value_malloc_12;
        return_value_malloc_12=malloc((unsigned long int)clen);
        fstReaderRecreateHierFile__1__1__7__lz4_cmem = (unsigned char *)return_value_malloc_12;
        unsigned char *fstReaderRecreateHierFile__1__1__7__lz4_ucmem;
        void *return_value_malloc_13;
        return_value_malloc_13=malloc((unsigned long int)uclen);
        fstReaderRecreateHierFile__1__1__7__lz4_ucmem = (unsigned char *)return_value_malloc_13;
        unsigned char *lz4_ucmem2;
        unsigned long int uclen2;
        signed int skiplen2 = 0;
        fstFread((void *)fstReaderRecreateHierFile__1__1__7__lz4_cmem, (unsigned long int)clen, (unsigned long int)1, xc->f);
        uclen2=fstGetVarint64(fstReaderRecreateHierFile__1__1__7__lz4_cmem, &skiplen2);
        void *return_value_malloc_14;
        return_value_malloc_14=malloc(uclen2);
        lz4_ucmem2 = (unsigned char *)return_value_malloc_14;
        signed int return_value_LZ4_decompress_safe_partial_15;
        return_value_LZ4_decompress_safe_partial_15=LZ4_decompress_safe_partial((char *)fstReaderRecreateHierFile__1__1__7__lz4_cmem + (signed long int)skiplen2, (char *)lz4_ucmem2, (signed int)(clen - (signed long int)skiplen2), (signed int)uclen2, (signed int)uclen2);
        pass_status = (signed int)(uclen2 == (unsigned long int)return_value_LZ4_decompress_safe_partial_15);
        if(!(pass_status == 0))
        {
          signed int return_value_LZ4_decompress_safe_partial_16;
          return_value_LZ4_decompress_safe_partial_16=LZ4_decompress_safe_partial((char *)lz4_ucmem2, (char *)fstReaderRecreateHierFile__1__1__7__lz4_ucmem, (signed int)uclen2, (signed int)uclen, (signed int)uclen);
          pass_status = (signed int)(uclen == (signed long int)return_value_LZ4_decompress_safe_partial_16);
          unsigned long int return_value_fstFwrite_17;
          return_value_fstFwrite_17=fstFwrite((const void *)fstReaderRecreateHierFile__1__1__7__lz4_ucmem, (unsigned long int)uclen, (unsigned long int)1, xc->fh);
          if(!(return_value_fstFwrite_17 == 1ul))
            pass_status = 0;

        }

        free((void *)lz4_ucmem2);
        free((void *)fstReaderRecreateHierFile__1__1__7__lz4_ucmem);
        free((void *)fstReaderRecreateHierFile__1__1__7__lz4_cmem);
      }

      else
        if(htyp == 6)
        {
          unsigned char *lz4_cmem;
          void *return_value_malloc_18;
          return_value_malloc_18=malloc((unsigned long int)clen);
          lz4_cmem = (unsigned char *)return_value_malloc_18;
          unsigned char *lz4_ucmem;
          void *return_value_malloc_19;
          return_value_malloc_19=malloc((unsigned long int)uclen);
          lz4_ucmem = (unsigned char *)return_value_malloc_19;
          fstFread((void *)lz4_cmem, (unsigned long int)clen, (unsigned long int)1, xc->f);
          signed int return_value_LZ4_decompress_safe_partial_20;
          return_value_LZ4_decompress_safe_partial_20=LZ4_decompress_safe_partial((char *)lz4_cmem, (char *)lz4_ucmem, (signed int)clen, (signed int)uclen, (signed int)uclen);
          pass_status = (signed int)(uclen == (signed long int)return_value_LZ4_decompress_safe_partial_20);
          unsigned long int return_value_fstFwrite_21;
          return_value_fstFwrite_21=fstFwrite((const void *)lz4_ucmem, (unsigned long int)uclen, (unsigned long int)1, xc->fh);
          if(!(return_value_fstFwrite_21 == 1ul))
            pass_status = 0;

          free((void *)lz4_ucmem);
          free((void *)lz4_cmem);
        }

        else
          pass_status = 0;
    free((void *)mem);
    free((void *)fnam);
    fstReaderFseeko(xc, xc->f, offs_cache, 0);
  }

  return pass_status;
}

// fstReaderResetScope
// file ./../../src/helpers/fst/fstapi.h line 410
void fstReaderResetScope(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  const char *return_value_fstReaderPopScope_1;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    do
    {
      return_value_fstReaderPopScope_1=fstReaderPopScope((void *)xc);
      if(return_value_fstReaderPopScope_1 == ((const char *)NULL))
        break;

    }
    while((_Bool)1);

}

// fstReaderSetFacProcessMask
// file ./../../src/helpers/fst/fstapi.c line 3325
void fstReaderSetFacProcessMask(void *ctx, unsigned int facidx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    facidx = facidx - 1u;
    if(!(facidx >= xc->maxhandle))
    {
      signed int idx = (signed int)(facidx / (unsigned int)8);
      signed int bitpos = (signed int)(facidx & (unsigned int)7);
      xc->process_mask[(signed long int)idx] = xc->process_mask[(signed long int)idx] | (unsigned char)(1 << bitpos);
    }

  }

}

// fstReaderSetFacProcessMaskAll
// file ./../../src/helpers/fst/fstapi.c line 3361
void fstReaderSetFacProcessMaskAll(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    memset((void *)xc->process_mask, 0xff, (unsigned long int)((xc->maxhandle + (unsigned int)7) / (unsigned int)8));

}

// fstReaderSetLimitTimeRange
// file ./../../src/helpers/fst/fstapi.c line 3521
void fstReaderSetLimitTimeRange(void *ctx, unsigned long int start_time, unsigned long int end_time)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
  {
    xc->limit_range_valid = (unsigned int)1;
    xc->limit_range_start = start_time;
    xc->limit_range_end = end_time;
  }

}

// fstReaderSetUnlimitedTimeRange
// file ./../../src/helpers/fst/fstapi.c line 3534
void fstReaderSetUnlimitedTimeRange(void *ctx)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    xc->limit_range_valid = (unsigned int)0;

}

// fstReaderSetVcdExtensions
// file ./../../src/helpers/fst/fstapi.c line 3545
void fstReaderSetVcdExtensions(void *ctx, signed int enable)
{
  struct fstReaderContext *xc = (struct fstReaderContext *)ctx;
  if(!(xc == ((struct fstReaderContext *)NULL)))
    xc->use_vcd_extensions = (unsigned int)(enable != 0);

}

// fstReaderUint64
// file ./../../src/helpers/fst/fstapi.c line 379
static unsigned long int fstReaderUint64(struct _IO_FILE *f)
{
  unsigned long int val = (unsigned long int)0;
  unsigned char buf[(signed long int)sizeof(unsigned long int) /*8l*/ ];
  unsigned int i;
  fstFread((void *)buf, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, f);
  i = (unsigned int)0;
  for( ; !((unsigned long int)i >= sizeof(unsigned long int) /*8ul*/ ); i = i + 1u)
  {
    val = val << 8;
    val = val | (unsigned long int)buf[(signed long int)i];
  }
  return val;
}

// fstReaderVarint32
// file ./../../src/helpers/fst/fstapi.c line 526
static unsigned int fstReaderVarint32(struct _IO_FILE *f)
{
  unsigned char buf[5l];
  unsigned char *mem = buf;
  unsigned int rc = (unsigned int)0;
  signed int ch;
  unsigned char *tmp_post_1;
  do
  {
    ch=fgetc(f);
    tmp_post_1 = mem;
    mem = mem + 1l;
    *tmp_post_1 = (unsigned char)ch;
  }
  while(!((0x80 & ch) == 0));
  mem = mem - 1l;
  do
  {
    rc = rc << 7;
    rc = rc | (unsigned int)((signed int)*mem & 0x7f);
    if(mem == buf)
      break;

    mem = mem - 1l;
  }
  while((_Bool)1);
  return rc;
}

// fstReaderVarint32WithSkip
// file ./../../src/helpers/fst/fstapi.c line 555
static unsigned int fstReaderVarint32WithSkip(struct _IO_FILE *f, unsigned int *skiplen)
{
  unsigned char buf[5l];
  unsigned char *mem = buf;
  unsigned int rc = (unsigned int)0;
  signed int ch;
  unsigned char *tmp_post_1;
  do
  {
    ch=fgetc(f);
    tmp_post_1 = mem;
    mem = mem + 1l;
    *tmp_post_1 = (unsigned char)ch;
  }
  while(!((0x80 & ch) == 0));
  *skiplen = (unsigned int)(mem - buf);
  mem = mem - 1l;
  do
  {
    rc = rc << 7;
    rc = rc | (unsigned int)((signed int)*mem & 0x7f);
    if(mem == buf)
      break;

    mem = mem - 1l;
  }
  while((_Bool)1);
  return rc;
}

// fstReaderVarint64
// file ./../../src/helpers/fst/fstapi.c line 585
static unsigned long int fstReaderVarint64(struct _IO_FILE *f)
{
  unsigned char buf[16l];
  unsigned char *mem = buf;
  unsigned long int rc = (unsigned long int)0;
  signed int ch;
  unsigned char *tmp_post_1;
  do
  {
    ch=fgetc(f);
    tmp_post_1 = mem;
    mem = mem + 1l;
    *tmp_post_1 = (unsigned char)ch;
  }
  while(!((0x80 & ch) == 0));
  mem = mem - 1l;
  do
  {
    rc = rc << 7;
    rc = rc | (unsigned long int)((signed int)*mem & 0x7f);
    if(mem == buf)
      break;

    mem = mem - 1l;
  }
  while((_Bool)1);
  return rc;
}

// fstRealpath
// file ./../../src/helpers/fst/fstapi.c line 279
static char * fstRealpath(const char *path, char *resolved_path)
{
  char *return_value_realpath_1;
  return_value_realpath_1=realpath(path, resolved_path);
  return return_value_realpath_1;
}

// fstUtilityBinToEsc
// file ./../../src/helpers/fst/fstapi.c line 6439
signed int fstUtilityBinToEsc(unsigned char *d, unsigned char *s, signed int len)
{
  unsigned char *src = s;
  unsigned char *dst = d;
  unsigned char val;
  signed int i = 0;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  unsigned char *tmp_post_19;
  unsigned char *tmp_post_20;
  unsigned char *tmp_post_21;
  unsigned char *tmp_post_22;
  _Bool tmp_if_expr_28;
  unsigned char *tmp_post_23;
  unsigned char *tmp_post_24;
  unsigned char *tmp_post_25;
  unsigned char *tmp_post_26;
  unsigned char *tmp_post_27;
  for( ; !(i >= len); i = i + 1)
    switch((signed int)src[(signed long int)i])
    {
      case 7:
      {
        tmp_post_1 = dst;
        dst = dst + 1l;
        *tmp_post_1 = (unsigned char)92;
        tmp_post_2 = dst;
        dst = dst + 1l;
        *tmp_post_2 = (unsigned char)97;
        break;
      }
      case 8:
      {
        tmp_post_3 = dst;
        dst = dst + 1l;
        *tmp_post_3 = (unsigned char)92;
        tmp_post_4 = dst;
        dst = dst + 1l;
        *tmp_post_4 = (unsigned char)98;
        break;
      }
      case 12:
      {
        tmp_post_5 = dst;
        dst = dst + 1l;
        *tmp_post_5 = (unsigned char)92;
        tmp_post_6 = dst;
        dst = dst + 1l;
        *tmp_post_6 = (unsigned char)102;
        break;
      }
      case 10:
      {
        tmp_post_7 = dst;
        dst = dst + 1l;
        *tmp_post_7 = (unsigned char)92;
        tmp_post_8 = dst;
        dst = dst + 1l;
        *tmp_post_8 = (unsigned char)110;
        break;
      }
      case 13:
      {
        tmp_post_9 = dst;
        dst = dst + 1l;
        *tmp_post_9 = (unsigned char)92;
        tmp_post_10 = dst;
        dst = dst + 1l;
        *tmp_post_10 = (unsigned char)114;
        break;
      }
      case 9:
      {
        tmp_post_11 = dst;
        dst = dst + 1l;
        *tmp_post_11 = (unsigned char)92;
        tmp_post_12 = dst;
        dst = dst + 1l;
        *tmp_post_12 = (unsigned char)116;
        break;
      }
      case 11:
      {
        tmp_post_13 = dst;
        dst = dst + 1l;
        *tmp_post_13 = (unsigned char)92;
        tmp_post_14 = dst;
        dst = dst + 1l;
        *tmp_post_14 = (unsigned char)118;
        break;
      }
      case 39:
      {
        tmp_post_15 = dst;
        dst = dst + 1l;
        *tmp_post_15 = (unsigned char)92;
        tmp_post_16 = dst;
        dst = dst + 1l;
        *tmp_post_16 = (unsigned char)39;
        break;
      }
      case 34:
      {
        tmp_post_17 = dst;
        dst = dst + 1l;
        *tmp_post_17 = (unsigned char)92;
        tmp_post_18 = dst;
        dst = dst + 1l;
        *tmp_post_18 = (unsigned char)34;
        break;
      }
      case 92:
      {
        tmp_post_19 = dst;
        dst = dst + 1l;
        *tmp_post_19 = (unsigned char)92;
        tmp_post_20 = dst;
        dst = dst + 1l;
        *tmp_post_20 = (unsigned char)92;
        break;
      }
      case 63:
      {
        tmp_post_21 = dst;
        dst = dst + 1l;
        *tmp_post_21 = (unsigned char)92;
        tmp_post_22 = dst;
        dst = dst + 1l;
        *tmp_post_22 = (unsigned char)63;
        break;
      }
      default:
      {
        if((signed int)src[(signed long int)i] >= 33)
          tmp_if_expr_28 = (signed int)src[(signed long int)i] <= 126 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_28 = (_Bool)0;
        if(tmp_if_expr_28)
        {
          tmp_post_23 = dst;
          dst = dst + 1l;
          *tmp_post_23 = src[(signed long int)i];
        }

        else
        {
          val = src[(signed long int)i];
          tmp_post_24 = dst;
          dst = dst + 1l;
          *tmp_post_24 = (unsigned char)92;
          tmp_post_25 = dst;
          dst = dst + 1l;
          *tmp_post_25 = (unsigned char)((signed int)val / 64 + 48);
          val = (unsigned char)((signed int)val & 63);
          tmp_post_26 = dst;
          dst = dst + 1l;
          *tmp_post_26 = (unsigned char)((signed int)val / 8 + 48);
          val = (unsigned char)((signed int)val & 7);
          tmp_post_27 = dst;
          dst = dst + 1l;
          *tmp_post_27 = (unsigned char)((signed int)val + 48);
        }
      }
    }
  return (signed int)(dst - d);
}

// fstUtilityEscToBin
// file ./../../src/helpers/fst/fstapi.c line 6484
signed int fstUtilityEscToBin(unsigned char *d, unsigned char *s, signed int len)
{
  unsigned char *src = s;
  unsigned char *dst;
  unsigned char *tmp_if_expr_1;
  if(d == ((unsigned char *)NULL))
    tmp_if_expr_1 = s;

  else
  {
    s = d;
    tmp_if_expr_1 = s;
  }
  dst = tmp_if_expr_1;
  unsigned char val[3l];
  signed int i = 0;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  signed int return_value_toupper_14;
  signed int return_value_toupper_15;
  _Bool tmp_if_expr_16;
  signed int tmp_if_expr_17;
  _Bool tmp_if_expr_18;
  signed int tmp_if_expr_19;
  unsigned char *tmp_post_20;
  unsigned char *tmp_post_21;
  unsigned char *tmp_post_22;
  for( ; !(i >= len); i = i + 1)
    if(!((signed int)src[(signed long int)i] == 92))
    {
      tmp_post_2 = dst;
      dst = dst + 1l;
      *tmp_post_2 = src[(signed long int)i];
    }

    else
    {
      i = i + 1;
      switch((signed int)src[(signed long int)i])
      {
        case 97:
        {
          tmp_post_3 = dst;
          dst = dst + 1l;
          *tmp_post_3 = (unsigned char)7;
          break;
        }
        case 98:
        {
          tmp_post_4 = dst;
          dst = dst + 1l;
          *tmp_post_4 = (unsigned char)8;
          break;
        }
        case 102:
        {
          tmp_post_5 = dst;
          dst = dst + 1l;
          *tmp_post_5 = (unsigned char)12;
          break;
        }
        case 110:
        {
          tmp_post_6 = dst;
          dst = dst + 1l;
          *tmp_post_6 = (unsigned char)10;
          break;
        }
        case 114:
        {
          tmp_post_7 = dst;
          dst = dst + 1l;
          *tmp_post_7 = (unsigned char)13;
          break;
        }
        case 116:
        {
          tmp_post_8 = dst;
          dst = dst + 1l;
          *tmp_post_8 = (unsigned char)9;
          break;
        }
        case 118:
        {
          tmp_post_9 = dst;
          dst = dst + 1l;
          *tmp_post_9 = (unsigned char)11;
          break;
        }
        case 39:
        {
          tmp_post_10 = dst;
          dst = dst + 1l;
          *tmp_post_10 = (unsigned char)39;
          break;
        }
        case 34:
        {
          tmp_post_11 = dst;
          dst = dst + 1l;
          *tmp_post_11 = (unsigned char)34;
          break;
        }
        case 92:
        {
          tmp_post_12 = dst;
          dst = dst + 1l;
          *tmp_post_12 = (unsigned char)92;
          break;
        }
        case 63:
        {
          tmp_post_13 = dst;
          dst = dst + 1l;
          *tmp_post_13 = (unsigned char)63;
          break;
        }
        case 120:
        {
          i = i + 1;
          return_value_toupper_14=toupper((signed int)src[(signed long int)i]);
          val[(signed long int)0] = (unsigned char)return_value_toupper_14;
          i = i + 1;
          return_value_toupper_15=toupper((signed int)src[(signed long int)i]);
          val[(signed long int)1] = (unsigned char)return_value_toupper_15;
          if((signed int)val[0l] >= 65)
            tmp_if_expr_16 = (signed int)val[(signed long int)0] <= 70 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_16 = (_Bool)0;
          if(tmp_if_expr_16)
            tmp_if_expr_17 = ((signed int)val[(signed long int)0] - 65) + 10;

          else
            tmp_if_expr_17 = (signed int)val[(signed long int)0] - 48;
          val[(signed long int)0] = (unsigned char)tmp_if_expr_17;
          if((signed int)val[1l] >= 65)
            tmp_if_expr_18 = (signed int)val[(signed long int)1] <= 70 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_18 = (_Bool)0;
          if(tmp_if_expr_18)
            tmp_if_expr_19 = ((signed int)val[(signed long int)1] - 65) + 10;

          else
            tmp_if_expr_19 = (signed int)val[(signed long int)1] - 48;
          val[(signed long int)1] = (unsigned char)tmp_if_expr_19;
          tmp_post_20 = dst;
          dst = dst + 1l;
          *tmp_post_20 = (unsigned char)((signed int)val[(signed long int)0] * 16 + (signed int)val[(signed long int)1]);
          break;
        }
        case 48:

        case 49:

        case 50:

        case 51:

        case 52:

        case 53:

        case 54:

        case 55:
        {
          val[(signed long int)0] = (unsigned char)((signed int)src[(signed long int)i] - 48);
          i = i + 1;
          val[(signed long int)1] = (unsigned char)((signed int)src[(signed long int)i] - 48);
          i = i + 1;
          val[(signed long int)2] = (unsigned char)((signed int)src[(signed long int)i] - 48);
          tmp_post_21 = dst;
          dst = dst + 1l;
          *tmp_post_21 = (unsigned char)((signed int)val[(signed long int)0] * 64 + (signed int)val[(signed long int)1] * 8 + (signed int)val[(signed long int)2]);
          break;
        }
        default:
        {
          tmp_post_22 = dst;
          dst = dst + 1l;
          *tmp_post_22 = src[(signed long int)i];
        }
      }
    }
  return (signed int)(dst - s);
}

// fstVcdID
// file ./../../src/helpers/fst/fstapi.c line 3568
static void fstVcdID(char *buf, unsigned int value)
{
  char *pnt = buf;
  char *tmp_post_1;
  for( ; !(value == 0u); value = value / (unsigned int)94)
  {
    value = value - 1u;
    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = (char)((unsigned int)33 + value % (unsigned int)94);
  }
  *pnt = (char)0;
}

// fstVcdIDForFwrite
// file ./../../src/helpers/fst/fstapi.c line 3583
static signed int fstVcdIDForFwrite(char *buf, unsigned int value)
{
  char *pnt = buf;
  char *tmp_post_1;
  for( ; !(value == 0u); value = value / (unsigned int)94)
  {
    value = value - 1u;
    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = (char)((unsigned int)33 + value % (unsigned int)94);
  }
  return (signed int)(pnt - buf);
}

// fstWriterClose
// file ./../../src/helpers/fst/fstapi.c line 1857
void fstWriterClose(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    pthread_mutex_lock(&xc->mutex);
    pthread_mutex_unlock(&xc->mutex);
  }

  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  signed long int tmp_if_expr_13;
  _Bool tmp_if_expr_17;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    if(xc->already_in_close == 0)
    {
      if(xc->already_in_flush == 0)
      {
        unsigned char *tmem;
        signed long int fixup_offs;
        signed long int tlen;
        signed long int hlen;
        xc->already_in_close = (unsigned char)1;
        if(!(xc->section_header_only == 0u))
          tmp_if_expr_2 = xc->section_header_truncpos != 0l ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = xc->vchg_siz <= (unsigned int)1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = !(xc->is_initial_time != 0u) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          signed int return_value_fileno_1;
          return_value_fileno_1=fileno(xc->handle);
          fstFtruncate(return_value_fileno_1, xc->section_header_truncpos);
          fstWriterFseeko(xc, xc->handle, xc->section_header_truncpos, 0);
          xc->section_header_only = (unsigned int)0;
        }

        else
        {
          xc->skip_writing_section_hdr = (unsigned int)1;
          if(xc->size_limit_locked == 0u)
          {
            if(!(xc->is_initial_time == 0u))
            {
              unsigned int dupe_idx;
              fstWriterEmitTimeChange((void *)xc, (unsigned long int)0);
              dupe_idx = (unsigned int)0;
              for( ; !(dupe_idx >= xc->maxhandle); dupe_idx = dupe_idx + 1u)
                fstWriterEmitValueChange((void *)xc, dupe_idx + (unsigned int)1, (const void *)(xc->curval_mem + (signed long int)xc->valpos_mem[(signed long int)((unsigned int)4 * dupe_idx)]));
            }

            fstWriterFlushContextPrivate((void *)xc);
            pthread_mutex_lock(&xc->mutex);
            pthread_mutex_unlock(&xc->mutex);
          }

        }
        fstDestroyMmaps(xc, 1);
        fflush(xc->geom_handle);
        tlen=ftello(xc->geom_handle);
        signed int return_value_fileno_5;
        return_value_fileno_5=fileno(xc->geom_handle);
        void *return_value_mmap_6;
        return_value_mmap_6=mmap((void *)0, (unsigned long int)tlen, 0x1 | 0x2, 0x01, return_value_fileno_5, (signed long int)0);
        tmem = (unsigned char *)(void *)return_value_mmap_6;
        if(!(tmem == ((unsigned char *)NULL)))
        {
          unsigned long int destlen = (unsigned long int)tlen;
          unsigned char *dmem;
          unsigned long int return_value_compressBound_7;
          return_value_compressBound_7=compressBound(destlen);
          void *return_value_malloc_8;
          return_value_malloc_8=malloc(return_value_compressBound_7);
          dmem = (unsigned char *)return_value_malloc_8;
          signed int rc;
          rc=compress2(dmem, &destlen, tmem, (unsigned long int)tlen, 9);
          if(!(rc == 0) || !(tlen >= (signed long int)destlen))
            destlen = (unsigned long int)tlen;

          fixup_offs=ftello(xc->handle);
          fputc(255, xc->handle);
          fstWriterUint64(xc->handle, destlen + (unsigned long int)24);
          fstWriterUint64(xc->handle, (unsigned long int)tlen);
          fstWriterUint64(xc->handle, (unsigned long int)xc->maxhandle);
          fstFwrite((const void *)((signed long int)destlen != tlen ? dmem : tmem), destlen, (unsigned long int)1, xc->handle);
          fflush(xc->handle);
          fstWriterFseeko(xc, xc->handle, fixup_offs, 0);
          fputc(3, xc->handle);
          fstWriterFseeko(xc, xc->handle, (signed long int)0, 2);
          fflush(xc->handle);
          free((void *)dmem);
          if(!(tmem == ((unsigned char *)NULL)))
            munmap((void *)tmem, (unsigned long int)tlen);

        }

        if(!(xc->num_blackouts == 0u))
        {
          unsigned long int cur_bl = (unsigned long int)0;
          signed long int bpos;
          signed long int eos;
          unsigned int i;
          fixup_offs=ftello(xc->handle);
          fputc(255, xc->handle);
          bpos = fixup_offs + (signed long int)1;
          fstWriterUint64(xc->handle, (unsigned long int)0);
          fstWriterVarint(xc->handle, (unsigned long int)xc->num_blackouts);
          i = (unsigned int)0;
          for( ; !(i >= xc->num_blackouts); i = i + 1u)
          {
            fputc((signed int)xc->blackout_head->active, xc->handle);
            fstWriterVarint(xc->handle, xc->blackout_head->tim - cur_bl);
            cur_bl = xc->blackout_head->tim;
            xc->blackout_curr = xc->blackout_head->next;
            free((void *)xc->blackout_head);
            xc->blackout_head = xc->blackout_curr;
          }
          eos=ftello(xc->handle);
          fstWriterFseeko(xc, xc->handle, bpos, 0);
          fstWriterUint64(xc->handle, (unsigned long int)(eos - bpos));
          fflush(xc->handle);
          fstWriterFseeko(xc, xc->handle, fixup_offs, 0);
          fputc(2, xc->handle);
          fstWriterFseeko(xc, xc->handle, (signed long int)0, 2);
          fflush(xc->handle);
        }

        if(!(xc->compress_hier == 0u))
        {
          signed long int hl;
          signed long int fstWriterClose__1__2__5__eos;
          struct gzFile_s *zhandle;
          signed int zfd;
          signed int fourpack_duo = 0;
          char *fnam;
          unsigned long int return_value_strlen_9;
          return_value_strlen_9=strlen(xc->filename);
          void *return_value_malloc_10;
          return_value_malloc_10=malloc(return_value_strlen_9 + (unsigned long int)5 + (unsigned long int)1);
          fnam = (char *)return_value_malloc_10;
          fixup_offs=ftello(xc->handle);
          fputc(255, xc->handle);
          hlen=ftello(xc->handle);
          fstWriterUint64(xc->handle, (unsigned long int)0);
          fstWriterUint64(xc->handle, (unsigned long int)xc->hier_file_len);
          if(xc->fourpack == 0u)
          {
            unsigned char *mem;
            void *return_value_malloc_11;
            return_value_malloc_11=malloc((unsigned long int)32768);
            mem = (unsigned char *)return_value_malloc_11;
            signed int return_value_fileno_12;
            return_value_fileno_12=fileno(xc->handle);
            zfd=dup(return_value_fileno_12);
            fflush(xc->handle);
            zhandle=gzdopen(zfd, "wb4");
            if(!(zhandle == ((struct gzFile_s *)NULL)))
            {
              fstWriterFseeko(xc, xc->hier_handle, (signed long int)0, 0);
              hl = (signed long int)0;
              for( ; !(hl >= xc->hier_file_len); hl = hl + (signed long int)32768)
              {
                unsigned int len;
                if(xc->hier_file_len + -hl >= 32769l)
                  tmp_if_expr_13 = (signed long int)32768;

                else
                  tmp_if_expr_13 = xc->hier_file_len - hl;
                len = (unsigned int)tmp_if_expr_13;
                fstFread((void *)mem, (unsigned long int)len, (unsigned long int)1, xc->hier_handle);
                gzwrite(zhandle, (const void *)mem, len);
              }
              gzclose(zhandle);
            }

            else
              close(zfd);
            free((void *)mem);
          }

          else
          {
            signed int lz4_maxlen;
            unsigned char *fstWriterClose__1__2__5__2__mem;
            unsigned char *hmem;
            signed int packed_len;
            fflush(xc->handle);
            lz4_maxlen=LZ4_compressBound((signed int)xc->hier_file_len);
            void *return_value_malloc_14;
            return_value_malloc_14=malloc((unsigned long int)lz4_maxlen);
            fstWriterClose__1__2__5__2__mem = (unsigned char *)return_value_malloc_14;
            signed int return_value_fileno_15;
            return_value_fileno_15=fileno(xc->hier_handle);
            void *return_value_mmap_16;
            return_value_mmap_16=mmap((void *)0, (unsigned long int)xc->hier_file_len, 0x1 | 0x2, 0x01, return_value_fileno_15, (signed long int)0);
            hmem = (unsigned char *)(void *)return_value_mmap_16;
            packed_len=LZ4_compress((char *)hmem, (char *)fstWriterClose__1__2__5__2__mem, (signed int)xc->hier_file_len);
            if(!(hmem == ((unsigned char *)NULL)))
              munmap((void *)hmem, (unsigned long int)xc->hier_file_len);

            if(xc->repack_on_close == 0u)
              tmp_if_expr_17 = xc->hier_file_len > (signed long int)(4 * 1024 * 1024) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_17 = (_Bool)0;
            fourpack_duo = (signed int)tmp_if_expr_17;
            if(!(fourpack_duo == 0))
            {
              unsigned char *mem_duo;
              signed int lz4_maxlen_duo;
              signed int packed_len_duo;
              lz4_maxlen_duo=LZ4_compressBound(packed_len);
              void *return_value_malloc_18;
              return_value_malloc_18=malloc((unsigned long int)lz4_maxlen_duo);
              mem_duo = (unsigned char *)return_value_malloc_18;
              packed_len_duo=LZ4_compress((char *)fstWriterClose__1__2__5__2__mem, (char *)mem_duo, packed_len);
              fstWriterVarint(xc->handle, (unsigned long int)packed_len);
              fstFwrite((const void *)mem_duo, (unsigned long int)packed_len_duo, (unsigned long int)1, xc->handle);
              free((void *)mem_duo);
            }

            else
              fstFwrite((const void *)fstWriterClose__1__2__5__2__mem, (unsigned long int)packed_len, (unsigned long int)1, xc->handle);
            free((void *)fstWriterClose__1__2__5__2__mem);
          }
          fstWriterFseeko(xc, xc->handle, (signed long int)0, 2);
          fstWriterClose__1__2__5__eos=ftello(xc->handle);
          fstWriterFseeko(xc, xc->handle, hlen, 0);
          fstWriterUint64(xc->handle, (unsigned long int)(fstWriterClose__1__2__5__eos - hlen));
          fflush(xc->handle);
          fstWriterFseeko(xc, xc->handle, fixup_offs, 0);
          fputc(xc->fourpack != 0u ? (fourpack_duo != 0 ? 7 : 6) : 4, xc->handle);
          fstWriterFseeko(xc, xc->handle, (signed long int)0, 2);
          fflush(xc->handle);
          sprintf(fnam, "%s.hier", xc->filename);
          unlink(fnam);
          free((void *)fnam);
        }

        fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8), 0);
        fstWriterUint64(xc->handle, xc->firsttime);
        fstWriterUint64(xc->handle, xc->curtime);
        fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8 + 8 + 8 + 8 + 8), 0);
        fstWriterUint64(xc->handle, (unsigned long int)xc->numscopes);
        fstWriterUint64(xc->handle, (unsigned long int)xc->numsigs);
        fstWriterUint64(xc->handle, (unsigned long int)xc->maxhandle);
        fstWriterUint64(xc->handle, (unsigned long int)xc->secnum);
        fflush(xc->handle);
        tmpfile_close(&xc->tchn_handle, &xc->tchn_handle_nam);
        free((void *)xc->vchg_mem);
        xc->vchg_mem = (unsigned char *)(void *)0;
        tmpfile_close(&xc->curval_handle, &xc->curval_handle_nam);
        tmpfile_close(&xc->valpos_handle, &xc->valpos_handle_nam);
        tmpfile_close(&xc->geom_handle, &xc->geom_handle_nam);
        if(!(xc->hier_handle == ((struct _IO_FILE *)NULL)))
        {
          fclose(xc->hier_handle);
          xc->hier_handle = (struct _IO_FILE *)(void *)0;
        }

        if(!(xc->handle == ((struct _IO_FILE *)NULL)))
        {
          if(!(xc->repack_on_close == 0u))
          {
            struct _IO_FILE *fp;
            signed long int offpnt;
            signed long int uclen;
            signed int flen;
            unsigned long int return_value_strlen_19;
            return_value_strlen_19=strlen(xc->filename);
            flen = (signed int)return_value_strlen_19;
            char *hf;
            void *return_value_calloc_20;
            return_value_calloc_20=calloc((unsigned long int)1, (unsigned long int)(flen + 5));
            hf = (char *)return_value_calloc_20;
            strcpy(hf, xc->filename);
            strcpy(hf + (signed long int)flen, ".pak");
            fp=fopen(hf, "wb");
            if(!(fp == ((struct _IO_FILE *)NULL)))
            {
              void *dsth;
              signed int fstWriterClose__1__2__7__1__1__zfd;
              char gz_membuf[32768l];
              fstWriterFseeko(xc, xc->handle, (signed long int)0, 2);
              uclen=ftello(xc->handle);
              fputc(254, fp);
              fstWriterUint64(fp, (unsigned long int)0);
              fstWriterUint64(fp, (unsigned long int)uclen);
              fflush(fp);
              fstWriterFseeko(xc, xc->handle, (signed long int)0, 0);
              signed int return_value_fileno_21;
              return_value_fileno_21=fileno(fp);
              fstWriterClose__1__2__7__1__1__zfd=dup(return_value_fileno_21);
              struct gzFile_s *return_value_gzdopen_22;
              return_value_gzdopen_22=gzdopen(fstWriterClose__1__2__7__1__1__zfd, "wb4");
              dsth = (void *)return_value_gzdopen_22;
              if(!(dsth == NULL))
              {
                offpnt = (signed long int)0;
                for( ; !(offpnt >= uclen); offpnt = offpnt + (signed long int)32768)
                {
                  unsigned long int this_len = (unsigned long int)(uclen - offpnt > (signed long int)32768 ? (signed long int)32768 : uclen - offpnt);
                  fstFread((void *)gz_membuf, this_len, (unsigned long int)1, xc->handle);
                  gzwrite((struct gzFile_s *)dsth, (const void *)gz_membuf, (unsigned int)this_len);
                }
                gzclose((struct gzFile_s *)dsth);
              }

              else
                close(fstWriterClose__1__2__7__1__1__zfd);
              fstWriterFseeko(xc, fp, (signed long int)0, 2);
              offpnt=ftello(fp);
              fstWriterFseeko(xc, fp, (signed long int)1, 0);
              fstWriterUint64(fp, (unsigned long int)(offpnt - (signed long int)1));
              fclose(fp);
              fclose(xc->handle);
              xc->handle = (struct _IO_FILE *)(void *)0;
              unlink(xc->filename);
              rename(hf, xc->filename);
            }

            else
            {
              xc->repack_on_close = (unsigned int)0;
              fclose(xc->handle);
              xc->handle = (struct _IO_FILE *)(void *)0;
            }
            free((void *)hf);
          }

          else
          {
            fclose(xc->handle);
            xc->handle = (struct _IO_FILE *)(void *)0;
          }
        }

        pthread_mutex_destroy(&xc->mutex);
        pthread_attr_destroy(&xc->thread_attr);
        if(!(xc->path_array == NULL))
          JudyHSFreeArray(&xc->path_array, (struct J_UDY_ERROR_STRUCT *)(void *)0);

        free((void *)xc->filename);
        xc->filename = (char *)(void *)0;
        free((void *)xc);
      }

    }

  }

}

// fstWriterCreate
// file ./../../src/helpers/fst/fstapi.c line 1105
void * fstWriterCreate(const char *nam, signed int use_compressed_hier)
{
  struct fstWriterContext *xc;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct fstWriterContext) /*432ul*/ );
  xc = (struct fstWriterContext *)return_value_calloc_1;
  xc->compress_hier = (unsigned int)use_compressed_hier;
  fstDetermineBreakSize(xc);
  _Bool tmp_if_expr_10;
  if(nam == ((const char *)NULL))
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    xc->handle=unlink_fopen(nam, "w+b");
    tmp_if_expr_10 = !(xc->handle != ((struct _IO_FILE *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  if(tmp_if_expr_10)
  {
    free((void *)xc);
    xc = (struct fstWriterContext *)(void *)0;
  }

  else
  {
    signed int flen;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(nam);
    flen = (signed int)return_value_strlen_2;
    char *hf;
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)(flen + 6));
    hf = (char *)return_value_calloc_3;
    memcpy((void *)hf, (const void *)nam, (unsigned long int)flen);
    strcpy(hf + (signed long int)flen, ".hier");
    xc->hier_handle=unlink_fopen(hf, "w+b");
    xc->geom_handle=tmpfile_open(&xc->geom_handle_nam);
    xc->valpos_handle=tmpfile_open(&xc->valpos_handle_nam);
    xc->curval_handle=tmpfile_open(&xc->curval_handle_nam);
    xc->tchn_handle=tmpfile_open(&xc->tchn_handle_nam);
    xc->vchg_alloc_siz = (unsigned int)(xc->fst_break_size + xc->fst_break_add_size);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)xc->vchg_alloc_siz);
    xc->vchg_mem = (unsigned char *)return_value_malloc_4;
    if(!(xc->hier_handle == ((struct _IO_FILE *)NULL)))
      tmp_if_expr_5 = xc->geom_handle != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = xc->valpos_handle != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
      tmp_if_expr_7 = xc->curval_handle != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_8 = xc->vchg_mem != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
      tmp_if_expr_9 = xc->tchn_handle != ((struct _IO_FILE *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
    {
      xc->filename=strdup(nam);
      xc->is_initial_time = (unsigned int)1;
      fstWriterEmitHdrBytes(xc);
      xc->nan=strtod("NaN", (char ** restrict )(void *)0);
      pthread_mutex_init(&xc->mutex, (const union anonymous_58 *)(void *)0);
      pthread_attr_init(&xc->thread_attr);
      pthread_attr_setdetachstate(&xc->thread_attr, 1);
    }

    else
    {
      fclose(xc->handle);
      if(!(xc->hier_handle == ((struct _IO_FILE *)NULL)))
      {
        fclose(xc->hier_handle);
        unlink(hf);
      }

      tmpfile_close(&xc->geom_handle, &xc->geom_handle_nam);
      tmpfile_close(&xc->valpos_handle, &xc->valpos_handle_nam);
      tmpfile_close(&xc->curval_handle, &xc->curval_handle_nam);
      tmpfile_close(&xc->tchn_handle, &xc->tchn_handle_nam);
      free((void *)xc->vchg_mem);
      free((void *)xc);
      xc = (struct fstWriterContext *)(void *)0;
    }
    free((void *)hf);
  }
  return (void *)xc;
}

// fstWriterCreateMmaps
// file ./../../src/helpers/fst/fstapi.c line 949
static void fstWriterCreateMmaps(struct fstWriterContext *xc)
{
  signed long int curpos;
  curpos=ftello(xc->handle);
  fflush(xc->hier_handle);
  fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8), 0);
  fstWriterUint64(xc->handle, xc->firsttime);
  fstWriterUint64(xc->handle, xc->curtime);
  fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8 + 8 + 8 + 8 + 8), 0);
  fstWriterUint64(xc->handle, (unsigned long int)xc->numscopes);
  fstWriterUint64(xc->handle, (unsigned long int)xc->numsigs);
  fstWriterUint64(xc->handle, (unsigned long int)xc->maxhandle);
  fstWriterUint64(xc->handle, (unsigned long int)xc->secnum);
  fstWriterFseeko(xc, xc->handle, curpos, 0);
  fflush(xc->handle);
  if(xc->valpos_mem == ((unsigned int *)NULL))
  {
    fflush(xc->valpos_handle);
    signed int return_value_fileno_1;
    return_value_fileno_1=fileno(xc->valpos_handle);
    void *return_value_mmap_2;
    return_value_mmap_2=mmap((void *)0, (unsigned long int)(xc->maxhandle * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ , 0x1 | 0x2, 0x01, return_value_fileno_1, (signed long int)0);
    xc->valpos_mem = (unsigned int *)(void *)return_value_mmap_2;
  }

  if(xc->curval_mem == ((unsigned char *)NULL))
  {
    fflush(xc->curval_handle);
    signed int return_value_fileno_3;
    return_value_fileno_3=fileno(xc->curval_handle);
    void *return_value_mmap_4;
    return_value_mmap_4=mmap((void *)0, (unsigned long int)xc->maxvalpos, 0x1 | 0x2, 0x01, return_value_fileno_3, (signed long int)0);
    xc->curval_mem = (unsigned char *)(void *)return_value_mmap_4;
  }

}

// fstWriterCreateVar
// file ./../../src/helpers/fst/fstapi.c line 2536
unsigned int fstWriterCreateVar(void *ctx, enum fstVarType vt, enum fstVarDir vd, unsigned int len, const char *nam, unsigned int aliasHandle)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  unsigned int i;
  signed int nlen;
  signed int is_real;
  if(!(nam == ((const char *)NULL)) && !(xc == ((struct fstWriterContext *)NULL)))
  {
    if(!(xc->valpos_mem == ((unsigned int *)NULL)))
      fstDestroyMmaps(xc, 0);

    fputc((signed int)vt, xc->hier_handle);
    fputc((signed int)vd, xc->hier_handle);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(nam);
    nlen = (signed int)return_value_strlen_1;
    fstFwrite((const void *)nam, (unsigned long int)nlen, (unsigned long int)1, xc->hier_handle);
    fputc(0, xc->hier_handle);
    xc->hier_file_len = xc->hier_file_len + (signed long int)(nlen + 3);
    if((signed int)vt == FST_VT_VCD_REAL || (signed int)vt == FST_VT_VCD_REAL_PARAMETER || (signed int)vt == FST_VT_VCD_REALTIME || (signed int)vt == FST_VT_SV_SHORTREAL)
    {
      is_real = 1;
      len = (unsigned int)8;
    }

    else
    {
      is_real = 0;
      if((signed int)vt == FST_VT_GEN_STRING)
        len = (unsigned int)0;

    }
    signed int return_value_fstWriterVarint_2;
    return_value_fstWriterVarint_2=fstWriterVarint(xc->hier_handle, (unsigned long int)len);
    xc->hier_file_len = xc->hier_file_len + (signed long int)return_value_fstWriterVarint_2;
    if(!(xc->maxhandle >= aliasHandle))
      aliasHandle = (unsigned int)0;

    signed int return_value_fstWriterVarint_3;
    return_value_fstWriterVarint_3=fstWriterVarint(xc->hier_handle, (unsigned long int)aliasHandle);
    xc->hier_file_len = xc->hier_file_len + (signed long int)return_value_fstWriterVarint_3;
    xc->numsigs = xc->numsigs + 1u;
    if(xc->numsigs == xc->next_huge_break)
    {
      if(!(xc->fst_break_size >= xc->fst_huge_break_size))
      {
        xc->next_huge_break = xc->next_huge_break + (unsigned int)1000000;
        xc->fst_break_size = xc->fst_break_size + xc->fst_orig_break_size;
        xc->fst_break_add_size = xc->fst_break_add_size + xc->fst_orig_break_add_size;
        xc->vchg_alloc_siz = (unsigned int)(xc->fst_break_size + xc->fst_break_add_size);
        if(!(xc->vchg_mem == ((unsigned char *)NULL)))
        {
          void *return_value_realloc_4;
          return_value_realloc_4=realloc((void *)xc->vchg_mem, (unsigned long int)xc->vchg_alloc_siz);
          xc->vchg_mem = (unsigned char *)return_value_realloc_4;
        }

      }

    }

    if(aliasHandle == 0u)
    {
      unsigned int zero = (unsigned int)0;
      if(!(len == 0u))
        fstWriterVarint(xc->geom_handle, (unsigned long int)(!(is_real != 0) ? len : (unsigned int)0));

      else
        fstWriterVarint(xc->geom_handle, (unsigned long int)0xFFFFFFFF);
      fstFwrite((const void *)&xc->maxvalpos, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, xc->valpos_handle);
      fstFwrite((const void *)&len, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, xc->valpos_handle);
      fstFwrite((const void *)&zero, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, xc->valpos_handle);
      fstFwrite((const void *)&zero, sizeof(unsigned int) /*4ul*/ , (unsigned long int)1, xc->valpos_handle);
      if(is_real == 0)
      {
        i = (unsigned int)0;
        for( ; !(i >= len); i = i + 1u)
          fputc(120, xc->curval_handle);
      }

      else
        fstFwrite((const void *)&xc->nan, (unsigned long int)8, (unsigned long int)1, xc->curval_handle);
      xc->maxvalpos = xc->maxvalpos + len;
      xc->maxhandle = xc->maxhandle + 1u;
      return xc->maxhandle;
    }

    else
      return aliasHandle;
  }

  return (unsigned int)0;
}

// fstWriterCreateVar2
// file ./../../src/helpers/fst/fstapi.c line 2527
unsigned int fstWriterCreateVar2(void *ctx, enum fstVarType vt, enum fstVarDir vd, unsigned int len, const char *nam, unsigned int aliasHandle, const char *type, enum fstSupplementalVarType svt, enum fstSupplementalDataType sdt)
{
  fstWriterSetAttrGeneric(ctx, type != ((const char *)NULL) ? type : "", 2, (unsigned long int)((signed int)svt << FST_SDT_SVT_SHIFT_COUNT | (signed int)sdt & FST_SDT_ABS_MAX));
  unsigned int return_value_fstWriterCreateVar_1;
  return_value_fstWriterCreateVar_1=fstWriterCreateVar(ctx, vt, vd, len, nam, aliasHandle);
  return return_value_fstWriterCreateVar_1;
}

// fstWriterEmitDumpActive
// file ./../../src/helpers/fst/fstapi.c line 2944
void fstWriterEmitDumpActive(void *ctx, signed int enable)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    struct fstBlackoutChain *b;
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct fstBlackoutChain) /*24ul*/ );
    b = (struct fstBlackoutChain *)return_value_calloc_1;
    b->tim = xc->curtime;
    b->active = (unsigned int)(enable != 0);
    xc->num_blackouts = xc->num_blackouts + 1u;
    if(!(xc->blackout_curr == ((struct fstBlackoutChain *)NULL)))
    {
      xc->blackout_curr->next = b;
      xc->blackout_curr = b;
    }

    else
    {
      xc->blackout_head = b;
      xc->blackout_curr = b;
    }
  }

}

// fstWriterEmitHdrBytes
// file ./../../src/helpers/fst/fstapi.c line 881
static void fstWriterEmitHdrBytes(struct fstWriterContext *xc)
{
  char vbuf[128l];
  char dbuf[119l];
  double endtest = 2.7182818284590452354;
  signed long int walltime;
  fputc(0, xc->handle);
  fstWriterUint64(xc->handle, (unsigned long int)329);
  fstWriterUint64(xc->handle, (unsigned long int)0);
  fstWriterUint64(xc->handle, (unsigned long int)0);
  fstFwrite((const void *)&endtest, (unsigned long int)8, (unsigned long int)1, xc->handle);
  fstWriterUint64(xc->handle, xc->fst_break_size);
  fstWriterUint64(xc->handle, (unsigned long int)0);
  fstWriterUint64(xc->handle, (unsigned long int)0);
  fstWriterUint64(xc->handle, (unsigned long int)0);
  fstWriterUint64(xc->handle, (unsigned long int)0);
  fputc(-9 & 255, xc->handle);
  memset((void *)vbuf, 0, (unsigned long int)128);
  strcpy(vbuf, "fstWriter");
  fstFwrite((const void *)vbuf, (unsigned long int)128, (unsigned long int)1, xc->handle);
  memset((void *)dbuf, 0, (unsigned long int)119);
  time(&walltime);
  struct tm *return_value_localtime_1;
  return_value_localtime_1=localtime(&walltime);
  char *return_value_asctime_2;
  return_value_asctime_2=asctime(return_value_localtime_1);
  strcpy(dbuf, return_value_asctime_2);
  fstFwrite((const void *)dbuf, (unsigned long int)119, (unsigned long int)1, xc->handle);
  fputc((signed int)xc->filetype, xc->handle);
  fstWriterUint64(xc->handle, (unsigned long int)xc->timezero);
  fflush(xc->handle);
}

// fstWriterEmitSectionHeader
// file ./../../src/helpers/fst/fstapi.c line 1170
static void fstWriterEmitSectionHeader(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  unsigned long int tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    unsigned long int destlen;
    unsigned char *dmem;
    signed int rc;
    destlen = (unsigned long int)xc->maxvalpos;
    unsigned long int return_value_compressBound_1;
    return_value_compressBound_1=compressBound(destlen);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(return_value_compressBound_1);
    dmem = (unsigned char *)return_value_malloc_2;
    rc=compress2(dmem, &destlen, xc->curval_mem, (unsigned long int)xc->maxvalpos, 4);
    fputc(255, xc->handle);
    xc->section_start=ftello(xc->handle);
    if(!(xc->xc_parent == ((struct fstWriterContext *)NULL)))
      xc->xc_parent->section_start = xc->section_start;

    xc->section_header_only = (unsigned int)1;
    fstWriterUint64(xc->handle, (unsigned long int)0);
    if(!(xc->is_initial_time == 0u))
      tmp_if_expr_3 = xc->firsttime;

    else
      tmp_if_expr_3 = xc->curtime;
    fstWriterUint64(xc->handle, tmp_if_expr_3);
    fstWriterUint64(xc->handle, xc->curtime);
    fstWriterUint64(xc->handle, (unsigned long int)0);
    fstWriterVarint(xc->handle, (unsigned long int)xc->maxvalpos);
    if(rc == 0)
      tmp_if_expr_4 = destlen < (unsigned long int)xc->maxvalpos ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      fstWriterVarint(xc->handle, destlen);

    else
      fstWriterVarint(xc->handle, (unsigned long int)xc->maxvalpos);
    fstWriterVarint(xc->handle, (unsigned long int)xc->maxhandle);
    if(rc == 0)
      tmp_if_expr_5 = destlen < (unsigned long int)xc->maxvalpos ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      fstFwrite((const void *)dmem, destlen, (unsigned long int)1, xc->handle);

    else
      fstFwrite((const void *)xc->curval_mem, (unsigned long int)xc->maxvalpos, (unsigned long int)1, xc->handle);
    free((void *)dmem);
  }

}

// fstWriterEmitTimeChange
// file ./../../src/helpers/fst/fstapi.c line 2889
void fstWriterEmitTimeChange(void *ctx, unsigned long int tim)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  unsigned int i;
  signed int skip = 0;
  _Bool tmp_if_expr_1;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    if(!(xc->is_initial_time == 0u))
    {
      if(!(xc->size_limit_locked == 0u))
        goto __CPROVER_DUMP_L11;

      if(xc->valpos_mem == ((unsigned int *)NULL))
        fstWriterCreateMmaps(xc);

      skip = 1;
      xc->firsttime = xc->vc_emitted != 0u ? (unsigned long int)0 : tim;
      xc->curtime = (unsigned long int)0;
      xc->vchg_mem[(signed long int)0] = (unsigned char)33;
      xc->vchg_siz = (unsigned int)1;
      fstWriterEmitSectionHeader((void *)xc);
      i = (unsigned int)0;
      for( ; !(i >= xc->maxhandle); i = i + 1u)
      {
        xc->valpos_mem[(signed long int)((unsigned int)4 * i + (unsigned int)2)] = (unsigned int)0;
        xc->valpos_mem[(signed long int)((unsigned int)4 * i + (unsigned int)3)] = (unsigned int)0;
      }
      xc->is_initial_time = (unsigned int)0;
    }

    else
    {
      if((unsigned long int)xc->vchg_siz >= xc->fst_break_size)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = xc->flush_context_pending != 0u ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        xc->flush_context_pending = (unsigned int)0;
        fstWriterFlushContextPrivate((void *)xc);
        xc->tchn_cnt = xc->tchn_cnt + 1u;
        fstWriterVarint(xc->tchn_handle, xc->curtime);
      }

    }
    if(skip == 0)
      xc->tchn_idx = xc->tchn_idx + 1u;

    fstWriterVarint(xc->tchn_handle, tim - xc->curtime);
    xc->tchn_cnt = xc->tchn_cnt + 1u;
    xc->curtime = tim;
  }


__CPROVER_DUMP_L11:
  ;
}

// fstWriterEmitValueChange
// file ./../../src/helpers/fst/fstapi.c line 2728
void fstWriterEmitValueChange(void *ctx, unsigned int handle, const void *val)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  const unsigned char *buf = (const unsigned char *)val;
  unsigned int offs;
  signed int len;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    if(xc->maxhandle >= handle)
    {
      unsigned int fpos;
      unsigned int *vm4ip;
      if(xc->valpos_mem == ((unsigned int *)NULL))
      {
        xc->vc_emitted = (unsigned int)1;
        fstWriterCreateMmaps(xc);
      }

      handle = handle - 1u;
      vm4ip = &xc->valpos_mem[(signed long int)((unsigned int)4 * handle)];
      len = (signed int)vm4ip[(signed long int)1];
      if(!(len == 0))
      {
        if(xc->is_initial_time == 0u)
        {
          fpos = xc->vchg_siz;
          if(!(xc->vchg_alloc_siz >= 10u + fpos + (unsigned int)len))
          {
            xc->vchg_alloc_siz = xc->vchg_alloc_siz + (unsigned int)(xc->fst_break_add_size + (unsigned long int)len);
            void *return_value_realloc_1;
            return_value_realloc_1=realloc((void *)xc->vchg_mem, (unsigned long int)xc->vchg_alloc_siz);
            xc->vchg_mem = (unsigned char *)return_value_realloc_1;
            if(xc->vchg_mem == ((unsigned char *)NULL))
            {
              fprintf(stderr, "FATAL ERROR, could not realloc() in fstWriterEmitValueChange, exiting.\n");
              exit(255);
            }

          }

          unsigned int return_value_fstWriterUint32WithVarint32_2;
          return_value_fstWriterUint32WithVarint32_2=fstWriterUint32WithVarint32(xc, &vm4ip[(signed long int)2], xc->tchn_idx - vm4ip[(signed long int)3], (const void *)buf, (unsigned int)len);
          xc->vchg_siz = xc->vchg_siz + return_value_fstWriterUint32WithVarint32_2;
          vm4ip[(signed long int)3] = xc->tchn_idx;
          vm4ip[(signed long int)2] = fpos;
        }

        else
        {
          offs = vm4ip[(signed long int)0];
          memcpy((void *)(xc->curval_mem + (signed long int)offs), (const void *)buf, (unsigned long int)len);
        }
      }

    }

  }

}

// fstWriterEmitVariableLengthValueChange
// file ./../../src/helpers/fst/fstapi.c line 2846
void fstWriterEmitVariableLengthValueChange(void *ctx, unsigned int handle, const void *val, unsigned int len)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  const unsigned char *buf = (const unsigned char *)val;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    if(xc->maxhandle >= handle)
    {
      unsigned int fpos;
      unsigned int *vm4ip;
      if(xc->valpos_mem == ((unsigned int *)NULL))
      {
        xc->vc_emitted = (unsigned int)1;
        fstWriterCreateMmaps(xc);
      }

      handle = handle - 1u;
      vm4ip = &xc->valpos_mem[(signed long int)((unsigned int)4 * handle)];
      if(vm4ip[1l] == 0u)
      {
        fpos = xc->vchg_siz;
        if(!(xc->vchg_alloc_siz >= 15u + fpos + len))
        {
          xc->vchg_alloc_siz = xc->vchg_alloc_siz + (unsigned int)(xc->fst_break_add_size + (unsigned long int)len + (unsigned long int)5);
          void *return_value_realloc_1;
          return_value_realloc_1=realloc((void *)xc->vchg_mem, (unsigned long int)xc->vchg_alloc_siz);
          xc->vchg_mem = (unsigned char *)return_value_realloc_1;
          if(xc->vchg_mem == ((unsigned char *)NULL))
          {
            fprintf(stderr, "FATAL ERROR, could not realloc() in fstWriterEmitVariableLengthValueChange, exiting.\n");
            exit(255);
          }

        }

        unsigned int return_value_fstWriterUint32WithVarint32AndLength_2;
        return_value_fstWriterUint32WithVarint32AndLength_2=fstWriterUint32WithVarint32AndLength(xc, &vm4ip[(signed long int)2], xc->tchn_idx - vm4ip[(signed long int)3], (const void *)buf, len);
        xc->vchg_siz = xc->vchg_siz + return_value_fstWriterUint32WithVarint32AndLength_2;
        vm4ip[(signed long int)3] = xc->tchn_idx;
        vm4ip[(signed long int)2] = fpos;
      }

    }

  }

}

// fstWriterFlushContext
// file ./../../src/helpers/fst/fstapi.c line 1841
void fstWriterFlushContext(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    if(xc->tchn_idx >= 2u)
      xc->flush_context_pending = (unsigned int)1;

  }

}

// fstWriterFlushContextPrivate
// file ./../../src/helpers/fst/fstapi.c line 1776
static void fstWriterFlushContextPrivate(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc->parallel_enabled == 0u))
  {
    struct fstWriterContext *xc2;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct fstWriterContext) /*432ul*/ );
    xc2 = (struct fstWriterContext *)return_value_malloc_1;
    unsigned int i;
    pthread_mutex_lock(&xc->mutex);
    pthread_mutex_unlock(&xc->mutex);
    xc->xc_parent = xc;
    memcpy((void *)xc2, (const void *)xc, sizeof(struct fstWriterContext) /*432ul*/ );
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(xc->maxhandle * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ );
    xc2->valpos_mem = (unsigned int *)return_value_malloc_2;
    memcpy((void *)xc2->valpos_mem, (const void *)xc->valpos_mem, (unsigned long int)(xc->maxhandle * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ );
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)xc->vchg_alloc_siz);
    xc->vchg_mem = (unsigned char *)return_value_malloc_3;
    xc->vchg_mem[(signed long int)0] = (unsigned char)33;
    xc->vchg_siz = (unsigned int)1;
    i = (unsigned int)0;
    for( ; !(i >= xc->maxhandle); i = i + 1u)
    {
      unsigned int *vm4ip = &xc->valpos_mem[(signed long int)((unsigned int)4 * i)];
      vm4ip[(signed long int)2] = (unsigned int)0;
      vm4ip[(signed long int)3] = (unsigned int)0;
    }
    xc->tchn_idx = (unsigned int)0;
    xc->tchn_cnt = xc->tchn_idx;
    xc->tchn_handle=tmpfile_open(&xc->tchn_handle_nam);
    fstWriterFseeko(xc, xc->tchn_handle, (signed long int)0, 0);
    signed int return_value_fileno_4;
    return_value_fileno_4=fileno(xc->tchn_handle);
    fstFtruncate(return_value_fileno_4, (signed long int)0);
    xc->section_header_only = (unsigned int)0;
    xc->secnum = xc->secnum + 1u;
    pthread_mutex_lock(&xc->mutex);
    pthread_create(&xc->thread, &xc->thread_attr, fstWriterFlushContextPrivate1, (void *)xc2);
  }

  else
  {
    if(!(xc->parallel_was_enabled == 0u))
    {
      pthread_mutex_lock(&xc->mutex);
      pthread_mutex_unlock(&xc->mutex);
    }

    xc->xc_parent = xc;
    fstWriterFlushContextPrivate2((void *)xc);
  }
}

// fstWriterFlushContextPrivate1
// file ./../../src/helpers/fst/fstapi.c line 1756
static void * fstWriterFlushContextPrivate1(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  fstWriterFlushContextPrivate2((void *)xc);
  pthread_mutex_unlock(&xc->xc_parent->mutex);
  free((void *)xc->valpos_mem);
  free((void *)xc->vchg_mem);
  tmpfile_close(&xc->tchn_handle, &xc->tchn_handle_nam);
  free((void *)xc);
  return (void *)0;
}

// fstWriterFlushContextPrivate2
// file ./../../src/helpers/fst/fstapi.c line 1225
static void fstWriterFlushContextPrivate2(void *ctx)
{
  unsigned int i;
  unsigned char *vchg_mem;
  struct _IO_FILE *f;
  signed long int fpos;
  signed long int indxpos;
  signed long int endpos;
  unsigned int prevpos;
  signed int zerocnt;
  unsigned char *scratchpad;
  unsigned char *scratchpnt;
  unsigned char *tmem;
  signed long int tlen;
  signed long int unc_memreq = (signed long int)0;
  unsigned char *packmem;
  unsigned int packmemlen;
  unsigned int *vm4ip;
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  struct fstWriterContext *xc2 = xc->xc_parent;
  void *PJHSArray = (void *)0;
  _Bool tmp_if_expr_1;
  if(!(xc->vchg_siz >= 2u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = xc->already_in_flush != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  signed int tmp_if_expr_14;
  signed int return_value_LZ4_compress_12;
  signed int return_value_fastlz_compress_13;
  if(!tmp_if_expr_1)
  {
    xc->already_in_flush = (unsigned char)1;
    xc->section_header_only = (unsigned int)0;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)xc->vchg_siz);
    scratchpad = (unsigned char *)return_value_malloc_2;
    vchg_mem = xc->vchg_mem;
    f = xc->handle;
    fstWriterVarint(f, (unsigned long int)xc->maxhandle);
    if(!(xc->fourpack == 0u))
      tmp_if_expr_3 = 52;

    else
      tmp_if_expr_3 = xc->fastpack != 0u ? 70 : 90;
    fputc(tmp_if_expr_3, f);
    fpos = (signed long int)1;
    packmemlen = (unsigned int)1024;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)packmemlen);
    packmem = (unsigned char *)return_value_malloc_4;
    i = (unsigned int)0;
    for( ; !(i >= xc->maxhandle); i = i + 1u)
    {
      vm4ip = &xc->valpos_mem[(signed long int)((unsigned int)4 * i)];
      if(!(vm4ip[2l] == 0u))
      {
        unsigned int offs = vm4ip[(signed long int)2];
        unsigned int next_offs;
        unsigned int wrlen;
        vm4ip[(signed long int)2] = (unsigned int)fpos;
        scratchpnt = scratchpad + (signed long int)xc->vchg_siz;
        if(!(vm4ip[1l] >= 2u))
        {
          if(vm4ip[1l] == 1u)
          {
            wrlen=fstGetVarint32Length(vchg_mem + (signed long int)offs + (signed long int)4);
            xc->curval_mem[(signed long int)vm4ip[(signed long int)0]] = vchg_mem[(signed long int)(offs + (unsigned int)4 + wrlen)];
            while(!(offs == 0u))
            {
              unsigned char val;
              unsigned int fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta;
              unsigned int rcv;
              next_offs = *((unsigned int *)(vchg_mem + (signed long int)offs));
              offs = offs + (unsigned int)4;
              fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta=fstGetVarint32(vchg_mem + (signed long int)offs, (signed int *)&wrlen);
              val = vchg_mem[(signed long int)(offs + wrlen)];
              offs = next_offs;
              switch((signed int)val)
              {
                case 48:

                case 49:
                {
                  rcv = (unsigned int)(((signed int)val & 1) << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 2;
                  break;
                }
                case 120:

                case 88:
                {
                  rcv = (unsigned int)(1 | 0 << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 4;
                  break;
                }
                case 122:

                case 90:
                {
                  rcv = (unsigned int)(1 | 1 << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 4;
                  break;
                }
                case 104:

                case 72:
                {
                  rcv = (unsigned int)(1 | 2 << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 4;
                  break;
                }
                case 117:

                case 85:
                {
                  rcv = (unsigned int)(1 | 3 << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 4;
                  break;
                }
                case 119:

                case 87:
                {
                  rcv = (unsigned int)(1 | 4 << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 4;
                  break;
                }
                case 108:

                case 76:
                {
                  rcv = (unsigned int)(1 | 5 << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 4;
                  break;
                }
                default:
                  rcv = (unsigned int)(1 | 6 << 1) | fstWriterFlushContextPrivate2__1__1__1__1__1__1__1__time_delta << 4;
              }
              scratchpnt=fstCopyVarint32ToLeft(scratchpnt, rcv);
            }
          }

          else
          {
            unsigned char *pnt;
            unsigned int record_len;
            unsigned int time_delta;
            while(!(offs == 0u))
            {
              next_offs = *((unsigned int *)(vchg_mem + (signed long int)offs));
              offs = offs + (unsigned int)4;
              pnt = vchg_mem + (signed long int)offs;
              offs = next_offs;
              time_delta=fstGetVarint32(pnt, (signed int *)&wrlen);
              pnt = pnt + (signed long int)wrlen;
              record_len=fstGetVarint32(pnt, (signed int *)&wrlen);
              pnt = pnt + (signed long int)wrlen;
              scratchpnt = scratchpnt - (signed long int)record_len;
              memcpy((void *)scratchpnt, (const void *)pnt, (unsigned long int)record_len);
              scratchpnt=fstCopyVarint32ToLeft(scratchpnt, record_len);
              scratchpnt=fstCopyVarint32ToLeft(scratchpnt, time_delta << 1);
            }
          }
        }

        else
        {
          wrlen=fstGetVarint32Length(vchg_mem + (signed long int)offs + (signed long int)4);
          memcpy((void *)(xc->curval_mem + (signed long int)vm4ip[(signed long int)0]), (const void *)(vchg_mem + (signed long int)offs + (signed long int)4 + (signed long int)wrlen), (unsigned long int)vm4ip[(signed long int)1]);
          while(!(offs == 0u))
          {
            unsigned int idx;
            char is_binary = (char)1;
            unsigned char *fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt;
            unsigned int fstWriterFlushContextPrivate2__1__1__1__1__2__1__time_delta;
            next_offs = *((unsigned int *)(vchg_mem + (signed long int)offs));
            offs = offs + (unsigned int)4;
            fstWriterFlushContextPrivate2__1__1__1__1__2__1__time_delta=fstGetVarint32(vchg_mem + (signed long int)offs, (signed int *)&wrlen);
            fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt = vchg_mem + (signed long int)offs + (signed long int)wrlen;
            offs = next_offs;
            idx = (unsigned int)0;
            for( ; !(idx >= vm4ip[1l]); idx = idx + 1u)
            {
              if((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)idx] == 48)
                tmp_if_expr_5 = (_Bool)1;

              else
                tmp_if_expr_5 = (signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)idx] == 49 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_5)
                goto __CPROVER_DUMP_L28;

              else
              {
                is_binary = (char)0;
                break;
              }

            __CPROVER_DUMP_L28:
              ;
            }
            if(!(is_binary == 0))
            {
              unsigned char acc = (unsigned char)0;
              idx = vm4ip[(signed long int)1] + (unsigned int)7 & (unsigned int)~7;
              switch(vm4ip[(signed long int)1] & (unsigned int)7)
              {
                case (unsigned int)7:
                  acc = acc | (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)6) - (unsigned int)8)] & 1) << 1);
                case (unsigned int)6:
                  acc = acc | (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)5) - (unsigned int)8)] & 1) << 2);
                case (unsigned int)5:
                  acc = acc | (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)4) - (unsigned int)8)] & 1) << 3);
                case (unsigned int)4:
                  acc = acc | (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)3) - (unsigned int)8)] & 1) << 4);
                case (unsigned int)3:
                  acc = acc | (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)2) - (unsigned int)8)] & 1) << 5);
                case (unsigned int)2:
                  acc = acc | (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)1) - (unsigned int)8)] & 1) << 6);
                case (unsigned int)1:
                {
                  acc = acc | (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)0) - (unsigned int)8)] & 1) << 7);
                  scratchpnt = scratchpnt - 1l;
                  *scratchpnt = acc;
                  idx = idx - (unsigned int)8;
                  if(!(idx == 0u))
                    goto __CPROVER_DUMP_L30;

                }
                case (unsigned int)0:
                {

                __CPROVER_DUMP_L30:
                  ;
                  acc = (unsigned char)(((signed int)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt[(signed long int)((idx + (unsigned int)7) - (unsigned int)8)] & 1) << 0);
                }
                default:
                  scratchpnt=fstCopyVarint32ToLeft(scratchpnt, fstWriterFlushContextPrivate2__1__1__1__1__2__1__time_delta << 1);
              }
            }

            else
            {
              scratchpnt = scratchpnt - (signed long int)vm4ip[(signed long int)1];
              memcpy((void *)scratchpnt, (const void *)fstWriterFlushContextPrivate2__1__1__1__1__2__1__pnt, (unsigned long int)vm4ip[(signed long int)1]);
              scratchpnt=fstCopyVarint32ToLeft(scratchpnt, fstWriterFlushContextPrivate2__1__1__1__1__2__1__time_delta << 1 | (unsigned int)1);
            }
          }
        }
        wrlen = (unsigned int)((scratchpad + (signed long int)xc->vchg_siz) - scratchpnt);
        unc_memreq = unc_memreq + (signed long int)wrlen;
        if(wrlen >= 33u)
        {
          unsigned long int destlen = (unsigned long int)wrlen;
          unsigned char *fstWriterFlushContextPrivate2__1__1__1__1__3__dmem;
          unsigned int fstWriterFlushContextPrivate2__1__1__1__1__3__rc;
          if(xc->fastpack == 0u)
          {
            if(packmemlen >= wrlen)
              fstWriterFlushContextPrivate2__1__1__1__1__3__dmem = packmem;

            else
            {
              free((void *)packmem);
              packmemlen = wrlen;
              unsigned long int return_value_compressBound_6;
              return_value_compressBound_6=compressBound((unsigned long int)packmemlen);
              void *return_value_malloc_7;
              return_value_malloc_7=malloc(return_value_compressBound_6);
              packmem = (unsigned char *)return_value_malloc_7;
              fstWriterFlushContextPrivate2__1__1__1__1__3__dmem = packmem;
            }
            signed int return_value_compress2_8;
            return_value_compress2_8=compress2(fstWriterFlushContextPrivate2__1__1__1__1__3__dmem, &destlen, scratchpnt, (unsigned long int)wrlen, 4);
            fstWriterFlushContextPrivate2__1__1__1__1__3__rc = (unsigned int)return_value_compress2_8;
            if(fstWriterFlushContextPrivate2__1__1__1__1__3__rc == 0u)
            {
              void **pv;
              pv=JudyHSIns(&PJHSArray, (void *)fstWriterFlushContextPrivate2__1__1__1__1__3__dmem, destlen, (struct J_UDY_ERROR_STRUCT *)(void *)0);
              if(!(*pv == NULL))
              {
                unsigned int pvi = (unsigned int)(signed long int)*pv;
                vm4ip[(signed long int)2] = -pvi;
              }

              else
              {
                *pv = (void *)(signed long int)(i + (unsigned int)1);
                signed int return_value_fstWriterVarint_9;
                return_value_fstWriterVarint_9=fstWriterVarint(f, (unsigned long int)wrlen);
                fpos = fpos + (signed long int)return_value_fstWriterVarint_9;
                fpos = fpos + (signed long int)destlen;
                fstFwrite((const void *)fstWriterFlushContextPrivate2__1__1__1__1__3__dmem, destlen, (unsigned long int)1, f);
              }
            }

            else
            {
              void **fstWriterFlushContextPrivate2__1__1__1__1__3__1__4__pv;
              fstWriterFlushContextPrivate2__1__1__1__1__3__1__4__pv=JudyHSIns(&PJHSArray, (void *)scratchpnt, (unsigned long int)wrlen, (struct J_UDY_ERROR_STRUCT *)(void *)0);
              if(!(*fstWriterFlushContextPrivate2__1__1__1__1__3__1__4__pv == NULL))
              {
                unsigned int fstWriterFlushContextPrivate2__1__1__1__1__3__1__4__1__pvi = (unsigned int)(signed long int)*fstWriterFlushContextPrivate2__1__1__1__1__3__1__4__pv;
                vm4ip[(signed long int)2] = -fstWriterFlushContextPrivate2__1__1__1__1__3__1__4__1__pvi;
              }

              else
              {
                *fstWriterFlushContextPrivate2__1__1__1__1__3__1__4__pv = (void *)(signed long int)(i + (unsigned int)1);
                signed int return_value_fstWriterVarint_10;
                return_value_fstWriterVarint_10=fstWriterVarint(f, (unsigned long int)0);
                fpos = fpos + (signed long int)return_value_fstWriterVarint_10;
                fpos = fpos + (signed long int)wrlen;
                fstFwrite((const void *)scratchpnt, (unsigned long int)wrlen, (unsigned long int)1, f);
              }
            }
          }

          else
          {
            if(packmemlen >= 2u * wrlen + 2u)
              fstWriterFlushContextPrivate2__1__1__1__1__3__dmem = packmem;

            else
            {
              free((void *)packmem);
              packmemlen = wrlen * (unsigned int)2 + (unsigned int)2;
              void *return_value_malloc_11;
              return_value_malloc_11=malloc((unsigned long int)packmemlen);
              packmem = (unsigned char *)return_value_malloc_11;
              fstWriterFlushContextPrivate2__1__1__1__1__3__dmem = packmem;
            }
            if(!(xc->fourpack == 0u))
            {
              return_value_LZ4_compress_12=LZ4_compress((char *)scratchpnt, (char *)fstWriterFlushContextPrivate2__1__1__1__1__3__dmem, (signed int)wrlen);
              tmp_if_expr_14 = return_value_LZ4_compress_12;
            }

            else
            {
              return_value_fastlz_compress_13=fastlz_compress((const void *)scratchpnt, (signed int)wrlen, (void *)fstWriterFlushContextPrivate2__1__1__1__1__3__dmem);
              tmp_if_expr_14 = return_value_fastlz_compress_13;
            }
            fstWriterFlushContextPrivate2__1__1__1__1__3__rc = (unsigned int)tmp_if_expr_14;
            if(!((unsigned long int)fstWriterFlushContextPrivate2__1__1__1__1__3__rc >= destlen))
            {
              void **fstWriterFlushContextPrivate2__1__1__1__1__3__2__3__pv;
              fstWriterFlushContextPrivate2__1__1__1__1__3__2__3__pv=JudyHSIns(&PJHSArray, (void *)fstWriterFlushContextPrivate2__1__1__1__1__3__dmem, (unsigned long int)fstWriterFlushContextPrivate2__1__1__1__1__3__rc, (struct J_UDY_ERROR_STRUCT *)(void *)0);
              if(!(*fstWriterFlushContextPrivate2__1__1__1__1__3__2__3__pv == NULL))
              {
                unsigned int fstWriterFlushContextPrivate2__1__1__1__1__3__2__3__1__pvi = (unsigned int)(signed long int)*fstWriterFlushContextPrivate2__1__1__1__1__3__2__3__pv;
                vm4ip[(signed long int)2] = -fstWriterFlushContextPrivate2__1__1__1__1__3__2__3__1__pvi;
              }

              else
              {
                *fstWriterFlushContextPrivate2__1__1__1__1__3__2__3__pv = (void *)(signed long int)(i + (unsigned int)1);
                signed int return_value_fstWriterVarint_15;
                return_value_fstWriterVarint_15=fstWriterVarint(f, (unsigned long int)wrlen);
                fpos = fpos + (signed long int)return_value_fstWriterVarint_15;
                fpos = fpos + (signed long int)fstWriterFlushContextPrivate2__1__1__1__1__3__rc;
                fstFwrite((const void *)fstWriterFlushContextPrivate2__1__1__1__1__3__dmem, (unsigned long int)fstWriterFlushContextPrivate2__1__1__1__1__3__rc, (unsigned long int)1, f);
              }
            }

            else
            {
              void **fstWriterFlushContextPrivate2__1__1__1__1__3__2__4__pv;
              fstWriterFlushContextPrivate2__1__1__1__1__3__2__4__pv=JudyHSIns(&PJHSArray, (void *)scratchpnt, (unsigned long int)wrlen, (struct J_UDY_ERROR_STRUCT *)(void *)0);
              if(!(*fstWriterFlushContextPrivate2__1__1__1__1__3__2__4__pv == NULL))
              {
                unsigned int fstWriterFlushContextPrivate2__1__1__1__1__3__2__4__1__pvi = (unsigned int)(signed long int)*fstWriterFlushContextPrivate2__1__1__1__1__3__2__4__pv;
                vm4ip[(signed long int)2] = -fstWriterFlushContextPrivate2__1__1__1__1__3__2__4__1__pvi;
              }

              else
              {
                *fstWriterFlushContextPrivate2__1__1__1__1__3__2__4__pv = (void *)(signed long int)(i + (unsigned int)1);
                signed int return_value_fstWriterVarint_16;
                return_value_fstWriterVarint_16=fstWriterVarint(f, (unsigned long int)0);
                fpos = fpos + (signed long int)return_value_fstWriterVarint_16;
                fpos = fpos + (signed long int)wrlen;
                fstFwrite((const void *)scratchpnt, (unsigned long int)wrlen, (unsigned long int)1, f);
              }
            }
          }
        }

        else
        {
          void **fstWriterFlushContextPrivate2__1__1__1__1__4__pv;
          fstWriterFlushContextPrivate2__1__1__1__1__4__pv=JudyHSIns(&PJHSArray, (void *)scratchpnt, (unsigned long int)wrlen, (struct J_UDY_ERROR_STRUCT *)(void *)0);
          if(!(*fstWriterFlushContextPrivate2__1__1__1__1__4__pv == NULL))
          {
            unsigned int fstWriterFlushContextPrivate2__1__1__1__1__4__1__pvi = (unsigned int)(signed long int)*fstWriterFlushContextPrivate2__1__1__1__1__4__pv;
            vm4ip[(signed long int)2] = -fstWriterFlushContextPrivate2__1__1__1__1__4__1__pvi;
          }

          else
          {
            *fstWriterFlushContextPrivate2__1__1__1__1__4__pv = (void *)(signed long int)(i + (unsigned int)1);
            signed int return_value_fstWriterVarint_17;
            return_value_fstWriterVarint_17=fstWriterVarint(f, (unsigned long int)0);
            fpos = fpos + (signed long int)return_value_fstWriterVarint_17;
            fpos = fpos + (signed long int)wrlen;
            fstFwrite((const void *)scratchpnt, (unsigned long int)wrlen, (unsigned long int)1, f);
          }
        }
      }

    }
    JudyHSFreeArray(&PJHSArray, (struct J_UDY_ERROR_STRUCT *)(void *)0);
    free((void *)packmem);
    packmem = (unsigned char *)(void *)0;
    prevpos = (unsigned int)0;
    zerocnt = 0;
    free((void *)scratchpad);
    scratchpad = (unsigned char *)(void *)0;
    indxpos=ftello(f);
    xc->secnum = xc->secnum + 1u;
    {
      unsigned int prev_alias = (unsigned int)0;
      i = (unsigned int)0;
      for( ; !(i >= xc->maxhandle); i = i + 1u)
      {
        vm4ip = &xc->valpos_mem[(signed long int)((unsigned int)4 * i)];
        if(!(vm4ip[2l] == 0u))
        {
          if(!(zerocnt == 0))
          {
            signed int return_value_fstWriterVarint_18;
            return_value_fstWriterVarint_18=fstWriterVarint(f, (unsigned long int)(zerocnt << 1));
            fpos = fpos + (signed long int)return_value_fstWriterVarint_18;
            zerocnt = 0;
          }

          if(!((0x80000000 & vm4ip[2l]) == 0u))
          {
            if(!(vm4ip[2l] == prev_alias))
            {
              prev_alias = vm4ip[(signed long int)2];
              signed int return_value_fstWriterSVarint_19;
              return_value_fstWriterSVarint_19=fstWriterSVarint(f, (signed long int)(signed int)prev_alias << 1 | (signed long int)1);
              fpos = fpos + (signed long int)return_value_fstWriterSVarint_19;
            }

            else
            {
              signed int return_value_fstWriterSVarint_20;
              return_value_fstWriterSVarint_20=fstWriterSVarint(f, (signed long int)(0 << 1 | 1));
              fpos = fpos + (signed long int)return_value_fstWriterSVarint_20;
            }
          }

          else
          {
            signed int return_value_fstWriterSVarint_21;
            return_value_fstWriterSVarint_21=fstWriterSVarint(f, (signed long int)(vm4ip[(signed long int)2] - prevpos << 1 | (unsigned int)1));
            fpos = fpos + (signed long int)return_value_fstWriterSVarint_21;
            prevpos = vm4ip[(signed long int)2];
          }
          vm4ip[(signed long int)2] = (unsigned int)0;
          vm4ip[(signed long int)3] = (unsigned int)0;
        }

        else
          zerocnt = zerocnt + 1;
      }
    }
    if(!(zerocnt == 0))
      fstWriterVarint(f, (unsigned long int)(zerocnt << 1));

    xc->vchg_mem[(signed long int)0] = (unsigned char)33;
    xc->vchg_siz = (unsigned int)1;
    endpos=ftello(xc->handle);
    fstWriterUint64(xc->handle, (unsigned long int)(endpos - indxpos));
    fflush(xc->tchn_handle);
    tlen=ftello(xc->tchn_handle);
    fstWriterFseeko(xc, xc->tchn_handle, (signed long int)0, 0);
    signed int return_value_fileno_26;
    return_value_fileno_26=fileno(xc->tchn_handle);
    void *return_value_mmap_27;
    return_value_mmap_27=mmap((void *)0, (unsigned long int)tlen, 0x1 | 0x2, 0x01, return_value_fileno_26, (signed long int)0);
    tmem = (unsigned char *)(void *)return_value_mmap_27;
    if(!(tmem == ((unsigned char *)NULL)))
    {
      unsigned long int fstWriterFlushContextPrivate2__1__5__destlen = (unsigned long int)tlen;
      unsigned char *dmem;
      unsigned long int return_value_compressBound_28;
      return_value_compressBound_28=compressBound(fstWriterFlushContextPrivate2__1__5__destlen);
      void *return_value_malloc_29;
      return_value_malloc_29=malloc(return_value_compressBound_28);
      dmem = (unsigned char *)return_value_malloc_29;
      signed int rc;
      rc=compress2(dmem, &fstWriterFlushContextPrivate2__1__5__destlen, tmem, (unsigned long int)tlen, 9);
      if(rc == 0 && !((signed long int)fstWriterFlushContextPrivate2__1__5__destlen >= tlen))
        fstFwrite((const void *)dmem, fstWriterFlushContextPrivate2__1__5__destlen, (unsigned long int)1, xc->handle);

      else
      {
        fstFwrite((const void *)tmem, (unsigned long int)tlen, (unsigned long int)1, xc->handle);
        fstWriterFlushContextPrivate2__1__5__destlen = (unsigned long int)tlen;
      }
      free((void *)dmem);
      if(!(tmem == ((unsigned char *)NULL)))
        munmap((void *)tmem, (unsigned long int)tlen);

      fstWriterUint64(xc->handle, (unsigned long int)tlen);
      fstWriterUint64(xc->handle, fstWriterFlushContextPrivate2__1__5__destlen);
      fstWriterUint64(xc->handle, (unsigned long int)xc->tchn_cnt);
    }

    xc->tchn_idx = (unsigned int)0;
    xc->tchn_cnt = xc->tchn_idx;
    fstWriterFseeko(xc, xc->tchn_handle, (signed long int)0, 0);
    signed int return_value_fileno_30;
    return_value_fileno_30=fileno(xc->tchn_handle);
    fstFtruncate(return_value_fileno_30, (signed long int)0);
    endpos=ftello(xc->handle);
    fstWriterFseeko(xc, xc->handle, xc->section_start, 0);
    fstWriterUint64(xc->handle, (unsigned long int)(endpos - xc->section_start));
    fstWriterFseeko(xc, xc->handle, (signed long int)8, 1);
    fstWriterUint64(xc->handle, xc->curtime);
    fstWriterUint64(xc->handle, (unsigned long int)unc_memreq);
    fflush(xc->handle);
    fstWriterFseeko(xc, xc->handle, xc->section_start - (signed long int)1, 0);
    fputc(8, xc->handle);
    fflush(xc->handle);
    fstWriterFseeko(xc, xc->handle, endpos, 0);
    xc2->section_header_truncpos = endpos;
    if(!(xc->dump_size_limit == 0ul))
    {
      if(endpos >= (signed long int)xc->dump_size_limit)
      {
        xc2->skip_writing_section_hdr = (unsigned int)1;
        xc2->size_limit_locked = (unsigned int)1;
        xc2->is_initial_time = (unsigned int)1;
      }

    }

    if(xc2->skip_writing_section_hdr == 0u)
      fstWriterEmitSectionHeader((void *)xc);

    fflush(xc->handle);
    xc->already_in_flush = (unsigned char)0;
  }

}

// fstWriterFseeko
// file ./../../src/helpers/fst/fstapi.c line 797
static signed int fstWriterFseeko(struct fstWriterContext *xc, struct _IO_FILE *stream, signed long int offset, signed int whence)
{
  signed int rc;
  rc=fseeko(stream, offset, whence);
  if(!(rc >= 0))
    xc->fseek_failed = (unsigned int)1;

  return rc;
}

// fstWriterGetDumpSizeLimitReached
// file ./../../src/helpers/fst/fstapi.c line 2498
signed int fstWriterGetDumpSizeLimitReached(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
    return (signed int)((signed int)xc->size_limit_locked != 0);

  else
    return 0;
}

// fstWriterGetFseekFailed
// file ./../../src/helpers/fst/fstapi.c line 2510
signed int fstWriterGetFseekFailed(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
    return (signed int)((signed int)xc->fseek_failed != 0);

  else
    return 0;
}

// fstWriterSVarint
// file ./../../src/helpers/fst/fstapi.c line 662
static signed int fstWriterSVarint(struct _IO_FILE *handle, signed long int v)
{
  unsigned char buf[15l];
  unsigned char byt;
  unsigned char *pnt = buf;
  signed int more = 1;
  signed int len;
  unsigned char *tmp_post_1;
  do
  {
    byt = (unsigned char)(v | (signed long int)0x80);
    v = v >> 7;
    if((0x40 & (signed int)byt) == 0 && v == 0l || v == -1l && !((0x40 & (signed int)byt) == 0))
    {
      more = 0;
      byt = byt & (unsigned char)0x7f;
    }

    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = byt;
  }
  while(!(more == 0));
  len = (signed int)(pnt - buf);
  fstFwrite((const void *)buf, (unsigned long int)len, (unsigned long int)1, handle);
  return len;
}

// fstWriterSetAttrBegin
// file ./../../src/helpers/fst/fstapi.c line 2677
void fstWriterSetAttrBegin(void *ctx, enum fstAttrType attrtype, signed int subtype, const char *attrname, unsigned long int arg)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    fputc(FST_ST_GEN_ATTRBEGIN, xc->hier_handle);
    if((signed int)attrtype >= 4)
    {
      attrtype = (enum fstAttrType)FST_AT_MISC;
      subtype = 7;
    }

    fputc((signed int)attrtype, xc->hier_handle);
    switch((signed int)attrtype)
    {
      case FST_AT_ARRAY:
      {
        if(subtype >= 4 || !(subtype >= 0))
          subtype = 0;

        goto __CPROVER_DUMP_L7;
      }
      case FST_AT_ENUM:
      {
        if(subtype >= 14 || !(subtype >= 0))
          subtype = 0;

        goto __CPROVER_DUMP_L7;
      }
      case FST_AT_PACK:
        if(subtype >= 4 || !(subtype >= 0))
          subtype = 0;

      case FST_AT_MISC:

      default:
      {

      __CPROVER_DUMP_L7:
        ;
        fputc(subtype, xc->hier_handle);
        fprintf(xc->hier_handle, "%s%c", attrname != ((const char *)NULL) ? attrname : "", 0);
        if(!(attrname == ((const char *)NULL)))
        {
          unsigned long int return_value_strlen_1;
          return_value_strlen_1=strlen(attrname);
          xc->hier_file_len = xc->hier_file_len + (signed long int)return_value_strlen_1;
        }

        xc->hier_file_len = xc->hier_file_len + (signed long int)4;
        signed int return_value_fstWriterVarint_2;
        return_value_fstWriterVarint_2=fstWriterVarint(xc->hier_handle, arg);
        xc->hier_file_len = xc->hier_file_len + (signed long int)return_value_fstWriterVarint_2;
      }
    }
  }

}

// fstWriterSetAttrDoubleArgGeneric
// file ./../../src/helpers/fst/fstapi.c line 2254
static void fstWriterSetAttrDoubleArgGeneric(void *ctx, signed int typ, unsigned long int arg1, unsigned long int arg2)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    unsigned char buf[11l];
    unsigned char *pnt;
    pnt=fstCopyVarint64ToRight(buf, arg1);
    if(!(arg1 == 0ul))
      *pnt = (unsigned char)0;

    fstWriterSetAttrBegin((void *)xc, (enum fstAttrType)FST_AT_MISC, typ, (char *)buf, arg2);
  }

}

// fstWriterSetAttrEnd
// file ./../../src/helpers/fst/fstapi.c line 2713
void fstWriterSetAttrEnd(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    fputc(FST_ST_GEN_ATTREND, xc->hier_handle);
    xc->hier_file_len = xc->hier_file_len + 1l;
  }

}

// fstWriterSetAttrGeneric
// file ./../../src/helpers/fst/fstapi.c line 2271
static void fstWriterSetAttrGeneric(void *ctx, const char *comm, signed int typ, unsigned long int arg)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  _Bool tmp_if_expr_1;
  if(!(comm == ((const char *)NULL)) && !(xc == ((struct fstWriterContext *)NULL)))
  {
    char *s;
    s=strdup(comm);
    char *sf = s;
    for( ; !(*s == 0); s = s + 1l)
    {
      if((signed int)*s == 10)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)*s == 13 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        *s = (char)32;

    }
    fstWriterSetAttrBegin((void *)xc, (enum fstAttrType)FST_AT_MISC, typ, sf, arg);
    free((void *)sf);
  }

}

// fstWriterSetComment
// file ./../../src/helpers/fst/fstapi.c line 2359
void fstWriterSetComment(void *ctx, const char *comm)
{
  fstWriterSetAttrGeneric(ctx, comm, 0, (unsigned long int)0);
}

// fstWriterSetDate
// file ./../../src/helpers/fst/fstapi.c line 2196
void fstWriterSetDate(void *ctx, const char *dat)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    char s[119l];
    signed long int fpos;
    fpos=ftello(xc->handle);
    signed int len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(dat);
    len = (signed int)return_value_strlen_1;
    fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1 + 128), 0);
    memset((void *)s, 0, (unsigned long int)119);
    memcpy((void *)s, (const void *)dat, (unsigned long int)(len < 119 ? len : 119));
    fstFwrite((const void *)s, (unsigned long int)119, (unsigned long int)1, xc->handle);
    fflush(xc->handle);
    fstWriterFseeko(xc, xc->handle, fpos, 0);
  }

}

// fstWriterSetDumpSizeLimit
// file ./../../src/helpers/fst/fstapi.c line 2488
void fstWriterSetDumpSizeLimit(void *ctx, unsigned long int numbytes)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
    xc->dump_size_limit = numbytes;

}

// fstWriterSetEnvVar
// file ./../../src/helpers/fst/fstapi.c line 2371
void fstWriterSetEnvVar(void *ctx, const char *envvar)
{
  fstWriterSetAttrGeneric(ctx, envvar, 1, (unsigned long int)0);
}

// fstWriterSetFileType
// file ./../../src/helpers/fst/fstapi.c line 2234
void fstWriterSetFileType(void *ctx, enum fstFileType filetype)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    if(!((signed int)filetype >= 3))
    {
      signed long int fpos;
      fpos=ftello(xc->handle);
      xc->filetype = (unsigned char)filetype;
      fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1 + 128 + 119), 0);
      fputc((signed int)xc->filetype, xc->handle);
      fflush(xc->handle);
      fstWriterFseeko(xc, xc->handle, fpos, 0);
    }

  }

}

// fstWriterSetPackType
// file ./../../src/helpers/fst/fstapi.c line 2449
void fstWriterSetPackType(void *ctx, enum fstWriterPackType typ)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    xc->fastpack = (unsigned int)((signed int)typ != FST_WR_PT_ZLIB);
    xc->fourpack = (unsigned int)((signed int)typ == FST_WR_PT_LZ4);
  }

}

// fstWriterSetParallelMode
// file ./../../src/helpers/fst/fstapi.c line 2470
void fstWriterSetParallelMode(void *ctx, signed int enable)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    xc->parallel_was_enabled = (unsigned int)xc->parallel_was_enabled | (unsigned int)xc->parallel_enabled;
    xc->parallel_enabled = (unsigned int)(enable != 0);
  }

}

// fstWriterSetRepackOnClose
// file ./../../src/helpers/fst/fstapi.c line 2460
void fstWriterSetRepackOnClose(void *ctx, signed int enable)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
    xc->repack_on_close = (unsigned int)(enable != 0);

}

// fstWriterSetScope
// file ./../../src/helpers/fst/fstapi.c line 2636
void fstWriterSetScope(void *ctx, enum fstScopeType scopetype, const char *scopename, const char *scopecomp)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    fputc(FST_ST_VCD_SCOPE, xc->hier_handle);
    if((signed int)scopetype >= 22)
      scopetype = (enum fstScopeType)FST_ST_VCD_MODULE;

    fputc((signed int)scopetype, xc->hier_handle);
    fprintf(xc->hier_handle, "%s%c%s%c", scopename != ((const char *)NULL) ? scopename : "", 0, scopecomp != ((const char *)NULL) ? scopecomp : "", 0);
    if(!(scopename == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(scopename);
      xc->hier_file_len = xc->hier_file_len + (signed long int)return_value_strlen_1;
    }

    if(!(scopecomp == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(scopecomp);
      xc->hier_file_len = xc->hier_file_len + (signed long int)return_value_strlen_2;
    }

    xc->hier_file_len = xc->hier_file_len + (signed long int)4;
    xc->numscopes = xc->numscopes + 1u;
  }

}

// fstWriterSetSourceInstantiationStem
// file ./../../src/helpers/fst/fstapi.c line 2353
void fstWriterSetSourceInstantiationStem(void *ctx, const char *path, unsigned int line, unsigned int use_realpath)
{
  fstWriterSetSourceStem_2(ctx, path, line, use_realpath, 5);
}

// fstWriterSetSourceStem
// file ./../../src/helpers/fst/fstapi.c line 2347
void fstWriterSetSourceStem(void *ctx, const char *path, unsigned int line, unsigned int use_realpath)
{
  fstWriterSetSourceStem_2(ctx, path, line, use_realpath, 4);
}

// fstWriterSetSourceStem_2
// file ./../../src/helpers/fst/fstapi.c line 2291
static void fstWriterSetSourceStem_2(void *ctx, const char *path, unsigned int line, unsigned int use_realpath, signed int typ)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(path == ((const char *)NULL)) && !(xc == ((struct fstWriterContext *)NULL)))
  {
    if(!(*path == 0))
    {
      unsigned long int sidx = (unsigned long int)0;
      signed int slen;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(path);
      slen = (signed int)return_value_strlen_1;
      char *path2;
      void *return_value___builtin_alloca_2;
      return_value___builtin_alloca_2=__builtin_alloca((unsigned long int)(slen + 1));
      path2 = (char *)return_value___builtin_alloca_2;
      void **pv;
      strcpy(path2, path);
      pv=JudyHSIns(&xc->path_array, (void *)path2, (unsigned long int)slen, (struct J_UDY_ERROR_STRUCT *)(void *)0);
      if(!(*pv == NULL))
        sidx = (unsigned long int)(signed long int)*pv;

      else
      {
        char *rp = (char *)(void *)0;
        xc->path_array_count = xc->path_array_count + 1u;
        sidx = (unsigned long int)xc->path_array_count;
        *pv = (void *)(signed long int)xc->path_array_count;
        if(!(use_realpath == 0u))
          rp=fstRealpath(path2, (char *)(void *)0);

        fstWriterSetAttrGeneric((void *)xc, rp != ((char *)NULL) ? rp : path2, 3, sidx);
        if(!(rp == ((char *)NULL)))
          free((void *)rp);

      }
      fstWriterSetAttrDoubleArgGeneric((void *)xc, typ, sidx, (unsigned long int)line);
    }

  }

}

// fstWriterSetTimescale
// file ./../../src/helpers/fst/fstapi.c line 2377
void fstWriterSetTimescale(void *ctx, signed int ts)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    signed long int fpos;
    fpos=ftello(xc->handle);
    fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8), 0);
    fputc(ts & 255, xc->handle);
    fflush(xc->handle);
    fstWriterFseeko(xc, xc->handle, fpos, 0);
  }

}

// fstWriterSetTimescaleFromString
// file ./../../src/helpers/fst/fstapi.c line 2391
void fstWriterSetTimescaleFromString(void *ctx, const char *s)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(s == ((const char *)NULL)) && !(xc == ((struct fstWriterContext *)NULL)))
  {
    signed int mat = 0;
    signed int seconds_exp = -9;
    signed int tv;
    tv=atoi(s);
    const char *pnt = s;
    for( ; !(*pnt == 0); pnt = pnt + 1l)
    {
      switch((signed int)*pnt)
      {
        case 109:
        {
          seconds_exp = -3;
          mat = 1;
          break;
        }
        case 117:
        {
          seconds_exp = -6;
          mat = 1;
          break;
        }
        case 110:
        {
          seconds_exp = -9;
          mat = 1;
          break;
        }
        case 112:
        {
          seconds_exp = -12;
          mat = 1;
          break;
        }
        case 102:
        {
          seconds_exp = -15;
          mat = 1;
          break;
        }
        case 97:
        {
          seconds_exp = -18;
          mat = 1;
          break;
        }
        case 122:
        {
          seconds_exp = -21;
          mat = 1;
          break;
        }
        case 115:
        {
          seconds_exp = 0;
          mat = 1;
        }
      }
      if(!(mat == 0))
        break;

    }
    if(tv == 10)
      seconds_exp = seconds_exp + 1;

    else
      if(tv == 100)
        seconds_exp = seconds_exp + 2;

    fstWriterSetTimescale(ctx, seconds_exp);
  }

}

// fstWriterSetTimezero
// file ./../../src/helpers/fst/fstapi.c line 2435
void fstWriterSetTimezero(void *ctx, signed long int tim)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    signed long int fpos;
    fpos=ftello(xc->handle);
    fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1 + 128 + 119 + 1), 0);
    xc->timezero = tim;
    fstWriterUint64(xc->handle, (unsigned long int)xc->timezero);
    fflush(xc->handle);
    fstWriterFseeko(xc, xc->handle, fpos, 0);
  }

}

// fstWriterSetUpscope
// file ./../../src/helpers/fst/fstapi.c line 2665
void fstWriterSetUpscope(void *ctx)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(xc == ((struct fstWriterContext *)NULL)))
  {
    fputc(FST_ST_VCD_UPSCOPE, xc->hier_handle);
    xc->hier_file_len = xc->hier_file_len + 1l;
  }

}

// fstWriterSetValueList
// file ./../../src/helpers/fst/fstapi.c line 2365
void fstWriterSetValueList(void *ctx, const char *vl)
{
  fstWriterSetAttrGeneric(ctx, vl, 6, (unsigned long int)0);
}

// fstWriterSetVersion
// file ./../../src/helpers/fst/fstapi.c line 2215
void fstWriterSetVersion(void *ctx, const char *vers)
{
  struct fstWriterContext *xc = (struct fstWriterContext *)ctx;
  if(!(vers == ((const char *)NULL)) && !(xc == ((struct fstWriterContext *)NULL)))
  {
    char s[128l];
    signed long int fpos;
    fpos=ftello(xc->handle);
    signed int len;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(vers);
    len = (signed int)return_value_strlen_1;
    fstWriterFseeko(xc, xc->handle, (signed long int)(0 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 1), 0);
    memset((void *)s, 0, (unsigned long int)128);
    memcpy((void *)s, (const void *)vers, (unsigned long int)(len < 128 ? len : 128));
    fstFwrite((const void *)s, (unsigned long int)128, (unsigned long int)1, xc->handle);
    fflush(xc->handle);
    fstWriterFseeko(xc, xc->handle, fpos, 0);
  }

}

// fstWriterUint32WithVarint32
// file ./../../src/helpers/fst/fstapi.c line 814
static unsigned int fstWriterUint32WithVarint32(struct fstWriterContext *xc, unsigned int *u, unsigned int v, const void *dbuf, unsigned int siz)
{
  unsigned char *buf = xc->vchg_mem + (signed long int)xc->vchg_siz;
  unsigned char *pnt = buf;
  unsigned int nxt;
  unsigned int len;
  *((unsigned int *)pnt) = *((unsigned int *)u);
  pnt = pnt + (signed long int)4;
  unsigned char *tmp_post_1;
  do
  {
    nxt = v >> 7;
    if(nxt == 0u)
      break;

    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = (unsigned char)((signed int)(unsigned char)v | 0x80);
    v = nxt;
  }
  while((_Bool)1);
  unsigned char *tmp_post_2 = pnt;
  pnt = pnt + 1l;
  *tmp_post_2 = (unsigned char)v;
  memcpy((void *)pnt, dbuf, (unsigned long int)siz);
  len = (unsigned int)((pnt - buf) + (signed long int)siz);
  return len;
}

// fstWriterUint32WithVarint32AndLength
// file ./../../src/helpers/fst/fstapi.c line 841
static unsigned int fstWriterUint32WithVarint32AndLength(struct fstWriterContext *xc, unsigned int *u, unsigned int v, const void *dbuf, unsigned int siz)
{
  unsigned char *buf = xc->vchg_mem + (signed long int)xc->vchg_siz;
  unsigned char *pnt = buf;
  unsigned int nxt;
  unsigned int len;
  *((unsigned int *)pnt) = *((unsigned int *)u);
  pnt = pnt + (signed long int)4;
  unsigned char *tmp_post_1;
  do
  {
    nxt = v >> 7;
    if(nxt == 0u)
      break;

    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = (unsigned char)((signed int)(unsigned char)v | 0x80);
    v = nxt;
  }
  while((_Bool)1);
  unsigned char *tmp_post_2 = pnt;
  pnt = pnt + 1l;
  *tmp_post_2 = (unsigned char)v;
  v = siz;
  unsigned char *tmp_post_3;
  do
  {
    nxt = v >> 7;
    if(nxt == 0u)
      break;

    tmp_post_3 = pnt;
    pnt = pnt + 1l;
    *tmp_post_3 = (unsigned char)((signed int)(unsigned char)v | 0x80);
    v = nxt;
  }
  while((_Bool)1);
  unsigned char *tmp_post_4 = pnt;
  pnt = pnt + 1l;
  *tmp_post_4 = (unsigned char)v;
  memcpy((void *)pnt, dbuf, (unsigned long int)siz);
  len = (unsigned int)((pnt - buf) + (signed long int)siz);
  return len;
}

// fstWriterUint64
// file ./../../src/helpers/fst/fstapi.c line 363
static signed int fstWriterUint64(struct _IO_FILE *handle, unsigned long int v)
{
  unsigned char buf[8l];
  signed int i = 7;
  for( ; i >= 0; i = i - 1)
  {
    buf[(signed long int)i] = (unsigned char)(v & (unsigned long int)0xff);
    v = v >> 8;
  }
  fstFwrite((const void *)buf, (unsigned long int)8, (unsigned long int)1, handle);
  return 8;
}

// fstWriterVarint
// file ./../../src/helpers/fst/fstapi.c line 614
static signed int fstWriterVarint(struct _IO_FILE *handle, unsigned long int v)
{
  unsigned long int nxt;
  unsigned char buf[10l];
  unsigned char *pnt = buf;
  signed int len;
  unsigned char *tmp_post_1;
  do
  {
    nxt = v >> 7;
    if(nxt == 0ul)
      break;

    tmp_post_1 = pnt;
    pnt = pnt + 1l;
    *tmp_post_1 = (unsigned char)((signed int)(unsigned char)v | 0x80);
    v = nxt;
  }
  while((_Bool)1);
  unsigned char *tmp_post_2 = pnt;
  pnt = pnt + 1l;
  *tmp_post_2 = (unsigned char)v;
  len = (signed int)(pnt - buf);
  fstFwrite((const void *)buf, (unsigned long int)len, (unsigned long int)1, handle);
  return len;
}

// fstWritex
// file ./../../src/helpers/fst/fstapi.c line 3130
static void fstWritex(struct fstReaderContext *xc, void *v, signed int len)
{
  unsigned char *s = (unsigned char *)v;
  if(!(len == 0))
  {
    if(!(len >= 64))
    {
      if(xc->writex_pos + len >= 64)
        fstWritex(xc, (void *)0, 0);

      memcpy((void *)(xc->writex_buf + (signed long int)xc->writex_pos), (const void *)s, (unsigned long int)len);
      xc->writex_pos = xc->writex_pos + len;
    }

    else
    {
      fstWritex(xc, (void *)0, 0);
      signed long int return_value_write_1;
      return_value_write_1=write(xc->writex_fd, (const void *)s, (unsigned long int)len);
    }
  }

  else
    if(!(xc->writex_pos == 0))
    {
      signed long int return_value_write_2;
      return_value_write_2=write(xc->writex_fd, (const void *)xc->writex_buf, (unsigned long int)xc->writex_pos);
      xc->writex_pos = 0;
    }

}

// fst_alpha_strcmpeq
// file logfile.c line 730
signed int fst_alpha_strcmpeq(const char *s1, const char *s2)
{
  do
  {
    char c1 = *s1;
    char c2 = *s2;
    if((signed int)c1 == 9 || (signed int)c1 == 32 || (signed int)c1 == 91)
      c1 = (char)0;

    if((signed int)c2 == 9 || (signed int)c2 == 32 || (signed int)c2 == 91)
      c2 = (char)0;

    if(!(c1 == c2))
      return 1;

    if(c1 == 0)
      break;

    s1 = s1 + 1l;
    s2 = s2 + 1l;
  }
  while((_Bool)1);
  return 0;
}

// hexify
// file logfile.c line 640
static char * hexify(char *s)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  len = (signed int)return_value_strlen_1;
  char *tmp_post_5;
  char *tmp_post_7;
  char *tmp_post_9;
  char *tmp_post_11;
  _Bool tmp_if_expr_14;
  signed int tmp_if_expr_15;
  char *tmp_post_16;
  char *tmp_post_17;
  char *tmp_post_18;
  if(!(len >= 4))
  {
    char *s2;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(len + 1 + 1));
    s2 = (char *)return_value_malloc_2;
    signed int idx;
    s2[(signed long int)0] = (char)98;
    idx = 0;
    for( ; !(idx >= len); idx = idx + 1)
    {
      signed int return_value_toupper_3;
      return_value_toupper_3=toupper((signed int)(unsigned char)s[(signed long int)idx]);
      s2[(signed long int)(idx + 1)] = (char)return_value_toupper_3;
    }
    s2[(signed long int)(idx + 1)] = (char)0;
    free((void *)s);
    return s2;
  }

  else
  {
    signed int skip = len & 3;
    signed int siz = (len + 3) / 4 + 1;
    char *sorig = s;
    char *hexify__1__2__s2;
    void *return_value_calloc_4;
    return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)siz);
    hexify__1__2__s2 = (char *)return_value_calloc_4;
    signed int hexify__1__2__idx;
    char *pnt = hexify__1__2__s2;
    char arr[5l] = { (char)0, (char)0, (char)0, (char)0, (char)0 };
    while(!(*s == 0))
    {
      char isx;
      char isz;
      signed int val;
      if(skip == 0)
      {
        tmp_post_5 = s;
        s = s + 1l;
        signed int return_value_toupper_6;
        return_value_toupper_6=toupper((signed int)(unsigned char)*tmp_post_5);
        arr[(signed long int)0] = (char)return_value_toupper_6;
        tmp_post_7 = s;
        s = s + 1l;
        signed int return_value_toupper_8;
        return_value_toupper_8=toupper((signed int)(unsigned char)*tmp_post_7);
        arr[(signed long int)1] = (char)return_value_toupper_8;
        tmp_post_9 = s;
        s = s + 1l;
        signed int return_value_toupper_10;
        return_value_toupper_10=toupper((signed int)(unsigned char)*tmp_post_9);
        arr[(signed long int)2] = (char)return_value_toupper_10;
        tmp_post_11 = s;
        s = s + 1l;
        signed int return_value_toupper_12;
        return_value_toupper_12=toupper((signed int)(unsigned char)*tmp_post_11);
        arr[(signed long int)3] = (char)return_value_toupper_12;
      }

      else
      {
        signed int j = 3;
        hexify__1__2__idx = skip - 1;
        for( ; hexify__1__2__idx >= 0; hexify__1__2__idx = hexify__1__2__idx - 1)
        {
          signed int return_value_toupper_13;
          return_value_toupper_13=toupper((signed int)(unsigned char)s[(signed long int)hexify__1__2__idx]);
          arr[(signed long int)j] = (char)return_value_toupper_13;
          j = j - 1;
        }
        hexify__1__2__idx = j;
        for( ; hexify__1__2__idx >= 0; hexify__1__2__idx = hexify__1__2__idx - 1)
        {
          if((signed int)arr[(signed long int)(1 + j)] == 88)
            tmp_if_expr_14 = (_Bool)1;

          else
            tmp_if_expr_14 = (signed int)arr[(signed long int)(j + 1)] == 90 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_14)
            tmp_if_expr_15 = (signed int)arr[(signed long int)(j + 1)];

          else
            tmp_if_expr_15 = 48;
          arr[(signed long int)hexify__1__2__idx] = (char)tmp_if_expr_15;
        }
        s = s + (signed long int)skip;
        skip = 0;
      }
      isz = (char)0;
      isx = isz;
      val = 0;
      hexify__1__2__idx = 0;
      for( ; !(hexify__1__2__idx >= 4); hexify__1__2__idx = hexify__1__2__idx + 1)
      {
        val = val << 1;
        if(!((signed int)arr[(signed long int)hexify__1__2__idx] == 48))
        {
          if((signed int)arr[(signed long int)hexify__1__2__idx] == 49)
            val = val | 1;

          else
            if((signed int)arr[(signed long int)hexify__1__2__idx] == 90)
              isz = isz + 1;

            else
              isx = isx + 1;
        }

      }
      if(!(isx == 0))
      {
        tmp_post_16 = pnt;
        pnt = pnt + 1l;
        *tmp_post_16 = (char)((signed int)isx == 4 ? 120 : 88);
      }

      else
        if(!(isz == 0))
        {
          tmp_post_17 = pnt;
          pnt = pnt + 1l;
          *tmp_post_17 = (char)((signed int)isz == 4 ? 122 : 90);
        }

        else
        {
          tmp_post_18 = pnt;
          pnt = pnt + 1l;
          *tmp_post_18 = "0123456789ABCDEF"[(signed long int)val];
        }
    }
    free((void *)sorig);
    return hexify__1__2__s2;
  }
}

// import_doubleclick
// file logfile.c line 1132
static void import_doubleclick(struct _GtkWidget *text, char *s)
{
  struct text_find_t *t = text_root;
  char *s2;
  struct ds_tree_node *ft = flattened_mod_list_root;
  for( ; !(t == ((struct text_find_t *)NULL)); t = t->next)
    if(text == t->text)
      break;

  if(!(t == ((struct text_find_t *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(t->ctx->which->fullname);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(s);
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(return_value_strlen_1 + (unsigned long int)1 + return_value_strlen_2 + (unsigned long int)1);
    s2 = (char *)return_value_malloc_3;
    sprintf(s2, "%s.%s", t->ctx->which->fullname, s);
    while(!(ft == ((struct ds_tree_node *)NULL)))
    {
      signed int return_value_strcmp_4;
      return_value_strcmp_4=strcmp(s2, ft->fullname);
      if(return_value_strcmp_4 == 0)
      {
        bwlogbox(ft->fullname, 640 + 8 * 8, ft, 0);
        break;
      }

      ft = ft->next_flat;
    }
    free((void *)s2);
  }

}

// insert
// file jrb.c line 51
static void insert(struct jrb_node *item, struct jrb_node *list)
{
  struct jrb_node *last_node = list->blink;
  list->blink = item;
  last_node->flink = item;
  item->blink = last_node;
  item->flink = list;
}

// is_big_endian
// file ./../../src/helpers/vzt_read.c line 41
static signed int is_big_endian(void)
{
  /* tag-#anon#lUN[U32'u32'||lARR4{U8}_U8_'c'|] */
union anonymous_1
{
  // u32
  unsigned int u32;
  // c
  unsigned char c[(signed long int)sizeof(unsigned int) /*4l*/ ];
};

/* */
  ;
  union anonymous_1 u;
  u.u32 = (unsigned int)1;
  return (signed int)((signed int)u.c[(signed long int)(sizeof(unsigned int) /*4ul*/  - (unsigned long int)1)] == 1);
}

// is_identifier
// file logfile.c line 632
static signed int is_identifier(char ch)
{
  signed int rc = (signed int)((signed int)ch >= 97 && (signed int)ch <= 122 || (signed int)ch >= 65 && (signed int)ch <= 90 || (signed int)ch >= 48 && (signed int)ch <= 57 || (signed int)ch == 95 || (signed int)ch == 36);
  return rc;
}

// iter_backward_search_caseins
// file logfile.c line 338
static signed int iter_backward_search_caseins(const struct _GtkTextIter *iter, char *str, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end)
{
  struct _GtkTextIter start = *iter;
  struct _GtkTextIter next;
  char *line_text;
  signed int offset;
  signed int cmpval;
  if(str == ((char *)NULL))
    return 0;

  else
  {
    signed long int return_value_g_utf8_strlen_1;
    return_value_g_utf8_strlen_1=g_utf8_strlen(str, (signed long int)-1);
    offset = (signed int)return_value_g_utf8_strlen_1;
    do
    {
      signed int return_value_gtk_text_iter_is_start_2;
      return_value_gtk_text_iter_is_start_2=gtk_text_iter_is_start(&start);
      if(!(return_value_gtk_text_iter_is_start_2 == 0))
        break;

      next = start;
      forward_chars_with_skipping(&next, offset);
      line_text=gtk_text_iter_get_visible_text(&start, &next);
      cmpval=strcasecmp(str, line_text);
      g_free((void *)line_text);
      if(cmpval == 0)
      {
        *match_start = start;
        *match_end = next;
        return (signed int)!(0 != 0);
      }

      gtk_text_iter_backward_char(&start);
    }
    while((_Bool)1);
    return 0;
  }
}

// iter_forward_search_caseins
// file logfile.c line 198
static signed int iter_forward_search_caseins(const struct _GtkTextIter *iter, char *str, struct _GtkTextIter *match_start, struct _GtkTextIter *match_end)
{
  struct _GtkTextIter start = *iter;
  struct _GtkTextIter next;
  char *line_text;
  char *found;
  char *pnt;
  signed int offset;
  char *strcaseins;
  if(str == ((char *)NULL))
    return 0;

  else
  {
    strcaseins=strdup(str);
    pnt = strcaseins;
    while(!(*pnt == 0))
    {
      signed int return_value_toupper_1;
      return_value_toupper_1=toupper((signed int)(unsigned char)*pnt);
      *pnt = (char)return_value_toupper_1;
      pnt = pnt + 1l;
    }
    do
    {
      next = start;
      gtk_text_iter_forward_line(&next);
      signed int return_value_gtk_text_iter_equal_2;
      return_value_gtk_text_iter_equal_2=gtk_text_iter_equal(&start, &next);
      if(!(return_value_gtk_text_iter_equal_2 == 0))
      {
        free((void *)strcaseins);
        return 0;
      }

      line_text=gtk_text_iter_get_visible_text(&start, &next);
      pnt = line_text;
      while(!(*pnt == 0))
      {
        signed int return_value_toupper_3;
        return_value_toupper_3=toupper((signed int)(unsigned char)*pnt);
        *pnt = (char)return_value_toupper_3;
        pnt = pnt + 1l;
      }
      found=strstr(line_text, strcaseins);
      if(!(found == ((char *)NULL)))
      {
        char cached = *found;
        *found = (char)0;
        signed long int return_value_g_utf8_strlen_4;
        return_value_g_utf8_strlen_4=g_utf8_strlen(line_text, (signed long int)-1);
        offset = (signed int)return_value_g_utf8_strlen_4;
        *found = cached;
        break;
      }

      g_free((void *)line_text);
      start = next;
    }
    while((_Bool)1);
    *match_start = start;
    forward_chars_with_skipping(match_start, offset);
    signed long int return_value_g_utf8_strlen_5;
    return_value_g_utf8_strlen_5=g_utf8_strlen(str, (signed long int)-1);
    offset = (signed int)return_value_g_utf8_strlen_5;
    *match_end = *match_start;
    forward_chars_with_skipping(match_end, offset);
    free((void *)strcaseins);
    return (signed int)!(0 != 0);
  }
}

// jrb_delete_node
// file jrb.c line 403
extern void jrb_delete_node(struct jrb_node *n)
{
  struct jrb_node *s;
  struct jrb_node *p;
  struct jrb_node *gp;
  char ir;
  if(!(n->internal == 0))
  {
    fprintf(stderr, "Cannot delete an internal node: 0x%p\n", (void *)n);
    exit(1);
  }

  if(!((2 & (signed int)n->roothead) == 0))
  {
    fprintf(stderr, "Cannot delete the head of an jrb_tree: 0x%p\n", (void *)n);
    exit(1);
  }

  delete_item(n);
  p = n->parent;
  struct jrb_node *tmp_if_expr_1;
  struct jrb_node *tmp_if_expr_2;
  struct jrb_node *tmp_if_expr_3;
  struct jrb_node *tmp_if_expr_4;
  struct jrb_node *tmp_if_expr_5;
  struct jrb_node *tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(!((1 & (signed int)n->roothead) == 0))
  {
    p->parent = p;
    free((void *)n);
  }

  else
  {
    if(!(n->left == 0))
      tmp_if_expr_1 = n->parent->blink;

    else
      tmp_if_expr_1 = n->parent->flink;
    s = tmp_if_expr_1;
    if(!((1 & (signed int)p->roothead) == 0))
    {
      s->parent = p->parent;
      s->parent->parent = s;
      s->roothead = s->roothead | (unsigned char)1;
      free((void *)p);
      free((void *)n);
    }

    else
    {
      gp = p->parent;
      s->parent = gp;
      if(!(p->left == 0))
      {
        gp->flink = s;
        s->left = (unsigned char)1;
      }

      else
      {
        gp->blink = s;
        s->left = (unsigned char)0;
      }
      ir = (char)p->red;
      free((void *)p);
      free((void *)n);
      if(s->internal == 0)
      {
        p=lprev(s);
        if((2 & (signed int)p->roothead) == 0)
          p->val.v = (void *)s;

        p=rprev(s);
        if((2 & (signed int)p->roothead) == 0)
          p->key.v = (void *)s;

      }

      else
        if(s->red == 0)
        {
          fprintf(stderr, "DELETION PROB -- sib is black, internal\n");
          exit(1);
        }

        else
        {
          p=lprev(s);
          if((2 & (signed int)p->roothead) == 0)
            p->val.v = (void *)s->flink;

          p=rprev(s);
          if((2 & (signed int)p->roothead) == 0)
            p->key.v = (void *)s->blink;

          s->red = (unsigned char)0;
          goto __CPROVER_DUMP_L41;
        }
      if(ir == 0)
      {
        n = s;
        p = n->parent;
        if(!(n->left == 0))
          tmp_if_expr_2 = n->parent->blink;

        else
          tmp_if_expr_2 = n->parent->flink;
        s = tmp_if_expr_2;
        for( ; p->red == 0; s = tmp_if_expr_3)
        {
          if(!(s->red == 0))
            break;

          if(s->internal == 0)
            break;

          if(!(s->flink->red == 0))
            break;

          if(!(s->blink->red == 0))
            break;

          s->red = (unsigned char)1;
          n = p;
          if(!((1 & (signed int)n->roothead) == 0))
            goto __CPROVER_DUMP_L41;

          p = n->parent;
          if(!(n->left == 0))
            tmp_if_expr_3 = n->parent->blink;

          else
            tmp_if_expr_3 = n->parent->flink;
        }
        if(p->red == 0)
        {
          if(!(s->red == 0))
          {
            single_rotate(p, (signed int)!(n->left != 0));
            p->red = (unsigned char)1;
            s->red = (unsigned char)0;
            if(!(n->left == 0))
              tmp_if_expr_4 = n->parent->blink;

            else
              tmp_if_expr_4 = n->parent->flink;
            s = tmp_if_expr_4;
          }

        }

        struct jrb_node *x;
        struct jrb_node *z;
        char il;
        if(s->internal == 0)
        {
          fprintf(stderr, "DELETION ERROR: sibling not internal\n");
          exit(1);
        }

        il = (char)n->left;
        if(!(il == 0))
          tmp_if_expr_5 = s->flink;

        else
          tmp_if_expr_5 = s->blink;
        x = tmp_if_expr_5;
        if(!(x->left == 0))
          tmp_if_expr_6 = x->parent->blink;

        else
          tmp_if_expr_6 = x->parent->flink;
        z = tmp_if_expr_6;
        if(!(z->red == 0))
        {
          single_rotate(p, (signed int)!(il != 0));
          z->red = (unsigned char)0;
          if(!(p->red == 0))
            s->red = (unsigned char)1;

          else
            s->red = (unsigned char)0;
          p->red = (unsigned char)0;
        }

        else
          if(x->red == 0)
          {
            if(!(s->red == 0))
              tmp_if_expr_7 = (_Bool)1;

            else
              tmp_if_expr_7 = !(p->red != 0) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_7)
            {
              fprintf(stderr, "DELETION ERROR: 2.3c not quite right\n");
              exit(1);
            }

            p->red = (unsigned char)0;
            s->red = (unsigned char)1;
            goto __CPROVER_DUMP_L41;
          }

          else
            if(!(p->red == 0))
            {
              single_rotate(s, (signed int)il);
              single_rotate(p, (signed int)!(il != 0));
              x->red = (unsigned char)0;
              s->red = (unsigned char)1;
              goto __CPROVER_DUMP_L41;
            }

            else
            {
              single_rotate(s, (signed int)il);
              single_rotate(p, (signed int)!(il != 0));
              x->red = (unsigned char)0;
              goto __CPROVER_DUMP_L41;
            }
      }

    }
  }

__CPROVER_DUMP_L41:
  ;
}

// jrb_find_gen
// file jrb.c line 272
extern struct jrb_node * jrb_find_gen(struct jrb_node *n, union anonymous_26 key, signed int (*fxn)(union anonymous_26, union anonymous_26))
{
  signed int fnd;
  struct jrb_node *j;
  j=jrb_find_gte_gen(n, key, fxn, &fnd);
  if(!(fnd == 0))
    return j;

  else
    return (struct jrb_node *)(void *)0;
}

// jrb_find_gte_gen
// file jrb.c line 244
extern struct jrb_node * jrb_find_gte_gen(struct jrb_node *n, union anonymous_26 key, signed int (*fxn)(union anonymous_26, union anonymous_26), signed int *fnd)
{
  signed int cmp;
  *fnd = 0;
  if((2 & (signed int)n->roothead) == 0)
  {
    fprintf(stderr, "jrb_find_gte_str called on non-head 0x%p\n", (void *)n);
    exit(1);
  }

  if(n->parent == n)
    return n;

  else
  {
    cmp=fxn(key, n->blink->key);
    if(cmp == 0)
    {
      *fnd = 1;
      return n->blink;
    }

    else
    {
      if(cmp >= 1)
        return n;

      else
        n = n->parent;
      if(n->internal == 0)
        return n;

      cmp=fxn(key, ((struct jrb_node *)n->key.v)->key);
      if(cmp == 0)
      {
        *fnd = 1;
        return (struct jrb_node *)n->key.v;
      }

      if(!(cmp >= 0))
        n = n->flink;

      else
        n = n->blink;
    }
  }
}

// jrb_find_gte_int
// file jrb.c line 178
extern struct jrb_node * jrb_find_gte_int(struct jrb_node *n, signed int ikey, signed int *fnd)
{
  *fnd = 0;
  if((2 & (signed int)n->roothead) == 0)
  {
    fprintf(stderr, "jrb_find_gte_int called on non-head 0x%p\n", (void *)n);
    exit(1);
  }

  struct jrb_node *tmp_if_expr_1;
  if(n->parent == n)
    return n;

  else
    if(ikey == n->blink->key.i)
    {
      *fnd = 1;
      return n->blink;
    }

    else
    {
      if(!(n->blink->key.i >= ikey))
        return n;

      else
        n = n->parent;
      for( ; (_Bool)1; n = tmp_if_expr_1)
      {
        if(n->internal == 0)
          return n;

        if(ikey == ((struct jrb_node *)n->key.v)->key.i)
        {
          *fnd = 1;
          return (struct jrb_node *)n->key.v;
        }

        if(!(ikey >= ((struct jrb_node *)n->key.v)->key.i))
          tmp_if_expr_1 = n->flink;

        else
          tmp_if_expr_1 = n->blink;
      }
    }
}

// jrb_find_gte_str
// file jrb.c line 142
extern struct jrb_node * jrb_find_gte_str(struct jrb_node *n, char *key, signed int *fnd)
{
  signed int cmp;
  *fnd = 0;
  if((2 & (signed int)n->roothead) == 0)
  {
    fprintf(stderr, "jrb_find_gte_str called on non-head 0x%p\n", (void *)n);
    exit(1);
  }

  if(n->parent == n)
    return n;

  else
  {
    cmp=strcmp(key, n->blink->key.s);
    if(cmp == 0)
    {
      *fnd = 1;
      return n->blink;
    }

    else
    {
      if(cmp >= 1)
        return n;

      else
        n = n->parent;
      while((_Bool)1)
      {
        if(n->internal == 0)
          return n;

        cmp=strcmp(key, ((struct jrb_node *)n->key.v)->key.s);
        if(cmp == 0)
        {
          *fnd = 1;
          return (struct jrb_node *)n->key.v;
        }

        if(!(cmp >= 0))
          n = n->flink;

        else
          n = n->blink;
      }
    }
  }
}

// jrb_find_gte_vptr
// file jrb.c line 211
extern struct jrb_node * jrb_find_gte_vptr(struct jrb_node *n, void *vkey, signed int *fnd)
{
  *fnd = 0;
  if((2 & (signed int)n->roothead) == 0)
  {
    fprintf(stderr, "jrb_find_gte_int called on non-head 0x%p\n", (void *)n);
    exit(1);
  }

  struct jrb_node *tmp_if_expr_1;
  if(n->parent == n)
    return n;

  else
    if((char *)vkey == (char *)n->blink->key.v)
    {
      *fnd = 1;
      return n->blink;
    }

    else
    {
      if(!((char *)n->blink->key.v >= (char *)vkey))
        return n;

      else
        n = n->parent;
      for( ; (_Bool)1; n = tmp_if_expr_1)
      {
        if(n->internal == 0)
          return n;

        if((char *)vkey == (char *)((struct jrb_node *)n->key.v)->key.v)
        {
          *fnd = 1;
          return (struct jrb_node *)n->key.v;
        }

        if(!((char *)vkey >= (char *)((struct jrb_node *)n->key.v)->key.v))
          tmp_if_expr_1 = n->flink;

        else
          tmp_if_expr_1 = n->blink;
      }
    }
}

// jrb_find_int
// file jrb.h line 66
extern struct jrb_node * jrb_find_int(struct jrb_node *n, signed int ikey)
{
  signed int fnd;
  struct jrb_node *j;
  j=jrb_find_gte_int(n, ikey, &fnd);
  if(!(fnd == 0))
    return j;

  else
    return (struct jrb_node *)(void *)0;
}

// jrb_find_str
// file jrb.h line 65
extern struct jrb_node * jrb_find_str(struct jrb_node *n, char *key)
{
  signed int fnd;
  struct jrb_node *j;
  j=jrb_find_gte_str(n, key, &fnd);
  if(!(fnd == 0))
    return j;

  else
    return (struct jrb_node *)(void *)0;
}

// jrb_find_vptr
// file jrb.c line 235
extern struct jrb_node * jrb_find_vptr(struct jrb_node *n, void *vkey)
{
  signed int fnd;
  struct jrb_node *j;
  j=jrb_find_gte_vptr(n, vkey, &fnd);
  if(!(fnd == 0))
    return j;

  else
    return (struct jrb_node *)(void *)0;
}

// jrb_free_tree
// file jrb.h line 88
extern void jrb_free_tree(struct jrb_node *n)
{
  if((2 & (signed int)n->roothead) == 0)
  {
    fprintf(stderr, "ERROR: Rb_free_tree called on a non-head node\n");
    exit(1);
  }

  while(!(n->flink == n))
    jrb_delete_node(n->flink);
  free((void *)n);
}

// jrb_insert_b
// file jrb.c line 281
static struct jrb_node * jrb_insert_b(struct jrb_node *n, union anonymous_26 key, union anonymous_26 val)
{
  struct jrb_node *newleft;
  struct jrb_node *newright;
  struct jrb_node *newnode;
  struct jrb_node *p;
  if(!((2 & (signed int)n->roothead) == 0))
  {
    if(n->parent == n)
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct jrb_node) /*64ul*/ );
      newnode = (struct jrb_node *)return_value_calloc_1;
      newnode->val = val;
      newnode->key = key;
      newnode->internal = (unsigned char)0;
      newnode->red = (unsigned char)0;
      newnode->roothead = (unsigned char)0;
      insert(newnode, n);
      n->parent = newnode;
      newnode->parent = n;
      newnode->roothead = newnode->roothead | (unsigned char)1;
      return newnode;
    }

    else
    {
      void *return_value_calloc_2;
      return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct jrb_node) /*64ul*/ );
      newright = (struct jrb_node *)return_value_calloc_2;
      newright->val = val;
      newright->key = key;
      newright->internal = (unsigned char)0;
      newright->red = (unsigned char)0;
      newright->roothead = (unsigned char)0;
      insert(newright, n);
      newleft = newright->blink;
      newleft->roothead = (unsigned char)0;
      mk_new_int(newleft, newright, newleft->parent, (signed int)newleft->left);
      p=rprev(newright);
      if((2 & (signed int)p->roothead) == 0)
        p->key.v = (void *)newright;

      return newright;
    }
  }

  else
  {
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)1, sizeof(struct jrb_node) /*64ul*/ );
    newleft = (struct jrb_node *)return_value_calloc_3;
    newleft->val = val;
    newleft->key = key;
    newleft->internal = (unsigned char)0;
    newleft->red = (unsigned char)0;
    newleft->roothead = (unsigned char)0;
    insert(newleft, n);
    n->roothead = (unsigned char)0;
    mk_new_int(newleft, n, n->parent, (signed int)n->left);
    p=lprev(newleft);
    if((2 & (signed int)p->roothead) == 0)
      p->val.v = (void *)newleft;

    return newleft;
  }
}

// jrb_insert_gen
// file jrb.c line 601
extern struct jrb_node * jrb_insert_gen(struct jrb_node *tree, union anonymous_26 key, union anonymous_26 val, signed int (*func)(union anonymous_26, union anonymous_26))
{
  signed int fnd;
  struct jrb_node *return_value_jrb_find_gte_gen_1;
  return_value_jrb_find_gte_gen_1=jrb_find_gte_gen(tree, key, func, &fnd);
  struct jrb_node *return_value_jrb_insert_b_2;
  return_value_jrb_insert_b_2=jrb_insert_b(return_value_jrb_find_gte_gen_1, key, val);
  return return_value_jrb_insert_b_2;
}

// jrb_insert_int
// file jrb.h line 58
extern struct jrb_node * jrb_insert_int(struct jrb_node *tree, signed int ikey, union anonymous_26 val)
{
  union anonymous_26 k;
  signed int fnd;
  k.i = ikey;
  struct jrb_node *return_value_jrb_find_gte_int_1;
  return_value_jrb_find_gte_int_1=jrb_find_gte_int(tree, ikey, &fnd);
  struct jrb_node *return_value_jrb_insert_b_2;
  return_value_jrb_insert_b_2=jrb_insert_b(return_value_jrb_find_gte_int_1, k, val);
  return return_value_jrb_insert_b_2;
}

// jrb_insert_str
// file jrb.h line 57
extern struct jrb_node * jrb_insert_str(struct jrb_node *tree, char *key, union anonymous_26 val)
{
  union anonymous_26 k;
  signed int fnd;
  k.s = key;
  struct jrb_node *return_value_jrb_find_gte_str_1;
  return_value_jrb_find_gte_str_1=jrb_find_gte_str(tree, key, &fnd);
  struct jrb_node *return_value_jrb_insert_b_2;
  return_value_jrb_insert_b_2=jrb_insert_b(return_value_jrb_find_gte_str_1, k, val);
  return return_value_jrb_insert_b_2;
}

// jrb_insert_vptr
// file jrb.c line 592
extern struct jrb_node * jrb_insert_vptr(struct jrb_node *tree, void *vkey, union anonymous_26 val)
{
  union anonymous_26 k;
  signed int fnd;
  k.v = vkey;
  struct jrb_node *return_value_jrb_find_gte_vptr_1;
  return_value_jrb_find_gte_vptr_1=jrb_find_gte_vptr(tree, vkey, &fnd);
  struct jrb_node *return_value_jrb_insert_b_2;
  return_value_jrb_insert_b_2=jrb_insert_b(return_value_jrb_find_gte_vptr_1, k, val);
  return return_value_jrb_insert_b_2;
}

// jrb_nblack
// file jrb.c line 524
extern signed int jrb_nblack(struct jrb_node *n)
{
  signed int nb;
  _Bool tmp_if_expr_1;
  if(!((2 & (signed int)n->roothead) == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = n->internal != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    fprintf(stderr, "ERROR: jrb_nblack called on a non-external node 0x%p\n", (void *)n);
    exit(1);
  }

  nb = 0;
  for( ; (2 & (signed int)n->roothead) == 0; n = n->parent)
    if(n->red == 0)
      nb = nb + 1;

  return nb;
}

// jrb_plength
// file jrb.c line 540
signed int jrb_plength(struct jrb_node *n)
{
  signed int pl;
  _Bool tmp_if_expr_1;
  if(!((2 & (signed int)n->roothead) == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = n->internal != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    fprintf(stderr, "ERROR: jrb_plength called on a non-external node 0x%p\n", (void *)n);
    exit(1);
  }

  pl = 0;
  for( ; (2 & (signed int)n->roothead) == 0; n = n->parent)
    pl = pl + 1;
  return pl;
}

// jrb_val
// file jrb.c line 569
extern union anonymous_26 jrb_val(struct jrb_node *n)
{
  return n->val;
}

// log_realize_text
// file logfile.c line 1096
static void log_realize_text(struct _GtkWidget *text, void *data)
{
  (void)text;
  (void)data;
}

// log_text
// file logfile.c line 1047
void log_text(struct _GtkWidget *text, struct _GdkFont *font, char *str)
{
  (void)font;
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
  gtk_text_buffer_insert_with_tags(((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer, &iterx, str, -1, mono_tag, size_tag, (void *)0);
}

// log_text_active
// file logfile.c line 1071
void log_text_active(struct _GtkWidget *text, struct _GdkFont *font, char *str)
{
  (void)font;
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
  gtk_text_buffer_insert_with_tags(((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer, &iterx, str, -1, dgray_tag, mono_tag, size_tag, (void *)0);
}

// log_text_bold
// file logfile.c line 1059
void log_text_bold(struct _GtkWidget *text, struct _GdkFont *font, char *str)
{
  (void)font;
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
  gtk_text_buffer_insert_with_tags(((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer, &iterx, str, -1, bold_tag, mono_tag, size_tag, fwht_tag, blue_tag, (void *)0);
}

// log_text_prelight
// file logfile.c line 1083
void log_text_prelight(struct _GtkWidget *text, struct _GdkFont *font, char *str)
{
  (void)font;
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
  gtk_text_buffer_insert_with_tags(((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer, &iterx, str, -1, lgray_tag, mono_tag, size_tag, (void *)0);
}

// lprev
// file jrb.c line 109
static struct jrb_node * lprev(struct jrb_node *n)
{
  if(!((2 & (signed int)n->roothead) == 0))
    return n;

  else
  {
    for( ; (1 & (signed int)n->roothead) == 0; n = n->parent)
      if(n->left == 0)
        return n->parent;

    return n->parent;
  }
}

// lx2_iter_fn
// file logfile.c line 1108
static void lx2_iter_fn(struct lxt2_rd_trace **lt, unsigned long int *pnt_time, unsigned int *pnt_facidx, char **pnt_value)
{
  (void)lt;
  if((unsigned long int)anno_ctx->marker >= *pnt_time)
  {
    struct jrb_node *node;
    node=jrb_find_int(lx2vals, (signed int)*pnt_facidx);
    union anonymous_26 jv;
    if(!(node == ((struct jrb_node *)NULL)))
    {
      free((void *)node->val.s);
      node->val.s=strdup(*pnt_value);
    }

    else
    {
      jv.s=strdup(*pnt_value);
      jrb_insert_int(lx2vals, (signed int)*pnt_facidx, jv);
    }
  }

}

// lxt2_rd_build_radix
// file ./../../src/helpers/lxt2_read.c line 474
static void lxt2_rd_build_radix(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b, signed int granule, unsigned int strtfac, unsigned int endfac)
{
  unsigned int i;
  signed int offset;
  i = (unsigned int)0;
  for( ; !(i >= 65u); i = i + 1u)
    lt->radix_sort[(signed long int)i] = (void **)(void *)0;
  i = strtfac;
  for( ; !(i >= endfac); i = i + 1u)
  {
    unsigned long int x;
    signed int process_idx = (signed int)(i / (unsigned int)8);
    signed int process_bit = (signed int)(i & (unsigned int)7);
    if(!((1 << process_bit & (signed int)lt->process_mask[(signed long int)process_idx]) == 0))
    {
      x = lt->fac_map[(signed long int)i];
      if(!(x == 0ul))
      {
        if(granule == 0 && !((1ULL & x) == 0ul))
        {
          lxt2_rd_iter_radix0(lt, b, i);
          x = x & ~1ULL;
          lt->fac_map[(signed long int)i] = x;
          if(x == 0ul)
            goto __CPROVER_DUMP_L6;

        }

        unsigned long int return_value_lxt2_rd_tzc_1;
        return_value_lxt2_rd_tzc_1=lxt2_rd_tzc(x);
        offset = (signed int)return_value_lxt2_rd_tzc_1;
        lt->next_radix[(signed long int)i] = (void *)lt->radix_sort[(signed long int)offset];
        lt->radix_sort[(signed long int)offset] = &lt->next_radix[(signed long int)i];
      }

    }


  __CPROVER_DUMP_L6:
    ;
  }
}

// lxt2_rd_close
// file ./../../src/helpers/lxt2_read.c line 1027
void lxt2_rd_close(struct lxt2_rd_trace *lt)
{
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
  {
    struct lxt2_rd_block *b;
    struct lxt2_rd_block *bt;
    unsigned int i;
    if(!(lt->process_mask == ((char *)NULL)))
    {
      free((void *)lt->process_mask);
      lt->process_mask = (char *)(void *)0;
    }

    if(!(lt->process_mask_compressed == ((char *)NULL)))
    {
      free((void *)lt->process_mask_compressed);
      lt->process_mask_compressed = (char *)(void *)0;
    }

    if(!(lt->rows == ((unsigned int *)NULL)))
    {
      free((void *)lt->rows);
      lt->rows = (unsigned int *)(void *)0;
    }

    if(!(lt->msb == ((signed int *)NULL)))
    {
      free((void *)lt->msb);
      lt->msb = (signed int *)(void *)0;
    }

    if(!(lt->lsb == ((signed int *)NULL)))
    {
      free((void *)lt->lsb);
      lt->lsb = (signed int *)(void *)0;
    }

    if(!(lt->flags == ((unsigned int *)NULL)))
    {
      free((void *)lt->flags);
      lt->flags = (unsigned int *)(void *)0;
    }

    if(!(lt->len == ((unsigned int *)NULL)))
    {
      free((void *)lt->len);
      lt->len = (unsigned int *)(void *)0;
    }

    if(!(lt->next_radix == ((void **)NULL)))
    {
      free((void *)lt->next_radix);
      lt->next_radix = (void **)(void *)0;
    }

    i = (unsigned int)0;
    for( ; !(i >= lt->numfacs); i = i + 1u)
      if(!(lt->value[(signed long int)i] == ((char *)NULL)))
      {
        free((void *)lt->value[(signed long int)i]);
        lt->value[(signed long int)i] = (char *)(void *)0;
      }

    if(!(lt->value == ((char **)NULL)))
    {
      free((void *)lt->value);
      lt->value = (char **)(void *)0;
    }

    if(!(lt->zfacnames == ((char *)NULL)))
    {
      free((void *)lt->zfacnames);
      lt->zfacnames = (char *)(void *)0;
    }

    if(!(lt->faccache == ((struct lxt2_rd_facname_cache *)NULL)))
    {
      if(!(lt->faccache->bufprev == ((char *)NULL)))
      {
        free((void *)lt->faccache->bufprev);
        lt->faccache->bufprev = (char *)(void *)0;
      }

      if(!(lt->faccache->bufcurr == ((char *)NULL)))
      {
        free((void *)lt->faccache->bufcurr);
        lt->faccache->bufcurr = (char *)(void *)0;
      }

      free((void *)lt->faccache);
      lt->faccache = (struct lxt2_rd_facname_cache *)(void *)0;
    }

    if(!(lt->fac_map == ((unsigned long int *)NULL)))
    {
      free((void *)lt->fac_map);
      lt->fac_map = (unsigned long int *)(void *)0;
    }

    if(!(lt->fac_curpos == ((char **)NULL)))
    {
      free((void *)lt->fac_curpos);
      lt->fac_curpos = (char **)(void *)0;
    }

    b = lt->block_head;
    for( ; !(b == ((struct lxt2_rd_block *)NULL)); b = bt)
    {
      bt = b->next;
      if(!(b->mem == ((char *)NULL)))
      {
        free((void *)b->mem);
        b->mem = (char *)(void *)0;
      }

      if(!(b->string_pointers == ((char **)NULL)))
      {
        free((void *)b->string_pointers);
        b->string_pointers = (char **)(void *)0;
      }

      if(!(b->string_lens == ((unsigned int *)NULL)))
      {
        free((void *)b->string_lens);
        b->string_lens = (unsigned int *)(void *)0;
      }

      free((void *)b);
    }
    lt->block_curr = (struct lxt2_rd_block *)(void *)0;
    lt->block_head = lt->block_curr;
    if(!(lt->zhandle == ((struct gzFile_s *)NULL)))
    {
      gzclose(lt->zhandle);
      lt->zhandle = (struct gzFile_s *)(void *)0;
    }

    if(!(lt->handle == ((struct _IO_FILE *)NULL)))
    {
      fclose(lt->handle);
      lt->handle = (struct _IO_FILE *)(void *)0;
    }

    free((void *)lt);
  }

}

// lxt2_rd_expand_bits_to_integer
// file ./../../src/helpers/lxt2_read.c line 154
unsigned int lxt2_rd_expand_bits_to_integer(signed int len, char *s)
{
  unsigned int v = (unsigned int)0;
  signed int i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    v = v << 1;
    v = v | (unsigned int)((signed int)*s & 1);
    s = s + 1l;
  }
  return v;
}

// lxt2_rd_expand_integer_to_bits
// file ./../../src/helpers/lxt2_read.c line 137
static char * lxt2_rd_expand_integer_to_bits(signed int len, unsigned int value)
{
  static char s[33l];
  char *p = s;
  signed int i;
  signed int len2 = len - 1;
  i = 0;
  char *tmp_post_1;
  for( ; !(i >= len); i = i + 1)
  {
    tmp_post_1 = p;
    p = p + 1l;
    *tmp_post_1 = (char)(48 | (signed int)((value & (unsigned int)(1 << len2 - i)) != (unsigned int)0));
  }
  *p = (char)0;
  return s;
}

// lxt2_rd_get_16
// file ./../../src/helpers/lxt2_read.c line 53
static unsigned int lxt2_rd_get_16(void *mm, signed int offset)
{
  unsigned char *nn = (unsigned char *)mm + (signed long int)offset;
  unsigned int m1;
  unsigned char *tmp_post_1 = nn;
  nn = nn + 1l;
  m1 = (unsigned int)*((unsigned char *)tmp_post_1);
  unsigned int m2 = (unsigned int)*((unsigned char *)nn);
  return m1 << 8 | m2;
}

// lxt2_rd_get_24
// file ./../../src/helpers/lxt2_read.c line 61
static unsigned int lxt2_rd_get_24(void *mm, signed int offset)
{
  unsigned char *nn = (unsigned char *)mm + (signed long int)offset;
  unsigned int m1;
  unsigned char *tmp_post_1 = nn;
  nn = nn + 1l;
  m1 = (unsigned int)*((unsigned char *)tmp_post_1);
  unsigned int m2;
  unsigned char *tmp_post_2 = nn;
  nn = nn + 1l;
  m2 = (unsigned int)*((unsigned char *)tmp_post_2);
  unsigned int m3 = (unsigned int)*((unsigned char *)nn);
  return m1 << 16 | m2 << 8 | m3;
}

// lxt2_rd_get_32
// file ./../../src/helpers/lxt2_read.c line 70
static unsigned int lxt2_rd_get_32(void *mm, signed int offset)
{
  unsigned char *nn = (unsigned char *)mm + (signed long int)offset;
  unsigned int m1;
  unsigned char *tmp_post_1 = nn;
  nn = nn + 1l;
  m1 = (unsigned int)*((unsigned char *)tmp_post_1);
  unsigned int m2;
  unsigned char *tmp_post_2 = nn;
  nn = nn + 1l;
  m2 = (unsigned int)*((unsigned char *)tmp_post_2);
  unsigned int m3;
  unsigned char *tmp_post_3 = nn;
  nn = nn + 1l;
  m3 = (unsigned int)*((unsigned char *)tmp_post_3);
  unsigned int m4 = (unsigned int)*((unsigned char *)nn);
  return m1 << 24 | m2 << 16 | m3 << 8 | m4;
}

// lxt2_rd_get_64
// file ./../../src/helpers/lxt2_read.c line 80
static unsigned long int lxt2_rd_get_64(void *mm, signed int offset)
{
  unsigned int return_value_lxt2_rd_get_32_1;
  return_value_lxt2_rd_get_32_1=lxt2_rd_get_32(mm, offset);
  unsigned int return_value_lxt2_rd_get_32_2;
  return_value_lxt2_rd_get_32_2=lxt2_rd_get_32(mm, offset + 4);
  return (unsigned long int)return_value_lxt2_rd_get_32_1 << 32 | (unsigned long int)return_value_lxt2_rd_get_32_2;
}

// lxt2_rd_get_fac_geometry
// file ./../../src/helpers/lxt2_read.c line 1103
struct lxt2_rd_geometry * lxt2_rd_get_fac_geometry(struct lxt2_rd_trace *lt, unsigned int facidx)
{
  _Bool tmp_if_expr_1;
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
    tmp_if_expr_1 = facidx < lt->numfacs ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    lt->geometry.rows = lt->rows[(signed long int)facidx];
    lt->geometry.msb = lt->msb[(signed long int)facidx];
    lt->geometry.lsb = lt->lsb[(signed long int)facidx];
    lt->geometry.flags = lt->flags[(signed long int)facidx];
    lt->geometry.len = lt->len[(signed long int)facidx];
    return &lt->geometry;
  }

  else
    return (struct lxt2_rd_geometry *)(void *)0;
}

// lxt2_rd_get_facname
// file ../../src/helpers/lxt2_read.h line 274
char * lxt2_rd_get_facname(struct lxt2_rd_trace *lt, unsigned int facidx)
{
  char *pnt;
  unsigned int clone;
  unsigned int j;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
  {
    if(facidx == 1u + lt->faccache->old_facidx || facidx == 0u)
    {
      if(facidx == 0u)
      {
        lt->faccache->n = lt->zfacnames;
        lt->faccache->bufcurr[(signed long int)0] = (char)0;
        lt->faccache->bufprev[(signed long int)0] = (char)0;
      }

      if(!(facidx == lt->numfacs))
      {
        pnt = lt->faccache->bufcurr;
        lt->faccache->bufcurr = lt->faccache->bufprev;
        lt->faccache->bufprev = pnt;
        clone=lxt2_rd_get_16((void *)lt->faccache->n, 0);
        lt->faccache->n = lt->faccache->n + (signed long int)2;
        pnt = lt->faccache->bufcurr;
        j = (unsigned int)0;
        for( ; !(j >= clone); j = j + 1u)
        {
          tmp_post_1 = pnt;
          pnt = pnt + 1l;
          *tmp_post_1 = lt->faccache->bufprev[(signed long int)j];
        }
        do
        {
          tmp_post_2 = pnt;
          pnt = pnt + 1l;
          tmp_post_3 = lt->faccache->n;
          lt->faccache->n = lt->faccache->n + 1l;
          *tmp_post_2 = (char)(unsigned int)((unsigned char *)tmp_post_3)[(signed long int)0];
          if(*tmp_post_2 == 0)
            break;

        }
        while((_Bool)1);
        lt->faccache->old_facidx = facidx;
        return lt->faccache->bufcurr;
      }

      else
        return (char *)(void *)0;
    }

    else
      if(!(facidx >= lt->numfacs))
      {
        signed int strt;
        if(facidx == lt->faccache->old_facidx)
          return lt->faccache->bufcurr;

        if(!(1u + lt->faccache->old_facidx >= facidx))
          strt = (signed int)(lt->faccache->old_facidx + (unsigned int)1);

        else
          strt = 0;
        j = (unsigned int)strt;
        for( ; !(j >= facidx); j = j + 1u)
          lxt2_rd_get_facname(lt, j);
        char *return_value_lxt2_rd_get_facname_4;
        return_value_lxt2_rd_get_facname_4=lxt2_rd_get_facname(lt, j);
        return return_value_lxt2_rd_get_facname_4;
      }

  }

  return (char *)(void *)0;
}

// lxt2_rd_get_num_active_blocks
// file ./../../src/helpers/lxt2_read.c line 1431
unsigned int lxt2_rd_get_num_active_blocks(struct lxt2_rd_trace *lt)
{
  signed int blk = 0;
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
  {
    struct lxt2_rd_block *b = lt->block_head;
    for( ; !(b == ((struct lxt2_rd_block *)NULL)); b = b->next)
      if(b->short_read_ignore == 0u)
      {
        if(b->exclude_block == 0u)
          blk = blk + 1;

      }

  }

  return (unsigned int)blk;
}

// lxt2_rd_init
// file ../../src/helpers/lxt2_read.h line 265
struct lxt2_rd_trace * lxt2_rd_init(const char *name)
{
  struct lxt2_rd_trace *lt;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct lxt2_rd_trace) /*1320ul*/ );
  lt = (struct lxt2_rd_trace *)return_value_calloc_1;
  unsigned int i;
  lt->handle=fopen(name, "rb");
  unsigned int return_value_lxt2_rd_get_16_58;
  unsigned int tmp_if_expr_6;
  unsigned int return_value_lxt2_rd_get_32_5;
  unsigned int tmp_if_expr_8;
  unsigned int return_value_lxt2_rd_get_32_7;
  unsigned int tmp_if_expr_10;
  unsigned int return_value_lxt2_rd_get_32_9;
  unsigned long int tmp_if_expr_12;
  unsigned long int return_value_lxt2_rd_get_64_11;
  unsigned int tmp_if_expr_14;
  unsigned int return_value_lxt2_rd_get_32_13;
  unsigned int tmp_if_expr_16;
  unsigned int return_value_lxt2_rd_get_32_15;
  unsigned int tmp_if_expr_18;
  unsigned int return_value_lxt2_rd_get_32_17;
  unsigned int tmp_if_expr_20;
  unsigned int return_value_lxt2_rd_get_32_19;
  unsigned int tmp_if_expr_22;
  unsigned int return_value_lxt2_rd_get_32_21;
  signed int tmp_if_expr_43;
  unsigned int tmp_if_expr_49;
  unsigned int return_value_lxt2_rd_get_32_48;
  unsigned int tmp_if_expr_51;
  unsigned int return_value_lxt2_rd_get_32_50;
  unsigned long int tmp_if_expr_53;
  unsigned long int return_value_lxt2_rd_get_64_52;
  unsigned long int tmp_if_expr_55;
  unsigned long int return_value_lxt2_rd_get_64_54;
  _Bool tmp_if_expr_56;
  _Bool tmp_if_expr_57;
  if(lt->handle == ((struct _IO_FILE *)NULL))
  {
    lxt2_rd_close(lt);
    lt = (struct lxt2_rd_trace *)(void *)0;
  }

  else
  {
    unsigned short int id = (unsigned short int)0;
    unsigned short int version = (unsigned short int)0;
    lt->block_mem_max = (unsigned long int)(64 * 1024 * 1024);
    setvbuf(lt->handle, (char *)(void *)0, 2, (unsigned long int)0);
    unsigned long int return_value_fread_2;
    return_value_fread_2=fread((void *)&id, (unsigned long int)2, (unsigned long int)1, lt->handle);
    if(return_value_fread_2 == 0ul)
      id = (unsigned short int)0;

    unsigned long int return_value_fread_3;
    return_value_fread_3=fread((void *)&version, (unsigned long int)2, (unsigned long int)1, lt->handle);
    if(return_value_fread_3 == 0ul)
      id = (unsigned short int)0;

    unsigned long int return_value_fread_4;
    return_value_fread_4=fread((void *)&lt->granule_size, (unsigned long int)1, (unsigned long int)1, lt->handle);
    if(return_value_fread_4 == 0ul)
      id = (unsigned short int)0;

    unsigned int return_value_lxt2_rd_get_16_59;
    return_value_lxt2_rd_get_16_59=lxt2_rd_get_16((void *)&id, 0);
    if(!(return_value_lxt2_rd_get_16_59 == 4992u))
    {
      fprintf(stderr, "LXTLOAD | *** Not an lxt file ***\n");
      lxt2_rd_close(lt);
      lt = (struct lxt2_rd_trace *)(void *)0;
    }

    else
    {
      return_value_lxt2_rd_get_16_58=lxt2_rd_get_16((void *)&version, 0);
      version = (unsigned short int)return_value_lxt2_rd_get_16_58;
      if((signed int)version >= 2)
      {
        fprintf(stderr, "LXTLOAD | *** Version %d lxt not supported ***\n", version);
        lxt2_rd_close(lt);
        lt = (struct lxt2_rd_trace *)(void *)0;
      }

      else
        if((signed int)lt->granule_size >= 65)
        {
          fprintf(stderr, "LXTLOAD | *** Granule size of %d (>%d) not supported ***\n", lt->granule_size, 64);
          lxt2_rd_close(lt);
          lt = (struct lxt2_rd_trace *)(void *)0;
        }

        else
        {
          unsigned long int rcf;
          signed int rc;
          char *m;
          signed long int pos;
          signed long int fend;
          signed int t;
          struct lxt2_rd_block *b;
          rcf=fread((void *)&lt->numfacs, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_lxt2_rd_get_32_5=lxt2_rd_get_32((void *)&lt->numfacs, 0);
            tmp_if_expr_6 = return_value_lxt2_rd_get_32_5;
          }

          else
            tmp_if_expr_6 = (unsigned int)0;
          lt->numfacs = tmp_if_expr_6;
          if(lt->numfacs == 0u)
          {
            unsigned int num_expansion_bytes;
            rcf=fread((void *)&num_expansion_bytes, (unsigned long int)4, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_lxt2_rd_get_32_7=lxt2_rd_get_32((void *)&num_expansion_bytes, 0);
              tmp_if_expr_8 = return_value_lxt2_rd_get_32_7;
            }

            else
              tmp_if_expr_8 = (unsigned int)0;
            num_expansion_bytes = tmp_if_expr_8;
            rcf=fread((void *)&lt->numfacs, (unsigned long int)4, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_lxt2_rd_get_32_9=lxt2_rd_get_32((void *)&lt->numfacs, 0);
              tmp_if_expr_10 = return_value_lxt2_rd_get_32_9;
            }

            else
              tmp_if_expr_10 = (unsigned int)0;
            lt->numfacs = tmp_if_expr_10;
            if(num_expansion_bytes >= 8u)
            {
              rcf=fread((void *)&lt->timezero, (unsigned long int)8, (unsigned long int)1, lt->handle);
              if(!(rcf == 0ul))
              {
                return_value_lxt2_rd_get_64_11=lxt2_rd_get_64((void *)&lt->timezero, 0);
                tmp_if_expr_12 = return_value_lxt2_rd_get_64_11;
              }

              else
                tmp_if_expr_12 = (unsigned long int)0;
              lt->timezero = (signed long int)tmp_if_expr_12;
              if(num_expansion_bytes >= 9u)
                fseeko(lt->handle, (signed long int)(num_expansion_bytes - (unsigned int)8), 1);

            }

            else
              fseeko(lt->handle, (signed long int)num_expansion_bytes, 1);
          }

          rcf=fread((void *)&lt->numfacbytes, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_lxt2_rd_get_32_13=lxt2_rd_get_32((void *)&lt->numfacbytes, 0);
            tmp_if_expr_14 = return_value_lxt2_rd_get_32_13;
          }

          else
            tmp_if_expr_14 = (unsigned int)0;
          lt->numfacbytes = tmp_if_expr_14;
          rcf=fread((void *)&lt->longestname, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_lxt2_rd_get_32_15=lxt2_rd_get_32((void *)&lt->longestname, 0);
            tmp_if_expr_16 = return_value_lxt2_rd_get_32_15;
          }

          else
            tmp_if_expr_16 = (unsigned int)0;
          lt->longestname = tmp_if_expr_16;
          rcf=fread((void *)&lt->zfacnamesize, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_lxt2_rd_get_32_17=lxt2_rd_get_32((void *)&lt->zfacnamesize, 0);
            tmp_if_expr_18 = return_value_lxt2_rd_get_32_17;
          }

          else
            tmp_if_expr_18 = (unsigned int)0;
          lt->zfacnamesize = tmp_if_expr_18;
          rcf=fread((void *)&lt->zfacname_predec_size, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_lxt2_rd_get_32_19=lxt2_rd_get_32((void *)&lt->zfacname_predec_size, 0);
            tmp_if_expr_20 = return_value_lxt2_rd_get_32_19;
          }

          else
            tmp_if_expr_20 = (unsigned int)0;
          lt->zfacname_predec_size = tmp_if_expr_20;
          rcf=fread((void *)&lt->zfacgeometrysize, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_lxt2_rd_get_32_21=lxt2_rd_get_32((void *)&lt->zfacgeometrysize, 0);
            tmp_if_expr_22 = return_value_lxt2_rd_get_32_21;
          }

          else
            tmp_if_expr_22 = (unsigned int)0;
          lt->zfacgeometrysize = tmp_if_expr_22;
          rcf=fread((void *)&lt->timescale, (unsigned long int)1, (unsigned long int)1, lt->handle);
          if(rcf == 0ul)
            lt->timescale = (unsigned char)0;

          if(lt->numfacs == 0u)
          {
            fprintf(stderr, "LXTLOAD | *** Nothing to do, zero facilities found.\n");
            lxt2_rd_close(lt);
            lt = (struct lxt2_rd_trace *)(void *)0;
          }

          else
          {
            fprintf(stderr, "LXTLOAD | %d facilities\n", lt->numfacs);
            pos=ftello(lt->handle);
            void *return_value_calloc_23;
            return_value_calloc_23=calloc((unsigned long int)1, (unsigned long int)(lt->numfacs / (unsigned int)8 + (unsigned int)1));
            lt->process_mask = (char *)return_value_calloc_23;
            void *return_value_calloc_24;
            return_value_calloc_24=calloc((unsigned long int)1, (unsigned long int)(lt->numfacs / (unsigned int)2048 + (unsigned int)1));
            lt->process_mask_compressed = (char *)return_value_calloc_24;
            signed int return_value_fileno_25;
            return_value_fileno_25=fileno(lt->handle);
            signed int return_value_dup_26;
            return_value_dup_26=dup(return_value_fileno_25);
            lt->zhandle=gzdopen(return_value_dup_26, "rb");
            void *return_value_malloc_27;
            return_value_malloc_27=malloc((unsigned long int)lt->zfacname_predec_size);
            m = (char *)return_value_malloc_27;
            rc=gzread(lt->zhandle, (void *)m, lt->zfacname_predec_size);
            gzclose(lt->zhandle);
            lt->zhandle = (struct gzFile_s *)(void *)0;
            if(!((unsigned int)rc == lt->zfacname_predec_size))
            {
              fprintf(stderr, "LXTLOAD | *** name section mangled %d (act) vs %d (exp)\n", rc, lt->zfacname_predec_size);
              free((void *)m);
              lxt2_rd_close(lt);
              lt = (struct lxt2_rd_trace *)(void *)0;
              return lt;
            }

            lt->zfacnames = m;
            void *return_value_calloc_28;
            return_value_calloc_28=calloc((unsigned long int)1, sizeof(struct lxt2_rd_facname_cache) /*32ul*/ );
            lt->faccache = (struct lxt2_rd_facname_cache *)return_value_calloc_28;
            lt->faccache->old_facidx = lt->numfacs;
            void *return_value_malloc_29;
            return_value_malloc_29=malloc((unsigned long int)(lt->longestname + (unsigned int)1));
            lt->faccache->bufcurr = (char *)return_value_malloc_29;
            void *return_value_malloc_30;
            return_value_malloc_30=malloc((unsigned long int)(lt->longestname + (unsigned int)1));
            lt->faccache->bufprev = (char *)return_value_malloc_30;
            pos = pos + (signed long int)lt->zfacnamesize;
            fseeko(lt->handle, pos, 0);
            signed int return_value_fileno_31;
            return_value_fileno_31=fileno(lt->handle);
            signed int return_value_dup_32;
            return_value_dup_32=dup(return_value_fileno_31);
            lt->zhandle=gzdopen(return_value_dup_32, "rb");
            t = (signed int)((unsigned long int)(lt->numfacs * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ );
            void *return_value_malloc_33;
            return_value_malloc_33=malloc((unsigned long int)t);
            m = (char *)return_value_malloc_33;
            rc=gzread(lt->zhandle, (void *)m, (unsigned int)t);
            gzclose(lt->zhandle);
            lt->zhandle = (struct gzFile_s *)(void *)0;
            if(!(rc == t))
            {
              fprintf(stderr, "LXTLOAD | *** geometry section mangled %d (act) vs %d (exp)\n", rc, t);
              free((void *)m);
              lxt2_rd_close(lt);
              lt = (struct lxt2_rd_trace *)(void *)0;
              return lt;
            }

            pos = pos + (signed long int)lt->zfacgeometrysize;
            void *return_value_malloc_34;
            return_value_malloc_34=malloc((unsigned long int)lt->numfacs * sizeof(unsigned int) /*4ul*/ );
            lt->rows = (unsigned int *)return_value_malloc_34;
            void *return_value_malloc_35;
            return_value_malloc_35=malloc((unsigned long int)lt->numfacs * sizeof(signed int) /*4ul*/ );
            lt->msb = (signed int *)return_value_malloc_35;
            void *return_value_malloc_36;
            return_value_malloc_36=malloc((unsigned long int)lt->numfacs * sizeof(signed int) /*4ul*/ );
            lt->lsb = (signed int *)return_value_malloc_36;
            void *return_value_malloc_37;
            return_value_malloc_37=malloc((unsigned long int)lt->numfacs * sizeof(unsigned int) /*4ul*/ );
            lt->flags = (unsigned int *)return_value_malloc_37;
            void *return_value_malloc_38;
            return_value_malloc_38=malloc((unsigned long int)lt->numfacs * sizeof(unsigned int) /*4ul*/ );
            lt->len = (unsigned int *)return_value_malloc_38;
            void *return_value_malloc_39;
            return_value_malloc_39=malloc((unsigned long int)lt->numfacs * sizeof(char *) /*8ul*/ );
            lt->value = (char **)return_value_malloc_39;
            void *return_value_malloc_40;
            return_value_malloc_40=malloc((unsigned long int)lt->numfacs * sizeof(void *) /*8ul*/ );
            lt->next_radix = (void **)return_value_malloc_40;
            i = (unsigned int)0;
            for( ; !(i >= lt->numfacs); i = i + 1u)
            {
              lt->rows[(signed long int)i]=lxt2_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 0);
              unsigned int return_value_lxt2_rd_get_32_41;
              return_value_lxt2_rd_get_32_41=lxt2_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 4);
              lt->msb[(signed long int)i] = (signed int)return_value_lxt2_rd_get_32_41;
              unsigned int return_value_lxt2_rd_get_32_42;
              return_value_lxt2_rd_get_32_42=lxt2_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 8);
              lt->lsb[(signed long int)i] = (signed int)return_value_lxt2_rd_get_32_42;
              lt->flags[(signed long int)i]=lxt2_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 12);
              if((1u & lt->flags[(signed long int)i]) == 0u)
              {
                if(lt->lsb[(signed long int)i] >= lt->msb[(signed long int)i])
                  tmp_if_expr_43 = (lt->lsb[(signed long int)i] - lt->msb[(signed long int)i]) + 1;

                else
                  tmp_if_expr_43 = (lt->msb[(signed long int)i] - lt->lsb[(signed long int)i]) + 1;
                lt->len[(signed long int)i] = (unsigned int)tmp_if_expr_43;
              }

              else
                lt->len[(signed long int)i] = (unsigned int)32;
              void *return_value_calloc_44;
              return_value_calloc_44=calloc((unsigned long int)(lt->len[(signed long int)i] + (unsigned int)1), sizeof(char) /*1ul*/ );
              lt->value[(signed long int)i] = (char *)return_value_calloc_44;
            }
            lt->numrealfacs = (unsigned int)0;
            for( ; !(lt->numrealfacs >= lt->numfacs); lt->numrealfacs = lt->numrealfacs + 1u)
              if(!((8u & lt->flags[(signed long int)lt->numrealfacs]) == 0u))
                break;

            if(!(lt->numfacs >= lt->numrealfacs))
              lt->numrealfacs = lt->numfacs;

            lt->prev_time = ~0ULL;
            free((void *)m);
            void *return_value_malloc_45;
            return_value_malloc_45=malloc((unsigned long int)lt->numfacs * sizeof(unsigned long int) /*8ul*/ );
            lt->fac_map = (unsigned long int *)return_value_malloc_45;
            void *return_value_malloc_46;
            return_value_malloc_46=malloc((unsigned long int)lt->numfacs * sizeof(char *) /*8ul*/ );
            lt->fac_curpos = (char **)return_value_malloc_46;
            do
            {
              fseeko(lt->handle, 0L, 2);
              fend=ftello(lt->handle);
              if(pos >= fend)
                break;

              fseeko(lt->handle, pos, 0);
              void *return_value_calloc_47;
              return_value_calloc_47=calloc((unsigned long int)1, sizeof(struct lxt2_rd_block) /*96ul*/ );
              b = (struct lxt2_rd_block *)return_value_calloc_47;
              rcf=fread((void *)&b->uncompressed_siz, (unsigned long int)4, (unsigned long int)1, lt->handle);
              if(!(rcf == 0ul))
              {
                return_value_lxt2_rd_get_32_48=lxt2_rd_get_32((void *)&b->uncompressed_siz, 0);
                tmp_if_expr_49 = return_value_lxt2_rd_get_32_48;
              }

              else
                tmp_if_expr_49 = (unsigned int)0;
              b->uncompressed_siz = tmp_if_expr_49;
              rcf=fread((void *)&b->compressed_siz, (unsigned long int)4, (unsigned long int)1, lt->handle);
              if(!(rcf == 0ul))
              {
                return_value_lxt2_rd_get_32_50=lxt2_rd_get_32((void *)&b->compressed_siz, 0);
                tmp_if_expr_51 = return_value_lxt2_rd_get_32_50;
              }

              else
                tmp_if_expr_51 = (unsigned int)0;
              b->compressed_siz = tmp_if_expr_51;
              rcf=fread((void *)&b->start, (unsigned long int)8, (unsigned long int)1, lt->handle);
              if(!(rcf == 0ul))
              {
                return_value_lxt2_rd_get_64_52=lxt2_rd_get_64((void *)&b->start, 0);
                tmp_if_expr_53 = return_value_lxt2_rd_get_64_52;
              }

              else
                tmp_if_expr_53 = (unsigned long int)0;
              b->start = tmp_if_expr_53;
              rcf=fread((void *)&b->end, (unsigned long int)8, (unsigned long int)1, lt->handle);
              if(!(rcf == 0ul))
              {
                return_value_lxt2_rd_get_64_54=lxt2_rd_get_64((void *)&b->end, 0);
                tmp_if_expr_55 = return_value_lxt2_rd_get_64_54;
              }

              else
                tmp_if_expr_55 = (unsigned long int)0;
              b->end = tmp_if_expr_55;
              pos=ftello(lt->handle);
              fseeko(lt->handle, pos, 0);
              if(pos >= fend)
              {
                free((void *)b);
                break;
              }

              b->filepos = pos;
              if(!(b->uncompressed_siz == 0u))
                tmp_if_expr_56 = b->compressed_siz != 0u ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_56 = (_Bool)0;
              if(tmp_if_expr_56)
                tmp_if_expr_57 = b->end != 0ul ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_57 = (_Bool)0;
              if(tmp_if_expr_57)
              {
                fseeko(lt->handle, (signed long int)b->compressed_siz, 1);
                lt->numblocks = lt->numblocks + 1u;
                if(!(lt->block_curr == ((struct lxt2_rd_block *)NULL)))
                {
                  lt->block_curr->next = b;
                  lt->block_curr = b;
                  lt->end = b->end;
                }

                else
                {
                  lt->block_curr = b;
                  lt->block_head = lt->block_curr;
                  lt->start = b->start;
                  lt->end = b->end;
                }
              }

              else
              {
                free((void *)b);
                break;
              }
              pos = pos + (signed long int)b->compressed_siz;
            }
            while((_Bool)1);
            if(!(lt->numblocks == 0u))
            {
              fprintf(stderr, "LXTLOAD | Read %d block header%s OK\n", lt->numblocks, lt->numblocks != (unsigned int)1 ? "s" : "");
              fprintf(stderr, "LXTLOAD | [%ld] start time\n", lt->start);
              fprintf(stderr, "LXTLOAD | [%ld] end time\n", lt->end);
              fprintf(stderr, "LXTLOAD | \n");
              lt->value_change_callback = lxt2_rd_null_callback;
            }

            else
            {
              lxt2_rd_close(lt);
              lt = (struct lxt2_rd_trace *)(void *)0;
            }
          }
        }
    }
  }
  return lt;
}

// lxt2_rd_iter_blocks
// file ../../src/helpers/lxt2_read.h line 295
signed int lxt2_rd_iter_blocks(struct lxt2_rd_trace *lt, void (*value_change_callback)(struct lxt2_rd_trace **, unsigned long int *, unsigned int *, char **), void *user_callback_data_pointer)
{
  struct lxt2_rd_block *b;
  signed int blk = 0;
  signed int blkfinal = 0;
  signed int processed = 0;
  struct lxt2_rd_block *bcutoff = (struct lxt2_rd_block *)(void *)0;
  struct lxt2_rd_block *bfinal = (struct lxt2_rd_block *)(void *)0;
  signed int striped_kill = 0;
  unsigned int real_uncompressed_siz = (unsigned int)0;
  unsigned char gzid[2l];
  unsigned int i;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_18;
  unsigned int tmp_if_expr_6;
  unsigned int return_value_lxt2_rd_get_32_5;
  unsigned int tmp_if_expr_8;
  unsigned int return_value_lxt2_rd_get_32_7;
  unsigned int tmp_if_expr_10;
  unsigned int return_value_lxt2_rd_get_32_9;
  _Bool tmp_if_expr_14;
  signed int return_value_inflate_13;
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
  {
    lt->value_change_callback = value_change_callback != ((void (*)(struct lxt2_rd_trace **, unsigned long int *, unsigned int *, char **))NULL) ? value_change_callback : lxt2_rd_null_callback;
    lt->user_callback_data_pointer = user_callback_data_pointer;
    b = lt->block_head;
    blk = 0;
    i = (unsigned int)0;
    for( ; !(i >= lt->numfacs); i = i + 1u)
      if(!(lt->value[(signed long int)i] == ((char *)NULL)))
        lt->value[(signed long int)i][(signed long int)0] = (char)0;

    for( ; !(b == ((struct lxt2_rd_block *)NULL)); b = b->next)
    {
      if(b->mem == ((char *)NULL))
      {
        if(b->short_read_ignore == 0u)
        {
          if(b->exclude_block == 0u)
          {
            if(!(processed >= 5))
            {
              signed int gate;
              if(processed == 4)
                tmp_if_expr_1 = b->next != ((struct lxt2_rd_block *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_1 = (_Bool)0;
              gate = (signed int)tmp_if_expr_1;
              fprintf(stderr, "LXTLOAD | block [%d] processing %ld / %ld%s\n", blk, b->start, b->end, gate != 0 ? " ..." : "");
              if(!(gate == 0))
                bcutoff = b;

            }

            processed = processed + 1;
            fseeko(lt->handle, b->filepos, 0);
            gzid[(signed long int)1] = (unsigned char)0;
            gzid[(signed long int)0] = gzid[(signed long int)1];
            unsigned long int return_value_fread_2;
            return_value_fread_2=fread((void *)&gzid, (unsigned long int)2, (unsigned long int)1, lt->handle);
            if(return_value_fread_2 == 0ul)
            {
              gzid[(signed long int)1] = (unsigned char)0;
              gzid[(signed long int)0] = gzid[(signed long int)1];
            }

            fseeko(lt->handle, b->filepos, 0);
            if(!((signed int)gzid[0l] == 0x1f))
              tmp_if_expr_18 = (_Bool)1;

            else
              tmp_if_expr_18 = (signed int)gzid[(signed long int)1] != 0x8b ? (_Bool)1 : (_Bool)0;
            striped_kill = (signed int)tmp_if_expr_18;
            if(!(striped_kill == 0))
            {
              unsigned int clen;
              unsigned int unclen;
              unsigned int iter = (unsigned int)0;
              char *pnt;
              signed long int fspos = b->filepos;
              unsigned int zlen = (unsigned int)16;
              char *zbuff;
              void *return_value_malloc_3;
              return_value_malloc_3=malloc((unsigned long int)zlen);
              zbuff = (char *)return_value_malloc_3;
              struct z_stream_s strm;
              real_uncompressed_siz = b->uncompressed_siz;
              void *return_value_malloc_4;
              return_value_malloc_4=malloc((unsigned long int)b->uncompressed_siz);
              b->mem = (char *)return_value_malloc_4;
              pnt = b->mem;
              b->uncompressed_siz = (unsigned int)0;
              lxt2_rd_regenerate_process_mask(lt);
              while(!(iter == 0xFFFFFFFF))
              {
                unsigned long int rcf;
                iter = (unsigned int)0;
                unclen = iter;
                clen = unclen;
                rcf=fread((void *)&clen, (unsigned long int)4, (unsigned long int)1, lt->handle);
                if(!(rcf == 0ul))
                {
                  return_value_lxt2_rd_get_32_5=lxt2_rd_get_32((void *)&clen, 0);
                  tmp_if_expr_6 = return_value_lxt2_rd_get_32_5;
                }

                else
                  tmp_if_expr_6 = (unsigned int)0;
                clen = tmp_if_expr_6;
                rcf=fread((void *)&unclen, (unsigned long int)4, (unsigned long int)1, lt->handle);
                if(!(rcf == 0ul))
                {
                  return_value_lxt2_rd_get_32_7=lxt2_rd_get_32((void *)&unclen, 0);
                  tmp_if_expr_8 = return_value_lxt2_rd_get_32_7;
                }

                else
                  tmp_if_expr_8 = (unsigned int)0;
                unclen = tmp_if_expr_8;
                rcf=fread((void *)&iter, (unsigned long int)4, (unsigned long int)1, lt->handle);
                if(!(rcf == 0ul))
                {
                  return_value_lxt2_rd_get_32_9=lxt2_rd_get_32((void *)&iter, 0);
                  tmp_if_expr_10 = return_value_lxt2_rd_get_32_9;
                }

                else
                  tmp_if_expr_10 = (unsigned int)0;
                iter = tmp_if_expr_10;
                fspos = fspos + (signed long int)12;
                if(iter == 0xFFFFFFFF)
                  tmp_if_expr_14 = (_Bool)1;

                else
                  tmp_if_expr_14 = lt->process_mask_compressed[(signed long int)(iter / (unsigned int)2048)] != 0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_14)
                {
                  if(!(zlen >= clen))
                  {
                    if(!(zbuff == ((char *)NULL)))
                      free((void *)zbuff);

                    zlen = clen * (unsigned int)2;
                    void *return_value_malloc_11;
                    return_value_malloc_11=malloc((unsigned long int)(zlen != 0u ? zlen : (unsigned int)1));
                    zbuff = (char *)return_value_malloc_11;
                  }

                  unsigned long int return_value_fread_12;
                  return_value_fread_12=fread((void *)zbuff, (unsigned long int)clen, (unsigned long int)1, lt->handle);
                  if(return_value_fread_12 == 0ul)
                    clen = (unsigned int)0;

                  strm.avail_in = clen - (unsigned int)10;
                  strm.avail_out = unclen;
                  strm.total_out = (unsigned long int)0;
                  strm.total_in = strm.total_out;
                  strm.zalloc = (void * (*)(void *, unsigned int, unsigned int))(void *)0;
                  strm.zfree = (void (*)(void *, void *))(void *)0;
                  strm.opaque = (void *)0;
                  strm.next_in = (unsigned char *)(zbuff + (signed long int)10);
                  strm.next_out = (unsigned char *)pnt;
                  if(!(clen == 0u) && !(unclen == 0u))
                  {
                    inflateInit2_(&strm, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
                    do
                    {
                      return_value_inflate_13=inflate(&strm, 0);
                      if(!(return_value_inflate_13 == 0))
                        break;

                    }
                    while((_Bool)1);
                    inflateEnd(&strm);
                  }

                  if(clen == 0u || unclen == 0u || !(strm.total_out == (unsigned long int)unclen))
                  {
                    fprintf(stderr, "LXTLOAD | short read on subblock %ld vs %d (exp), ignoring\n", strm.total_out, unclen);
                    free((void *)b->mem);
                    b->mem = (char *)(void *)0;
                    b->short_read_ignore = (unsigned int)1;
                    b->uncompressed_siz = real_uncompressed_siz;
                    break;
                  }

                  b->uncompressed_siz = b->uncompressed_siz + (unsigned int)strm.total_out;
                  pnt = pnt + (signed long int)strm.total_out;
                  fspos = fspos + (signed long int)clen;
                }

                else
                {
                  fspos = fspos + (signed long int)clen;
                  fseeko(lt->handle, fspos, 0);
                }
              }
              if(!(zbuff == ((char *)NULL)))
                free((void *)zbuff);

            }

            else
            {
              signed int rc;
              void *return_value_malloc_15;
              return_value_malloc_15=malloc((unsigned long int)b->uncompressed_siz);
              b->mem = (char *)return_value_malloc_15;
              signed int return_value_fileno_16;
              return_value_fileno_16=fileno(lt->handle);
              signed int return_value_dup_17;
              return_value_dup_17=dup(return_value_fileno_16);
              lt->zhandle=gzdopen(return_value_dup_17, "rb");
              rc=gzread(lt->zhandle, (void *)b->mem, b->uncompressed_siz);
              gzclose(lt->zhandle);
              lt->zhandle = (struct gzFile_s *)(void *)0;
              if(!((unsigned int)rc == b->uncompressed_siz))
              {
                fprintf(stderr, "LXTLOAD | short read on block %d vs %d (exp), ignoring\n", rc, b->uncompressed_siz);
                free((void *)b->mem);
                b->mem = (char *)(void *)0;
                b->short_read_ignore = (unsigned int)1;
              }

              else
                lt->block_mem_consumed = lt->block_mem_consumed + (unsigned long int)b->uncompressed_siz;
            }
            bfinal = b;
            blkfinal = blk;
          }

        }

      }

      if(!(b->mem == ((char *)NULL)))
      {
        lxt2_rd_process_block(lt, b);
        if(!(striped_kill == 0))
        {
          free((void *)b->mem);
          b->mem = (char *)(void *)0;
          b->uncompressed_siz = real_uncompressed_siz;
        }

        else
          if(lt->numblocks >= 2u)
          {
            if(!(lt->block_mem_max >= lt->block_mem_consumed))
            {
              lt->block_mem_consumed = lt->block_mem_consumed - (unsigned long int)b->uncompressed_siz;
              free((void *)b->mem);
              b->mem = (char *)(void *)0;
            }

          }

      }

      blk = blk + 1;
    }
  }

  if(!(bcutoff == ((struct lxt2_rd_block *)NULL)) && !(bfinal == bcutoff))
    fprintf(stderr, "LXTLOAD | block [%d] processed %ld / %ld\n", blkfinal, bfinal->start, bfinal->end);

  return blk;
}

// lxt2_rd_iter_radix
// file ./../../src/helpers/lxt2_read.c line 175
void lxt2_rd_iter_radix(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b)
{
  unsigned int which_time;
  signed int offset;
  void **top_elem;
  unsigned long int msk = ~1ULL;
  unsigned int x;
  which_time = (unsigned int)0;
  char *return_value_lxt2_rd_expand_integer_to_bits_2;
  char *return_value_lxt2_rd_expand_integer_to_bits_3;
  signed int tmp_if_expr_4;
  for( ; !(which_time >= (unsigned int)lt->num_time_table_entries); msk = msk << 1)
  {
    top_elem = lt->radix_sort[(signed long int)which_time];
    if(!(top_elem == ((void **)NULL)))
    {
      unsigned int idx = (unsigned int)(top_elem - lt->next_radix);
      unsigned int vch;
      unsigned int i;
      switch((signed int)lt->fac_curpos_width)
      {
        case 1:
        {
          vch = (unsigned int)((unsigned char *)lt->fac_curpos[(signed long int)idx])[(signed long int)0];
          break;
        }
        case 2:
        {
          vch=lxt2_rd_get_16((void *)lt->fac_curpos[(signed long int)idx], 0);
          break;
        }
        case 3:
        {
          vch=lxt2_rd_get_24((void *)lt->fac_curpos[(signed long int)idx], 0);
          break;
        }
        case 4:

        default:
          vch=lxt2_rd_get_32((void *)lt->fac_curpos[(signed long int)idx], 0);
      }
      lt->fac_curpos[(signed long int)idx] = lt->fac_curpos[(signed long int)idx] + (signed long int)lt->fac_curpos_width;
      lt->fac_map[(signed long int)idx] = lt->fac_map[(signed long int)idx] & msk;
      unsigned long int return_value_lxt2_rd_tzc_1;
      return_value_lxt2_rd_tzc_1=lxt2_rd_tzc(lt->fac_map[(signed long int)idx]);
      offset = (signed int)return_value_lxt2_rd_tzc_1;
      lt->radix_sort[(signed long int)which_time] = (void **)lt->next_radix[(signed long int)idx];
      lt->next_radix[(signed long int)idx] = (void *)lt->radix_sort[(signed long int)offset];
      lt->radix_sort[(signed long int)offset] = &lt->next_radix[(signed long int)idx];
      switch(vch)
      {
        case (unsigned int)0:

        case (unsigned int)1:
        {
          memset((void *)lt->value[(signed long int)idx], (signed int)((unsigned int)48 + (vch - (unsigned int)0)), (unsigned long int)lt->len[(signed long int)idx]);
          break;
        }
        case (unsigned int)2:
        {
          i = (unsigned int)0;
          for( ; !(i >= lt->len[(signed long int)idx]); i = i + 1u)
            lt->value[(signed long int)idx][(signed long int)i] = lt->value[(signed long int)idx][(signed long int)i] ^ (char)1;
          break;
        }
        case (unsigned int)3:

        case (unsigned int)4:
        {
          memmove((void *)lt->value[(signed long int)idx], (const void *)(lt->value[(signed long int)idx] + (signed long int)1), (unsigned long int)(lt->len[(signed long int)idx] - (unsigned int)1));
          lt->value[(signed long int)idx][(signed long int)(lt->len[(signed long int)idx] - (unsigned int)1)] = (char)((unsigned int)48 + (vch - (unsigned int)3));
          break;
        }
        case (unsigned int)5:

        case (unsigned int)6:
        {
          memmove((void *)(lt->value[(signed long int)idx] + (signed long int)1), (const void *)lt->value[(signed long int)idx], (unsigned long int)(lt->len[(signed long int)idx] - (unsigned int)1));
          lt->value[(signed long int)idx][(signed long int)0] = (char)((unsigned int)48 + (vch - (unsigned int)5));
          break;
        }
        case (unsigned int)7:

        case (unsigned int)8:

        case (unsigned int)9:

        case (unsigned int)10:
        {
          x=lxt2_rd_expand_bits_to_integer((signed int)lt->len[(signed long int)idx], lt->value[(signed long int)idx]);
          x = x + (vch - (unsigned int)7) + (unsigned int)1;
          return_value_lxt2_rd_expand_integer_to_bits_2=lxt2_rd_expand_integer_to_bits((signed int)lt->len[(signed long int)idx], x);
          memcpy((void *)lt->value[(signed long int)idx], (const void *)return_value_lxt2_rd_expand_integer_to_bits_2, (unsigned long int)lt->len[(signed long int)idx]);
          break;
        }
        case (unsigned int)11:

        case (unsigned int)12:

        case (unsigned int)13:

        case (unsigned int)14:
        {
          x=lxt2_rd_expand_bits_to_integer((signed int)lt->len[(signed long int)idx], lt->value[(signed long int)idx]);
          x = x - ((vch - (unsigned int)11) + (unsigned int)1);
          return_value_lxt2_rd_expand_integer_to_bits_3=lxt2_rd_expand_integer_to_bits((signed int)lt->len[(signed long int)idx], x);
          memcpy((void *)lt->value[(signed long int)idx], (const void *)return_value_lxt2_rd_expand_integer_to_bits_3, (unsigned long int)lt->len[(signed long int)idx]);
          break;
        }
        case (unsigned int)15:
        {
          memset((void *)lt->value[(signed long int)idx], 120, (unsigned long int)lt->len[(signed long int)idx]);
          break;
        }
        case (unsigned int)16:
        {
          memset((void *)lt->value[(signed long int)idx], 122, (unsigned long int)lt->len[(signed long int)idx]);
          break;
        }
        case (unsigned int)17:
        {
          lt->value[(signed long int)idx][(signed long int)0] = (char)0;
          break;
        }
        default:
        {
          vch = vch - (unsigned int)18;
          if(vch >= b->num_dict_entries)
          {
            fprintf(stderr, "LXTLOAD | Internal error: vch(%d) >= num_dict_entries(%d)\n", vch, b->num_dict_entries);
            exit(255);
          }

          if(!((6u & lt->flags[(signed long int)idx]) == 0u))
          {
            free((void *)lt->value[(signed long int)idx]);
            lt->value[(signed long int)idx]=strdup(b->string_pointers[(signed long int)vch]);
            break;
          }

          if(lt->len[(signed long int)idx] == b->string_lens[(signed long int)vch])
            memcpy((void *)lt->value[(signed long int)idx], (const void *)b->string_pointers[(signed long int)vch], (unsigned long int)lt->len[(signed long int)idx]);

          else
            if(!(b->string_lens[(signed long int)vch] >= lt->len[(signed long int)idx]))
            {
              signed int lendelta = (signed int)(lt->len[(signed long int)idx] - b->string_lens[(signed long int)vch]);
              if(!((signed int)*b->string_pointers[(signed long int)vch] == 49))
                tmp_if_expr_4 = (signed int)b->string_pointers[(signed long int)vch][(signed long int)0];

              else
                tmp_if_expr_4 = 48;
              memset((void *)lt->value[(signed long int)idx], tmp_if_expr_4, (unsigned long int)lendelta);
              strcpy(lt->value[(signed long int)idx] + (signed long int)lendelta, b->string_pointers[(signed long int)vch]);
            }

            else
            {
              fprintf(stderr, "LXTLOAD | Internal error %d ('%s') vs %d ('%s')\n", lt->len[(signed long int)idx], lt->value[(signed long int)idx], b->string_lens[(signed long int)vch], b->string_pointers[(signed long int)vch]);
              exit(255);
            }
        }
      }
      if(!(lt->time_table[(signed long int)which_time] == lt->prev_time))
        lt->prev_time = lt->time_table[(signed long int)which_time];

      lt->value_change_callback(&lt, &lt->time_table[(signed long int)which_time], &idx, &lt->value[(signed long int)idx]);
    }

    which_time = which_time + 1u;
  }
}

// lxt2_rd_iter_radix0
// file ./../../src/helpers/lxt2_read.c line 298
void lxt2_rd_iter_radix0(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b, unsigned int idx)
{
  unsigned int vch;
  unsigned int which_time;
  unsigned int i;
  signed int uniq = 0;
  switch((signed int)lt->fac_curpos_width)
  {
    case 1:
    {
      vch = (unsigned int)((unsigned char *)lt->fac_curpos[(signed long int)idx])[(signed long int)0];
      break;
    }
    case 2:
    {
      vch=lxt2_rd_get_16((void *)lt->fac_curpos[(signed long int)idx], 0);
      break;
    }
    case 3:
    {
      vch=lxt2_rd_get_24((void *)lt->fac_curpos[(signed long int)idx], 0);
      break;
    }
    case 4:

    default:
      vch=lxt2_rd_get_32((void *)lt->fac_curpos[(signed long int)idx], 0);
  }
  lt->fac_curpos[(signed long int)idx] = lt->fac_curpos[(signed long int)idx] + (signed long int)lt->fac_curpos_width;
  which_time = (unsigned int)0;
  signed int tmp_if_expr_2;
  switch(vch)
  {
    case (unsigned int)0:
    {
      i = (unsigned int)0;
      for( ; !(i >= lt->len[(signed long int)idx]); i = i + 1u)
        if(!((signed int)lt->value[(signed long int)idx][(signed long int)i] == 48))
        {
          memset((void *)(lt->value[(signed long int)idx] + (signed long int)i), 48, (unsigned long int)(lt->len[(signed long int)idx] - i));
          uniq = 1;
          break;
        }

      break;
    }
    case (unsigned int)1:
    {
      i = (unsigned int)0;
      for( ; !(i >= lt->len[(signed long int)idx]); i = i + 1u)
        if(!((signed int)lt->value[(signed long int)idx][(signed long int)i] == 49))
        {
          memset((void *)(lt->value[(signed long int)idx] + (signed long int)i), 49, (unsigned long int)(lt->len[(signed long int)idx] - i));
          uniq = 1;
          break;
        }

      break;
    }
    case (unsigned int)2:

    case (unsigned int)3:

    case (unsigned int)4:

    case (unsigned int)5:

    case (unsigned int)6:

    case (unsigned int)7:

    case (unsigned int)8:

    case (unsigned int)9:

    case (unsigned int)10:

    case (unsigned int)11:

    case (unsigned int)12:

    case (unsigned int)13:

    case (unsigned int)14:
    {
      fprintf(stderr, "LXTLOAD | Internal error in granule 0 position 0\n");
      exit(255);
    }
    case (unsigned int)15:
    {
      i = (unsigned int)0;
      for( ; !(i >= lt->len[(signed long int)idx]); i = i + 1u)
        if(!((signed int)lt->value[(signed long int)idx][(signed long int)i] == 120))
        {
          memset((void *)(lt->value[(signed long int)idx] + (signed long int)i), 120, (unsigned long int)(lt->len[(signed long int)idx] - i));
          uniq = 1;
          break;
        }

      break;
    }
    case (unsigned int)16:
    {
      i = (unsigned int)0;
      for( ; !(i >= lt->len[(signed long int)idx]); i = i + 1u)
        if(!((signed int)lt->value[(signed long int)idx][(signed long int)i] == 122))
        {
          memset((void *)(lt->value[(signed long int)idx] + (signed long int)i), 122, (unsigned long int)(lt->len[(signed long int)idx] - i));
          uniq = 1;
          break;
        }

      break;
    }
    case (unsigned int)17:
    {
      if(!(lt->value[(signed long int)idx] == ((char *)NULL)))
      {
        lt->value[(signed long int)idx][(signed long int)0] = (char)0;
        uniq = 1;
      }

      break;
    }
    default:
    {
      vch = vch - (unsigned int)18;
      if(vch >= b->num_dict_entries)
      {
        fprintf(stderr, "LXTLOAD | Internal error: vch(%d) >= num_dict_entries(%d)\n", vch, b->num_dict_entries);
        exit(255);
      }

      if(!((6u & lt->flags[(signed long int)idx]) == 0u))
      {
        signed int return_value_strcmp_1;
        return_value_strcmp_1=strcmp(lt->value[(signed long int)idx], b->string_pointers[(signed long int)vch]);
        if(!(return_value_strcmp_1 == 0))
        {
          free((void *)lt->value[(signed long int)idx]);
          lt->value[(signed long int)idx]=strdup(b->string_pointers[(signed long int)vch]);
          uniq = 1;
        }

        break;
      }

      if(lt->len[(signed long int)idx] == b->string_lens[(signed long int)vch])
      {
        i = (unsigned int)0;
        for( ; !(i >= lt->len[(signed long int)idx]); i = i + 1u)
          if(!(lt->value[(signed long int)idx][(signed long int)i] == b->string_pointers[(signed long int)vch][(signed long int)i]))
          {
            memcpy((void *)(lt->value[(signed long int)idx] + (signed long int)i), (const void *)(b->string_pointers[(signed long int)vch] + (signed long int)i), (unsigned long int)(lt->len[(signed long int)idx] - i));
            uniq = 1;
          }

      }

      else
        if(!(b->string_lens[(signed long int)vch] >= lt->len[(signed long int)idx]))
        {
          unsigned int lendelta = lt->len[(signed long int)idx] - b->string_lens[(signed long int)vch];
          signed int fill;
          if(!((signed int)*b->string_pointers[(signed long int)vch] == 49))
            tmp_if_expr_2 = (signed int)b->string_pointers[(signed long int)vch][(signed long int)0];

          else
            tmp_if_expr_2 = 48;
          fill = tmp_if_expr_2;
          i = (unsigned int)0;
          for( ; !(i >= lendelta); i = i + 1u)
            if(!((signed int)lt->value[(signed long int)idx][(signed long int)i] == fill))
            {
              memset((void *)(lt->value[(signed long int)idx] + (signed long int)i), fill, (unsigned long int)(lendelta - i));
              strcpy(lt->value[(signed long int)idx] + (signed long int)lendelta, b->string_pointers[(signed long int)vch]);
              uniq = 1;
              goto fini;
            }

          i = lendelta;
          for( ; !(i >= lt->len[(signed long int)idx]); i = i + 1u)
            if(!(lt->value[(signed long int)idx][(signed long int)i] == b->string_pointers[(signed long int)vch][(signed long int)(i + -lendelta)]))
            {
              memcpy((void *)(lt->value[(signed long int)idx] + (signed long int)i), (const void *)((b->string_pointers[(signed long int)vch] + (signed long int)i) - (signed long int)lendelta), (unsigned long int)(lt->len[(signed long int)idx] - i));
              uniq = 1;
            }

        }

        else
        {
          fprintf(stderr, "LXTLOAD | Internal error %d ('%s') vs %d ('%s')\n", lt->len[(signed long int)idx], lt->value[(signed long int)idx], b->string_lens[(signed long int)vch], b->string_pointers[(signed long int)vch]);
          exit(255);
        }
    }
  }

fini:
  ;
  if(!(uniq == 0))
  {
    if(!(lt->time_table[(signed long int)which_time] == lt->prev_time))
      lt->prev_time = lt->time_table[(signed long int)which_time];

    lt->value_change_callback(&lt, &lt->time_table[(signed long int)which_time], &idx, &lt->value[(signed long int)idx]);
  }

}

// lxt2_rd_limit_time_range
// file ../../src/helpers/lxt2_read.h line 301
unsigned int lxt2_rd_limit_time_range(struct lxt2_rd_trace *lt, unsigned long int strt_time, unsigned long int end_time)
{
  unsigned long int tmp_time;
  signed int blk = 0;
  _Bool tmp_if_expr_1;
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
  {
    struct lxt2_rd_block *b = lt->block_head;
    struct lxt2_rd_block *bprev = (struct lxt2_rd_block *)(void *)0;
    signed int state = 0;
    if(!(end_time >= strt_time))
    {
      tmp_time = strt_time;
      strt_time = end_time;
      end_time = tmp_time;
    }

    for( ; !(b == ((struct lxt2_rd_block *)NULL)); b = b->next)
    {
      switch(state)
      {
        case 0:
        {
          if(b->end >= strt_time)
          {
            state = 1;
            if(!(strt_time >= b->start))
            {
              if(!(bprev == ((struct lxt2_rd_block *)NULL)))
              {
                bprev->exclude_block = (unsigned int)0;
                blk = blk + 1;
              }

            }

          }

          break;
        }
        case 1:
          if(!(end_time >= b->start))
            state = 2;

      }
      if(state == 1)
        tmp_if_expr_1 = !(b->short_read_ignore != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        b->exclude_block = (unsigned int)0;
        blk = blk + 1;
      }

      else
        b->exclude_block = (unsigned int)1;
      bprev = b;
    }
  }

  return (unsigned int)blk;
}

// lxt2_rd_null_callback
// file ./../../src/helpers/lxt2_read.c line 746
void lxt2_rd_null_callback(struct lxt2_rd_trace **lt, unsigned long int *pnt_time, unsigned int *pnt_facidx, char **pnt_value)
{
  (void)lt;
  (void)pnt_time;
  (void)pnt_facidx;
  (void)pnt_value;
}

// lxt2_rd_ones_cnt
// file ./../../src/helpers/lxt2_read.c line 98
static inline unsigned long int lxt2_rd_ones_cnt(unsigned long int x)
{
  x = x - (x >> 1 & 0x5555555555555555ULL);
  x = (x >> 2 & 0x3333333333333333ULL) + (x & 0x3333333333333333ULL);
  x = (x >> 4) + x & 0x0f0f0f0f0f0f0f0fULL;
  return x * 0x0101010101010101ULL >> 56;
}

// lxt2_rd_process_block
// file ./../../src/helpers/lxt2_read.c line 560
signed int lxt2_rd_process_block(struct lxt2_rd_trace *lt, struct lxt2_rd_block *b)
{
  char vld;
  char *pnt;
  unsigned int i;
  signed int granule = 0;
  char sect_typ;
  unsigned int strtfac_gran = (unsigned int)0;
  char granvld = (char)0;
  b->num_map_entries=lxt2_rd_get_32((void *)b->mem, (signed int)(b->uncompressed_siz - (unsigned int)4));
  b->num_dict_entries=lxt2_rd_get_32((void *)b->mem, (signed int)(b->uncompressed_siz - (unsigned int)12));
  if((signed int)lt->granule_size == 64)
    b->map_start = ((b->mem + (signed long int)b->uncompressed_siz) - (signed long int)12) - (signed long int)(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)b->num_map_entries);

  else
    b->map_start = ((b->mem + (signed long int)b->uncompressed_siz) - (signed long int)12) - (signed long int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)b->num_map_entries);
  unsigned int return_value_lxt2_rd_get_32_1;
  return_value_lxt2_rd_get_32_1=lxt2_rd_get_32((void *)b->mem, (signed int)(b->uncompressed_siz - (unsigned int)8));
  b->dict_start = b->map_start - (signed long int)return_value_lxt2_rd_get_32_1;
  vld = (char)(unsigned int)((unsigned char *)(b->dict_start - (signed long int)1))[(signed long int)0];
  if(!((signed int)vld == 1))
  {
    fprintf(stderr, "LXTLOAD | Malformed section\n");
    exit(255);
  }

  if(!(b->num_dict_entries == 0u))
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)b->num_dict_entries * sizeof(char *) /*8ul*/ );
    b->string_pointers = (char **)return_value_malloc_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc((unsigned long int)b->num_dict_entries * sizeof(unsigned int) /*4ul*/ );
    b->string_lens = (unsigned int *)return_value_malloc_3;
    pnt = b->dict_start;
    i = (unsigned int)0;
    for( ; !(i >= b->num_dict_entries); i = i + 1u)
    {
      b->string_pointers[(signed long int)i] = pnt;
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(pnt);
      b->string_lens[(signed long int)i] = (unsigned int)return_value_strlen_4;
      pnt = pnt + (signed long int)(b->string_lens[(signed long int)i] + (unsigned int)1);
    }
    if(!(pnt == b->map_start))
    {
      fprintf(stderr, "LXTLOAD | dictionary corrupt, exiting\n");
      exit(255);
    }

  }

  pnt = b->mem;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  do
  {
    sect_typ = *pnt;
    if(!((signed int)sect_typ == 0))
    {
      if(!((signed int)sect_typ == 2))
        break;

    }

    unsigned int strtfac;
    unsigned int endfac;
    if((signed int)sect_typ == 2)
    {
      unsigned int sublen;
      lxt2_rd_regenerate_process_mask(lt);
      strtfac=lxt2_rd_get_32((void *)pnt, 1);
      sublen=lxt2_rd_get_32((void *)pnt, 5);
      if(granvld == 0)
      {
        granvld = (char)1;
        strtfac_gran = strtfac;
      }

      else
        granule = granule + (signed int)(strtfac == strtfac_gran);
      if(lt->process_mask_compressed[(signed long int)(strtfac / 2048u)] == 0)
      {
        pnt = pnt + (signed long int)9;
        pnt = pnt + (signed long int)sublen;
        continue;
      }

      endfac = strtfac + (unsigned int)2048;
      if(!(lt->numrealfacs >= endfac))
        endfac = lt->numrealfacs;

      pnt = pnt + (signed long int)8;
    }

    else
    {
      strtfac = (unsigned int)0;
      endfac = lt->numrealfacs;
    }
    pnt = pnt + 1l;
    lt->num_time_table_entries = (unsigned char)(unsigned int)((unsigned char *)pnt)[(signed long int)0];
    pnt = pnt + 1l;
    i = (unsigned int)0;
    for( ; !(i >= (unsigned int)lt->num_time_table_entries); i = i + 1u)
    {
      lt->time_table[(signed long int)i]=lxt2_rd_get_64((void *)pnt, 0);
      pnt = pnt + (signed long int)8;
    }
    lt->fac_map_index_width = (unsigned char)(unsigned int)((unsigned char *)pnt)[(signed long int)0];
    if(lt->fac_map_index_width == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)lt->fac_map_index_width > 4 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      fprintf(stderr, "LXTLOAD | Map index width of %d is illegal, exiting.\n", lt->fac_map_index_width);
      exit(255);
    }

    pnt = pnt + 1l;
    i = strtfac;
    for( ; !(i >= endfac); i = i + 1u)
    {
      unsigned int mskindx;
      switch((signed int)lt->fac_map_index_width)
      {
        case 1:
        {
          mskindx = (unsigned int)((unsigned char *)pnt)[(signed long int)0];
          break;
        }
        case 2:
        {
          mskindx=lxt2_rd_get_16((void *)pnt, 0);
          break;
        }
        case 3:
        {
          mskindx=lxt2_rd_get_24((void *)pnt, 0);
          break;
        }
        case 4:

        default:
          mskindx=lxt2_rd_get_32((void *)pnt, 0);
      }
      pnt = pnt + (signed long int)lt->fac_map_index_width;
      if((signed int)lt->granule_size == 64)
        lt->fac_map[(signed long int)i]=lxt2_rd_get_64((void *)b->map_start, (signed int)((unsigned long int)mskindx * sizeof(unsigned long int) /*8ul*/ ));

      else
      {
        unsigned int return_value_lxt2_rd_get_32_6;
        return_value_lxt2_rd_get_32_6=lxt2_rd_get_32((void *)b->map_start, (signed int)((unsigned long int)mskindx * sizeof(unsigned int) /*4ul*/ ));
        lt->fac_map[(signed long int)i] = (unsigned long int)return_value_lxt2_rd_get_32_6;
      }
    }
    lt->fac_curpos_width = (unsigned char)(unsigned int)((unsigned char *)pnt)[(signed long int)0];
    if(lt->fac_curpos_width == 0)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)lt->fac_curpos_width > 4 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
    {
      fprintf(stderr, "LXTLOAD | Curpos index width of %d is illegal, exiting.\n", lt->fac_curpos_width);
      exit(255);
    }

    pnt = pnt + 1l;
    i = strtfac;
    for( ; !(i >= endfac); i = i + 1u)
    {
      lt->fac_curpos[(signed long int)i] = pnt;
      if(!(lt->fac_map[(signed long int)i] == 0ul))
      {
        unsigned long int return_value_lxt2_rd_ones_cnt_8;
        return_value_lxt2_rd_ones_cnt_8=lxt2_rd_ones_cnt(lt->fac_map[(signed long int)i]);
        pnt = pnt + (signed long int)(return_value_lxt2_rd_ones_cnt_8 * (unsigned long int)lt->fac_curpos_width);
      }

    }
    lxt2_rd_build_radix(lt, b, granule, strtfac, endfac);
    lxt2_rd_iter_radix(lt, b);
    if(!((signed int)sect_typ == 2))
      granule = granule + 1;

  }
  while((_Bool)1);
  return 1;
}

// lxt2_rd_regenerate_process_mask
// file ./../../src/helpers/lxt2_read.c line 516
static void lxt2_rd_regenerate_process_mask(struct lxt2_rd_trace *lt)
{
  unsigned int i;
  signed int j;
  signed int lim;
  signed int idx;
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
  {
    if(!(lt->process_mask_dirty == 0u))
    {
      lt->process_mask_dirty = (unsigned int)0;
      idx = 0;
      i = (unsigned int)0;
      for( ; !(i >= lt->numrealfacs); i = i + (unsigned int)2048)
      {
        if(!(lt->numrealfacs >= 2048u + i))
          lim = (signed int)lt->numrealfacs;

        else
          lim = (signed int)(i + (unsigned int)2048);
        lt->process_mask_compressed[(signed long int)idx] = (char)0;
        j = (signed int)i;
        for( ; !(j >= lim); j = j + 1)
        {
          signed int process_idx = j / 8;
          signed int process_bit = j & 7;
          if(!((1 << process_bit & (signed int)lt->process_mask[(signed long int)process_idx]) == 0))
          {
            lt->process_mask_compressed[(signed long int)idx] = (char)1;
            break;
          }

        }
        idx = idx + 1;
      }
    }

  }

}

// lxt2_rd_tzc
// file ./../../src/helpers/lxt2_read.c line 127
static inline unsigned long int lxt2_rd_tzc(unsigned long int x)
{
  unsigned long int return_value_lxt2_rd_ones_cnt_1;
  return_value_lxt2_rd_ones_cnt_1=lxt2_rd_ones_cnt((x & -x) - 1ULL);
  return return_value_lxt2_rd_ones_cnt_1;
}

// lxt2_rd_unlimit_time_range
// file ../../src/helpers/lxt2_read.h line 302
unsigned int lxt2_rd_unlimit_time_range(struct lxt2_rd_trace *lt)
{
  signed int blk = 0;
  if(!(lt == ((struct lxt2_rd_trace *)NULL)))
  {
    struct lxt2_rd_block *b = lt->block_head;
    for( ; !(b == ((struct lxt2_rd_block *)NULL)); b = b->next)
    {
      b->exclude_block = (unsigned int)0;
      if(b->short_read_ignore == 0u)
        blk = blk + 1;

    }
  }

  return (unsigned int)blk;
}

// main
// file stem_recurse.c line 465
signed int main(signed int argc, char **argv)
{
  char *wlve;
  wlve=getenv("LANG");
  if(!(wlve == ((char *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(wlve, "C");
    if(!(return_value_strcmp_1 == 0))
    {
      setenv("LC_NUMERIC", "C", 1);
      setenv("LC_COLLATE", "C", 1);
      setenv("LC_CTYPE", "C", 1);
    }

  }

  wlve=getenv("LC_ALL");
  if(!(wlve == ((char *)NULL)))
  {
    signed int return_value_strcmp_2;
    return_value_strcmp_2=strcmp(wlve, "C");
    if(!(return_value_strcmp_2 == 0))
      unsetenv("LC_ALL");

  }

  main_2r(argc, argv);
  signed int return_value_gtk_init_check_3;
  return_value_gtk_init_check_3=gtk_init_check(&argc, &argv);
  if(return_value_gtk_init_check_3 == 0)
  {
    printf("Could not initialize GTK!  Is DISPLAY env var/xhost set?\n\n");
    exit(255);
  }

  if(!(anno_ctx == ((struct gtkwave_annotate_ipc_t *)NULL)))
    switch(anno_ctx->aet_type)
    {
      case 4:
      {
        fst=fstReaderOpen(anno_ctx->aet_name);
        if(fst == NULL)
        {
          fprintf(stderr, "Could not initialize '%s', exiting.\n", (const void *)anno_ctx->aet_name);
          exit(255);
        }

        else
          timezero=fstReaderGetTimezero(fst);
        break;
      }
      case 2:
      {
        vzt=vzt_rd_init(anno_ctx->aet_name);
        if(vzt == ((struct vzt_rd_trace *)NULL))
        {
          fprintf(stderr, "Could not initialize '%s', exiting.\n", (const void *)anno_ctx->aet_name);
          exit(255);
        }

        break;
      }
      case 3:
      {
        lx2=lxt2_rd_init(anno_ctx->aet_name);
        if(lx2 == ((struct lxt2_rd_trace *)NULL))
        {
          fprintf(stderr, "Could not initialize '%s', exiting.\n", (const void *)anno_ctx->aet_name);
          exit(255);
        }

        break;
      }
      case 1:

      default:
      {
        fprintf(stderr, "Unsupported wave file type %d encountered, exiting.\n", anno_ctx->aet_type);
        exit(255);
      }
    }

  treebox("RTL Design Hierarchy", (void (*)(void))(void *)0, (struct _GtkWidget *)(void *)0);
  g_timeout_add((unsigned int)100, update_ctx_when_idle, (void *)0);
  gtk_main();
  return 0;
}

// main_2r
// file stem_recurse.c line 238
signed int main_2r(signed int argc, char **argv)
{
  struct _IO_FILE *f;
  struct ds_tree_node *modules = (struct ds_tree_node *)(void *)0;
  char *id;
  signed int i;
  signed int len;
  if(!(argc == 2))
  {
    printf("Usage:\n------\n%s stems_filename\n\n", argv[(signed long int)0]);
    exit(0);
  }

  id = argv[(signed long int)1];
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(id);
  len = (signed int)return_value_strlen_1;
  i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    const unsigned short int **return_value___ctype_b_loc_2;
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((4096 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)id[(signed long int)i]]) == 0)
      break;

  }
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  if(i == len)
  {
    unsigned int shmid;
    sscanf(id, "%x", &shmid);
    void *return_value_shmat_3;
    return_value_shmat_3=shmat((signed int)shmid, (void *)0, 0);
    anno_ctx = (struct gtkwave_annotate_ipc_t *)return_value_shmat_3;
    if(!(anno_ctx == ((struct gtkwave_annotate_ipc_t *)NULL)))
    {
      signed int return_value_memcmp_4;
      return_value_memcmp_4=memcmp((const void *)anno_ctx->matchword, (const void *)"WAVE", (unsigned long int)4);
      if(return_value_memcmp_4 == 0)
        tmp_if_expr_5 = anno_ctx->aet_type > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = anno_ctx->aet_type < 5 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        id = anno_ctx->stems_name;

      else
      {
        shmdt((void *)anno_ctx);
        fprintf(stderr, "Not a valid shared memory ID from gtkwave, exiting.\n");
        exit(255);
      }
    }

    else
      id = argv[(signed long int)1];
  }

  else
    id = argv[(signed long int)1];
  f=fopen(id, "rb");
  if(f == ((struct _IO_FILE *)NULL))
  {
    fprintf(stderr, "*** Could not open '%s'\n", argv[(signed long int)1]);
    perror("Why");
    exit(255);
  }

  signed int return_value_feof_7;
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_15;
  do
  {
    return_value_feof_7=feof(f);
    if(!(return_value_feof_7 == 0))
      break;

    char *ln;
    ln=fgetmalloc(f);
    if(fgetmalloc_len >= 5)
    {
      if((signed int)*ln == 43)
      {
        if((signed int)ln[1l] == 43)
        {
          if((signed int)ln[2l] == 32)
          {
            if((signed int)ln[3l] == 99)
            {
              char cname[1024l];
              char mname[1024l];
              char pname[1024l];
              char scratch[128l];
              struct ds_tree_node *which_module;
              struct ds_component *dc;
              sscanf(ln + (signed long int)8, "%s %s %s %s %s", (const void *)cname, (const void *)scratch, (const void *)mname, (const void *)scratch, (const void *)pname);
              modules=ds_splay(mname, modules);
              if(modules == ((struct ds_tree_node *)NULL))
                tmp_if_expr_10 = (_Bool)1;

              else
              {
                return_value_strcmp_9=strcmp(modules->item, mname);
                tmp_if_expr_10 = return_value_strcmp_9 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_10)
              {
                char *return_value_strdup_8;
                return_value_strdup_8=strdup(mname);
                modules=ds_insert(return_value_strdup_8, modules);
              }

              which_module = modules;
              which_module->refcnt = which_module->refcnt + 1;
              modules=ds_splay(pname, modules);
              signed int return_value_strcmp_12;
              return_value_strcmp_12=strcmp(modules->item, pname);
              if(!(return_value_strcmp_12 == 0))
              {
                char *return_value_strdup_11;
                return_value_strdup_11=strdup(pname);
                modules=ds_insert(return_value_strdup_11, modules);
              }

              void *return_value_calloc_13;
              return_value_calloc_13=calloc((unsigned long int)1, sizeof(struct ds_component) /*24ul*/ );
              dc = (struct ds_component *)return_value_calloc_13;
              dc->compname=strdup(cname);
              dc->module = which_module;
              dc->next = modules->comp;
              modules->comp = dc;
            }

            else
            {
              if((signed int)ln[3l] == 109)
                tmp_if_expr_15 = (_Bool)1;

              else
                tmp_if_expr_15 = (signed int)ln[(signed long int)3] == 117 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_15)
              {
                char main_2r__1__6__1__1__2__scratch[128l];
                char main_2r__1__6__1__1__2__mname[1024l];
                char fname[1024l];
                signed int s_line;
                signed int e_line;
                sscanf(ln + (signed long int)3, "%s %s %s %s %s %d %s %d", (const void *)main_2r__1__6__1__1__2__scratch, (const void *)main_2r__1__6__1__1__2__mname, (const void *)main_2r__1__6__1__1__2__scratch, (const void *)fname, (const void *)main_2r__1__6__1__1__2__scratch, &s_line, (const void *)main_2r__1__6__1__1__2__scratch, &e_line);
                char *return_value_strdup_14;
                return_value_strdup_14=strdup(main_2r__1__6__1__1__2__mname);
                modules=ds_insert(return_value_strdup_14, modules);
                modules->filename=strdup(fname);
                modules->s_line = s_line;
                modules->e_line = e_line;
                modules->resolved = (unsigned int)1;
              }

            }
          }

        }

      }

    }

    free((void *)ln);
  }
  while((_Bool)1);
  fclose(f);
  mod_cnt = 0;
  rec_tree(modules, &mod_cnt);
  void *return_value_calloc_16;
  return_value_calloc_16=calloc((unsigned long int)(mod_cnt != 0 ? mod_cnt : 1), sizeof(struct ds_tree_node *) /*8ul*/ );
  mod_list = (struct ds_tree_node **)return_value_calloc_16;
  mod_cnt = 0;
  rec_tree_populate(modules, &mod_cnt, mod_list);
  return 0;
}

// make_jrb
// file jrb.h line 50
extern struct jrb_node * make_jrb(void)
{
  struct jrb_node *head;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct jrb_node) /*64ul*/ );
  head = (struct jrb_node *)return_value_calloc_1;
  head->flink = head;
  head->blink = head;
  head->parent = head;
  head->key.s = "";
  head->roothead = head->roothead | (unsigned char)2;
  return head;
}

// mk_new_int
// file jrb.c line 78
static void mk_new_int(struct jrb_node *l, struct jrb_node *r, struct jrb_node *p, signed int il)
{
  struct jrb_node *newnode;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct jrb_node) /*64ul*/ );
  newnode = (struct jrb_node *)return_value_calloc_1;
  newnode->internal = (unsigned char)1;
  newnode->red = (unsigned char)1;
  newnode->roothead = (unsigned char)0;
  newnode->flink = l;
  newnode->blink = r;
  newnode->parent = p;
  newnode->key.v = (void *)l;
  newnode->val.v = (void *)r;
  l->parent = newnode;
  r->parent = newnode;
  l->left = (unsigned char)1;
  r->left = (unsigned char)0;
  if(!((2 & (signed int)p->roothead) == 0))
  {
    p->parent = newnode;
    newnode->roothead = newnode->roothead | (unsigned char)1;
  }

  else
    if(!(il == 0))
    {
      newnode->left = (unsigned char)1;
      p->flink = newnode;
    }

    else
    {
      newnode->left = (unsigned char)0;
      p->blink = newnode;
    }
  recolor(newnode);
}

// ok_callback
// file logfile.c line 1443
static void ok_callback(struct _GtkWidget *widget, struct logfile_context_t *ctx)
{
  (void)widget;
  bwlogbox(ctx->which->fullname, ctx->width, ctx->which, (signed int)(ctx->display_mode == 0));
}

// press_callback
// file logfile.c line 506
static void press_callback(struct _GtkWidget *widget, void **data)
{
  struct _GdkEventKey ev;
  ev.keyval = (unsigned int)0xff0d;
  forward_noskip = (signed int)!(0 != 0);
  find_edit_cb(widget, &ev, data);
  forward_noskip = 0;
}

// read_insert_position
// file logfile.c line 145
void read_insert_position(struct text_find_t *tr)
{
  struct _GtkTextBuffer *tb;
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)tr->text, return_value_gtk_text_view_get_type_1);
  tb = ((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer;
  struct _GtkTextMark *tm;
  tm=gtk_text_buffer_get_insert(tb);
  struct _GtkTextIter iter;
  gtk_text_buffer_get_iter_at_mark(tb, &iter, tm);
  tr->line=gtk_text_iter_get_line(&iter);
  tr->offs=gtk_text_iter_get_line_offset(&iter);
}

// rec_tree
// file stem_recurse.c line 201
void rec_tree(struct ds_tree_node *t, signed int *cnt)
{
  if(!(t == ((struct ds_tree_node *)NULL)))
  {
    if(!(t->left == ((struct ds_tree_node *)NULL)))
      rec_tree(t->left, cnt);

    *cnt = *cnt + 1;
    if(!(t->right == ((struct ds_tree_node *)NULL)))
      rec_tree(t->right, cnt);

  }

}

// rec_tree_populate
// file stem_recurse.c line 218
void rec_tree_populate(struct ds_tree_node *t, signed int *cnt, struct ds_tree_node **list_root)
{
  if(!(t == ((struct ds_tree_node *)NULL)))
  {
    if(!(t->left == ((struct ds_tree_node *)NULL)))
      rec_tree_populate(t->left, cnt, list_root);

    list_root[(signed long int)*cnt] = t;
    *cnt = *cnt + 1;
    if(!(t->right == ((struct ds_tree_node *)NULL)))
      rec_tree_populate(t->right, cnt, list_root);

  }

}

// recolor
// file jrb.c line 314
static void recolor(struct jrb_node *n)
{
  struct jrb_node *p;
  struct jrb_node *gp;
  struct jrb_node *s;
  signed int done = 0;
  struct jrb_node *tmp_if_expr_1;
  while(done == 0)
  {
    if(!((1 & (signed int)n->roothead) == 0))
    {
      n->red = (unsigned char)0;
      goto __CPROVER_DUMP_L12;
    }

    p = n->parent;
    if(p->red == 0)
      goto __CPROVER_DUMP_L12;

    if(!((1 & (signed int)p->roothead) == 0))
    {
      p->red = (unsigned char)0;
      goto __CPROVER_DUMP_L12;
    }

    gp = p->parent;
    if(!(p->left == 0))
      tmp_if_expr_1 = p->parent->blink;

    else
      tmp_if_expr_1 = p->parent->flink;
    s = tmp_if_expr_1;
    if(!(s->red == 0))
    {
      p->red = (unsigned char)0;
      gp->red = (unsigned char)1;
      s->red = (unsigned char)0;
      n = gp;
    }

    else
      done = 1;
  }
  if(((signed int)n->left == 0) == ((signed int)p->left == 0))
  {
    single_rotate(gp, (signed int)n->left);
    p->red = (unsigned char)0;
    gp->red = (unsigned char)1;
  }

  else
  {
    single_rotate(p, (signed int)n->left);
    single_rotate(gp, (signed int)n->left);
    n->red = (unsigned char)0;
    gp->red = (unsigned char)1;
  }

__CPROVER_DUMP_L12:
  ;
}

// recurse_into_modules
// file stem_recurse.c line 102
struct _GtkCTreeNode * recurse_into_modules(char *compname_build, char *compname, struct ds_tree_node *t, signed int depth, struct _GtkCTreeNode *subtree, struct _GtkCTreeNode *sibling)
{
  struct ds_component *comp;
  struct ds_component **comp_array;
  signed int i;
  char *compname_full;
  char *txt;
  char *txt2 = (char *)(void *)0;
  struct ds_tree_node *tdup;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ds_tree_node) /*80ul*/ );
  tdup = (struct ds_tree_node *)return_value_malloc_1;
  signed int numcomps;
  memcpy((void *)tdup, (const void *)t, sizeof(struct ds_tree_node) /*80ul*/ );
  t = tdup;
  t->next_flat = flattened_mod_list_root;
  flattened_mod_list_root = t;
  if(!(compname_build == ((char *)NULL)))
  {
    signed int cnl;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(compname_build);
    cnl = (signed int)return_value_strlen_2;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(compname);
    void *return_value_malloc_4;
    return_value_malloc_4=malloc((unsigned long int)(cnl + 1) + return_value_strlen_3 + (unsigned long int)1);
    compname_full = (char *)return_value_malloc_4;
    strcpy(compname_full, compname_build);
    compname_full[(signed long int)cnl] = (char)46;
    strcpy(compname_full + (signed long int)cnl + (signed long int)1, compname);
  }

  else
    compname_full=strdup(t->item);
  t->fullname = compname_full;
  char *tmp_if_expr_5;
  if(!(compname_build == ((char *)NULL)))
    tmp_if_expr_5 = compname;

  else
    tmp_if_expr_5 = t->item;
  txt = tmp_if_expr_5;
  if(t->filename == ((char *)NULL))
  {
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(txt);
    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(" [MISSING]");
    void *return_value_malloc_8;
    return_value_malloc_8=malloc(return_value_strlen_6 + return_value_strlen_7 + (unsigned long int)1);
    txt2 = (char *)return_value_malloc_8;
    strcpy(txt2, txt);
    strcat(txt2, " [MISSING]");
    txt = txt2;
  }

  comp = t->comp;
  if(!(comp == ((struct ds_component *)NULL)))
  {
    sibling=gtk_ctree_insert_node(ctree_main, subtree, sibling, &txt, (unsigned char)3, (struct _GdkDrawable *)(void *)0, (struct _GdkDrawable *)(void *)0, (struct _GdkDrawable *)(void *)0, (struct _GdkDrawable *)(void *)0, 0, 0);
    gtk_ctree_node_set_row_data(ctree_main, sibling, (void *)t);
    numcomps = 0;
    for( ; !(comp == ((struct ds_component *)NULL)); comp = comp->next)
      numcomps = numcomps + 1;
    void *return_value_calloc_9;
    return_value_calloc_9=calloc((unsigned long int)numcomps, sizeof(struct ds_component *) /*8ul*/ );
    comp_array = (struct ds_component **)return_value_calloc_9;
    comp = t->comp;
    i = 0;
    for( ; !(i >= numcomps); i = i + 1)
    {
      comp_array[(signed long int)i] = comp;
      comp = comp->next;
    }
    qsort((void *)comp_array, (unsigned long int)numcomps, sizeof(struct ds_component *) /*8ul*/ , compar_comp_array_bsearch);
    i = 0;
    for( ; !(i >= numcomps); i = i + 1)
    {
      comp = comp_array[(signed long int)i];
      sibling=recurse_into_modules(compname_full, comp->compname, comp->module, depth + 1, sibling, (struct _GtkCTreeNode *)(void *)0);
    }
    free((void *)comp_array);
  }

  else
  {
    sibling=gtk_ctree_insert_node(ctree_main, subtree, sibling, &txt, (unsigned char)3, (struct _GdkDrawable *)(void *)0, (struct _GdkDrawable *)(void *)0, (struct _GdkDrawable *)(void *)0, (struct _GdkDrawable *)(void *)0, (signed int)!(0 != 0), 0);
    gtk_ctree_node_set_row_data(ctree_main, sibling, (void *)t);
  }
  if(!(txt2 == ((char *)NULL)))
    free((void *)txt2);

  return subtree;
}

// rprev
// file jrb.c line 119
static struct jrb_node * rprev(struct jrb_node *n)
{
  if(!((2 & (signed int)n->roothead) == 0))
    return n;

  else
  {
    for( ; (1 & (signed int)n->roothead) == 0; n = n->parent)
      if(!(n->left == 0))
        return n->parent;

    return n->parent;
  }
}

// scroll_event
// file logfile.c line 1319
static signed int scroll_event(struct _GtkWidget *widget, struct _GdkEventScroll *event, void *text)
{
  (void)widget;
  struct _GtkTextView *text_view;
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)text, return_value_gtk_text_view_get_type_1);
  text_view = (struct _GtkTextView *)return_value_g_type_check_instance_cast_2;
  struct _GtkAdjustment *vadj = text_view->vadjustment;
  double s_val;
  s_val=gtk_adjustment_get_step_increment(vadj);
  double p_val;
  p_val=gtk_adjustment_get_page_increment(vadj);
  unsigned long int return_value_gtk_adjustment_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  unsigned long int return_value_gtk_object_get_type_5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  unsigned long int return_value_gtk_adjustment_get_type_7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  unsigned long int return_value_gtk_object_get_type_9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  unsigned long int return_value_gtk_adjustment_get_type_11;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  unsigned long int return_value_gtk_object_get_type_13;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  unsigned long int return_value_gtk_adjustment_get_type_15;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  unsigned long int return_value_gtk_object_get_type_17;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  switch((signed int)event->direction)
  {
    case GDK_SCROLL_UP:
    {
      vadj->value = vadj->value - s_val;
      if(vadj->value < vadj->lower)
        vadj->value = vadj->lower;

      return_value_gtk_adjustment_get_type_3=gtk_adjustment_get_type();
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)vadj, return_value_gtk_adjustment_get_type_3);
      return_value_gtk_object_get_type_5=gtk_object_get_type();
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkAdjustment *)return_value_g_type_check_instance_cast_4, return_value_gtk_object_get_type_5);
      gtk_signal_emit_by_name((struct _GtkObject *)return_value_g_type_check_instance_cast_6, "changed");
      return_value_gtk_adjustment_get_type_7=gtk_adjustment_get_type();
      return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)vadj, return_value_gtk_adjustment_get_type_7);
      return_value_gtk_object_get_type_9=gtk_object_get_type();
      return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkAdjustment *)return_value_g_type_check_instance_cast_8, return_value_gtk_object_get_type_9);
      gtk_signal_emit_by_name((struct _GtkObject *)return_value_g_type_check_instance_cast_10, "value_changed");
      break;
    }
    case GDK_SCROLL_DOWN:
    {
      vadj->value = vadj->value + s_val;
      if(vadj->value > vadj->upper + -p_val)
        vadj->value = vadj->upper - p_val;

      return_value_gtk_adjustment_get_type_11=gtk_adjustment_get_type();
      return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)vadj, return_value_gtk_adjustment_get_type_11);
      return_value_gtk_object_get_type_13=gtk_object_get_type();
      return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkAdjustment *)return_value_g_type_check_instance_cast_12, return_value_gtk_object_get_type_13);
      gtk_signal_emit_by_name((struct _GtkObject *)return_value_g_type_check_instance_cast_14, "changed");
      return_value_gtk_adjustment_get_type_15=gtk_adjustment_get_type();
      return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)vadj, return_value_gtk_adjustment_get_type_15);
      return_value_gtk_object_get_type_17=gtk_object_get_type();
      return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkAdjustment *)return_value_g_type_check_instance_cast_16, return_value_gtk_object_get_type_17);
      gtk_signal_emit_by_name((struct _GtkObject *)return_value_g_type_check_instance_cast_18, "value_changed");
    }
    default:
      ;
  }
  return (signed int)!(0 != 0);
}

// search_backward
// file logfile.c line 453
static void search_backward(struct _GtkWidget *widget, void *data)
{
  (void)widget;
  (void)data;
  tr_search_backward(search_string);
}

// search_forward
// file logfile.c line 462
static void search_forward(struct _GtkWidget *widget, void *data)
{
  (void)widget;
  (void)data;
  tr_search_forward(search_string, forward_noskip);
}

// select_row_callback
// file tree_widget.c line 32
static void select_row_callback(struct _GtkWidget *widget, signed int row, signed int column, struct _GdkEventButton *event, void *data)
{
  (void)widget;
  (void)column;
  (void)event;
  (void)data;
  struct ds_tree_node *t;
  unsigned long int return_value_gtk_clist_get_type_1;
  return_value_gtk_clist_get_type_1=gtk_clist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)ctree_main, return_value_gtk_clist_get_type_1);
  void *return_value_gtk_clist_get_row_data_3;
  return_value_gtk_clist_get_row_data_3=gtk_clist_get_row_data((struct _GtkCList *)return_value_g_type_check_instance_cast_2, row);
  t = (struct ds_tree_node *)return_value_gtk_clist_get_row_data_3;
  selectedtree = t;
  if(!(t->filename == ((char *)NULL)))
    bwlogbox(t->fullname, 640 + 8 * 8, t, 0);

}

// set_insert_position
// file logfile.c line 157
void set_insert_position(struct text_find_t *tr)
{
  struct _GtkTextBuffer *tb;
  unsigned long int return_value_gtk_text_view_get_type_1;
  return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)tr->text, return_value_gtk_text_view_get_type_1);
  tb = ((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer;
  struct _GtkTextMark *tm;
  tm=gtk_text_buffer_get_insert(tb);
  struct _GtkTextIter iter;
  signed int llen;
  gtk_text_buffer_get_iter_at_mark(tb, &iter, tm);
  gtk_text_iter_set_line(&iter, tr->line);
  llen=gtk_text_iter_get_chars_in_line(&iter);
  signed int tmp_if_expr_3;
  if(!(llen >= tr->offs))
    tmp_if_expr_3 = llen;

  else
    tmp_if_expr_3 = tr->offs;
  tr->offs = tmp_if_expr_3;
  gtk_text_iter_set_line_offset(&iter, tr->offs);
  gtk_text_buffer_place_cursor(tb, &iter);
}

// setup_dnd
// file tcl_helper.c line 840
void setup_dnd(struct _GtkWidget *wid)
{
  struct _GtkTargetEntry target_entry[3l];
  target_entry[(signed long int)0].target = "text/plain";
  target_entry[(signed long int)0].flags = (unsigned int)0;
  target_entry[(signed long int)0].info = (unsigned int)0;
  target_entry[(signed long int)1].target = "text/uri-list";
  target_entry[(signed long int)1].flags = (unsigned int)0;
  target_entry[(signed long int)1].info = (unsigned int)1;
  target_entry[(signed long int)2].target = "STRING";
  target_entry[(signed long int)2].flags = (unsigned int)0;
  target_entry[(signed long int)2].info = (unsigned int)2;
  unsigned long int return_value_gtk_widget_get_type_1;
  return_value_gtk_widget_get_type_1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_widget_get_type_1);
  gtk_drag_dest_set((struct _GtkWidget *)return_value_g_type_check_instance_cast_2, (enum anonymous_11)(GTK_DEST_DEFAULT_MOTION | GTK_DEST_DEFAULT_HIGHLIGHT | GTK_DEST_DEFAULT_DROP), target_entry, (signed int)(sizeof(struct _GtkTargetEntry [3l]) /*48ul*/  / sizeof(struct _GtkTargetEntry) /*16ul*/ ), (enum anonymous_37)GDK_ACTION_COPY);
  unsigned long int return_value_gtk_object_get_type_3;
  return_value_gtk_object_get_type_3=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_object_get_type_3);
  unsigned long int return_value_gtk_widget_get_type_5;
  return_value_gtk_widget_get_type_5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_widget_get_type_5);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_4, "drag_data_received", (void (*)(void))DNDDataReceivedCB, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)(struct _GtkWidget *)return_value_g_type_check_instance_cast_6, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_7;
  return_value_gtk_object_get_type_7=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_object_get_type_7);
  unsigned long int return_value_gtk_widget_get_type_9;
  return_value_gtk_widget_get_type_9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_widget_get_type_9);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_8, "drag_motion", (void (*)(void))DNDDragMotionCB, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)(struct _GtkWidget *)return_value_g_type_check_instance_cast_10, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_11;
  return_value_gtk_object_get_type_11=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_object_get_type_11);
  unsigned long int return_value_gtk_widget_get_type_13;
  return_value_gtk_widget_get_type_13=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_widget_get_type_13);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_12, "drag_begin", (void (*)(void))DNDBeginCB_link1, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)(struct _GtkWidget *)return_value_g_type_check_instance_cast_14, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type_15;
  return_value_gtk_object_get_type_15=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_object_get_type_15);
  unsigned long int return_value_gtk_widget_get_type_17;
  return_value_gtk_widget_get_type_17=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)wid, return_value_gtk_widget_get_type_17);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_16, "drag_end", (void (*)(void))DNDEndCB_link1, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)(struct _GtkWidget *)return_value_g_type_check_instance_cast_18, (void (*)(void *))(void *)0, 0, 0);
}

// single_rotate
// file jrb.c line 359
static void single_rotate(struct jrb_node *y, signed int l)
{
  signed int rl = 0;
  signed int ir;
  struct jrb_node *x;
  struct jrb_node *yp;
  ir = (signed int)y->roothead & 1;
  yp = y->parent;
  if(ir == 0)
    rl = (signed int)y->left;

  if(!(l == 0))
  {
    x = y->flink;
    y->flink = x->blink;
    y->flink->left = (unsigned char)1;
    y->flink->parent = y;
    x->blink = y;
    y->left = (unsigned char)0;
  }

  else
  {
    x = y->blink;
    y->blink = x->flink;
    y->blink->left = (unsigned char)0;
    y->blink->parent = y;
    x->flink = y;
    y->left = (unsigned char)1;
  }
  x->parent = yp;
  y->parent = x;
  if(!(ir == 0))
  {
    yp->parent = x;
    y->roothead = (unsigned char)0;
    x->roothead = x->roothead | (unsigned char)1;
  }

  else
    if(!(rl == 0))
    {
      yp->flink = x;
      x->left = (unsigned char)1;
    }

    else
    {
      yp->blink = x;
      x->left = (unsigned char)0;
    }
}

// tclBackslash
// file tcl_helper.c line 40
static char tclBackslash(const char *src, signed int *readPtr)
{
  const char *p = src + (signed long int)1;
  char result;
  signed int count = 2;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_6;
  switch((signed int)*p)
  {
    case 97:
    {
      result = (char)0x7;
      break;
    }
    case 98:
    {
      result = (char)0x8;
      break;
    }
    case 102:
    {
      result = (char)0xc;
      break;
    }
    case 110:
    {
      result = (char)0xa;
      break;
    }
    case 114:
    {
      result = (char)0xd;
      break;
    }
    case 116:
    {
      result = (char)0x9;
      break;
    }
    case 118:
    {
      result = (char)0xb;
      break;
    }
    case 120:
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((4096 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)p[1l]]) == 0))
      {
        char *end;
        unsigned long int return_value_strtoul_1;
        return_value_strtoul_1=strtoul(p + (signed long int)1, &end, 16);
        result = (char)return_value_strtoul_1;
        count = (signed int)(end - src);
      }

      else
      {
        count = 2;
        result = (char)120;
      }
      break;
    }
    case 10:
    {
      do
      {
        p = p + 1l;
        if((signed int)*p == 32)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*p == 9 ? (_Bool)1 : (_Bool)0;
      }
      while(tmp_if_expr_3);
      result = (char)32;
      count = (signed int)(p - src);
      break;
    }
    case 0:
    {
      result = (char)92;
      count = 1;
      break;
    }
    default:
    {
      return_value___ctype_b_loc_6=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned char)*p]) == 0))
      {
        result = (char)((signed int)*p - 48);
        p = p + 1l;
        const unsigned short int **return_value___ctype_b_loc_4;
        return_value___ctype_b_loc_4=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*p]) == 0)
          break;

        count = 3;
        result = (char)(((signed int)result << 3) + ((signed int)*p - 48));
        p = p + 1l;
        const unsigned short int **return_value___ctype_b_loc_5;
        return_value___ctype_b_loc_5=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)(unsigned char)*p]) == 0)
          break;

        count = 4;
        result = (char)(((signed int)result << 3) + ((signed int)*p - 48));
        break;
      }

      result = *p;
      count = 2;
    }
  }
  if(!(readPtr == ((signed int *)NULL)))
    *readPtr = count;

  return result;
}

// tclConvertElement
// file tcl_helper.c line 485
static signed int tclConvertElement(const char *src, char *dst, signed int flags)
{
  char *p = dst;
  _Bool tmp_if_expr_1;
  if(src == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*src == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    p[(signed long int)0] = (char)123;
    p[(signed long int)1] = (char)125;
    p[(signed long int)2] = (char)0;
    return 2;
  }

  else
  {
    if((1 & flags) == 0 && !((2 & flags) == 0))
    {
      *p = (char)123;
      p = p + 1l;
      for( ; !((signed int)*src == 0); p = p + 1l)
      {
        *p = *src;
        src = src + 1l;
      }
      *p = (char)125;
      p = p + 1l;
    }

    else
    {
      if((signed int)*src == 123)
      {
        p[(signed long int)0] = (char)92;
        p[(signed long int)1] = (char)123;
        p = p + (signed long int)2;
        src = src + 1l;
        flags = flags | 4;
      }

      for( ; !((signed int)*src == 0); src = src + 1l)
        switch((signed int)*src)
        {
          case 93:

          case 91:

          case 36:

          case 59:

          case 32:

          case 92:

          case 34:
          {
            *p = (char)92;
            p = p + 1l;
            goto __CPROVER_DUMP_L16;
          }
          case 123:

          case 125:
          {
            if(!((4 & flags) == 0))
            {
              *p = (char)92;
              p = p + 1l;
            }

            goto __CPROVER_DUMP_L16;
          }
          case 12:
          {
            *p = (char)92;
            p = p + 1l;
            *p = (char)102;
            p = p + 1l;
            break;
          }
          case 10:
          {
            *p = (char)92;
            p = p + 1l;
            *p = (char)110;
            p = p + 1l;
            break;
          }
          case 13:
          {
            *p = (char)92;
            p = p + 1l;
            *p = (char)114;
            p = p + 1l;
            break;
          }
          case 9:
          {
            *p = (char)92;
            p = p + 1l;
            *p = (char)116;
            p = p + 1l;
            break;
          }
          case 11:
          {
            *p = (char)92;
            p = p + 1l;
            *p = (char)118;
            p = p + 1l;
            break;
          }
          default:
          {

          __CPROVER_DUMP_L16:
            ;
            *p = *src;
            p = p + 1l;
          }
        }
    }
    *p = (char)0;
    return (signed int)(p - dst);
  }
}

// tclCopyAndCollapse
// file tcl_helper.c line 265
static void tclCopyAndCollapse(signed int count, const char *src, char *dst)
{
  char c;
  signed int numRead;
  c = *src;
  for( ; count >= 1; count = count - 1)
  {
    if((signed int)c == 92)
    {
      *dst=tclBackslash(src, &numRead);
      dst = dst + 1l;
      src = src + (signed long int)(numRead - 1);
      count = count - (numRead - 1);
    }

    else
    {
      *dst = c;
      dst = dst + 1l;
    }
    src = src + 1l;
    c = *src;
  }
  *dst = (char)0;
}

// tclFindElement
// file tcl_helper.c line 131
static signed int tclFindElement(const char *list, const char **elementPtr, const char **nextPtr, signed int *sizePtr, signed int *bracePtr)
{
  const char *p;
  signed int openBraces = 0;
  signed int inQuotes = 0;
  signed int size;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*list]) == 0)
      break;

    list = list + 1l;
  }
  while((_Bool)1);
  if((signed int)*list == 123)
  {
    openBraces = 1;
    list = list + 1l;
  }

  else
    if((signed int)*list == 34)
    {
      inQuotes = 1;
      list = list + 1l;
    }

  if(!(bracePtr == ((signed int *)NULL)))
    *bracePtr = openBraces;

  p = list;
  _Bool tmp_if_expr_3;
  signed int siz;
  _Bool tmp_if_expr_5;
  while((_Bool)1)
    switch((signed int)*p)
    {
      case 123:
      {
        if(!(openBraces == 0))
          openBraces = openBraces + 1;

        goto __CPROVER_DUMP_L23;
      }
      case 125:
      {
        if(openBraces == 1)
        {
          size = (signed int)(p - list);
          p = p + 1l;
          const unsigned short int **return_value___ctype_b_loc_2;
          return_value___ctype_b_loc_2=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(unsigned char)*p]) == 0))
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = (signed int)*p == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            goto done;

          return 0;
        }

        else
          if(!(openBraces == 0))
            openBraces = openBraces - 1;

        goto __CPROVER_DUMP_L23;
      }
      case 92:
      {
        tclBackslash(p, &siz);
        p = p + (signed long int)(siz - 1);
        goto __CPROVER_DUMP_L23;
      }
      case 32:

      case 12:

      case 10:

      case 13:

      case 9:

      case 11:
      {
        if(inQuotes == 0 && openBraces == 0)
        {
          size = (signed int)(p - list);
          goto done;
        }

        goto __CPROVER_DUMP_L23;
      }
      case 34:
      {
        if(!(inQuotes == 0))
        {
          size = (signed int)(p - list);
          p = p + 1l;
          const unsigned short int **return_value___ctype_b_loc_4;
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)(unsigned char)*p]) == 0))
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = (signed int)*p == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            goto done;

          return 0;
        }

        goto __CPROVER_DUMP_L23;
      }
      case 0:
      {
        if(!(inQuotes == 0) || !(openBraces == 0))
          return 0;

        size = (signed int)(p - list);
        goto done;
      }
      default:
      {

      __CPROVER_DUMP_L23:
        ;
        p = p + 1l;
      }
    }
  const unsigned short int **return_value___ctype_b_loc_6;
  do
  {

  done:
    ;
    return_value___ctype_b_loc_6=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)(unsigned char)*p]) == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  *elementPtr = list;
  *nextPtr = p;
  if(!(sizePtr == ((signed int *)NULL)))
    *sizePtr = size;

  return 1;
}

// tclScanElement
// file tcl_helper.c line 406
static signed int tclScanElement(const char *string, signed int *flagPtr)
{
  const char *p;
  signed int nestingLevel = 0;
  signed int flags = 0;
  if(string == ((const char *)NULL))
    string = "";

  p = string;
  _Bool tmp_if_expr_1;
  if((signed int)*p == 123)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*p == 34 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)*p == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    flags = flags | 2;

  _Bool tmp_if_expr_3;
  for( ; !((signed int)*p == 0); p = p + 1l)
    switch((signed int)*p)
    {
      case 123:
      {
        nestingLevel = nestingLevel + 1;
        break;
      }
      case 125:
      {
        nestingLevel = nestingLevel - 1;
        if(!(nestingLevel >= 0))
          flags = flags | 1 | 4;

        break;
      }
      case 91:

      case 36:

      case 59:

      case 32:

      case 12:

      case 13:

      case 9:

      case 11:
      {
        flags = flags | 2;
        break;
      }
      case 10:
      {
        flags = flags | 1;
        break;
      }
      case 92:
      {
        if((signed int)p[1l] == 0)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)p[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          flags = 1 | 4;

        else
        {
          signed int size;
          tclBackslash(p, &size);
          p = p + (signed long int)(size - 1);
          flags = flags | 2;
        }
      }
    }
  if(!(nestingLevel == 0))
    flags = 1 | 4;

  *flagPtr = flags;
  return (signed int)((signed long int)2 * (p - string) + (signed long int)2);
}

// tmpfile_close
// file ./../../src/helpers/fst/fstapi.c line 235
static void tmpfile_close(struct _IO_FILE **f, char **nam)
{
  if(!(f == ((struct _IO_FILE **)NULL)))
  {
    if(!(*f == ((struct _IO_FILE *)NULL)))
    {
      fclose(*f);
      *f = (struct _IO_FILE *)(void *)0;
    }

  }

  if(!(nam == ((char **)NULL)))
  {
    if(!(*nam == ((char *)NULL)))
    {
      unlink(*nam);
      free((void *)*nam);
      *nam = (char *)(void *)0;
    }

  }

}

// tmpfile_open
// file ./../../src/helpers/fst/fstapi.c line 225
static struct _IO_FILE * tmpfile_open(char **nam)
{
  struct _IO_FILE *f;
  f=tmpfile();
  if(!(nam == ((char **)NULL)))
    *nam = (char *)(void *)0;

  return f;
}

// tmpnam_rtlbrowse
// file logfile.c line 591
static char * tmpnam_rtlbrowse(char *s, signed int *fd)
{
  (void)s;
  char *backpath = "gtkwaveXXXXXX";
  char *tmpspace;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen("/tmp");
  len = (signed int)return_value_strlen_1;
  signed int i;
  unsigned char slash = (unsigned char)47;
  i = 0;
  _Bool tmp_if_expr_2;
  for( ; !(i >= len); i = i + 1)
  {
    if((signed int)"/tmp"[(signed long int)i] == 92)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)"/tmp"[(signed long int)i] == 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      slash = (unsigned char)"/tmp"[(signed long int)i];
      break;
    }

  }
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(backpath);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)(len + 1) + return_value_strlen_3 + (unsigned long int)1);
  tmpspace = (char *)return_value_malloc_4;
  sprintf(tmpspace, "%s%c%s", (const void *)"/tmp", slash, backpath);
  *fd=mkstemp(tmpspace);
  if(!(*fd >= 0))
  {
    fprintf(stderr, "tmpnam_rtlbrowse() could not create tempfile, exiting.\n");
    perror("Why");
    exit(255);
  }

  return tmpspace;
}

// toggle_callback
// file logfile.c line 496
static void toggle_callback(struct _GtkWidget *widget, struct _GtkWidget *nothing)
{
  (void)nothing;
  unsigned long int return_value_gtk_toggle_button_get_type_1;
  return_value_gtk_toggle_button_get_type_1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_toggle_button_get_type_1);
  matchcase_active = (signed int)((signed int)((struct _GtkToggleButton *)return_value_g_type_check_instance_cast_2)->active != 0);
  tr_search_forward(search_string, (signed int)!(0 != 0));
}

// tr_search_backward
// file logfile.c line 379
void tr_search_backward(char *str)
{
  struct text_find_t *tr = selected_text_via_tab;
  if(!(tr == ((struct text_find_t *)NULL)))
  {
    if(!(tr->text == ((struct _GtkWidget *)NULL)))
    {
      struct _GtkTextBuffer *tb;
      unsigned long int return_value_gtk_text_view_get_type_1;
      return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)tr->text, return_value_gtk_text_view_get_type_1);
      tb = ((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer;
      struct _GtkTextMark *tm;
      tm=gtk_text_buffer_get_insert(tb);
      struct _GtkTextIter iter;
      signed int found = 0;
      struct _GtkTextIter match_start;
      struct _GtkTextIter match_end;
      gtk_text_buffer_get_iter_at_mark(tb, &iter, tm);
      tr->line=gtk_text_iter_get_line(&iter);
      tr->offs=gtk_text_iter_get_line_offset(&iter);
      if(tr->line == tr->srch_line)
      {
        if(tr->offs == tr->srch_offs)
          gtk_text_iter_backward_char(&iter);

      }

      if(!(str == ((char *)NULL)))
      {
        if(matchcase_active == 0)
          found=iter_backward_search_caseins(&iter, str, &match_start, &match_end);

        else
          found=gtk_text_iter_backward_search(&iter, str, (enum anonymous_0)GTK_TEXT_SEARCH_TEXT_ONLY, &match_start, &match_end, (const struct _GtkTextIter *)(void *)0);
        if(found == 0)
        {
          gtk_text_buffer_get_end_iter(tb, &iter);
          if(matchcase_active == 0)
            found=iter_backward_search_caseins(&iter, str, &match_start, &match_end);

          else
            found=gtk_text_iter_backward_search(&iter, str, (enum anonymous_0)GTK_TEXT_SEARCH_TEXT_ONLY, &match_start, &match_end, (const struct _GtkTextIter *)(void *)0);
        }

      }

      if(!(found == 0))
      {
        gtk_text_buffer_select_range(tb, &match_start, &match_end);
        read_insert_position(tr);
        tr->srch_line = tr->line;
        tr->srch_offs = tr->offs;
        unsigned long int return_value_gtk_text_view_get_type_3;
        return_value_gtk_text_view_get_type_3=gtk_text_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
        return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)tr->text, return_value_gtk_text_view_get_type_3);
        gtk_text_view_scroll_to_iter((struct _GtkTextView *)return_value_g_type_check_instance_cast_4, &match_start, 0.0, (signed int)!(0 != 0), 0.0, 0.5);
      }

      else
      {
        gtk_text_buffer_get_iter_at_mark(tb, &iter, tm);
        gtk_text_buffer_select_range(tb, &iter, &iter);
      }
    }

  }

}

// tr_search_forward
// file logfile.c line 263
void tr_search_forward(char *str, signed int noskip)
{
  struct text_find_t *tr = selected_text_via_tab;
  if(!(tr == ((struct text_find_t *)NULL)))
  {
    if(!(tr->text == ((struct _GtkWidget *)NULL)))
    {
      struct _GtkTextBuffer *tb;
      unsigned long int return_value_gtk_text_view_get_type_1;
      return_value_gtk_text_view_get_type_1=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)tr->text, return_value_gtk_text_view_get_type_1);
      tb = ((struct _GtkTextView *)return_value_g_type_check_instance_cast_2)->buffer;
      struct _GtkTextMark *tm;
      tm=gtk_text_buffer_get_insert(tb);
      struct _GtkTextIter iter;
      signed int found = 0;
      struct _GtkTextIter match_start;
      struct _GtkTextIter match_end;
      gtk_text_buffer_get_iter_at_mark(tb, &iter, tm);
      tr->line=gtk_text_iter_get_line(&iter);
      tr->offs=gtk_text_iter_get_line_offset(&iter);
      if(noskip == 0)
      {
        if(tr->line == tr->srch_line)
        {
          if(tr->offs == tr->srch_offs)
            gtk_text_iter_forward_char(&iter);

        }

      }

      if(!(str == ((char *)NULL)))
      {
        if(matchcase_active == 0)
          found=iter_forward_search_caseins(&iter, str, &match_start, &match_end);

        else
          found=gtk_text_iter_forward_search(&iter, str, (enum anonymous_0)GTK_TEXT_SEARCH_TEXT_ONLY, &match_start, &match_end, (const struct _GtkTextIter *)(void *)0);
        if(found == 0)
        {
          gtk_text_buffer_get_start_iter(tb, &iter);
          if(matchcase_active == 0)
            found=iter_forward_search_caseins(&iter, str, &match_start, &match_end);

          else
            found=gtk_text_iter_forward_search(&iter, str, (enum anonymous_0)GTK_TEXT_SEARCH_TEXT_ONLY, &match_start, &match_end, (const struct _GtkTextIter *)(void *)0);
        }

      }

      if(!(found == 0))
      {
        gtk_text_buffer_select_range(tb, &match_start, &match_end);
        read_insert_position(tr);
        tr->srch_line = tr->line;
        tr->srch_offs = tr->offs;
        unsigned long int return_value_gtk_text_view_get_type_3;
        return_value_gtk_text_view_get_type_3=gtk_text_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
        return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)tr->text, return_value_gtk_text_view_get_type_3);
        gtk_text_view_scroll_to_iter((struct _GtkTextView *)return_value_g_type_check_instance_cast_4, &match_start, 0.0, (signed int)!(0 != 0), 0.0, 0.5);
      }

      else
      {
        gtk_text_buffer_get_iter_at_mark(tb, &iter, tm);
        gtk_text_buffer_select_range(tb, &iter, &iter);
      }
    }

  }

}

// treebox
// file tree_widget.c line 102
void treebox(char *title, void (*func)(void), struct _GtkWidget *old_window)
{
  (void)old_window;
  struct _GtkWidget *scrolled_win;
  struct _GtkWidget *frame2;
  struct _GtkWidget *table;
  struct _GtkCList *clist;
  if(!(is_active == 0))
    gdk_window_raise(window->window);

  else
  {
    is_active = 1;
    cleanup = func;
    window=gtk_window_new((enum anonymous_70)GTK_WINDOW_TOPLEVEL);
    unsigned long int return_value_gtk_window_get_type_1;
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_window_get_type_1);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, title);
    unsigned long int return_value_gtk_object_get_type_3;
    return_value_gtk_object_get_type_3=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_object_get_type_3);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_4, "delete_event", (void (*)(void))destroy_callback_link1, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 0, 0);
    unsigned long int return_value_gtk_window_get_type_5;
    return_value_gtk_window_get_type_5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_window_get_type_5);
    gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast_6, 640, 600);
    table=gtk_table_new((unsigned int)256, (unsigned int)1, 0);
    gtk_widget_show(table);
    frame2=gtk_hpaned_new();
    gtk_widget_show(frame2);
    notebook=gtk_notebook_new();
    unsigned long int return_value_gtk_notebook_get_type_7;
    return_value_gtk_notebook_get_type_7=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type_7);
    gtk_notebook_set_tab_pos((struct _GtkNotebook *)return_value_g_type_check_instance_cast_8, (enum anonymous_18)GTK_POS_TOP);
    unsigned long int return_value_gtk_notebook_get_type_9;
    return_value_gtk_notebook_get_type_9=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
    return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type_9);
    gtk_notebook_set_show_tabs((struct _GtkNotebook *)return_value_g_type_check_instance_cast_10, ~0);
    unsigned long int return_value_gtk_notebook_get_type_11;
    return_value_gtk_notebook_get_type_11=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
    return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type_11);
    gtk_notebook_set_show_border((struct _GtkNotebook *)return_value_g_type_check_instance_cast_12, ~0);
    unsigned long int return_value_gtk_notebook_get_type_13;
    return_value_gtk_notebook_get_type_13=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
    return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type_13);
    gtk_notebook_set_scrollable((struct _GtkNotebook *)return_value_g_type_check_instance_cast_14, ~0);
    unsigned long int return_value_gtk_notebook_get_type_15;
    return_value_gtk_notebook_get_type_15=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
    return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type_15);
    gtk_notebook_popup_enable((struct _GtkNotebook *)return_value_g_type_check_instance_cast_16);
    gtk_widget_show(notebook);
    unsigned long int return_value_gtk_paned_get_type_17;
    return_value_gtk_paned_get_type_17=gtk_paned_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
    return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)frame2, return_value_gtk_paned_get_type_17);
    gtk_paned_pack2((struct _GtkPaned *)return_value_g_type_check_instance_cast_18, notebook, (signed int)!(0 != 0), (signed int)!(0 != 0));
    unsigned long int return_value_gtk_table_get_type_19;
    return_value_gtk_table_get_type_19=gtk_table_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
    return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)table, return_value_gtk_table_get_type_19);
    gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast_20, frame2, (unsigned int)0, (unsigned int)1, (unsigned int)0, (unsigned int)255, (enum anonymous_63)(GTK_FILL | GTK_EXPAND), (enum anonymous_63)(GTK_FILL | GTK_EXPAND | GTK_SHRINK), (unsigned int)1, (unsigned int)1);
    tree=gtk_ctree_new(1, 0);
    unsigned long int return_value_gtk_ctree_get_type_21;
    return_value_gtk_ctree_get_type_21=gtk_ctree_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
    return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)tree, return_value_gtk_ctree_get_type_21);
    ctree_main = (struct _GtkCTree *)return_value_g_type_check_instance_cast_22;
    unsigned long int return_value_gtk_clist_get_type_23;
    return_value_gtk_clist_get_type_23=gtk_clist_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
    return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)tree, return_value_gtk_clist_get_type_23);
    gtk_clist_set_column_auto_resize((struct _GtkCList *)return_value_g_type_check_instance_cast_24, 0, (signed int)!(0 != 0));
    gtk_widget_show(tree);
    unsigned long int return_value_gtk_clist_get_type_25;
    return_value_gtk_clist_get_type_25=gtk_clist_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
    return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)tree, return_value_gtk_clist_get_type_25);
    clist = (struct _GtkCList *)return_value_g_type_check_instance_cast_26;
    unsigned long int return_value_gtk_object_get_type_27;
    return_value_gtk_object_get_type_27=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
    return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)clist, return_value_gtk_object_get_type_27);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_28, "select_row", (void (*)(void))select_row_callback, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 1, 0);
    unsigned long int return_value_gtk_object_get_type_29;
    return_value_gtk_object_get_type_29=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
    return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)clist, return_value_gtk_object_get_type_29);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast_30, "unselect_row", (void (*)(void))unselect_row_callback, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)0, (void (*)(void *))(void *)0, 1, 0);
    gtk_clist_freeze(clist);
    gtk_clist_clear(clist);
    bwmaketree();
    gtk_clist_thaw(clist);
    selectedtree = (struct ds_tree_node *)(void *)0;
    scrolled_win=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
    unsigned long int return_value_gtk_widget_get_type_31;
    return_value_gtk_widget_get_type_31=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
    return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_win, return_value_gtk_widget_get_type_31);
    gtk_widget_set_usize((struct _GtkWidget *)return_value_g_type_check_instance_cast_32, 150, 300);
    unsigned long int return_value_gtk_scrolled_window_get_type_33;
    return_value_gtk_scrolled_window_get_type_33=gtk_scrolled_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
    return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_win, return_value_gtk_scrolled_window_get_type_33);
    gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_34, (enum anonymous_19)GTK_POLICY_AUTOMATIC, (enum anonymous_19)GTK_POLICY_AUTOMATIC);
    gtk_widget_show(scrolled_win);
    unsigned long int return_value_gtk_container_get_type_35;
    return_value_gtk_container_get_type_35=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_36;
    return_value_g_type_check_instance_cast_36=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_win, return_value_gtk_container_get_type_35);
    unsigned long int return_value_gtk_widget_get_type_37;
    return_value_gtk_widget_get_type_37=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_38;
    return_value_g_type_check_instance_cast_38=g_type_check_instance_cast((struct _GTypeInstance *)tree, return_value_gtk_widget_get_type_37);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_36, (struct _GtkWidget *)return_value_g_type_check_instance_cast_38);
    unsigned long int return_value_gtk_paned_get_type_39;
    return_value_gtk_paned_get_type_39=gtk_paned_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
    return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)frame2, return_value_gtk_paned_get_type_39);
    gtk_paned_pack1((struct _GtkPaned *)return_value_g_type_check_instance_cast_40, scrolled_win, (signed int)!(0 != 0), (signed int)!(0 != 0));
    create_toolbar(table);
    unsigned long int return_value_gtk_container_get_type_41;
    return_value_gtk_container_get_type_41=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_42;
    return_value_g_type_check_instance_cast_42=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_container_get_type_41);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_42, table);
    gtk_widget_show(window);
    setup_dnd(window);
  }
}

// treebox_is_active
// file tree_widget.c line 74
signed int treebox_is_active(void)
{
  return is_active;
}

// unlink_fopen
// file ./../../src/helpers/fst/fstapi.c line 170
static struct _IO_FILE * unlink_fopen(const char *nam, const char *mode)
{
  unlink(nam);
  struct _IO_FILE *return_value_fopen_1;
  return_value_fopen_1=fopen(nam, mode);
  return return_value_fopen_1;
}

// unselect_row_callback
// file tree_widget.c line 61
static void unselect_row_callback(struct _GtkWidget *widget, signed int row, signed int column, struct _GdkEventButton *event, void *data)
{
  (void)widget;
  (void)row;
  (void)column;
  (void)event;
  (void)data;
  selectedtree = (struct ds_tree_node *)(void *)0;
}

// update_ctx_when_idle
// file logfile.c line 1451
signed int update_ctx_when_idle(void *textview_or_dummy)
{
  struct text_find_t *t;
  if(!(anno_ctx == ((struct gtkwave_annotate_ipc_t *)NULL)))
  {
    if(!(anno_ctx->cygwin_remote_kill == 0u))
    {
      anno_ctx->cygwin_remote_kill = (unsigned int)0;
      exit(0);
    }

  }

  _Bool tmp_if_expr_1;
  if(textview_or_dummy == NULL)
  {
    if(!(anno_ctx == ((struct gtkwave_annotate_ipc_t *)NULL)))
    {
      if(!((unsigned int)anno_ctx->marker_set == old_marker_set))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = old_marker != anno_ctx->marker ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        old_marker_set = (unsigned int)anno_ctx->marker_set;
        old_marker = anno_ctx->marker;
      }

      else
        return (signed int)!(0 != 0);
      goto __CPROVER_DUMP_L7;
    }

    return (signed int)!(0 != 0);
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    t = text_root;
    while(!(t == ((struct text_find_t *)NULL)))
      if(!(textview_or_dummy == NULL))
      {
        if(textview_or_dummy == (void *)t->text)
          goto __CPROVER_DUMP_L9;

        t = t->next;
      }

      else
      {

      __CPROVER_DUMP_L9:
        ;
        if(!(t->window == ((struct _GtkWidget *)NULL)))
        {
          if(t->ctx->display_mode == 0 || !(textview_or_dummy == NULL))
          {
            struct _GtkTextIter st_iter;
            struct _GtkTextIter en_iter;
            struct _GtkAdjustment *vadj;
            unsigned long int return_value_gtk_text_view_get_type_2;
            return_value_gtk_text_view_get_type_2=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
            return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)t->text, return_value_gtk_text_view_get_type_2);
            vadj = ((struct _GtkTextView *)return_value_g_type_check_instance_cast_3)->vadjustment;
            double vvalue = vadj->value;
            read_insert_position(t);
            unsigned long int return_value_gtk_text_view_get_type_4;
            return_value_gtk_text_view_get_type_4=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
            return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)t->text, return_value_gtk_text_view_get_type_4);
            gtk_text_buffer_get_start_iter(((struct _GtkTextView *)return_value_g_type_check_instance_cast_5)->buffer, &st_iter);
            unsigned long int return_value_gtk_text_view_get_type_6;
            return_value_gtk_text_view_get_type_6=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
            return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)t->text, return_value_gtk_text_view_get_type_6);
            gtk_text_buffer_get_end_iter(((struct _GtkTextView *)return_value_g_type_check_instance_cast_7)->buffer, &en_iter);
            unsigned long int return_value_gtk_text_view_get_type_8;
            return_value_gtk_text_view_get_type_8=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
            return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)t->text, return_value_gtk_text_view_get_type_8);
            gtk_text_buffer_delete(((struct _GtkTextView *)return_value_g_type_check_instance_cast_9)->buffer, &st_iter, &en_iter);
            unsigned long int return_value_gtk_text_view_get_type_10;
            return_value_gtk_text_view_get_type_10=gtk_text_view_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
            return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)t->text, return_value_gtk_text_view_get_type_10);
            gtk_text_buffer_get_start_iter(((struct _GtkTextView *)return_value_g_type_check_instance_cast_11)->buffer, &iterx);
            bold_tag = t->bold_tag;
            dgray_tag = t->dgray_tag;
            lgray_tag = t->lgray_tag;
            blue_tag = t->blue_tag;
            fwht_tag = t->fwht_tag;
            mono_tag = t->mono_tag;
            size_tag = t->size_tag;
            bwlogbox_2(t->ctx, (struct _GtkWidget *)(void *)0, t->button, t->text);
            set_insert_position(t);
            vadj->value = vvalue;
            unsigned long int return_value_gtk_object_get_type_12;
            return_value_gtk_object_get_type_12=gtk_object_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
            return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)vadj, return_value_gtk_object_get_type_12);
            gtk_signal_emit_by_name((struct _GtkObject *)return_value_g_type_check_instance_cast_13, "changed");
            unsigned long int return_value_gtk_object_get_type_14;
            return_value_gtk_object_get_type_14=gtk_object_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
            return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)vadj, return_value_gtk_object_get_type_14);
            gtk_signal_emit_by_name((struct _GtkObject *)return_value_g_type_check_instance_cast_15, "value_changed");
          }

        }

        t = t->next;
      }
    return (signed int)!(0 != 0);
  }
}

// v_preproc
// file vlex.l line 33
static signed int v_preproc(char *buf, signed int max_size)
{
  signed int ch;
  if(v_preproc_initialized == 0)
  {
    yyin=fopen(v_preproc_name, "rb");
    if(yyin == ((struct _IO_FILE *)NULL))
      return 0;

    v_preproc_initialized = 1;
    my_yylineno = 1;
  }

  ch=fgetc(yyin);
  if(!(ch == -1))
  {
    buf[(signed long int)0] = (char)ch;
    buf[(signed long int)1] = (char)0;
    return 1;
  }

  else
  {
    fclose(yyin);
    yyin = (struct _IO_FILE *)(void *)0;
    v_preproc_initialized = 0;
    return 0;
  }
}

// vzt_rd_block_vch_decode
// file ./../../src/helpers/vzt_read.c line 307
static void vzt_rd_block_vch_decode(struct vzt_rd_trace *lt, struct vzt_rd_block *b)
{
  vzt_rd_pthread_mutex_lock(lt, &b->mutex);
  unsigned long int tmp_post_3;
  unsigned int tmp_post_9;
  if(b->times == ((unsigned long int *)NULL))
  {
    if(!(b->mem == ((char *)NULL)))
    {
      unsigned long int *times = (unsigned long int *)(void *)0;
      unsigned int *change_dict = (unsigned int *)(void *)0;
      unsigned int *val_dict = (unsigned int *)(void *)0;
      unsigned int num_time_ticks;
      unsigned int num_sections;
      unsigned int num_dict_entries;
      char *pnt = b->mem;
      unsigned int i;
      unsigned int j;
      unsigned int m;
      unsigned int num_dict_words;
      unsigned int *val_tmp;
      unsigned int num_bitplanes;
      unsigned long int padskip;
      num_time_ticks=vzt_rd_get_v32(&pnt);
      if(!(num_time_ticks == 0u))
      {
        unsigned long int cur_time;
        void *return_value_malloc_1;
        return_value_malloc_1=malloc((unsigned long int)num_time_ticks * sizeof(unsigned long int) /*8ul*/ );
        times = (unsigned long int *)return_value_malloc_1;
        cur_time=vzt_rd_get_v64(&pnt);
        times[(signed long int)0] = cur_time;
        i = (unsigned int)1;
        for( ; !(i >= num_time_ticks); i = i + 1u)
        {
          unsigned long int delta;
          delta=vzt_rd_get_v64(&pnt);
          cur_time = cur_time + delta;
          times[(signed long int)i] = cur_time;
        }
      }

      else
      {
        unsigned long int vzt_rd_block_vch_decode__1__1__2__cur_time = b->start;
        num_time_ticks = (unsigned int)((b->end - b->start) + (unsigned long int)1);
        void *return_value_malloc_2;
        return_value_malloc_2=malloc((unsigned long int)num_time_ticks * sizeof(unsigned long int) /*8ul*/ );
        times = (unsigned long int *)return_value_malloc_2;
        i = (unsigned int)0;
        for( ; !(i >= num_time_ticks); i = i + 1u)
        {
          tmp_post_3 = vzt_rd_block_vch_decode__1__1__2__cur_time;
          vzt_rd_block_vch_decode__1__1__2__cur_time = vzt_rd_block_vch_decode__1__1__2__cur_time + 1ul;
          times[(signed long int)i] = tmp_post_3;
        }
      }
      num_sections=vzt_rd_get_v32(&pnt);
      num_dict_entries=vzt_rd_get_v32(&pnt);
      padskip = (unsigned long int)pnt & (unsigned long int)3;
      pnt = pnt + (signed long int)(padskip != 0ul ? (unsigned long int)4 - padskip : (unsigned long int)0);
      if(!(b->rle == 0u))
      {
        unsigned int *curr_dec_dict;
        unsigned int first_bit = (unsigned int)0;
        unsigned int curr_bit = (unsigned int)0;
        unsigned int runlen;
        num_dict_words = num_sections * num_dict_entries;
        b->num_rle_bytes = (unsigned int)((unsigned long int)num_dict_words * sizeof(unsigned int) /*4ul*/ );
        void *return_value_calloc_4;
        return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)b->num_rle_bytes);
        val_dict = (unsigned int *)return_value_calloc_4;
        curr_dec_dict = val_dict;
        vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
        lt->block_mem_consumed = lt->block_mem_consumed + (unsigned long int)b->num_rle_bytes;
        vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
        i = (unsigned int)0;
        for( ; !(i >= num_dict_entries); i = i + 1u)
        {
          unsigned int curr_dec_bit = (unsigned int)0;
          unsigned int curr_dec_word = (unsigned int)0;
          do
          {
            runlen=vzt_rd_get_v32(&pnt);
            if(runlen == 0u)
              first_bit = first_bit ^ (unsigned int)1;

            curr_bit = curr_bit ^ (unsigned int)1;
            if(curr_dec_bit == 0u && curr_dec_word == 0u)
              curr_bit = first_bit;

            j = (unsigned int)0;
            for( ; !(j >= runlen); j = j + 1u)
            {
              if(!(curr_bit == 0u))
                *curr_dec_dict = *curr_dec_dict | (unsigned int)(1 << curr_dec_bit);

              curr_dec_bit = curr_dec_bit + 1u;
              if(curr_dec_bit == 32u)
              {
                curr_dec_bit = (unsigned int)0;
                curr_dec_dict = curr_dec_dict + 1l;
                curr_dec_word = curr_dec_word + 1u;
                if(curr_dec_word == num_sections)
                  goto iloop;

              }

            }
          }
          while((_Bool)1);

        iloop:
          ;
          i = i + (unsigned int)0;
        }
        goto bpcalc;
      }

      val_dict = (unsigned int *)pnt;
      num_dict_words = num_dict_entries * num_sections;
      pnt = (char *)(val_dict + (signed long int)num_dict_words);

    bpcalc:
      ;
      num_bitplanes = (unsigned int)((unsigned char *)pnt)[(signed long int)0] + (unsigned int)1;
      pnt = pnt + 1l;
      b->multi_state = (unsigned int)(num_bitplanes > (unsigned int)1);
      padskip = (unsigned long int)pnt & (unsigned long int)3;
      pnt = pnt + (signed long int)(padskip != 0ul ? (unsigned long int)4 - padskip : (unsigned long int)0);
      b->vindex = (unsigned int *)pnt;
      signed int return_value_is_big_endian_5;
      return_value_is_big_endian_5=is_big_endian();
      if(!(return_value_is_big_endian_5 == 0))
      {
        if(b->rle == 0u)
        {
          i = (unsigned int)0;
          for( ; !(i >= num_dict_words); i = i + 1u)
            val_dict[(signed long int)i]=vzt_rd_get_32r((void *)(val_dict + (signed long int)i), 0);
        }

        val_tmp = b->vindex;
        i = (unsigned int)0;
        for( ; !(i >= num_bitplanes); i = i + 1u)
        {
          j = (unsigned int)0;
          for( ; !(j >= lt->total_values); j = j + 1u)
          {
            *val_tmp=vzt_rd_get_32r((void *)val_tmp, 0);
            val_tmp = val_tmp + 1l;
          }
        }
      }

      pnt = (char *)(b->vindex + (signed long int)(num_bitplanes * lt->total_values));
      b->num_str_entries=vzt_rd_get_v32(&pnt);
      if(!(b->num_str_entries == 0u))
      {
        void *return_value_calloc_6;
        return_value_calloc_6=calloc((unsigned long int)b->num_str_entries, sizeof(char *) /*8ul*/ );
        b->sindex = (char **)return_value_calloc_6;
        i = (unsigned int)0;
        for( ; !(i >= b->num_str_entries); i = i + 1u)
        {
          b->sindex[(signed long int)i] = pnt;
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(pnt);
          pnt = pnt + (signed long int)(return_value_strlen_7 + (unsigned long int)1);
        }
      }

      num_dict_words = (unsigned int)((unsigned long int)(num_sections * num_dict_entries) * sizeof(unsigned int) /*4ul*/ );
      void *return_value_malloc_8;
      return_value_malloc_8=malloc(num_dict_words != 0u ? (unsigned long int)num_dict_words : sizeof(unsigned int) /*4ul*/ );
      change_dict = (unsigned int *)return_value_malloc_8;
      m = (unsigned int)0;
      i = (unsigned int)0;
      for( ; !(i >= num_dict_entries); i = i + 1u)
      {
        unsigned int pbit = (unsigned int)0;
        j = (unsigned int)0;
        for( ; !(j >= num_sections); j = j + 1u)
        {
          unsigned int k = val_dict[(signed long int)m];
          unsigned int l = k ^ k << 1 ^ pbit;
          tmp_post_9 = m;
          m = m + 1u;
          change_dict[(signed long int)tmp_post_9] = l;
          pbit = k >> 31;
        }
      }
      b->val_dict = val_dict;
      b->change_dict = change_dict;
      b->times = times;
      b->num_time_ticks = num_time_ticks;
      b->num_dict_entries = num_dict_entries;
      b->num_sections = num_sections;
    }

  }

  vzt_rd_pthread_mutex_unlock(lt, &b->mutex);
}

// vzt_rd_block_vch_free
// file ./../../src/helpers/vzt_read.c line 475
static signed int vzt_rd_block_vch_free(struct vzt_rd_trace *lt, struct vzt_rd_block *b, signed int killed)
{
  vzt_rd_pthread_mutex_lock(lt, &b->mutex);
  if(!(killed == 0))
    b->killed = (unsigned int)killed;

  if(!(b->rle == 0u))
  {
    if(!(b->val_dict == ((unsigned int *)NULL)))
    {
      free((void *)b->val_dict);
      b->val_dict = (unsigned int *)(void *)0;
      vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
      lt->block_mem_consumed = lt->block_mem_consumed - (unsigned long int)b->num_rle_bytes;
      vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
    }

  }

  if(!(b->mem == ((char *)NULL)))
  {
    free((void *)b->mem);
    b->mem = (char *)(void *)0;
  }

  if(!(b->change_dict == ((unsigned int *)NULL)))
  {
    free((void *)b->change_dict);
    b->change_dict = (unsigned int *)(void *)0;
  }

  if(!(b->times == ((unsigned long int *)NULL)))
  {
    free((void *)b->times);
    b->times = (unsigned long int *)(void *)0;
  }

  if(!(b->sindex == ((char **)NULL)))
  {
    free((void *)b->sindex);
    b->sindex = (char **)(void *)0;
  }

  vzt_rd_pthread_mutex_unlock(lt, &b->mutex);
  return 1;
}

// vzt_rd_close
// file ./../../src/helpers/vzt_read.c line 2204
void vzt_rd_close(struct vzt_rd_trace *lt)
{
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
  {
    struct vzt_rd_block *b;
    struct vzt_rd_block *bt;
    if(!(lt->process_mask == ((char *)NULL)))
    {
      free((void *)lt->process_mask);
      lt->process_mask = (char *)(void *)0;
    }

    if(!(lt->rows == ((unsigned int *)NULL)))
    {
      free((void *)lt->rows);
      lt->rows = (unsigned int *)(void *)0;
    }

    if(!(lt->msb == ((signed int *)NULL)))
    {
      free((void *)lt->msb);
      lt->msb = (signed int *)(void *)0;
    }

    if(!(lt->lsb == ((signed int *)NULL)))
    {
      free((void *)lt->lsb);
      lt->lsb = (signed int *)(void *)0;
    }

    if(!(lt->flags == ((unsigned int *)NULL)))
    {
      free((void *)lt->flags);
      lt->flags = (unsigned int *)(void *)0;
    }

    if(!(lt->len == ((unsigned int *)NULL)))
    {
      free((void *)lt->len);
      lt->len = (unsigned int *)(void *)0;
    }

    if(!(lt->vindex_offset == ((unsigned int *)NULL)))
    {
      free((void *)lt->vindex_offset);
      lt->vindex_offset = (unsigned int *)(void *)0;
    }

    if(!(lt->zfacnames == ((char *)NULL)))
    {
      free((void *)lt->zfacnames);
      lt->zfacnames = (char *)(void *)0;
    }

    if(!(lt->value_current_sector == ((char *)NULL)))
    {
      free((void *)lt->value_current_sector);
      lt->value_current_sector = (char *)(void *)0;
    }

    if(!(lt->value_previous_sector == ((char *)NULL)))
    {
      free((void *)lt->value_previous_sector);
      lt->value_previous_sector = (char *)(void *)0;
    }

    if(!(lt->faccache == ((struct vzt_rd_facname_cache *)NULL)))
    {
      if(!(lt->faccache->bufprev == ((char *)NULL)))
      {
        free((void *)lt->faccache->bufprev);
        lt->faccache->bufprev = (char *)(void *)0;
      }

      if(!(lt->faccache->bufcurr == ((char *)NULL)))
      {
        free((void *)lt->faccache->bufcurr);
        lt->faccache->bufcurr = (char *)(void *)0;
      }

      free((void *)lt->faccache);
      lt->faccache = (struct vzt_rd_facname_cache *)(void *)0;
    }

    b = lt->block_head;
    for( ; !(b == ((struct vzt_rd_block *)NULL)); b = bt)
    {
      bt = b->next;
      vzt_rd_block_vch_free(lt, b, 1);
      vzt_rd_pthread_mutex_destroy(lt, &b->mutex);
      free((void *)b);
    }
    lt->block_curr = (struct vzt_rd_block *)(void *)0;
    lt->block_head = lt->block_curr;
    if(!(lt->zhandle == NULL))
    {
      gzclose((struct gzFile_s *)lt->zhandle);
      lt->zhandle = (void *)0;
    }

    if(!(lt->handle == ((struct _IO_FILE *)NULL)))
    {
      fclose(lt->handle);
      lt->handle = (struct _IO_FILE *)(void *)0;
    }

    if(!(lt->filename == ((char *)NULL)))
    {
      free((void *)lt->filename);
      lt->filename = (char *)(void *)0;
    }

    vzt_rd_pthread_mutex_destroy(lt, &lt->mutex);
    free((void *)lt);
  }

}

// vzt_rd_decompress_blk
// file ./../../src/helpers/vzt_read.c line 1363
static void vzt_rd_decompress_blk(struct vzt_rd_trace *lt, struct vzt_rd_block *b, signed int reopen)
{
  unsigned int rc;
  void *zhandle;
  struct _IO_FILE *handle;
  if(!(reopen == 0))
    handle=fopen(lt->filename, "rb");

  else
    handle = lt->handle;
  fseeko(handle, b->filepos, 0);
  vzt_rd_pthread_mutex_lock(lt, &b->mutex);
  signed int return_value_fileno_2;
  signed int return_value_dup_3;
  struct gzFile_s *return_value_gzdopen_4;
  signed int return_value_gzread_5;
  signed int return_value_fileno_6;
  signed int return_value_dup_7;
  signed int return_value_BZ2_bzread_8;
  signed int return_value_fileno_9;
  signed int return_value_dup_10;
  unsigned long int return_value_LZMA_read_11;
  if(b->killed == 0u)
  {
    if(b->mem == ((char *)NULL))
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)b->uncompressed_siz);
      b->mem = (char *)return_value_malloc_1;
      switch((signed int)b->ztype)
      {
        case 0:
        {
          return_value_fileno_2=fileno(handle);
          return_value_dup_3=dup(return_value_fileno_2);
          return_value_gzdopen_4=gzdopen(return_value_dup_3, "rb");
          zhandle = (void *)return_value_gzdopen_4;
          return_value_gzread_5=gzread((struct gzFile_s *)zhandle, (void *)b->mem, b->uncompressed_siz);
          rc = (unsigned int)return_value_gzread_5;
          gzclose((struct gzFile_s *)zhandle);
          break;
        }
        case 1:
        {
          return_value_fileno_6=fileno(handle);
          return_value_dup_7=dup(return_value_fileno_6);
          zhandle=BZ2_bzdopen(return_value_dup_7, "rb");
          return_value_BZ2_bzread_8=BZ2_bzread(zhandle, (void *)b->mem, (signed int)b->uncompressed_siz);
          rc = (unsigned int)return_value_BZ2_bzread_8;
          BZ2_bzclose(zhandle);
          break;
        }
        case 2:

        default:
        {
          return_value_fileno_9=fileno(handle);
          return_value_dup_10=dup(return_value_fileno_9);
          zhandle=LZMA_fdopen(return_value_dup_10, "rb");
          return_value_LZMA_read_11=LZMA_read(zhandle, (void *)b->mem, (unsigned long int)b->uncompressed_siz);
          rc = (unsigned int)return_value_LZMA_read_11;
          LZMA_close(zhandle);
        }
      }
      if(!(rc == b->uncompressed_siz))
      {
        fprintf(stderr, "VZTLOAD | short read on block %p %d vs %d (exp), ignoring\n", (void *)b, rc, b->uncompressed_siz);
        free((void *)b->mem);
        b->mem = (char *)(void *)0;
        b->short_read_ignore = (unsigned int)1;
      }

      else
      {
        vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
        lt->block_mem_consumed = lt->block_mem_consumed + (unsigned long int)b->uncompressed_siz;
        vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
      }
    }

  }

  vzt_rd_pthread_mutex_unlock(lt, &b->mutex);
  if(!(reopen == 0))
    fclose(handle);

}

// vzt_rd_decompress_blk_pth
// file ./../../src/helpers/vzt_read.c line 1438
static void vzt_rd_decompress_blk_pth(struct vzt_rd_trace *lt, struct vzt_rd_block *b)
{
  struct vzt_pth_args *vpa;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct vzt_pth_args) /*16ul*/ );
  vpa = (struct vzt_pth_args *)return_value_malloc_1;
  vpa->lt = lt;
  vpa->b = b;
  vzt_rd_pthread_create(lt, &b->pth, &b->pth_attr, vzt_rd_decompress_blk_pth_actual, (void *)vpa);
}

// vzt_rd_decompress_blk_pth_actual
// file ./../../src/helpers/vzt_read.c line 1428
static void * vzt_rd_decompress_blk_pth_actual(void *args)
{
  struct vzt_pth_args *vpa = (struct vzt_pth_args *)args;
  vzt_rd_decompress_blk(vpa->lt, vpa->b, 1);
  vzt_rd_block_vch_decode(vpa->lt, vpa->b);
  free((void *)vpa);
  return (void *)0;
}

// vzt_rd_det_gzip_type
// file ./../../src/helpers/vzt_read.c line 1340
static signed int vzt_rd_det_gzip_type(struct _IO_FILE *handle)
{
  unsigned char cbuf[2l] = { (unsigned char)0, (unsigned char)0 };
  signed long int off;
  off=ftello(handle);
  unsigned long int return_value_fread_1;
  return_value_fread_1=fread((void *)cbuf, (unsigned long int)1, (unsigned long int)2, handle);
  if(return_value_fread_1 == 0ul)
  {
    cbuf[(signed long int)1] = (unsigned char)0;
    cbuf[(signed long int)0] = cbuf[(signed long int)1];
  }

  fseeko(handle, off, 0);
  if((signed int)cbuf[0l] == 0x1f)
  {
    if(!((signed int)cbuf[1l] == 0x8b))
      goto __CPROVER_DUMP_L2;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if((signed int)cbuf[0l] == 122)
    {
      if(!((signed int)cbuf[1l] == 55))
        goto __CPROVER_DUMP_L3;

      return 2;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      return 1;
    }
  }
}

// vzt_rd_double_xdr
// file ./../../src/helpers/vzt_read.c line 673
static void vzt_rd_double_xdr(char *pnt, char *buf)
{
  signed int j;
  struct XDR x;
  double d;
  char xdrdata[8l] = { (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0 };
  j = 0;
  for( ; !(j >= 64); j = j + 1)
  {
    signed int byte = j / 8;
    signed int bit = 7 - (j & 7);
    if((signed int)pnt[(signed long int)j] == 49)
      xdrdata[(signed long int)byte] = xdrdata[(signed long int)byte] | (char)(1 << bit);

    else
      xdrdata[(signed long int)byte] = xdrdata[(signed long int)byte] & (char)~(1 << bit);
  }
  xdrmem_create(&x, xdrdata, (unsigned int)sizeof(char [8l]) /*8ul*/ , (enum xdr_op)XDR_DECODE);
  xdr_double(&x, &d);
  sprintf(buf, "%.16g", d);
}

// vzt_rd_expand_bits_to_integer
// file ./../../src/helpers/vzt_read.c line 287
unsigned int vzt_rd_expand_bits_to_integer(signed int len, char *s)
{
  unsigned int v = (unsigned int)0;
  signed int i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    v = v << 1;
    v = v | (unsigned int)((signed int)*s & 1);
    s = s + 1l;
  }
  return v;
}

// vzt_rd_fac_value
// file ./../../src/helpers/vzt_read.c line 589
signed int vzt_rd_fac_value(struct vzt_rd_trace *lt, struct vzt_rd_block *b, unsigned int time_offset, unsigned int facidx, char *value)
{
  unsigned int len = lt->len[(signed long int)facidx];
  unsigned int i;
  signed int word = (signed int)(time_offset / (unsigned int)32);
  signed int bit = (signed int)(time_offset & (unsigned int)31);
  signed int row_size = (signed int)b->num_sections;
  unsigned int *valpnt;
  unsigned int *val_base;
  _Bool tmp_if_expr_1;
  if(!(b->num_time_ticks >= time_offset))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = facidx > lt->numrealfacs ? (_Bool)1 : (_Bool)0;
  unsigned int tmp_post_2;
  unsigned int tmp_post_3;
  unsigned int tmp_post_4;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    val_base = b->val_dict + (signed long int)word;
    if((131072u & lt->flags[(signed long int)facidx]) == 0u)
    {
      unsigned int vzt_rd_fac_value__1__1__vindex_offset = lt->vindex_offset[(signed long int)facidx];
      if(!(b->multi_state == 0u))
      {
        unsigned int vzt_rd_fac_value__1__1__1__vindex_offset_x = vzt_rd_fac_value__1__1__vindex_offset + lt->total_values;
        unsigned int *vzt_rd_fac_value__1__1__1__valpnt_x;
        signed int vzt_rd_fac_value__1__1__1__which;
        i = (unsigned int)0;
        for( ; !(i >= len); i = i + 1u)
        {
          tmp_post_2 = vzt_rd_fac_value__1__1__vindex_offset;
          vzt_rd_fac_value__1__1__vindex_offset = vzt_rd_fac_value__1__1__vindex_offset + 1u;
          valpnt = val_base + (signed long int)(b->vindex[(signed long int)tmp_post_2] * (unsigned int)row_size);
          tmp_post_3 = vzt_rd_fac_value__1__1__1__vindex_offset_x;
          vzt_rd_fac_value__1__1__1__vindex_offset_x = vzt_rd_fac_value__1__1__1__vindex_offset_x + 1u;
          vzt_rd_fac_value__1__1__1__valpnt_x = val_base + (signed long int)(b->vindex[(signed long int)tmp_post_3] * (unsigned int)row_size);
          vzt_rd_fac_value__1__1__1__which = (signed int)((*vzt_rd_fac_value__1__1__1__valpnt_x >> bit & (unsigned int)1) << 1 | *valpnt >> bit & (unsigned int)1);
          value[(signed long int)i] = "01xz"[(signed long int)vzt_rd_fac_value__1__1__1__which];
        }
      }

      else
      {
        i = (unsigned int)0;
        for( ; !(i >= len); i = i + 1u)
        {
          tmp_post_4 = vzt_rd_fac_value__1__1__vindex_offset;
          vzt_rd_fac_value__1__1__vindex_offset = vzt_rd_fac_value__1__1__vindex_offset + 1u;
          valpnt = val_base + (signed long int)(b->vindex[(signed long int)tmp_post_4] * (unsigned int)row_size);
          value[(signed long int)i] = (char)((unsigned int)48 | *valpnt >> bit & (unsigned int)1);
        }
      }
    }

    else
    {
      unsigned int vindex_offset;
      if(!(b->multi_state == 0u))
      {
        unsigned int vindex_offset_x;
        unsigned int *valpnt_x;
        signed int which;
        i = (unsigned int)0;
        for( ; !(i >= len); i = i + 1u)
        {
          if(i + facidx >= lt->numfacs)
            break;

          vindex_offset = lt->vindex_offset[(signed long int)(facidx + i)];
          vindex_offset_x = vindex_offset + lt->total_values;
          valpnt = val_base + (signed long int)(b->vindex[(signed long int)vindex_offset] * (unsigned int)row_size);
          valpnt_x = val_base + (signed long int)(b->vindex[(signed long int)vindex_offset_x] * (unsigned int)row_size);
          which = (signed int)((*valpnt_x >> bit & (unsigned int)1) << 1 | *valpnt >> bit & (unsigned int)1);
          value[(signed long int)i] = "01xz"[(signed long int)which];
        }
      }

      else
      {
        i = (unsigned int)0;
        for( ; !(i >= len); i = i + 1u)
        {
          if(i + facidx >= lt->numfacs)
            break;

          vindex_offset = lt->vindex_offset[(signed long int)(facidx + i)];
          valpnt = val_base + (signed long int)(b->vindex[(signed long int)vindex_offset] * (unsigned int)row_size);
          value[(signed long int)i] = (char)((unsigned int)48 | *valpnt >> bit & (unsigned int)1);
        }
      }
    }
    value[(signed long int)i] = (char)0;
    return 1;
  }
}

// vzt_rd_get_16
// file ./../../src/helpers/vzt_read.c line 135
static unsigned int vzt_rd_get_16(void *mm, signed int offset)
{
  unsigned char *nn = (unsigned char *)mm + (signed long int)offset;
  unsigned int m1;
  unsigned char *tmp_post_1 = nn;
  nn = nn + 1l;
  m1 = (unsigned int)*((unsigned char *)tmp_post_1);
  unsigned int m2 = (unsigned int)*((unsigned char *)nn);
  return m1 << 8 | m2;
}

// vzt_rd_get_32
// file ./../../src/helpers/vzt_read.c line 143
static unsigned int vzt_rd_get_32(void *mm, signed int offset)
{
  unsigned char *nn = (unsigned char *)mm + (signed long int)offset;
  unsigned int m1;
  unsigned char *tmp_post_1 = nn;
  nn = nn + 1l;
  m1 = (unsigned int)*((unsigned char *)tmp_post_1);
  unsigned int m2;
  unsigned char *tmp_post_2 = nn;
  nn = nn + 1l;
  m2 = (unsigned int)*((unsigned char *)tmp_post_2);
  unsigned int m3;
  unsigned char *tmp_post_3 = nn;
  nn = nn + 1l;
  m3 = (unsigned int)*((unsigned char *)tmp_post_3);
  unsigned int m4 = (unsigned int)*((unsigned char *)nn);
  return m1 << 24 | m2 << 16 | m3 << 8 | m4;
}

// vzt_rd_get_32r
// file ./../../src/helpers/vzt_read.c line 163
static unsigned int vzt_rd_get_32r(void *mm, signed int offset)
{
  unsigned char *nn = (unsigned char *)mm + (signed long int)offset;
  unsigned int m4;
  unsigned char *tmp_post_1 = nn;
  nn = nn + 1l;
  m4 = (unsigned int)*((unsigned char *)tmp_post_1);
  unsigned int m3;
  unsigned char *tmp_post_2 = nn;
  nn = nn + 1l;
  m3 = (unsigned int)*((unsigned char *)tmp_post_2);
  unsigned int m2;
  unsigned char *tmp_post_3 = nn;
  nn = nn + 1l;
  m2 = (unsigned int)*((unsigned char *)tmp_post_3);
  unsigned int m1 = (unsigned int)*((unsigned char *)nn);
  return m1 << 24 | m2 << 16 | m3 << 8 | m4;
}

// vzt_rd_get_64
// file ./../../src/helpers/vzt_read.c line 153
static unsigned long int vzt_rd_get_64(void *mm, signed int offset)
{
  unsigned int return_value_vzt_rd_get_32_1;
  return_value_vzt_rd_get_32_1=vzt_rd_get_32(mm, offset);
  unsigned int return_value_vzt_rd_get_32_2;
  return_value_vzt_rd_get_32_2=vzt_rd_get_32(mm, offset + 4);
  return (unsigned long int)return_value_vzt_rd_get_32_1 << 32 | (unsigned long int)return_value_vzt_rd_get_32_2;
}

// vzt_rd_get_alias_root_link1
// file ./../../src/helpers/vzt_read.c line 1060
static inline unsigned int vzt_rd_get_alias_root_link1(struct vzt_rd_trace *lt, unsigned int facidx)
{
  _Bool tmp_if_expr_1;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
    tmp_if_expr_1 = facidx < lt->numfacs ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    for( ; !((8u & lt->flags[(signed long int)facidx]) == 0u); facidx = lt->rows[(signed long int)facidx])
      ;
    return facidx;
  }

  else
    return ~((unsigned int)0);
}

// vzt_rd_get_block_mem_usage
// file ./../../src/helpers/vzt_read.c line 1293
unsigned long int vzt_rd_get_block_mem_usage(struct vzt_rd_trace *lt)
{
  unsigned long int mem;
  vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
  mem = lt->block_mem_consumed;
  vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
  return mem;
}

// vzt_rd_get_fac_geometry
// file ./../../src/helpers/vzt_read.c line 974
struct vzt_rd_geometry * vzt_rd_get_fac_geometry(struct vzt_rd_trace *lt, unsigned int facidx)
{
  _Bool tmp_if_expr_1;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
    tmp_if_expr_1 = facidx < lt->numfacs ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    lt->geometry.rows = lt->rows[(signed long int)facidx];
    lt->geometry.msb = lt->msb[(signed long int)facidx];
    lt->geometry.lsb = lt->lsb[(signed long int)facidx];
    lt->geometry.flags = lt->flags[(signed long int)facidx];
    lt->geometry.len = lt->len[(signed long int)facidx];
    return &lt->geometry;
  }

  else
    return (struct vzt_rd_geometry *)(void *)0;
}

// vzt_rd_get_facname
// file ../../src/helpers/vzt_read.h line 260
char * vzt_rd_get_facname(struct vzt_rd_trace *lt, unsigned int facidx)
{
  char *pnt;
  unsigned int clonecnt;
  unsigned int j;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
  {
    if(facidx == 1u + lt->faccache->old_facidx || facidx == 0u)
    {
      if(facidx == 0u)
      {
        lt->faccache->n = lt->zfacnames;
        lt->faccache->bufcurr[(signed long int)0] = (char)0;
        lt->faccache->bufprev[(signed long int)0] = (char)0;
      }

      if(!(facidx == lt->numfacs))
      {
        pnt = lt->faccache->bufcurr;
        lt->faccache->bufcurr = lt->faccache->bufprev;
        lt->faccache->bufprev = pnt;
        clonecnt=vzt_rd_get_16((void *)lt->faccache->n, 0);
        lt->faccache->n = lt->faccache->n + (signed long int)2;
        pnt = lt->faccache->bufcurr;
        j = (unsigned int)0;
        for( ; !(j >= clonecnt); j = j + 1u)
        {
          tmp_post_1 = pnt;
          pnt = pnt + 1l;
          *tmp_post_1 = lt->faccache->bufprev[(signed long int)j];
        }
        do
        {
          tmp_post_2 = pnt;
          pnt = pnt + 1l;
          tmp_post_3 = lt->faccache->n;
          lt->faccache->n = lt->faccache->n + 1l;
          *tmp_post_2 = (char)(unsigned int)((unsigned char *)tmp_post_3)[(signed long int)0];
          if(*tmp_post_2 == 0)
            break;

        }
        while((_Bool)1);
        lt->faccache->old_facidx = facidx;
        return lt->faccache->bufcurr;
      }

      else
        return (char *)(void *)0;
    }

    else
      if(!(facidx >= lt->numfacs))
      {
        signed int strt;
        if(facidx == lt->faccache->old_facidx)
          return lt->faccache->bufcurr;

        if(!(1u + lt->faccache->old_facidx >= facidx))
          strt = (signed int)(lt->faccache->old_facidx + (unsigned int)1);

        else
          strt = 0;
        j = (unsigned int)strt;
        for( ; !(j >= facidx); j = j + 1u)
          vzt_rd_get_facname(lt, j);
        char *return_value_vzt_rd_get_facname_4;
        return_value_vzt_rd_get_facname_4=vzt_rd_get_facname(lt, j);
        return return_value_vzt_rd_get_facname_4;
      }

  }

  return (char *)(void *)0;
}

// vzt_rd_get_num_active_blocks
// file ./../../src/helpers/vzt_read.c line 1316
unsigned int vzt_rd_get_num_active_blocks(struct vzt_rd_trace *lt)
{
  signed int blk = 0;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
  {
    struct vzt_rd_block *b = lt->block_head;
    for( ; !(b == ((struct vzt_rd_block *)NULL)); b = b->next)
      if(b->short_read_ignore == 0u)
      {
        if(b->exclude_block == 0u)
          blk = blk + 1;

      }

  }

  return (unsigned int)blk;
}

// vzt_rd_get_v32
// file ./../../src/helpers/vzt_read.c line 174
static unsigned int vzt_rd_get_v32(char **mmx)
{
  signed char *c;
  signed char *beg;
  unsigned int val;
  signed char **mm = (signed char **)mmx;
  c = *mm;
  beg = c;
  if((signed int)*c >= 0)
  {
    for( ; (signed int)*c >= 0; c = c + 1l)
      ;
    *mm = c + (signed long int)1;
    val = (unsigned int)((signed int)*c & 0x7f);
    do
    {
      val = val << 7;
      c = c - 1l;
      val = val | (unsigned int)*c;
    }
    while(!(c == beg));
  }

  else
  {
    *mm = c + (signed long int)1;
    val = (unsigned int)((signed int)*c & 0x7f);
  }
  return val;
}

// vzt_rd_get_v64
// file ./../../src/helpers/vzt_read.c line 205
static unsigned long int vzt_rd_get_v64(char **mmx)
{
  signed char *c;
  signed char *beg;
  unsigned long int val;
  signed char **mm = (signed char **)mmx;
  c = *mm;
  beg = c;
  if((signed int)*c >= 0)
  {
    for( ; (signed int)*c >= 0; c = c + 1l)
      ;
    *mm = c + (signed long int)1;
    val = (unsigned long int)((signed int)*c & 0x7f);
    do
    {
      val = val << 7;
      c = c - 1l;
      val = val | (unsigned long int)*c;
    }
    while(!(c == beg));
  }

  else
  {
    val = (unsigned long int)((signed int)*c & 0x7f);
    *mm = c + (signed long int)1;
  }
  return val;
}

// vzt_rd_init
// file ../../src/helpers/vzt_read.h line 250
struct vzt_rd_trace * vzt_rd_init(const char *name)
{
  struct vzt_rd_trace *return_value_vzt_rd_init_smp_1;
  return_value_vzt_rd_init_smp_1=vzt_rd_init_smp(name, (unsigned int)1);
  return return_value_vzt_rd_init_smp_1;
}

// vzt_rd_init_smp
// file ./../../src/helpers/vzt_read.c line 1675
struct vzt_rd_trace * vzt_rd_init_smp(const char *name, unsigned int num_cpus)
{
  struct vzt_rd_trace *lt;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct vzt_rd_trace) /*328ul*/ );
  lt = (struct vzt_rd_trace *)return_value_calloc_1;
  unsigned int i;
  unsigned int vindex_offset;
  lt->handle=fopen(name, "rb");
  unsigned int return_value_vzt_rd_get_16_81;
  unsigned int tmp_if_expr_6;
  unsigned int return_value_vzt_rd_get_32_5;
  unsigned int tmp_if_expr_8;
  unsigned int return_value_vzt_rd_get_32_7;
  unsigned int tmp_if_expr_10;
  unsigned int return_value_vzt_rd_get_32_9;
  unsigned long int tmp_if_expr_12;
  unsigned long int return_value_vzt_rd_get_64_11;
  unsigned int tmp_if_expr_14;
  unsigned int return_value_vzt_rd_get_32_13;
  unsigned int tmp_if_expr_16;
  unsigned int return_value_vzt_rd_get_32_15;
  unsigned int tmp_if_expr_18;
  unsigned int return_value_vzt_rd_get_32_17;
  unsigned int tmp_if_expr_20;
  unsigned int return_value_vzt_rd_get_32_19;
  unsigned int tmp_if_expr_22;
  unsigned int return_value_vzt_rd_get_32_21;
  signed int return_value_fileno_25;
  signed int return_value_dup_26;
  struct gzFile_s *return_value_gzdopen_27;
  void *return_value_malloc_28;
  signed int return_value_gzread_29;
  signed int return_value_fileno_30;
  signed int return_value_dup_31;
  void *return_value_malloc_32;
  signed int return_value_BZ2_bzread_33;
  signed int return_value_fileno_34;
  signed int return_value_dup_35;
  void *return_value_malloc_36;
  unsigned long int return_value_LZMA_read_37;
  signed int return_value_fileno_42;
  signed int return_value_dup_43;
  struct gzFile_s *return_value_gzdopen_44;
  void *return_value_malloc_45;
  signed int return_value_gzread_46;
  signed int return_value_fileno_47;
  signed int return_value_dup_48;
  void *return_value_malloc_49;
  signed int return_value_BZ2_bzread_50;
  signed int return_value_fileno_51;
  signed int return_value_dup_52;
  void *return_value_malloc_53;
  unsigned long int return_value_LZMA_read_54;
  unsigned int tmp_if_expr_65;
  unsigned int return_value_vzt_rd_get_alias_root_64;
  signed int tmp_if_expr_66;
  unsigned int tmp_if_expr_71;
  unsigned int return_value_vzt_rd_get_32_70;
  unsigned int tmp_if_expr_73;
  unsigned int return_value_vzt_rd_get_32_72;
  unsigned long int tmp_if_expr_75;
  unsigned long int return_value_vzt_rd_get_64_74;
  unsigned long int tmp_if_expr_77;
  unsigned long int return_value_vzt_rd_get_64_76;
  _Bool tmp_if_expr_79;
  _Bool tmp_if_expr_80;
  if(lt->handle == ((struct _IO_FILE *)NULL))
  {
    vzt_rd_close(lt);
    lt = (struct vzt_rd_trace *)(void *)0;
  }

  else
  {
    unsigned short int id = (unsigned short int)0;
    unsigned short int version = (unsigned short int)0;
    lt->filename=strdup(name);
    lt->block_mem_max = (unsigned long int)(64 * 1024 * 1024);
    if(!(num_cpus >= 1u))
      num_cpus = (unsigned int)1;

    if(num_cpus >= 9u)
      num_cpus = (unsigned int)8;

    lt->pthreads = num_cpus - (unsigned int)1;
    setvbuf(lt->handle, (char *)(void *)0, 2, (unsigned long int)0);
    unsigned long int return_value_fread_2;
    return_value_fread_2=fread((void *)&id, (unsigned long int)2, (unsigned long int)1, lt->handle);
    if(return_value_fread_2 == 0ul)
      id = (unsigned short int)0;

    unsigned long int return_value_fread_3;
    return_value_fread_3=fread((void *)&version, (unsigned long int)2, (unsigned long int)1, lt->handle);
    if(return_value_fread_3 == 0ul)
      id = (unsigned short int)0;

    unsigned long int return_value_fread_4;
    return_value_fread_4=fread((void *)&lt->granule_size, (unsigned long int)1, (unsigned long int)1, lt->handle);
    if(return_value_fread_4 == 0ul)
      id = (unsigned short int)0;

    unsigned int return_value_vzt_rd_get_16_82;
    return_value_vzt_rd_get_16_82=vzt_rd_get_16((void *)&id, 0);
    if(!(return_value_vzt_rd_get_16_82 == 22106u))
    {
      fprintf(stderr, "VZTLOAD | *** Not a vzt file ***\n");
      vzt_rd_close(lt);
      lt = (struct vzt_rd_trace *)(void *)0;
    }

    else
    {
      return_value_vzt_rd_get_16_81=vzt_rd_get_16((void *)&version, 0);
      version = (unsigned short int)return_value_vzt_rd_get_16_81;
      if((signed int)version >= 2)
      {
        fprintf(stderr, "VZTLOAD | *** Version %d vzt not supported ***\n", version);
        vzt_rd_close(lt);
        lt = (struct vzt_rd_trace *)(void *)0;
      }

      else
        if((signed int)lt->granule_size >= 33)
        {
          fprintf(stderr, "VZTLOAD | *** Granule size of %d (>%d) not supported ***\n", lt->granule_size, 32);
          vzt_rd_close(lt);
          lt = (struct vzt_rd_trace *)(void *)0;
        }

        else
        {
          unsigned long int rcf;
          unsigned int rc;
          char *m;
          signed long int pos;
          signed long int fend;
          unsigned int t;
          struct vzt_rd_block *b;
          vzt_rd_pthread_mutex_init(lt, &lt->mutex, (const union anonymous_58 *)(void *)0);
          rcf=fread((void *)&lt->numfacs, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_vzt_rd_get_32_5=vzt_rd_get_32((void *)&lt->numfacs, 0);
            tmp_if_expr_6 = return_value_vzt_rd_get_32_5;
          }

          else
            tmp_if_expr_6 = (unsigned int)0;
          lt->numfacs = tmp_if_expr_6;
          if(lt->numfacs == 0u)
          {
            unsigned int num_expansion_bytes;
            rcf=fread((void *)&num_expansion_bytes, (unsigned long int)4, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_vzt_rd_get_32_7=vzt_rd_get_32((void *)&num_expansion_bytes, 0);
              tmp_if_expr_8 = return_value_vzt_rd_get_32_7;
            }

            else
              tmp_if_expr_8 = (unsigned int)0;
            num_expansion_bytes = tmp_if_expr_8;
            rcf=fread((void *)&lt->numfacs, (unsigned long int)4, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_vzt_rd_get_32_9=vzt_rd_get_32((void *)&lt->numfacs, 0);
              tmp_if_expr_10 = return_value_vzt_rd_get_32_9;
            }

            else
              tmp_if_expr_10 = (unsigned int)0;
            lt->numfacs = tmp_if_expr_10;
            if(num_expansion_bytes >= 8u)
            {
              rcf=fread((void *)&lt->timezero, (unsigned long int)8, (unsigned long int)1, lt->handle);
              if(!(rcf == 0ul))
              {
                return_value_vzt_rd_get_64_11=vzt_rd_get_64((void *)&lt->timezero, 0);
                tmp_if_expr_12 = return_value_vzt_rd_get_64_11;
              }

              else
                tmp_if_expr_12 = (unsigned long int)0;
              lt->timezero = (signed long int)tmp_if_expr_12;
              if(num_expansion_bytes >= 9u)
                fseeko(lt->handle, (signed long int)(num_expansion_bytes - (unsigned int)8), 1);

            }

            else
              fseeko(lt->handle, (signed long int)num_expansion_bytes, 1);
          }

          rcf=fread((void *)&lt->numfacbytes, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_vzt_rd_get_32_13=vzt_rd_get_32((void *)&lt->numfacbytes, 0);
            tmp_if_expr_14 = return_value_vzt_rd_get_32_13;
          }

          else
            tmp_if_expr_14 = (unsigned int)0;
          lt->numfacbytes = tmp_if_expr_14;
          rcf=fread((void *)&lt->longestname, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_vzt_rd_get_32_15=vzt_rd_get_32((void *)&lt->longestname, 0);
            tmp_if_expr_16 = return_value_vzt_rd_get_32_15;
          }

          else
            tmp_if_expr_16 = (unsigned int)0;
          lt->longestname = tmp_if_expr_16;
          rcf=fread((void *)&lt->zfacnamesize, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_vzt_rd_get_32_17=vzt_rd_get_32((void *)&lt->zfacnamesize, 0);
            tmp_if_expr_18 = return_value_vzt_rd_get_32_17;
          }

          else
            tmp_if_expr_18 = (unsigned int)0;
          lt->zfacnamesize = tmp_if_expr_18;
          rcf=fread((void *)&lt->zfacname_predec_size, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_vzt_rd_get_32_19=vzt_rd_get_32((void *)&lt->zfacname_predec_size, 0);
            tmp_if_expr_20 = return_value_vzt_rd_get_32_19;
          }

          else
            tmp_if_expr_20 = (unsigned int)0;
          lt->zfacname_predec_size = tmp_if_expr_20;
          rcf=fread((void *)&lt->zfacgeometrysize, (unsigned long int)4, (unsigned long int)1, lt->handle);
          if(!(rcf == 0ul))
          {
            return_value_vzt_rd_get_32_21=vzt_rd_get_32((void *)&lt->zfacgeometrysize, 0);
            tmp_if_expr_22 = return_value_vzt_rd_get_32_21;
          }

          else
            tmp_if_expr_22 = (unsigned int)0;
          lt->zfacgeometrysize = tmp_if_expr_22;
          rcf=fread((void *)&lt->timescale, (unsigned long int)1, (unsigned long int)1, lt->handle);
          if(rcf == 0ul)
            lt->timescale = (unsigned char)0;

          fprintf(stderr, "VZTLOAD | %d facilities\n", lt->numfacs);
          pos=ftello(lt->handle);
          void *return_value_calloc_23;
          return_value_calloc_23=calloc((unsigned long int)1, (unsigned long int)(lt->numfacs / (unsigned int)8 + (unsigned int)1));
          lt->process_mask = (char *)return_value_calloc_23;
          signed int return_value_vzt_rd_det_gzip_type_24;
          return_value_vzt_rd_det_gzip_type_24=vzt_rd_det_gzip_type(lt->handle);
          switch(return_value_vzt_rd_det_gzip_type_24)
          {
            case 0:
            {
              return_value_fileno_25=fileno(lt->handle);
              return_value_dup_26=dup(return_value_fileno_25);
              return_value_gzdopen_27=gzdopen(return_value_dup_26, "rb");
              lt->zhandle = (void *)return_value_gzdopen_27;
              return_value_malloc_28=malloc((unsigned long int)lt->zfacname_predec_size);
              m = (char *)return_value_malloc_28;
              return_value_gzread_29=gzread((struct gzFile_s *)lt->zhandle, (void *)m, lt->zfacname_predec_size);
              rc = (unsigned int)return_value_gzread_29;
              gzclose((struct gzFile_s *)lt->zhandle);
              lt->zhandle = (void *)0;
              break;
            }
            case 1:
            {
              return_value_fileno_30=fileno(lt->handle);
              return_value_dup_31=dup(return_value_fileno_30);
              lt->zhandle=BZ2_bzdopen(return_value_dup_31, "rb");
              return_value_malloc_32=malloc((unsigned long int)lt->zfacname_predec_size);
              m = (char *)return_value_malloc_32;
              return_value_BZ2_bzread_33=BZ2_bzread(lt->zhandle, (void *)m, (signed int)lt->zfacname_predec_size);
              rc = (unsigned int)return_value_BZ2_bzread_33;
              BZ2_bzclose(lt->zhandle);
              lt->zhandle = (void *)0;
              break;
            }
            case 2:

            default:
            {
              return_value_fileno_34=fileno(lt->handle);
              return_value_dup_35=dup(return_value_fileno_34);
              lt->zhandle=LZMA_fdopen(return_value_dup_35, "rb");
              return_value_malloc_36=malloc((unsigned long int)lt->zfacname_predec_size);
              m = (char *)return_value_malloc_36;
              return_value_LZMA_read_37=LZMA_read(lt->zhandle, (void *)m, (unsigned long int)lt->zfacname_predec_size);
              rc = (unsigned int)return_value_LZMA_read_37;
              LZMA_close(lt->zhandle);
              lt->zhandle = (void *)0;
            }
          }
          if(!(rc == lt->zfacname_predec_size))
          {
            fprintf(stderr, "VZTLOAD | *** name section mangled %d (act) vs %d (exp)\n", rc, lt->zfacname_predec_size);
            free((void *)m);
            vzt_rd_close(lt);
            lt = (struct vzt_rd_trace *)(void *)0;
            return lt;
          }

          lt->zfacnames = m;
          void *return_value_calloc_38;
          return_value_calloc_38=calloc((unsigned long int)1, sizeof(struct vzt_rd_facname_cache) /*32ul*/ );
          lt->faccache = (struct vzt_rd_facname_cache *)return_value_calloc_38;
          lt->faccache->old_facidx = lt->numfacs;
          void *return_value_malloc_39;
          return_value_malloc_39=malloc((unsigned long int)(lt->longestname + (unsigned int)1));
          lt->faccache->bufcurr = (char *)return_value_malloc_39;
          void *return_value_malloc_40;
          return_value_malloc_40=malloc((unsigned long int)(lt->longestname + (unsigned int)1));
          lt->faccache->bufprev = (char *)return_value_malloc_40;
          pos = pos + (signed long int)lt->zfacnamesize;
          fseeko(lt->handle, pos, 0);
          signed int return_value_vzt_rd_det_gzip_type_41;
          return_value_vzt_rd_det_gzip_type_41=vzt_rd_det_gzip_type(lt->handle);
          switch(return_value_vzt_rd_det_gzip_type_41)
          {
            case 0:
            {
              return_value_fileno_42=fileno(lt->handle);
              return_value_dup_43=dup(return_value_fileno_42);
              return_value_gzdopen_44=gzdopen(return_value_dup_43, "rb");
              lt->zhandle = (void *)return_value_gzdopen_44;
              t = (unsigned int)((unsigned long int)(lt->numfacs * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ );
              return_value_malloc_45=malloc((unsigned long int)t);
              m = (char *)return_value_malloc_45;
              return_value_gzread_46=gzread((struct gzFile_s *)lt->zhandle, (void *)m, t);
              rc = (unsigned int)return_value_gzread_46;
              gzclose((struct gzFile_s *)lt->zhandle);
              lt->zhandle = (void *)0;
              break;
            }
            case 1:
            {
              return_value_fileno_47=fileno(lt->handle);
              return_value_dup_48=dup(return_value_fileno_47);
              lt->zhandle=BZ2_bzdopen(return_value_dup_48, "rb");
              t = (unsigned int)((unsigned long int)(lt->numfacs * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ );
              return_value_malloc_49=malloc((unsigned long int)t);
              m = (char *)return_value_malloc_49;
              return_value_BZ2_bzread_50=BZ2_bzread(lt->zhandle, (void *)m, (signed int)t);
              rc = (unsigned int)return_value_BZ2_bzread_50;
              BZ2_bzclose(lt->zhandle);
              lt->zhandle = (void *)0;
              break;
            }
            case 2:

            default:
            {
              return_value_fileno_51=fileno(lt->handle);
              return_value_dup_52=dup(return_value_fileno_51);
              lt->zhandle=LZMA_fdopen(return_value_dup_52, "rb");
              t = (unsigned int)((unsigned long int)(lt->numfacs * (unsigned int)4) * sizeof(unsigned int) /*4ul*/ );
              return_value_malloc_53=malloc((unsigned long int)t);
              m = (char *)return_value_malloc_53;
              return_value_LZMA_read_54=LZMA_read(lt->zhandle, (void *)m, (unsigned long int)t);
              rc = (unsigned int)return_value_LZMA_read_54;
              LZMA_close(lt->zhandle);
              lt->zhandle = (void *)0;
            }
          }
          if(!(rc == t))
          {
            fprintf(stderr, "VZTLOAD | *** geometry section mangled %d (act) vs %d (exp)\n", rc, t);
            free((void *)m);
            vzt_rd_close(lt);
            lt = (struct vzt_rd_trace *)(void *)0;
            return lt;
          }

          pos = pos + (signed long int)lt->zfacgeometrysize;
          void *return_value_malloc_55;
          return_value_malloc_55=malloc((unsigned long int)lt->numfacs * sizeof(unsigned int) /*4ul*/ );
          lt->rows = (unsigned int *)return_value_malloc_55;
          void *return_value_malloc_56;
          return_value_malloc_56=malloc((unsigned long int)lt->numfacs * sizeof(signed int) /*4ul*/ );
          lt->msb = (signed int *)return_value_malloc_56;
          void *return_value_malloc_57;
          return_value_malloc_57=malloc((unsigned long int)lt->numfacs * sizeof(signed int) /*4ul*/ );
          lt->lsb = (signed int *)return_value_malloc_57;
          void *return_value_malloc_58;
          return_value_malloc_58=malloc((unsigned long int)lt->numfacs * sizeof(unsigned int) /*4ul*/ );
          lt->flags = (unsigned int *)return_value_malloc_58;
          void *return_value_malloc_59;
          return_value_malloc_59=malloc((unsigned long int)lt->numfacs * sizeof(unsigned int) /*4ul*/ );
          lt->len = (unsigned int *)return_value_malloc_59;
          void *return_value_malloc_60;
          return_value_malloc_60=malloc((unsigned long int)lt->numfacs * sizeof(unsigned int) /*4ul*/ );
          lt->vindex_offset = (unsigned int *)return_value_malloc_60;
          lt->longest_len = (unsigned int)32;
          i = (unsigned int)0;
          for( ; !(i >= lt->numfacs); i = i + 1u)
          {
            signed int j;
            lt->rows[(signed long int)i]=vzt_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 0);
            unsigned int return_value_vzt_rd_get_32_61;
            return_value_vzt_rd_get_32_61=vzt_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 4);
            lt->msb[(signed long int)i] = (signed int)return_value_vzt_rd_get_32_61;
            unsigned int return_value_vzt_rd_get_32_62;
            return_value_vzt_rd_get_32_62=vzt_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 8);
            lt->lsb[(signed long int)i] = (signed int)return_value_vzt_rd_get_32_62;
            unsigned int return_value_vzt_rd_get_32_63;
            return_value_vzt_rd_get_32_63=vzt_rd_get_32((void *)(m + (signed long int)(i * (unsigned int)16)), 12);
            lt->flags[(signed long int)i] = return_value_vzt_rd_get_32_63 & (unsigned int)(0 | 1 << 0 | 1 << 1 | 1 << 2 | 1 << 2 | 1 << 3 | 1 << 4 | 1 << 5 | 1 << 6 | 1 << 0 | 1 << 7 | 1 << 0 | 1 << 8 | 1 << 9 | 1 << 10 | 1 << 11 | 1 << 12 | 1 << 13 | 1 << 14 | 1 << 15 | 1 << 16);
            if((8u & lt->flags[(signed long int)i]) == 0u)
              tmp_if_expr_65 = i;

            else
            {
              return_value_vzt_rd_get_alias_root_64=vzt_rd_get_alias_root_link1(lt, i);
              tmp_if_expr_65 = return_value_vzt_rd_get_alias_root_64;
            }
            j = (signed int)tmp_if_expr_65;
            if((7u & lt->flags[(signed long int)i]) == 0u)
            {
              if(lt->lsb[(signed long int)j] >= lt->msb[(signed long int)j])
                tmp_if_expr_66 = (lt->lsb[(signed long int)j] - lt->msb[(signed long int)j]) + 1;

              else
                tmp_if_expr_66 = (lt->msb[(signed long int)j] - lt->lsb[(signed long int)j]) + 1;
              lt->len[(signed long int)i] = (unsigned int)tmp_if_expr_66;
            }

            else
              lt->len[(signed long int)i] = (unsigned int)((lt->flags[(signed long int)j] & (unsigned int)(1 << 0 | 1 << 2)) != 0u ? 32 : 64);
            if(!(lt->longest_len >= lt->len[(signed long int)i]))
              lt->longest_len = lt->len[(signed long int)i];

          }
          vindex_offset = (unsigned int)0;
          lt->numrealfacs = (unsigned int)0;
          for( ; !(lt->numrealfacs >= lt->numfacs); lt->numrealfacs = lt->numrealfacs + 1u)
          {
            if(!((8u & lt->flags[(signed long int)lt->numrealfacs]) == 0u))
              break;

            lt->vindex_offset[(signed long int)lt->numrealfacs] = vindex_offset;
            vindex_offset = vindex_offset + lt->len[(signed long int)lt->numrealfacs];
          }
          lt->total_values = vindex_offset;
          fprintf(stderr, "VZTLOAD | Total value bits: %d\n", lt->total_values);
          if(!(lt->numfacs >= lt->numrealfacs))
            lt->numrealfacs = lt->numfacs;

          void *return_value_malloc_67;
          return_value_malloc_67=malloc((unsigned long int)(lt->longest_len + (unsigned int)1));
          lt->value_current_sector = (char *)return_value_malloc_67;
          void *return_value_malloc_68;
          return_value_malloc_68=malloc((unsigned long int)(lt->longest_len + (unsigned int)1));
          lt->value_previous_sector = (char *)return_value_malloc_68;
          free((void *)m);
          do
          {
            fseeko(lt->handle, 0L, 2);
            fend=ftello(lt->handle);
            if(pos >= fend)
              break;

            fseeko(lt->handle, pos, 0);
            void *return_value_calloc_69;
            return_value_calloc_69=calloc((unsigned long int)1, sizeof(struct vzt_rd_block) /*248ul*/ );
            b = (struct vzt_rd_block *)return_value_calloc_69;
            b->last_rd_value_idx = (unsigned int)~0;
            rcf=fread((void *)&b->uncompressed_siz, (unsigned long int)4, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_vzt_rd_get_32_70=vzt_rd_get_32((void *)&b->uncompressed_siz, 0);
              tmp_if_expr_71 = return_value_vzt_rd_get_32_70;
            }

            else
              tmp_if_expr_71 = (unsigned int)0;
            b->uncompressed_siz = tmp_if_expr_71;
            rcf=fread((void *)&b->compressed_siz, (unsigned long int)4, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_vzt_rd_get_32_72=vzt_rd_get_32((void *)&b->compressed_siz, 0);
              tmp_if_expr_73 = return_value_vzt_rd_get_32_72;
            }

            else
              tmp_if_expr_73 = (unsigned int)0;
            b->compressed_siz = tmp_if_expr_73;
            rcf=fread((void *)&b->start, (unsigned long int)8, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_vzt_rd_get_64_74=vzt_rd_get_64((void *)&b->start, 0);
              tmp_if_expr_75 = return_value_vzt_rd_get_64_74;
            }

            else
              tmp_if_expr_75 = (unsigned long int)0;
            b->start = tmp_if_expr_75;
            rcf=fread((void *)&b->end, (unsigned long int)8, (unsigned long int)1, lt->handle);
            if(!(rcf == 0ul))
            {
              return_value_vzt_rd_get_64_76=vzt_rd_get_64((void *)&b->end, 0);
              tmp_if_expr_77 = return_value_vzt_rd_get_64_76;
            }

            else
              tmp_if_expr_77 = (unsigned long int)0;
            b->end = tmp_if_expr_77;
            pos=ftello(lt->handle);
            b->rle = (unsigned int)(b->start > b->end);
            if(!((unsigned int)b->rle == 0u))
            {
              unsigned long int tb = b->start;
              b->start = b->end;
              b->end = tb;
            }

            signed int return_value_vzt_rd_det_gzip_type_78;
            return_value_vzt_rd_det_gzip_type_78=vzt_rd_det_gzip_type(lt->handle);
            b->ztype = (unsigned int)return_value_vzt_rd_det_gzip_type_78;
            if(pos >= fend)
            {
              free((void *)b);
              break;
            }

            b->filepos = pos;
            if(!(b->uncompressed_siz == 0u))
              tmp_if_expr_79 = b->compressed_siz != 0u ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_79 = (_Bool)0;
            if(tmp_if_expr_79)
              tmp_if_expr_80 = b->end != 0ul ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_80 = (_Bool)0;
            if(tmp_if_expr_80)
            {
              fseeko(lt->handle, (signed long int)b->compressed_siz, 1);
              lt->numblocks = lt->numblocks + 1u;
              if(lt->pthreads >= lt->numblocks)
              {
                vzt_rd_pthread_mutex_init(lt, &b->mutex, (const union anonymous_58 *)(void *)0);
                vzt_rd_decompress_blk_pth(lt, b);
              }

              if(!(lt->block_curr == ((struct vzt_rd_block *)NULL)))
              {
                b->prev = lt->block_curr;
                lt->block_curr->next = b;
                lt->block_curr = b;
                lt->end = b->end;
              }

              else
              {
                lt->block_curr = b;
                lt->block_head = lt->block_curr;
                lt->start = b->start;
                lt->end = b->end;
              }
            }

            else
            {
              free((void *)b);
              break;
            }
            pos = pos + (signed long int)b->compressed_siz;
          }
          while((_Bool)1);
          if(!(lt->numblocks == 0u))
          {
            fprintf(stderr, "VZTLOAD | Read %d block header%s OK\n", lt->numblocks, lt->numblocks != (unsigned int)1 ? "s" : "");
            fprintf(stderr, "VZTLOAD | [%ld] start time\n", lt->start);
            fprintf(stderr, "VZTLOAD | [%ld] end time\n", lt->end);
            fprintf(stderr, "VZTLOAD | \n");
            lt->value_change_callback = vzt_rd_null_callback;
          }

          else
          {
            vzt_rd_close(lt);
            lt = (struct vzt_rd_trace *)(void *)0;
          }
        }
    }
  }
  return lt;
}

// vzt_rd_iter_blocks
// file ./../../src/helpers/vzt_read.c line 1452
signed int vzt_rd_iter_blocks(struct vzt_rd_trace *lt, void (*value_change_callback)(struct vzt_rd_trace **, unsigned long int *, unsigned int *, char **), void *user_callback_data_pointer)
{
  struct vzt_rd_block *b;
  struct vzt_rd_block *bpre;
  signed int blk = 0;
  signed int blkfinal = 0;
  signed int processed = 0;
  struct vzt_rd_block *bcutoff = (struct vzt_rd_block *)(void *)0;
  struct vzt_rd_block *bfinal = (struct vzt_rd_block *)(void *)0;
  _Bool tmp_if_expr_1;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
  {
    lt->value_change_callback = value_change_callback != ((void (*)(struct vzt_rd_trace **, unsigned long int *, unsigned int *, char **))NULL) ? value_change_callback : vzt_rd_null_callback;
    lt->user_callback_data_pointer = user_callback_data_pointer;
    b = lt->block_head;
    blk = 0;
    for( ; !(b == ((struct vzt_rd_block *)NULL)); b = b->next)
    {
      if(b->mem == ((char *)NULL))
      {
        if(b->short_read_ignore == 0u)
        {
          if(b->exclude_block == 0u)
          {
            if(!(processed >= 5))
            {
              signed int gate;
              if(processed == 4)
                tmp_if_expr_1 = b->next != ((struct vzt_rd_block *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_1 = (_Bool)0;
              gate = (signed int)tmp_if_expr_1;
              fprintf(stderr, "VZTLOAD | block [%d] processing %ld / %ld%s\n", blk, b->start, b->end, gate != 0 ? " ..." : "");
              if(!(gate == 0))
                bcutoff = b;

            }

            processed = processed + 1;
            if(!(lt->pthreads == 0u))
            {
              signed int count = (signed int)lt->pthreads;
              bpre = b->next;
              for( ; !(bpre == ((struct vzt_rd_block *)NULL)); bpre = bpre->next)
                if(bpre->mem == ((char *)NULL))
                {
                  if(bpre->short_read_ignore == 0u)
                  {
                    if(bpre->exclude_block == 0u)
                    {
                      vzt_rd_decompress_blk_pth(lt, bpre);
                      count = count - 1;
                      if(count == 0)
                        break;

                    }

                  }

                }

            }

            vzt_rd_decompress_blk(lt, b, 0);
            bfinal = b;
            blkfinal = blk;
          }

        }

      }

      if(!(b->mem == ((char *)NULL)))
      {
        if(!(lt->process_linear == 0u))
          vzt_rd_process_block_linear(lt, b);

        else
          vzt_rd_process_block(lt, b);
        if(lt->numblocks >= 3u)
        {
          unsigned long int block_mem_consumed;
          vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
          block_mem_consumed = lt->block_mem_consumed;
          vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
          if(!(lt->block_mem_max >= block_mem_consumed))
          {
            if(!(b->prev == ((struct vzt_rd_block *)NULL)))
            {
              vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
              lt->block_mem_consumed = lt->block_mem_consumed - (unsigned long int)b->prev->uncompressed_siz;
              vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
              vzt_rd_block_vch_free(lt, b->prev, 0);
            }

          }

        }

      }

      blk = blk + 1;
    }
  }

  if(!(bcutoff == ((struct vzt_rd_block *)NULL)) && !(bfinal == bcutoff))
    fprintf(stderr, "VZTLOAD | block [%d] processed %ld / %ld\n", blkfinal, bfinal->start, bfinal->end);

  return blk;
}

// vzt_rd_limit_time_range
// file ./../../src/helpers/vzt_read.c line 1571
unsigned int vzt_rd_limit_time_range(struct vzt_rd_trace *lt, unsigned long int strt_time, unsigned long int end_time)
{
  unsigned long int tmp_time;
  signed int blk = 0;
  _Bool tmp_if_expr_1;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
  {
    struct vzt_rd_block *b = lt->block_head;
    struct vzt_rd_block *bprev = (struct vzt_rd_block *)(void *)0;
    signed int state = 0;
    if(!(end_time >= strt_time))
    {
      tmp_time = strt_time;
      strt_time = end_time;
      end_time = tmp_time;
    }

    for( ; !(b == ((struct vzt_rd_block *)NULL)); b = b->next)
    {
      switch(state)
      {
        case 0:
        {
          if(b->end >= strt_time)
          {
            state = 1;
            if(!(strt_time >= b->start))
            {
              if(!(bprev == ((struct vzt_rd_block *)NULL)))
              {
                bprev->exclude_block = (unsigned int)0;
                blk = blk + 1;
              }

            }

          }

          break;
        }
        case 1:
          if(!(end_time >= b->start))
            state = 2;

      }
      if(state == 1)
        tmp_if_expr_1 = !(b->short_read_ignore != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        b->exclude_block = (unsigned int)0;
        blk = blk + 1;
      }

      else
        b->exclude_block = (unsigned int)1;
      bprev = b;
    }
  }

  return (unsigned int)blk;
}

// vzt_rd_make_sindex
// file ./../../src/helpers/vzt_read.c line 720
static unsigned int vzt_rd_make_sindex(char *pnt)
{
  unsigned int spnt = (unsigned int)0;
  unsigned int bpos = (unsigned int)0;
  for( ; !(bpos >= 32u); bpos = bpos + 1u)
  {
    spnt = spnt << 1;
    spnt = spnt | (unsigned int)((signed int)pnt[(signed long int)bpos] & 1);
  }
  return spnt;
}

// vzt_rd_next_value_chg_time
// file ./../../src/helpers/vzt_read.c line 500
unsigned int vzt_rd_next_value_chg_time(struct vzt_rd_trace *lt, struct vzt_rd_block *b, unsigned int time_offset, unsigned int facidx)
{
  unsigned int i;
  unsigned int len = lt->len[(signed long int)facidx];
  unsigned int vindex_offset = lt->vindex_offset[(signed long int)facidx];
  unsigned int vindex_offset_x = vindex_offset + lt->total_values;
  unsigned int old_time_offset = time_offset;
  signed int word = (signed int)(time_offset / (unsigned int)32);
  signed int bit = (signed int)((time_offset & (unsigned int)31) + (unsigned int)1);
  signed int row_size = (signed int)b->num_sections;
  unsigned int *valpnt;
  unsigned int *valpnt_x;
  unsigned int change_msk;
  _Bool tmp_if_expr_1;
  if(time_offset >= b->num_time_ticks + 4294967295u)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = facidx > lt->numrealfacs ? (_Bool)1 : (_Bool)0;
  unsigned int tmp_if_expr_3;
  unsigned int return_value_vzt_rd_tzc_2;
  if(tmp_if_expr_1)
    return time_offset;

  else
  {
    time_offset = time_offset & (unsigned int)~31;
    for( ; !(word >= row_size); word = word + 1)
    {
      if(!(bit == 32))
      {
        change_msk = (unsigned int)0;
        if((131072u & lt->flags[(signed long int)facidx]) == 0u)
        {
          if(!(b->multi_state == 0u))
          {
            i = (unsigned int)0;
            for( ; !(i >= len); i = i + 1u)
            {
              valpnt = b->change_dict + (signed long int)(b->vindex[(signed long int)(vindex_offset + i)] * (unsigned int)row_size + (unsigned int)word);
              valpnt_x = b->change_dict + (signed long int)(b->vindex[(signed long int)(vindex_offset_x + i)] * (unsigned int)row_size + (unsigned int)word);
              change_msk = change_msk | *valpnt;
              change_msk = change_msk | *valpnt_x;
            }
          }

          else
          {
            i = (unsigned int)0;
            for( ; !(i >= len); i = i + 1u)
            {
              valpnt = b->change_dict + (signed long int)(b->vindex[(signed long int)(vindex_offset + i)] * (unsigned int)row_size + (unsigned int)word);
              change_msk = change_msk | *valpnt;
            }
          }
        }

        else
          if(!(b->multi_state == 0u))
          {
            i = (unsigned int)0;
            for( ; !(i >= len); i = i + 1u)
            {
              if(i + facidx >= lt->numfacs)
                break;

              vindex_offset = lt->vindex_offset[(signed long int)(facidx + i)];
              vindex_offset_x = vindex_offset + lt->total_values;
              valpnt = b->change_dict + (signed long int)(b->vindex[(signed long int)vindex_offset] * (unsigned int)row_size + (unsigned int)word);
              valpnt_x = b->change_dict + (signed long int)(b->vindex[(signed long int)vindex_offset_x] * (unsigned int)row_size + (unsigned int)word);
              change_msk = change_msk | *valpnt;
              change_msk = change_msk | *valpnt_x;
            }
          }

          else
          {
            i = (unsigned int)0;
            for( ; !(i >= len); i = i + 1u)
            {
              if(i + facidx >= lt->numfacs)
                break;

              vindex_offset = lt->vindex_offset[(signed long int)(facidx + i)];
              valpnt = b->change_dict + (signed long int)(b->vindex[(signed long int)vindex_offset] * (unsigned int)row_size + (unsigned int)word);
              change_msk = change_msk | *valpnt;
            }
          }
        change_msk = change_msk >> bit;
        if(!(change_msk == 0u))
        {
          if(!((1u & change_msk) == 0u))
            tmp_if_expr_3 = (unsigned int)0;

          else
          {
            return_value_vzt_rd_tzc_2=vzt_rd_tzc(change_msk);
            tmp_if_expr_3 = return_value_vzt_rd_tzc_2;
          }
          return tmp_if_expr_3 + time_offset + (unsigned int)bit;
        }

      }

      time_offset = time_offset + (unsigned int)32;
      bit = 0;
    }
    return old_time_offset;
  }
}

// vzt_rd_null_callback
// file ./../../src/helpers/vzt_read.c line 950
void vzt_rd_null_callback(struct vzt_rd_trace **lt, unsigned long int *pnt_time, unsigned int *pnt_facidx, char **pnt_value)
{
  (void)lt;
  (void)pnt_time;
  (void)pnt_facidx;
  (void)pnt_value;
}

// vzt_rd_ones_cnt
// file ./../../src/helpers/vzt_read.c line 262
static inline unsigned int vzt_rd_ones_cnt(unsigned int x)
{
  x = x - (x >> 1 & (unsigned int)0x55555555);
  x = (x >> 2 & (unsigned int)0x33333333) + (x & (unsigned int)0x33333333);
  x = (x >> 4) + x & (unsigned int)0x0f0f0f0f;
  return x * (unsigned int)0x01010101 >> 24;
}

// vzt_rd_process_block
// file ./../../src/helpers/vzt_read.c line 805
signed int vzt_rd_process_block(struct vzt_rd_trace *lt, struct vzt_rd_block *b)
{
  unsigned int i;
  unsigned int i2;
  unsigned int idx;
  char *pnt = lt->value_current_sector;
  char *pnt2 = lt->value_previous_sector;
  char buf[32l];
  char *bufpnt;
  struct vzt_ncycle_autosort **autosort;
  struct vzt_ncycle_autosort *deadlist = (struct vzt_ncycle_autosort *)(void *)0;
  struct vzt_ncycle_autosort *autofacs;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)lt->numrealfacs, sizeof(struct vzt_ncycle_autosort) /*8ul*/ );
  autofacs = (struct vzt_ncycle_autosort *)return_value_calloc_1;
  vzt_rd_block_vch_decode(lt, b);
  vzt_rd_pthread_mutex_lock(lt, &b->mutex);
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)b->num_time_ticks, sizeof(struct vzt_ncycle_autosort *) /*8ul*/ );
  autosort = (struct vzt_ncycle_autosort **)return_value_calloc_2;
  i = (unsigned int)0;
  for( ; !(i >= b->num_time_ticks); i = i + 1u)
    autosort[(signed long int)i] = (struct vzt_ncycle_autosort *)(void *)0;
  deadlist = (struct vzt_ncycle_autosort *)(void *)0;
  idx = (unsigned int)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  char *tmp_if_expr_4;
  for( ; !(idx >= lt->numrealfacs); idx = idx + 1u)
  {
    signed int process_idx = (signed int)(idx / (unsigned int)8);
    signed int process_bit = (signed int)(idx & (unsigned int)7);
    if(!((1 << process_bit & (signed int)lt->process_mask[(signed long int)process_idx]) == 0))
    {
      i = (unsigned int)0;
      vzt_rd_fac_value(lt, b, i, idx, pnt);
      if(i == 0u)
        tmp_if_expr_5 = b->prev != ((struct vzt_rd_block *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = !(b->prev->exclude_block != 0u) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
      {
        vzt_rd_fac_value(lt, b->prev, b->prev->num_time_ticks - (unsigned int)1, idx, pnt2);
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(pnt, pnt2);
        if(!(return_value_strcmp_3 == 0))
          goto do_vch_0;

      }

      else
      {

      do_vch_0:
        ;
        if((6u & lt->flags[(signed long int)idx]) == 0u)
          lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &pnt);

        else
          if(!((2u & lt->flags[(signed long int)idx]) == 0u))
          {
            bufpnt = buf;
            vzt_rd_double_xdr(pnt, buf);
            lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &bufpnt);
          }

          else
          {
            unsigned int spnt;
            spnt=vzt_rd_make_sindex(pnt);
            char *msg;
            if(b->prev == ((struct vzt_rd_block *)NULL) && i == 0u)
              tmp_if_expr_4 = "UNDEF";

            else
              tmp_if_expr_4 = b->sindex[(signed long int)spnt];
            msg = tmp_if_expr_4;
            lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &msg);
          }
      }
      i2=vzt_rd_next_value_chg_time(lt, b, i, idx);
      if(!(i2 == 0u))
      {
        struct vzt_ncycle_autosort *t = autosort[(signed long int)i2];
        (autofacs + (signed long int)idx)->next = t;
        autosort[(signed long int)i2] = autofacs + (signed long int)idx;
      }

      else
      {
        struct vzt_ncycle_autosort *vzt_rd_process_block__1__2__1__1__4__t = deadlist;
        (autofacs + (signed long int)idx)->next = vzt_rd_process_block__1__2__1__1__4__t;
        deadlist = autofacs + (signed long int)idx;
      }
    }

  }
  i = (unsigned int)1;
  char *tmp_if_expr_7;
  for( ; !(i >= b->num_time_ticks); i = i + 1u)
  {
    struct vzt_ncycle_autosort *vzt_rd_process_block__1__3__1__t = autosort[(signed long int)i];
    if(!(vzt_rd_process_block__1__3__1__t == ((struct vzt_ncycle_autosort *)NULL)))
    {
      if(!(vzt_rd_process_block__1__3__1__t == ((struct vzt_ncycle_autosort *)NULL)))
      {
        struct vzt_ncycle_autosort *tn = vzt_rd_process_block__1__3__1__t->next;
        idx = (unsigned int)(vzt_rd_process_block__1__3__1__t - autofacs);
        vzt_rd_fac_value(lt, b, i, idx, pnt);
        if((6u & lt->flags[(signed long int)idx]) == 0u)
          lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &pnt);

        else
          if(!((2u & lt->flags[(signed long int)idx]) == 0u))
          {
            bufpnt = buf;
            vzt_rd_double_xdr(pnt, buf);
            lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &bufpnt);
          }

          else
          {
            unsigned int vzt_rd_process_block__1__3__1__1__1__2__2__spnt;
            vzt_rd_process_block__1__3__1__1__1__2__2__spnt=vzt_rd_make_sindex(pnt);
            char *vzt_rd_process_block__1__3__1__1__1__2__2__msg;
            if(b->prev == ((struct vzt_rd_block *)NULL) && i == 0u)
              tmp_if_expr_7 = "UNDEF";

            else
              tmp_if_expr_7 = b->sindex[(signed long int)vzt_rd_process_block__1__3__1__1__1__2__2__spnt];
            vzt_rd_process_block__1__3__1__1__1__2__2__msg = tmp_if_expr_7;
            lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &vzt_rd_process_block__1__3__1__1__1__2__2__msg);
          }
        i2=vzt_rd_next_value_chg_time(lt, b, i, idx);
        if(!(i2 == i))
        {
          struct vzt_ncycle_autosort *ta = autosort[(signed long int)i2];
          (autofacs + (signed long int)idx)->next = ta;
          autosort[(signed long int)i2] = autofacs + (signed long int)idx;
        }

        else
        {
          struct vzt_ncycle_autosort *vzt_rd_process_block__1__3__1__1__1__4__ta = deadlist;
          (autofacs + (signed long int)idx)->next = vzt_rd_process_block__1__3__1__1__1__4__ta;
          deadlist = autofacs + (signed long int)idx;
        }
        vzt_rd_process_block__1__3__1__t = tn;
      }

    }

  }
  vzt_rd_pthread_mutex_unlock(lt, &b->mutex);
  free((void *)autofacs);
  free((void *)autosort);
  return 1;
}

// vzt_rd_process_block_linear
// file ./../../src/helpers/vzt_read.c line 738
signed int vzt_rd_process_block_linear(struct vzt_rd_trace *lt, struct vzt_rd_block *b)
{
  signed int i;
  signed int i2;
  unsigned int idx;
  char *pnt = lt->value_current_sector;
  char *pnt2 = lt->value_previous_sector;
  char buf[32l];
  char *bufpnt;
  vzt_rd_block_vch_decode(lt, b);
  vzt_rd_pthread_mutex_lock(lt, &b->mutex);
  idx = (unsigned int)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  char *tmp_if_expr_2;
  for( ; !(idx >= lt->numrealfacs); idx = idx + 1u)
  {
    signed int process_idx = (signed int)(idx / (unsigned int)8);
    signed int process_bit = (signed int)(idx & (unsigned int)7);
    if(!((1 << process_bit & (signed int)lt->process_mask[(signed long int)process_idx]) == 0))
    {
      i = 0;
      do
      {
        vzt_rd_fac_value(lt, b, (unsigned int)i, idx, pnt);
        if(i == 0)
          tmp_if_expr_3 = b->prev != ((struct vzt_rd_block *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = !(b->prev->exclude_block != 0u) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          vzt_rd_fac_value(lt, b->prev, b->prev->num_time_ticks - (unsigned int)1, idx, pnt2);
          signed int return_value_strcmp_1;
          return_value_strcmp_1=strcmp(pnt, pnt2);
          if(!(return_value_strcmp_1 == 0))
            goto do_vch;

        }

        else
        {

        do_vch:
          ;
          if((6u & lt->flags[(signed long int)idx]) == 0u)
            lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &pnt);

          else
            if(!((2u & lt->flags[(signed long int)idx]) == 0u))
            {
              bufpnt = buf;
              vzt_rd_double_xdr(pnt, buf);
              lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &bufpnt);
            }

            else
            {
              unsigned int spnt;
              spnt=vzt_rd_make_sindex(pnt);
              char *msg;
              if(b->prev == ((struct vzt_rd_block *)NULL) && i == 0)
                tmp_if_expr_2 = "UNDEF";

              else
                tmp_if_expr_2 = b->sindex[(signed long int)spnt];
              msg = tmp_if_expr_2;
              lt->value_change_callback(&lt, &b->times[(signed long int)i], &idx, &msg);
            }
        }
        unsigned int return_value_vzt_rd_next_value_chg_time_5;
        return_value_vzt_rd_next_value_chg_time_5=vzt_rd_next_value_chg_time(lt, b, (unsigned int)i, idx);
        i2 = (signed int)return_value_vzt_rd_next_value_chg_time_5;
        if(i == i2)
          break;

        i = i2;
      }
      while((_Bool)1);
    }

  }
  vzt_rd_pthread_mutex_unlock(lt, &b->mutex);
  return 1;
}

// vzt_rd_process_block_single_factime
// file ./../../src/helpers/vzt_read.c line 2260
static char * vzt_rd_process_block_single_factime(struct vzt_rd_trace *lt, struct vzt_rd_block *b, unsigned long int simtime, unsigned int idx)
{
  unsigned int i;
  char *pnt = lt->value_current_sector;
  char *buf = lt->value_previous_sector;
  char *rcval = (char *)(void *)0;
  vzt_rd_block_vch_decode(lt, b);
  vzt_rd_pthread_mutex_lock(lt, &b->mutex);
  _Bool tmp_if_expr_1;
  if(b->last_rd_value_simtime == simtime)
    tmp_if_expr_1 = b->last_rd_value_idx != (unsigned int)~0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    i = b->last_rd_value_idx;

  else
  {
    signed int i_ok = 0;
    i = (unsigned int)0;
    for( ; !(i >= b->num_time_ticks); i = i + 1u)
    {
      if(simtime == b->times[(signed long int)i])
      {
        i_ok = (signed int)i;
        break;
      }

      if(!(simtime >= b->times[(signed long int)i]))
        break;

      i_ok = (signed int)i;
    }
    b->last_rd_value_idx = (unsigned int)i_ok;
    b->last_rd_value_simtime = simtime;
  }
  vzt_rd_fac_value(lt, b, i, idx, pnt);
  if((6u & lt->flags[(signed long int)idx]) == 0u)
    rcval = pnt;

  else
    if(!((2u & lt->flags[(signed long int)idx]) == 0u))
    {
      vzt_rd_double_xdr(pnt, buf);
      rcval = buf;
    }

    else
    {
      unsigned int spnt;
      spnt=vzt_rd_make_sindex(pnt);
      rcval = b->sindex[(signed long int)spnt];
    }
  vzt_rd_pthread_mutex_unlock(lt, &b->mutex);
  return rcval;
}

// vzt_rd_process_blocks_linearly
// file ./../../src/helpers/vzt_read.c line 1661
void vzt_rd_process_blocks_linearly(struct vzt_rd_trace *lt, signed int doit)
{
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
    lt->process_linear = (unsigned int)(doit != 0);

}

// vzt_rd_pthread_create
// file ./../../src/helpers/vzt_read.c line 95
static inline void vzt_rd_pthread_create(struct vzt_rd_trace *lt, unsigned long int *thread, union pthread_attr_t *attr, void * (*start_routine)(void *), void *arg)
{
  if(!(lt->pthreads == 0u))
  {
    pthread_attr_init(attr);
    pthread_attr_setdetachstate(attr, 1);
    pthread_create(thread, attr, start_routine, arg);
  }

}

// vzt_rd_pthread_mutex_destroy
// file ./../../src/helpers/vzt_read.c line 90
static inline void vzt_rd_pthread_mutex_destroy(struct vzt_rd_trace *lt, union anonymous_9 *mutex)
{
  if(!(lt->pthreads == 0u))
    pthread_mutex_destroy(mutex);

}

// vzt_rd_pthread_mutex_init
// file ./../../src/helpers/vzt_read.c line 74
static inline signed int vzt_rd_pthread_mutex_init(struct vzt_rd_trace *lt, union anonymous_9 *mutex, const union anonymous_58 *mutexattr)
{
  if(!(lt->pthreads == 0u))
    pthread_mutex_init(mutex, mutexattr);

  return 0;
}

// vzt_rd_pthread_mutex_lock
// file ./../../src/helpers/vzt_read.c line 80
static inline void vzt_rd_pthread_mutex_lock(struct vzt_rd_trace *lt, union anonymous_9 *mx)
{
  if(!(lt->pthreads == 0u))
    pthread_mutex_lock(mx);

}

// vzt_rd_pthread_mutex_unlock
// file ./../../src/helpers/vzt_read.c line 85
static inline void vzt_rd_pthread_mutex_unlock(struct vzt_rd_trace *lt, union anonymous_9 *mx)
{
  if(!(lt->pthreads == 0u))
    pthread_mutex_unlock(mx);

}

// vzt_rd_tzc
// file ./../../src/helpers/vzt_read.c line 277
static inline unsigned int vzt_rd_tzc(unsigned int x)
{
  unsigned int return_value_vzt_rd_ones_cnt_1;
  return_value_vzt_rd_ones_cnt_1=vzt_rd_ones_cnt((x & -x) - (unsigned int)1);
  return return_value_vzt_rd_ones_cnt_1;
}

// vzt_rd_unlimit_time_range
// file ./../../src/helpers/vzt_read.c line 1633
unsigned int vzt_rd_unlimit_time_range(struct vzt_rd_trace *lt)
{
  signed int blk = 0;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
  {
    struct vzt_rd_block *b = lt->block_head;
    for( ; !(b == ((struct vzt_rd_block *)NULL)); b = b->next)
    {
      b->exclude_block = (unsigned int)0;
      if(b->short_read_ignore == 0u)
        blk = blk + 1;

    }
  }

  return (unsigned int)blk;
}

// vzt_rd_value
// file ../../src/helpers/vzt_read.h line 292
char * vzt_rd_value(struct vzt_rd_trace *lt, unsigned long int simtime, unsigned int idx)
{
  struct vzt_rd_block *b;
  struct vzt_rd_block *b2;
  char *rcval = (char *)(void *)0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(lt == ((struct vzt_rd_trace *)NULL)))
  {
    b = lt->block_head;
    if(simtime == lt->last_rd_value_simtime)
      tmp_if_expr_1 = lt->last_rd_value_block != ((struct vzt_rd_block *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      b = lt->last_rd_value_block;
      goto b_chk;
    }

    else
      lt->last_rd_value_simtime = simtime;

  __CPROVER_DUMP_L4:
    ;
    if(!(b == ((struct vzt_rd_block *)NULL)))
    {
      if(!(simtime >= b->start))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = b->end < simtime ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        b = b->next;

      else
      {
        lt->last_rd_value_block = b;

      b_chk:
        ;
        if(b->mem == ((char *)NULL))
        {
          if(b->short_read_ignore == 0u)
            vzt_rd_decompress_blk(lt, b, 0);

        }

        if(!(b->mem == ((char *)NULL)))
        {
          rcval=vzt_rd_process_block_single_factime(lt, b, simtime, idx);
          goto __CPROVER_DUMP_L12;
        }

        b = b->next;
      }
      goto __CPROVER_DUMP_L4;
    }

  }

  else
    return (char *)(void *)0;

__CPROVER_DUMP_L12:
  ;
  if(!(b == ((struct vzt_rd_block *)NULL)))
  {
    if(lt->numblocks >= 3u)
    {
      unsigned long int block_mem_consumed;
      vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
      block_mem_consumed = lt->block_mem_consumed;
      vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
      if(!(lt->block_mem_max >= block_mem_consumed))
      {
        b2 = lt->block_head;
        for( ; !(b2 == ((struct vzt_rd_block *)NULL)); b2 = b2->next)
          if(!(lt->block_mem_max >= block_mem_consumed))
          {
            if(!(b2 == b))
            {
              vzt_rd_pthread_mutex_lock(lt, &lt->mutex);
              lt->block_mem_consumed = lt->block_mem_consumed - (unsigned long int)b2->uncompressed_siz;
              vzt_rd_pthread_mutex_unlock(lt, &lt->mutex);
              vzt_rd_block_vch_free(lt, b2, 0);
            }

          }

      }

    }

  }

  return rcval;
}

// vzt_rd_vectorize
// file ./../../src/helpers/vzt_read.c line 2005
void vzt_rd_vectorize(struct vzt_rd_trace *lt)
{
  _Bool tmp_if_expr_17;
  if(lt == ((struct vzt_rd_trace *)NULL))
    tmp_if_expr_17 = (_Bool)1;

  else
    tmp_if_expr_17 = lt->vectorize != 0u ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_18;
  if(tmp_if_expr_17)
    tmp_if_expr_18 = (_Bool)1;

  else
    tmp_if_expr_18 = lt->numfacs < (unsigned int)2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  signed int return_value_strcmp_6;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  unsigned int tmp_post_13;
  if(tmp_if_expr_18)
    goto __CPROVER_DUMP_L47;

  else
  {
    unsigned int old_longest_len = lt->longest_len;
    signed int pmxlen = 31;
    char *pbuff;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(pmxlen + 1));
    pbuff = (char *)return_value_malloc_1;
    char *pname;
    signed int plen;
    signed int plen2;
    unsigned int i;
    signed int pidx;
    signed int num_after_combine = (signed int)lt->numfacs;
    signed int num_synvecs = 0;
    signed int num_synalias = 0;
    struct vzt_synvec_chain **synvec_chain;
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)lt->numfacs, sizeof(struct vzt_synvec_chain *) /*8ul*/ );
    synvec_chain = (struct vzt_synvec_chain **)return_value_calloc_2;
    i = (unsigned int)0;
    for( ; !(i >= lt->numfacs + 4294967295u); i = i + 1u)
    {
      unsigned int j;
      if(lt->len[(signed long int)i] == 1u)
      {
        pname=vzt_rd_get_facname(lt, i);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(pname);
        plen = (signed int)return_value_strlen_3;
        if(!(pmxlen >= plen))
        {
          free((void *)pbuff);
          void *return_value_malloc_4;
          return_value_malloc_4=malloc((unsigned long int)(plen + 1));
          pbuff = (char *)return_value_malloc_4;
        }

        memcpy((void *)pbuff, (const void *)pname, (unsigned long int)plen);
        pbuff[(signed long int)plen] = (char)0;
        pidx = lt->msb[(signed long int)i];
        j = i + (unsigned int)1;
        for( ; !(j >= lt->numfacs + 4294967295u); j = j + 1u)
        {
          pname=vzt_rd_get_facname(lt, j);
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(pname);
          plen2 = (signed int)return_value_strlen_5;
          if(!(plen == plen2))
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_strcmp_6=strcmp(pbuff, pname);
            tmp_if_expr_7 = return_value_strcmp_6 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            tmp_if_expr_8 = (_Bool)1;

          else
            tmp_if_expr_8 = lt->len[(signed long int)j] != (unsigned int)1 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_8)
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            if(!(pidx == lt->msb[(signed long int)j] + -1))
              tmp_if_expr_9 = pidx != lt->msb[(signed long int)j] + 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_9 = (_Bool)0;
            tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
          {
            i = j - (unsigned int)1;
            break;
          }

          pidx = lt->msb[(signed long int)j];
          lt->len[(signed long int)i] = lt->len[(signed long int)i] + lt->len[(signed long int)j];
          lt->lsb[(signed long int)i] = lt->lsb[(signed long int)j];
          lt->len[(signed long int)j] = (unsigned int)0;
          num_after_combine = num_after_combine - 1;
          if(!(lt->longest_len >= lt->len[(signed long int)i]))
            lt->longest_len = lt->len[(signed long int)i];

        }
      }

    }
    free((void *)pbuff);
    i = lt->numrealfacs;
    for( ; !(i >= lt->numfacs); i = i + 1u)
    {
      if(!((8u & lt->flags[(signed long int)i]) == 0u))
      {
        unsigned int vzt_rd_vectorize__1__2__2__1__1__j;
        vzt_rd_vectorize__1__2__2__1__1__j=vzt_rd_get_alias_root_link1(lt, i);
        unsigned int k;
        unsigned int l;
        if(!(lt->len[(signed long int)i] == 0u))
        {
          if(lt->len[(signed long int)i] == 1u)
          {
            if(lt->len[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j] == 1u)
              goto __CPROVER_DUMP_L40;

          }

          if(lt->len[(signed long int)i] == lt->len[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j])
          {
            unsigned int nfm1 = lt->numfacs - (unsigned int)1;
            if(!(vzt_rd_vectorize__1__2__2__1__1__j == nfm1) && !(i == nfm1))
            {
              if(!(lt->len[(signed long int)(1u + i)] == 0u))
              {
                if(!(lt->len[(signed long int)(1u + vzt_rd_vectorize__1__2__2__1__1__j)] == 0u))
                  goto __CPROVER_DUMP_L40;

              }

            }

          }

          lt->vindex_offset[(signed long int)i] = lt->vindex_offset[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j];
          k = (unsigned int)1;
          for( ; !(k >= lt->len[(signed long int)i]); k = k + 1u)
            if(lt->numfacs + 4294967295u >= k + i)
            {
              unsigned int return_value_vzt_rd_get_alias_root_11;
              return_value_vzt_rd_get_alias_root_11=vzt_rd_get_alias_root_link1(lt, k + i);
              lt->vindex_offset[(signed long int)(k + i)] = lt->vindex_offset[(signed long int)return_value_vzt_rd_get_alias_root_11];
            }

          if(!(synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j] == ((struct vzt_synvec_chain *)NULL)))
          {
            signed int alias_found = 0;
            k = (unsigned int)0;
            for( ; !(k >= synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->num_entries); k = k + 1u)
            {
              unsigned int idx = synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->chain[(signed long int)k];
              if(lt->len[(signed long int)i] == lt->len[(signed long int)idx])
              {
                l = (unsigned int)0;
                for( ; !(l >= lt->len[(signed long int)i]); l = l + 1u)
                  if(lt->numfacs + 4294967295u >= idx + l)
                  {
                    if(!(lt->vindex_offset[(signed long int)(idx + l)] == lt->vindex_offset[(signed long int)(l + i)]))
                      break;

                  }

                if(l == lt->len[(signed long int)i])
                {
                  lt->rows[(signed long int)i] = idx;
                  num_synalias = num_synalias + 1;
                  alias_found = 1;
                  break;
                }

              }

            }
            if(alias_found == 0)
            {
              void *return_value_realloc_12;
              return_value_realloc_12=realloc((void *)synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j], sizeof(struct vzt_synvec_chain) /*8ul*/  + (unsigned long int)synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->num_entries * sizeof(unsigned int) /*4ul*/ );
              synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j] = (struct vzt_synvec_chain *)return_value_realloc_12;
              tmp_post_13 = synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->num_entries;
              synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->num_entries = synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->num_entries + 1u;
              synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->chain[(signed long int)tmp_post_13] = i;
              lt->flags[(signed long int)i] = lt->flags[(signed long int)i] | (unsigned int)(1 << 17);
              lt->flags[(signed long int)i] = lt->flags[(signed long int)i] & (unsigned int)~(1 << 3);
              lt->numrealfacs = i + (unsigned int)1;
              num_synvecs = num_synvecs + 1;
            }

          }

          else
          {
            void *return_value_malloc_14;
            return_value_malloc_14=malloc(sizeof(struct vzt_synvec_chain) /*8ul*/ );
            synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j] = (struct vzt_synvec_chain *)return_value_malloc_14;
            if(!(synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j] == ((struct vzt_synvec_chain *)NULL)))
            {
              synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->num_entries = (unsigned int)1;
              synvec_chain[(signed long int)vzt_rd_vectorize__1__2__2__1__1__j]->chain[(signed long int)0] = i;
            }

            lt->flags[(signed long int)i] = lt->flags[(signed long int)i] | (unsigned int)(1 << 17);
            lt->flags[(signed long int)i] = lt->flags[(signed long int)i] & (unsigned int)~(1 << 3);
            lt->numrealfacs = i + (unsigned int)1;
            num_synvecs = num_synvecs + 1;
          }
        }

      }


    __CPROVER_DUMP_L40:
      ;
    }
    i = (unsigned int)0;
    for( ; !(i >= lt->numfacs); i = i + 1u)
      if(!(synvec_chain[(signed long int)i] == ((struct vzt_synvec_chain *)NULL)))
        free((void *)synvec_chain[(signed long int)i]);

    free((void *)synvec_chain);
    fprintf(stderr, "VZTLOAD | %d facilities (after vectorization)\n", num_after_combine);
    if(!(num_synvecs == 0))
    {
      fprintf(stderr, "VZTLOAD | %d complex vectors synthesized\n", num_synvecs);
      if(!(num_synalias == 0))
        fprintf(stderr, "VZTLOAD | %d complex aliases synthesized\n", num_synalias);

    }

    fprintf(stderr, "VZTLOAD | \n");
    if(!(lt->longest_len == old_longest_len))
    {
      free((void *)lt->value_current_sector);
      free((void *)lt->value_previous_sector);
      void *return_value_malloc_15;
      return_value_malloc_15=malloc((unsigned long int)(lt->longest_len + (unsigned int)1));
      lt->value_current_sector = (char *)return_value_malloc_15;
      void *return_value_malloc_16;
      return_value_malloc_16=malloc((unsigned long int)(lt->longest_len + (unsigned int)1));
      lt->value_previous_sector = (char *)return_value_malloc_16;
    }

  }

__CPROVER_DUMP_L47:
  ;
}

// yy_create_buffer
// file vlex.c line 2447
struct yy_buffer_state * yy_create_buffer(struct _IO_FILE *file, signed int size)
{
  struct yy_buffer_state *b;
  void *return_value_yy_flex_alloc_1;
  return_value_yy_flex_alloc_1=yy_flex_alloc((unsigned int)sizeof(struct yy_buffer_state) /*56ul*/ );
  b = (struct yy_buffer_state *)return_value_yy_flex_alloc_1;
  if(b == ((struct yy_buffer_state *)NULL))
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = (unsigned int)size;
  void *return_value_yy_flex_alloc_2;
  return_value_yy_flex_alloc_2=yy_flex_alloc(b->yy_buf_size + (unsigned int)2);
  b->yy_ch_buf = (char *)return_value_yy_flex_alloc_2;
  if(b->yy_ch_buf == ((char *)NULL))
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;
  yy_init_buffer(b, file);
  return b;
}

// yy_delete_buffer
// file vlex.c line 2478
void yy_delete_buffer(struct yy_buffer_state *b)
{
  if(!(b == ((struct yy_buffer_state *)NULL)))
  {
    if(b == yy_current_buffer)
      yy_current_buffer = (struct yy_buffer_state *)0;

    if(!(b->yy_is_our_buffer == 0))
      yy_flex_free((void *)b->yy_ch_buf);

    yy_flex_free((void *)b);
  }

}

// yy_fatal_error
// file vlex.c line 2706
static void yy_fatal_error(const char *msg)
{
  fprintf(stderr, "%s\n", msg);
  exit(2);
}

// yy_flex_alloc
// file vlex.c line 2770
static void * yy_flex_alloc(unsigned int size)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)size);
  return (void *)return_value_malloc_1;
}

// yy_flex_free
// file vlex.c line 2798
static void yy_flex_free(void *ptr)
{
  free(ptr);
}

// yy_flex_realloc
// file vlex.c line 2780
static void * yy_flex_realloc(void *ptr, unsigned int size)
{
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)(char *)ptr, (unsigned long int)size);
  return (void *)return_value_realloc_1;
}

// yy_flush_buffer
// file vlex.c line 2526
void yy_flush_buffer(struct yy_buffer_state *b)
{
  if(!(b == ((struct yy_buffer_state *)NULL)))
  {
    b->yy_n_chars = 0;
    b->yy_ch_buf[(signed long int)0] = (char)0;
    b->yy_ch_buf[(signed long int)1] = (char)0;
    b->yy_buf_pos = &b->yy_ch_buf[(signed long int)0];
    b->yy_at_bol = 1;
    b->yy_buffer_status = 0;
    if(b == yy_current_buffer)
      yy_load_buffer_state();

  }

}

// yy_get_next_buffer
// file vlex.c line 2074
static signed int yy_get_next_buffer(void)
{
  char *dest = yy_current_buffer->yy_ch_buf;
  char *source = yytext;
  signed int number_to_move;
  signed int i;
  signed int ret_val;
  if(!(yy_current_buffer->yy_ch_buf + (signed long int)(1 + yy_n_chars) >= yy_c_buf_p))
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");

  char *tmp_post_1;
  char *tmp_post_2;
  if(yy_current_buffer->yy_fill_buffer == 0)
  {
    if(yy_c_buf_p - yytext == 1l)
      return 1;

    return 2;
  }

  else
  {
    number_to_move = (signed int)(yy_c_buf_p - yytext) - 1;
    i = 0;
    for( ; !(i >= number_to_move); i = i + 1)
    {
      tmp_post_1 = dest;
      dest = dest + 1l;
      tmp_post_2 = source;
      source = source + 1l;
      *tmp_post_1 = *tmp_post_2;
    }
    if(yy_current_buffer->yy_buffer_status == 2)
    {
      yy_n_chars = 0;
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }

    else
    {
      signed int num_to_read = (signed int)((yy_current_buffer->yy_buf_size - (unsigned int)number_to_move) - (unsigned int)1);
      while(!(num_to_read >= 1))
      {
        struct yy_buffer_state *b = yy_current_buffer;
        signed int yy_c_buf_p_offset = (signed int)(yy_c_buf_p - b->yy_ch_buf);
        if(!(b->yy_is_our_buffer == 0))
        {
          signed int new_size = (signed int)(b->yy_buf_size * (unsigned int)2);
          if(!(new_size >= 1))
            b->yy_buf_size = b->yy_buf_size + b->yy_buf_size / (unsigned int)8;

          else
            b->yy_buf_size = b->yy_buf_size * (unsigned int)2;
          void *return_value_yy_flex_realloc_3;
          return_value_yy_flex_realloc_3=yy_flex_realloc((void *)b->yy_ch_buf, b->yy_buf_size + (unsigned int)2);
          b->yy_ch_buf = (char *)return_value_yy_flex_realloc_3;
        }

        else
          b->yy_ch_buf = ((char *)NULL);
        if(b->yy_ch_buf == ((char *)NULL))
          yy_fatal_error("fatal error - scanner input buffer overflow");

        yy_c_buf_p = &b->yy_ch_buf[(signed long int)yy_c_buf_p_offset];
        num_to_read = (signed int)((yy_current_buffer->yy_buf_size - (unsigned int)number_to_move) - (unsigned int)1);
      }
      if(num_to_read >= 8193)
        num_to_read = 8192;

      yy_n_chars=v_preproc(&yy_current_buffer->yy_ch_buf[(signed long int)number_to_move], num_to_read);
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }
    if(yy_n_chars == 0)
    {
      if(number_to_move == 0)
      {
        ret_val = 1;
        yyrestart(yyin);
      }

      else
      {
        ret_val = 2;
        yy_current_buffer->yy_buffer_status = 2;
      }
    }

    else
      ret_val = 0;
    yy_n_chars = yy_n_chars + number_to_move;
    yy_current_buffer->yy_ch_buf[(signed long int)yy_n_chars] = (char)0;
    yy_current_buffer->yy_ch_buf[(signed long int)(yy_n_chars + 1)] = (char)0;
    yytext = &yy_current_buffer->yy_ch_buf[(signed long int)0];
    return ret_val;
  }
}

// yy_get_previous_state
// file vlex.c line 2206
static signed int yy_get_previous_state(void)
{
  signed int yy_current_state;
  char *yy_cp;
  yy_current_state = yy_start;
  yy_cp = yytext + (signed long int)0;
  signed int tmp_if_expr_1;
  for( ; !(yy_cp >= yy_c_buf_p); yy_cp = yy_cp + 1l)
  {
    unsigned char yy_c;
    if(!(*yy_cp == 0))
      tmp_if_expr_1 = yy_ec[(signed long int)(unsigned int)(unsigned char)*yy_cp];

    else
      tmp_if_expr_1 = 1;
    yy_c = (unsigned char)tmp_if_expr_1;
    if(!(yy_accept[(signed long int)yy_current_state] == 0))
    {
      yy_last_accepting_state = yy_current_state;
      yy_last_accepting_cpos = yy_cp;
    }

    while(!((signed int)yy_chk[(signed long int)((signed int)yy_base[(signed long int)yy_current_state] + (signed int)yy_c)] == yy_current_state))
    {
      yy_current_state = (signed int)yy_def[(signed long int)yy_current_state];
      if(yy_current_state >= 599)
        yy_c = (unsigned char)yy_meta[(signed long int)(unsigned int)yy_c];

    }
    yy_current_state = (signed int)yy_nxt[(signed long int)((unsigned int)yy_base[(signed long int)yy_current_state] + (unsigned int)yy_c)];
  }
  return yy_current_state;
}

// yy_init_buffer
// file vlex.c line 2499
void yy_init_buffer(struct yy_buffer_state *b, struct _IO_FILE *file)
{
  yy_flush_buffer(b);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  signed int tmp_if_expr_3;
  signed int return_value_fileno_1;
  signed int return_value_isatty_2;
  if(!(file == ((struct _IO_FILE *)NULL)))
  {
    return_value_fileno_1=fileno(file);
    return_value_isatty_2=isatty(return_value_fileno_1);
    tmp_if_expr_3 = (signed int)(return_value_isatty_2 > 0);
  }

  else
    tmp_if_expr_3 = 0;
  b->yy_is_interactive = tmp_if_expr_3;
}

// yy_load_buffer_state
// file vlex.c line 2434
void yy_load_buffer_state(void)
{
  yy_n_chars = yy_current_buffer->yy_n_chars;
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
  yytext = yy_c_buf_p;
  yyin = yy_current_buffer->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
}

// yy_scan_buffer
// file vlex.c line 2557
struct yy_buffer_state * yy_scan_buffer(char *base, unsigned int size)
{
  struct yy_buffer_state *b;
  _Bool tmp_if_expr_1;
  if(!(size >= 2u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)base[(signed long int)(size - (unsigned int)2)] != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)base[(signed long int)(size - (unsigned int)1)] != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return ((struct yy_buffer_state *)NULL);

  else
  {
    void *return_value_yy_flex_alloc_3;
    return_value_yy_flex_alloc_3=yy_flex_alloc((unsigned int)sizeof(struct yy_buffer_state) /*56ul*/ );
    b = (struct yy_buffer_state *)return_value_yy_flex_alloc_3;
    if(b == ((struct yy_buffer_state *)NULL))
      yy_fatal_error("out of dynamic memory in yy_scan_buffer()");

    b->yy_buf_size = size - (unsigned int)2;
    b->yy_ch_buf = base;
    b->yy_buf_pos = b->yy_ch_buf;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = ((struct _IO_FILE *)NULL);
    b->yy_n_chars = (signed int)b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = 0;
    yy_switch_to_buffer(b);
    return b;
  }
}

// yy_scan_bytes
// file vlex.c line 2612
struct yy_buffer_state * yy_scan_bytes(const char *bytes, signed int len)
{
  struct yy_buffer_state *b;
  char *buf;
  unsigned int n;
  signed int i;
  n = (unsigned int)(len + 2);
  void *return_value_yy_flex_alloc_1;
  return_value_yy_flex_alloc_1=yy_flex_alloc(n);
  buf = (char *)return_value_yy_flex_alloc_1;
  if(buf == ((char *)NULL))
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");

  i = 0;
  for( ; !(i >= len); i = i + 1)
    buf[(signed long int)i] = bytes[(signed long int)i];
  buf[(signed long int)(len + 1)] = (char)0;
  buf[(signed long int)len] = buf[(signed long int)(len + 1)];
  b=yy_scan_buffer(buf, n);
  if(b == ((struct yy_buffer_state *)NULL))
    yy_fatal_error("bad buffer in yy_scan_bytes()");

  b->yy_is_our_buffer = 1;
  return b;
}

// yy_scan_string
// file vlex.c line 2595
struct yy_buffer_state * yy_scan_string(const char *yy_str)
{
  signed int len = 0;
  for( ; !(yy_str[(signed long int)len] == 0); len = len + 1)
    ;
  struct yy_buffer_state *return_value_yy_scan_bytes_1;
  return_value_yy_scan_bytes_1=yy_scan_bytes(yy_str, len);
  return return_value_yy_scan_bytes_1;
}

// yy_switch_to_buffer
// file vlex.c line 2404
void yy_switch_to_buffer(struct yy_buffer_state *new_buffer)
{
  if(!(yy_current_buffer == new_buffer))
  {
    if(!(yy_current_buffer == ((struct yy_buffer_state *)NULL)))
    {
      *yy_c_buf_p = yy_hold_char;
      yy_current_buffer->yy_buf_pos = yy_c_buf_p;
      yy_current_buffer->yy_n_chars = yy_n_chars;
    }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();
    yy_did_buffer_switch_on_eof = 1;
  }

}

// yy_try_NUL_trans
// file vlex.c line 2241
static signed int yy_try_NUL_trans(signed int yy_current_state)
{
  signed int yy_is_jam;
  char *yy_cp = yy_c_buf_p;
  unsigned char yy_c = (unsigned char)1;
  if(!(yy_accept[(signed long int)yy_current_state] == 0))
  {
    yy_last_accepting_state = yy_current_state;
    yy_last_accepting_cpos = yy_cp;
  }

  while(!((signed int)yy_chk[(signed long int)((signed int)yy_base[(signed long int)yy_current_state] + (signed int)yy_c)] == yy_current_state))
  {
    yy_current_state = (signed int)yy_def[(signed long int)yy_current_state];
    if(yy_current_state >= 599)
      yy_c = (unsigned char)yy_meta[(signed long int)(unsigned int)yy_c];

  }
  yy_current_state = (signed int)yy_nxt[(signed long int)((unsigned int)yy_base[(signed long int)yy_current_state] + (unsigned int)yy_c)];
  yy_is_jam = (signed int)(yy_current_state == 598);
  return yy_is_jam != 0 ? 0 : yy_current_state;
}

// yylex
// file vlex.h line 24
signed int yylex(void)
{
  signed int yy_current_state;
  char *yy_cp = (char *)(void *)0;
  char *yy_bp = (char *)(void *)0;
  signed int yy_act;
  if(!(yy_init == 0))
  {
    yy_init = 0;
    if(yy_start == 0)
      yy_start = 1;

    if(yyin == ((struct _IO_FILE *)NULL))
      yyin = stdin;

    if(yyout == ((struct _IO_FILE *)NULL))
      yyout = stdout;

    if(yy_current_buffer == ((struct yy_buffer_state *)NULL))
      yy_current_buffer=yy_create_buffer(yyin, 16384);

    yy_load_buffer_state();
  }

  signed int yy_amount_of_matched_text;
  signed int return_value_yy_get_next_buffer_2;
  signed int return_value_yywrap_3;
  while((_Bool)1)
  {
    yy_cp = yy_c_buf_p;
    *yy_cp = yy_hold_char;
    yy_bp = yy_cp;
    yy_current_state = yy_start;
    do
    {

    yy_match:
      ;
      unsigned char yy_c = (unsigned char)yy_ec[(signed long int)(unsigned int)(unsigned char)*yy_cp];
      if(!(yy_accept[(signed long int)yy_current_state] == 0))
      {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
      }

      while(!((signed int)yy_chk[(signed long int)((signed int)yy_base[(signed long int)yy_current_state] + (signed int)yy_c)] == yy_current_state))
      {
        yy_current_state = (signed int)yy_def[(signed long int)yy_current_state];
        if(yy_current_state >= 599)
          yy_c = (unsigned char)yy_meta[(signed long int)(unsigned int)yy_c];

      }
      yy_current_state = (signed int)yy_nxt[(signed long int)((unsigned int)yy_base[(signed long int)yy_current_state] + (unsigned int)yy_c)];
      yy_cp = yy_cp + 1l;
      if(!((signed int)yy_base[(signed long int)yy_current_state] == 1324))
        goto yy_match;


    yy_find_action:
      ;
      yy_act = (signed int)yy_accept[(signed long int)yy_current_state];
      if(yy_act == 0)
      {
        yy_cp = yy_last_accepting_cpos;
        yy_current_state = yy_last_accepting_state;
        yy_act = (signed int)yy_accept[(signed long int)yy_current_state];
      }

      yytext = yy_bp;
      yyleng = (signed int)(yy_cp - yy_bp);
      yy_hold_char = *yy_cp;
      *yy_cp = (char)0;
      yy_c_buf_p = yy_cp;

    do_action:
      ;
      for( ; (_Bool)1; yy_act = 151 + (yy_start - 1) / 2 + 1)
      {
        if(!(yy_act == 0))
        {
          if(yy_act == 1)
            goto __CPROVER_DUMP_L14;

          if(yy_act == 2)
            goto __CPROVER_DUMP_L15;

          if(yy_act == 3)
            goto __CPROVER_DUMP_L16;

          if(yy_act == 4)
            goto __CPROVER_DUMP_L17;

          if(yy_act == 5)
            goto __CPROVER_DUMP_L18;

          if(yy_act == 6)
            goto __CPROVER_DUMP_L19;

          if(yy_act == 7)
            goto __CPROVER_DUMP_L20;

          if(yy_act == 8)
            goto __CPROVER_DUMP_L21;

          if(yy_act == 9)
            goto __CPROVER_DUMP_L22;

          if(yy_act == 10)
            goto __CPROVER_DUMP_L23;

          if(yy_act == 11)
            goto __CPROVER_DUMP_L24;

          if(yy_act == 12)
            goto __CPROVER_DUMP_L25;

          if(yy_act == 13)
            goto __CPROVER_DUMP_L26;

          if(yy_act == 14)
            goto __CPROVER_DUMP_L27;

          if(yy_act == 15)
            goto __CPROVER_DUMP_L28;

          if(yy_act == 16)
            goto __CPROVER_DUMP_L29;

          if(yy_act == 17)
            goto __CPROVER_DUMP_L30;

          if(yy_act == 18)
            goto __CPROVER_DUMP_L31;

          if(yy_act == 19)
            goto __CPROVER_DUMP_L32;

          if(yy_act == 20)
            goto __CPROVER_DUMP_L33;

          if(yy_act == 21)
            goto __CPROVER_DUMP_L34;

          if(yy_act == 22)
            goto __CPROVER_DUMP_L35;

          if(yy_act == 23)
            goto __CPROVER_DUMP_L36;

          if(yy_act == 24)
            goto __CPROVER_DUMP_L37;

          if(yy_act == 25)
            goto __CPROVER_DUMP_L38;

          if(yy_act == 26)
            goto __CPROVER_DUMP_L39;

          if(yy_act == 27)
            goto __CPROVER_DUMP_L40;

          if(yy_act == 28)
            goto __CPROVER_DUMP_L41;

          if(yy_act == 29)
            goto __CPROVER_DUMP_L42;

          if(yy_act == 30)
            goto __CPROVER_DUMP_L43;

          if(yy_act == 31)
            goto __CPROVER_DUMP_L44;

          if(yy_act == 32)
            goto __CPROVER_DUMP_L45;

          if(yy_act == 33)
            goto __CPROVER_DUMP_L46;

          if(yy_act == 34)
            goto __CPROVER_DUMP_L47;

          if(yy_act == 35)
            goto __CPROVER_DUMP_L48;

          if(yy_act == 36)
            goto __CPROVER_DUMP_L49;

          if(yy_act == 37)
            goto __CPROVER_DUMP_L50;

          if(yy_act == 38)
            goto __CPROVER_DUMP_L51;

          if(yy_act == 39)
            goto __CPROVER_DUMP_L52;

          if(yy_act == 40)
            goto __CPROVER_DUMP_L53;

          if(yy_act == 41)
            goto __CPROVER_DUMP_L54;

          if(yy_act == 42)
            goto __CPROVER_DUMP_L55;

          if(yy_act == 43)
            goto __CPROVER_DUMP_L56;

          if(yy_act == 44)
            goto __CPROVER_DUMP_L57;

          if(yy_act == 45)
            goto __CPROVER_DUMP_L58;

          if(yy_act == 46)
            goto __CPROVER_DUMP_L59;

          if(yy_act == 47)
            goto __CPROVER_DUMP_L60;

          if(yy_act == 48)
            goto __CPROVER_DUMP_L61;

          if(yy_act == 49)
            goto __CPROVER_DUMP_L62;

          if(yy_act == 50)
            goto __CPROVER_DUMP_L63;

          if(yy_act == 51)
            goto __CPROVER_DUMP_L64;

          if(yy_act == 52)
            goto __CPROVER_DUMP_L65;

          if(yy_act == 53)
            goto __CPROVER_DUMP_L66;

          if(yy_act == 54)
            goto __CPROVER_DUMP_L67;

          if(yy_act == 55)
            goto __CPROVER_DUMP_L68;

          if(yy_act == 56)
            goto __CPROVER_DUMP_L69;

          if(yy_act == 57)
            goto __CPROVER_DUMP_L70;

          if(yy_act == 58)
            goto __CPROVER_DUMP_L71;

          if(yy_act == 59)
            goto __CPROVER_DUMP_L72;

          if(yy_act == 60)
            goto __CPROVER_DUMP_L73;

          if(yy_act == 61)
            goto __CPROVER_DUMP_L74;

          if(yy_act == 62)
            goto __CPROVER_DUMP_L75;

          if(yy_act == 63)
            goto __CPROVER_DUMP_L76;

          if(yy_act == 64)
            goto __CPROVER_DUMP_L77;

          if(yy_act == 65)
            goto __CPROVER_DUMP_L78;

          if(yy_act == 66)
            goto __CPROVER_DUMP_L79;

          if(yy_act == 67)
            goto __CPROVER_DUMP_L80;

          if(yy_act == 68)
            goto __CPROVER_DUMP_L81;

          if(yy_act == 69)
            goto __CPROVER_DUMP_L82;

          if(yy_act == 70)
            goto __CPROVER_DUMP_L83;

          if(yy_act == 71)
            goto __CPROVER_DUMP_L84;

          if(yy_act == 72)
            goto __CPROVER_DUMP_L85;

          if(yy_act == 73)
            goto __CPROVER_DUMP_L86;

          if(yy_act == 74)
            goto __CPROVER_DUMP_L87;

          if(yy_act == 75)
            goto __CPROVER_DUMP_L88;

          if(yy_act == 76)
            goto __CPROVER_DUMP_L89;

          if(yy_act == 77)
            goto __CPROVER_DUMP_L90;

          if(yy_act == 78)
            goto __CPROVER_DUMP_L91;

          if(yy_act == 79)
            goto __CPROVER_DUMP_L92;

          if(yy_act == 80)
            goto __CPROVER_DUMP_L93;

          if(yy_act == 81)
            goto __CPROVER_DUMP_L94;

          if(yy_act == 82)
            goto __CPROVER_DUMP_L95;

          if(yy_act == 83)
            goto __CPROVER_DUMP_L96;

          if(yy_act == 84)
            goto __CPROVER_DUMP_L97;

          if(yy_act == 85)
            goto __CPROVER_DUMP_L98;

          if(yy_act == 86)
            goto __CPROVER_DUMP_L99;

          if(yy_act == 87)
            goto __CPROVER_DUMP_L100;

          if(yy_act == 88)
            goto __CPROVER_DUMP_L101;

          if(yy_act == 89)
            goto __CPROVER_DUMP_L102;

          if(yy_act == 90)
            goto __CPROVER_DUMP_L103;

          if(yy_act == 91)
            goto __CPROVER_DUMP_L104;

          if(yy_act == 92)
            goto __CPROVER_DUMP_L105;

          if(yy_act == 93)
            goto __CPROVER_DUMP_L106;

          if(yy_act == 94)
            goto __CPROVER_DUMP_L107;

          if(yy_act == 95)
            goto __CPROVER_DUMP_L108;

          if(yy_act == 96)
            goto __CPROVER_DUMP_L109;

          if(yy_act == 97)
            goto __CPROVER_DUMP_L110;

          if(yy_act == 98)
            goto __CPROVER_DUMP_L111;

          if(yy_act == 99)
            goto __CPROVER_DUMP_L112;

          if(yy_act == 100)
            goto __CPROVER_DUMP_L113;

          if(yy_act == 101)
            goto __CPROVER_DUMP_L114;

          if(yy_act == 102)
            goto __CPROVER_DUMP_L115;

          if(yy_act == 103)
            goto __CPROVER_DUMP_L116;

          if(yy_act == 104)
            goto __CPROVER_DUMP_L117;

          if(yy_act == 105)
            goto __CPROVER_DUMP_L118;

          if(yy_act == 106)
            goto __CPROVER_DUMP_L119;

          if(yy_act == 107)
            goto __CPROVER_DUMP_L120;

          if(yy_act == 108)
            goto __CPROVER_DUMP_L121;

          if(yy_act == 109)
            goto __CPROVER_DUMP_L122;

          if(yy_act == 110)
            goto __CPROVER_DUMP_L123;

          if(yy_act == 111)
            goto __CPROVER_DUMP_L124;

          if(yy_act == 112)
            goto __CPROVER_DUMP_L125;

          if(yy_act == 113)
            goto __CPROVER_DUMP_L126;

          if(yy_act == 114)
            goto __CPROVER_DUMP_L127;

          if(yy_act == 115)
            goto __CPROVER_DUMP_L128;

          if(yy_act == 116)
            goto __CPROVER_DUMP_L129;

          if(yy_act == 117)
            goto __CPROVER_DUMP_L130;

          if(yy_act == 118)
            goto __CPROVER_DUMP_L131;

          if(yy_act == 119)
            goto __CPROVER_DUMP_L132;

          if(yy_act == 120)
            goto __CPROVER_DUMP_L133;

          if(yy_act == 121)
            goto __CPROVER_DUMP_L134;

          if(yy_act == 122)
            goto __CPROVER_DUMP_L135;

          if(yy_act == 123)
            goto __CPROVER_DUMP_L136;

          if(yy_act == 124)
            goto __CPROVER_DUMP_L137;

          if(yy_act == 125)
            goto __CPROVER_DUMP_L138;

          if(yy_act == 126)
            goto __CPROVER_DUMP_L139;

          if(yy_act == 127)
            goto __CPROVER_DUMP_L140;

          if(yy_act == 128)
            goto __CPROVER_DUMP_L141;

          if(yy_act == 129)
            goto __CPROVER_DUMP_L142;

          if(yy_act == 130)
            goto __CPROVER_DUMP_L143;

          if(yy_act == 131)
            goto __CPROVER_DUMP_L144;

          if(yy_act == 132)
            goto __CPROVER_DUMP_L145;

          if(yy_act == 133)
            goto __CPROVER_DUMP_L146;

          if(yy_act == 134)
            goto __CPROVER_DUMP_L148;

          if(yy_act == 135)
            goto __CPROVER_DUMP_L149;

          if(yy_act == 136)
            goto __CPROVER_DUMP_L150;

          if(yy_act == 137)
            goto __CPROVER_DUMP_L151;

          if(yy_act == 138)
            goto __CPROVER_DUMP_L152;

          if(yy_act == 139)
            goto __CPROVER_DUMP_L153;

          if(yy_act == 140)
            goto __CPROVER_DUMP_L154;

          if(yy_act == 141)
            goto __CPROVER_DUMP_L155;

          if(yy_act == 142)
            goto __CPROVER_DUMP_L156;

          if(yy_act == 143)
            goto __CPROVER_DUMP_L157;

          if(yy_act == 144)
            goto __CPROVER_DUMP_L158;

          if(yy_act == 145)
            goto __CPROVER_DUMP_L159;

          if(yy_act == 146)
            goto __CPROVER_DUMP_L160;

          if(yy_act == 147)
            goto __CPROVER_DUMP_L161;

          if(yy_act == 148)
            goto __CPROVER_DUMP_L162;

          if(yy_act == 149)
            goto __CPROVER_DUMP_L163;

          if(yy_act == 150)
            goto __CPROVER_DUMP_L164;

          if(yy_act == 1 || yy_act == 1 || yy_act == 1)
            goto __CPROVER_DUMP_L165;

          if(yy_act == 151)
            goto __CPROVER_DUMP_L166;

          goto __CPROVER_DUMP_L177;
        }

        *yy_cp = yy_hold_char;
        yy_cp = yy_last_accepting_cpos;
        yy_current_state = yy_last_accepting_state;
        goto yy_find_action;

      __CPROVER_DUMP_L14:
        ;
        yy_start = 1 + 2 * 1;
        return 9;

      __CPROVER_DUMP_L15:
        ;
        return 9;

      __CPROVER_DUMP_L16:
        ;
        yy_start = 1 + 2 * 0;
        return 9;

      __CPROVER_DUMP_L17:
        ;
        return 9;

      __CPROVER_DUMP_L18:
        ;
        return 9;

      __CPROVER_DUMP_L19:
        ;
        my_yylineno = my_yylineno + 1;
        return 9;

      __CPROVER_DUMP_L20:
        ;
        return 14;

      __CPROVER_DUMP_L21:
        ;
        return 14;

      __CPROVER_DUMP_L22:
        ;
        return 14;

      __CPROVER_DUMP_L23:
        ;
        return 14;

      __CPROVER_DUMP_L24:
        ;
        return 14;

      __CPROVER_DUMP_L25:
        ;
        return 14;

      __CPROVER_DUMP_L26:
        ;
        return 14;

      __CPROVER_DUMP_L27:
        ;
        return 14;

      __CPROVER_DUMP_L28:
        ;
        return 14;

      __CPROVER_DUMP_L29:
        ;
        return 14;

      __CPROVER_DUMP_L30:
        ;
        return 14;

      __CPROVER_DUMP_L31:
        ;
        return 14;

      __CPROVER_DUMP_L32:
        ;
        return 14;

      __CPROVER_DUMP_L33:
        ;
        return 14;

      __CPROVER_DUMP_L34:
        ;
        return 14;

      __CPROVER_DUMP_L35:
        ;
        return 14;

      __CPROVER_DUMP_L36:
        ;
        return 14;

      __CPROVER_DUMP_L37:
        ;
        return 14;

      __CPROVER_DUMP_L38:
        ;
        return 14;

      __CPROVER_DUMP_L39:
        ;
        return 14;

      __CPROVER_DUMP_L40:
        ;
        return 14;

      __CPROVER_DUMP_L41:
        ;
        return 14;

      __CPROVER_DUMP_L42:
        ;
        return 14;

      __CPROVER_DUMP_L43:
        ;
        return 14;

      __CPROVER_DUMP_L44:
        ;
        return 14;

      __CPROVER_DUMP_L45:
        ;
        return 14;

      __CPROVER_DUMP_L46:
        ;
        return 14;

      __CPROVER_DUMP_L47:
        ;
        return 14;

      __CPROVER_DUMP_L48:
        ;
        return 14;

      __CPROVER_DUMP_L49:
        ;
        return 14;

      __CPROVER_DUMP_L50:
        ;
        return 14;

      __CPROVER_DUMP_L51:
        ;
        return 14;

      __CPROVER_DUMP_L52:
        ;
        return 14;

      __CPROVER_DUMP_L53:
        ;
        return 14;

      __CPROVER_DUMP_L54:
        ;
        return 14;

      __CPROVER_DUMP_L55:
        ;
        return 14;

      __CPROVER_DUMP_L56:
        ;
        return 14;

      __CPROVER_DUMP_L57:
        ;
        return 14;

      __CPROVER_DUMP_L58:
        ;
        return 14;

      __CPROVER_DUMP_L59:
        ;
        return 14;

      __CPROVER_DUMP_L60:
        ;
        return 14;

      __CPROVER_DUMP_L61:
        ;
        return 14;

      __CPROVER_DUMP_L62:
        ;
        return 14;

      __CPROVER_DUMP_L63:
        ;
        return 14;

      __CPROVER_DUMP_L64:
        ;
        return 14;

      __CPROVER_DUMP_L65:
        ;
        return 14;

      __CPROVER_DUMP_L66:
        ;
        return 14;

      __CPROVER_DUMP_L67:
        ;
        return 14;

      __CPROVER_DUMP_L68:
        ;
        return 14;

      __CPROVER_DUMP_L69:
        ;
        return 14;

      __CPROVER_DUMP_L70:
        ;
        return 14;

      __CPROVER_DUMP_L71:
        ;
        return 14;

      __CPROVER_DUMP_L72:
        ;
        return 14;

      __CPROVER_DUMP_L73:
        ;
        return 14;

      __CPROVER_DUMP_L74:
        ;
        return 14;

      __CPROVER_DUMP_L75:
        ;
        return 14;

      __CPROVER_DUMP_L76:
        ;
        return 14;

      __CPROVER_DUMP_L77:
        ;
        return 14;

      __CPROVER_DUMP_L78:
        ;
        return 14;

      __CPROVER_DUMP_L79:
        ;
        return 14;

      __CPROVER_DUMP_L80:
        ;
        return 14;

      __CPROVER_DUMP_L81:
        ;
        return 14;

      __CPROVER_DUMP_L82:
        ;
        return 14;

      __CPROVER_DUMP_L83:
        ;
        return 14;

      __CPROVER_DUMP_L84:
        ;
        return 14;

      __CPROVER_DUMP_L85:
        ;
        return 14;

      __CPROVER_DUMP_L86:
        ;
        return 14;

      __CPROVER_DUMP_L87:
        ;
        return 14;

      __CPROVER_DUMP_L88:
        ;
        return 14;

      __CPROVER_DUMP_L89:
        ;
        return 14;

      __CPROVER_DUMP_L90:
        ;
        return 14;

      __CPROVER_DUMP_L91:
        ;
        return 14;

      __CPROVER_DUMP_L92:
        ;
        return 14;

      __CPROVER_DUMP_L93:
        ;
        return 14;

      __CPROVER_DUMP_L94:
        ;
        return 14;

      __CPROVER_DUMP_L95:
        ;
        return 14;

      __CPROVER_DUMP_L96:
        ;
        return 14;

      __CPROVER_DUMP_L97:
        ;
        return 14;

      __CPROVER_DUMP_L98:
        ;
        return 14;

      __CPROVER_DUMP_L99:
        ;
        return 14;

      __CPROVER_DUMP_L100:
        ;
        return 14;

      __CPROVER_DUMP_L101:
        ;
        return 14;

      __CPROVER_DUMP_L102:
        ;
        return 14;

      __CPROVER_DUMP_L103:
        ;
        return 14;

      __CPROVER_DUMP_L104:
        ;
        return 14;

      __CPROVER_DUMP_L105:
        ;
        return 14;

      __CPROVER_DUMP_L106:
        ;
        return 14;

      __CPROVER_DUMP_L107:
        ;
        return 14;

      __CPROVER_DUMP_L108:
        ;
        return 14;

      __CPROVER_DUMP_L109:
        ;
        return 14;

      __CPROVER_DUMP_L110:
        ;
        return 14;

      __CPROVER_DUMP_L111:
        ;
        return 14;

      __CPROVER_DUMP_L112:
        ;
        return 14;

      __CPROVER_DUMP_L113:
        ;
        return 14;

      __CPROVER_DUMP_L114:
        ;
        return 14;

      __CPROVER_DUMP_L115:
        ;
        return 14;

      __CPROVER_DUMP_L116:
        ;
        return 15;

      __CPROVER_DUMP_L117:
        ;
        return 15;

      __CPROVER_DUMP_L118:
        ;
        return 15;

      __CPROVER_DUMP_L119:
        ;
        return 15;

      __CPROVER_DUMP_L120:
        ;
        return 15;

      __CPROVER_DUMP_L121:
        ;
        return 15;

      __CPROVER_DUMP_L122:
        ;
        return 15;

      __CPROVER_DUMP_L123:
        ;
        return 15;

      __CPROVER_DUMP_L124:
        ;
        return 15;

      __CPROVER_DUMP_L125:
        ;
        return 15;

      __CPROVER_DUMP_L126:
        ;
        return 15;

      __CPROVER_DUMP_L127:
        ;
        return 15;

      __CPROVER_DUMP_L128:
        ;
        return 15;

      __CPROVER_DUMP_L129:
        ;
        return 15;

      __CPROVER_DUMP_L130:
        ;
        return 15;

      __CPROVER_DUMP_L131:
        ;
        return 15;

      __CPROVER_DUMP_L132:
        ;
        return 15;

      __CPROVER_DUMP_L133:
        ;
        return 15;

      __CPROVER_DUMP_L134:
        ;
        return 15;

      __CPROVER_DUMP_L135:
        ;
        return 15;

      __CPROVER_DUMP_L136:
        ;
        return 15;

      __CPROVER_DUMP_L137:
        ;
        return 15;

      __CPROVER_DUMP_L138:
        ;
        return 15;

      __CPROVER_DUMP_L139:
        ;
        return 4;

      __CPROVER_DUMP_L140:
        ;
        return 4;

      __CPROVER_DUMP_L141:
        ;
        return 4;

      __CPROVER_DUMP_L142:
        ;
        return 5;

      __CPROVER_DUMP_L143:
        ;
        return 5;

      __CPROVER_DUMP_L144:
        ;
        return 13;

      __CPROVER_DUMP_L145:
        ;
        my_yylineno = my_yylineno + 1;
        yy_start = 1 + 2 * 0;
        return 7;

      __CPROVER_DUMP_L146:
        ;
        const char *return_value_is_builtin_define_1;
        return_value_is_builtin_define_1=is_builtin_define(yytext + (signed long int)1, (unsigned int)(yyleng - 1));
        if(!(return_value_is_builtin_define_1 == ((const char *)NULL)))
        {
          yy_start = 1 + 2 * 2;
          return 12;
        }

        return 8;

      __CPROVER_DUMP_L148:
        ;
        return 2;

      __CPROVER_DUMP_L149:
        ;
        return 11;

      __CPROVER_DUMP_L150:
        ;
        return 2;

      __CPROVER_DUMP_L151:
        ;
        return 2;

      __CPROVER_DUMP_L152:
        ;
        return 3;

      __CPROVER_DUMP_L153:
        ;
        return 10;

      __CPROVER_DUMP_L154:
        ;
        return 10;

      __CPROVER_DUMP_L155:
        ;
        return 10;

      __CPROVER_DUMP_L156:
        ;
        return 10;

      __CPROVER_DUMP_L157:
        ;
        return 10;

      __CPROVER_DUMP_L158:
        ;
        return 1;

      __CPROVER_DUMP_L159:
        ;
        return 7;

      __CPROVER_DUMP_L160:
        ;
        my_yylineno = my_yylineno + 1;
        return 7;

      __CPROVER_DUMP_L161:
        ;
        return 9;

      __CPROVER_DUMP_L162:
        ;
        return 6;

      __CPROVER_DUMP_L163:
        ;
        return 1;

      __CPROVER_DUMP_L164:
        ;
        fwrite((const void *)yytext, (unsigned long int)yyleng, (unsigned long int)1, yyout);
        goto __CPROVER_DUMP_L178;

      __CPROVER_DUMP_L165:
        ;
        return 0;

      __CPROVER_DUMP_L166:
        ;
        yy_amount_of_matched_text = (signed int)(yy_cp - yytext) - 1;
        *yy_cp = yy_hold_char;
        if(yy_current_buffer->yy_buffer_status == 0)
        {
          yy_n_chars = yy_current_buffer->yy_n_chars;
          yy_current_buffer->yy_input_file = yyin;
          yy_current_buffer->yy_buffer_status = 1;
        }

        if(yy_current_buffer->yy_ch_buf + (signed long int)yy_n_chars >= yy_c_buf_p)
        {
          signed int yy_next_state;
          yy_c_buf_p = yytext + (signed long int)yy_amount_of_matched_text;
          yy_current_state=yy_get_previous_state();
          yy_next_state=yy_try_NUL_trans(yy_current_state);
          yy_bp = yytext + (signed long int)0;
          if(!(yy_next_state == 0))
          {
            yy_c_buf_p = yy_c_buf_p + 1l;
            yy_cp = yy_c_buf_p;
            yy_current_state = yy_next_state;
            goto yy_match;
          }

          else
          {
            yy_cp = yy_c_buf_p;
            goto yy_find_action;
          }
        }

        return_value_yy_get_next_buffer_2=yy_get_next_buffer();
        if(!(return_value_yy_get_next_buffer_2 == 1))
        {
          if(return_value_yy_get_next_buffer_2 == 0)
            goto __CPROVER_DUMP_L174;

          if(return_value_yy_get_next_buffer_2 == 2)
            goto __CPROVER_DUMP_L175;

          goto __CPROVER_DUMP_L176;
        }

        yy_did_buffer_switch_on_eof = 0;
        return_value_yywrap_3=yywrap();
        if(return_value_yywrap_3 == 0)
          break;

        yy_c_buf_p = yytext + (signed long int)0;
      }
      if(yy_did_buffer_switch_on_eof == 0)
        yyrestart(yyin);

      goto __CPROVER_DUMP_L176;

    __CPROVER_DUMP_L174:
      ;
      yy_c_buf_p = yytext + (signed long int)yy_amount_of_matched_text;
      yy_current_state=yy_get_previous_state();
      yy_cp = yy_c_buf_p;
      yy_bp = yytext + (signed long int)0;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L175:
    ;
    yy_c_buf_p = &yy_current_buffer->yy_ch_buf[(signed long int)yy_n_chars];
    yy_current_state=yy_get_previous_state();
    yy_cp = yy_c_buf_p;
    yy_bp = yytext + (signed long int)0;
    goto yy_find_action;

  __CPROVER_DUMP_L176:
    ;
    continue;

  __CPROVER_DUMP_L177:
    ;
    yy_fatal_error("fatal flex scanner internal error--no action found");

  __CPROVER_DUMP_L178:
    ;
  }
}

// yyrestart
// file vlex.c line 2389
void yyrestart(struct _IO_FILE *input_file)
{
  if(yy_current_buffer == ((struct yy_buffer_state *)NULL))
    yy_current_buffer=yy_create_buffer(yyin, 16384);

  yy_init_buffer(yy_current_buffer, input_file);
  yy_load_buffer_state();
}

// yywrap
// file vlex.l line 24
static signed int yywrap(void)
{
  return 1;
}

// zMergeTclList
// file tcl_helper.c line 594
char * zMergeTclList(signed int argc, const char **argv)
{
  signed int localFlags[20l];
  signed int *flagPtr;
  signed int numChars;
  signed int i;
  char *result;
  char *dst;
  void *return_value_malloc_1;
  if(!(argc >= 21))
    flagPtr = localFlags;

  else
  {
    return_value_malloc_1=malloc((unsigned long int)argc * sizeof(signed int) /*4ul*/ );
    flagPtr = (signed int *)return_value_malloc_1;
  }
  numChars = 1;
  i = 0;
  signed int return_value_tclScanElement_2;
  for( ; !(i >= argc); i = i + 1)
  {
    return_value_tclScanElement_2=tclScanElement(argv[(signed long int)i], &flagPtr[(signed long int)i]);
    numChars = numChars + return_value_tclScanElement_2 + 1;
  }
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)numChars);
  result = (char *)return_value_malloc_3;
  dst = result;
  i = 0;
  for( ; !(i >= argc); i = i + 1)
  {
    numChars=tclConvertElement(argv[(signed long int)i], dst, flagPtr[(signed long int)i]);
    dst = dst + (signed long int)numChars;
    *dst = (char)32;
    dst = dst + 1l;
  }
  if(dst == result)
    *dst = (char)0;

  else
    dst[(signed long int)-1] = (char)0;
  if(!(flagPtr == localFlags))
    free((void *)flagPtr);

  return result;
}

// zSplitTclList
// file tcl_helper.c line 304
char ** zSplitTclList(const char *list, signed int *argcPtr)
{
  char **argv;
  const char *l;
  char *p;
  signed int size;
  signed int i;
  signed int ok;
  signed int elSize;
  signed int brace;
  const char *element;
  size = 1;
  l = list;
  for( ; !((signed int)*l == 0); l = l + 1l)
  {
    const unsigned short int **return_value___ctype_b_loc_1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)*l]) == 0))
      size = size + 1;

  }
  size = size + 1;
  i = (signed int)((unsigned long int)size * sizeof(char *) /*8ul*/  + (unsigned long int)(l - list) + (unsigned long int)1);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)i);
  argv = (char **)return_value_malloc_2;
  i = 0;
  p = (char *)(argv + (signed long int)size);
  for( ; !((signed int)*list == 0); i = i + 1)
  {
    ok=tclFindElement(list, &element, &list, &elSize, &brace);
    if(ok == 0)
    {
      free((void *)argv);
      return (char **)(void *)0;
    }

    if((signed int)*element == 0)
      break;

    if(i >= size)
    {
      free((void *)argv);
      return (char **)(void *)0;
    }

    argv[(signed long int)i] = p;
    if(!(brace == 0))
    {
      strncpy(p, element, (unsigned long int)elSize);
      p = p + (signed long int)elSize;
      *p = (char)0;
      p = p + 1l;
    }

    else
    {
      tclCopyAndCollapse(elSize, element, p);
      p = p + (signed long int)(elSize + 1);
    }
  }
  argv[(signed long int)i] = (char *)(void *)0;
  *argcPtr = i;
  return argv;
}

