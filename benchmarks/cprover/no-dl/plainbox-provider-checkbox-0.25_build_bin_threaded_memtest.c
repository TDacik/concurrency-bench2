// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$5;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$3;

// tag-#anon#ST[ARR16{U64}$U64$'__bits'|]
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 125
struct anonymous$12;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$8;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$11;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$1;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$9;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$0;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$4;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$10;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$7;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$13;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sysinfo
// file /usr/include/linux/sysinfo.h line 7
struct sysinfo;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#ifndef NULL
#define NULL ((void*)0)
#endif

// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// human_memsize
// file ../../src/threaded_memtest.c line 123
char * human_memsize(unsigned long int size);
// index
// file /usr/include/string.h line 488
extern char * index(const char *, signed int);
// int_handler
// file ../../src/threaded_memtest.c line 250
void int_handler(signed int signum);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mem_twiddler
// file ../../src/threaded_memtest.c line 147
void * mem_twiddler(void *arg);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// on_cpu
// file ../../src/threaded_memtest.c line 90
signed int on_cpu(unsigned int cpu);
// parse_memsize
// file ../../src/threaded_memtest.c line 102
unsigned long int parse_memsize(const char *str);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// progressbar
// file ../../src/threaded_memtest.c line 133
void progressbar(char *label, unsigned int cur, unsigned int total);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$6 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$6 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$6 *, union anonymous$13 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$13 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$13 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// sched_setaffinity
// file /usr/include/sched.h line 118
extern signed int sched_setaffinity(signed int, unsigned long int, const struct anonymous$12 *);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$8 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// sysinfo
// file /usr/include/x86_64-linux-gnu/sys/sysinfo.h line 29
extern signed int sysinfo(struct sysinfo *);
// usage
// file ../../src/threaded_memtest.c line 253
void usage(void);

struct anonymous$5
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$3
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$12
{
  // __bits
  unsigned long int __bits[16l];
};

struct anonymous$8
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$11
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$2
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$1
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$0
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$4
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$7
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous _kill;
  // _timer
  struct anonymous$0 _timer;
  // _rt
  struct anonymous$1 _rt;
  // _sigchld
  struct anonymous$2 _sigchld;
  // _sigfault
  struct anonymous$3 _sigfault;
  // _sigpoll
  struct anonymous$4 _sigpoll;
  // _sigsys
  struct anonymous$5 _sigsys;
};

struct anonymous$9
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$7 _sifields;
};

union anonymous$10
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$9 *, void *);
};

union anonymous$6
{
  // __data
  struct anonymous$11 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$13
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$10 __sigaction_handler;
  // sa_mask
  struct anonymous$8 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sysinfo
{
  // uptime
  signed long int uptime;
  // loads
  unsigned long int loads[3l];
  // totalram
  unsigned long int totalram;
  // freeram
  unsigned long int freeram;
  // sharedram
  unsigned long int sharedram;
  // bufferram
  unsigned long int bufferram;
  // totalswap
  unsigned long int totalswap;
  // freeswap
  unsigned long int freeswap;
  // procs
  unsigned short int procs;
  // pad
  unsigned short int pad;
  // totalhigh
  unsigned long int totalhigh;
  // freehigh
  unsigned long int freehigh;
  // mem_unit
  unsigned int mem_unit;
  // _f
  char _f[0l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// basename
// file ../../src/threaded_memtest.c line 87
char *basename = (char *)(void *)0;
// created_threads
// file ../../src/threaded_memtest.c line 71
unsigned int created_threads = (unsigned int)0;
// ct_mutex
// file ../../src/threaded_memtest.c line 72
union anonymous$13 ct_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// default_memsize
// file ../../src/threaded_memtest.c line 60
unsigned long int default_memsize;
// default_runtime
// file ../../src/threaded_memtest.c line 59
unsigned int default_runtime = (unsigned int)(60 * 15);
// default_threads
// file ../../src/threaded_memtest.c line 58
unsigned int default_threads = (unsigned int)2;
// done
// file ../../src/threaded_memtest.c line 84
unsigned int done = (unsigned int)0;
// duration
// file ../../src/threaded_memtest.c line 65
struct timeval duration = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
// finish
// file ../../src/threaded_memtest.c line 65
struct timeval finish = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
// finish_cond
// file ../../src/threaded_memtest.c line 83
union anonymous$6 finish_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// finish_mutex
// file ../../src/threaded_memtest.c line 82
union anonymous$13 finish_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// init_cond
// file ../../src/threaded_memtest.c line 77
union anonymous$6 init_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// init_mutex
// file ../../src/threaded_memtest.c line 76
union anonymous$13 init_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// live_threads
// file ../../src/threaded_memtest.c line 73
unsigned int live_threads = (unsigned int)0;
// loop_counters
// file ../../src/threaded_memtest.c line 66
unsigned long int *loop_counters = (unsigned long int *)(void *)0;
// lt_mutex
// file ../../src/threaded_memtest.c line 74
union anonymous$13 lt_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// memsize
// file ../../src/threaded_memtest.c line 60
unsigned long int memsize;
// memsize_str
// file ../../src/threaded_memtest.c line 121
char memsize_str[22l];
// mmap_cond
// file ../../src/threaded_memtest.c line 79
union anonymous$6 mmap_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mmap_done
// file ../../src/threaded_memtest.c line 75
unsigned int mmap_done = (unsigned int)0;
// mmap_mutex
// file ../../src/threaded_memtest.c line 78
union anonymous$13 mmap_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mmap_regions
// file ../../src/threaded_memtest.c line 69
char **mmap_regions = (char **)(void *)0;
// num_cpus
// file ../../src/threaded_memtest.c line 62
unsigned int num_cpus;
// num_threads
// file ../../src/threaded_memtest.c line 58
unsigned int num_threads;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// parallel
// file ../../src/threaded_memtest.c line 57
signed int parallel = 0;
// quiet
// file ../../src/threaded_memtest.c line 56
signed int quiet = 0;
// running_threads
// file ../../src/threaded_memtest.c line 85
unsigned int running_threads = (unsigned int)0;
// runtime
// file ../../src/threaded_memtest.c line 59
unsigned int runtime;
// start
// file ../../src/threaded_memtest.c line 65
struct timeval start = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// test_mutex
// file ../../src/threaded_memtest.c line 80
union anonymous$13 test_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// test_start
// file ../../src/threaded_memtest.c line 81
union anonymous$6 test_start = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// threads
// file ../../src/threaded_memtest.c line 68
unsigned long int *threads;
// total_ram
// file ../../src/threaded_memtest.c line 63
unsigned long int total_ram;
// verbose
// file ../../src/threaded_memtest.c line 55
signed int verbose = 0;

// human_memsize
// file ../../src/threaded_memtest.c line 123
char * human_memsize(unsigned long int size)
{
  char unit = (char)32;
  if(size >= 10241ul)
  {
    unit = (char)75;
    size = size / (unsigned long int)1024;
  }

  if(size >= 10241ul)
  {
    unit = (char)77;
    size = size / (unsigned long int)1024;
  }

  if(size >= 10241ul)
  {
    unit = (char)71;
    size = size / (unsigned long int)1024;
  }

  snprintf(memsize_str, (unsigned long int)22, "%ld%c", size, unit);
  return memsize_str;
}

// int_handler
// file ../../src/threaded_memtest.c line 250
void int_handler(signed int signum)
{
  done = (unsigned int)1;
}

// main
// file ../../src/threaded_memtest.c line 267
signed int main(signed int argc, char **argv)
{
  struct sysinfo info;
  struct sigaction mysig;
  signed int i;
  signed int rv = 0;
  float duration_f;
  float loops_per_sec;
  unsigned long int free_mem;
  unsigned long int mapsize;
  basename=strrchr(argv[(signed long int)0], 47);
  if(!(basename == ((char *)NULL)))
    basename = basename + 1l;

  else
    basename = argv[(signed long int)0];
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(83);
  num_cpus = (unsigned int)return_value_sysconf$1;
  if(!(default_threads >= 2u * num_cpus))
    default_threads = num_cpus * (unsigned int)2;

  signed int return_value_sysinfo$2;
  return_value_sysinfo$2=sysinfo(&info);
  signed int return_value_atoi$3;
  signed int return_value_atoi$4;
  if(!(return_value_sysinfo$2 == 0))
  {
    perror("sysinfo");
    return -1;
  }

  else
  {
    free_mem = (info.freeram + info.bufferram) * (unsigned long int)info.mem_unit;
    total_ram = info.totalram * (unsigned long int)info.mem_unit;
    default_memsize = (unsigned long int)((double)free_mem * 0.95);
    runtime = default_runtime;
    num_threads = default_threads;
    memsize = default_memsize;
    do
    {
      i=getopt(argc, argv, "hvqpt:n:m:");
      if(i == -1)
        break;

      switch(i)
      {
        case 104:
        {
          usage();
          return 0;
        }
        case 118:
        {
          verbose = 1;
          break;
        }
        case 113:
        {
          quiet = 1;
          break;
        }
        case 112:
        {
          parallel = 1;
          break;
        }
        case 116:
        {
          return_value_atoi$3=atoi(optarg);
          runtime = (unsigned int)return_value_atoi$3;
          if(runtime == 0u)
          {
            printf("%s: error: bad runtime \"%s\"\n", basename, optarg);
            return 1;
          }

          break;
        }
        case 110:
        {
          return_value_atoi$4=atoi(optarg);
          num_threads = (unsigned int)return_value_atoi$4;
          if(num_threads == 0u)
          {
            printf("%s: error: bad thread count \"%s\"\n", basename, optarg);
            return 1;
          }

          break;
        }
        case 109:
        {
          memsize=parse_memsize(optarg);
          if(memsize == 0ul)
          {
            printf("%s: error: bad memory size \"%s\"\n", basename, optarg);
            return 1;
          }

        }
        default:
          ;
      }
    }
    while((_Bool)1);
    mapsize = memsize / (unsigned long int)num_threads;
    if(!(num_threads >= num_cpus))
      printf("Warning: num_threads < num_cpus. This isn't usually a good idea.\n");

    if(!(free_mem >= memsize))
      printf("Warning: memsize > free_mem. You will probably hit swap.\n");

    if(!(verbose == 0))
    {
      printf("Detected %u processors.\n", num_cpus);
      char *return_value_human_memsize$5;
      return_value_human_memsize$5=human_memsize(free_mem);
      printf("RAM: %.1f%% free (%s/", (100.0 * (double)free_mem) / (double)total_ram, return_value_human_memsize$5);
      char *return_value_human_memsize$6;
      return_value_human_memsize$6=human_memsize(total_ram);
      printf("%s)\n", return_value_human_memsize$6);
    }

    char *return_value_human_memsize$7;
    return_value_human_memsize$7=human_memsize(memsize);
    printf("Testing %s RAM for %u seconds using %u threads:\n", return_value_human_memsize$7, runtime, num_threads);
    void *return_value_malloc$8;
    return_value_malloc$8=malloc((unsigned long int)num_threads * sizeof(unsigned long int) /*8ul*/ );
    threads = (unsigned long int *)return_value_malloc$8;
    void *return_value_malloc$9;
    return_value_malloc$9=malloc((unsigned long int)num_threads * sizeof(char *) /*8ul*/ );
    mmap_regions = (char **)return_value_malloc$9;
    void *return_value_malloc$10;
    return_value_malloc$10=malloc((unsigned long int)num_threads * sizeof(unsigned long int *) /*8ul*/ );
    loop_counters = (unsigned long int *)return_value_malloc$10;
    while(!(created_threads >= num_threads))
    {
      pthread_mutex_lock(&mmap_mutex);
      mmap_done = (unsigned int)0;
      signed int return_value_pthread_create$11;
      return_value_pthread_create$11=pthread_create(&threads[(signed long int)created_threads], (const union pthread_attr_t *)(void *)0, mem_twiddler, (void *)&mapsize);
      if(!(return_value_pthread_create$11 == 0))
      {
        perror("pthread_create");
        exit(1);
      }

      while(mmap_done == 0u)
        pthread_cond_wait(&mmap_cond, &mmap_mutex);
      pthread_mutex_unlock(&mmap_mutex);
      if(quiet == 0 && verbose == 0)
        progressbar("Starting threads", created_threads, num_threads);

    }
    if(!(parallel == 0))
    {
      pthread_mutex_lock(&init_mutex);
      while(!(live_threads >= num_threads))
        pthread_cond_wait(&init_cond, &init_mutex);
      pthread_mutex_unlock(&init_mutex);
    }

    if(quiet == 0 && verbose == 0)
      printf("\n");

    gettimeofday(&start, (struct timezone *)(void *)0);
    pthread_cond_broadcast(&test_start);
    mysig.__sigaction_handler.sa_handler = int_handler;
    sigemptyset(&mysig.sa_mask);
    mysig.sa_flags = 0;
    sigaction(2, &mysig, (struct sigaction *)(void *)0);
    i = 0;
    while(done == 0u && !((unsigned int)i >= runtime))
    {
      unsigned int return_value_sleep$12;
      return_value_sleep$12=sleep((unsigned int)1);
      if(return_value_sleep$12 == 0u)
        i = i + 1;

      if(quiet == 0)
        progressbar("Testing RAM", (unsigned int)i, runtime);

    }
    if(!((unsigned int)i == runtime))
      rv = 1;

    done = (unsigned int)1;
    for( ; !(live_threads == 0u); live_threads = live_threads - 1u)
      pthread_join(threads[(signed long int)(live_threads - (unsigned int)1)], (void **)(void *)0);
    gettimeofday(&finish, (struct timezone *)(void *)0);
    if(quiet == 0)
      printf("\n");

    do
    {
      (&duration)->tv_sec = (&finish)->tv_sec - (&start)->tv_sec;
      (&duration)->tv_usec = (&finish)->tv_usec - (&start)->tv_usec;
      if(!(duration.tv_usec >= 0l))
      {
        (&duration)->tv_sec = (&duration)->tv_sec - 1l;
        (&duration)->tv_usec = (&duration)->tv_usec + (signed long int)1000000;
      }

    }
    while((_Bool)0);
    duration_f = (float)((double)(float)duration.tv_sec + (double)(float)duration.tv_usec / 1000000.0);
    loops_per_sec = (float)0;
    if(!(verbose == 0))
      printf("Runtime was %.2fs\n", duration_f);

    i = 0;
    for( ; !((unsigned int)i >= num_threads); i = i + 1)
    {
      if(!(verbose == 0))
        printf("thread %i: %lu loops\n", i, loop_counters[(signed long int)i]);

      loops_per_sec = loops_per_sec + (float)loop_counters[(signed long int)i] / duration_f;
    }
    printf("Total loops per second: %.2f\n", loops_per_sec);
    printf("Testing complete.\n");
    return rv;
  }
}

// mem_twiddler
// file ../../src/threaded_memtest.c line 147
void * mem_twiddler(void *arg)
{
  unsigned long int thread_id;
  unsigned long int pages;
  unsigned long int pagesize;
  unsigned long int i;
  unsigned long int p;
  volatile signed long int garbage;
  signed long int *lp;
  signed int t;
  signed int offset;
  char *my_region;
  unsigned long int mapsize = *((unsigned long int *)arg);
  pthread_mutex_lock(&ct_mutex);
  unsigned int tmp_post$1 = created_threads;
  created_threads = created_threads + 1u;
  thread_id = (unsigned long int)tmp_post$1;
  pthread_mutex_unlock(&ct_mutex);
  if(!(parallel == 0))
  {
    mmap_done = (unsigned int)1;
    pthread_cond_signal(&mmap_cond);
  }

  on_cpu((unsigned int)(thread_id % (unsigned long int)num_cpus));
  signed int return_value_getpagesize$2;
  return_value_getpagesize$2=getpagesize();
  pagesize = (unsigned long int)return_value_getpagesize$2;
  pages = mapsize / pagesize;
  char *return_value_human_memsize$3;
  if(!(verbose == 0))
  {
    return_value_human_memsize$3=human_memsize(mapsize);
    printf("thread %ld: mapping %s RAM\n", thread_id, return_value_human_memsize$3);
  }

  void *return_value_mmap$4;
  return_value_mmap$4=mmap((void *)0, mapsize, 0x1 | 0x2, 0x20 | 0x02, -1, (signed long int)0);
  my_region = (char *)return_value_mmap$4;
  if(my_region == (char *)-1)
  {
    perror("mmap");
    exit(1);
  }

  mmap_regions[(signed long int)thread_id] = my_region;
  i = (unsigned long int)0;
  for( ; !(i >= pages); i = i + 1ul)
  {
    lp = (signed long int *)&my_region[(signed long int)(i * pagesize)];
    lp[(signed long int)0] = (signed long int)0xDEADBEEF;
    lp[(signed long int)1] = (signed long int)thread_id;
    lp[(signed long int)2] = (signed long int)i;
  }
  pthread_mutex_lock(&lt_mutex);
  live_threads = live_threads + 1u;
  pthread_mutex_unlock(&lt_mutex);
  if(!(verbose == 0))
    printf("thread %ld: mapping complete\n", thread_id);

  if(parallel == 0)
  {
    mmap_done = (unsigned int)1;
    pthread_cond_signal(&mmap_cond);
  }

  else
    if(live_threads == num_threads)
      pthread_cond_signal(&init_cond);

  pthread_mutex_lock(&test_mutex);
  while(start.tv_sec == 0l)
    pthread_cond_wait(&test_start, &test_mutex);
  running_threads = running_threads + 1u;
  pthread_mutex_unlock(&test_mutex);
  if(!(verbose == 0))
    printf("thread %lu: test start\n", thread_id);

  loop_counters[(signed long int)thread_id] = (unsigned long int)0;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  while(done == 0u)
  {
    signed int return_value_rand$5;
    return_value_rand$5=rand();
    t = (signed int)((unsigned int)return_value_rand$5 % num_threads);
    signed int return_value_rand$6;
    return_value_rand$6=rand();
    p = (unsigned long int)return_value_rand$6 % pages;
    lp = (signed long int *)&mmap_regions[(signed long int)t][(signed long int)(p * pagesize)];
    if(!(*lp == 3735928559l))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = lp[(signed long int)1] != (signed long int)t ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = (unsigned long int)lp[(signed long int)2] != p ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
    {
      fprintf(stderr, "MEMORY CORRUPTION DETECTED\n");
      fprintf(stderr, "thread %lu (CPU %lu) reading map %u, page %lu\n", thread_id, thread_id % (unsigned long int)num_cpus, t, p);
      fprintf(stderr, "read: %#lx %lu %lu  should be: %#x %i %lu\n", lp[(signed long int)0], lp[(signed long int)1], lp[(signed long int)2], 0xDEADBEEF, t, p);
    }

    signed int return_value_rand$9;
    return_value_rand$9=rand();
    offset = (signed int)((unsigned long int)return_value_rand$9 % (pagesize / sizeof(signed long int) /*8ul*/  - (unsigned long int)3) + (unsigned long int)3);
    signed int return_value_rand$11;
    return_value_rand$11=rand();
    if(!(return_value_rand$11 % 2 == 0))
    {
      signed int return_value_rand$10;
      return_value_rand$10=rand();
      lp[(signed long int)offset] = (signed long int)return_value_rand$10;
    }

    else
      garbage = lp[(signed long int)offset];
    loop_counters[(signed long int)thread_id] = loop_counters[(signed long int)thread_id] + 1ul;
  }
  pthread_mutex_lock(&finish_mutex);
  if(!(verbose == 0))
    printf("thread %lu finished.\n", thread_id);

  running_threads = running_threads - 1u;
  if(running_threads == 0u)
    pthread_cond_broadcast(&finish_cond);

  else
    while(!(running_threads == 0u))
      pthread_cond_wait(&finish_cond, &finish_mutex);
  pthread_mutex_unlock(&finish_mutex);
  if(!(verbose == 0))
    printf("thread %lu unmapping and exiting\n", thread_id);

  signed int return_value_munmap$12;
  return_value_munmap$12=munmap((void *)my_region, mapsize);
  if(!(return_value_munmap$12 == 0))
  {
    perror("munmap");
    exit(2);
  }

  return (void *)0;
}

// on_cpu
// file ../../src/threaded_memtest.c line 90
signed int on_cpu(unsigned int cpu)
{
  struct anonymous$12 mask;
  do
    __builtin_memset((void *)&mask, 0, sizeof(struct anonymous$12) /*128ul*/ );
  while((_Bool)0);
  unsigned long int __cpu = (unsigned long int)cpu;
  if(!(__cpu / 8ul >= sizeof(struct anonymous$12) /*128ul*/ ))
    ((unsigned long int *)(&mask)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&mask)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

  else
    (unsigned long int)0;
  signed int return_value_sched_setaffinity$1;
  return_value_sched_setaffinity$1=sched_setaffinity(0, sizeof(struct anonymous$12) /*128ul*/ , &mask);
  if(!(return_value_sched_setaffinity$1 >= 0))
  {
    perror("sched_setaffinity");
    return -1;
  }

  else
    return 0;
}

// parse_memsize
// file ../../src/threaded_memtest.c line 102
unsigned long int parse_memsize(const char *str)
{
  unsigned long int size;
  char okchars[8l] = { 'G', 'g', 'M', 'm', 'K', 'k', '%', 0 };
  char unit;
  signed int return_value_atoi$1;
  return_value_atoi$1=atoi(str);
  size = (unsigned long int)return_value_atoi$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(str);
  unit = str[(signed long int)(return_value_strlen$2 - (unsigned long int)1)];
  char *return_value_index$3;
  return_value_index$3=index(okchars, (signed int)unit);
  if(!(return_value_index$3 == ((char *)NULL)))
    switch((signed int)unit)
    {
      case 71:

      case 103:
        size = size * (unsigned long int)1024;
      case 77:

      case 109:
        size = size * (unsigned long int)1024;
      case 75:

      case 107:
      {
        size = size * (unsigned long int)1024;
        break;
      }
      case 37:
        size = (unsigned long int)(((double)size / 100.0) * (double)total_ram);
    }

  return size;
}

// progressbar
// file ../../src/threaded_memtest.c line 133
void progressbar(char *label, unsigned int cur, unsigned int total)
{
  unsigned int pos;
  char bar[41l];
  char spinner[5l] = { '-', '\', '|', '/', 0 };
  pos = ((unsigned int)40 * cur) / total;
  memset((void *)bar, 46, (unsigned long int)40);
  memset((void *)bar, 35, (unsigned long int)pos);
  bar[(signed long int)40] = (char)0;
  if(total >= 80u && !(pos >= 40u))
    bar[(signed long int)pos] = spinner[(signed long int)(cur % (unsigned int)4)];

  printf("\r%18s [%s] %u/%u", label, (const void *)bar, cur, total);
  fflush(stdout);
}

// usage
// file ../../src/threaded_memtest.c line 253
void usage(void)
{
  printf("usage: %s [-h] [-v] [-q] [-p] [-t sec] [-n threads] [-m size]\n", basename);
  printf("  -h: show this help\n");
  printf("  -v: verbose\n");
  printf("  -q: quiet (do not show progress meters)\n");
  printf("  -p: parallel thread startup\n");
  printf("  -t: test time, in seconds. default: %u\n", default_runtime);
  printf("  -n: number of threads. default: %u (2*num_cpus)\n", default_threads);
  char *return_value_human_memsize$1;
  return_value_human_memsize$1=human_memsize(default_memsize);
  printf("  -m: memory usage. default: %s (%.0f%% of free RAM)\n", return_value_human_memsize$1, 0.95 * 100.0);
  printf("memory size may use k/m/g suffixes, or may be a percentage of total RAM.\n");
}

