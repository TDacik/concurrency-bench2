// #anon_enum_CMD_PAUSE=0_CMD_PLAY=1_CMD_SEEK=2_CMD_STOP=3_CMD_TERM=4
// file player.c line 55
enum anonymous_37 { CMD_PAUSE=0, CMD_PLAY=1, CMD_SEEK=2, CMD_STOP=3, CMD_TERM=4 };

// #anon_enum_GDK_ACTION_DEFAULT=1_GDK_ACTION_COPY=2_GDK_ACTION_MOVE=4_GDK_ACTION_LINK=8_GDK_ACTION_PRIVATE=16_GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous_11 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum_GDK_AXIS_IGNORE=0_GDK_AXIS_X=1_GDK_AXIS_Y=2_GDK_AXIS_PRESSURE=3_GDK_AXIS_XTILT=4_GDK_AXIS_YTILT=5_GDK_AXIS_WHEEL=6_GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous_20 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum_GDK_CROSSING_NORMAL=0_GDK_CROSSING_GRAB=1_GDK_CROSSING_UNGRAB=2_GDK_CROSSING_GTK_GRAB=3_GDK_CROSSING_GTK_UNGRAB=4_GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous_8 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum_GDK_DRAG_PROTO_MOTIF=0_GDK_DRAG_PROTO_XDND=1_GDK_DRAG_PROTO_ROOTWIN=2_GDK_DRAG_PROTO_NONE=3_GDK_DRAG_PROTO_WIN32_DROPFILES=4_GDK_DRAG_PROTO_OLE2=5_GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous_10 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum_GDK_FONT_FONT=0_GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous_44 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum_GDK_LSB_FIRST=0_GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous_35 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum_GDK_MODE_DISABLED=0_GDK_MODE_SCREEN=1_GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous_23 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum_GDK_NOTHING=-1_GDK_DELETE=0_GDK_DESTROY=1_GDK_EXPOSE=2_GDK_MOTION_NOTIFY=3_GDK_BUTTON_PRESS=4_GDK_2BUTTON_PRESS=5_GDK_3BUTTON_PRESS=6_GDK_BUTTON_RELEASE=7_GDK_KEY_PRESS=8_GDK_KEY_RELEASE=9_GDK_ENTER_NOTIFY=10_GDK_LEAVE_NOTIFY=11_GDK_FOCUS_CHANGE=12_GDK_CONFIGURE=13_GDK_MAP=14_GDK_UNMAP=15_GDK_PROPERTY_NOTIFY=16_GDK_SELECTION_CLEAR=17_GDK_SELECTION_REQUEST=18_GDK_SELECTION_NOTIFY=19_GDK_PROXIMITY_IN=20_GDK_PROXIMITY_OUT=21_GDK_DRAG_ENTER=22_GDK_DRAG_LEAVE=23_GDK_DRAG_MOTION=24_GDK_DRAG_STATUS=25_GDK_DROP_START=26_GDK_DROP_FINISHED=27_GDK_CLIENT_EVENT=28_GDK_VISIBILITY_NOTIFY=29_GDK_NO_EXPOSE=30_GDK_SCROLL=31_GDK_WINDOW_STATE=32_GDK_SETTING=33_GDK_OWNER_CHANGE=34_GDK_GRAB_BROKEN=35_GDK_DAMAGE=36_GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous_4 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum_GDK_NOTIFY_ANCESTOR=0_GDK_NOTIFY_VIRTUAL=1_GDK_NOTIFY_INFERIOR=2_GDK_NOTIFY_NONLINEAR=3_GDK_NOTIFY_NONLINEAR_VIRTUAL=4_GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous_9 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum_GDK_OWNER_CHANGE_NEW_OWNER=0_GDK_OWNER_CHANGE_DESTROY=1_GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous_49 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum_GDK_SCROLL_UP=0_GDK_SCROLL_DOWN=1_GDK_SCROLL_LEFT=2_GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous_6 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum_GDK_SETTING_ACTION_NEW=0_GDK_SETTING_ACTION_CHANGED=1_GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous_48 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum_GDK_SHIFT_MASK=1_GDK_LOCK_MASK=2_GDK_CONTROL_MASK=4_GDK_MOD1_MASK=8_GDK_MOD2_MASK=16_GDK_MOD3_MASK=32_GDK_MOD4_MASK=64_GDK_MOD5_MASK=128_GDK_BUTTON1_MASK=256_GDK_BUTTON2_MASK=512_GDK_BUTTON3_MASK=1024_GDK_BUTTON4_MASK=2048_GDK_BUTTON5_MASK=4096_GDK_SUPER_MASK=67108864_GDK_HYPER_MASK=134217728_GDK_META_MASK=268435456_GDK_RELEASE_MASK=1073741824_GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous_19 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum_GDK_SOURCE_MOUSE=0_GDK_SOURCE_PEN=1_GDK_SOURCE_ERASER=2_GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous_22 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum_GDK_VISIBILITY_UNOBSCURED=0_GDK_VISIBILITY_PARTIAL=1_GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous_5 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum_GDK_VISUAL_STATIC_GRAY=0_GDK_VISUAL_GRAYSCALE=1_GDK_VISUAL_STATIC_COLOR=2_GDK_VISUAL_PSEUDO_COLOR=3_GDK_VISUAL_TRUE_COLOR=4_GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous_34 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum_GDK_WINDOW_STATE_WITHDRAWN=1_GDK_WINDOW_STATE_ICONIFIED=2_GDK_WINDOW_STATE_MAXIMIZED=4_GDK_WINDOW_STATE_STICKY=8_GDK_WINDOW_STATE_FULLSCREEN=16_GDK_WINDOW_STATE_ABOVE=32_GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous_12 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum_GTK_BUTTONS_NONE=0_GTK_BUTTONS_OK=1_GTK_BUTTONS_CLOSE=2_GTK_BUTTONS_CANCEL=3_GTK_BUTTONS_YES_NO=4_GTK_BUTTONS_OK_CANCEL=5
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 89
enum anonymous_31 { GTK_BUTTONS_NONE=0, GTK_BUTTONS_OK=1, GTK_BUTTONS_CLOSE=2, GTK_BUTTONS_CANCEL=3, GTK_BUTTONS_YES_NO=4, GTK_BUTTONS_OK_CANCEL=5 };

// #anon_enum_GTK_DIALOG_MODAL=1_GTK_DIALOG_DESTROY_WITH_PARENT=2_GTK_DIALOG_NO_SEPARATOR=4
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 41
enum anonymous_29 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_NO_SEPARATOR=4 };

// #anon_enum_GTK_FILE_CHOOSER_ACTION_OPEN=0_GTK_FILE_CHOOSER_ACTION_SAVE=1_GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2_GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 56
enum anonymous_3 { GTK_FILE_CHOOSER_ACTION_OPEN=0, GTK_FILE_CHOOSER_ACTION_SAVE=1, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2, GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3 };

// #anon_enum_GTK_ICON_SIZE_INVALID=0_GTK_ICON_SIZE_MENU=1_GTK_ICON_SIZE_SMALL_TOOLBAR=2_GTK_ICON_SIZE_LARGE_TOOLBAR=3_GTK_ICON_SIZE_BUTTON=4_GTK_ICON_SIZE_DND=5_GTK_ICON_SIZE_DIALOG=6
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 142
enum anonymous_7 { GTK_ICON_SIZE_INVALID=0, GTK_ICON_SIZE_MENU=1, GTK_ICON_SIZE_SMALL_TOOLBAR=2, GTK_ICON_SIZE_LARGE_TOOLBAR=3, GTK_ICON_SIZE_BUTTON=4, GTK_ICON_SIZE_DND=5, GTK_ICON_SIZE_DIALOG=6 };

// #anon_enum_GTK_MESSAGE_INFO=0_GTK_MESSAGE_WARNING=1_GTK_MESSAGE_QUESTION=2_GTK_MESSAGE_ERROR=3_GTK_MESSAGE_OTHER=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 221
enum anonymous_30 { GTK_MESSAGE_INFO=0, GTK_MESSAGE_WARNING=1, GTK_MESSAGE_QUESTION=2, GTK_MESSAGE_ERROR=3, GTK_MESSAGE_OTHER=4 };

// #anon_enum_GTK_ORIENTATION_HORIZONTAL=0_GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 262
enum anonymous_41 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum_GTK_POLICY_ALWAYS=0_GTK_POLICY_AUTOMATIC=1_GTK_POLICY_NEVER=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 305
enum anonymous_13 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2 };

// #anon_enum_GTK_RC_FG=1_GTK_RC_BG=2_GTK_RC_TEXT=4_GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous_46 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum_GTK_SELECTION_NONE=0_GTK_SELECTION_SINGLE=1_GTK_SELECTION_BROWSE=2_GTK_SELECTION_MULTIPLE=3_GTK_SELECTION_EXTENDED=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 379
enum anonymous_2 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3, GTK_SELECTION_EXTENDED=3 };

// #anon_enum_GTK_SORT_ASCENDING=0_GTK_SORT_DESCENDING=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 476
enum anonymous_15 { GTK_SORT_ASCENDING=0, GTK_SORT_DESCENDING=1 };

// #anon_enum_GTK_TREE_VIEW_COLUMN_GROW_ONLY=0_GTK_TREE_VIEW_COLUMN_AUTOSIZE=1_GTK_TREE_VIEW_COLUMN_FIXED=2
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 45
enum anonymous_1 { GTK_TREE_VIEW_COLUMN_GROW_ONLY=0, GTK_TREE_VIEW_COLUMN_AUTOSIZE=1, GTK_TREE_VIEW_COLUMN_FIXED=2 };

// #anon_enum_GTK_UPDATE_ALWAYS=0_GTK_UPDATE_IF_VALID=1
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 53
enum anonymous_18 { GTK_UPDATE_ALWAYS=0, GTK_UPDATE_IF_VALID=1 };

// #anon_enum_GTK_UPDATE_CONTINUOUS=0_GTK_UPDATE_DISCONTINUOUS=1_GTK_UPDATE_DELAYED=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 434
enum anonymous_39 { GTK_UPDATE_CONTINUOUS=0, GTK_UPDATE_DISCONTINUOUS=1, GTK_UPDATE_DELAYED=2 };

// #anon_enum_GTK_WINDOW_TOPLEVEL=0_GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous_36 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum_G_CONNECT_AFTER=1_G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous_24 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum_G_LOG_FLAG_RECURSION=1_G_LOG_FLAG_FATAL=2_G_LOG_LEVEL_ERROR=4_G_LOG_LEVEL_CRITICAL=8_G_LOG_LEVEL_WARNING=16_G_LOG_LEVEL_MESSAGE=32_G_LOG_LEVEL_INFO=64_G_LOG_LEVEL_DEBUG=128_G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous_50 { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// #anon_enum_G_OPTION_ARG_NONE=0_G_OPTION_ARG_STRING=1_G_OPTION_ARG_INT=2_G_OPTION_ARG_CALLBACK=3_G_OPTION_ARG_FILENAME=4_G_OPTION_ARG_STRING_ARRAY=5_G_OPTION_ARG_FILENAME_ARRAY=6_G_OPTION_ARG_DOUBLE=7_G_OPTION_ARG_INT64=8
// file /usr/include/glib-2.0/glib/goption.h line 118
enum anonymous_0 { G_OPTION_ARG_NONE=0, G_OPTION_ARG_STRING=1, G_OPTION_ARG_INT=2, G_OPTION_ARG_CALLBACK=3, G_OPTION_ARG_FILENAME=4, G_OPTION_ARG_STRING_ARRAY=5, G_OPTION_ARG_FILENAME_ARRAY=6, G_OPTION_ARG_DOUBLE=7, G_OPTION_ARG_INT64=8 };

// #anon_enum_PLAYING=0_PAUSED=1_STOPPED=2
// file player.h line 32
enum anonymous_16 { PLAYING=0, PAUSED=1, STOPPED=2 };

// #anon_enum_READER_RESUME=0_READER_RUNNING=1_READER_STOP=2_READER_STOPPED=3_READER_TERM=4
// file player.c line 91
enum anonymous_40 { READER_RESUME=0, READER_RUNNING=1, READER_STOP=2, READER_STOPPED=3, READER_TERM=4 };

// #anon_enum_SAMPLE_A=0_SAMPLE_B=1_SAMPLE_NA=2
// file test.h line 27
enum anonymous_14 { SAMPLE_A=0, SAMPLE_B=1, SAMPLE_NA=2 };

// tag-#anon#ST[*{F32}_F32_'begin'||*{F32}_F32_'end'||*{F32}_F32_'in'||*{F32}_F32_'out'||S32'bufsize'||S32'nframes'||SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#'prefill'||SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#'space'||S32'prefill_sem_ok'||S32'space_sem_ok'|]
// file player.c line 75
struct anonymous_26;

// tag-#anon#ST[*{S8}_S8_'filename'||S32'bits'||S32'channels'||S32'frames'||S32'rate'||F64'duration'||U32'minutes'||U32'seconds'|]
// file soundfile.h line 25
struct anonymous_32;

// tag-#anon#ST[EN#anon_enum_CMD_PAUSE=0_CMD_PLAY=1_CMD_SEEK=2_CMD_STOP=3_CMD_TERM=4#{U32}_U32_'command'||U32'_pad0'||F64'offset'||S32'whence'||U32'_pad1'||*{SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#}_SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#_'sem'|]
// file player.c line 54
struct anonymous_38;

// tag-#anon#ST[EN#anon_enum_PLAYING=0_PAUSED=1_STOPPED=2#{U32}_U32_'playback'||U32'_pad0'||F64'location'|]
// file player.h line 31
struct anonymous_17;

// tag-#anon#ST[EN#anon_enum_READER_RESUME=0_READER_RUNNING=1_READER_STOP=2_READER_STOPPED=3_READER_TERM=4#{U32}_U32_'control'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'control_cond'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'control_cond_mutex'||U64'thread_id'||S32'thread_ok'||U32'_pad1'||SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#'sem'||SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]#'notify'||S32'sem_ok'||S32'notify_ok'||*{SYM#tag-Sound_file#}_SYM#tag-Sound_file#_'sndfile'||SYM#tag-#anon#ST[*{S8}_S8_'filename'||S32'bits'||S32'channels'||S32'frames'||S32'rate'||F64'duration'||U32'minutes'||U32'seconds'|]#'metadata'||S8'is_eof'||U56'_pad2'|]
// file player.c line 89
struct anonymous_27;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_42;

// tag-#anon#ST[S8'isvalid'||U24'_pad0'||U32'ntrials'||*{EN#anon_enum_SAMPLE_A=0_SAMPLE_B=1_SAMPLE_NA=2#{U32}_U32_}_EN#anon_enum_SAMPLE_A=0_SAMPLE_B=1_SAMPLE_NA=2#{U32}_U32__'answers'||*{EN#anon_enum_SAMPLE_A=0_SAMPLE_B=1_SAMPLE_NA=2#{U32}_U32_}_EN#anon_enum_SAMPLE_A=0_SAMPLE_B=1_SAMPLE_NA=2#{U32}_U32__'guesses'|]
// file test.c line 28
struct anonymous_33;

// tag-#anon#ST[U64'thread_id'||U64'thread_ok'||*{SYM#tag-_GAsyncQueue#}_SYM#tag-_GAsyncQueue#_'messages'|]
// file player.c line 115
struct anonymous_28;

// tag-#anon#UN[ARR20{S8}_S8_'b'||ARR10{S16}_S16_'s'||ARR5{S64}_S64_'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous;

// tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous_25;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_47;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}_V_'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous_21;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_43;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_45;

// tag-PaDeviceInfo
// file /usr/include/portaudio.h line 449
struct PaDeviceInfo;

// tag-PaHostApiInfo
// file /usr/include/portaudio.h line 245
struct PaHostApiInfo;

// tag-PaHostApiTypeId
// file /usr/include/portaudio.h line 224
enum PaHostApiTypeId { paInDevelopment=0, paDirectSound=1, paMME=2, paASIO=3, paSoundManager=4, paCoreAudio=5, paOSS=7, paALSA=8, paAL=9, paBeOS=10, paWDMKS=11, paJACK=12, paWASAPI=13, paAudioScienceHPI=14 };

// tag-PaStreamCallbackTimeInfo
// file /usr/include/portaudio.h line 648
struct PaStreamCallbackTimeInfo;

// tag-PaStreamParameters
// file /usr/include/portaudio.h line 487
struct PaStreamParameters;

// tag-Player
// file player.h line 28
struct Player;

// tag-SF_INFO
// file /usr/include/sndfile.h line 328
struct SF_INFO;

// tag-SNDFILE_tag
// file /usr/include/sndfile.h line 305
struct SNDFILE_tag;

// tag-Sound_file
// file soundfile.h line 38
struct Sound_file;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GAsyncQueue
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 36
struct _GAsyncQueue;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GOptionContext
// file /usr/include/glib-2.0/glib/goption.h line 38
struct _GOptionContext;

// tag-_GOptionEntry
// file /usr/include/glib-2.0/glib/goption.h line 52
struct _GOptionEntry;

// tag-_GOptionGroup
// file /usr/include/glib-2.0/glib/goption.h line 51
struct _GOptionGroup;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GtkAccelGroup
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 60
struct _GtkAccelGroup;

// tag-_GtkAccelGroupEntry
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 63
struct _GtkAccelGroupEntry;

// tag-_GtkAccelKey
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 62
struct _GtkAccelKey;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkCellEditable
// file /usr/include/gtk-2.0/gtk/gtkcelleditable.h line 37
struct _GtkCellEditable;

// tag-_GtkCellRenderer
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 55
struct _GtkCellRenderer;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkEntry
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 63
struct _GtkEntry;

// tag-_GtkFileChooser
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 37
struct _GtkFileChooser;

// tag-_GtkHBox
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 48
struct _GtkHBox;

// tag-_GtkIMContext
// file /usr/include/gtk-2.0/gtk/gtkimcontext.h line 42
struct _GtkIMContext;

// tag-_GtkItem
// file /usr/include/gtk-2.0/gtk/gtkitem.h line 48
struct _GtkItem;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkListStore
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 42
struct _GtkListStore;

// tag-_GtkMenuBar
// file /usr/include/gtk-2.0/gtk/gtkmenubar.h line 48
struct _GtkMenuBar;

// tag-_GtkMenuItem
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 48
struct _GtkMenuItem;

// tag-_GtkMenuShell
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 48
struct _GtkMenuShell;

// tag-_GtkMessageDialog
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 47
struct _GtkMessageDialog;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkRange
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 53
struct _GtkRange;

// tag-_GtkRangeLayout
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 50
struct _GtkRangeLayout;

// tag-_GtkRangeStepTimer
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 51
struct _GtkRangeStepTimer;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSpinButton
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 71
struct _GtkSpinButton;

// tag-_GtkStatusbar
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 47
struct _GtkStatusbar;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkTreeIter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 43
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 46
struct _GtkTreeModel;

// tag-_GtkTreePath
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 44
struct _GtkTreePath;

// tag-_GtkTreeSelection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 58
struct _GtkTreeSelection;

// tag-_GtkTreeView
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 55
struct _GtkTreeView;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 52
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 57
struct _GtkTreeViewPrivate;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// Pa_CloseStream
// file /usr/include/portaudio.h line 894
signed int Pa_CloseStream(void *);
// Pa_GetDeviceCount
// file /usr/include/portaudio.h line 371
signed int Pa_GetDeviceCount(void);
// Pa_GetDeviceInfo
// file /usr/include/portaudio.h line 482
const struct PaDeviceInfo * Pa_GetDeviceInfo(signed int);
// Pa_GetErrorText
// file /usr/include/portaudio.h line 110
const char * Pa_GetErrorText(signed int);
// Pa_GetHostApiInfo
// file /usr/include/portaudio.h line 289
const struct PaHostApiInfo * Pa_GetHostApiInfo(signed int);
// Pa_Initialize
// file /usr/include/portaudio.h line 132
signed int Pa_Initialize(void);
// Pa_OpenStream
// file /usr/include/portaudio.h line 841
signed int Pa_OpenStream(void **, const struct PaStreamParameters *, const struct PaStreamParameters *, double, unsigned long int, unsigned long int, signed int (*)(const void *, void *, unsigned long int, const struct PaStreamCallbackTimeInfo *, unsigned long int, void *), void *);
// Pa_SetStreamFinishedCallback
// file /usr/include/portaudio.h line 932
signed int Pa_SetStreamFinishedCallback(void *, void (*)(void *));
// Pa_StartStream
// file /usr/include/portaudio.h line 937
signed int Pa_StartStream(void *);
// Pa_StopStream
// file /usr/include/portaudio.h line 943
signed int Pa_StopStream(void *);
// Pa_Terminate
// file /usr/include/portaudio.h line 151
signed int Pa_Terminate(void);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// add_marker_clicked
// file mainwin.c line 543
static void add_marker_clicked(struct _GtkWidget *widget, void *data);
// button_clicked
// file newtestwin.c line 103
static void button_clicked(struct _GtkWidget *button, void *data);
// calculate_p_value
// file test.h line 37
extern double calculate_p_value(void);
// cdf_binomial
// file test.c line 181
static double cdf_binomial(unsigned int k, unsigned int n, double p);
// clear_status_bar
// file mainwin.c line 195
static void clear_status_bar(void);
// close_clicked
// file resultwin.c line 43
static void close_clicked(struct _GtkWidget *button, void *data);
// close_playback
// file playback.c line 88
extern void close_playback(void);
// close_player
// file player.h line 37
extern void close_player(struct Player *player);
// close_sound_file
// file soundfile.h line 41
extern signed int close_sound_file(struct Sound_file *sndfile);
// close_test
// file test.h line 31
extern void close_test(void);
// controller_main
// file player.c line 448
static void * controller_main(void *arg);
// create_main_window
// file mainwin.c line 206
static void create_main_window(void);
// create_marker_box
// file mainwin.c line 331
static struct _GtkWidget * create_marker_box(void);
// create_menu_bar
// file mainwin.c line 431
static struct _GtkWidget * create_menu_bar(void);
// create_metadata_box
// file mainwin.c line 410
static struct _GtkWidget * create_metadata_box(void);
// create_new_test_window
// file newtestwin.c line 114
static void create_new_test_window(void);
// create_play_button
// file mainwin.c line 249
static struct _GtkWidget * create_play_button(char *label);
// create_playback_box
// file mainwin.c line 268
static struct _GtkWidget * create_playback_box(void);
// create_status_bar
// file mainwin.c line 477
static void create_status_bar(void);
// create_test_box
// file mainwin.c line 393
static struct _GtkWidget * create_test_box(void);
// decide_button_clicked
// file mainwin.c line 621
static void decide_button_clicked(struct _GtkWidget *widget, void *data);
// delete_event_handler
// file newtestwin.c line 96
static signed int delete_event_handler(struct _GtkWidget *widget, union _GdkEvent *event, void *data);
// delete_event_handler_link1
// file resultwin.c line 36
static signed int delete_event_handler_link1(struct _GtkWidget *widget_link1, union _GdkEvent *event_link1, void *data_link1);
// destroy_event_handler
// file mainwin.c line 497
static void destroy_event_handler(struct _GtkWidget *widget, void *data);
// error_dialog
// file gtkui.c line 123
extern void error_dialog(struct _GtkWidget *parent_win, char *msg);
// g_async_queue_new
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 39
extern struct _GAsyncQueue * g_async_queue_new(void);
// g_async_queue_pop
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 74
extern void * g_async_queue_pop(struct _GAsyncQueue *);
// g_async_queue_push
// file /usr/include/glib-2.0/glib/gasyncqueue.h line 58
extern void g_async_queue_push(struct _GAsyncQueue *, void *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous_50, const char *, ...);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_object_set
// file /usr/include/glib-2.0/gobject/gobject.h line 432
extern void g_object_set(void *, const char *, ...);
// g_option_context_add_group
// file /usr/include/glib-2.0/glib/goption.h line 342
extern void g_option_context_add_group(struct _GOptionContext *, struct _GOptionGroup *);
// g_option_context_add_main_entries
// file /usr/include/glib-2.0/glib/goption.h line 320
extern void g_option_context_add_main_entries(struct _GOptionContext *, const struct _GOptionEntry *, const char *);
// g_option_context_new
// file /usr/include/glib-2.0/glib/goption.h line 289
extern struct _GOptionContext * g_option_context_new(const char *);
// g_option_context_parse
// file /usr/include/glib-2.0/glib/goption.h line 324
extern signed int g_option_context_parse(struct _GOptionContext *, signed int *, char ***, struct _GError **);
// g_option_context_set_description
// file /usr/include/glib-2.0/glib/goption.h line 296
extern void g_option_context_set_description(struct _GOptionContext *, const char *);
// g_option_context_set_summary
// file /usr/include/glib-2.0/glib/goption.h line 291
extern void g_option_context_set_summary(struct _GOptionContext *, const char *);
// g_path_get_basename
// file /usr/include/glib-2.0/glib/gfileutils.h line 176
extern char * g_path_get_basename(const char *);
// g_random_int
// file /usr/include/glib-2.0/glib/grand.h line 86
extern unsigned int g_random_int(void);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous_24);
// g_source_remove
// file /usr/include/glib-2.0/glib/gmain.h line 545
extern signed int g_source_remove(unsigned int);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_string_append
// file /usr/include/glib-2.0/glib/gstring.h line 80
extern struct _GString * g_string_append(struct _GString *, const char *);
// g_string_new
// file /usr/include/glib-2.0/glib/gstring.h line 49
extern struct _GString * g_string_new(const char *);
// g_string_printf
// file /usr/include/glib-2.0/glib/gstring.h line 140
extern void g_string_printf(struct _GString *, const char *, ...);
// g_thread_init
// file /usr/include/glib-2.0/glib/deprecated/gthread.h line 265
extern void g_thread_init(void *);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// get_answer
// file test.h line 34
extern enum anonymous_14 get_answer(unsigned int t);
// get_guess
// file test.h line 35
extern enum anonymous_14 get_guess(unsigned int t);
// get_metadata
// file soundfile.h line 42
extern struct anonymous_32 get_metadata(struct Sound_file *sndfile);
// get_metadatas
// file playback.h line 31
extern void get_metadatas(struct anonymous_32 *a, struct anonymous_32 *b);
// get_playback_state
// file playback.h line 32
extern signed int get_playback_state(struct anonymous_17 *state);
// get_player_metadata
// file player.h line 39
extern struct anonymous_32 get_player_metadata(struct Player *player);
// get_player_state
// file player.h line 40
extern struct anonymous_17 get_player_state(struct Player *player);
// gtk_adjustment_get_type
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 78
unsigned long int gtk_adjustment_get_type(void);
// gtk_adjustment_get_value
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 92
double gtk_adjustment_get_value(struct _GtkAdjustment *);
// gtk_adjustment_new
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 79
struct _GtkObject * gtk_adjustment_new(double, double, double, double, double, double);
// gtk_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 104
unsigned long int gtk_box_get_type(void);
// gtk_box_pack_end
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 114
void gtk_box_pack_end(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 109
void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_button_new
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 92
struct _GtkWidget * gtk_button_new(void);
// gtk_button_new_from_stock
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 94
struct _GtkWidget * gtk_button_new_from_stock(const char *);
// gtk_button_new_with_mnemonic
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 95
struct _GtkWidget * gtk_button_new_with_mnemonic(const char *);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 97
struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_container_set_border_width
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 108
void gtk_container_set_border_width(struct _GtkContainer *, unsigned int);
// gtk_dialog_add_button
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 139
struct _GtkWidget * gtk_dialog_add_button(struct _GtkDialog *, const char *, signed int);
// gtk_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 127
unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_run
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 175
signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_file_chooser_button_new
// file /usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h line 70
struct _GtkWidget * gtk_file_chooser_button_new(const char *, enum anonymous_3);
// gtk_file_chooser_get_filename
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 163
char * gtk_file_chooser_get_filename(struct _GtkFileChooser *);
// gtk_file_chooser_get_type
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 88
unsigned long int gtk_file_chooser_get_type(void);
// gtk_get_option_group
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 107
struct _GOptionGroup * gtk_get_option_group(signed int);
// gtk_hbox_new
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 63
struct _GtkWidget * gtk_hbox_new(signed int, signed int);
// gtk_hscale_new
// file /usr/include/gtk-2.0/gtk/gtkhscale.h line 63
struct _GtkWidget * gtk_hscale_new(struct _GtkAdjustment *);
// gtk_image_menu_item_new_from_stock
// file /usr/include/gtk-2.0/gtk/gtkimagemenuitem.h line 70
struct _GtkWidget * gtk_image_menu_item_new_from_stock(const char *, struct _GtkAccelGroup *);
// gtk_image_new_from_stock
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 199
struct _GtkWidget * gtk_image_new_from_stock(const char *, enum anonymous_7);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_new_with_mnemonic
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 111
struct _GtkWidget * gtk_label_new_with_mnemonic(const char *);
// gtk_label_set_markup
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 121
void gtk_label_set_markup(struct _GtkLabel *, const char *);
// gtk_label_set_mnemonic_widget
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 133
void gtk_label_set_mnemonic_widget(struct _GtkLabel *, struct _GtkWidget *);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_list_store_append
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 126
void gtk_list_store_append(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_clear
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 128
void gtk_list_store_clear(struct _GtkListStore *);
// gtk_list_store_new
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 78
struct _GtkListStore * gtk_list_store_new(signed int, ...);
// gtk_list_store_remove
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 103
signed int gtk_list_store_remove(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_set
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 92
void gtk_list_store_set(struct _GtkListStore *, struct _GtkTreeIter *, ...);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_menu_bar_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenubar.h line 68
unsigned long int gtk_menu_bar_get_type(void);
// gtk_menu_bar_new
// file /usr/include/gtk-2.0/gtk/gtkmenubar.h line 69
struct _GtkWidget * gtk_menu_bar_new(void);
// gtk_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 99
unsigned long int gtk_menu_item_get_type(void);
// gtk_menu_item_new_with_mnemonic
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 102
struct _GtkWidget * gtk_menu_item_new_with_mnemonic(const char *);
// gtk_menu_item_set_submenu
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 103
void gtk_menu_item_set_submenu(struct _GtkMenuItem *, struct _GtkWidget *);
// gtk_menu_new
// file /usr/include/gtk-2.0/gtk/gtkmenu.h line 126
struct _GtkWidget * gtk_menu_new(void);
// gtk_menu_shell_append
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 101
void gtk_menu_shell_append(struct _GtkMenuShell *, struct _GtkWidget *);
// gtk_menu_shell_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 100
unsigned long int gtk_menu_shell_get_type(void);
// gtk_message_dialog_format_secondary_text
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 123
void gtk_message_dialog_format_secondary_text(struct _GtkMessageDialog *, const char *, ...);
// gtk_message_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 99
unsigned long int gtk_message_dialog_get_type(void);
// gtk_message_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 101
struct _GtkWidget * gtk_message_dialog_new(struct _GtkWindow *, enum anonymous_29, enum anonymous_30, enum anonymous_31, const char *, ...);
// gtk_range_get_type
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 136
unsigned long int gtk_range_get_type(void);
// gtk_range_set_update_policy
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 139
void gtk_range_set_update_policy(struct _GtkRange *, enum anonymous_39);
// gtk_range_set_value
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 183
void gtk_range_set_value(struct _GtkRange *, double);
// gtk_scrolled_window_add_with_viewport
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 127
void gtk_scrolled_window_add_with_viewport(struct _GtkScrolledWindow *, struct _GtkWidget *);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_new
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 103
struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 113
void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous_13, enum anonymous_13);
// gtk_show_about_dialog
// file /usr/include/gtk-2.0/gtk/gtkaboutdialog.h line 75
void gtk_show_about_dialog(struct _GtkWindow *, const char *, ...);
// gtk_spin_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 123
unsigned long int gtk_spin_button_get_type(void);
// gtk_spin_button_get_value_as_int
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 163
signed int gtk_spin_button_get_value_as_int(struct _GtkSpinButton *);
// gtk_spin_button_new
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 130
struct _GtkWidget * gtk_spin_button_new(struct _GtkAdjustment *, double, unsigned int);
// gtk_statusbar_get_context_id
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 94
unsigned int gtk_statusbar_get_context_id(struct _GtkStatusbar *, const char *);
// gtk_statusbar_get_type
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 89
unsigned long int gtk_statusbar_get_type(void);
// gtk_statusbar_new
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 90
struct _GtkWidget * gtk_statusbar_new(void);
// gtk_statusbar_pop
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 100
void gtk_statusbar_pop(struct _GtkStatusbar *, unsigned int);
// gtk_statusbar_push
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 97
unsigned int gtk_statusbar_push(struct _GtkStatusbar *, unsigned int, const char *);
// gtk_tree_model_get
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 234
void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 198
signed int gtk_tree_model_get_iter(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreePath *);
// gtk_tree_model_get_path
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 208
struct _GtkTreePath * gtk_tree_model_get_path(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 190
unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_path_free
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 139
void gtk_tree_path_free(struct _GtkTreePath *);
// gtk_tree_path_next
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 144
void gtk_tree_path_next(struct _GtkTreePath *);
// gtk_tree_path_prev
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 145
signed int gtk_tree_path_prev(struct _GtkTreePath *);
// gtk_tree_selection_get_selected
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 92
signed int gtk_tree_selection_get_selected(struct _GtkTreeSelection *, struct _GtkTreeModel **, struct _GtkTreeIter *);
// gtk_tree_selection_select_path
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 101
void gtk_tree_selection_select_path(struct _GtkTreeSelection *, struct _GtkTreePath *);
// gtk_tree_view_append_column
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 167
signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_new_with_attributes
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 128
struct _GtkTreeViewColumn * gtk_tree_view_column_new_with_attributes(const char *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_get_selection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 148
struct _GtkTreeSelection * gtk_tree_view_get_selection(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 140
unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_new_with_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 142
struct _GtkWidget * gtk_tree_view_new_with_model(struct _GtkTreeModel *);
// gtk_vbox_new
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 63
struct _GtkWidget * gtk_vbox_new(signed int, signed int);
// gtk_widget_destroy
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 837
void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_hide_all
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 848
void gtk_widget_hide_all(struct _GtkWidget *);
// gtk_widget_show_all
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 854
void gtk_widget_show_all(struct _GtkWidget *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous_36);
// gtk_window_present
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 330
void gtk_window_present(struct _GtkWindow *);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// hide_decide_dialog
// file decidewin.c line 84
extern void hide_decide_dialog(void);
// hide_result_window
// file gtkui.h line 52
extern void hide_result_window(void);
// init_new_test
// file newtestwin.c line 45
static void init_new_test(void);
// init_playback
// file playback.c line 46
extern signed int init_playback(const char *a, const char *b, signed int outdev);
// init_player
// file player.h line 36
extern struct Player * init_player(const char *filename, signed int outdev);
// init_test
// file test.h line 29
extern signed int init_test(const char *a, const char *b, unsigned int ntrials, signed int outdev);
// is_test_valid
// file test.c line 109
extern signed int is_test_valid(void);
// marker_activated
// file mainwin.c line 503
static void marker_activated(struct _GtkTreeView *markers, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// menu_item_clicked
// file mainwin.c line 578
static void menu_item_clicked(struct _GtkWidget *widget, void *data);
// num_test_trials
// file test.h line 33
extern signed int num_test_trials(void);
// open_sound_file
// file soundfile.h line 40
extern struct Sound_file * open_sound_file(const char *filename);
// parse_options
// file gtkui.c line 40
static void parse_options(signed int *argc, char ***argv);
// pause_button_clicked
// file mainwin.c line 690
static void pause_button_clicked(struct _GtkWidget *widget, void *data);
// pause_or_resume_playback
// file playback.h line 36
extern signed int pause_or_resume_playback(void);
// pause_or_resume_player
// file player.h line 44
extern void pause_or_resume_player(struct Player *player, union anonymous_25 *sem);
// play_button_clicked
// file mainwin.c line 634
static void play_button_clicked(struct _GtkWidget *widget, void *data);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_43 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_43 *, const union anonymous_47 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_43 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_43 *, union anonymous_45 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_45 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_45 *, const union anonymous_47 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_45 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_45 *);
// read_pcm_data
// file soundfile.h line 45
extern unsigned int read_pcm_data(struct Sound_file *sndfile, float *buf, unsigned int nframes);
// reader_main
// file player.c line 154
static void * reader_main(void *arg);
// recurrent_update_location
// file mainwin.c line 170
static signed int recurrent_update_location(void *data);
// remove_marker_clicked
// file mainwin.c line 564
static void remove_marker_clicked(struct _GtkWidget *widget, void *data);
// reset_test
// file gtkui.c line 141
extern void reset_test(void);
// response_handler
// file decidewin.c line 31
static void response_handler(struct _GtkWidget *widget, signed int response, void *data);
// resume_reader_thread
// file player.c line 321
static signed int resume_reader_thread(struct Player *player);
// rewind_button_clicked
// file mainwin.c line 710
static void rewind_button_clicked(struct _GtkWidget *widget, void *data);
// scale_button_pressed_or_released
// file mainwin.c line 523
static signed int scale_button_pressed_or_released(struct _GtkWidget *widget, struct _GdkEventButton *event, void *data);
// scan_audio_output
// file player.c line 595
static signed int scan_audio_output(void);
// seek
// file player.c line 380
static double seek(struct Player *player, double offset, signed int whence);
// seek_playback
// file playback.h line 37
extern void seek_playback(double offset);
// seek_player
// file player.h line 45
extern void seek_player(struct Player *player, double offset, signed int whence, union anonymous_25 *sem);
// seek_sound_file
// file soundfile.h line 43
extern double seek_sound_file(struct Sound_file *sndfile, double offset, signed int whence);
// sem_destroy
// file /usr/include/semaphore.h line 39
extern signed int sem_destroy(union anonymous_25 *);
// sem_getvalue
// file /usr/include/semaphore.h line 72
extern signed int sem_getvalue(union anonymous_25 *, signed int *);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous_25 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous_25 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous_25 *);
// set_guess
// file test.h line 36
extern signed int set_guess(unsigned int t, enum anonymous_14 ans);
// sf_close
// file /usr/include/sndfile.h line 632
signed int sf_close(struct SNDFILE_tag *);
// sf_open
// file /usr/include/sndfile.h line 485
struct SNDFILE_tag * sf_open(const char *, signed int, struct SF_INFO *);
// sf_readf_float
// file /usr/include/sndfile.h line 602
signed long int sf_readf_float(struct SNDFILE_tag *, float *, signed long int);
// sf_seek
// file /usr/include/sndfile.h line 558
signed long int sf_seek(struct SNDFILE_tag *, signed long int, signed int);
// show_decide_dialog
// file decidewin.c line 61
extern void show_decide_dialog(struct _GtkWindow *parent);
// show_main_window
// file gtkui.h line 40
extern void show_main_window(void);
// show_new_test_window
// file gtkui.h line 48
extern void show_new_test_window(void);
// show_result_window
// file gtkui.h line 51
extern void show_result_window(void);
// start_playback
// file playback.h line 34
extern void start_playback(signed int sample, double location);
// start_player
// file player.h line 42
extern void start_player(struct Player *player, union anonymous_25 *sem);
// stop_playback
// file playback.h line 35
extern void stop_playback(void);
// stop_player
// file player.h line 43
extern void stop_player(struct Player *player, union anonymous_25 *sem);
// stop_reader_thread
// file player.c line 282
static signed int stop_reader_thread(struct Player *player);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// stream_callback
// file player.c line 518
static signed int stream_callback(const void *input, void *output, unsigned long int nframes, const struct PaStreamCallbackTimeInfo *timeinfo, unsigned long int statusflags, void *userdata);
// stream_finished_callback
// file player.c line 584
static void stream_finished_callback(void *userdata);
// terminate_reader_thread
// file player.c line 352
static void terminate_reader_thread(struct Player *player);
// ui_main
// file gtkui.h line 35
extern void ui_main(signed int argc, char **argv);
// update_location
// file mainwin.c line 150
static void update_location(void);
// update_main_window
// file gtkui.h line 41
extern void update_main_window(void);

union anonymous_25
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

struct anonymous_26
{
  // begin
  float *begin;
  // end
  float *end;
  // in
  float *in;
  // out
  float *out;
  // bufsize
  signed int bufsize;
  // nframes
  signed int nframes;
  // prefill
  union anonymous_25 prefill;
  // space
  union anonymous_25 space;
  // prefill_sem_ok
  signed int prefill_sem_ok;
  // space_sem_ok
  signed int space_sem_ok;
};

struct anonymous_32
{
  // filename
  char *filename;
  // bits
  signed int bits;
  // channels
  signed int channels;
  // frames
  signed int frames;
  // rate
  signed int rate;
  // duration
  double duration;
  // minutes
  unsigned int minutes;
  // seconds
  unsigned int seconds;
};

struct anonymous_38
{
  // command
  enum anonymous_37 command;
  // offset
  double offset;
  // whence
  signed int whence;
  // sem
  union anonymous_25 *sem;
};

struct anonymous_17
{
  // playback
  enum anonymous_16 playback;
  // location
  double location;
};

struct anonymous_42
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_43
{
  // __data
  struct anonymous_42 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_45
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_27
{
  // control
  enum anonymous_40 control;
  // control_cond
  union anonymous_43 control_cond;
  // control_cond_mutex
  union anonymous_45 control_cond_mutex;
  // thread_id
  unsigned long int thread_id;
  // thread_ok
  signed int thread_ok;
  // sem
  union anonymous_25 sem;
  // notify
  union anonymous_25 notify;
  // sem_ok
  signed int sem_ok;
  // notify_ok
  signed int notify_ok;
  // sndfile
  struct Sound_file *sndfile;
  // metadata
  struct anonymous_32 metadata;
  // is_eof
  char is_eof;
};

struct anonymous_33
{
  // isvalid
  char isvalid;
  // ntrials
  unsigned int ntrials;
  // answers
  enum anonymous_14 *answers;
  // guesses
  enum anonymous_14 *guesses;
};

struct anonymous_28
{
  // thread_id
  unsigned long int thread_id;
  // thread_ok
  unsigned long int thread_ok;
  // messages
  struct _GAsyncQueue *messages;
};

union anonymous
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

union anonymous_47
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_21
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct PaDeviceInfo
{
  // structVersion
  signed int structVersion;
  // name
  const char *name;
  // hostApi
  signed int hostApi;
  // maxInputChannels
  signed int maxInputChannels;
  // maxOutputChannels
  signed int maxOutputChannels;
  // defaultLowInputLatency
  double defaultLowInputLatency;
  // defaultLowOutputLatency
  double defaultLowOutputLatency;
  // defaultHighInputLatency
  double defaultHighInputLatency;
  // defaultHighOutputLatency
  double defaultHighOutputLatency;
  // defaultSampleRate
  double defaultSampleRate;
};

struct PaHostApiInfo
{
  // structVersion
  signed int structVersion;
  // type
  enum PaHostApiTypeId type;
  // name
  const char *name;
  // deviceCount
  signed int deviceCount;
  // defaultInputDevice
  signed int defaultInputDevice;
  // defaultOutputDevice
  signed int defaultOutputDevice;
};

struct PaStreamCallbackTimeInfo
{
  // inputBufferAdcTime
  double inputBufferAdcTime;
  // currentTime
  double currentTime;
  // outputBufferDacTime
  double outputBufferDacTime;
};

struct PaStreamParameters
{
  // device
  signed int device;
  // channelCount
  signed int channelCount;
  // sampleFormat
  unsigned long int sampleFormat;
  // suggestedLatency
  double suggestedLatency;
  // hostApiSpecificStreamInfo
  void *hostApiSpecificStreamInfo;
};

struct Player
{
  // buffer
  struct anonymous_26 buffer;
  // reader
  struct anonymous_27 reader;
  // controller
  struct anonymous_28 controller;
  // state
  struct anonymous_17 state;
  // origin
  double origin;
  // nplayed
  signed int nplayed;
  // stream
  void *stream;
};

struct SF_INFO
{
  // frames
  signed long int frames;
  // samplerate
  signed int samplerate;
  // channels
  signed int channels;
  // format
  signed int format;
  // sections
  signed int sections;
  // seekable
  signed int seekable;
};

struct Sound_file
{
  // sffile
  struct SNDFILE_tag *sffile;
  // metadata
  struct anonymous_32 metadata;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GOptionEntry
{
  // long_name
  const char *long_name;
  // short_name
  char short_name;
  // flags
  signed int flags;
  // arg
  enum anonymous_0 arg;
  // arg_data
  void *arg_data;
  // description
  const char *description;
  // arg_description
  const char *arg_description;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous_21 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous_22 source;
  // mode
  enum anonymous_23 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous_20 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous_19 modifiers;
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous_10 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous_11 actions;
  // suggested_action
  enum anonymous_11 suggested_action;
  // action
  enum anonymous_11 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkEventAny
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventExpose
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous_5 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous_6 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous_8 mode;
  // detail
  enum anonymous_9 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous_49 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous data;
};

struct _GdkEventDND
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous_12 changed_mask;
  // new_window_state
  enum anonymous_12 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous_48 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous_4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous_4 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous_44 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous_34 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous_35 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GtkAccelGroup
{
  // parent
  struct _GObject parent;
  // lock_count
  unsigned int lock_count;
  // modifier_mask
  enum anonymous_19 modifier_mask;
  // acceleratables
  struct _GSList *acceleratables;
  // n_accels
  unsigned int n_accels;
  // priv_accels
  struct _GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelKey
{
  // accel_key
  unsigned int accel_key;
  // accel_mods
  enum anonymous_19 accel_mods;
  // accel_flags
  unsigned int accel_flags : 16;
};

struct _GtkAccelGroupEntry
{
  // key
  struct _GtkAccelKey key;
  // closure
  struct _GClosure *closure;
  // accel_path_quark
  unsigned int accel_path_quark;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkCellRenderer
{
  // parent
  struct _GtkObject parent;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // width
  signed int width;
  // height
  signed int height;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
  // mode
  unsigned int mode : 2;
  // visible
  unsigned int visible : 1;
  // is_expander
  unsigned int is_expander : 1;
  // is_expanded
  unsigned int is_expanded : 1;
  // cell_background_set
  unsigned int cell_background_set : 1;
  // sensitive
  unsigned int sensitive : 1;
  // editing
  unsigned int editing : 1;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous_19 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkEntry
{
  // widget
  struct _GtkWidget widget;
  // text
  char *text;
  // editable
  unsigned int editable : 1;
  // visible
  unsigned int visible : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // in_drag
  unsigned int in_drag : 1;
  // text_length
  unsigned short int text_length;
  // text_max_length
  unsigned short int text_max_length;
  // text_area
  struct _GdkDrawable *text_area;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // current_pos
  signed int current_pos;
  // selection_bound
  signed int selection_bound;
  // cached_layout
  struct _PangoLayout *cached_layout;
  // cache_includes_preedit
  unsigned int cache_includes_preedit : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // has_frame
  unsigned int has_frame : 1;
  // activates_default
  unsigned int activates_default : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // in_click
  unsigned int in_click : 1;
  // is_cell_renderer
  unsigned int is_cell_renderer : 1;
  // editing_canceled
  unsigned int editing_canceled : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // select_words
  unsigned int select_words : 1;
  // select_lines
  unsigned int select_lines : 1;
  // resolved_dir
  unsigned int resolved_dir : 4;
  // truncate_multiline
  unsigned int truncate_multiline : 1;
  // button
  unsigned int button;
  // blink_timeout
  unsigned int blink_timeout;
  // recompute_idle
  unsigned int recompute_idle;
  // scroll_offset
  signed int scroll_offset;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // x_text_size
  unsigned short int x_text_size;
  // x_n_bytes
  unsigned short int x_n_bytes;
  // preedit_length
  unsigned short int preedit_length;
  // preedit_cursor
  unsigned short int preedit_cursor;
  // dnd_position
  signed int dnd_position;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // invisible_char
  unsigned int invisible_char;
  // width_chars
  signed int width_chars;
};

struct _GtkHBox
{
  // box
  struct _GtkBox box;
};

struct _GtkIMContext
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GtkItem
{
  // bin
  struct _GtkBin bin;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // seq
  void *seq;
  // _gtk_reserved1
  void *_gtk_reserved1;
  // sort_list
  struct _GList *sort_list;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous_15 order;
  // column_headers
  unsigned long int *column_headers;
  // length
  signed int length;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkMenuShell
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // active_menu_item
  struct _GtkWidget *active_menu_item;
  // parent_menu_shell
  struct _GtkWidget *parent_menu_shell;
  // button
  unsigned int button;
  // activate_time
  unsigned int activate_time;
  // active
  unsigned int active : 1;
  // have_grab
  unsigned int have_grab : 1;
  // have_xgrab
  unsigned int have_xgrab : 1;
  // ignore_leave
  unsigned int ignore_leave : 1;
  // menu_flag
  unsigned int menu_flag : 1;
  // ignore_enter
  unsigned int ignore_enter : 1;
  // keyboard_mode
  unsigned int keyboard_mode : 1;
};

struct _GtkMenuBar
{
  // menu_shell
  struct _GtkMenuShell menu_shell;
};

struct _GtkMenuItem
{
  // item
  struct _GtkItem item;
  // submenu
  struct _GtkWidget *submenu;
  // event_window
  struct _GdkDrawable *event_window;
  // toggle_size
  unsigned short int toggle_size;
  // accelerator_width
  unsigned short int accelerator_width;
  // accel_path
  char *accel_path;
  // show_submenu_indicator
  unsigned int show_submenu_indicator : 1;
  // submenu_placement
  unsigned int submenu_placement : 1;
  // submenu_direction
  unsigned int submenu_direction : 1;
  // right_justify
  unsigned int right_justify : 1;
  // timer_from_keypress
  unsigned int timer_from_keypress : 1;
  // from_menubar
  unsigned int from_menubar : 1;
  // timer
  unsigned int timer;
};

struct _GtkMessageDialog
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // image
  struct _GtkWidget *image;
  // label
  struct _GtkWidget *label;
};

struct _GtkRange
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // update_policy
  enum anonymous_39 update_policy;
  // inverted
  unsigned int inverted : 1;
  // flippable
  unsigned int flippable : 1;
  // has_stepper_a
  unsigned int has_stepper_a : 1;
  // has_stepper_b
  unsigned int has_stepper_b : 1;
  // has_stepper_c
  unsigned int has_stepper_c : 1;
  // has_stepper_d
  unsigned int has_stepper_d : 1;
  // need_recalc
  unsigned int need_recalc : 1;
  // slider_size_fixed
  unsigned int slider_size_fixed : 1;
  // min_slider_size
  signed int min_slider_size;
  // orientation
  enum anonymous_41 orientation;
  // range_rect
  struct _GdkRectangle range_rect;
  // slider_start
  signed int slider_start;
  // slider_end
  signed int slider_end;
  // round_digits
  signed int round_digits;
  // trough_click_forward
  unsigned int trough_click_forward : 1;
  // update_pending
  unsigned int update_pending : 1;
  // layout
  struct _GtkRangeLayout *layout;
  // timer
  struct _GtkRangeStepTimer *timer;
  // slide_initial_slider_position
  signed int slide_initial_slider_position;
  // slide_initial_coordinate
  signed int slide_initial_coordinate;
  // update_timeout_id
  unsigned int update_timeout_id;
  // event_window
  struct _GdkDrawable *event_window;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous_46 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSpinButton
{
  // entry
  struct _GtkEntry entry;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // panel
  struct _GdkDrawable *panel;
  // timer
  unsigned int timer;
  // climb_rate
  double climb_rate;
  // timer_step
  double timer_step;
  // update_policy
  enum anonymous_18 update_policy;
  // in_child
  unsigned int in_child : 2;
  // click_child
  unsigned int click_child : 2;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // timer_calls
  unsigned int timer_calls : 3;
  // digits
  unsigned int digits : 10;
  // numeric
  unsigned int numeric : 1;
  // wrap
  unsigned int wrap : 1;
  // snap_to_ticks
  unsigned int snap_to_ticks : 1;
};

struct _GtkStatusbar
{
  // parent_widget
  struct _GtkHBox parent_widget;
  // frame
  struct _GtkWidget *frame;
  // label
  struct _GtkWidget *label;
  // messages
  struct _GSList *messages;
  // keys
  struct _GSList *keys;
  // seq_context_id
  unsigned int seq_context_id;
  // seq_message_id
  unsigned int seq_message_id;
  // grip_window
  struct _GdkDrawable *grip_window;
  // has_resize_grip
  unsigned int has_resize_grip : 1;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct _GtkTreeSelection
{
  // parent
  struct _GObject parent;
  // tree_view
  struct _GtkTreeView *tree_view;
  // type
  enum anonymous_2 type;
  // user_func
  signed int (*user_func)(struct _GtkTreeSelection *, struct _GtkTreeModel *, struct _GtkTreePath *, signed int, void *);
  // user_data
  void *user_data;
  // destroy
  void (*destroy)(void *);
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewColumn
{
  // parent
  struct _GtkObject parent;
  // tree_view
  struct _GtkWidget *tree_view;
  // button
  struct _GtkWidget *button;
  // child
  struct _GtkWidget *child;
  // arrow
  struct _GtkWidget *arrow;
  // alignment
  struct _GtkWidget *alignment;
  // window
  struct _GdkDrawable *window;
  // editable_widget
  struct _GtkCellEditable *editable_widget;
  // xalign
  float xalign;
  // property_changed_signal
  unsigned int property_changed_signal;
  // spacing
  signed int spacing;
  // column_type
  enum anonymous_1 column_type;
  // requested_width
  signed int requested_width;
  // button_request
  signed int button_request;
  // resized_width
  signed int resized_width;
  // width
  signed int width;
  // fixed_width
  signed int fixed_width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // drag_x
  signed int drag_x;
  // drag_y
  signed int drag_y;
  // title
  char *title;
  // cell_list
  struct _GList *cell_list;
  // sort_clicked_signal
  unsigned int sort_clicked_signal;
  // sort_column_changed_signal
  unsigned int sort_column_changed_signal;
  // sort_column_id
  signed int sort_column_id;
  // sort_order
  enum anonymous_15 sort_order;
  // visible
  unsigned int visible : 1;
  // resizable
  unsigned int resizable : 1;
  // clickable
  unsigned int clickable : 1;
  // dirty
  unsigned int dirty : 1;
  // show_sort_indicator
  unsigned int show_sort_indicator : 1;
  // maybe_reordered
  unsigned int maybe_reordered : 1;
  // reorderable
  unsigned int reorderable : 1;
  // use_resized_width
  unsigned int use_resized_width : 1;
  // expand
  unsigned int expand : 1;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};


// BUFFER_SIZE
// file player.c line 35
static const signed int BUFFER_SIZE = 512;
// PREFILL
// file player.c line 38
static const float PREFILL = (const float)0.2;
// SLACK
// file player.c line 44
static const float SLACK = (const float)0.5;
// UPDATE_LOCATION_TIMEOUT
// file mainwin.c line 29
static const signed int UPDATE_LOCATION_TIMEOUT = 1000;
// about_menu_item
// file mainwin.c line 35
static struct _GtkWidget *about_menu_item;
// adjustment
// file mainwin.c line 48
static struct _GtkObject *adjustment;
// adjustment_link1
// file newtestwin.c line 31
static struct _GtkObject *adjustment_link1;
// answers
// file resultwin.c line 32
static struct _GtkWidget *answers;
// answers_box
// file resultwin.c line 24
static struct _GtkWidget *answers_box;
// audio_init_count
// file player.c line 47
static unsigned int audio_init_count;
// audio_init_count_mutex
// file player.c line 46
union anonymous_45 audio_init_count_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// basename_a
// file gtkui.c line 29
char *basename_a;
// basename_b
// file gtkui.c line 30
char *basename_b;
// button_box
// file newtestwin.c line 36
static struct _GtkWidget *button_box;
// cancel
// file newtestwin.c line 35
static struct _GtkWidget *cancel;
// close_box
// file resultwin.c line 25
static struct _GtkWidget *close_box;
// close_button
// file resultwin.c line 31
static struct _GtkWidget *close_button;
// current_player
// file playback.c line 29
static struct Player *current_player;
// current_test
// file test.c line 35
static struct anonymous_33 current_test = { .isvalid=(char)0, .ntrials=(unsigned int)-1, .answers=(enum anonymous_14 *)(void *)0,
    .guesses=(enum anonymous_14 *)(void *)0 };
// current_trial
// file gtkui.c line 25
signed int current_trial;
// dialog
// file decidewin.c line 24
static struct _GtkWidget *dialog;
// file_box
// file newtestwin.c line 30
static struct _GtkWidget *file_box;
// first_file_box
// file newtestwin.c line 28
static struct _GtkWidget *first_file_box;
// first_file_selector
// file newtestwin.c line 26
static struct _GtkWidget *first_file_selector;
// first_sample
// file mainwin.c line 41
static struct _GtkWidget *first_sample;
// guesses
// file resultwin.c line 33
static struct _GtkWidget *guesses;
// guesses_box
// file resultwin.c line 26
static struct _GtkWidget *guesses_box;
// is_user_seeking
// file mainwin.c line 50
static signed int is_user_seeking;
// main_box
// file newtestwin.c line 25
static struct _GtkWidget *main_box;
// main_box_link1
// file resultwin.c line 27
static struct _GtkWidget *main_box_link1;
// main_window
// file mainwin.c line 25
struct _GtkWidget *main_window;
// marker_list
// file mainwin.c line 53
static struct _GtkListStore *marker_list;
// markers
// file mainwin.c line 52
static struct _GtkWidget *markers;
// meta_a_label
// file mainwin.c line 56
static struct _GtkWidget *meta_a_label;
// meta_b_label
// file mainwin.c line 57
static struct _GtkWidget *meta_b_label;
// metadata_a
// file gtkui.c line 27
struct anonymous_32 metadata_a;
// metadata_b
// file gtkui.c line 28
struct anonymous_32 metadata_b;
// ncorr_box
// file resultwin.c line 28
static struct _GtkWidget *ncorr_box;
// new_test_menu_item
// file mainwin.c line 34
static struct _GtkWidget *new_test_menu_item;
// next_marker
// file mainwin.c line 46
static struct _GtkWidget *next_marker;
// non_play_context
// file mainwin.c line 39
static signed int non_play_context;
// ntrials
// file gtkui.c line 32
static signed int ntrials = 10;
// ok
// file newtestwin.c line 34
static struct _GtkWidget *ok;
// outdev
// file gtkui.c line 33
static signed int outdev = -1;
// pause_button
// file mainwin.c line 43
static struct _GtkWidget *pause_button;
// play_context
// file mainwin.c line 38
static signed int play_context;
// player_a
// file playback.c line 27
static struct Player *player_a;
// player_b
// file playback.c line 28
static struct Player *player_b;
// prev_marker
// file mainwin.c line 45
static struct _GtkWidget *prev_marker;
// pval_box
// file resultwin.c line 29
static struct _GtkWidget *pval_box;
// scale
// file mainwin.c line 49
static struct _GtkWidget *scale;
// second_file_box
// file newtestwin.c line 29
static struct _GtkWidget *second_file_box;
// second_file_selector
// file newtestwin.c line 27
static struct _GtkWidget *second_file_selector;
// second_sample
// file mainwin.c line 42
static struct _GtkWidget *second_sample;
// semaphore
// file playback.c line 31
static union anonymous_25 semaphore;
// spinner
// file newtestwin.c line 32
static struct _GtkWidget *spinner;
// spinner_box
// file newtestwin.c line 33
static struct _GtkWidget *spinner_box;
// status_bar
// file mainwin.c line 37
static struct _GtkWidget *status_bar;
// test_sample
// file mainwin.c line 44
static struct _GtkWidget *test_sample;
// timeout_id
// file mainwin.c line 32
static unsigned int timeout_id;
// trial_label
// file mainwin.c line 55
static struct _GtkWidget *trial_label;
// window
// file newtestwin.c line 24
static struct _GtkWidget *window;
// window_link1
// file resultwin.c line 30
static struct _GtkWidget *window_link1;

// add_marker_clicked
// file mainwin.c line 543
static void add_marker_clicked(struct _GtkWidget *widget, void *data)
{
  struct _GtkTreeIter new;
  struct anonymous_17 state;
  gtk_list_store_append(marker_list, &new);
  signed int return_value_get_playback_state_4;
  return_value_get_playback_state_4=get_playback_state(&state);
  if(!(return_value_get_playback_state_4 == -1))
    gtk_list_store_set(marker_list, &new, 0, state.location, -1);

  else
  {
    unsigned long int return_value_gtk_adjustment_get_type_1;
    return_value_gtk_adjustment_get_type_1=gtk_adjustment_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)adjustment, return_value_gtk_adjustment_get_type_1);
    double return_value_gtk_adjustment_get_value_3;
    return_value_gtk_adjustment_get_value_3=gtk_adjustment_get_value((struct _GtkAdjustment *)return_value_g_type_check_instance_cast_2);
    gtk_list_store_set(marker_list, &new, 0, return_value_gtk_adjustment_get_value_3, -1);
  }
}

// button_clicked
// file newtestwin.c line 103
static void button_clicked(struct _GtkWidget *button, void *data)
{
  if(button == cancel)
  {
    gtk_widget_destroy(window);
    window = (struct _GtkWidget *)(void *)0;
  }

  else
    if(button == ok)
      init_new_test();

}

// calculate_p_value
// file test.h line 37
extern double calculate_p_value(void)
{
  signed int i;
  signed int ncorr = 0;
  i = 0;
  signed int return_value_num_test_trials_1;
  do
  {
    return_value_num_test_trials_1=num_test_trials();
    if(i >= return_value_num_test_trials_1)
      break;

    enum anonymous_14 return_value_get_answer_2;
    return_value_get_answer_2=get_answer((unsigned int)i);
    enum anonymous_14 return_value_get_guess_3;
    return_value_get_guess_3=get_guess((unsigned int)i);
    if(return_value_get_answer_2 == return_value_get_guess_3)
      ncorr = ncorr + 1;

    i = i + 1;
  }
  while((_Bool)1);
  if(ncorr == 0)
    return 1.0;

  else
  {
    signed int return_value_num_test_trials_4;
    return_value_num_test_trials_4=num_test_trials();
    double return_value_cdf_binomial_5;
    return_value_cdf_binomial_5=cdf_binomial((unsigned int)(ncorr - 1), (unsigned int)return_value_num_test_trials_4, 0.5);
    return 1.0 - return_value_cdf_binomial_5;
  }
}

// cdf_binomial
// file test.c line 181
static double cdf_binomial(unsigned int k, unsigned int n, double p)
{
  double f;
  double F;
  signed int x;
  if(k >= n)
    return (double)1;

  else
  {
    f=pow((double)1 - p, (double)n);
    F = f;
    x = 1;
    for( ; k >= (unsigned int)x; x = x + 1)
    {
      f = (p / ((double)1 - p)) * (((1.0 * (double)n - (double)x) + (double)1) / (double)x) * f;
      F = F + f;
    }
    return F;
  }
}

// clear_status_bar
// file mainwin.c line 195
static void clear_status_bar(void)
{
  unsigned long int return_value_gtk_statusbar_get_type_1;
  return_value_gtk_statusbar_get_type_1=gtk_statusbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_1);
  gtk_statusbar_pop((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_2, (unsigned int)play_context);
  unsigned long int return_value_gtk_statusbar_get_type_3;
  return_value_gtk_statusbar_get_type_3=gtk_statusbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_3);
  gtk_statusbar_pop((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_4, (unsigned int)play_context);
}

// close_clicked
// file resultwin.c line 43
static void close_clicked(struct _GtkWidget *button, void *data)
{
  gtk_widget_destroy(window_link1);
  window_link1 = (struct _GtkWidget *)(void *)0;
}

// close_playback
// file playback.c line 88
extern void close_playback(void)
{
  close_player(player_a);
  close_player(player_b);
  current_player = (struct Player *)(void *)0;
  player_b = current_player;
  player_a = player_b;
  sem_destroy(&semaphore);
}

// close_player
// file player.h line 37
extern void close_player(struct Player *player)
{
  struct anonymous_38 *msg;
  /* assertion player */
  assert(player != ((struct Player *)NULL));
  if(!(player->controller.thread_ok == 0ul))
  {
    void *return_value_g_malloc_1;
    return_value_g_malloc_1=g_malloc(sizeof(struct anonymous_38) /*32ul*/ );
    msg = (struct anonymous_38 *)return_value_g_malloc_1;
    msg->command = (enum anonymous_37)CMD_TERM;
    msg->sem = (union anonymous_25 *)(void *)0;
    g_async_queue_push(player->controller.messages, (void *)msg);
    pthread_join(player->controller.thread_id, (void **)(void *)0);
  }

  signed int return_value_close_sound_file_2;
  if(!(player->reader.sndfile == ((struct Sound_file *)NULL)))
  {
    return_value_close_sound_file_2=close_sound_file(player->reader.sndfile);
    if(!(return_value_close_sound_file_2 == 0))
      g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "failed to close sound file");

  }

  pthread_mutex_lock(&audio_init_count_mutex);
  audio_init_count = audio_init_count - 1u;
  if(audio_init_count == 0u)
  {
    signed int return_value_Pa_Terminate_3;
    return_value_Pa_Terminate_3=Pa_Terminate();
    if(!(return_value_Pa_Terminate_3 == 0))
      g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "failed to shut down audio subsystem");

  }

  pthread_mutex_unlock(&audio_init_count_mutex);
  if(!(player->buffer.begin == ((float *)NULL)))
    g_free((void *)player->buffer.begin);

  pthread_mutex_destroy(&player->reader.control_cond_mutex);
  pthread_cond_destroy(&player->reader.control_cond);
  if(!(player->buffer.space_sem_ok == 0))
    sem_destroy(&player->buffer.space);

  if(!(player->reader.sem_ok == 0))
    sem_destroy(&player->reader.sem);

  g_free((void *)player);
}

// close_sound_file
// file soundfile.h line 41
extern signed int close_sound_file(struct Sound_file *sndfile)
{
  signed int rval;
  /* assertion sndfile */
  assert(sndfile != ((struct Sound_file *)NULL));
  rval=sf_close(sndfile->sffile);
  g_free((void *)sndfile->metadata.filename);
  g_free((void *)sndfile);
  return rval;
}

// close_test
// file test.h line 31
extern void close_test(void)
{
  if(!(current_test.isvalid == 0))
  {
    close_playback();
    g_free((void *)current_test.guesses);
    g_free((void *)current_test.answers);
    current_test.isvalid = (char)0;
  }

}

// controller_main
// file player.c line 448
static void * controller_main(void *arg)
{
  struct Player *player = (struct Player *)arg;
  struct anonymous_38 *msg;
  signed int term = 0;
  do
  {
    void *return_value_g_async_queue_pop_1;
    return_value_g_async_queue_pop_1=g_async_queue_pop(player->controller.messages);
    msg = (struct anonymous_38 *)return_value_g_async_queue_pop_1;
    switch((signed int)msg->command)
    {
      case CMD_PAUSE:
      {
        switch((signed int)player->state.playback)
        {
          case PLAYING:
          {
            Pa_StopStream(player->stream);
            player->state.playback = (enum anonymous_16)PAUSED;
            break;
          }
          case PAUSED:
          {
            Pa_StartStream(player->stream);
            player->state.playback = (enum anonymous_16)PLAYING;
          }
        }
        break;
      }
      case CMD_PLAY:
      {
        Pa_StartStream(player->stream);
        player->state.playback = (enum anonymous_16)PLAYING;
        break;
      }
      case CMD_SEEK:
      {
        seek(player, msg->offset, msg->whence);
        break;
      }
      case CMD_STOP:
      {
        Pa_StopStream(player->stream);
        player->state.playback = (enum anonymous_16)STOPPED;
        break;
      }
      case CMD_TERM:
      {
        if(!(player->stream == NULL))
        {
          Pa_StopStream(player->stream);
          signed int return_value_Pa_CloseStream_2;
          return_value_Pa_CloseStream_2=Pa_CloseStream(player->stream);
          if(!(return_value_Pa_CloseStream_2 == 0))
            g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "failed to close playback stream");

          player->stream = (void *)0;
        }

        if(!(player->reader.thread_ok == 0))
          terminate_reader_thread(player);

        term = 1;
      }
    }
    if(!(msg->sem == ((union anonymous_25 *)NULL)))
      sem_post(msg->sem);

    g_free((void *)msg);
    if(!(term == 0))
      pthread_exit((void *)0);

  }
  while((_Bool)1);
  return (void *)0;
}

// create_main_window
// file mainwin.c line 206
static void create_main_window(void)
{
  struct _GtkWidget *left_box;
  struct _GtkWidget *main_hbox;
  struct _GtkWidget *create_main_window__1__main_box;
  struct _GtkWidget *playback_box;
  struct _GtkWidget *test_box;
  struct _GtkWidget *marker_box;
  struct _GtkWidget *meta_box;
  struct _GtkWidget *menu_bar;
  main_window=gtk_window_new((enum anonymous_36)GTK_WINDOW_TOPLEVEL);
  playback_box=create_playback_box();
  test_box=create_test_box();
  marker_box=create_marker_box();
  meta_box=create_metadata_box();
  menu_bar=create_menu_bar();
  create_status_bar();
  left_box=gtk_vbox_new(0, 10);
  unsigned long int return_value_gtk_box_get_type_1;
  return_value_gtk_box_get_type_1=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)left_box, return_value_gtk_box_get_type_1);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_2, test_box, (signed int)!(0 != 0), 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_3;
  return_value_gtk_box_get_type_3=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)left_box, return_value_gtk_box_get_type_3);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_4, meta_box, (signed int)!(0 != 0), 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_5;
  return_value_gtk_box_get_type_5=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)left_box, return_value_gtk_box_get_type_5);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_6, playback_box, (signed int)!(0 != 0), 0, (unsigned int)0);
  main_hbox=gtk_hbox_new(0, 10);
  unsigned long int return_value_gtk_container_get_type_7;
  return_value_gtk_container_get_type_7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)main_hbox, return_value_gtk_container_get_type_7);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_8, (unsigned int)10);
  unsigned long int return_value_gtk_box_get_type_9;
  return_value_gtk_box_get_type_9=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)main_hbox, return_value_gtk_box_get_type_9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_10, left_box, 0, (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_11;
  return_value_gtk_box_get_type_11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)main_hbox, return_value_gtk_box_get_type_11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_12, marker_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  create_main_window__1__main_box=gtk_vbox_new(0, 0);
  unsigned long int return_value_gtk_box_get_type_13;
  return_value_gtk_box_get_type_13=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)create_main_window__1__main_box, return_value_gtk_box_get_type_13);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_14, menu_bar, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_15;
  return_value_gtk_box_get_type_15=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)create_main_window__1__main_box, return_value_gtk_box_get_type_15);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_16, main_hbox, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_17;
  return_value_gtk_box_get_type_17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)create_main_window__1__main_box, return_value_gtk_box_get_type_17);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_18, status_bar, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_window_get_type_19;
  return_value_gtk_window_get_type_19=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_window_get_type_19);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_20, "ABX Tester");
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)main_window, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_21, "destroy", (void (*)(void))destroy_event_handler, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  unsigned long int return_value_gtk_container_get_type_22;
  return_value_gtk_container_get_type_22=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
  return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_container_get_type_22);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_23, create_main_window__1__main_box);
}

// create_marker_box
// file mainwin.c line 331
static struct _GtkWidget * create_marker_box(void)
{
  struct _GtkWidget *scrolled_window;
  struct _GtkWidget *add_marker;
  struct _GtkWidget *remove_marker;
  struct _GtkWidget *clear_markers;
  struct _GtkWidget *upper_buttons_box;
  struct _GtkWidget *marker_buttons_box;
  struct _GtkWidget *marker_box;
  struct _GtkTreeViewColumn *column;
  marker_list=gtk_list_store_new(1, (unsigned long int)(15 << 2));
  unsigned long int return_value_gtk_tree_model_get_type_1;
  return_value_gtk_tree_model_get_type_1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)marker_list, return_value_gtk_tree_model_get_type_1);
  markers=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_2);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
  return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)markers, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_3, "row-activated", (void (*)(void))marker_activated, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  struct _GtkCellRenderer *return_value_gtk_cell_renderer_text_new_4;
  return_value_gtk_cell_renderer_text_new_4=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("_Markers", return_value_gtk_cell_renderer_text_new_4, (const void *)"text", 0, (void *)0);
  unsigned long int return_value_gtk_tree_view_get_type_5;
  return_value_gtk_tree_view_get_type_5=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)markers, return_value_gtk_tree_view_get_type_5);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast_6, column);
  add_marker=gtk_button_new_from_stock("gtk-add");
  remove_marker=gtk_button_new_from_stock("gtk-remove");
  clear_markers=gtk_button_new_from_stock("gtk-clear");
  struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
  return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)add_marker, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_7, "clicked", (void (*)(void))add_marker_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)remove_marker, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_8, "clicked", (void (*)(void))remove_marker_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
  return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)clear_markers, (unsigned long int)(20 << 2));
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)marker_list, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_9, "clicked", (void (*)(void))gtk_list_store_clear, (void *)(struct _GObject *)return_value_g_type_check_instance_cast_10, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)G_CONNECT_SWAPPED);
  upper_buttons_box=gtk_hbox_new((signed int)!(0 != 0), 5);
  unsigned long int return_value_gtk_box_get_type_11;
  return_value_gtk_box_get_type_11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)upper_buttons_box, return_value_gtk_box_get_type_11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_12, add_marker, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_13;
  return_value_gtk_box_get_type_13=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)upper_buttons_box, return_value_gtk_box_get_type_13);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_14, remove_marker, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  marker_buttons_box=gtk_vbox_new((signed int)!(0 != 0), 5);
  unsigned long int return_value_gtk_box_get_type_15;
  return_value_gtk_box_get_type_15=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)marker_buttons_box, return_value_gtk_box_get_type_15);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_16, upper_buttons_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_17;
  return_value_gtk_box_get_type_17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)marker_buttons_box, return_value_gtk_box_get_type_17);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_18, clear_markers, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_scrolled_window_get_type_19;
  return_value_gtk_scrolled_window_get_type_19=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type_19);
  gtk_scrolled_window_add_with_viewport((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_20, markers);
  unsigned long int return_value_gtk_scrolled_window_get_type_21;
  return_value_gtk_scrolled_window_get_type_21=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type_21);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast_22, (enum anonymous_13)GTK_POLICY_AUTOMATIC, (enum anonymous_13)GTK_POLICY_AUTOMATIC);
  marker_box=gtk_vbox_new(0, 5);
  unsigned long int return_value_gtk_box_get_type_23;
  return_value_gtk_box_get_type_23=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)marker_box, return_value_gtk_box_get_type_23);
  unsigned long int return_value_gtk_widget_get_type_25;
  return_value_gtk_widget_get_type_25=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_widget_get_type_25);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_24, (struct _GtkWidget *)return_value_g_type_check_instance_cast_26, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_27;
  return_value_gtk_box_get_type_27=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)marker_box, return_value_gtk_box_get_type_27);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_28, marker_buttons_box, 0, 0, (unsigned int)0);
  return marker_box;
}

// create_menu_bar
// file mainwin.c line 431
static struct _GtkWidget * create_menu_bar(void)
{
  struct _GtkWidget *menu_bar;
  struct _GtkWidget *test_menu_item;
  struct _GtkWidget *test_menu;
  struct _GtkWidget *quit_menu_item;
  struct _GtkWidget *help_menu;
  struct _GtkWidget *help_menu_item;
  test_menu=gtk_menu_new();
  new_test_menu_item=gtk_image_menu_item_new_from_stock("gtk-new", (struct _GtkAccelGroup *)(void *)0);
  quit_menu_item=gtk_image_menu_item_new_from_stock("gtk-quit", (struct _GtkAccelGroup *)(void *)0);
  unsigned long int return_value_gtk_menu_shell_get_type_1;
  return_value_gtk_menu_shell_get_type_1=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)test_menu, return_value_gtk_menu_shell_get_type_1);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_2, new_test_menu_item);
  unsigned long int return_value_gtk_menu_shell_get_type_3;
  return_value_gtk_menu_shell_get_type_3=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)test_menu, return_value_gtk_menu_shell_get_type_3);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_4, quit_menu_item);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)new_test_menu_item, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_5, "activate", (void (*)(void))menu_item_clicked, (void *)"test.new", (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)quit_menu_item, (unsigned long int)(20 << 2));
  struct _GTypeInstance *return_value_g_type_check_instance_cast_7;
  return_value_g_type_check_instance_cast_7=g_type_check_instance_cast((struct _GTypeInstance *)main_window, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_6, "activate", (void (*)(void))gtk_widget_destroy, (void *)(struct _GObject *)return_value_g_type_check_instance_cast_7, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)G_CONNECT_SWAPPED);
  test_menu_item=gtk_menu_item_new_with_mnemonic("_Test");
  unsigned long int return_value_gtk_menu_item_get_type_8;
  return_value_gtk_menu_item_get_type_8=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
  return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)test_menu_item, return_value_gtk_menu_item_get_type_8);
  gtk_menu_item_set_submenu((struct _GtkMenuItem *)return_value_g_type_check_instance_cast_9, test_menu);
  help_menu=gtk_menu_new();
  about_menu_item=gtk_image_menu_item_new_from_stock("gtk-about", (struct _GtkAccelGroup *)(void *)0);
  unsigned long int return_value_gtk_menu_shell_get_type_10;
  return_value_gtk_menu_shell_get_type_10=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
  return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)help_menu, return_value_gtk_menu_shell_get_type_10);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast_11, about_menu_item);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)about_menu_item, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_12, "activate", (void (*)(void))menu_item_clicked, (void *)"help.about", (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  help_menu_item=gtk_menu_item_new_with_mnemonic("_Help");
  unsigned long int return_value_gtk_menu_item_get_type_13;
  return_value_gtk_menu_item_get_type_13=gtk_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)help_menu_item, return_value_gtk_menu_item_get_type_13);
  gtk_menu_item_set_submenu((struct _GtkMenuItem *)return_value_g_type_check_instance_cast_14, help_menu);
  menu_bar=gtk_menu_bar_new();
  unsigned long int return_value_gtk_menu_bar_get_type_15;
  return_value_gtk_menu_bar_get_type_15=gtk_menu_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)menu_bar, return_value_gtk_menu_bar_get_type_15);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenuBar *)return_value_g_type_check_instance_cast_16, test_menu_item);
  unsigned long int return_value_gtk_menu_bar_get_type_17;
  return_value_gtk_menu_bar_get_type_17=gtk_menu_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)menu_bar, return_value_gtk_menu_bar_get_type_17);
  gtk_menu_shell_append((struct _GtkMenuShell *)(struct _GtkMenuBar *)return_value_g_type_check_instance_cast_18, help_menu_item);
  return menu_bar;
}

// create_metadata_box
// file mainwin.c line 410
static struct _GtkWidget * create_metadata_box(void)
{
  struct _GtkWidget *meta_a_hbox;
  struct _GtkWidget *meta_b_hbox;
  struct _GtkWidget *meta_vbox;
  meta_a_label=gtk_label_new("Sample A: (none)");
  meta_b_label=gtk_label_new("Sample B: (none)");
  meta_a_hbox=gtk_hbox_new(0, 0);
  meta_b_hbox=gtk_hbox_new(0, 0);
  unsigned long int return_value_gtk_box_get_type_1;
  return_value_gtk_box_get_type_1=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)meta_a_hbox, return_value_gtk_box_get_type_1);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_2, meta_a_label, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_3;
  return_value_gtk_box_get_type_3=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)meta_b_hbox, return_value_gtk_box_get_type_3);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_4, meta_b_label, 0, 0, (unsigned int)0);
  meta_vbox=gtk_vbox_new((signed int)!(0 != 0), 5);
  unsigned long int return_value_gtk_box_get_type_5;
  return_value_gtk_box_get_type_5=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)meta_vbox, return_value_gtk_box_get_type_5);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_6, meta_a_hbox, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_7;
  return_value_gtk_box_get_type_7=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)meta_vbox, return_value_gtk_box_get_type_7);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_8, meta_b_hbox, 0, 0, (unsigned int)0);
  return meta_vbox;
}

// create_new_test_window
// file newtestwin.c line 114
static void create_new_test_window(void)
{
  struct _GtkWidget *sample_a_label;
  sample_a_label=gtk_label_new_with_mnemonic("Sample _A:");
  struct _GtkWidget *sample_b_label;
  sample_b_label=gtk_label_new_with_mnemonic("Sample _B:");
  struct _GtkWidget *trials_label;
  trials_label=gtk_label_new_with_mnemonic("Number of _trials:");
  first_file_selector=gtk_file_chooser_button_new("Choose audio sample A", (enum anonymous_3)GTK_FILE_CHOOSER_ACTION_OPEN);
  second_file_selector=gtk_file_chooser_button_new("Choose audio sample B", (enum anonymous_3)GTK_FILE_CHOOSER_ACTION_OPEN);
  unsigned long int return_value_gtk_label_get_type_1;
  return_value_gtk_label_get_type_1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)sample_a_label, return_value_gtk_label_get_type_1);
  gtk_label_set_mnemonic_widget((struct _GtkLabel *)return_value_g_type_check_instance_cast_2, first_file_selector);
  unsigned long int return_value_gtk_label_get_type_3;
  return_value_gtk_label_get_type_3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)sample_b_label, return_value_gtk_label_get_type_3);
  gtk_label_set_mnemonic_widget((struct _GtkLabel *)return_value_g_type_check_instance_cast_4, second_file_selector);
  first_file_box=gtk_hbox_new(0, 5);
  unsigned long int return_value_gtk_box_get_type_5;
  return_value_gtk_box_get_type_5=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)first_file_box, return_value_gtk_box_get_type_5);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_6, sample_a_label, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_7;
  return_value_gtk_box_get_type_7=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)first_file_box, return_value_gtk_box_get_type_7);
  unsigned long int return_value_gtk_widget_get_type_9;
  return_value_gtk_widget_get_type_9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)first_file_selector, return_value_gtk_widget_get_type_9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_8, (struct _GtkWidget *)return_value_g_type_check_instance_cast_10, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  second_file_box=gtk_hbox_new(0, 5);
  unsigned long int return_value_gtk_box_get_type_11;
  return_value_gtk_box_get_type_11=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)second_file_box, return_value_gtk_box_get_type_11);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_12, sample_b_label, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_13;
  return_value_gtk_box_get_type_13=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)second_file_box, return_value_gtk_box_get_type_13);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_14, second_file_selector, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  file_box=gtk_vbox_new(0, 5);
  unsigned long int return_value_gtk_box_get_type_15;
  return_value_gtk_box_get_type_15=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)file_box, return_value_gtk_box_get_type_15);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_16, first_file_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_17;
  return_value_gtk_box_get_type_17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)file_box, return_value_gtk_box_get_type_17);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_18, second_file_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  adjustment_link1=gtk_adjustment_new((double)1, (double)1, (double)50, 1.0, 10.0, (double)0);
  unsigned long int return_value_gtk_adjustment_get_type_19;
  return_value_gtk_adjustment_get_type_19=gtk_adjustment_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)adjustment_link1, return_value_gtk_adjustment_get_type_19);
  spinner=gtk_spin_button_new((struct _GtkAdjustment *)return_value_g_type_check_instance_cast_20, (double)1, (unsigned int)0);
  unsigned long int return_value_gtk_label_get_type_21;
  return_value_gtk_label_get_type_21=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_22;
  return_value_g_type_check_instance_cast_22=g_type_check_instance_cast((struct _GTypeInstance *)trials_label, return_value_gtk_label_get_type_21);
  gtk_label_set_mnemonic_widget((struct _GtkLabel *)return_value_g_type_check_instance_cast_22, spinner);
  spinner_box=gtk_hbox_new(0, 5);
  unsigned long int return_value_gtk_box_get_type_23;
  return_value_gtk_box_get_type_23=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_24;
  return_value_g_type_check_instance_cast_24=g_type_check_instance_cast((struct _GTypeInstance *)spinner_box, return_value_gtk_box_get_type_23);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_24, trials_label, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_25;
  return_value_gtk_box_get_type_25=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)spinner_box, return_value_gtk_box_get_type_25);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_26, spinner, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  ok=gtk_button_new_from_stock("gtk-ok");
  cancel=gtk_button_new_from_stock("gtk-cancel");
  button_box=gtk_hbox_new((signed int)!(0 != 0), 5);
  unsigned long int return_value_gtk_box_get_type_27;
  return_value_gtk_box_get_type_27=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)button_box, return_value_gtk_box_get_type_27);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_28, ok, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_29;
  return_value_gtk_box_get_type_29=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_30;
  return_value_g_type_check_instance_cast_30=g_type_check_instance_cast((struct _GTypeInstance *)button_box, return_value_gtk_box_get_type_29);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_30, cancel, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  g_signal_connect_data((void *)ok, "clicked", (void (*)(void))button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  g_signal_connect_data((void *)cancel, "clicked", (void (*)(void))button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  window=gtk_window_new((enum anonymous_36)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_window_get_type_31;
  return_value_gtk_window_get_type_31=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
  return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_window_get_type_31);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_32, "New test");
  main_box=gtk_vbox_new(0, 5);
  unsigned long int return_value_gtk_container_get_type_33;
  return_value_gtk_container_get_type_33=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_34;
  return_value_g_type_check_instance_cast_34=g_type_check_instance_cast((struct _GTypeInstance *)main_box, return_value_gtk_container_get_type_33);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_34, (unsigned int)10);
  unsigned long int return_value_gtk_box_get_type_35;
  return_value_gtk_box_get_type_35=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_36;
  return_value_g_type_check_instance_cast_36=g_type_check_instance_cast((struct _GTypeInstance *)main_box, return_value_gtk_box_get_type_35);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_36, file_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_37;
  return_value_gtk_box_get_type_37=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_38;
  return_value_g_type_check_instance_cast_38=g_type_check_instance_cast((struct _GTypeInstance *)main_box, return_value_gtk_box_get_type_37);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_38, spinner_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)5);
  unsigned long int return_value_gtk_box_get_type_39;
  return_value_gtk_box_get_type_39=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_40;
  return_value_g_type_check_instance_cast_40=g_type_check_instance_cast((struct _GTypeInstance *)main_box, return_value_gtk_box_get_type_39);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_40, button_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_41;
  return_value_g_type_check_instance_cast_41=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_41, "delete_event", (void (*)(void))delete_event_handler, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  unsigned long int return_value_gtk_container_get_type_42;
  return_value_gtk_container_get_type_42=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_43;
  return_value_g_type_check_instance_cast_43=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_container_get_type_42);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_43, main_box);
}

// create_play_button
// file mainwin.c line 249
static struct _GtkWidget * create_play_button(char *label)
{
  struct _GtkWidget *aligned_box;
  aligned_box=gtk_hbox_new((signed int)!(0 != 0), 0);
  struct _GtkWidget *box;
  box=gtk_hbox_new(0, 3);
  unsigned long int return_value_gtk_box_get_type_1;
  return_value_gtk_box_get_type_1=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type_1);
  struct _GtkWidget *return_value_gtk_image_new_from_stock_3;
  return_value_gtk_image_new_from_stock_3=gtk_image_new_from_stock("gtk-media-play", (enum anonymous_7)GTK_ICON_SIZE_BUTTON);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_2, return_value_gtk_image_new_from_stock_3, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_4;
  return_value_gtk_box_get_type_4=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)box, return_value_gtk_box_get_type_4);
  struct _GtkWidget *return_value_gtk_label_new_with_mnemonic_6;
  return_value_gtk_label_new_with_mnemonic_6=gtk_label_new_with_mnemonic(label);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_5, return_value_gtk_label_new_with_mnemonic_6, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_7;
  return_value_gtk_box_get_type_7=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)aligned_box, return_value_gtk_box_get_type_7);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_8, box, (signed int)!(0 != 0), 0, (unsigned int)0);
  return aligned_box;
}

// create_playback_box
// file mainwin.c line 268
static struct _GtkWidget * create_playback_box(void)
{
  struct _GtkWidget *playback_box;
  struct _GtkWidget *create_playback_box__1__button_box;
  struct _GtkWidget *first_row;
  struct _GtkWidget *second_row;
  adjustment=gtk_adjustment_new((double)0, (double)0, (double)60, 1.0, 15.0, (double)0);
  unsigned long int return_value_gtk_adjustment_get_type_1;
  return_value_gtk_adjustment_get_type_1=gtk_adjustment_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)adjustment, return_value_gtk_adjustment_get_type_1);
  scale=gtk_hscale_new((struct _GtkAdjustment *)return_value_g_type_check_instance_cast_2);
  unsigned long int return_value_gtk_range_get_type_3;
  return_value_gtk_range_get_type_3=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)scale, return_value_gtk_range_get_type_3);
  gtk_range_set_update_policy((struct _GtkRange *)return_value_g_type_check_instance_cast_4, (enum anonymous_39)GTK_UPDATE_DISCONTINUOUS);
  is_user_seeking = 0;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)scale, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_5, "button_press_event", (void (*)(void))scale_button_pressed_or_released, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)scale, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_6, "button_release_event", (void (*)(void))scale_button_pressed_or_released, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  first_sample=gtk_button_new();
  unsigned long int return_value_gtk_container_get_type_7;
  return_value_gtk_container_get_type_7=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)first_sample, return_value_gtk_container_get_type_7);
  struct _GtkWidget *return_value_create_play_button_9;
  return_value_create_play_button_9=create_play_button("Play _A");
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_8, return_value_create_play_button_9);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
  return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)first_sample, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_10, "clicked", (void (*)(void))play_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  second_sample=gtk_button_new();
  unsigned long int return_value_gtk_container_get_type_11;
  return_value_gtk_container_get_type_11=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_12;
  return_value_g_type_check_instance_cast_12=g_type_check_instance_cast((struct _GTypeInstance *)second_sample, return_value_gtk_container_get_type_11);
  struct _GtkWidget *return_value_create_play_button_13;
  return_value_create_play_button_13=create_play_button("Play _B");
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_12, return_value_create_play_button_13);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)second_sample, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_14, "clicked", (void (*)(void))play_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  test_sample=gtk_button_new();
  unsigned long int return_value_gtk_container_get_type_15;
  return_value_gtk_container_get_type_15=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)test_sample, return_value_gtk_container_get_type_15);
  struct _GtkWidget *return_value_create_play_button_17;
  return_value_create_play_button_17=create_play_button("Play _X");
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_16, return_value_create_play_button_17);
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)test_sample, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_18, "clicked", (void (*)(void))play_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  pause_button=gtk_button_new_from_stock("gtk-media-pause");
  struct _GTypeInstance *return_value_g_type_check_instance_cast_19;
  return_value_g_type_check_instance_cast_19=g_type_check_instance_cast((struct _GTypeInstance *)pause_button, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_19, "clicked", (void (*)(void))pause_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  prev_marker=gtk_button_new_from_stock("gtk-media-previous");
  struct _GTypeInstance *return_value_g_type_check_instance_cast_20;
  return_value_g_type_check_instance_cast_20=g_type_check_instance_cast((struct _GTypeInstance *)prev_marker, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_20, "clicked", (void (*)(void))rewind_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  next_marker=gtk_button_new_from_stock("gtk-media-next");
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)next_marker, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_21, "clicked", (void (*)(void))rewind_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  create_playback_box__1__button_box=gtk_vbox_new((signed int)!(0 != 0), 5);
  first_row=gtk_hbox_new((signed int)!(0 != 0), 5);
  second_row=gtk_hbox_new((signed int)!(0 != 0), 5);
  unsigned long int return_value_gtk_box_get_type_22;
  return_value_gtk_box_get_type_22=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
  return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)first_row, return_value_gtk_box_get_type_22);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_23, first_sample, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_24;
  return_value_gtk_box_get_type_24=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_25;
  return_value_g_type_check_instance_cast_25=g_type_check_instance_cast((struct _GTypeInstance *)first_row, return_value_gtk_box_get_type_24);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_25, second_sample, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_26;
  return_value_gtk_box_get_type_26=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_27;
  return_value_g_type_check_instance_cast_27=g_type_check_instance_cast((struct _GTypeInstance *)first_row, return_value_gtk_box_get_type_26);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_27, test_sample, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_28;
  return_value_gtk_box_get_type_28=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_29;
  return_value_g_type_check_instance_cast_29=g_type_check_instance_cast((struct _GTypeInstance *)second_row, return_value_gtk_box_get_type_28);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_29, pause_button, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_30;
  return_value_gtk_box_get_type_30=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_31;
  return_value_g_type_check_instance_cast_31=g_type_check_instance_cast((struct _GTypeInstance *)second_row, return_value_gtk_box_get_type_30);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_31, prev_marker, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_32;
  return_value_gtk_box_get_type_32=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_33;
  return_value_g_type_check_instance_cast_33=g_type_check_instance_cast((struct _GTypeInstance *)second_row, return_value_gtk_box_get_type_32);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_33, next_marker, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_34;
  return_value_gtk_box_get_type_34=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_35;
  return_value_g_type_check_instance_cast_35=g_type_check_instance_cast((struct _GTypeInstance *)create_playback_box__1__button_box, return_value_gtk_box_get_type_34);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_35, first_row, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_36;
  return_value_gtk_box_get_type_36=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)create_playback_box__1__button_box, return_value_gtk_box_get_type_36);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_37, second_row, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  playback_box=gtk_vbox_new(0, 5);
  unsigned long int return_value_gtk_box_get_type_38;
  return_value_gtk_box_get_type_38=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
  return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)playback_box, return_value_gtk_box_get_type_38);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_39, scale, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_40;
  return_value_gtk_box_get_type_40=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_41;
  return_value_g_type_check_instance_cast_41=g_type_check_instance_cast((struct _GTypeInstance *)playback_box, return_value_gtk_box_get_type_40);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_41, create_playback_box__1__button_box, 0, 0, (unsigned int)0);
  return playback_box;
}

// create_status_bar
// file mainwin.c line 477
static void create_status_bar(void)
{
  status_bar=gtk_statusbar_new();
  unsigned long int return_value_gtk_statusbar_get_type_1;
  return_value_gtk_statusbar_get_type_1=gtk_statusbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_1);
  unsigned int return_value_gtk_statusbar_get_context_id_3;
  return_value_gtk_statusbar_get_context_id_3=gtk_statusbar_get_context_id((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_2, "Playback status");
  play_context = (signed int)return_value_gtk_statusbar_get_context_id_3;
  unsigned long int return_value_gtk_statusbar_get_type_4;
  return_value_gtk_statusbar_get_type_4=gtk_statusbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_4);
  unsigned int return_value_gtk_statusbar_get_context_id_6;
  return_value_gtk_statusbar_get_context_id_6=gtk_statusbar_get_context_id((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_5, "Non-playback status");
  non_play_context = (signed int)return_value_gtk_statusbar_get_context_id_6;
  unsigned long int return_value_gtk_statusbar_get_type_7;
  return_value_gtk_statusbar_get_type_7=gtk_statusbar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_7);
  gtk_statusbar_push((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_8, (unsigned int)non_play_context, "Stopped");
}

// create_test_box
// file mainwin.c line 393
static struct _GtkWidget * create_test_box(void)
{
  struct _GtkWidget *test_box;
  test_box=gtk_hbox_new(0, 5);
  struct _GtkWidget *decide;
  decide=gtk_button_new_with_mnemonic("_Decide X");
  struct _GTypeInstance *return_value_g_type_check_instance_cast_1;
  return_value_g_type_check_instance_cast_1=g_type_check_instance_cast((struct _GTypeInstance *)decide, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_1, "clicked", (void (*)(void))decide_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  trial_label=gtk_label_new("(no test in progress)");
  unsigned long int return_value_gtk_box_get_type_2;
  return_value_gtk_box_get_type_2=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
  return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)test_box, return_value_gtk_box_get_type_2);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_3, trial_label, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_4;
  return_value_gtk_box_get_type_4=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
  return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)test_box, return_value_gtk_box_get_type_4);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_5, decide, 0, 0, (unsigned int)0);
  return test_box;
}

// decide_button_clicked
// file mainwin.c line 621
static void decide_button_clicked(struct _GtkWidget *widget, void *data)
{
  if(current_trial >= 0)
  {
    stop_playback();
    clear_status_bar();
    unsigned long int return_value_gtk_window_get_type_1;
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_window_get_type_1);
    show_decide_dialog((struct _GtkWindow *)return_value_g_type_check_instance_cast_2);
  }

}

// delete_event_handler
// file newtestwin.c line 96
static signed int delete_event_handler(struct _GtkWidget *widget, union _GdkEvent *event, void *data)
{
  window = (struct _GtkWidget *)(void *)0;
  return 0;
}

// delete_event_handler_link1
// file resultwin.c line 36
static signed int delete_event_handler_link1(struct _GtkWidget *widget_link1, union _GdkEvent *event_link1, void *data_link1)
{
  window_link1 = (struct _GtkWidget *)(void *)0;
  return 0;
}

// destroy_event_handler
// file mainwin.c line 497
static void destroy_event_handler(struct _GtkWidget *widget, void *data)
{
  gtk_main_quit();
}

// error_dialog
// file gtkui.c line 123
extern void error_dialog(struct _GtkWidget *parent_win, char *msg)
{
  struct _GtkWidget *errdialog;
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)parent_win, return_value_gtk_window_get_type_1);
  errdialog=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, (enum anonymous_29)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_30)GTK_MESSAGE_ERROR, (enum anonymous_31)GTK_BUTTONS_CLOSE, "%s", msg);
  unsigned long int return_value_gtk_window_get_type_3;
  return_value_gtk_window_get_type_3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)errdialog, return_value_gtk_window_get_type_3);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_4, "Error");
  unsigned long int return_value_gtk_dialog_get_type_5;
  return_value_gtk_dialog_get_type_5=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)errdialog, return_value_gtk_dialog_get_type_5);
  gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast_6);
  gtk_widget_destroy(errdialog);
}

// get_answer
// file test.h line 34
extern enum anonymous_14 get_answer(unsigned int t)
{
  signed int return_value_is_test_valid_1;
  return_value_is_test_valid_1=is_test_valid();
  if(return_value_is_test_valid_1 == 0 || !(current_test.ntrials >= t))
    return (enum anonymous_14)-1;

  else
    return current_test.answers[(signed long int)t];
}

// get_guess
// file test.h line 35
extern enum anonymous_14 get_guess(unsigned int t)
{
  signed int return_value_is_test_valid_1;
  return_value_is_test_valid_1=is_test_valid();
  if(return_value_is_test_valid_1 == 0 || !(current_test.ntrials >= t))
    return (enum anonymous_14)-1;

  else
    return current_test.guesses[(signed long int)t];
}

// get_metadata
// file soundfile.h line 42
extern struct anonymous_32 get_metadata(struct Sound_file *sndfile)
{
  /* assertion sndfile */
  assert(sndfile != ((struct Sound_file *)NULL));
  return sndfile->metadata;
}

// get_metadatas
// file playback.h line 31
extern void get_metadatas(struct anonymous_32 *a, struct anonymous_32 *b)
{
  /* assertion a && b */
  assert(a != ((struct anonymous_32 *)NULL) && b != ((struct anonymous_32 *)NULL));
  *a=get_player_metadata(player_a);
  *b=get_player_metadata(player_b);
}

// get_playback_state
// file playback.h line 32
extern signed int get_playback_state(struct anonymous_17 *state)
{
  /* assertion state */
  assert(state != ((struct anonymous_17 *)NULL));
  if(current_player == ((struct Player *)NULL))
    return -1;

  else
    if(current_player == player_a)
    {
      *state=get_player_state(player_a);
      return 0;
    }

    else
    {
      *state=get_player_state(player_b);
      return 1;
    }
}

// get_player_metadata
// file player.h line 39
extern struct anonymous_32 get_player_metadata(struct Player *player)
{
  /* assertion player */
  assert(player != ((struct Player *)NULL));
  return player->reader.metadata;
}

// get_player_state
// file player.h line 40
extern struct anonymous_17 get_player_state(struct Player *player)
{
  /* assertion player */
  assert(player != ((struct Player *)NULL));
  return player->state;
}

// hide_decide_dialog
// file decidewin.c line 84
extern void hide_decide_dialog(void)
{
  if(!(dialog == ((struct _GtkWidget *)NULL)))
    gtk_widget_hide_all(dialog);

}

// hide_result_window
// file gtkui.h line 52
extern void hide_result_window(void)
{
  if(!(window_link1 == ((struct _GtkWidget *)NULL)))
  {
    gtk_widget_destroy(window_link1);
    window_link1 = (struct _GtkWidget *)(void *)0;
  }

}

// init_new_test
// file newtestwin.c line 45
static void init_new_test(void)
{
  char *a;
  char *b;
  char *s;
  signed int testsucc;
  unsigned long int return_value_gtk_file_chooser_get_type_1;
  return_value_gtk_file_chooser_get_type_1=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)first_file_selector, return_value_gtk_file_chooser_get_type_1);
  a=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast_2);
  unsigned long int return_value_gtk_file_chooser_get_type_3;
  return_value_gtk_file_chooser_get_type_3=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)second_file_selector, return_value_gtk_file_chooser_get_type_3);
  b=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast_4);
  if(a == ((char *)NULL))
    error_dialog(window, "You have not chosen sample file A.");

  else
    if(b == ((char *)NULL))
      error_dialog(window, "You have not chosen sample file B.");

    else
    {
      unsigned long int return_value_gtk_spin_button_get_type_5;
      return_value_gtk_spin_button_get_type_5=gtk_spin_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
      return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)spinner, return_value_gtk_spin_button_get_type_5);
      signed int return_value_gtk_spin_button_get_value_as_int_7;
      return_value_gtk_spin_button_get_value_as_int_7=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast_6);
      testsucc=init_test(a, b, (unsigned int)return_value_gtk_spin_button_get_value_as_int_7, -1);
      switch(testsucc)
      {
        case 0:
        {
          gtk_widget_destroy(window);
          window = (struct _GtkWidget *)(void *)0;
          reset_test();
          break;
        }
        case 1:
          b = a;
        case 2:
        {
          s=g_strdup_printf("An error occurred while setting up playback for sample '%s'.", b);
          error_dialog(window, s);
          g_free((void *)s);
          break;
        }
        case 3:
        {
          error_dialog(window, "The chosen samples have different duration.  Both samples must have exactly the same duration.");
          break;
        }
        case 4:
          error_dialog(window, "Invalid number of trials.");
      }
    }
}

// init_playback
// file playback.c line 46
extern signed int init_playback(const char *a, const char *b, signed int outdev)
{
  struct anonymous_32 ma;
  struct anonymous_32 mb;
  struct Player *pa;
  struct Player *pb;
  if(!(player_a == ((struct Player *)NULL)))
  {
    /* assertion player_b */
    assert(player_b != ((struct Player *)NULL));
    return 1;
  }

  else
  {
    pa=init_player(a, outdev);
    if(pa == ((struct Player *)NULL))
    {
      g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't initialize player for '%s'", a);
      return 2;
    }

    else
    {
      pb=init_player(b, outdev);
      if(pb == ((struct Player *)NULL))
      {
        g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't initialize player for '%s'", b);
        close_player(pa);
        return 3;
      }

      else
      {
        ma=get_player_metadata(pa);
        mb=get_player_metadata(pb);
        if(IEEE_FLOAT_NOTEQUAL(ma.duration, mb.duration))
        {
          g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "samples '%s' and '%s' have different duration", a, b);
          close_player(pa);
          close_player(pb);
          return 4;
        }

        else
        {
          player_a = pa;
          player_b = pb;
          sem_init(&semaphore, 0, (unsigned int)0);
          return 0;
        }
      }
    }
  }
}

// init_player
// file player.h line 36
extern struct Player * init_player(const char *filename, signed int outdev)
{
  struct Player *player;
  signed int pa_rval;
  unsigned long int nbytes;
  struct PaStreamParameters strparams;
  void *return_value_g_malloc_1;
  return_value_g_malloc_1=g_malloc(sizeof(struct Player) /*416ul*/ );
  player = (struct Player *)return_value_g_malloc_1;
  player->stream = (void *)0;
  player->reader.sndfile = (struct Sound_file *)(void *)0;
  player->reader.thread_ok = 0;
  player->reader.sem_ok = player->reader.thread_ok;
  player->reader.is_eof = (char)0;
  pthread_mutex_init(&player->reader.control_cond_mutex, (const union anonymous_47 *)(void *)0);
  pthread_cond_init(&player->reader.control_cond, (const union anonymous_47 *)(void *)0);
  player->controller.messages = (struct _GAsyncQueue *)(void *)0;
  player->controller.thread_ok = (unsigned long int)0;
  player->buffer.end = (float *)(void *)0;
  player->buffer.begin = player->buffer.end;
  player->buffer.out = (float *)(void *)0;
  player->buffer.in = player->buffer.out;
  player->buffer.space_sem_ok = 0;
  player->state.location = (double)0;
  player->origin = (double)0;
  pthread_mutex_lock(&audio_init_count_mutex);
  if(audio_init_count == 0u)
  {
    pa_rval=Pa_Initialize();
    if(!(pa_rval == 0))
    {
      const char *return_value_Pa_GetErrorText_2;
      return_value_Pa_GetErrorText_2=Pa_GetErrorText(pa_rval);
      g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't initialize audio subsystem: %s", return_value_Pa_GetErrorText_2);
      close_player(player);
      pthread_mutex_unlock(&audio_init_count_mutex);
      return (struct Player *)(void *)0;
    }

  }

  audio_init_count = audio_init_count + 1u;
  pthread_mutex_unlock(&audio_init_count_mutex);
  if(outdev == -1)
    outdev=scan_audio_output();

  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  if(outdev == -1)
  {
    g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't find default output audio device");
    close_player(player);
    return (struct Player *)(void *)0;
  }

  else
  {
    player->reader.sndfile=open_sound_file(filename);
    if(!(player->reader.sndfile == ((struct Sound_file *)NULL)))
      player->reader.metadata=get_metadata(player->reader.sndfile);

    else
    {
      g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't open file '%s'", filename);
      close_player(player);
      return (struct Player *)(void *)0;
    }
    memset((void *)&strparams, 0, sizeof(struct PaStreamParameters) /*32ul*/ );
    strparams.channelCount = player->reader.metadata.channels;
    strparams.device = outdev;
    strparams.sampleFormat = (unsigned long int)0x00000001;
    const struct PaDeviceInfo *return_value_Pa_GetDeviceInfo_3;
    return_value_Pa_GetDeviceInfo_3=Pa_GetDeviceInfo(outdev);
    strparams.suggestedLatency = return_value_Pa_GetDeviceInfo_3->defaultHighOutputLatency;
    strparams.hostApiSpecificStreamInfo = (void *)0;
    pa_rval=Pa_OpenStream(&player->stream, (const struct PaStreamParameters *)(void *)0, &strparams, (double)player->reader.metadata.rate, (unsigned long int)0, (unsigned long int)0, stream_callback, (void *)player);
    if(!(pa_rval == 0))
    {
      const char *return_value_Pa_GetErrorText_4;
      return_value_Pa_GetErrorText_4=Pa_GetErrorText(pa_rval);
      g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't open audio stream for playback: %s", return_value_Pa_GetErrorText_4);
      player->stream = (void *)0;
      close_player(player);
      return (struct Player *)(void *)0;
    }

    Pa_SetStreamFinishedCallback(player->stream, stream_finished_callback);
    nbytes = (unsigned long int)(1024 * BUFFER_SIZE);
    nbytes = nbytes - nbytes % ((unsigned long int)player->reader.metadata.channels * sizeof(float) /*4ul*/ );
    player->buffer.bufsize = (signed int)(nbytes / sizeof(float) /*4ul*/ );
    void *return_value_g_malloc_5;
    return_value_g_malloc_5=g_malloc(nbytes);
    player->buffer.begin = (float *)return_value_g_malloc_5;
    player->buffer.end = player->buffer.begin + (signed long int)player->buffer.bufsize;
    player->buffer.out = player->buffer.begin;
    player->buffer.in = player->buffer.out;
    player->buffer.nframes = 0;
    signed int return_value_sem_init_6;
    return_value_sem_init_6=sem_init(&player->buffer.space, 0, (unsigned int)1);
    player->buffer.space_sem_ok = (signed int)(return_value_sem_init_6 == 0);
    signed int return_value_sem_init_7;
    return_value_sem_init_7=sem_init(&player->reader.sem, 0, (unsigned int)0);
    player->reader.sem_ok = (signed int)(return_value_sem_init_7 == 0);
    signed int return_value_sem_init_8;
    return_value_sem_init_8=sem_init(&player->reader.notify, 0, (unsigned int)0);
    player->reader.notify_ok = (signed int)(return_value_sem_init_8 == 0);
    if(player->buffer.space_sem_ok == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = !(player->reader.sem_ok != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
      tmp_if_expr_10 = (_Bool)1;

    else
      tmp_if_expr_10 = !(player->reader.notify_ok != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_10)
    {
      close_player(player);
      return (struct Player *)(void *)0;
    }

    else
    {
      player->controller.messages=g_async_queue_new();
      signed int return_value_pthread_create_11;
      return_value_pthread_create_11=pthread_create(&player->controller.thread_id, (const union pthread_attr_t *)(void *)0, controller_main, (void *)player);
      player->controller.thread_ok = (unsigned long int)(return_value_pthread_create_11 == 0);
      if(player->controller.thread_ok == 0ul)
      {
        g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't create controller thread");
        close_player(player);
        return (struct Player *)(void *)0;
      }

      else
      {
        player->reader.control = (enum anonymous_40)READER_STOP;
        signed int return_value_pthread_create_12;
        return_value_pthread_create_12=pthread_create(&player->reader.thread_id, (const union pthread_attr_t *)(void *)0, reader_main, (void *)player);
        player->reader.thread_ok = (signed int)(return_value_pthread_create_12 == 0);
        if(player->reader.thread_ok == 0)
        {
          g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't create reader thread");
          close_player(player);
          return (struct Player *)(void *)0;
        }

        else
        {
          sem_wait(&player->reader.sem);
          return player;
        }
      }
    }
  }
}

// init_test
// file test.h line 29
extern signed int init_test(const char *a, const char *b, unsigned int ntrials, signed int outdev)
{
  struct anonymous_33 test;
  signed int i;
  signed int res;
  close_test();
  res=init_playback(a, b, outdev);
  if(res == 2 || res == 3 || res == 4)
  {
    g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't initialize playback");
    test.isvalid = (char)0;
    return res - 1;
  }

  else
    if(ntrials == 0u)
    {
      g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "number of trials is zero");
      test.isvalid = (char)0;
      return 4;
    }

    else
    {
      void *return_value_g_malloc_1;
      return_value_g_malloc_1=g_malloc((unsigned long int)ntrials * sizeof(enum anonymous_14) /*4ul*/ );
      test.guesses = (enum anonymous_14 *)return_value_g_malloc_1;
      void *return_value_g_malloc_2;
      return_value_g_malloc_2=g_malloc((unsigned long int)ntrials * sizeof(enum anonymous_14) /*4ul*/ );
      test.answers = (enum anonymous_14 *)return_value_g_malloc_2;
      i = 0;
      for( ; !((unsigned int)i >= ntrials); i = i + 1)
      {
        unsigned int return_value_g_random_int_3;
        return_value_g_random_int_3=g_random_int();
        if(!((32768u & return_value_g_random_int_3) == 0u) == (_Bool)1)
          test.answers[(signed long int)i] = (enum anonymous_14)SAMPLE_A;

        else
          test.answers[(signed long int)i] = (enum anonymous_14)SAMPLE_B;
        test.guesses[(signed long int)i] = (enum anonymous_14)SAMPLE_NA;
      }
      test.ntrials = ntrials;
      test.isvalid = (char)1;
      current_test = test;
      return 0;
    }
}

// is_test_valid
// file test.c line 109
extern signed int is_test_valid(void)
{
  return (signed int)current_test.isvalid;
}

// main
// file abx.c line 27
signed int main(signed int argc, char **argv)
{
  ui_main(argc, argv);
  close_test();
  return 0;
}

// marker_activated
// file mainwin.c line 503
static void marker_activated(struct _GtkTreeView *markers, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _GtkTreeIter iter;
  double marker;
  unsigned long int return_value_gtk_tree_model_get_type_1;
  return_value_gtk_tree_model_get_type_1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)marker_list, return_value_gtk_tree_model_get_type_1);
  signed int return_value_gtk_tree_model_get_iter_3;
  return_value_gtk_tree_model_get_iter_3=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_2, &iter, path);
  if(return_value_gtk_tree_model_get_iter_3 == 0)
    g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't get iterator for marked item");

  else
  {
    unsigned long int return_value_gtk_tree_model_get_type_4;
    return_value_gtk_tree_model_get_type_4=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
    return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)marker_list, return_value_gtk_tree_model_get_type_4);
    gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_5, &iter, 0, &marker, -1);
    seek_playback(marker);
    update_location();
  }
}

// menu_item_clicked
// file mainwin.c line 578
static void menu_item_clicked(struct _GtkWidget *widget, void *data)
{
  char license[(signed long int)(sizeof(char [242l]) * 2 + 129) /*613l*/ ];
  static char license_1[242l] = { 'T', 'h', 'i', 's', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm', ' ', 'i', 's', ' ', 'f', 'r', 'e', 'e', ' ', 's', 'o', 'f', 't', 'w', 'a', 'r', 'e', ':', ' ', 'y', 'o', 'u', ' ', 'c', 'a', 'n', ' ', 'r', 'e', 'd', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 'i', 't', ' ', 'a', 'n', 'd', '/', 'o', 'r', ' ', 'm', 'o', 'd', 'i', 'f', 'y', '\n', 'i', 't', ' ', 'u', 'n', 'd', 'e', 'r', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'a', 's', ' ', 'p', 'u', 'b', 'l', 'i', 's', 'h', 'e', 'd', ' ', 'b', 'y', '\n', 't', 'h', 'e', ' ', 'F', 'r', 'e', 'e', ' ', 'S', 'o', 'f', 't', 'w', 'a', 'r', 'e', ' ', 'F', 'o', 'u', 'n', 'd', 'a', 't', 'i', 'o', 'n', ',', ' ', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', '3', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ',', ' ', 'o', 'r', '\n', '(', 'a', 't', ' ', 'y', 'o', 'u', 'r', ' ', 'o', 'p', 't', 'i', 'o', 'n', ')', ' ', 'a', 'n', 'y', ' ', 'l', 'a', 't', 'e', 'r', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', '.', '\n', '\n', 0 };
  strcpy(license, license_1);
  static char license_2[371l] = { 'T', 'h', 'i', 's', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm', ' ', 'i', 's', ' ', 'd', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'h', 'o', 'p', 'e', ' ', 't', 'h', 'a', 't', ' ', 'i', 't', ' ', 'w', 'i', 'l', 'l', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'f', 'u', 'l', ',', '\n', 'b', 'u', 't', ' ', 'W', 'I', 'T', 'H', 'O', 'U', 'T', ' ', 'A', 'N', 'Y', ' ', 'W', 'A', 'R', 'R', 'A', 'N', 'T', 'Y', ';', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'e', 'v', 'e', 'n', ' ', 't', 'h', 'e', ' ', 'i', 'm', 'p', 'l', 'i', 'e', 'd', ' ', 'w', 'a', 'r', 'r', 'a', 'n', 't', 'y', ' ', 'o', 'f', '\n', 'M', 'E', 'R', 'C', 'H', 'A', 'N', 'T', 'A', 'B', 'I', 'L', 'I', 'T', 'Y', ' ', 'o', 'r', ' ', 'F', 'I', 'T', 'N', 'E', 'S', 'S', ' ', 'F', 'O', 'R', ' ', 'A', ' ', 'P', 'A', 'R', 'T', 'I', 'C', 'U', 'L', 'A', 'R', ' ', 'P', 'U', 'R', 'P', 'O', 'S', 'E', '.', ' ', ' ', 'S', 'e', 'e', ' ', 't', 'h', 'e', '\n', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'f', 'o', 'r', ' ', 'm', 'o', 'r', 'e', ' ', 'd', 'e', 't', 'a', 'i', 'l', 's', '.', '\n', '\n', 'Y', 'o', 'u', ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'h', 'a', 'v', 'e', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'a', ' ', 'c', 'o', 'p', 'y', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', '\n', 'a', 'l', 'o', 'n', 'g', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'i', 's', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm', '.', ' ', ' ', 'I', 'f', ' ', 'n', 'o', 't', ',', ' ', 's', 'e', 'e', ' ', '<', 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'g', 'n', 'u', '.', 'o', 'r', 'g', '/', 'l', 'i', 'c', 'e', 'n', 's', 'e', 's', '/', '>', '.', 0 };
  strcat(license, license_2);
  static char *authors[2l] = { "Petteri Hintsanen <petterih@iki.fi>", (char *)(void *)0 };
  if(widget == new_test_menu_item)
    show_new_test_window();

  else
    if(widget == about_menu_item)
      gtk_show_about_dialog((struct _GtkWindow *)(void *)0, "program-name", (const void *)"ABX Tester", (const void *)"title", (const void *)"About ABX Tester", (const void *)"authors", (const void *)authors, (const void *)"comments", (const void *)"Fidelity testing program.", (const void *)"website", (const void *)"http://iki.fi/petterih/abx.html", (const void *)"license", (const void *)license, (void *)0);

}

// num_test_trials
// file test.h line 33
extern signed int num_test_trials(void)
{
  signed int return_value_is_test_valid_1;
  return_value_is_test_valid_1=is_test_valid();
  if(return_value_is_test_valid_1 == 0)
    return -1;

  else
    return (signed int)current_test.ntrials;
}

// open_sound_file
// file soundfile.h line 40
extern struct Sound_file * open_sound_file(const char *filename)
{
  struct Sound_file *sndfile;
  struct SNDFILE_tag *sffile;
  struct SF_INFO sfinfo;
  if(filename == ((const char *)NULL))
    return (struct Sound_file *)(void *)0;

  else
  {
    sfinfo.format = 0;
    sffile=sf_open(filename, 16, &sfinfo);
    if(sffile == ((struct SNDFILE_tag *)NULL))
      return (struct Sound_file *)(void *)0;

    else
    {
      void *return_value_g_malloc_1;
      return_value_g_malloc_1=g_malloc(sizeof(struct Sound_file) /*48ul*/ );
      sndfile = (struct Sound_file *)return_value_g_malloc_1;
      sndfile->sffile = sffile;
      if(!((1 & sfinfo.format) == 0))
        sndfile->metadata.bits = 8;

      else
        if(!((2 & sfinfo.format) == 0))
          sndfile->metadata.bits = 16;

        else
          if(!((3 & sfinfo.format) == 0))
            sndfile->metadata.bits = 24;

          else
            if(!((4 & sfinfo.format) == 0))
              sndfile->metadata.bits = 32;

            else
            {
              g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_ERROR, "unsupported bits per sample (must be 8, 16, 24, or 32)");

            __CPROVER_DUMP_L7:
              ;
              goto __CPROVER_DUMP_L7;
            }
      sndfile->metadata.filename=g_strdup(filename);
      sndfile->metadata.rate = sfinfo.samplerate;
      sndfile->metadata.channels = sfinfo.channels;
      sndfile->metadata.frames = (signed int)sfinfo.frames;
      sndfile->metadata.duration = (1.0 * (double)sndfile->metadata.frames) / (double)sndfile->metadata.rate;
      sndfile->metadata.minutes = (unsigned int)((signed int)sndfile->metadata.duration / 60);
      sndfile->metadata.seconds = (unsigned int)((signed int)sndfile->metadata.duration % 60);
      return sndfile;
    }
  }
}

// parse_options
// file gtkui.c line 40
static void parse_options(signed int *argc, char ***argv)
{
  struct _GError *error = (struct _GError *)(void *)0;
  struct _GOptionContext *context;
  struct _GOptionEntry entries[3l] = { { .long_name="num-trials", .short_name=(char)105, .flags=0,
    .arg=(enum anonymous_0)G_OPTION_ARG_INT, .arg_data=(void *)&ntrials,
    .description="Do N trials.", .arg_description="N" },
    { .long_name="audio-device", .short_name=(char)100, .flags=0,
    .arg=(enum anonymous_0)G_OPTION_ARG_INT, .arg_data=(void *)&outdev,
    .description="Use PortAudio audio device ID", .arg_description="ID" },
    { .long_name=(const char *)(void *)0, .short_name=0, .flags=0,
    .arg=(enum anonymous_0)0, .arg_data=NULL, .description=((const char *)NULL),
    .arg_description=((const char *)NULL) } };
  context=g_option_context_new("[SAMPLE-A SAMPLE-B]");
  g_option_context_set_summary(context, "Test for audible differences in fidelity between two audio samples\nwith ABX test.");
  g_option_context_set_description(context, "Report bugs to <petterih@iki.fi>.");
  g_option_context_add_main_entries(context, entries, (const char *)(void *)0);
  struct _GOptionGroup *return_value_gtk_get_option_group_1;
  return_value_gtk_get_option_group_1=gtk_get_option_group((signed int)!(0 != 0));
  g_option_context_add_group(context, return_value_gtk_get_option_group_1);
  signed int return_value_g_option_context_parse_2;
  return_value_g_option_context_parse_2=g_option_context_parse(context, argc, argv, &error);
  if(return_value_g_option_context_parse_2 == 0)
  {
    g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_ERROR, "option parsing failed: %s\n", error->message);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
  }

  if(!(ntrials >= 0))
    ntrials = 0;

}

// pause_button_clicked
// file mainwin.c line 690
static void pause_button_clicked(struct _GtkWidget *widget, void *data)
{
  signed int paused;
  paused=pause_or_resume_playback();
  unsigned long int return_value_gtk_statusbar_get_type_1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  unsigned long int return_value_gtk_statusbar_get_type_3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  switch(paused)
  {
    case 0:
    {
      return_value_gtk_statusbar_get_type_1=gtk_statusbar_get_type();
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_1);
      gtk_statusbar_push((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_2, (unsigned int)play_context, "Paused");
      break;
    }
    case 1:
    {
      return_value_gtk_statusbar_get_type_3=gtk_statusbar_get_type();
      return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_3);
      gtk_statusbar_pop((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_4, (unsigned int)play_context);
      break;
    }
    default:
      clear_status_bar();
  }
  update_location();
}

// pause_or_resume_playback
// file playback.h line 36
extern signed int pause_or_resume_playback(void)
{
  struct anonymous_17 state;
  if(current_player == ((struct Player *)NULL))
    return 2;

  else
  {
    pause_or_resume_player(current_player, &semaphore);
    sem_wait(&semaphore);
    get_playback_state(&state);
    switch((signed int)state.playback)
    {
      case PAUSED:
        return 0;
      case PLAYING:
        return 1;
      case STOPPED:
        return 2;
      default:
        return 2;
    }
  }
}

// pause_or_resume_player
// file player.h line 44
extern void pause_or_resume_player(struct Player *player, union anonymous_25 *sem)
{
  struct anonymous_38 *msg;
  /* assertion player */
  assert(player != ((struct Player *)NULL));
  void *return_value_g_malloc_1;
  return_value_g_malloc_1=g_malloc(sizeof(struct anonymous_38) /*32ul*/ );
  msg = (struct anonymous_38 *)return_value_g_malloc_1;
  msg->command = (enum anonymous_37)CMD_PAUSE;
  msg->sem = sem;
  g_async_queue_push(player->controller.messages, (void *)msg);
}

// play_button_clicked
// file mainwin.c line 634
static void play_button_clicked(struct _GtkWidget *widget, void *data)
{
  struct _GtkTreeIter iter;
  signed int sampleid;
  double marker;
  if(current_trial >= 0)
  {
    if(widget == first_sample)
      sampleid = 0;

    else
      if(widget == second_sample)
        sampleid = 1;

      else
      {
        enum anonymous_14 return_value_get_answer_1;
        return_value_get_answer_1=get_answer((unsigned int)current_trial);
        sampleid = (signed int)return_value_get_answer_1;
      }
    unsigned long int return_value_gtk_tree_view_get_type_8;
    return_value_gtk_tree_view_get_type_8=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
    return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)markers, return_value_gtk_tree_view_get_type_8);
    struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection_10;
    return_value_gtk_tree_view_get_selection_10=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_9);
    signed int return_value_gtk_tree_selection_get_selected_11;
    return_value_gtk_tree_selection_get_selected_11=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection_10, (struct _GtkTreeModel **)(void *)0, &iter);
    if(!(return_value_gtk_tree_selection_get_selected_11 == 0))
    {
      unsigned long int return_value_gtk_tree_model_get_type_2;
      return_value_gtk_tree_model_get_type_2=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
      return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)marker_list, return_value_gtk_tree_model_get_type_2);
      gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_3, &iter, 0, &marker, -1);
      start_playback(sampleid, marker);
    }

    else
    {
      struct anonymous_17 state;
      signed int return_value_get_playback_state_7;
      return_value_get_playback_state_7=get_playback_state(&state);
      if((signed int)state.playback == PLAYING && !(return_value_get_playback_state_7 == -1))
        start_playback(sampleid, state.location);

      else
      {
        unsigned long int return_value_gtk_adjustment_get_type_4;
        return_value_gtk_adjustment_get_type_4=gtk_adjustment_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
        return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)adjustment, return_value_gtk_adjustment_get_type_4);
        double return_value_gtk_adjustment_get_value_6;
        return_value_gtk_adjustment_get_value_6=gtk_adjustment_get_value((struct _GtkAdjustment *)return_value_g_type_check_instance_cast_5);
        start_playback(sampleid, return_value_gtk_adjustment_get_value_6);
      }
    }
    clear_status_bar();
    if(widget == first_sample)
    {
      unsigned long int return_value_gtk_statusbar_get_type_12;
      return_value_gtk_statusbar_get_type_12=gtk_statusbar_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_13;
      return_value_g_type_check_instance_cast_13=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_12);
      gtk_statusbar_push((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_13, (unsigned int)play_context, "Playing sample A");
    }

    else
      if(widget == second_sample)
      {
        unsigned long int return_value_gtk_statusbar_get_type_14;
        return_value_gtk_statusbar_get_type_14=gtk_statusbar_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_15;
        return_value_g_type_check_instance_cast_15=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_14);
        gtk_statusbar_push((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_15, (unsigned int)play_context, "Playing sample B");
      }

      else
      {
        unsigned long int return_value_gtk_statusbar_get_type_16;
        return_value_gtk_statusbar_get_type_16=gtk_statusbar_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast_17;
        return_value_g_type_check_instance_cast_17=g_type_check_instance_cast((struct _GTypeInstance *)status_bar, return_value_gtk_statusbar_get_type_16);
        gtk_statusbar_push((struct _GtkStatusbar *)return_value_g_type_check_instance_cast_17, (unsigned int)play_context, "Playing sample X");
      }
    update_location();
  }

}

// read_pcm_data
// file soundfile.h line 45
extern unsigned int read_pcm_data(struct Sound_file *sndfile, float *buf, unsigned int nframes)
{
  /* assertion sndfile && buf && nframes >= 0 */
  assert(sndfile != ((struct Sound_file *)NULL) && buf != ((float *)NULL) && nframes >= (unsigned int)0);
  signed long int return_value_sf_readf_float_1;
  return_value_sf_readf_float_1=sf_readf_float(sndfile->sffile, buf, (signed long int)nframes);
  return (unsigned int)return_value_sf_readf_float_1;
}

// reader_main
// file player.c line 154
static void * reader_main(void *arg)
{
  struct Player *player;
  signed int nchannels;
  signed int notify;
  player = (struct Player *)arg;
  nchannels = player->reader.metadata.channels;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  do
  {
    pthread_mutex_lock(&player->reader.control_cond_mutex);
    for( ; (_Bool)1; player->reader.is_eof = (char)0)
    {
      if(!((signed int)player->reader.control == READER_STOP))
      {
        if(!((signed int)player->reader.control == READER_TERM))
        {
          if(player->reader.is_eof == 0)
            goto __CPROVER_DUMP_L8;

        }

      }

      if((signed int)player->reader.control == READER_TERM)
        pthread_exit((void *)0);

      if((signed int)player->reader.control == READER_STOP)
        sem_post(&player->reader.sem);

      player->reader.control = (enum anonymous_40)READER_STOPPED;
      pthread_cond_wait(&player->reader.control_cond, &player->reader.control_cond_mutex);
      if((signed int)player->reader.control == READER_RESUME)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)player->reader.control == READER_TERM ? (_Bool)1 : (_Bool)0;
      /* assertion player->reader.control == READER_RESUME || player->reader.control == READER_TERM */
      assert(tmp_if_expr_1);
      sem_post(&player->reader.sem);
    }

  __CPROVER_DUMP_L8:
    ;
    if((signed int)player->reader.control == READER_RESUME)
      notify = 1;

    else
      notify = 0;
    player->reader.control = (enum anonymous_40)READER_RUNNING;
    pthread_mutex_unlock(&player->reader.control_cond_mutex);
    sem_wait(&player->buffer.space);
    if((signed int)player->reader.control == READER_STOP)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)player->reader.control == READER_TERM ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
      do
      {
        signed int nitems;
        signed int nread;
        if(player->buffer.in == player->buffer.end)
          tmp_if_expr_3 = player->buffer.out == player->buffer.begin ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = player->buffer.in + (signed long int)nchannels == player->buffer.out ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          if(!(notify == 0))
            sem_post(&player->reader.notify);

          break;
        }

        if(player->buffer.in == player->buffer.end)
          player->buffer.in = player->buffer.begin;

        if(player->buffer.in >= player->buffer.out)
          nitems = (signed int)((player->buffer.end - player->buffer.in) / (signed long int)nchannels);

        else
          nitems = (signed int)((player->buffer.out - player->buffer.in) / (signed long int)nchannels - (signed long int)1);
        /* assertion nitems > 0 */
        assert(nitems > 0);
        unsigned int return_value_read_pcm_data_5;
        return_value_read_pcm_data_5=read_pcm_data(player->reader.sndfile, player->buffer.in, (unsigned int)nitems);
        nread = (signed int)return_value_read_pcm_data_5;
        player->buffer.nframes = player->buffer.nframes + nread;
        player->buffer.in = player->buffer.in + (signed long int)(nread * nchannels);
        /* assertion player->buffer.nframes <= player->buffer.bufsize */
        assert(player->buffer.nframes <= player->buffer.bufsize);
        if(!(nread == nitems))
        {
          player->reader.is_eof = (char)1;
          if(!(notify == 0))
          {
            sem_post(&player->reader.notify);
            notify = 0;
          }

          break;
        }

        if(!(notify == 0))
        {
          if((float)player->buffer.nframes > PREFILL * (float)player->buffer.bufsize)
          {
            sem_post(&player->reader.notify);
            notify = 0;
          }

        }

      }
      while((_Bool)1);

  }
  while((_Bool)1);
}

// recurrent_update_location
// file mainwin.c line 170
static signed int recurrent_update_location(void *data)
{
  if(is_user_seeking == 0)
  {
    struct anonymous_17 state;
    signed int return_value_get_playback_state_3;
    return_value_get_playback_state_3=get_playback_state(&state);
    if(!(return_value_get_playback_state_3 == -1))
    {
      unsigned long int return_value_gtk_range_get_type_1;
      return_value_gtk_range_get_type_1=gtk_range_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)scale, return_value_gtk_range_get_type_1);
      gtk_range_set_value((struct _GtkRange *)return_value_g_type_check_instance_cast_2, state.location);
      if((signed int)state.playback == STOPPED)
      {
        timeout_id = (unsigned int)0;
        clear_status_bar();
        return 0;
      }

    }

    else
    {
      timeout_id = (unsigned int)0;
      return 0;
    }
  }

  return (signed int)!(0 != 0);
}

// remove_marker_clicked
// file mainwin.c line 564
static void remove_marker_clicked(struct _GtkWidget *widget, void *data)
{
  struct _GtkTreeIter iter;
  unsigned long int return_value_gtk_tree_view_get_type_1;
  return_value_gtk_tree_view_get_type_1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)markers, return_value_gtk_tree_view_get_type_1);
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection_3;
  return_value_gtk_tree_view_get_selection_3=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_2);
  signed int return_value_gtk_tree_selection_get_selected_4;
  return_value_gtk_tree_selection_get_selected_4=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection_3, (struct _GtkTreeModel **)(void *)0, &iter);
  if(!(return_value_gtk_tree_selection_get_selected_4 == 0))
    gtk_list_store_remove(marker_list, &iter);

}

// reset_test
// file gtkui.c line 141
extern void reset_test(void)
{
  if(!(basename_a == ((char *)NULL)))
    g_free((void *)basename_a);

  if(!(basename_b == ((char *)NULL)))
    g_free((void *)basename_b);

  current_trial = 0;
  get_metadatas(&metadata_a, &metadata_b);
  basename_a=g_path_get_basename(metadata_a.filename);
  basename_b=g_path_get_basename(metadata_b.filename);
  hide_decide_dialog();
  hide_result_window();
  update_main_window();
}

// response_handler
// file decidewin.c line 31
static void response_handler(struct _GtkWidget *widget, signed int response, void *data)
{
  signed int return_value_num_test_trials_1;
  switch(response)
  {
    case 0:

    case 1:
    {
      set_guess((unsigned int)current_trial, (enum anonymous_14)response);
      gtk_widget_hide_all(dialog);
      return_value_num_test_trials_1=num_test_trials();
      if(current_trial == return_value_num_test_trials_1 + -1)
      {
        show_result_window();
        close_test();
        current_trial = -1;
        update_main_window();
      }

      else
      {
        current_trial = current_trial + 1;
        update_main_window();
      }
      break;
    }
    case -4:

    case -6:
      gtk_widget_hide_all(dialog);
    default:
      ;
  }
}

// resume_reader_thread
// file player.c line 321
static signed int resume_reader_thread(struct Player *player)
{
  pthread_mutex_lock(&player->reader.control_cond_mutex);
  /* assertion player->reader.control != READER_RESUME */
  assert((signed int)player->reader.control != READER_RESUME);
  if((signed int)player->reader.control == READER_RUNNING)
  {
    pthread_mutex_unlock(&player->reader.control_cond_mutex);
    return 1;
  }

  else
  {
    player->reader.control = (enum anonymous_40)READER_RESUME;
    pthread_cond_signal(&player->reader.control_cond);
    pthread_mutex_unlock(&player->reader.control_cond_mutex);
    sem_wait(&player->reader.sem);
    sem_wait(&player->reader.notify);
    return 0;
  }
}

// rewind_button_clicked
// file mainwin.c line 710
static void rewind_button_clicked(struct _GtkWidget *widget, void *data)
{
  struct _GtkTreeSelection *selection;
  struct _GtkTreeIter iter;
  struct _GtkTreePath *path;
  double marker;
  unsigned long int return_value_gtk_tree_view_get_type_1;
  return_value_gtk_tree_view_get_type_1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)markers, return_value_gtk_tree_view_get_type_1);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_2);
  signed int return_value_gtk_tree_selection_get_selected_3;
  return_value_gtk_tree_selection_get_selected_3=gtk_tree_selection_get_selected(selection, (struct _GtkTreeModel **)(void *)0, &iter);
  _Bool tmp_if_expr_7;
  signed int return_value_gtk_tree_path_prev_6;
  if(!(return_value_gtk_tree_selection_get_selected_3 == 0))
  {
    unsigned long int return_value_gtk_tree_model_get_type_4;
    return_value_gtk_tree_model_get_type_4=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_5;
    return_value_g_type_check_instance_cast_5=g_type_check_instance_cast((struct _GTypeInstance *)marker_list, return_value_gtk_tree_model_get_type_4);
    path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_5, &iter);
    if(widget == prev_marker)
    {
      return_value_gtk_tree_path_prev_6=gtk_tree_path_prev(path);
      tmp_if_expr_7 = return_value_gtk_tree_path_prev_6 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
      gtk_tree_selection_select_path(selection, path);

    else
      if(widget == next_marker)
      {
        gtk_tree_path_next(path);
        gtk_tree_selection_select_path(selection, path);
      }

    unsigned long int return_value_gtk_tree_view_get_type_10;
    return_value_gtk_tree_view_get_type_10=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_11;
    return_value_g_type_check_instance_cast_11=g_type_check_instance_cast((struct _GTypeInstance *)markers, return_value_gtk_tree_view_get_type_10);
    struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection_12;
    return_value_gtk_tree_view_get_selection_12=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast_11);
    signed int return_value_gtk_tree_selection_get_selected_13;
    return_value_gtk_tree_selection_get_selected_13=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection_12, (struct _GtkTreeModel **)(void *)0, &iter);
    if(!(return_value_gtk_tree_selection_get_selected_13 == 0))
    {
      unsigned long int return_value_gtk_tree_model_get_type_8;
      return_value_gtk_tree_model_get_type_8=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_9;
      return_value_g_type_check_instance_cast_9=g_type_check_instance_cast((struct _GTypeInstance *)marker_list, return_value_gtk_tree_model_get_type_8);
      gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast_9, &iter, 0, &marker, -1);
      seek_playback(marker);
      update_location();
    }

    gtk_tree_path_free(path);
  }

}

// scale_button_pressed_or_released
// file mainwin.c line 523
static signed int scale_button_pressed_or_released(struct _GtkWidget *widget, struct _GdkEventButton *event, void *data)
{
  if((signed int)event->type == GDK_BUTTON_PRESS)
    is_user_seeking = 1;

  else
    if((signed int)event->type == GDK_BUTTON_RELEASE)
    {
      is_user_seeking = 0;
      unsigned long int return_value_gtk_adjustment_get_type_1;
      return_value_gtk_adjustment_get_type_1=gtk_adjustment_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
      return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)adjustment, return_value_gtk_adjustment_get_type_1);
      double return_value_gtk_adjustment_get_value_3;
      return_value_gtk_adjustment_get_value_3=gtk_adjustment_get_value((struct _GtkAdjustment *)return_value_g_type_check_instance_cast_2);
      seek_playback(return_value_gtk_adjustment_get_value_3);
      update_location();
    }

  return 0;
}

// scan_audio_output
// file player.c line 595
static signed int scan_audio_output(void)
{
  const struct PaDeviceInfo *devinfo;
  signed int i;
  signed int scan_audio_output__1__outdev = -1;
  signed int ndevices;
  ndevices=Pa_GetDeviceCount();
  if(!(ndevices >= 0))
  {
    const char *return_value_Pa_GetErrorText_1;
    return_value_Pa_GetErrorText_1=Pa_GetErrorText(ndevices);
    g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "can't find available audio devices: %s", return_value_Pa_GetErrorText_1);
  }

  i = 0;
  for( ; !(i >= ndevices); i = i + 1)
  {
    devinfo=Pa_GetDeviceInfo(i);
    if(!(devinfo == ((const struct PaDeviceInfo *)NULL)))
    {
      const struct PaHostApiInfo *return_value_Pa_GetHostApiInfo_2;
      return_value_Pa_GetHostApiInfo_2=Pa_GetHostApiInfo(devinfo->hostApi);
      if(i == return_value_Pa_GetHostApiInfo_2->defaultOutputDevice)
      {
        scan_audio_output__1__outdev = i;
        break;
      }

    }

  }
  return scan_audio_output__1__outdev;
}

// seek
// file player.c line 380
static double seek(struct Player *player, double offset, signed int whence)
{
  signed int space;
  signed int state;
  double loc;
  state = (signed int)player->state.playback;
  Pa_StopStream(player->stream);
  stop_reader_thread(player);
  switch(whence)
  {
    case 0:
    {
      loc = offset;
      break;
    }
    case 1:
    {
      loc = player->state.location + offset;
      break;
    }
    case 2:
      loc = player->reader.metadata.duration + offset;
  }
  _Bool tmp_if_expr_1;
  if(loc < 0.000000)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = loc > player->reader.metadata.duration ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (double)-1;

  else
  {
    player->state.location = loc;
    player->origin = loc;
    player->nplayed = 0;
    player->buffer.out = player->buffer.begin;
    player->buffer.in = player->buffer.out;
    player->buffer.nframes = 0;
    double return_value_seek_sound_file_2;
    return_value_seek_sound_file_2=seek_sound_file(player->reader.sndfile, loc, 0);
    if(IEEE_FLOAT_EQUAL(return_value_seek_sound_file_2, -1.000000))
      return (double)-1;

    else
    {
      sem_getvalue(&player->buffer.space, &space);
      /* assertion space == 0 || space == 1 */
      assert(space == 0 || space == 1);
      if(space == 0)
        sem_post(&player->buffer.space);

      resume_reader_thread(player);
      if(state == PLAYING)
      {
        Pa_StartStream(player->stream);
        player->state.playback = (enum anonymous_16)PLAYING;
      }

      return loc;
    }
  }
}

// seek_playback
// file playback.h line 37
extern void seek_playback(double offset)
{
  if(!(current_player == ((struct Player *)NULL)))
  {
    seek_player(current_player, offset, 0, &semaphore);
    sem_wait(&semaphore);
  }

}

// seek_player
// file player.h line 45
extern void seek_player(struct Player *player, double offset, signed int whence, union anonymous_25 *sem)
{
  struct anonymous_38 *msg;
  /* assertion player */
  assert(player != ((struct Player *)NULL));
  void *return_value_g_malloc_1;
  return_value_g_malloc_1=g_malloc(sizeof(struct anonymous_38) /*32ul*/ );
  msg = (struct anonymous_38 *)return_value_g_malloc_1;
  msg->command = (enum anonymous_37)CMD_SEEK;
  msg->offset = offset;
  msg->whence = whence;
  msg->sem = sem;
  g_async_queue_push(player->controller.messages, (void *)msg);
}

// seek_sound_file
// file soundfile.h line 43
extern double seek_sound_file(struct Sound_file *sndfile, double offset, signed int whence)
{
  signed long int frames;
  signed long int loc;
  /* assertion sndfile */
  assert(sndfile != ((struct Sound_file *)NULL));
  frames = (signed long int)((double)sndfile->metadata.rate * offset);
  loc=sf_seek(sndfile->sffile, frames, whence);
  if(!(loc == -1l))
    loc = (signed long int)((1.0 * (double)loc) / (double)sndfile->metadata.rate);

  return (double)loc;
}

// set_guess
// file test.h line 36
extern signed int set_guess(unsigned int t, enum anonymous_14 ans)
{
  signed int return_value_is_test_valid_1;
  return_value_is_test_valid_1=is_test_valid();
  if(return_value_is_test_valid_1 == 0 || !(current_test.ntrials >= t))
    return -1;

  else
  {
    current_test.guesses[(signed long int)t] = ans;
    return 0;
  }
}

// show_decide_dialog
// file decidewin.c line 61
extern void show_decide_dialog(struct _GtkWindow *parent)
{
  if(!(dialog == ((struct _GtkWidget *)NULL)))
    gtk_widget_show_all(dialog);

  else
  {
    dialog=gtk_message_dialog_new(parent, (enum anonymous_29)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous_30)GTK_MESSAGE_QUESTION, (enum anonymous_31)GTK_BUTTONS_NONE, "Decide X");
    unsigned long int return_value_gtk_window_get_type_1;
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_window_get_type_1);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, "Decision");
    unsigned long int return_value_gtk_message_dialog_get_type_3;
    return_value_gtk_message_dialog_get_type_3=gtk_message_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
    return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_message_dialog_get_type_3);
    gtk_message_dialog_format_secondary_text((struct _GtkMessageDialog *)return_value_g_type_check_instance_cast_4, "Which one is X, A or B?");
    unsigned long int return_value_gtk_dialog_get_type_5;
    return_value_gtk_dialog_get_type_5=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
    return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type_5);
    gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast_6, "_A", 0);
    unsigned long int return_value_gtk_dialog_get_type_7;
    return_value_gtk_dialog_get_type_7=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
    return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type_7);
    gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast_8, "_B", 1);
    unsigned long int return_value_gtk_dialog_get_type_9;
    return_value_gtk_dialog_get_type_9=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_10;
    return_value_g_type_check_instance_cast_10=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type_9);
    gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast_10, "gtk-cancel", -6);
    g_signal_connect_data((void *)dialog, "response", (void (*)(void))response_handler, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
    gtk_widget_show_all(dialog);
  }
}

// show_main_window
// file gtkui.h line 40
extern void show_main_window(void)
{
  if(main_window == ((struct _GtkWidget *)NULL))
  {
    create_main_window();
    gtk_widget_show_all(main_window);
  }

  else
  {
    unsigned long int return_value_gtk_window_get_type_1;
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)main_window, return_value_gtk_window_get_type_1);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast_2);
  }
}

// show_new_test_window
// file gtkui.h line 48
extern void show_new_test_window(void)
{
  if(window == ((struct _GtkWidget *)NULL))
  {
    create_new_test_window();
    gtk_widget_show_all(window);
  }

  else
  {
    unsigned long int return_value_gtk_window_get_type_1;
    return_value_gtk_window_get_type_1=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
    return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_window_get_type_1);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast_2);
  }
}

// show_result_window
// file gtkui.h line 51
extern void show_result_window(void)
{
  struct _GString *as;
  struct _GString *gs;
  signed int i;
  signed int ncorr;
  window_link1=gtk_window_new((enum anonymous_36)GTK_WINDOW_TOPLEVEL);
  unsigned long int return_value_gtk_window_get_type_1;
  return_value_gtk_window_get_type_1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_2;
  return_value_g_type_check_instance_cast_2=g_type_check_instance_cast((struct _GTypeInstance *)window_link1, return_value_gtk_window_get_type_1);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast_2, "Test results");
  struct _GTypeInstance *return_value_g_type_check_instance_cast_3;
  return_value_g_type_check_instance_cast_3=g_type_check_instance_cast((struct _GTypeInstance *)window_link1, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast_3, "delete_event", (void (*)(void))delete_event_handler_link1, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  close_button=gtk_button_new_from_stock("gtk-close");
  g_signal_connect_data((void *)close_button, "clicked", (void (*)(void))close_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous_24)0);
  enum anonymous_14 return_value_get_answer_4;
  return_value_get_answer_4=get_answer((unsigned int)0);
  enum anonymous_14 return_value_get_guess_5;
  return_value_get_guess_5=get_guess((unsigned int)0);
  if(return_value_get_answer_4 == return_value_get_guess_5)
    ncorr = 1;

  else
    ncorr = 0;
  enum anonymous_14 return_value_get_answer_6;
  return_value_get_answer_6=get_answer((unsigned int)0);
  as=g_string_new((signed int)return_value_get_answer_6 == SAMPLE_A ? "<tt>A" : "<tt>B");
  enum anonymous_14 return_value_get_guess_7;
  return_value_get_guess_7=get_guess((unsigned int)0);
  gs=g_string_new((signed int)return_value_get_guess_7 == SAMPLE_A ? "<tt>A" : "<tt>B");
  i = 1;
  signed int return_value_num_test_trials_8;
  do
  {
    return_value_num_test_trials_8=num_test_trials();
    if(i >= return_value_num_test_trials_8)
      break;

    enum anonymous_14 return_value_get_answer_9;
    return_value_get_answer_9=get_answer((unsigned int)i);
    g_string_append(as, (signed int)return_value_get_answer_9 == SAMPLE_A ? " A" : " B");
    enum anonymous_14 return_value_get_guess_10;
    return_value_get_guess_10=get_guess((unsigned int)i);
    g_string_append(gs, (signed int)return_value_get_guess_10 == SAMPLE_A ? " A" : " B");
    enum anonymous_14 return_value_get_answer_11;
    return_value_get_answer_11=get_answer((unsigned int)i);
    enum anonymous_14 return_value_get_guess_12;
    return_value_get_guess_12=get_guess((unsigned int)i);
    if(return_value_get_answer_11 == return_value_get_guess_12)
      ncorr = ncorr + 1;

    i = i + 1;
  }
  while((_Bool)1);
  g_string_append(as, "</tt>");
  g_string_append(gs, "</tt>");
  answers=gtk_label_new((const char *)(void *)0);
  unsigned long int return_value_gtk_label_get_type_13;
  return_value_gtk_label_get_type_13=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_14;
  return_value_g_type_check_instance_cast_14=g_type_check_instance_cast((struct _GTypeInstance *)answers, return_value_gtk_label_get_type_13);
  gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast_14, as->str);
  guesses=gtk_label_new((const char *)(void *)0);
  unsigned long int return_value_gtk_label_get_type_15;
  return_value_gtk_label_get_type_15=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_16;
  return_value_g_type_check_instance_cast_16=g_type_check_instance_cast((struct _GTypeInstance *)guesses, return_value_gtk_label_get_type_15);
  gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast_16, gs->str);
  answers_box=gtk_hbox_new(0, 5);
  guesses_box=gtk_hbox_new(0, 5);
  ncorr_box=gtk_hbox_new(0, 5);
  pval_box=gtk_hbox_new(0, 5);
  close_box=gtk_hbox_new(0, 5);
  unsigned long int return_value_gtk_box_get_type_17;
  return_value_gtk_box_get_type_17=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_18;
  return_value_g_type_check_instance_cast_18=g_type_check_instance_cast((struct _GTypeInstance *)answers_box, return_value_gtk_box_get_type_17);
  struct _GtkWidget *return_value_gtk_label_new_19;
  return_value_gtk_label_new_19=gtk_label_new("Correct decisions:");
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_18, return_value_gtk_label_new_19, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_20;
  return_value_gtk_box_get_type_20=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_21;
  return_value_g_type_check_instance_cast_21=g_type_check_instance_cast((struct _GTypeInstance *)answers_box, return_value_gtk_box_get_type_20);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_21, answers, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_22;
  return_value_gtk_box_get_type_22=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_23;
  return_value_g_type_check_instance_cast_23=g_type_check_instance_cast((struct _GTypeInstance *)guesses_box, return_value_gtk_box_get_type_22);
  struct _GtkWidget *return_value_gtk_label_new_24;
  return_value_gtk_label_new_24=gtk_label_new("Your decisions:");
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_23, return_value_gtk_label_new_24, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_25;
  return_value_gtk_box_get_type_25=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_26;
  return_value_g_type_check_instance_cast_26=g_type_check_instance_cast((struct _GTypeInstance *)guesses_box, return_value_gtk_box_get_type_25);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast_26, guesses, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_27;
  return_value_gtk_box_get_type_27=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_28;
  return_value_g_type_check_instance_cast_28=g_type_check_instance_cast((struct _GTypeInstance *)ncorr_box, return_value_gtk_box_get_type_27);
  char *return_value_g_strdup_printf_29;
  return_value_g_strdup_printf_29=g_strdup_printf("Number of correct decisions: %d", ncorr);
  struct _GtkWidget *return_value_gtk_label_new_30;
  return_value_gtk_label_new_30=gtk_label_new(return_value_g_strdup_printf_29);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_28, return_value_gtk_label_new_30, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_31;
  return_value_gtk_box_get_type_31=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_32;
  return_value_g_type_check_instance_cast_32=g_type_check_instance_cast((struct _GTypeInstance *)pval_box, return_value_gtk_box_get_type_31);
  double return_value_calculate_p_value_33;
  return_value_calculate_p_value_33=calculate_p_value();
  char *return_value_g_strdup_printf_34;
  return_value_g_strdup_printf_34=g_strdup_printf("p-value: %f", return_value_calculate_p_value_33);
  struct _GtkWidget *return_value_gtk_label_new_35;
  return_value_gtk_label_new_35=gtk_label_new(return_value_g_strdup_printf_34);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_32, return_value_gtk_label_new_35, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_36;
  return_value_gtk_box_get_type_36=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_37;
  return_value_g_type_check_instance_cast_37=g_type_check_instance_cast((struct _GTypeInstance *)close_box, return_value_gtk_box_get_type_36);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_37, close_button, (signed int)!(0 != 0), 0, (unsigned int)0);
  main_box_link1=gtk_vbox_new(0, 5);
  unsigned long int return_value_gtk_container_get_type_38;
  return_value_gtk_container_get_type_38=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_39;
  return_value_g_type_check_instance_cast_39=g_type_check_instance_cast((struct _GTypeInstance *)main_box_link1, return_value_gtk_container_get_type_38);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast_39, (unsigned int)10);
  unsigned long int return_value_gtk_box_get_type_40;
  return_value_gtk_box_get_type_40=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_41;
  return_value_g_type_check_instance_cast_41=g_type_check_instance_cast((struct _GTypeInstance *)main_box_link1, return_value_gtk_box_get_type_40);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_41, answers_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_42;
  return_value_gtk_box_get_type_42=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_43;
  return_value_g_type_check_instance_cast_43=g_type_check_instance_cast((struct _GTypeInstance *)main_box_link1, return_value_gtk_box_get_type_42);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_43, guesses_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_44;
  return_value_gtk_box_get_type_44=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_45;
  return_value_g_type_check_instance_cast_45=g_type_check_instance_cast((struct _GTypeInstance *)main_box_link1, return_value_gtk_box_get_type_44);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_45, ncorr_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_46;
  return_value_gtk_box_get_type_46=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_47;
  return_value_g_type_check_instance_cast_47=g_type_check_instance_cast((struct _GTypeInstance *)main_box_link1, return_value_gtk_box_get_type_46);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_47, pval_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_box_get_type_48;
  return_value_gtk_box_get_type_48=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_49;
  return_value_g_type_check_instance_cast_49=g_type_check_instance_cast((struct _GTypeInstance *)main_box_link1, return_value_gtk_box_get_type_48);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast_49, close_box, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_container_get_type_50;
  return_value_gtk_container_get_type_50=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_51;
  return_value_g_type_check_instance_cast_51=g_type_check_instance_cast((struct _GTypeInstance *)window_link1, return_value_gtk_container_get_type_50);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast_51, main_box_link1);
  gtk_widget_show_all(window_link1);
}

// start_playback
// file playback.h line 34
extern void start_playback(signed int sample, double location)
{
  struct Player *pl;
  if(sample == 0)
    pl = player_a;

  else
    pl = player_b;
  stop_playback();
  seek_player(pl, location, 0, (union anonymous_25 *)(void *)0);
  start_player(pl, &semaphore);
  current_player = pl;
  sem_wait(&semaphore);
}

// start_player
// file player.h line 42
extern void start_player(struct Player *player, union anonymous_25 *sem)
{
  struct anonymous_38 *msg;
  /* assertion player */
  assert(player != ((struct Player *)NULL));
  void *return_value_g_malloc_1;
  return_value_g_malloc_1=g_malloc(sizeof(struct anonymous_38) /*32ul*/ );
  msg = (struct anonymous_38 *)return_value_g_malloc_1;
  msg->command = (enum anonymous_37)CMD_PLAY;
  msg->sem = sem;
  g_async_queue_push(player->controller.messages, (void *)msg);
}

// stop_playback
// file playback.h line 35
extern void stop_playback(void)
{
  if(!(current_player == ((struct Player *)NULL)))
  {
    stop_player(current_player, &semaphore);
    sem_wait(&semaphore);
    current_player = (struct Player *)(void *)0;
  }

}

// stop_player
// file player.h line 43
extern void stop_player(struct Player *player, union anonymous_25 *sem)
{
  struct anonymous_38 *msg;
  /* assertion player */
  assert(player != ((struct Player *)NULL));
  void *return_value_g_malloc_1;
  return_value_g_malloc_1=g_malloc(sizeof(struct anonymous_38) /*32ul*/ );
  msg = (struct anonymous_38 *)return_value_g_malloc_1;
  msg->command = (enum anonymous_37)CMD_STOP;
  msg->sem = sem;
  g_async_queue_push(player->controller.messages, (void *)msg);
}

// stop_reader_thread
// file player.c line 282
static signed int stop_reader_thread(struct Player *player)
{
  pthread_mutex_lock(&player->reader.control_cond_mutex);
  /* assertion player->reader.control != READER_STOP */
  assert((signed int)player->reader.control != READER_STOP);
  if((signed int)player->reader.control == READER_STOPPED)
  {
    pthread_mutex_unlock(&player->reader.control_cond_mutex);
    return 1;
  }

  else
  {
    signed int space;
    player->reader.control = (enum anonymous_40)READER_STOP;
    sem_getvalue(&player->buffer.space, &space);
    /* assertion space == 0 || space == 1 */
    assert(space == 0 || space == 1);
    if(space == 0)
      sem_post(&player->buffer.space);

    pthread_mutex_unlock(&player->reader.control_cond_mutex);
    sem_wait(&player->reader.sem);
    return 0;
  }
}

// stream_callback
// file player.c line 518
static signed int stream_callback(const void *input, void *output, unsigned long int nframes, const struct PaStreamCallbackTimeInfo *timeinfo, unsigned long int statusflags, void *userdata)
{
  struct Player *player = (struct Player *)userdata;
  char eof = (char)0;
  signed int nchannels = player->reader.metadata.channels;
  float *outbuf = (float *)output;
  player->nplayed = player->nplayed + (signed int)nframes;
  float *tmp_post_1;
  float *tmp_post_2;
  float *tmp_post_3;
  while(nframes >= 1ul)
  {
    unsigned long int i;
    if(player->buffer.out == player->buffer.end)
      player->buffer.out = player->buffer.begin;

    if(player->buffer.out == player->buffer.in)
    {
      if(player->reader.is_eof == 0)
        g_log((char *)0, (enum anonymous_50)G_LOG_LEVEL_WARNING, "buffer underflow");

      else
        eof = (char)1;
      for( ; nframes >= 1ul; nframes = nframes - 1ul)
      {
        i = (unsigned long int)0;
        for( ; !(i >= (unsigned long int)nchannels); i = i + 1ul)
        {
          tmp_post_1 = outbuf;
          outbuf = outbuf + 1l;
          *tmp_post_1 = -1.0f;
        }
      }
    }

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= (unsigned long int)nchannels); i = i + 1ul)
      {
        tmp_post_2 = outbuf;
        outbuf = outbuf + 1l;
        tmp_post_3 = player->buffer.out;
        player->buffer.out = player->buffer.out + 1l;
        *tmp_post_2 = *tmp_post_3;
      }
      player->buffer.nframes = player->buffer.nframes - 1;
      nframes = nframes - 1ul;
    }
  }
  player->state.location = player->origin + (1.0 * (double)player->nplayed) / (double)player->reader.metadata.rate;
  if((float)player->buffer.nframes < SLACK * (float)player->buffer.bufsize)
  {
    signed int space;
    sem_getvalue(&player->buffer.space, &space);
    /* assertion space == 0 || space == 1 */
    assert(space == 0 || space == 1);
    if(space == 0)
      sem_post(&player->buffer.space);

  }

  if(eof == 0)
    return 0;

  else
    return 1;
}

// stream_finished_callback
// file player.c line 584
static void stream_finished_callback(void *userdata)
{
  struct Player *player = (struct Player *)userdata;
  player->state.playback = (enum anonymous_16)STOPPED;
}

// terminate_reader_thread
// file player.c line 352
static void terminate_reader_thread(struct Player *player)
{
  signed int space;
  /* assertion player->reader.control != READER_TERM */
  assert((signed int)player->reader.control != READER_TERM);
  pthread_mutex_lock(&player->reader.control_cond_mutex);
  player->reader.control = (enum anonymous_40)READER_TERM;
  sem_getvalue(&player->buffer.space, &space);
  /* assertion space == 0 || space == 1 */
  assert(space == 0 || space == 1);
  if(space == 0)
    sem_post(&player->buffer.space);

  pthread_cond_signal(&player->reader.control_cond);
  pthread_mutex_unlock(&player->reader.control_cond_mutex);
  pthread_join(player->reader.thread_id, (void **)(void *)0);
}

// ui_main
// file gtkui.h line 35
extern void ui_main(signed int argc, char **argv)
{
  parse_options(&argc, &argv);
  gtk_init(&argc, &argv);
  if(argc >= 3)
  {
    signed int return_value_init_test_1;
    return_value_init_test_1=init_test(argv[(signed long int)1], argv[(signed long int)2], (unsigned int)ntrials, outdev);
    switch(return_value_init_test_1)
    {
      case 0:
      {
        show_main_window();
        reset_test();
        goto __CPROVER_DUMP_L6;
      }
      case 1:
      {
        error_dialog(main_window, "An error occurred while setting up playback for the first sample.");
        goto __CPROVER_DUMP_L9;
      }
      case 2:
      {
        error_dialog(main_window, "An error occurred while setting up playback for the second sample.");
        goto __CPROVER_DUMP_L9;
      }
      case 3:
      {
        error_dialog(main_window, "The given samples have different durations.  Both samples must have exactly the same duration.");
        goto __CPROVER_DUMP_L9;
      }
      case 4:
      {
        error_dialog(main_window, "Invalid number of trials given in the command line.");
        goto __CPROVER_DUMP_L9;
      }
      default:

        __CPROVER_DUMP_L6:
          ;
    }
  }

  else
  {
    current_trial = -1;
    show_main_window();
  }
  gtk_main();

__CPROVER_DUMP_L9:
  ;
}

// update_location
// file mainwin.c line 150
static void update_location(void)
{
  if(!(timeout_id == 0u))
  {
    g_source_remove(timeout_id);
    timeout_id = (unsigned int)0;
  }

  signed int return_value_recurrent_update_location_1;
  return_value_recurrent_update_location_1=recurrent_update_location((void *)0);
  if(!(return_value_recurrent_update_location_1 == 0))
    timeout_id=g_timeout_add((unsigned int)UPDATE_LOCATION_TIMEOUT, recurrent_update_location, (void *)0);

}

// update_main_window
// file gtkui.h line 41
extern void update_main_window(void)
{
  static struct _GString *label = (struct _GString *)(void *)0;
  if(label == ((struct _GString *)NULL))
    label=g_string_new((const char *)(void *)0);

  static struct _GString *meta_a = (struct _GString *)(void *)0;
  if(meta_a == ((struct _GString *)NULL))
    meta_a=g_string_new((const char *)(void *)0);

  static struct _GString *meta_b = (struct _GString *)(void *)0;
  if(meta_b == ((struct _GString *)NULL))
    meta_b=g_string_new((const char *)(void *)0);

  if(!(current_trial >= 0))
  {
    g_string_printf(label, "No test in progress.");
    g_string_printf(meta_a, "A: (none)");
    g_string_printf(meta_b, "B: (none)");
    g_object_set((void *)adjustment, "upper", 0.0, (const void *)"value", 0.0, (void *)0);
    gtk_list_store_clear(marker_list);
  }

  else
    if(current_trial == 0)
    {
      signed int return_value_num_test_trials_1;
      return_value_num_test_trials_1=num_test_trials();
      g_string_printf(label, "Test trial 1 of %d", return_value_num_test_trials_1);
      g_string_printf(meta_a, "Sample A: '%s', %d Hz, %d bits, %d channels", basename_a, metadata_a.rate, metadata_a.bits, metadata_a.channels);
      g_string_printf(meta_b, "Sample B: '%s', %d Hz, %d bits, %d channels", basename_b, metadata_b.rate, metadata_b.bits, metadata_b.channels);
      g_object_set((void *)adjustment, "upper", (double)metadata_a.duration, (const void *)"value", 0.0, (void *)0);
      gtk_list_store_clear(marker_list);
    }

    else
    {
      signed int return_value_num_test_trials_2;
      return_value_num_test_trials_2=num_test_trials();
      g_string_printf(label, "Test trial %d of %d", current_trial + 1, return_value_num_test_trials_2);
    }
  unsigned long int return_value_gtk_label_get_type_3;
  return_value_gtk_label_get_type_3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_4;
  return_value_g_type_check_instance_cast_4=g_type_check_instance_cast((struct _GTypeInstance *)trial_label, return_value_gtk_label_get_type_3);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_4, label->str);
  unsigned long int return_value_gtk_label_get_type_5;
  return_value_gtk_label_get_type_5=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_6;
  return_value_g_type_check_instance_cast_6=g_type_check_instance_cast((struct _GTypeInstance *)meta_a_label, return_value_gtk_label_get_type_5);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_6, meta_a->str);
  unsigned long int return_value_gtk_label_get_type_7;
  return_value_gtk_label_get_type_7=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast_8;
  return_value_g_type_check_instance_cast_8=g_type_check_instance_cast((struct _GTypeInstance *)meta_b_label, return_value_gtk_label_get_type_7);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast_8, meta_b->str);
}

