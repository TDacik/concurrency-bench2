// tag-#anon#ST[*{*{SYM#tag-dns_hash_ent_s#}$SYM#tag-dns_hash_ent_s#$}$*{SYM#tag-dns_hash_ent_s#}$SYM#tag-dns_hash_ent_s#$$'pos'|U64'rhash']
// file hash.h line 49
struct anonymous$58;

// tag-#anon#ST[*{SYM#tag-llistnode_s#}$SYM#tag-llistnode_s#$'first'|*{SYM#tag-llistnode_s#}$SYM#tag-llistnode_s#$'last']
// file list.h line 123
struct anonymous$40;

// tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts']
// file cache.h line 64
struct anonymous$24;

// tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']
// file cache.h line 49
struct anonymous;

// tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']
// file conff.h line 62
struct anonymous$9;

// tag-#anon#ST[*{U8}$U8$'qname'|U64'cs'|U16'num_rrs'|U16'flags'|U32'$pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrext']#'rr']#'$anon0'|U8'c_ns'|U8'c_soa'|U48'$pad1']
// file cache.h line 58
struct anonymous$0;

// tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 126
struct anonymous$51;

// tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 111
struct anonymous$48;

// tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$49;

// tag-#anon#ST[*{cS8}$cS8$'name'|S32'val'|U32'$pad0']
// file consts.h line 60
struct anonymous$32;

// tag-#anon#ST[ARR10{S8}$S8$'name'|ARR32{S8}$S8$'phone'|U16'$pad0'|S32'outgoing']
// file /usr/include/linux/isdn.h line 102
struct anonymous$53;

// tag-#anon#ST[ARR16{U64}$U64$'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$41;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']#$'__cancel_jmp_buf'|ARR4{*{V}$V$}$*{V}$V$$'__pad']
// file /usr/include/pthread.h line 523
struct anonymous$66;

// tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrext']
// file cache.h line 69
struct anonymous$2;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']
// file /usr/include/pthread.h line 525
struct anonymous$65;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$55;

// tag-#anon#ST[S32'bucket'|U32'$pad0'|*{SYM#tag-dns_hash_ent_s#}$SYM#tag-dns_hash_ent_s#$'ent']
// file hash.h line 55
struct anonymous$59;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$44;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$47;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$46;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$43;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$45;

// tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']
// file conff.h line 55
struct anonymous$20;

// tag-#anon#ST[S64'perm_cache'|*{S8}$S8$'cache_dir'|*{S8}$S8$'pidfile'|S32'port'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'a'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'out_a'|SYM#tag-in6_addr#'ipv4_6_prefix'|U32'$pad0'|S64'max_ttl'|S64'min_ttl'|S64'neg_ttl'|S16'neg_rrs_pol'|S16'neg_domain_pol'|S16'verbosity'|ARR21{S8}$S8$'run_as'|S8'daemon'|S8'debug'|S8'stat_pipe'|S8'notcp'|S8'strict_suid'|S8'use_nss'|S8'paranoid'|S8'lndown_kluge'|S8'onquery'|S8'rnd_recs'|U24'$pad1'|S32'ctl_perms'|U32'$pad2'|*{S8}$S8$'scheme_file'|S32'proc_limit'|S32'procq_limit'|S64'tcp_qtimeout'|S64'timeout'|S32'par_queries'|S32'query_method'|S32'query_port_start'|S32'query_port_end'|S32'udpbufsize'|U32'$pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{*{U8}$U8$}$*{U8}$U8$$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{*{U8}$U8$}$*{U8}$U8$$'elem']#$'deleg_only_zones']
// file conff.h line 120
struct anonymous$21;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 119
struct anonymous$50;

// tag-#anon#ST[S64'ttl'|S64'ts']
// file cache.c line 135
struct anonymous$63;

// tag-#anon#ST[S8'prefix'|S8'pidfile'|S8'verbosity'|S8'pdnsduser'|S8'daemon'|S8'debug'|S8'stat_pipe'|S8'notcp'|S8'query_method']
// file conff.h line 161
struct anonymous$31;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'a'|SYM#tag-in_addr#'a4fallback'|S64'timeout'|U16'flags'|S16'nocache'|S16'state'|S16'qm'|S8'auth_serv'|S8'lean_query'|S8'edns_query'|S8'needs_testing'|S8'trusted'|S8'aa'|S8'tc'|S8'failed'|*{cU8}$cU8$'nsdomain'|*{SYM#tag-rejectlist_s#}$SYM#tag-rejectlist_s#$'rejectlist'|S32'sock'|U16'transl'|U16'recvl'|S32'iolen'|U32'$pad0'|*{SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#}$SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#$'msg'|*{SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#}$SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#$'recvbuf'|U16'myrid'|U16'$pad1'|S32's_errno']
// file dns_query.c line 75
struct anonymous$5;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'addr'|SYM#tag-#anon#UN[SYM#tag-in_pktinfo#'pi4'|SYM#tag-in6_pktinfo#'pi6']#'pi'|S32'sock'|S32'proto'|U64'len'|ARR0{U8}$U8$'buf']
// file dns_answer.c line 104
struct anonymous$69;

// tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']
// file conff.h line 76
struct anonymous$13;

// tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']
// file ipvers.h line 248
struct anonymous$15;

// tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']
// file conff.h line 69
struct anonymous$11;

// tag-#anon#ST[U16'__unused'|U16'mtu']
// file /usr/include/linux/icmp.h line 78
struct anonymous$36;

// tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']
// file dns.h line 166
struct anonymous$29;

// tag-#anon#ST[U16'id'|U16'sequence']
// file /usr/include/linux/icmp.h line 73
struct anonymous$35;

// tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']
// file dns.h line 201
struct anonymous$28;

// tag-#anon#ST[U16'port'|S16'uptest'|U32'$pad0'|S64'timeout'|S64'interval'|S64'ping_timeout'|ARR32{S8}$S8$'scheme'|*{S8}$S8$'uptest_cmd'|ARR21{S8}$S8$'uptest_usr'|ARR16{S8}$S8$'interface'|ARR16{S8}$S8$'device'|U24'$pad1'|*{U8}$U8$'query_test_name'|*{S8}$S8$'label'|S8'purge_cache'|S8'nocache'|S8'lean_query'|S8'edns_query'|S8'is_proxy'|S8'rootserver'|S8'rand_servers'|S8'preset'|S8'rejectrecursively'|U8'$pad2'|S16'rejectpolicy'|S16'policy'|U16'$pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#}$SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#}$SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#$'elem']#$'alist'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}$SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}$SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#$'elem']#$'atup_a'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#$'elem']#$'reject_a4'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#$'elem']#$'reject_a6'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'ping_a']
// file conff.h line 83
struct anonymous$7;

// tag-#anon#ST[U16'qtype'|U16'qclass'|ARR0{U8}$U8$'query']
// file dns_answer.c line 128
struct anonymous$70;

// tag-#anon#ST[U16'rdlen']
// file cache.c line 104
struct anonymous$60;

// tag-#anon#ST[U16'tp'|U16'dlen'|ARR0{U8}$U8$'nm']
// file dns_answer.c line 139
struct anonymous$71;

// tag-#anon#ST[U16'udpsize'|U16'rcode'|U16'version'|U8'do_flg'|U8'$pad0']
// file dns.h line 216
struct anonymous$17;

// tag-#anon#ST[U32'index'|ARR0{U8}$U8$'s']
// file dns.h line 279
struct anonymous$64;

// tag-#anon#ST[U64'nel']
// file list.h line 32
struct anonymous$3;

// tag-#anon#ST[U64'nel'|ARR0{*{U8}$U8$}$*{U8}$U8$$'elem']
// file conff.h line 118
struct anonymous$30;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#}$SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#$'elem']
// file conff.h line 67
struct anonymous$8;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'qname'|U64'cs'|U16'num_rrs'|U16'flags'|U32'$pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrext']#'rr']#'$anon0'|U8'c_ns'|U8'c_soa'|U48'$pad1']#}$SYM#tag-#anon#ST[*{U8}$U8$'qname'|U64'cs'|U16'num_rrs'|U16'flags'|U32'$pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrext']#'rr']#'$anon0'|U8'c_ns'|U8'c_soa'|U48'$pad1']#$'elem']
// file dns_query.c line 174
struct anonymous$16;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}$SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#$'elem']
// file conff.h line 60
struct anonymous$19;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'a'|SYM#tag-in_addr#'a4fallback'|S64'timeout'|U16'flags'|S16'nocache'|S16'state'|S16'qm'|S8'auth_serv'|S8'lean_query'|S8'edns_query'|S8'needs_testing'|S8'trusted'|S8'aa'|S8'tc'|S8'failed'|*{cU8}$cU8$'nsdomain'|*{SYM#tag-rejectlist_s#}$SYM#tag-rejectlist_s#$'rejectlist'|S32'sock'|U16'transl'|U16'recvl'|S32'iolen'|U32'$pad0'|*{SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#}$SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#$'msg'|*{SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#}$SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#$'recvbuf'|U16'myrid'|U16'$pad1'|S32's_errno']#}$SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'a'|SYM#tag-in_addr#'a4fallback'|S64'timeout'|U16'flags'|S16'nocache'|S16'state'|S16'qm'|S8'auth_serv'|S8'lean_query'|S8'edns_query'|S8'needs_testing'|S8'trusted'|S8'aa'|S8'tc'|S8'failed'|*{cU8}$cU8$'nsdomain'|*{SYM#tag-rejectlist_s#}$SYM#tag-rejectlist_s#$'rejectlist'|S32'sock'|U16'transl'|U16'recvl'|S32'iolen'|U32'$pad0'|*{SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#}$SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#$'msg'|*{SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#}$SYM#tag-#anon#ST[U16'id'|BF{U32}$U32$'rd'|BF{U32}$U32$'tc'|BF{U32}$U32$'aa'|BF{U32}$U32$'opcode'|BF{U32}$U32$'qr'|BF{U32}$U32$'rcode'|BF{U32}$U32$'cd'|BF{U32}$U32$'ad'|BF{U32}$U32$'z'|BF{U32}$U32$'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#$'recvbuf'|U16'myrid'|U16'$pad1'|S32's_errno']#$'elem']
// file dns_query.c line 118
struct anonymous$4;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#$'elem']
// file conff.h line 80
struct anonymous$12;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#$'elem']
// file conff.h line 53
struct anonymous$14;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#$'elem']
// file conff.h line 73
struct anonymous$10;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[U16'port'|S16'uptest'|U32'$pad0'|S64'timeout'|S64'interval'|S64'ping_timeout'|ARR32{S8}$S8$'scheme'|*{S8}$S8$'uptest_cmd'|ARR21{S8}$S8$'uptest_usr'|ARR16{S8}$S8$'interface'|ARR16{S8}$S8$'device'|U24'$pad1'|*{U8}$U8$'query_test_name'|*{S8}$S8$'label'|S8'purge_cache'|S8'nocache'|S8'lean_query'|S8'edns_query'|S8'is_proxy'|S8'rootserver'|S8'rand_servers'|S8'preset'|S8'rejectrecursively'|U8'$pad2'|S16'rejectpolicy'|S16'policy'|U16'$pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#}$SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#}$SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#$'elem']#$'alist'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}$SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}$SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#$'elem']#$'atup_a'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#$'elem']#$'reject_a4'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#$'elem']#$'reject_a6'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'ping_a']#}$SYM#tag-#anon#ST[U16'port'|S16'uptest'|U32'$pad0'|S64'timeout'|S64'interval'|S64'ping_timeout'|ARR32{S8}$S8$'scheme'|*{S8}$S8$'uptest_cmd'|ARR21{S8}$S8$'uptest_usr'|ARR16{S8}$S8$'interface'|ARR16{S8}$S8$'device'|U24'$pad1'|*{U8}$U8$'query_test_name'|*{S8}$S8$'label'|S8'purge_cache'|S8'nocache'|S8'lean_query'|S8'edns_query'|S8'is_proxy'|S8'rootserver'|S8'rand_servers'|S8'preset'|S8'rejectrecursively'|U8'$pad2'|S16'rejectpolicy'|S16'policy'|U16'$pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#}$SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#}$SYM#tag-#anon#ST[*{U8}$U8$'domain'|S16'exact'|S16'rule'|U32'$pad0']#$'elem']#$'alist'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}$SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}$SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'$pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#$'elem']#$'atup_a'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#$'elem']#$'reject_a4'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#$'elem']#}$SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}$SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#$'elem']#$'reject_a6'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'ping_a']#$'elem']
// file conff.h line 115
struct anonymous$18;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#}$SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#$'elem']
// file conff.h line 52
struct anonymous$54;

// tag-#anon#ST[U8'qlen'|U8'num_rrs'|U16'flags'|U8'c_ns'|U8'c_soa']
// file cache.c line 122
struct anonymous$62;

// tag-#anon#ST[U8'tp'|U8'num_rr'|U16'flags'|S64'ttl'|S64'ts']
// file cache.c line 109
struct anonymous$61;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V$'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$42;

// tag-#anon#UN[ARR16{S8}$S8$'ifrn_name']
// file /usr/include/net/if.h line 130
union anonymous$25;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'|ARR8{U16}$U16$'__u6_addr16'|ARR4{U32}$U32$'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous$27;

// tag-#anon#UN[ARR1{U32}$U32$'icmp6_un_data32'|ARR2{U16}$U16$'icmp6_un_data16'|ARR4{U8}$U8$'icmp6_un_data8']
// file /usr/include/netinet/icmp6.h line 43
union anonymous$37;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0'|SYM#tag-#anon#ST[*{V}$V$'_lower'|*{V}$V$'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$52;

// tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#}$SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}$SYM#tag-rr_lent_s#$'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'$pad0'|*{SYM#tag-rr_b_s#}$SYM#tag-rr_b_s#$'rrs']#$$'rrext']#'rr']
// file cache.h line 63
union anonymous$1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$56;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'id'|U16'sequence']#'echo'|U32'gateway'|SYM#tag-#anon#ST[U16'__unused'|U16'mtu']#'frag']
// file /usr/include/linux/icmp.h line 72
union anonymous$34;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$33;

// tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']
// file ipvers.h line 228
union anonymous$6;

// tag-#anon#UN[SYM#tag-in_pktinfo#'pi4'|SYM#tag-in6_pktinfo#'pi6']
// file dns_answer.c line 90
union anonymous$67;

// tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'|U8'ip6_un2_vfc']
// file /usr/include/netinet/ip6.h line 26
union anonymous$38;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'|SYM#tag-sockaddr#'ifru_dstaddr'|SYM#tag-sockaddr#'ifru_broadaddr'|SYM#tag-sockaddr#'ifru_netmask'|SYM#tag-sockaddr#'ifru_hwaddr'|S16'ifru_flags'|S32'ifru_ivalue'|S32'ifru_mtu'|SYM#tag-ifmap#'ifru_map'|ARR16{S8}$S8$'ifru_slave'|ARR16{S8}$S8$'ifru_newname'|*{S8}$S8$'ifru_data']
// file /usr/include/net/if.h line 135
union anonymous$26;

// tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']
// file dns_answer.c line 105
union anonymous$68;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$39;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$23;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 742
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_dynamic_list_head
// file list.h line 78
struct _dynamic_list_head;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 246
struct cmsghdr;

// tag-dns_hash_ent_s
// file hash.h line 29
struct dns_hash_ent_s;

// tag-icmp6_filter
// file /usr/include/netinet/icmp6.h line 33
struct icmp6_filter;

// tag-icmp6_hdr
// file /usr/include/netinet/icmp6.h line 38
struct icmp6_hdr;

// tag-icmp_filter
// file /usr/include/linux/icmp.h line 92
struct icmp_filter;

// tag-icmphdr
// file /usr/include/linux/icmp.h line 68
struct icmphdr;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in6_pktinfo
// file /usr/include/netinet/in.h line 535
struct in6_pktinfo;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-in_pktinfo
// file /usr/include/x86_64-linux-gnu/bits/in.h line 147
struct in_pktinfo;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip6_hbh
// file /usr/include/netinet/ip6.h line 57
struct ip6_hbh;

// tag-ip6_hdr
// file /usr/include/netinet/ip6.h line 24
struct ip6_hdr;

// tag-ip6_hdrctl
// file /usr/include/netinet/ip6.h line 28
struct ip6_hdrctl;

// tag-iphdr
// file /usr/include/netinet/ip.h line 44
struct iphdr;

// tag-llistnode_s
// file list.h line 118
struct llistnode_s;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 228
struct msghdr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-qhintnode_s
// file dns_query.h line 33
struct qhintnode_s;

// tag-qstatnode_s
// file dns_query.c line 2030
struct qstatnode_s;

// tag-rejectlist_s
// file dns_query.c line 61
struct rejectlist_s;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rr_b_s
// file cache.h line 39
struct rr_b_s;

// tag-rr_infos
// file rr_types.h line 455
struct rr_infos;

// tag-rr_lent_s
// file cache.h line 34
struct rr_lent_s;

// tag-rre_s
// file dns_answer.c line 481
struct rre_s;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

#ifndef NULL
#define NULL ((void*)0)
#endif

// SET_PDNSD_A2
// file ipvers.h line 260
static inline void SET_PDNSD_A2(struct anonymous$15 *a2, union anonymous$6 *a);
// SET_PDNSD_A2$link1
// file ipvers.h line 260
static inline void SET_PDNSD_A2$link1(struct anonymous$15 *a2$link1, union anonymous$6 *a$link1);
// __cmsg_nxthdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 276
extern struct cmsghdr * __cmsg_nxthdr(struct msghdr *, struct cmsghdr *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 680
extern void __pthread_register_cancel(struct anonymous$66 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 692
extern void __pthread_unregister_cancel(struct anonymous$66 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 733
extern void __pthread_unwind_next(struct anonymous$66 *);
// __sigsetjmp
// file /usr/include/pthread.h line 743
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _exit
// file /usr/include/unistd.h line 606
extern void _exit(signed int);
// a2ptrstr
// file dns.c line 306
signed int a2ptrstr(union anonymous$6 *a, signed int tp, unsigned char *buf);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$23, unsigned int *);
// add_additional_a
// file dns_answer.c line 715
static signed int add_additional_a(struct anonymous$28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, signed long int queryts, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva);
// add_additional_rr
// file dns_answer.c line 662
static signed int add_additional_rr(struct anonymous$28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, unsigned int dlen, void *data, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva);
// add_additional_rrs
// file dns_answer.c line 689
static signed int add_additional_rrs(struct anonymous$28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, struct rr_b_s *rrb, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva);
// add_ar
// file dns_answer.c line 495
static signed int add_ar(struct _dynamic_list_head **ar, unsigned short int tp, unsigned short int tsz, void *tnm, unsigned char *nm, unsigned int ttl);
// add_cache
// file cache.h line 173
void add_cache(struct anonymous$0 *cent);
// add_cent_rr
// file cache.h line 201
signed int add_cent_rr(struct anonymous$0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data);
// add_cent_rr_int
// file cache.c line 668
static signed int add_cent_rr_int(struct anonymous$0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data, struct rr_b_s **rtail);
// add_cent_rrset_by_index
// file cache.c line 605
static signed int add_cent_rrset_by_index(struct anonymous$0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags);
// add_cent_rrset_by_type
// file cache.h line 200
signed int add_cent_rrset_by_type(struct anonymous$0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags);
// add_dns_hash
// file hash.h line 69
signed int add_dns_hash(struct anonymous$0 *data, struct anonymous$58 *loc);
// add_host
// file dns.c line 340
static signed int add_host(unsigned char *pn, unsigned char *rns, union anonymous$6 *a, signed int tp, signed int a_sz, signed long int ttl, unsigned int flags, signed int reverse);
// add_opt_pseudo_rr
// file dns_answer.c line 423
signed int add_opt_pseudo_rr(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned short int udpsize, unsigned short int rcode, unsigned short int ednsver, unsigned short int Zflags);
// add_qserv
// file dns_query.c line 1958
static signed int add_qserv(struct anonymous$4 **q, struct anonymous$15 *a, signed int port, signed long int timeout, unsigned int flags, signed int nocache, char lean_query, char edns_query, char auth_s, char needs_testing, char trusted, const unsigned char *nsdomain, struct rejectlist_s *rejectlist);
// add_rejectlist
// file dns_query.c line 2853
static struct rejectlist_s * add_rejectlist(struct rejectlist_s *rl, struct anonymous$7 *sp);
// add_reverse_cache
// file cache.h line 174
signed int add_reverse_cache(struct anonymous$0 *cent);
// add_rr
// file dns_answer.c line 213
static signed int add_rr(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned short int type, unsigned int ttl, unsigned int dlen, void *data, char section, unsigned int *udp, struct _dynamic_list_head **cb);
// add_rrset
// file dns_answer.c line 554
static signed int add_rrset(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int tp, signed long int queryts, struct anonymous$0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar);
// add_to_response
// file dns_answer.c line 605
static signed int add_to_response(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int qtype, signed long int queryts, struct anonymous$0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar);
// addr_add
// file conf-parser.c line 1871
static const char * addr_add(struct anonymous$19 **ata, const char *ipstr);
// adjust_dom_ttl
// file cache.c line 1840
static inline void adjust_dom_ttl(struct anonymous$0 *cent);
// adjust_ttl
// file cache.c line 1817
static inline void adjust_ttl(struct anonymous *rrset);
// alloc_nel
// file list.c line 57
static inline unsigned long int alloc_nel(unsigned long int n);
// ans_ttl
// file dns_answer.c line 170
static inline signed long int ans_ttl(struct anonymous *rrset, signed long int queryts);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// auth_ok
// file dns_query.c line 2554
static signed int auth_ok(struct anonymous$4 *q, const unsigned char *name, signed int thint, struct anonymous$0 *ent, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, struct anonymous$5 *qse, struct _dynamic_list_head *ns, struct anonymous$4 **serv);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$23, unsigned int);
// bind_socket
// file dns_query.c line 682
static signed int bind_socket(signed int s);
// binsearch_keyword
// file consts.h line 65
signed int binsearch_keyword(const char *name, signed int len, const struct anonymous$32 *dic, signed int range);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// change_servers
// file servers.h line 45
signed int change_servers(signed int i, struct anonymous$54 *ar, signed int up);
// chdir
// file /usr/include/unistd.h line 500
extern signed int chdir(const char *);
// check_ipv6
// file main.c line 202
static signed int check_ipv6();
// check_localaddrs
// file conf-parser.c line 1976
static void check_localaddrs(struct anonymous$7 *serv);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// compose_answer
// file dns_answer.c line 752
static struct anonymous$28 * compose_answer(struct anonymous$40 *ql, struct anonymous$29 *hdr, unsigned long int *rlen, struct anonymous$17 *ednsinfo, unsigned int *udp, signed int *rcodep);
// compress_name
// file dns.c line 248
unsigned int compress_name(unsigned char *in, unsigned char *out, unsigned int offs, struct _dynamic_list_head **cb);
// confparse
// file conf-parser.c line 488
signed int confparse(struct _IO_FILE *in, char *prestr, struct anonymous$21 *global, struct anonymous$18 **servers, signed int includedepth, char **errstr);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$23, unsigned int);
// const_name
// file consts.h line 67
const char * const_name(signed int c);
// copy_cent
// file cache.c line 1098
struct anonymous$0 * copy_cent(struct anonymous$0 *cent);
// copy_rr
// file cache.c line 1059
static inline struct rr_b_s * copy_rr(struct rr_b_s *rr);
// copy_rrset
// file cache.c line 1072
static struct anonymous * copy_rrset(struct anonymous *rrset);
// cr_check_add
// file cache.c line 1759
static signed int cr_check_add(struct anonymous$0 *cent, signed int idx, signed long int ttl, signed long int ts, unsigned int flags);
// crash_msg
// file error.c line 52
void crash_msg(char *msg);
// create_rr
// file cache.c line 588
static struct rr_b_s * create_rr(unsigned int dlen, void *data);
// da_grow1
// file list.h line 54
struct anonymous$3 * da_grow1(struct anonymous$3 *a, unsigned long int headsz, unsigned long int elemsz, void (*cleanuproutine)(void *));
// da_grow1::cleanuproutine$object
//
void cleanuproutine$object(void *);
// da_nel
// file list.h line 59
static inline unsigned int da_nel(struct anonymous$3 *a);
// da_nel$link1
// file list.h line 59
static inline unsigned int da_nel$link1(struct anonymous$3 *a$link1);
// da_nel$link2
// file list.h line 59
static inline unsigned int da_nel$link2(struct anonymous$3 *a$link2);
// da_nel$link3
// file list.h line 59
static inline unsigned int da_nel$link3(struct anonymous$3 *a$link3);
// da_nel$link4
// file list.h line 59
static inline unsigned int da_nel$link4(struct anonymous$3 *a$link4);
// da_nel$link5
// file list.h line 59
static inline unsigned int da_nel$link5(struct anonymous$3 *a$link5);
// da_nel$link6
// file list.h line 59
static inline unsigned int da_nel$link6(struct anonymous$3 *a$link6);
// da_resize
// file list.h line 55
struct anonymous$3 * da_resize(struct anonymous$3 *a, unsigned long int headsz, unsigned long int elemsz, unsigned long int n, void (*cleanuproutine)(void *));
// da_resize::cleanuproutine$object
//
void cleanuproutine$object(void *);
// debug_msg
// file error.h line 74
void debug_msg(signed int c, const char *fmt, ...);
// decode_query
// file dns_answer.c line 1003
static signed int decode_query(unsigned char *data, unsigned long int rlen, unsigned char **ptrrem, unsigned long int *lenrem, struct anonymous$40 *qp);
// decode_query_additional
// file dns_answer.c line 1058
static signed int decode_query_additional(unsigned char *data, unsigned long int rlen, unsigned char *ptr, unsigned long int sz, signed int numrr, signed int *numopt, struct anonymous$17 *ep);
// decompress_name
// file dns.c line 44
signed int decompress_name(unsigned char *msg, unsigned long int msgsz, unsigned char **src, unsigned long int *sz, unsigned char *tgt, unsigned int *len);
// decrease_procs
// file dns_answer.c line 1347
static inline void decrease_procs();
// del_cache
// file cache.h line 175
void del_cache(const unsigned char *name);
// del_cache_ent
// file cache.c line 2075
static void del_cache_ent(struct anonymous$0 *cent, struct anonymous$58 *loc);
// del_cent
// file cache.c line 2061
void del_cent(struct anonymous$0 *cent);
// del_cent_rrset_by_index
// file cache.c line 776
static signed int del_cent_rrset_by_index(struct anonymous$0 *cent, signed int i);
// del_dns_hash
// file hash.h line 71
struct anonymous$0 * del_dns_hash(const unsigned char *key);
// del_dns_hash_ent
// file hash.h line 70
struct anonymous$0 * del_dns_hash_ent(struct anonymous$58 *loc);
// del_qserv
// file dns_query.c line 2025
static inline void del_qserv(struct anonymous$4 *q);
// del_rrset
// file cache.h line 202
signed int del_rrset(struct anonymous *rrs);
// destroy_cache
// file cache.h line 163
void destroy_cache(void);
// dev_up
// file netdev.c line 135
signed int dev_up(char *ifname, char *devname);
// dlist_first
// file list.h line 87
static inline void * dlist_first(struct _dynamic_list_head *a);
// dlist_first$link1
// file list.h line 87
static inline void * dlist_first$link1(struct _dynamic_list_head *a$link1);
// dlist_first$link2
// file list.h line 87
static inline void * dlist_first$link2(struct _dynamic_list_head *a$link2);
// dlist_grow
// file list.h line 112
struct _dynamic_list_head * dlist_grow(struct _dynamic_list_head *a, unsigned long int len);
// dlist_last
// file list.h line 107
static inline void * dlist_last(struct _dynamic_list_head *a);
// dlist_last$link1
// file list.h line 107
static inline void * dlist_last$link1(struct _dynamic_list_head *a$link1);
// dlist_last$link2
// file list.h line 107
static inline void * dlist_last$link2(struct _dynamic_list_head *a$link2);
// dlist_next
// file list.h line 98
static inline void * dlist_next(void *ref);
// dlist_next$link1
// file list.h line 98
static inline void * dlist_next$link1(void *ref$link1);
// dlist_next$link2
// file list.h line 98
static inline void * dlist_next$link2(void *ref$link2);
// dns_hash
// file hash.c line 57
static unsigned int dns_hash(const unsigned char *str, unsigned long int *rhash);
// dns_lookup
// file hash.h line 68
struct anonymous$0 * dns_lookup(const unsigned char *key, struct anonymous$58 *loc);
// dns_rootserver_resolv
// file dns_query.c line 2978
struct anonymous$14 * dns_rootserver_resolv(struct anonymous$19 *atup_a, signed int port, char edns_query, signed long int timeout);
// dnsflags2str
// file dns.c line 544
char * dnsflags2str(struct anonymous$29 *hdr, char *buf);
// domain_match
// file dns.c line 204
unsigned int domain_match(const unsigned char *ms, const unsigned char *md, unsigned int *os, unsigned int *od);
// dump_cache
// file cache.h line 168
signed int dump_cache(signed int fd, const unsigned char *name, signed int exact);
// dump_cent
// file cache.c line 2395
static signed int dump_cent(signed int fd, struct anonymous$0 *cent);
// dup2
// file /usr/include/unistd.h line 537
extern signed int dup2(signed int, signed int);
// empty_cache
// file cache.h line 162
signed int empty_cache(struct anonymous$8 *sla);
// equiv_inaddr2
// file helpers.h line 149
static inline signed int equiv_inaddr2(union anonymous$6 *a, struct anonymous$15 *b);
// equiv_inaddr2$link1
// file helpers.h line 149
static inline signed int equiv_inaddr2$link1(union anonymous$6 *a$link1, struct anonymous$15 *b$link1);
// equiv_inaddr2$link2
// file helpers.h line 149
static inline signed int equiv_inaddr2$link2(union anonymous$6 *a$link2, struct anonymous$15 *b$link2);
// escapestr
// file helpers.c line 583
signed int escapestr(const char *in, signed int ilen, char *str, signed int size);
// exclusive_lock_server_data
// file servers.h line 43
signed int exclusive_lock_server_data(signed int tm);
// exclusive_unlock_server_data
// file servers.h line 44
void exclusive_unlock_server_data(signed int retest);
// execl
// file /usr/include/unistd.h line 576
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fetch_first
// file hash.h line 76
struct anonymous$0 * fetch_first(struct anonymous$59 *pos);
// fetch_next
// file hash.h line 77
struct anonymous$0 * fetch_next(struct anonymous$59 *pos);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// final_init
// file main.c line 179
signed int final_init();
// flags2str
// file cache.h line 119
char * flags2str(unsigned int flags, char *buf, signed int nflags, const char *flgnames);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// follow_cname_chain
// file dns_answer.c line 188
static inline signed int follow_cname_chain(struct anonymous$0 *c, unsigned char *name);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 759
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_cent
// file cache.h line 203
void free_cent(struct anonymous$0 *cent);
// free_cent0
// file cache.h line 204
void free_cent0(void *ptr);
// free_dns_hash
// file hash.h line 74
void free_dns_hash();
// free_dns_hash_bucket
// file hash.h line 72
void free_dns_hash_bucket(signed int i);
// free_dns_hash_selected
// file hash.h line 73
void free_dns_hash_selected(signed int i, struct anonymous$8 *sla);
// free_rejectlist
// file dns_query.c line 2892
static inline void free_rejectlist(struct rejectlist_s *rl);
// free_server_data
// file conff.c line 390
static void free_server_data(struct anonymous$18 *sa);
// free_servparm
// file conff.h line 187
void free_servparm(struct anonymous$7 *serv);
// free_slist_array
// file conff.c line 368
void free_slist_array(struct anonymous$8 *sla);
// free_slist_domain
// file conff.h line 185
void free_slist_domain(void *ptr);
// free_zone
// file conff.h line 184
void free_zone(void *ptr);
// free_zones
// file conff.c line 354
static void free_zones(struct anonymous$30 *za);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fsprintf
// file helpers.h line 170
signed int fsprintf(signed int fd, const char *format, ...);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_cname
// file dns.c line 492
const char * get_cname(signed int id);
// get_ename
// file dns.c line 532
const char * get_ename(signed int id);
// get_rand16
// file helpers.h line 168
unsigned short int get_rand16(void);
// get_rrlent_ts
// file cache.c line 880
static inline signed long int get_rrlent_ts(struct rr_lent_s *le);
// get_tname
// file dns.c line 501
const char * get_tname(signed int id);
// getgid
// file /usr/include/unistd.h line 684
extern unsigned int getgid(void);
// getline
// file /usr/include/stdio.h line 678
extern signed long int getline(char ** restrict , unsigned long int *, struct _IO_FILE *);
// getlocalowner
// file cache.h line 178
unsigned char * getlocalowner(unsigned char *name, signed int tp);
// getnextp
// file conf-parser.c line 84
static char * getnextp(char **buf, unsigned long int *n, struct _IO_FILE *in, char *p, unsigned int *linenr, char **errstr);
// getpwnam_r
// file /usr/include/pwd.h line 151
extern signed int getpwnam_r(const char *, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// getrrset
// file cache.h line 221
static inline struct anonymous * getrrset(struct anonymous$0 *cent, signed int type);
// getrrset$link1
// file cache.h line 221
static inline struct anonymous * getrrset$link1(struct anonymous$0 *cent$link1, signed int type$link1);
// getrrset$link2
// file cache.h line 221
static inline struct anonymous * getrrset$link2(struct anonymous$0 *cent$link2, signed int type$link2);
// getrrset_eff
// file cache.h line 251
static inline struct anonymous * getrrset_eff(struct anonymous$0 *cent, signed int type);
// getrrset_eff$link1
// file cache.h line 251
static inline struct anonymous * getrrset_eff$link1(struct anonymous$0 *cent$link1, signed int type$link1);
// getrrset_eff$link2
// file cache.h line 251
static inline struct anonymous * getrrset_eff$link2(struct anonymous$0 *cent$link2, signed int type$link2);
// getrrset_eff$link3
// file cache.h line 251
static inline struct anonymous * getrrset_eff$link3(struct anonymous$0 *cent$link3, signed int type$link3);
// getrrtpname
// file dns.c line 480
const char * getrrtpname(signed int tp);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 678
extern unsigned int getuid(void);
// have_rr
// file cache.h line 274
static inline signed int have_rr(struct anonymous$0 *cent, signed int type);
// have_rr$link1
// file cache.h line 274
static inline signed int have_rr$link1(struct anonymous$0 *cent$link1, signed int type$link1);
// have_rr$link2
// file cache.h line 274
static inline signed int have_rr$link2(struct anonymous$0 *cent$link2, signed int type$link2);
// hexdump
// file helpers.c line 546
void hexdump(const void *data, signed int dlen, char *buf, signed int buflen);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// icmp4_errcmp
// file icmp.c line 136
static signed int icmp4_errcmp(char *packet, signed int plen, struct in_addr *to, char *errmsg, signed int elen, signed int errtype);
// icmp6_errcmp
// file icmp.c line 330
static signed int icmp6_errcmp(char *packet, signed int plen, struct in6_addr *to, char *errmsg, signed int elen, signed int errtype);
// if_up
// file netdev.c line 186
signed int if_up(char *devname);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_cache_lock
// file cache.h line 157
static inline void init_cache_lock();
// init_cent
// file cache.h line 199
signed int init_cent(struct anonymous$0 *cent, const unsigned char *qname, signed long int ttl, signed long int ts, unsigned int flags);
// init_crandom
// file helpers.c line 447
void init_crandom();
// init_log_lock
// file error.h line 45
static inline void init_log_lock(void);
// init_ping_socket
// file icmp.c line 114
void init_ping_socket(void);
// init_rng
// file helpers.c line 458
signed int init_rng(void);
// init_stat_sock
// file status.h line 56
void init_stat_sock(void);
// init_tcp_socket
// file dns_answer.c line 1967
signed int init_tcp_socket(void);
// init_udp_socket
// file dns_answer.c line 1536
signed int init_udp_socket(void);
// initgroups
// file /usr/include/grp.h line 198
extern signed int initgroups(const char *, unsigned int);
// insert_rrl
// file cache.c line 889
static signed int insert_rrl(struct anonymous *rrs, struct anonymous$0 *cent, signed int idx);
// invalidate_record
// file cache.h line 176
void invalidate_record(const unsigned char *name);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_inaddr2_any
// file helpers.h line 123
static inline signed int is_inaddr2_any(struct anonymous$15 *a);
// is_inaddr_any
// file helpers.h line 115
static inline signed int is_inaddr_any(union anonymous$6 *a);
// is_inaddr_any$link1
// file helpers.h line 115
static inline signed int is_inaddr_any$link1(union anonymous$6 *a$link1);
// is_inaddr_any$link2
// file helpers.h line 115
static inline signed int is_inaddr_any$link2(union anonymous$6 *a$link2);
// is_interrupted_servstat_thread
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread();
// is_interrupted_servstat_thread$link1
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread$link1();
// is_local_addr
// file netdev.h line 30
signed int is_local_addr(union anonymous$6 *a);
// isnormalencdomname
// file helpers.h line 112
signed int isnormalencdomname(const unsigned char *rhn, unsigned int maxlen);
// keyncmp
// file consts.c line 98
static inline signed int keyncmp(const char *key1, signed int len, const char *key2);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// listmerge
// file cache.c line 972
static struct rr_lent_s * listmerge(struct rr_lent_s *p, struct rr_lent_s *q);
// llist_first
// file list.h line 145
static inline void * llist_first(struct anonymous$40 *a);
// llist_free
// file list.h line 168
void llist_free(struct anonymous$40 *a);
// llist_grow
// file list.h line 167
signed int llist_grow(struct anonymous$40 *a, unsigned long int len);
// llist_init
// file list.h line 130
static inline void llist_init(struct anonymous$40 *a);
// llist_isempty
// file list.h line 138
static inline signed int llist_isempty(struct anonymous$40 *a);
// llist_last
// file list.h line 161
static inline void * llist_last(struct anonymous$40 *a);
// llist_next
// file list.h line 153
static inline void * llist_next(void *ref);
// loc2str
// file rr_types.c line 80
const char * loc2str(const void *binary, char *ascii, unsigned long int asclen);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// lock_cache_r
// file cache.c line 235
static void lock_cache_r(void);
// lock_cache_rw
// file cache.c line 269
static void lock_cache_rw(void);
// lock_server_data
// file servers.h line 41
void lock_server_data();
// log_message
// file error.h line 50
void log_message(signed int prior, const char *s, ...);
// lookup_cache
// file cache.h line 179
struct anonymous$0 * lookup_cache(const unsigned char *name, signed int *wild);
// lookup_cache_local_rrset
// file cache.h line 180
struct anonymous * lookup_cache_local_rrset(const unsigned char *name, signed int type);
// lookup_cache_status
// file dns_query.c line 3235
static signed int lookup_cache_status(const unsigned char *name, signed int thint, struct anonymous$0 **cachedp, unsigned short int *flagsp, signed long int queryts, unsigned char *c_soa);
// lookup_cent_array
// file dns_query.c line 1094
static struct anonymous$0 * lookup_cent_array(struct anonymous$16 *ca, const unsigned char *nm);
// lookup_const
// file consts.h line 66
signed int lookup_const(const char *name, signed int len);
// lookup_ns
// file dns_query.c line 2904
static struct anonymous$14 * lookup_ns(const unsigned char *domain);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mark_servers
// file servers.h line 39
signed int mark_servers(signed int i, char *label, signed int up);
// memcmp
// file /usr/include/string.h line 65
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// mempcpy
// file /usr/include/string.h line 386
extern void * mempcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mk_dns_hash
// file hash.h line 61
static inline void mk_dns_hash();
// mk_error_reply
// file dns_answer.c line 1133
static void mk_error_reply(unsigned short int id, unsigned short int opcode, unsigned short int rescode, struct anonymous$29 *rep);
// mk_flag_val
// file cache.h line 187
static inline unsigned int mk_flag_val(struct anonymous$7 *server);
// mk_netmask4
// file conf-parser.c line 1903
static inline unsigned int mk_netmask4(signed int len);
// mk_netmask6
// file conf-parser.c line 1915
static inline void mk_netmask6(struct in6_addr *m, signed int len);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// needs_intermittent_testing
// file servers.h line 56
static inline signed int needs_intermittent_testing(struct anonymous$7 *sp);
// needs_testing
// file servers.h line 49
static inline signed int needs_testing(struct anonymous$7 *sp);
// needs_testing$link1
// file servers.h line 49
static inline signed int needs_testing$link1(struct anonymous$7 *sp$link1);
// negate_cent
// file cache.h line 205
void negate_cent(struct anonymous$0 *cent, signed long int ttl, signed long int ts);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// p_cancel_query
// file dns_query.c line 1926
static void p_cancel_query(struct anonymous$5 *st);
// p_dns_cached_resolve
// file dns_query.c line 3340
static signed int p_dns_cached_resolve(struct anonymous$4 *q, const unsigned char *name, signed int thint, struct anonymous$0 **cachedp, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa);
// p_dns_resolve
// file dns_query.c line 3066
static signed int p_dns_resolve(const unsigned char *name, signed int thint, struct anonymous$0 **cachedp, signed int hops, struct qhintnode_s *qhlist, unsigned char *c_soa);
// p_exec_query
// file dns_query.c line 1137
static signed int p_exec_query(struct anonymous$0 **entp, const unsigned char *name, signed int thint, struct anonymous$5 *st, struct _dynamic_list_head **ns, unsigned char *c_soa);
// p_query_sm
// file dns_query.c line 847
static signed int p_query_sm(struct anonymous$5 *st);
// p_recursive_query
// file dns_query.c line 2070
static signed int p_recursive_query(struct anonymous$4 *q, const unsigned char *name, signed int thint, struct anonymous$0 **entp, signed int *nocache, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, unsigned char *c_soa);
// parse_ip
// file conf-parser.c line 1841
static const char * parse_ip(const char *ipstr, union anonymous$6 *a);
// parsestr2rhn
// file helpers.h line 54
const char * parsestr2rhn(const unsigned char *str, unsigned int len, unsigned char *rhn);
// pdnsd_a2str
// file helpers.h line 157
const char * pdnsd_a2str(union anonymous$6 *a, char *buf, signed int maxlen);
// pdnsd_exit
// file pdnsd_assert.h line 38
void pdnsd_exit(void);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// ping
// file icmp.c line 514
signed int ping(union anonymous$6 *addr, signed int timeout, signed int rep);
// ping4
// file icmp.c line 160
static signed int ping4(struct in_addr addr, signed int timeout, signed int rep);
// ping6
// file icmp.c line 371
static signed int ping6(struct in6_addr a, signed int timeout, signed int rep);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// precsize_ntoa
// file rr_types.c line 60
static const char * precsize_ntoa(unsigned char prec, char *retbuf);
// print_serr
// file status.c line 61
static signed int print_serr(signed int rs, const char *msg);
// print_succ
// file status.c line 77
static signed int print_succ(signed int rs);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_query
// file dns_answer.c line 1156
static struct anonymous$28 * process_query(unsigned char *data, unsigned long int *rlenp, unsigned int *udp, signed int *rcodep);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 299
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous$56 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 977
extern signed int pthread_cond_signal(union anonymous$56 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_timedwait(union anonymous$56 *, union anonymous$33 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous$56 *, union anonymous$33 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 278
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 242
extern void pthread_exit(void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1119
extern void * pthread_getspecific(unsigned int);
// pthread_key_create
// file /usr/include/pthread.h line 1111
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous$33 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 758
extern signed int pthread_mutex_trylock(union anonymous$33 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous$33 *);
// pthread_self
// file /usr/include/pthread.h line 275
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1122
extern signed int pthread_setspecific(unsigned int, const void *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$41 *, struct anonymous$41 *);
// purge_all_rrsets
// file cache.c line 1207
static signed int purge_all_rrsets(struct anonymous$0 *cent, signed int test, signed int *numrrsrem);
// purge_cache
// file cache.c line 1314
static void purge_cache(signed long int sz, signed int lazy);
// purge_cent
// file cache.c line 1257
static signed int purge_cent(struct anonymous$0 *cent, signed int delete, signed int test);
// purge_rrset
// file cache.c line 1188
static signed int purge_rrset(struct anonymous$0 *cent, signed int idx, signed int test);
// query_stat_same_inaddr2
// file dns_query.c line 2013
static inline signed int query_stat_same_inaddr2(struct anonymous$5 *qs, struct anonymous$15 *b);
// query_uptest
// file dns_query.c line 3513
signed int query_uptest(union anonymous$6 *addr, signed int port, const unsigned char *name, signed long int timeout, signed int rep);
// r_dns_cached_resolve
// file dns_query.h line 36
signed int r_dns_cached_resolve(unsigned char *name, signed int thint, struct anonymous$0 **cachedp, signed int hops, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// randrr
// file dns_answer.c line 519
static inline struct rr_b_s * randrr(struct rr_b_s *rrb);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// read_allocstring
// file status.c line 122
static signed int read_allocstring(signed int fh, char **res, unsigned int *len);
// read_config_file
// file conff.h line 182
signed int read_config_file(const char *nm, struct anonymous$21 *global, struct anonymous$18 **servers, signed int includedepth, char **errstr);
// read_disk_cache
// file cache.h line 164
void read_disk_cache(void);
// read_domain
// file status.c line 148
static signed int read_domain(signed int fh, char *buf, unsigned int buflen);
// read_hosts
// file dns.h line 291
signed int read_hosts(const char *fn, unsigned char *rns, signed long int ttl, unsigned int flags, signed int aliases, char **errstr);
// read_long
// file status.c line 104
static signed int read_long(signed int fh, unsigned int *res);
// read_resolv_conf
// file conf-parser.c line 2009
static signed int read_resolv_conf(const char *fn, struct anonymous$19 **ata, char **errstr);
// read_short
// file status.c line 91
static signed int read_short(signed int fh, unsigned short int *res);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realloc_or_cleanup
// file dns_query.c line 784
static inline void * realloc_or_cleanup(void *ptr, unsigned long int size);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, union anonymous$23, unsigned int *);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// reject_add
// file conf-parser.c line 1926
static const char * reject_add(struct anonymous$7 *serv, const char *ipstr);
// reload_config_file
// file conff.c line 222
signed int reload_config_file(const char *nm, char **errstr);
// remove_opt_pseudo_rr
// file dns_answer.c line 462
unsigned long int remove_opt_pseudo_rr(struct anonymous$28 *ans, unsigned long int sz);
// remove_rrl
// file cache.c line 953
static void remove_rrl(struct rr_lent_s *le);
// report_cache_stat
// file cache.h line 167
signed int report_cache_stat(signed int f);
// report_conf_stat
// file conff.c line 399
signed int report_conf_stat(signed int f);
// report_error
// file conf-parser.c line 54
static char * report_error(const char *conftype, unsigned int linenr, const char *msg);
// report_errorf
// file conf-parser.c line 70
static char * report_errorf(const char *conftype, unsigned int linenr, const char *frm, ...);
// report_server_stat
// file conff.c line 501
static signed int report_server_stat(signed int f, signed int i);
// report_thread_stat
// file dns_answer.c line 2141
signed int report_thread_stat(signed int f);
// resolv_rootserver_addrs
// file servers.c line 289
static struct anonymous$14 * resolv_rootserver_addrs(struct anonymous$19 *a, signed int port, char edns_query, signed long int timeout);
// retest
// file servers.c line 230
static void retest(signed int i, signed int j);
// rhn2str
// file helpers.h line 52
const unsigned char * rhn2str(const unsigned char *rhn, unsigned char *str, unsigned int size);
// rhncpy
// file helpers.h line 111
unsigned int rhncpy(unsigned char *dst, const unsigned char *src);
// rhnicmp
// file helpers.h line 214
static inline signed int rhnicmp(const unsigned char *a, const unsigned char *b);
// rhnicmp$link1
// file helpers.h line 214
static inline signed int rhnicmp$link1(const unsigned char *a$link1, const unsigned char *b$link1);
// rhnicmp$link2
// file helpers.h line 214
static inline signed int rhnicmp$link2(const unsigned char *a$link2, const unsigned char *b$link2);
// rhnlen
// file helpers.h line 62
static inline unsigned int rhnlen(const unsigned char *rhn);
// rhnlen$link1
// file helpers.h line 62
static inline unsigned int rhnlen$link1(const unsigned char *rhn$link1);
// rhnlen$link2
// file helpers.h line 62
static inline unsigned int rhnlen$link2(const unsigned char *rhn$link2);
// rhnlen$link3
// file helpers.h line 62
static inline unsigned int rhnlen$link3(const unsigned char *rhn$link3);
// rhnlen$link4
// file helpers.h line 62
static inline unsigned int rhnlen$link4(const unsigned char *rhn$link4);
// rhnlen$link5
// file helpers.h line 62
static inline unsigned int rhnlen$link5(const unsigned char *rhn$link5);
// rhnlen$link6
// file helpers.h line 62
static inline unsigned int rhnlen$link6(const unsigned char *rhn$link6);
// rhnsegcnt
// file helpers.h line 100
static inline unsigned int rhnsegcnt(const unsigned char *rhn);
// rhnsegcnt$link1
// file helpers.h line 100
static inline unsigned int rhnsegcnt$link1(const unsigned char *rhn$link1);
// rhnsegcnt$link2
// file helpers.h line 100
static inline unsigned int rhnsegcnt$link2(const unsigned char *rhn$link2);
// rr_to_cache
// file dns_query.c line 183
static signed int rr_to_cache(struct anonymous$16 **centa, unsigned char *oname, signed int tp, signed long int ttl, unsigned int dlen, void *data, unsigned int flags, signed long int queryts);
// rr_tp_byname
// file rr_types.h line 533
signed int rr_tp_byname(char *name);
// rrs2cent
// file dns_query.c line 229
static signed int rrs2cent(unsigned char *msg, unsigned long int msgsz, unsigned char **ptr, unsigned long int *lcnt, signed int recnum, unsigned int flags, signed long int queryts, struct anonymous$16 **centa, signed int *numopt, struct anonymous$17 *ep);
// run_as
// file helpers.h line 37
signed int run_as(const char *user);
// same_inaddr2
// file helpers.h line 141
static inline signed int same_inaddr2(union anonymous$6 *a, struct anonymous$15 *b);
// scan_string
// file conf-parser.c line 186
static signed int scan_string(char **curp, char *outbuf, unsigned int outbufsz, char **errstr);
// sched_server_test
// file servers.h line 38
void sched_server_test(union anonymous$6 *sa, signed int nadr, signed int up);
// scheme_ok
// file servers.c line 203
static signed int scheme_ok(struct anonymous$7 *serv);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, union anonymous$23, unsigned int);
// servstat_thread
// file servers.c line 314
void * servstat_thread(void *p);
// set_all_flags_ttl
// file dns_query.c line 3210
static void set_all_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous$0 *cached);
// set_cent_flags
// file cache.h line 177
signed int set_cent_flags(const unsigned char *name, unsigned int flags);
// set_flags_ttl
// file dns_query.c line 3196
static signed int set_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous$0 *cached, signed int tp);
// setgid
// file /usr/include/unistd.h line 720
extern signed int setgid(unsigned int);
// setsid
// file /usr/include/unistd.h line 670
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 703
extern signed int setuid(unsigned int);
// sigaction
// file /usr/include/signal.h line 257
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 219
extern signed int sigaddset(struct anonymous$41 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 213
extern signed int sigemptyset(struct anonymous$41 *);
// sigint_handler
// file servers.c line 853
static void sigint_handler(signed int signum);
// sigwait
// file /usr/include/signal.h line 268
extern signed int sigwait(const struct anonymous$41 *, signed int *);
// simple_dns_cached_resolve
// file dns_query.c line 3446
static signed int simple_dns_cached_resolve(struct anonymous$19 *atup_a, signed int port, char edns_query, signed long int timeout, const unsigned char *name, signed int thint, struct anonymous$0 **cachedp);
// skiprhn
// file helpers.h line 88
static inline unsigned char * skiprhn(unsigned char *rhn);
// skiprhn$link1
// file helpers.h line 88
static inline unsigned char * skiprhn$link1(unsigned char *rhn$link1);
// skiprhn$link2
// file helpers.h line 88
static inline unsigned char * skiprhn$link2(unsigned char *rhn$link2);
// skipsegs
// file helpers.h line 74
static inline const unsigned char * skipsegs(const unsigned char *nm, unsigned int k);
// skipsegs$link1
// file helpers.h line 74
static inline const unsigned char * skipsegs$link1(const unsigned char *nm$link1, unsigned int k$link1);
// skipsegs$link2
// file helpers.h line 74
static inline const unsigned char * skipsegs$link2(const unsigned char *nm$link2, unsigned int k$link2);
// slist_add
// file conf-parser.c line 2074
static const char * slist_add(struct anonymous$8 **sla, const char *nm, unsigned int len, signed int tp);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// soa_minimum
// file dns_query.c line 1106
static signed long int soa_minimum(struct rr_b_s *rrs);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// softlock_cache_r
// file cache.c line 371
static signed int softlock_cache_r(void);
// softlock_cache_rw
// file cache.c line 408
static signed int softlock_cache_rw(void);
// softlock_mutex
// file helpers.h line 39
signed int softlock_mutex(union anonymous$33 *mutex);
// softunlock_cache_r
// file cache.c line 396
static signed int softunlock_cache_r(void);
// softunlock_cache_rw
// file cache.c line 432
static signed int softunlock_cache_rw(void);
// sort_rrl
// file cache.c line 1012
static void sort_rrl();
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// start_dns_servers
// file dns_answer.c line 2109
void start_dns_servers(void);
// start_servstat_thread
// file servers.h line 37
signed int start_servstat_thread(void);
// start_stat_sock
// file status.h line 57
signed int start_stat_sock(void);
// status_thread
// file status.c line 172
static void * status_thread(void *p);
// statusif
// file netdev.c line 110
signed int statusif(char *name);
// stpcpy
// file /usr/include/string.h line 564
extern char * stpcpy(char *, const char *);
// stpncpy
// file /usr/include/string.h line 572
extern char * stpncpy(char *, const char *, unsigned long int);
// str2pdnsd_a
// file helpers.h line 156
signed int str2pdnsd_a(const char *addr, union anonymous$6 *a);
// str2rhn
// file helpers.h line 53
signed int str2rhn(const unsigned char *str, unsigned char *rhn);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncp
// file helpers.h line 234
static inline signed int strncp(char *dst, const char *src, unsigned long int dstsz);
// strncp$link1
// file helpers.h line 234
static inline signed int strncp$link1(char *dst$link1, const char *src$link1, unsigned long int dstsz$link1);
// strncp$link2
// file helpers.h line 234
static inline signed int strncp$link2(char *dst$link2, const char *src$link2, unsigned long int dstsz$link2);
// strndup
// file /usr/include/string.h line 179
extern char * strndup(const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtotime
// file conf-parser.c line 249
static signed long int strtotime(char *nptr, char **endptr, char **errstr);
// sva_add
// file dns_answer.c line 149
static signed int sva_add(struct _dynamic_list_head **sva, const unsigned char *rhn, unsigned short int tp, unsigned short int dlen, void *data);
// switch_to_tcp
// file dns_query.c line 814
static inline void switch_to_tcp(struct anonymous$5 *st);
// switch_to_udp
// file dns_query.c line 803
static inline void switch_to_udp(struct anonymous$5 *st);
// tcp_answer_thread
// file dns_answer.c line 1811
static void * tcp_answer_thread(void *csock);
// tcp_answer_thread::1::1::2::4::4::__cancel_routine$object
//
void __cancel_routine$object(void *);
// tcp_answer_thread::1::1::2::4::5::__cancel_routine$object
//
void __cancel_routine$object(void *);
// tcp_answer_thread::1::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// tcp_answer_thread_cleanup
// file dns_answer.c line 1801
static void tcp_answer_thread_cleanup(void *csock);
// tcp_server_thread
// file dns_answer.c line 2033
void * tcp_server_thread(void *p);
// test_onquery
// file servers.h line 40
void test_onquery(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timedlock_cache_rw
// file cache.c line 285
static signed int timedlock_cache_rw(signed int tm);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// translescapedchar
// file conf-parser.c line 149
static char translescapedchar(char c);
// udp_answer_thread
// file dns_answer.c line 1368
static void * udp_answer_thread(void *data);
// udp_answer_thread::1::1::2::5::__cancel_routine$object
//
void __cancel_routine$object(void *);
// udp_answer_thread::1::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// udp_answer_thread_cleanup
// file dns_answer.c line 1356
static void udp_answer_thread_cleanup(void *data);
// udp_server_thread
// file dns_answer.c line 1623
void * udp_server_thread(void *dummy);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// unlock_cache_r
// file cache.c line 250
static void unlock_cache_r(void);
// unlock_cache_rw
// file cache.c line 311
static void unlock_cache_rw(void);
// unlock_server_data
// file servers.h line 42
void unlock_server_data();
// uptest
// file servers.c line 73
static signed int uptest(struct anonymous$7 *serv, signed int j);
// use_server
// file dns_query.c line 2820
static signed int use_server(struct anonymous$7 *s, const unsigned char *name);
// usleep_r
// file thread.h line 113
static inline signed int usleep_r(unsigned long int useconds);
// usleep_r$link1
// file thread.h line 113
static inline signed int usleep_r$link1(unsigned long int useconds$link1);
// usleep_r$link2
// file thread.h line 113
static inline signed int usleep_r$link2(unsigned long int useconds$link2);
// usleep_r$link3
// file thread.h line 113
static inline signed int usleep_r$link3(unsigned long int useconds$link3);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// write_all
// file helpers.h line 182
static inline signed long int write_all(signed int fd, const void *data, unsigned long int n);
// write_all$link1
// file helpers.h line 182
static inline signed long int write_all$link1(signed int fd$link1, const void *data$link1, unsigned long int n$link1);
// write_all$link2
// file helpers.h line 182
static inline signed long int write_all$link2(signed int fd$link2, const void *data$link2, unsigned long int n$link2);
// write_disk_cache
// file cache.h line 165
void write_disk_cache(void);
// write_rrset
// file cache.c line 1554
static signed int write_rrset(signed int tp, struct anonymous *rrs, struct _IO_FILE *f);
// yield_lock_cache_rw
// file cache.c line 336
static void yield_lock_cache_rw();
// zone_add
// file conf-parser.c line 2103
static const char * zone_add(struct anonymous$30 **za, const char *zone, unsigned int len);

struct anonymous$58
{
  // pos
  struct dns_hash_ent_s **pos;
  // rhash
  unsigned long int rhash;
};

struct anonymous$40
{
  // first
  struct llistnode_s *first;
  // last
  struct llistnode_s *last;
};

struct anonymous$24
{
  // lent
  struct rr_lent_s *lent;
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
};

struct anonymous
{
  // lent
  struct rr_lent_s *lent;
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
  // flags
  unsigned short int flags;
  // rrs
  struct rr_b_s *rrs;
};

struct anonymous$9
{
  // domain
  unsigned char *domain;
  // exact
  signed short int exact;
  // rule
  signed short int rule;
};

struct anonymous$2
{
  // rrmu
  struct anonymous *rrmu[8l];
  // rrext
  struct anonymous **rrext;
};

union anonymous$1
{
  // neg
  struct anonymous$24 neg;
  // rr
  struct anonymous$2 rr;
};

struct anonymous$0
{
  // qname
  unsigned char *qname;
  // cs
  unsigned long int cs;
  // num_rrs
  unsigned short int num_rrs;
  // flags
  unsigned short int flags;
  // $anon0
  union anonymous$1 $anon0;
  // c_ns
  unsigned char c_ns;
  // c_soa
  unsigned char c_soa;
};

struct anonymous$51
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$48
{
  // _lower
  void *_lower;
  // _upper
  void *_upper;
};

struct anonymous$49
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
  // si_addr_bnd
  struct anonymous$48 si_addr_bnd;
};

struct anonymous$32
{
  // name
  const char *name;
  // val
  signed int val;
};

struct anonymous$53
{
  // name
  char name[10l];
  // phone
  char phone[32l];
  // outgoing
  signed int outgoing;
};

struct anonymous$41
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$65
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$66
{
  // __cancel_jmp_buf
  struct anonymous$65 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$55
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$59
{
  // bucket
  signed int bucket;
  // ent
  struct dns_hash_ent_s *ent;
};

struct anonymous$44
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$47
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$46
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$45
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$50
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$52
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$44 _kill;
  // _timer
  struct anonymous$45 _timer;
  // _rt
  struct anonymous$46 _rt;
  // _sigchld
  struct anonymous$47 _sigchld;
  // _sigfault
  struct anonymous$49 _sigfault;
  // _sigpoll
  struct anonymous$50 _sigpoll;
  // _sigsys
  struct anonymous$51 _sigsys;
};

struct anonymous$43
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$52 _sifields;
};

union anonymous$27
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct in6_addr
{
  // __in6_u
  union anonymous$27 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct anonymous$15
{
  // ipv6
  struct in6_addr ipv6;
  // ipv4
  struct in_addr ipv4;
};

struct anonymous$20
{
  // i_ts
  signed long int i_ts;
  // is_up
  char is_up;
  // a
  struct anonymous$15 a;
};

union anonymous$6
{
  // ipv4
  struct in_addr ipv4;
  // ipv6
  struct in6_addr ipv6;
};

struct anonymous$21
{
  // perm_cache
  signed long int perm_cache;
  // cache_dir
  char *cache_dir;
  // pidfile
  char *pidfile;
  // port
  signed int port;
  // a
  union anonymous$6 a;
  // out_a
  union anonymous$6 out_a;
  // ipv4_6_prefix
  struct in6_addr ipv4_6_prefix;
  // max_ttl
  signed long int max_ttl;
  // min_ttl
  signed long int min_ttl;
  // neg_ttl
  signed long int neg_ttl;
  // neg_rrs_pol
  signed short int neg_rrs_pol;
  // neg_domain_pol
  signed short int neg_domain_pol;
  // verbosity
  signed short int verbosity;
  // run_as
  char run_as[21l];
  // daemon
  char daemon;
  // debug
  char debug;
  // stat_pipe
  char stat_pipe;
  // notcp
  char notcp;
  // strict_suid
  char strict_suid;
  // use_nss
  char use_nss;
  // paranoid
  char paranoid;
  // lndown_kluge
  char lndown_kluge;
  // onquery
  char onquery;
  // rnd_recs
  char rnd_recs;
  // ctl_perms
  signed int ctl_perms;
  // scheme_file
  char *scheme_file;
  // proc_limit
  signed int proc_limit;
  // procq_limit
  signed int procq_limit;
  // tcp_qtimeout
  signed long int tcp_qtimeout;
  // timeout
  signed long int timeout;
  // par_queries
  signed int par_queries;
  // query_method
  signed int query_method;
  // query_port_start
  signed int query_port_start;
  // query_port_end
  signed int query_port_end;
  // udpbufsize
  signed int udpbufsize;
  // deleg_only_zones
  struct anonymous$30 *deleg_only_zones;
};

struct anonymous$63
{
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
} __attribute__ ((__packed__));

struct anonymous$31
{
  // prefix
  char prefix;
  // pidfile
  char pidfile;
  // verbosity
  char verbosity;
  // pdnsduser
  char pdnsduser;
  // daemon
  char daemon;
  // debug
  char debug;
  // stat_pipe
  char stat_pipe;
  // notcp
  char notcp;
  // query_method
  char query_method;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

union anonymous$68
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

struct anonymous$5
{
  // a
  union anonymous$68 a;
  // a4fallback
  struct in_addr a4fallback;
  // timeout
  signed long int timeout;
  // flags
  unsigned short int flags;
  // nocache
  signed short int nocache;
  // state
  signed short int state;
  // qm
  signed short int qm;
  // auth_serv
  char auth_serv;
  // lean_query
  char lean_query;
  // edns_query
  char edns_query;
  // needs_testing
  char needs_testing;
  // trusted
  char trusted;
  // aa
  char aa;
  // tc
  char tc;
  // failed
  char failed;
  // nsdomain
  const unsigned char *nsdomain;
  // rejectlist
  struct rejectlist_s *rejectlist;
  // sock
  signed int sock;
  // transl
  unsigned short int transl;
  // recvl
  unsigned short int recvl;
  // iolen
  signed int iolen;
  // msg
  struct anonymous$28 *msg;
  // recvbuf
  struct anonymous$29 *recvbuf;
  // myrid
  unsigned short int myrid;
  // s_errno
  signed int s_errno;
};

struct in_pktinfo
{
  // ipi_ifindex
  signed int ipi_ifindex;
  // ipi_spec_dst
  struct in_addr ipi_spec_dst;
  // ipi_addr
  struct in_addr ipi_addr;
};

struct in6_pktinfo
{
  // ipi6_addr
  struct in6_addr ipi6_addr;
  // ipi6_ifindex
  unsigned int ipi6_ifindex;
};

union anonymous$67
{
  // pi4
  struct in_pktinfo pi4;
  // pi6
  struct in6_pktinfo pi6;
};

struct anonymous$69
{
  // addr
  union anonymous$68 addr;
  // pi
  union anonymous$67 pi;
  // sock
  signed int sock;
  // proto
  signed int proto;
  // len
  unsigned long int len;
  // buf
  unsigned char buf[0l];
};

struct anonymous$13
{
  // a
  struct in6_addr a;
  // mask
  struct in6_addr mask;
};

struct anonymous$11
{
  // a
  struct in_addr a;
  // mask
  struct in_addr mask;
};

struct anonymous$36
{
  // __unused
  unsigned short int __unused;
  // mtu
  unsigned short int mtu;
};

struct anonymous$29
{
  // id
  unsigned short int id;
  // rd
  unsigned int rd : 1;
  // tc
  unsigned int tc : 1;
  // aa
  unsigned int aa : 1;
  // opcode
  unsigned int opcode : 4;
  // qr
  unsigned int qr : 1;
  // rcode
  unsigned int rcode : 4;
  // cd
  unsigned int cd : 1;
  // ad
  unsigned int ad : 1;
  // z
  unsigned int z : 1;
  // ra
  unsigned int ra : 1;
  // qdcount
  unsigned short int qdcount;
  // ancount
  unsigned short int ancount;
  // nscount
  unsigned short int nscount;
  // arcount
  unsigned short int arcount;
} __attribute__ ((__packed__));

struct anonymous$35
{
  // id
  unsigned short int id;
  // sequence
  unsigned short int sequence;
};

struct anonymous$28
{
  // len
  unsigned short int len;
  // hdr
  struct anonymous$29 hdr;
} __attribute__ ((__packed__));

struct anonymous$7
{
  // port
  unsigned short int port;
  // uptest
  signed short int uptest;
  // timeout
  signed long int timeout;
  // interval
  signed long int interval;
  // ping_timeout
  signed long int ping_timeout;
  // scheme
  char scheme[32l];
  // uptest_cmd
  char *uptest_cmd;
  // uptest_usr
  char uptest_usr[21l];
  // interface
  char interface[16l];
  // device
  char device[16l];
  // query_test_name
  unsigned char *query_test_name;
  // label
  char *label;
  // purge_cache
  char purge_cache;
  // nocache
  char nocache;
  // lean_query
  char lean_query;
  // edns_query
  char edns_query;
  // is_proxy
  char is_proxy;
  // rootserver
  char rootserver;
  // rand_servers
  char rand_servers;
  // preset
  char preset;
  // rejectrecursively
  char rejectrecursively;
  // rejectpolicy
  signed short int rejectpolicy;
  // policy
  signed short int policy;
  // alist
  struct anonymous$8 *alist;
  // atup_a
  struct anonymous$19 *atup_a;
  // reject_a4
  struct anonymous$10 *reject_a4;
  // reject_a6
  struct anonymous$12 *reject_a6;
  // ping_a
  union anonymous$6 ping_a;
};

struct anonymous$70
{
  // qtype
  unsigned short int qtype;
  // qclass
  unsigned short int qclass;
  // query
  unsigned char query[0l];
};

struct anonymous$60
{
  // rdlen
  unsigned short int rdlen;
};

struct anonymous$71
{
  // tp
  unsigned short int tp;
  // dlen
  unsigned short int dlen;
  // nm
  unsigned char nm[0l];
};

struct anonymous$17
{
  // udpsize
  unsigned short int udpsize;
  // rcode
  unsigned short int rcode;
  // version
  unsigned short int version;
  // do_flg
  unsigned char do_flg;
};

struct anonymous$64
{
  // index
  unsigned int index;
  // s
  unsigned char s[0l];
};

struct anonymous$3
{
  // nel
  unsigned long int nel;
};

struct anonymous$30
{
  // nel
  unsigned long int nel;
  // elem
  unsigned char *elem[0l];
};

struct anonymous$8
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$9 elem[0l];
};

struct anonymous$16
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$0 elem[0l];
};

struct anonymous$19
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$20 elem[0l];
};

struct anonymous$4
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$5 elem[0l];
};

struct anonymous$12
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$13 elem[0l];
};

struct anonymous$14
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$15 elem[0l];
};

struct anonymous$10
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$11 elem[0l];
};

struct anonymous$18
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous$7 elem[0l];
};

struct anonymous$54
{
  // nel
  unsigned long int nel;
  // elem
  union anonymous$6 elem[0l];
};

struct anonymous$62
{
  // qlen
  unsigned char qlen;
  // num_rrs
  unsigned char num_rrs;
  // flags
  unsigned short int flags;
  // c_ns
  unsigned char c_ns;
  // c_soa
  unsigned char c_soa;
} __attribute__ ((__packed__));

struct anonymous$61
{
  // tp
  unsigned char tp;
  // num_rr
  unsigned char num_rr;
  // flags
  unsigned short int flags;
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
} __attribute__ ((__packed__));

union anonymous$42
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$43 *, void *);
};

union anonymous$25
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous$37
{
  // icmp6_un_data32
  unsigned int icmp6_un_data32[1l];
  // icmp6_un_data16
  unsigned short int icmp6_un_data16[2l];
  // icmp6_un_data8
  unsigned char icmp6_un_data8[4l];
};

union anonymous$56
{
  // __data
  struct anonymous$55 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$34
{
  // echo
  struct anonymous$35 echo;
  // gateway
  unsigned int gateway;
  // frag
  struct anonymous$36 frag;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$33
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ip6_hdrctl
{
  // ip6_un1_flow
  unsigned int ip6_un1_flow;
  // ip6_un1_plen
  unsigned short int ip6_un1_plen;
  // ip6_un1_nxt
  unsigned char ip6_un1_nxt;
  // ip6_un1_hlim
  unsigned char ip6_un1_hlim;
};

union anonymous$38
{
  // ip6_un1
  struct ip6_hdrctl ip6_un1;
  // ip6_un2_vfc
  unsigned char ip6_un2_vfc;
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous$26
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

union anonymous$39
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$23
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _dynamic_list_head
{
  // last
  unsigned long int last;
  // lastsz
  unsigned long int lastsz;
  // data
  char data[0l];
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct dns_hash_ent_s
{
  // next
  struct dns_hash_ent_s *next;
  // rhash
  unsigned long int rhash;
  // data
  struct anonymous$0 *data;
};

struct icmp6_filter
{
  // icmp6_filt
  unsigned int icmp6_filt[8l];
};

struct icmp6_hdr
{
  // icmp6_type
  unsigned char icmp6_type;
  // icmp6_code
  unsigned char icmp6_code;
  // icmp6_cksum
  unsigned short int icmp6_cksum;
  // icmp6_dataun
  union anonymous$37 icmp6_dataun;
};

struct icmp_filter
{
  // data
  unsigned int data;
};

struct icmphdr
{
  // type
  unsigned char type;
  // code
  unsigned char code;
  // checksum
  unsigned short int checksum;
  // un
  union anonymous$34 un;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous$25 ifr_ifrn;
  // ifr_ifru
  union anonymous$26 ifr_ifru;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip6_hbh
{
  // ip6h_nxt
  unsigned char ip6h_nxt;
  // ip6h_len
  unsigned char ip6h_len;
};

struct ip6_hdr
{
  // ip6_ctlun
  union anonymous$38 ip6_ctlun;
  // ip6_src
  struct in6_addr ip6_src;
  // ip6_dst
  struct in6_addr ip6_dst;
};

struct iphdr
{
  // ihl
  unsigned int ihl : 4;
  // version
  unsigned int version : 4;
  // tos
  unsigned char tos;
  // tot_len
  unsigned short int tot_len;
  // id
  unsigned short int id;
  // frag_off
  unsigned short int frag_off;
  // ttl
  unsigned char ttl;
  // protocol
  unsigned char protocol;
  // check
  unsigned short int check;
  // saddr
  unsigned int saddr;
  // daddr
  unsigned int daddr;
};

struct llistnode_s
{
  // next
  struct llistnode_s *next;
  // data
  char *data[0l];
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct qhintnode_s
{
  // nm
  const unsigned char *nm;
  // tp
  signed int tp;
  // next
  struct qhintnode_s *next;
};

struct qstatnode_s
{
  // qa
  struct anonymous$4 *qa;
  // next
  struct qstatnode_s *next;
};

struct rejectlist_s
{
  // next
  struct rejectlist_s *next;
  // policy
  signed short int policy;
  // inherit
  signed short int inherit;
  // na4
  signed int na4;
  // na6
  signed int na6;
  // rdata
  struct anonymous$13 rdata[0l];
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct rr_b_s
{
  // next
  struct rr_b_s *next;
  // rdlen
  unsigned int rdlen;
  // data
  struct in6_addr data[0l];
};

struct rr_infos
{
  // class
  unsigned short int class;
  // excludes
  unsigned short int excludes;
};

struct rr_lent_s
{
  // next
  struct rr_lent_s *next;
  // prev
  struct rr_lent_s *prev;
  // rrset
  struct anonymous *rrset;
  // cent
  struct anonymous$0 *cent;
  // idx
  signed int idx;
};

struct rre_s
{
  // tp
  unsigned short int tp;
  // tsz
  unsigned short int tsz;
  // ttl
  unsigned int ttl;
  // tnm
  unsigned char tnm[0l];
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$42 __sigaction_handler;
  // sa_mask
  struct anonymous$41 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};


// ar_offs
// file dns_answer.c line 545
static const signed int ar_offs[6l] = { 0, 0, 0, 0, 2, 6 };
// ar_recs
// file dns_answer.c line 539
static const signed int ar_recs[6l] = { 2, 3, 4, 7, 15, 33 };
// attr_detached
// file thread.c line 41
union pthread_attr_t attr_detached;
// c_names
// file dns.c line 489
static const char * const c_names[4l] = { "IN", "CS", "CH", "HS" };
// cache_r_lock
// file cache.c line 165
static volatile signed int cache_r_lock = 0;
// cache_size
// file cache.c line 161
static volatile signed long int cache_size = (volatile signed long int)0;
// cache_w_lock
// file cache.c line 164
static volatile signed int cache_w_lock = 0;
// cachverid
// file cache.c line 46
static const char cachverid[4l] = { (const char)112, (const char)100, (const char)49, (const char)51 };
// cflgnames
// file cache.c line 2698
const char cflgnames[21l] = { (const char)78, (const char)69, (const char)71, (const char)76, (const char)79, (const char)67, (const char)65, (const char)85, (const char)84, (const char)78, (const char)79, (const char)67, (const char)65, (const char)68, (const char)68, (const char)78, (const char)79, (const char)80, (const char)82, (const char)84, (const char)83 };
// cmdline
// file main.c line 61
struct anonymous$31 cmdline = { .prefix=(char)0, .pidfile=0, .verbosity=0, .pdnsduser=0,
    .daemon=0, .debug=0, .stat_pipe=0, .notcp=0,
    .query_method=0 };
// cmdlineipv
// file main.c line 59
signed short int cmdlineipv = (signed short int)0;
// conf_file
// file main.c line 70
char *conf_file = "/etc/pdnsd.conf";
// const_dic
// file consts.c line 31
static const struct anonymous$32 const_dic[29l] = { { .name="auth", .val=22 }, { .name="default", .val=3 }, { .name="dev", .val=16 }, { .name="diald", .val=17 }, { .name="discover", .val=4 }, { .name="domain", .val=23 }, { .name="excluded", .val=19 }, { .name="exec", .val=7 }, { .name="fail", .val=24 }, { .name="false", .val=2 }, { .name="fqdn_only", .val=21 }, { .name="if", .val=6 }, { .name="included", .val=18 }, { .name="negate", .val=25 }, { .name="no", .val=2 }, { .name="none", .val=5 }, { .name="off", .val=2 }, { .name="on", .val=1 }, { .name="onquery", .val=10 }, { .name="ontimeout", .val=11 }, { .name="ping", .val=8 }, { .name="query", .val=9 }, { .name="simple_only", .val=20 }, { .name="tcp_only", .val=13 }, { .name="tcp_udp", .val=14 }, { .name="true", .val=1 }, { .name="udp_only", .val=12 }, { .name="udp_tcp", .val=15 }, { .name="yes", .val=1 } };
// const_names
// file consts.c line 64
static const char * const const_names[26l] = { "error", "on", "off", "default", "discover", "none", "if", "exec", "ping", "query", "onquery", "ontimeout", "udp_only", "tcp_only", "tcp_udp", "udp_tcp", "dev", "diald", "included", "excluded", "simple_only", "fqdn_only", "auth", "domain", "fail", "negate" };
// da_mem_errs
// file dns_answer.c line 75
static volatile unsigned long int da_mem_errs = (volatile unsigned long int)0;
// da_misc_errs
// file dns_answer.c line 78
static volatile unsigned long int da_misc_errs = (volatile unsigned long int)0;
// da_tcp_errs
// file dns_answer.c line 73
static volatile unsigned long int da_tcp_errs = (volatile unsigned long int)0;
// da_thrd_errs
// file dns_answer.c line 76
static volatile unsigned long int da_thrd_errs = (volatile unsigned long int)0;
// da_udp_errs
// file dns_answer.c line 74
static volatile unsigned long int da_udp_errs = (volatile unsigned long int)0;
// dbg_file
// file main.c line 65
struct _IO_FILE *dbg_file = (struct _IO_FILE *)(void *)0;
// debug_p
// file main.c line 52
signed short int debug_p = (signed short int)0;
// dflgnames
// file cache.c line 2699
const char dflgnames[15l] = { (const char)78, (const char)69, (const char)71, (const char)76, (const char)79, (const char)67, (const char)65, (const char)85, (const char)84, (const char)78, (const char)79, (const char)67, (const char)87, (const char)76, (const char)68 };
// dropped
// file dns_answer.c line 82
static volatile unsigned long int dropped = (volatile unsigned long int)0;
// e_names
// file dns.c line 512
static const char * const e_names[17l] = { "no error", "query format error", "server failed", "non-existent domain", "not supported", "query refused", "name exists when it should not", "RR set exists when it should not", "RR set that should exist does not", "server not authoritative for zone", "name not contained in zone", "11", "12", "13", "14", "15", "bad OPT version" };
// ent_num
// file cache.c line 162
static volatile signed long int ent_num = (volatile signed long int)0;
// global
// file conff.c line 40
struct anonymous$21 global = { .perm_cache=(signed long int)2048, .cache_dir=(char *)(void *)0, .pidfile=(char *)(void *)0,
    .port=53, .a={ .ipv4={ .s_addr=(unsigned int)0x00000000 } },
    .out_a={ .ipv4={ .s_addr=(unsigned int)0x00000000 } },
    .ipv4_6_prefix={ .__in6_u={ .__u6_addr8={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    .max_ttl=(signed long int)604800,
    .min_ttl=(signed long int)120, .neg_ttl=(signed long int)900,
    .neg_rrs_pol=(signed short int)3, .neg_domain_pol=(signed short int)22,
    .verbosity=(signed short int)0,
    .run_as={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .daemon=(char)0,
    .debug=(char)0, .stat_pipe=(char)0, .notcp=(char)0,
    .strict_suid=(char)1, .use_nss=(char)1,
    .paranoid=(char)0, .lndown_kluge=(char)0,
    .onquery=(char)0, .rnd_recs=(char)1,
    .ctl_perms=0600, .scheme_file=(char *)(void *)0, .proc_limit=40,
    .procq_limit=60, .tcp_qtimeout=(signed long int)30, .timeout=(signed long int)0,
    .par_queries=2, .query_method=12,
    .query_port_start=1024, .query_port_end=65535,
    .udpbufsize=1024, .deleg_only_zones=(struct anonymous$30 *)(void *)0 };
// global_options
// file conf-keywords.h line 127
static const struct anonymous$32 global_options[39l] = { { .name="cache_dir", .val=8 }, { .name="ctl_perms", .val=30 }, { .name="daemon", .val=22 }, { .name="debug", .val=29 }, { .name="delegation_only", .val=42 }, { .name="ignore_cd", .val=20 }, { .name="interface", .val=10 }, { .name="ipv4_6_prefix", .val=28 }, { .name="linkdown_kluge", .val=13 }, { .name="max_ttl", .val=14 }, { .name="min_ttl", .val=15 }, { .name="neg_domain_pol", .val=38 }, { .name="neg_rrs_pol", .val=37 }, { .name="neg_ttl", .val=36 }, { .name="outgoing_ip", .val=11 }, { .name="outside_interface", .val=11 }, { .name="par_queries", .val=34 }, { .name="paranoid", .val=19 }, { .name="perm_cache", .val=7 }, { .name="pid_file", .val=24 }, { .name="proc_limit", .val=31 }, { .name="procq_limit", .val=32 }, { .name="query_method", .val=26 }, { .name="query_port_end", .val=40 }, { .name="query_port_start", .val=39 }, { .name="randomize_recs", .val=35 }, { .name="run_as", .val=16 }, { .name="run_ipv4", .val=27 }, { .name="scheme_file", .val=12 }, { .name="server_ip", .val=10 }, { .name="server_port", .val=9 }, { .name="status_ctl", .val=21 }, { .name="strict_setuid", .val=17 }, { .name="tcp_qtimeout", .val=33 }, { .name="tcp_server", .val=23 }, { .name="timeout", .val=47 }, { .name="udpbufsize", .val=41 }, { .name="use_nss", .val=18 }, { .name="verbosity", .val=25 } };
// hash_buckets
// file hash.c line 50
struct dns_hash_ent_s *hash_buckets[1024l];
// help_message
// file main.c line 93
static const char help_message[1711l] = { '\n', '\n', 'U', 's', 'a', 'g', 'e', ':', ' ', 'p', 'd', 'n', 's', 'd', ' ', '[', '-', 'h', ']', ' ', '[', '-', 'V', ']', ' ', '[', '-', 's', ']', ' ', '[', '-', 'd', ']', ' ', '[', '-', 'g', ']', ' ', '[', '-', 't', ']', ' ', '[', '-', 'p', ' ', 'f', 'i', 'l', 'e', ']', ' ', '[', '-', 'v', 'n', ']', ' ', '[', '-', 'm', 'x', 'x', ']', ' ', '[', '-', 'c', ' ', 'f', 'i', 'l', 'e', ']', ' ', '[', '-', '4', ']', ' ', '[', '-', '6', ']', ' ', '[', '-', 'i', ' ', 'p', 'r', 'e', 'f', 'i', 'x', ']', ' ', '[', '-', 'a', ']', '\n', '\n', 'O', 'p', 't', 'i', 'o', 'n', 's', ':', '\n', '-', 'h', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'h', 'e', 'l', 'p', '\t', '\t', 'p', 'r', 'i', 'n', 't', ' ', 't', 'h', 'i', 's', ' ', 'h', 'e', 'l', 'p', ' ', 'p', 'a', 'g', 'e', ' ', 'a', 'n', 'd', ' ', 'e', 'x', 'i', 't', '.', '\n', '-', 'V', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'v', 'e', 'r', 's', 'i', 'o', 'n', '\t', 'p', 'r', 'i', 'n', 't', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'a', 'n', 'd', ' ', 'l', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'n', 'd', ' ', 'e', 'x', 'i', 't', '.', '\n', '-', '-', 'p', 'd', 'n', 's', 'd', '-', 'u', 's', 'e', 'r', '\t', 'p', 'r', 'i', 'n', 't', ' ', 't', 'h', 'e', ' ', 'u', 's', 'e', 'r', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'w', 'i', 'l', 'l', ' ', 'r', 'u', 'n', ' ', 'a', 's', ' ', 'a', 'n', 'd', ' ', 'e', 'x', 'i', 't', '.', '\n', '-', 's', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 's', 't', 'a', 't', 'u', 's', '\t', 'E', 'n', 'a', 'b', 'l', 'e', ' ', 's', 't', 'a', 't', 'u', 's', ' ', 'c', 'o', 'n', 't', 'r', 'o', 'l', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '.', '\n', '-', 'd', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'd', 'a', 'e', 'm', 'o', 'n', '\t', 'S', 't', 'a', 'r', 't', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'i', 'n', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'm', 'o', 'd', 'e', ' ', '(', 'a', 's', ' ', 'b', 'a', 'c', 'k', 'g', 'r', 'o', 'u', 'n', 'd', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', '.', ')', '\n', '-', 'g', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'd', 'e', 'b', 'u', 'g', '\t', '\t', 'P', 'r', 'i', 'n', 't', ' ', 's', 'o', 'm', 'e', ' ', 'd', 'e', 'b', 'u', 'g', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', 's', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's', 'o', 'l', 'e', ' ', 'o', 'r', ' ', 't', 'o', ' ', 't', 'h', 'e', '\n', '\t', '\t', 'f', 'i', 'l', 'e', ' ', 'p', 'd', 'n', 's', 'd', '.', 'd', 'e', 'b', 'u', 'g', ' ', 'i', 'n', ' ', 'y', 'o', 'u', 'r', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', '(', 'i', 'n', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'm', 'o', 'd', 'e', ')', '.', '\n', '-', 't', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 't', 'c', 'p', '\t', '\t', 'E', 'n', 'a', 'b', 'l', 'e', 's', ' ', 't', 'h', 'e', ' ', 'T', 'C', 'P', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 't', 'h', 'r', 'e', 'a', 'd', '.', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'w', 'i', 'l', 'l', ' ', 't', 'h', 'e', 'n', ' ', 's', 'e', 'r', 'v', 'e', '\n', '\t', '\t', 'T', 'C', 'P', ' ', 'a', 'n', 'd', ' ', 'U', 'D', 'P', ' ', 'q', 'u', 'e', 'r', 'i', 'e', 's', '.', '\n', '-', 'p', '\t', '\t', 'W', 'r', 'i', 't', 'e', 's', ' ', 't', 'h', 'e', ' ', 'p', 'i', 'd', ' ', 't', 'h', 'e', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'r', 'u', 'n', 's', ' ', 'a', 's', ' ', 't', 'o', ' ', 'a', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', '.', '\n', '\t', '\t', 'W', 'o', 'r', 'k', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'i', 'n', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'm', 'o', 'd', 'e', '.', '\n', '-', 'v', 'n', '\t', '\t', 's', 'e', 't', 's', ' ', 't', 'h', 'e', ' ', 'v', 'e', 'r', 'b', 'o', 's', 'i', 't', 'y', ' ', 'o', 'f', ' ', 'p', 'd', 'n', 's', 'd', '.', ' ', 'n', ' ', 'i', 's', ' ', 'a', ' ', 'n', 'u', 'm', 'e', 'r', 'i', 'c', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f', 'r', 'o', 'm', ' ', '0', '\n', '\t', '\t', '(', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ')', ' ', 't', 'o', ' ', '9', ' ', '(', 'm', 'a', 'n', 'y', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'd', 'e', 'b', 'u', 'g', 'g', 'i', 'n', 'g', ')', '.', '\n', '\t', '\t', 'U', 's', 'e', ' ', 'l', 'i', 'k', 'e', ' ', '-', 'v', '2', '\n', '-', 'm', 'x', 'x', '\t', '\t', 's', 'e', 't', 's', ' ', 't', 'h', 'e', ' ', 'q', 'u', 'e', 'r', 'y', ' ', 'm', 'e', 't', 'h', 'o', 'd', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'u', 's', 'e', 's', '.', ' ', 'P', 'o', 's', 's', 'i', 'b', 'l', 'e', ' ', 'v', 'a', 'l', 'u', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'x', 'x', ' ', 'a', 'r', 'e', ':', '\n', '\t', '\t', 'u', 'o', ' ', '(', 'U', 'D', 'P', ' ', 'o', 'n', 'l', 'y', ')', ',', ' ', 't', 'o', ' ', '(', 'T', 'C', 'P', ' ', 'o', 'n', 'l', 'y', ')', ',', ' ', 't', 'u', ' ', '(', 'T', 'C', 'P', ' ', 'o', 'r', ',', ' ', 'i', 'f', ' ', 't', 'h', 'e', ' ', 's', 'e', 'r', 'v', 'e', 'r', '\n', '\t', '\t', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 't', 'h', 'i', 's', ',', ' ', 'U', 'D', 'P', ')', ' ', 'a', 'n', 'd', ' ', 'u', 't', ' ', '(', 'U', 'D', 'P', ' ', 'a', 'n', 'd', ',', ' ', 'i', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'p', 'l', 'y', ' ', 'w', 'a', 's', '\n', '\t', '\t', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', 'd', ',', ' ', 'T', 'C', 'P', ')', '.', ' ', 'U', 's', 'e', ' ', 'l', 'i', 'k', 'e', ' ', '-', 'm', 'u', 'o', '.', ' ', 'P', 'r', 'e', 's', 'e', 't', ':', ' ', '-', 'm', 'u', 'o', '\n', '-', 'c', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'c', 'o', 'n', 'f', 'i', 'g', '-', 'f', 'i', 'l', 'e', '\t', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 's', ' ', 't', 'h', 'e', ' ', 'f', 'i', 'l', 'e', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'i', 's', ' ', 'r', 'e', 'a', 'd', ' ', 'f', 'r', 'o', 'm', '.', '\n', '\t', '\t', 'D', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'i', 's', ' ', '/', 'e', 't', 'c', '/', 'p', 'd', 'n', 's', 'd', '.', 'c', 'o', 'n', 'f', '\n', '-', '4', '\t', '\t', 's', 'w', 'i', 't', 'c', 'h', 'e', 's', ' ', 't', 'o', ' ', 'I', 'P', 'v', '4', ' ', 'm', 'o', 'd', 'e', '.', '\n', '\t', '\t', 'O', 'n', ' ', 'b', 'y', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', '.', '\n', '-', '6', '\t', '\t', 's', 'w', 'i', 't', 'c', 'h', 'e', 's', ' ', 't', 'o', ' ', 'I', 'P', 'v', '6', ' ', 'm', 'o', 'd', 'e', '.', '\n', '\t', '\t', 'O', 'f', 'f', ' ', 'b', 'y', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', '.', '\n', '-', 'i', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'i', 'p', 'v', '4', '_', '6', '_', 'p', 'r', 'e', 'f', 'i', 'x', '\t', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 's', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'e', 'f', 'i', 'x', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'u', 's', 'e', 's', ' ', 't', 'o', ' ', 'm', 'a', 'p', ' ', 'I', 'P', 'v', '4', ' ', 't', 'o', ' ', 'I', 'P', 'v', '6', '\n', '\t', '\t', 'a', 'd', 'd', 'r', 'e', 's', 's', 'e', 's', '.', ' ', 'M', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd', ' ', 'I', 'P', 'v', '6', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', '.', '\n', '\t', '\t', 'D', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'i', 's', ' ', ':', ':', 'f', 'f', 'f', 'f', ':', '0', '.', '0', '.', '0', '.', '0', '\n', '-', 'a', '\t', '\t', 'W', 'i', 't', 'h', ' ', 't', 'h', 'i', 's', ' ', 'o', 'p', 't', 'i', 'o', 'n', ',', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'w', 'i', 'l', 'l', ' ', 't', 'r', 'y', ' ', 't', 'o', ' ', 'd', 'e', 't', 'e', 'c', 't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y', ' ', 'i', 'f', '\n', '\t', '\t', 't', 'h', 'e', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 's', ' ', 'I', 'P', 'v', '6', ',', ' ', 'a', 'n', 'd', ' ', 'r', 'e', 'v', 'e', 'r', 't', ' ', 't', 'o', ' ', 'I', 'P', 'v', '4', ' ', 'o', 't', 'h', 'e', 'r', 'w', 'i', 's', 'e', '.', '\n', '\n', '\n', '"', 'n', 'o', '"', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 'p', 'r', 'e', 'p', 'e', 'n', 'd', 'e', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', '-', '-', 's', 't', 'a', 't', 'u', 's', ',', ' ', '-', '-', 'd', 'a', 'e', 'm', 'o', 'n', ',', ' ', '-', '-', 'd', 'e', 'b', 'u', 'g', ' ', 'a', 'n', 'd', ' ', '-', '-', 't', 'c', 'p', '\n', 'o', 'p', 't', 'i', 'o', 'n', 's', ' ', '(', 'e', '.', 'g', '.', ' ', '-', '-', 'n', 'o', 't', 'c', 'p', ')', ' ', 't', 'o', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'e', ' ', 't', 'h', 'e', 'i', 'r', ' ', 'e', 'f', 'f', 'e', 'c', 't', '.', '\n', 0 };
// icmp_errs
// file icmp.c line 69
static volatile unsigned long int icmp_errs = (volatile unsigned long int)0;
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// include_options
// file conf-keywords.h line 229
static const struct anonymous$32 include_options[1l] = { { .name="file", .val=81 } };
// info_message
// file main.c line 74
static const char info_message[778l] = { 'p', 'd', 'n', 's', 'd', ' ', '-', ' ', 'd', 'n', 's', ' ', 'p', 'r', 'o', 'x', 'y', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ',', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', '1', '.', '2', '.', '9', 'a', '-', 'p', 'a', 'r', '\n', '\n', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '(', 'C', ')', ' ', '2', '0', '0', '0', ',', ' ', '2', '0', '0', '1', ' ', 'T', 'h', 'o', 'm', 'a', 's', ' ', 'M', 'o', 'e', 's', 't', 'l', '\n', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '(', 'C', ')', ' ', '2', '0', '0', '2', ',', ' ', '2', '0', '0', '3', ',', ' ', '2', '0', '0', '4', ',', ' ', '2', '0', '0', '5', ',', ' ', '2', '0', '0', '6', ',', ' ', '2', '0', '0', '7', ',', ' ', '2', '0', '0', '8', ',', ' ', '2', '0', '1', '0', ' ', 'P', 'a', 'u', 'l', ' ', 'A', '.', ' ', 'R', 'o', 'm', 'b', 'o', 'u', 't', 's', '\n', '\n', 'p', 'd', 'n', 's', 'd', ' ', 'i', 's', ' ', 'f', 'r', 'e', 'e', ' ', 's', 'o', 'f', 't', 'w', 'a', 'r', 'e', ';', ' ', 'y', 'o', 'u', ' ', 'c', 'a', 'n', ' ', 'r', 'e', 'd', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 'i', 't', ' ', 'a', 'n', 'd', '/', 'o', 'r', ' ', 'm', 'o', 'd', 'i', 'f', 'y', '\n', 'i', 't', ' ', 'u', 'n', 'd', 'e', 'r', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'a', 's', ' ', 'p', 'u', 'b', 'l', 'i', 's', 'h', 'e', 'd', ' ', 'b', 'y', '\n', 't', 'h', 'e', ' ', 'F', 'r', 'e', 'e', ' ', 'S', 'o', 'f', 't', 'w', 'a', 'r', 'e', ' ', 'F', 'o', 'u', 'n', 'd', 'a', 't', 'i', 'o', 'n', ';', ' ', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', '3', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ',', ' ', 'o', 'r', '\n', '(', 'a', 't', ' ', 'y', 'o', 'u', 'r', ' ', 'o', 'p', 't', 'i', 'o', 'n', ')', ' ', 'a', 'n', 'y', ' ', 'l', 'a', 't', 'e', 'r', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', '.', '\n', '\n', 'p', 'd', 'n', 's', 'd', ' ', 'i', 's', ' ', 'd', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'h', 'o', 'p', 'e', ' ', 't', 'h', 'a', 't', ' ', 'i', 't', ' ', 'w', 'i', 'l', 'l', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'f', 'u', 'l', ',', '\n', 'b', 'u', 't', ' ', 'W', 'I', 'T', 'H', 'O', 'U', 'T', ' ', 'A', 'N', 'Y', ' ', 'W', 'A', 'R', 'R', 'A', 'N', 'T', 'Y', ';', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'e', 'v', 'e', 'n', ' ', 't', 'h', 'e', ' ', 'i', 'm', 'p', 'l', 'i', 'e', 'd', ' ', 'w', 'a', 'r', 'r', 'a', 'n', 't', 'y', ' ', 'o', 'f', '\n', 'M', 'E', 'R', 'C', 'H', 'A', 'N', 'T', 'A', 'B', 'I', 'L', 'I', 'T', 'Y', ' ', 'o', 'r', ' ', 'F', 'I', 'T', 'N', 'E', 'S', 'S', ' ', 'F', 'O', 'R', ' ', 'A', ' ', 'P', 'A', 'R', 'T', 'I', 'C', 'U', 'L', 'A', 'R', ' ', 'P', 'U', 'R', 'P', 'O', 'S', 'E', '.', ' ', ' ', 'S', 'e', 'e', ' ', 't', 'h', 'e', '\n', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'f', 'o', 'r', ' ', 'm', 'o', 'r', 'e', ' ', 'd', 'e', 't', 'a', 'i', 'l', 's', '.', '\n', '\n', 'Y', 'o', 'u', ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'h', 'a', 'v', 'e', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'a', ' ', 'c', 'o', 'p', 'y', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', '\n', 'a', 'l', 'o', 'n', 'g', ' ', 'w', 'i', 't', 'h', ' ', 'p', 'd', 's', 'n', 'd', ';', ' ', 's', 'e', 'e', ' ', 't', 'h', 'e', ' ', 'f', 'i', 'l', 'e', ' ', 'C', 'O', 'P', 'Y', 'I', 'N', 'G', '.', ' ', ' ', 'I', 'f', ' ', 'n', 'o', 't', ',', ' ', 's', 'e', 'e', '\n', '<', 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'g', 'n', 'u', '.', 'o', 'r', 'g', '/', 'l', 'i', 'c', 'e', 'n', 's', 'e', 's', '/', '>', '.', '\n', 0 };
// init_uid
// file main.c line 63
unsigned int init_uid;
// insert_sort
// file cache.c line 199
static signed short int insert_sort = (signed short int)1;
// isdn_errs
// file netdev.c line 96
static volatile unsigned long int isdn_errs = (volatile unsigned long int)0;
// lock_mutex
// file cache.c line 167
union anonymous$33 lock_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// loglock
// file error.c line 36
union anonymous$33 loglock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// main_thrid
// file main.c line 62
unsigned long int main_thrid;
// neg_options
// file conf-keywords.h line 234
static const struct anonymous$32 neg_options[3l] = { { .name="name", .val=77 }, { .name="ttl", .val=79 }, { .name="types", .val=80 } };
// ping6_isocket
// file icmp.c line 76
volatile signed int ping6_isocket = -1;
// ping_isocket
// file icmp.c line 74
volatile signed int ping_isocket = -1;
// poll_errs
// file dns_query.c line 159
static volatile unsigned long int poll_errs = (volatile unsigned long int)0;
// poweroften
// file rr_types.c line 53
static const unsigned int poweroften[8l] = { (const unsigned int)1, (const unsigned int)10, (const unsigned int)100, (const unsigned int)1000, (const unsigned int)10000, (const unsigned int)100000, (const unsigned int)1000000, (const unsigned int)10000000 };
// proc_lock
// file dns_answer.c line 84
static union anonymous$33 proc_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// procs
// file dns_answer.c line 80
static volatile signed int procs = 0;
// qprocs
// file dns_answer.c line 81
static volatile signed int qprocs = 0;
// qt_names
// file dns.c line 490
static const char * const qt_names[5l] = { "IXFR", "AXFR", "MAILB", "MAILA", "*" };
// r_cond
// file cache.c line 178
union anonymous$56 r_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// r_pend
// file cache.c line 181
static volatile signed int r_pend = 0;
// r_susp
// file cache.c line 183
static volatile signed int r_susp = 0;
// retest_flag
// file servers.c line 64
static signed short int retest_flag = (signed short int)0;
// rr_info
// file rr_types.h line 482
struct rr_infos rr_info[47l] = { { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)1, .excludes=(unsigned short int)(2 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)8, .excludes=(unsigned short int)(1 | 2) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)8, .excludes=(unsigned short int)(1 | 2) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 } };
// rr_options
// file conf-keywords.h line 202
static const struct anonymous$32 rr_options[13l] = { { .name="a", .val=70 }, { .name="authrec", .val=83 }, { .name="cname", .val=74 }, { .name="mx", .val=72 }, { .name="name", .val=77 }, { .name="ns", .val=78 }, { .name="owner", .val=78 }, { .name="ptr", .val=71 }, { .name="reverse", .val=84 }, { .name="soa", .val=73 }, { .name="spf", .val=76 }, { .name="ttl", .val=79 }, { .name="txt", .val=75 } };
// rrcachiterlist
// file rr_types.h line 184
const unsigned short int rrcachiterlist[47l] = { (const unsigned short int)1, (const unsigned short int)2, (const unsigned short int)3, (const unsigned short int)4, (const unsigned short int)5, (const unsigned short int)6, (const unsigned short int)7, (const unsigned short int)8, (const unsigned short int)9, (const unsigned short int)10, (const unsigned short int)11, (const unsigned short int)12, (const unsigned short int)13, (const unsigned short int)14, (const unsigned short int)15, (const unsigned short int)16, (const unsigned short int)17, (const unsigned short int)18, (const unsigned short int)19, (const unsigned short int)20, (const unsigned short int)21, (const unsigned short int)22, (const unsigned short int)23, (const unsigned short int)24, (const unsigned short int)25, (const unsigned short int)26, (const unsigned short int)27, (const unsigned short int)28, (const unsigned short int)29, (const unsigned short int)30, (const unsigned short int)31, (const unsigned short int)32, (const unsigned short int)33, (const unsigned short int)34, (const unsigned short int)35, (const unsigned short int)36, (const unsigned short int)37, (const unsigned short int)42, (const unsigned short int)43, (const unsigned short int)44, (const unsigned short int)45, (const unsigned short int)46, (const unsigned short int)47, (const unsigned short int)48, (const unsigned short int)49, (const unsigned short int)50, (const unsigned short int)51 };
// rrlkuptab
// file rr_types.h line 111
const unsigned short int rrlkuptab[51l] = { (const unsigned short int)0, (const unsigned short int)1, (const unsigned short int)8, (const unsigned short int)9, (const unsigned short int)2, (const unsigned short int)3, (const unsigned short int)10, (const unsigned short int)11, (const unsigned short int)12, (const unsigned short int)13, (const unsigned short int)14, (const unsigned short int)4, (const unsigned short int)15, (const unsigned short int)16, (const unsigned short int)5, (const unsigned short int)6, (const unsigned short int)17, (const unsigned short int)18, (const unsigned short int)19, (const unsigned short int)20, (const unsigned short int)21, (const unsigned short int)22, (const unsigned short int)23, (const unsigned short int)24, (const unsigned short int)25, (const unsigned short int)26, (const unsigned short int)27, (const unsigned short int)7, (const unsigned short int)28, (const unsigned short int)29, (const unsigned short int)30, (const unsigned short int)31, (const unsigned short int)32, (const unsigned short int)33, (const unsigned short int)34, (const unsigned short int)35, (const unsigned short int)36, (const unsigned short int)47, (const unsigned short int)48, (const unsigned short int)49, (const unsigned short int)50, (const unsigned short int)37, (const unsigned short int)38, (const unsigned short int)39, (const unsigned short int)40, (const unsigned short int)41, (const unsigned short int)42, (const unsigned short int)43, (const unsigned short int)44, (const unsigned short int)45, (const unsigned short int)46 };
// rrmuiterlist
// file rr_types.h line 169
const unsigned short int rrmuiterlist[8l] = { (const unsigned short int)1, (const unsigned short int)2, (const unsigned short int)5, (const unsigned short int)6, (const unsigned short int)12, (const unsigned short int)15, (const unsigned short int)16, (const unsigned short int)28 };
// rrnames
// file rr_types.h line 399
const char * const rrnames[51l] = { "A", "NS", "MD", "MF", "CNAME", "SOA", "MB", "MG", "MR", "NULL", "WKS", "PTR", "HINFO", "MINFO", "MX", "TXT", "RP", "AFSDB", "X25", "ISDN", "RT", "NSAP", "NSAP_PTR", "SIG", "KEY", "PX", "GPOS", "AAAA", "LOC", "NXT", "EID", "NIMLOC", "SRV", "ATMA", "NAPTR", "KX", "CERT", "A6", "DNAME", "SINK", "OPT", "APL", "DS", "SSHFP", "IPSECKEY", "RRSIG", "NSEC", "DNSKEY", "DHCID", "NSEC3", "NSEC3PARAM" };
// rrset_l
// file cache.c line 154
static struct rr_lent_s *rrset_l = (struct rr_lent_s *)(void *)0;
// rrset_l_tail
// file cache.c line 155
static struct rr_lent_s *rrset_l_tail = (struct rr_lent_s *)(void *)0;
// run_ipv4
// file main.c line 58
signed short int run_ipv4 = (signed short int)1;
// rw_cond
// file cache.c line 177
union anonymous$56 rw_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// rw_pend
// file cache.c line 182
static volatile signed int rw_pend = 0;
// schm
// file servers.c line 66
static char schm[32l];
// section_headers
// file conf-keywords.h line 117
static const struct anonymous$32 section_headers[6l] = { { .name="global", .val=1 }, { .name="include", .val=6 }, { .name="neg", .val=4 }, { .name="rr", .val=3 }, { .name="server", .val=2 }, { .name="source", .val=5 } };
// serv_presets
// file conff.c line 81
struct anonymous$7 serv_presets = { .port=(unsigned short int)53, .uptest=(signed short int)5, .timeout=(signed long int)120,
    .interval=(signed long int)900, .ping_timeout=(signed long int)600,
    .scheme={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .uptest_cmd=(char *)(void *)0,
    .uptest_usr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .interface={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .device={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .query_test_name=(unsigned char *)(void *)0,
    .label=(char *)(void *)0,
    .purge_cache=(char)0, .nocache=(char)0,
    .lean_query=(char)1, .edns_query=(char)0,
    .is_proxy=(char)0, .rootserver=(char)0,
    .rand_servers=(char)0, .preset=(char)1,
    .rejectrecursively=(char)0, .rejectpolicy=(signed short int)24,
    .policy=(signed short int)18, .alist=(struct anonymous$8 *)(void *)0,
    .atup_a=(struct anonymous$19 *)(void *)0,
    .reject_a4=(struct anonymous$10 *)(void *)0,
    .reject_a6=(struct anonymous$12 *)(void *)0,
    .ping_a={ .ipv4={ .s_addr=(unsigned int)0x00000000 } } };
// server_data_cond
// file servers.c line 57
static union anonymous$56 server_data_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// server_data_users
// file servers.c line 59
static signed int server_data_users = 0;
// server_options
// file conf-keywords.h line 170
static const struct anonymous$32 server_options[28l] = { { .name="caching", .val=56 }, { .name="device", .val=54 }, { .name="edns_query", .val=58 }, { .name="exclude", .val=64 }, { .name="file", .val=81 }, { .name="include", .val=63 }, { .name="interface", .val=53 }, { .name="interval", .val=52 }, { .name="ip", .val=43 }, { .name="label", .val=69 }, { .name="lean_query", .val=57 }, { .name="ping_ip", .val=49 }, { .name="ping_timeout", .val=48 }, { .name="policy", .val=65 }, { .name="port", .val=44 }, { .name="preset", .val=59 }, { .name="proxy_only", .val=60 }, { .name="purge_cache", .val=55 }, { .name="query_test_name", .val=51 }, { .name="randomize_servers", .val=62 }, { .name="reject", .val=66 }, { .name="reject_policy", .val=67 }, { .name="reject_recursively", .val=68 },
    { .name="root_server", .val=61 }, { .name="scheme", .val=45 }, { .name="timeout", .val=47 }, { .name="uptest", .val=46 }, { .name="uptest_cmd", .val=50 } };
// server_status_ping
// file servers.c line 59
static signed int server_status_ping = 0;
// server_test_cond
// file servers.c line 58
static union anonymous$56 server_test_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// servers
// file conff.c line 114
struct anonymous$18 *servers = (struct anonymous$18 *)(void *)0;
// servers_lock
// file servers.c line 56
static union anonymous$33 servers_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// servstat_thrid
// file main.c line 62
unsigned long int servstat_thrid;
// signal_interrupt
// file servers.c line 61
volatile signed int signal_interrupt = 0;
// sigs_msk
// file main.c line 69
struct anonymous$41 sigs_msk;
// sock_path
// file status.c line 56
char *sock_path = (char *)(void *)0;
// socketopen_errs
// file netdev.c line 86
static volatile unsigned long int socketopen_errs = (volatile unsigned long int)0;
// source_options
// file conf-keywords.h line 219
static const struct anonymous$32 source_options[6l] = { { .name="authrec", .val=83 }, { .name="file", .val=81 }, { .name="ns", .val=78 }, { .name="owner", .val=78 }, { .name="serve_aliases", .val=82 }, { .name="ttl", .val=79 } };
// spawned
// file dns_answer.c line 82
static volatile unsigned long int spawned = (volatile unsigned long int)0;
// stat_pipe
// file main.c line 54
signed short int stat_pipe = (signed short int)0;
// stat_sock
// file status.c line 57
signed int stat_sock;
// statsock_thrid
// file main.c line 62
unsigned long int statsock_thrid;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tcp_socket
// file main.c line 67
volatile signed int tcp_socket = -1;
// tcps_thrid
// file main.c line 62
unsigned long int tcps_thrid;
// thrid_cnt
// file dns_answer.c line 83
static volatile unsigned int thrid_cnt = (volatile unsigned int)0;
// thrid_key
// file thread.c line 43
unsigned int thrid_key;
// udp_socket
// file main.c line 68
volatile signed int udp_socket = -1;
// udps_thrid
// file main.c line 62
unsigned long int udps_thrid;
// use_cache_lock
// file cache.c line 193
volatile signed short int use_cache_lock = (volatile signed short int)0;
// use_log_lock
// file error.c line 37
volatile signed short int use_log_lock = (volatile signed short int)0;

// SET_PDNSD_A2
// file ipvers.h line 260
static inline void SET_PDNSD_A2(struct anonymous$15 *a2, union anonymous$6 *a)
{
  if(!(run_ipv4 == 0))
    a2->ipv4 = a->ipv4;

  else
  {
    a2->ipv6 = a->ipv6;
    a2->ipv4.s_addr = (unsigned int)0x00000000;
  }
}

// SET_PDNSD_A2$link1
// file ipvers.h line 260
static inline void SET_PDNSD_A2$link1(struct anonymous$15 *a2$link1, union anonymous$6 *a$link1)
{
  if(!(run_ipv4 == 0))
    a2$link1->ipv4 = a$link1->ipv4;

  else
  {
    a2$link1->ipv6 = a$link1->ipv6;
    a2$link1->ipv4.s_addr = (unsigned int)0x00000000;
  }
}

// a2ptrstr
// file dns.c line 306
signed int a2ptrstr(union anonymous$6 *a, signed int tp, unsigned char *buf)
{
  if(tp == 1)
  {
    unsigned char *p = (unsigned char *)&a->ipv4.s_addr;
    signed int n;
    n=snprintf((char *)buf, (unsigned long int)256, "%u.%u.%u.%u.in-addr.arpa.", p[(signed long int)3], p[(signed long int)2], p[(signed long int)1], p[(signed long int)0]);
    if(n >= 256 || !(n >= 0))
      return 0;

  }

  else
    if(tp == 28)
    {
      unsigned char *a2ptrstr$$1$$2$$p = (unsigned char *)&a->ipv6;
      signed int i;
      signed int offs = 0;
      i = 15;
      for( ; i >= 0; i = i - 1)
      {
        unsigned char bt = a2ptrstr$$1$$2$$p[(signed long int)i];
        signed int a2ptrstr$$1$$2$$1$$1$$n;
        a2ptrstr$$1$$2$$1$$1$$n=snprintf((char *)(buf + (signed long int)offs), (unsigned long int)(256 - offs), "%x.%x.", (signed int)bt & 0xf, (signed int)bt >> 4 & 0xf);
        if(!(a2ptrstr$$1$$2$$1$$1$$n >= 0))
          return 0;

        offs = offs + a2ptrstr$$1$$2$$1$$1$$n;
        if(offs >= 256)
          return 0;

      }
      signed int return_value_strncp$1;
      return_value_strncp$1=strncp$link1((char *)(buf + (signed long int)offs), "ip6.arpa.", (unsigned long int)(256 - offs));
      if(return_value_strncp$1 == 0)
        return 0;

    }

    else
      return 0;
  return 1;
}

// add_additional_a
// file dns_answer.c line 715
static signed int add_additional_a(struct anonymous$28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, signed long int queryts, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva)
{
  struct anonymous$0 *ae;
  signed int retval = 1;
  ae=lookup_cache(rhn, (signed int *)(void *)0);
  signed long int return_value_ans_ttl$2;
  signed int return_value_add_additional_rrs$3;
  signed long int return_value_ans_ttl$5;
  signed int return_value_add_additional_rrs$6;
  if(!(ae == ((struct anonymous$0 *)NULL)))
  {
    struct anonymous *rrset;
    struct rr_b_s *rr;
    struct anonymous *tmp_if_expr$1;
    if((1 & (signed int)ae->flags) == 0)
      tmp_if_expr$1 = ae->$anon0.rr.rrmu[(signed long int)0];

    else
      tmp_if_expr$1 = (struct anonymous *)(void *)0;
    rrset = tmp_if_expr$1;
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      rr = rrset->rrs;
      if(!(rr == ((struct rr_b_s *)NULL)))
      {
        return_value_ans_ttl$2=ans_ttl(rrset, queryts);
        return_value_add_additional_rrs$3=add_additional_rrs(ans, rlen, allocsz, rhn, (unsigned int)1, return_value_ans_ttl$2, rr, 3, udp, cb, sva);
        if(return_value_add_additional_rrs$3 == 0)
          retval = 0;

      }

    }

    if(!(retval == 0))
    {
      struct anonymous *tmp_if_expr$4;
      if((1 & (signed int)ae->flags) == 0)
        tmp_if_expr$4 = ae->$anon0.rr.rrmu[(signed long int)7];

      else
        tmp_if_expr$4 = (struct anonymous *)(void *)0;
      rrset = tmp_if_expr$4;
      if(!(rrset == ((struct anonymous *)NULL)))
      {
        rr = rrset->rrs;
        if(!(rr == ((struct rr_b_s *)NULL)))
        {
          return_value_ans_ttl$5=ans_ttl(rrset, queryts);
          return_value_add_additional_rrs$6=add_additional_rrs(ans, rlen, allocsz, rhn, (unsigned int)28, return_value_ans_ttl$5, rr, 3, udp, cb, sva);
          if(return_value_add_additional_rrs$6 == 0)
            retval = 0;

        }

      }

    }

    free_cent(ae);
    free((void *)ae);
  }

  return retval;
}

// add_additional_rr
// file dns_answer.c line 662
static signed int add_additional_rr(struct anonymous$28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, unsigned int dlen, void *data, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva)
{
  struct anonymous$71 *st;
  void *return_value_dlist_first$1;
  return_value_dlist_first$1=dlist_first$link1(*sva);
  st = (struct anonymous$71 *)return_value_dlist_first$1;
  signed int return_value_rhnicmp$5;
  unsigned char *return_value_skiprhn$3;
  signed int return_value_memcmp$4;
  void *return_value_dlist_next$2;
  for( ; !(st == ((struct anonymous$71 *)NULL)); st = (struct anonymous$71 *)return_value_dlist_next$2)
  {
    if((unsigned int)st->tp == tp)
    {
      return_value_rhnicmp$5=rhnicmp(st->nm, rhn);
      if(!(return_value_rhnicmp$5 == 0))
      {
        if((unsigned int)st->dlen == dlen)
        {
          return_value_skiprhn$3=skiprhn(st->nm);
          return_value_memcmp$4=memcmp((const void *)return_value_skiprhn$3, data, (unsigned long int)dlen);
          if(return_value_memcmp$4 == 0)
            return 1;

        }

      }

    }

    return_value_dlist_next$2=dlist_next$link1((void *)st);
  }
  signed int return_value_add_rr$6;
  return_value_add_rr$6=add_rr(ans, rlen, allocsz, rhn, (unsigned short int)tp, (unsigned int)ttl, dlen, data, (char)sect, udp, cb);
  if(return_value_add_rr$6 == 0)
    return 0;

  else
  {
    signed int return_value_sva_add$7;
    return_value_sva_add$7=sva_add(sva, rhn, (unsigned short int)tp, (unsigned short int)dlen, data);
    if(return_value_sva_add$7 == 0)
      return 0;

    else
      return 1;
  }
}

// add_additional_rrs
// file dns_answer.c line 689
static signed int add_additional_rrs(struct anonymous$28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, struct rr_b_s *rrb, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva)
{
  struct rr_b_s *rr;
  struct rr_b_s *first = (struct rr_b_s *)(void *)0;
  signed short int rnd_recs = (signed short int)global.rnd_recs;
  rr = rrb;
  if(!(rnd_recs == 0))
  {
    first=randrr(rrb);
    rr = first;
  }

  while(!(rr == ((struct rr_b_s *)NULL)))
  {
    signed int return_value_add_additional_rr$1;
    return_value_add_additional_rr$1=add_additional_rr(ans, rlen, allocsz, rhn, tp, ttl, rr->rdlen, (void *)rr->data, sect, udp, cb, sva);
    if(return_value_add_additional_rr$1 == 0)
      return 0;

    rr = rr->next;
    if(!(rnd_recs == 0))
    {
      if(rr == ((struct rr_b_s *)NULL))
        rr = rrb;

      if(rr == first)
        break;

    }

  }
  return 1;
}

// add_ar
// file dns_answer.c line 495
static signed int add_ar(struct _dynamic_list_head **ar, unsigned short int tp, unsigned short int tsz, void *tnm, unsigned char *nm, unsigned int ttl)
{
  struct rre_s *re;
  unsigned char *p;
  unsigned long int nmsz = (unsigned long int)0;
  unsigned long int size = sizeof(struct rre_s) /*8ul*/  + (unsigned long int)tsz;
  if((signed int)tp == 2 || (signed int)tp == 6)
  {
    unsigned int return_value_rhnlen$1;
    return_value_rhnlen$1=rhnlen$link2(nm);
    nmsz = (unsigned long int)return_value_rhnlen$1;
    size = size + nmsz;
  }

  *ar=dlist_grow(*ar, size);
  if(*ar == ((struct _dynamic_list_head *)NULL))
    return 0;

  else
  {
    void *return_value_dlist_last$2;
    return_value_dlist_last$2=dlist_last$link1(*ar);
    re = (struct rre_s *)return_value_dlist_last$2;
    re->tp = tp;
    re->tsz = tsz;
    re->ttl = ttl;
    void *return_value_mempcpy$3;
    return_value_mempcpy$3=mempcpy((void *)re->tnm, tnm, (unsigned long int)tsz);
    p = (unsigned char *)return_value_mempcpy$3;
    if((signed int)tp == 2 || (signed int)tp == 6)
      memcpy((void *)p, (const void *)nm, nmsz);

    return 1;
  }
}

// add_cache
// file cache.h line 173
void add_cache(struct anonymous$0 *cent)
{
  struct anonymous$0 *ce;
  struct anonymous$58 loc;
  signed int i;
  signed int ilim;
  lock_cache_rw();
  do
  {

  retry:
    ;
    ce=dns_lookup(cent->qname, &loc);
    if(ce == ((struct anonymous$0 *)NULL))
    {
      if((signed int)cent->num_rrs == 0)
      {
        if((1 & (signed int)cent->flags) == 0)
          goto purge_cache_return;

      }

      ce=copy_cent(cent);
      if(ce == ((struct anonymous$0 *)NULL))
        goto warn_unlock_cache_return;

      if((1 & (signed int)ce->flags) == 0)
      {
        signed int tmp_if_expr$1;
        if(!((1 & (signed int)ce->flags) == 0))
          tmp_if_expr$1 = 0;

        else
          tmp_if_expr$1 = ce->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        ilim = tmp_if_expr$1;
        i = 0;
        for( ; !(i >= ilim); i = i + 1)
        {
          struct anonymous *rrset;
          struct anonymous *tmp_if_expr$2;
          if(!(i >= 8))
            tmp_if_expr$2 = ce->$anon0.rr.rrmu[(signed long int)i];

          else
            tmp_if_expr$2 = ce->$anon0.rr.rrext[(signed long int)(i - 8)];
          rrset = tmp_if_expr$2;
          if(!(rrset == ((struct anonymous *)NULL)))
          {
            adjust_ttl(rrset);
            signed int return_value_insert_rrl$3;
            return_value_insert_rrl$3=insert_rrl(rrset, ce, i);
            if(return_value_insert_rrl$3 == 0)
              goto free_cent_unlock_cache_return;

          }

        }
      }

      else
      {
        adjust_dom_ttl(ce);
        signed int return_value_insert_rrl$4;
        return_value_insert_rrl$4=insert_rrl((struct anonymous *)(void *)0, ce, -1);
        if(return_value_insert_rrl$4 == 0)
          goto free_cent_unlock_cache_return;

      }
      signed int return_value_add_dns_hash$5;
      return_value_add_dns_hash$5=add_dns_hash(ce, &loc);
      if(return_value_add_dns_hash$5 == 0)
        goto free_cent_unlock_cache_return;

      ent_num = ent_num + 1l;
      goto __CPROVER_DUMP_L64;
    }

    if((1 & (signed int)cent->flags) == 0)
      break;

    signed int tmp_if_expr$6;
    if(!((1 & (signed int)ce->flags) == 0))
      tmp_if_expr$6 = 0;

    else
      tmp_if_expr$6 = ce->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
    ilim = tmp_if_expr$6;
    i = 0;
    for( ; !(i >= ilim); i = i + 1)
    {
      struct anonymous *add_cache$$1$$2$$1$$1$$1$$cerrs;
      struct anonymous *tmp_if_expr$7;
      if(!(i >= 8))
        tmp_if_expr$7 = ce->$anon0.rr.rrmu[(signed long int)i];

      else
        tmp_if_expr$7 = ce->$anon0.rr.rrext[(signed long int)(i - 8)];
      add_cache$$1$$2$$1$$1$$1$$cerrs = tmp_if_expr$7;
      if(!(add_cache$$1$$2$$1$$1$$1$$cerrs == ((struct anonymous *)NULL)))
      {
        if(!((2 & (signed int)add_cache$$1$$2$$1$$1$$1$$cerrs->flags) == 0))
          goto unlock_cache_return;

      }

    }
    del_cache_ent(ce, &loc);
  }
  while((_Bool)1);
  purge_cent(ce, 0, 0);
  cache_size = cache_size - (volatile signed long int)ce->cs;
  signed int tmp_if_expr$8;
  if(!((1 & (signed int)cent->flags) == 0))
    tmp_if_expr$8 = 0;

  else
    tmp_if_expr$8 = cent->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
  ilim = tmp_if_expr$8;
  i = 0;
  struct anonymous *tmp_if_expr$11;
  struct anonymous *tmp_if_expr$10;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$24;
  signed long int tmp_if_expr$22;
  signed long int return_value_time$23;
  for( ; !(i >= ilim); i = i + 1)
  {
    struct anonymous *centrrs;
    struct anonymous *tmp_if_expr$9;
    if(!(i >= 8))
      tmp_if_expr$9 = cent->$anon0.rr.rrmu[(signed long int)i];

    else
      tmp_if_expr$9 = cent->$anon0.rr.rrext[(signed long int)(i - 8)];
    centrrs = tmp_if_expr$9;
    if(!(centrrs == ((struct anonymous *)NULL)))
    {
      struct anonymous *cerrs;
      struct anonymous *tmp_if_expr$12;
      if(!((1 & (signed int)ce->flags) == 0))
        tmp_if_expr$12 = (struct anonymous *)(void *)0;

      else
      {
        if(!(i >= 8))
          tmp_if_expr$11 = ce->$anon0.rr.rrmu[(signed long int)i];

        else
        {
          if(!(ce->$anon0.rr.rrext == ((struct anonymous **)NULL)))
            tmp_if_expr$10 = ce->$anon0.rr.rrext[(signed long int)(i - 8)];

          else
            tmp_if_expr$10 = (struct anonymous *)(void *)0;
          tmp_if_expr$11 = tmp_if_expr$10;
        }
        tmp_if_expr$12 = tmp_if_expr$11;
      }
      cerrs = tmp_if_expr$12;
      _Bool tmp_if_expr$26;
      if(!(cerrs == ((struct anonymous *)NULL)))
      {
        if((2 & (signed int)centrrs->flags) == 0)
          tmp_if_expr$18 = ((signed int)cerrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$18 = (_Bool)0;
        if(tmp_if_expr$18)
          tmp_if_expr$25 = (_Bool)1;

        else
        {
          if(!((16 & (signed int)centrrs->flags) == 0))
          {
            if((16 & (signed int)cerrs->flags) == 0)
              tmp_if_expr$20 = (_Bool)1;

            else
            {
              if((64 & (signed int)centrrs->flags) == 0)
                tmp_if_expr$19 = ((signed int)cerrs->flags & 64) != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$19 = (_Bool)0;
              tmp_if_expr$20 = tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$21 = (_Bool)0;
          if(tmp_if_expr$21)
          {
            if(!(cerrs->ttl >= 120l))
              tmp_if_expr$22 = (signed long int)120;

            else
              tmp_if_expr$22 = cerrs->ttl;
            return_value_time$23=time((signed long int *)(void *)0);
            tmp_if_expr$24 = !(cerrs->ts + tmp_if_expr$22 < return_value_time$23) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$24 = (_Bool)0;
          tmp_if_expr$25 = tmp_if_expr$24 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr$26 = tmp_if_expr$25 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$26 = (_Bool)0;
      if(!tmp_if_expr$26)
      {
        struct rr_b_s *rr;
        struct rr_b_s *rtail;
        del_cent_rrset_by_index(ce, i);
        signed int return_value_cr_check_add$13;
        return_value_cr_check_add$13=cr_check_add(ce, i, centrrs->ttl, centrrs->ts, (unsigned int)centrrs->flags);
        if(return_value_cr_check_add$13 == 0)
          goto __CPROVER_DUMP_L55;

        signed int return_value_add_cent_rrset_by_index$14;
        return_value_add_cent_rrset_by_index$14=add_cent_rrset_by_index(ce, (unsigned int)i, centrrs->ttl, centrrs->ts, (unsigned int)centrrs->flags);
        if(return_value_add_cent_rrset_by_index$14 == 0)
          goto addsize_unlock_cache_return;

        rtail = (struct rr_b_s *)(void *)0;
        rr = centrrs->rrs;
        for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
        {
          signed int return_value_add_cent_rr_int$15;
          return_value_add_cent_rr_int$15=add_cent_rr_int(ce, (unsigned int)i, centrrs->ttl, centrrs->ts, (unsigned int)centrrs->flags, rr->rdlen, (void *)rr->data, &rtail);
          if(return_value_add_cent_rr_int$15 == 0)
            goto cleanup_cent_unlock_cache_return;

        }
        struct anonymous *tmp_if_expr$16;
        if(!(i >= 8))
          tmp_if_expr$16 = ce->$anon0.rr.rrmu[(signed long int)i];

        else
          tmp_if_expr$16 = ce->$anon0.rr.rrext[(signed long int)(i - 8)];
        cerrs = tmp_if_expr$16;
        adjust_ttl(cerrs);
        signed int return_value_insert_rrl$17;
        return_value_insert_rrl$17=insert_rrl(cerrs, ce, i);
        if(return_value_insert_rrl$17 == 0)
          goto cleanup_cent_unlock_cache_return;

      }

    }


  __CPROVER_DUMP_L55:
    ;
  }
  ce->flags = ce->flags | (unsigned short int)((signed int)cent->flags & (4 | 16));
  if(!((signed int)cent->c_ns == 0xff))
  {
    _Bool tmp_if_expr$27;
    if((signed int)ce->c_ns == 0xff)
      tmp_if_expr$27 = (_Bool)1;

    else
      tmp_if_expr$27 = (signed int)ce->c_ns < (signed int)cent->c_ns ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$27)
      ce->c_ns = cent->c_ns;

  }

  if(!((signed int)cent->c_soa == 0xff))
  {
    _Bool tmp_if_expr$28;
    if((signed int)ce->c_soa == 0xff)
      tmp_if_expr$28 = (_Bool)1;

    else
      tmp_if_expr$28 = (signed int)ce->c_soa < (signed int)cent->c_soa ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$28)
      ce->c_soa = cent->c_soa;

  }


__CPROVER_DUMP_L64:
  ;
  cache_size = cache_size + (volatile signed long int)ce->cs;

purge_cache_return:
  ;
  purge_cache((signed long int)global.perm_cache * (signed long int)1024 + (signed long int)10240, 1);
  goto unlock_cache_return;

cleanup_cent_unlock_cache_return:
  ;
  del_cent_rrset_by_index(ce, i);

addsize_unlock_cache_return:
  ;
  cache_size = cache_size + (volatile signed long int)ce->cs;
  goto warn_unlock_cache_return;

free_cent_unlock_cache_return:
  ;
  free_cent(ce);
  free((void *)ce);

warn_unlock_cache_return:
  ;
  log_message(4, "Out of cache memory.");

unlock_cache_return:
  ;
  unlock_cache_rw();
}

// add_cent_rr
// file cache.h line 201
signed int add_cent_rr(struct anonymous$0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data)
{
  signed int tpi;
  unsigned int idx;
  struct anonymous *rrset;
  struct rr_b_s *rtail;
  struct rr_b_s *rrb;
  struct anonymous *tmp_if_expr$2;
  struct anonymous *tmp_if_expr$1;
  signed int return_value_memcmp$4;
  if(!((2 & (signed int)cent->flags) == 0))
  {
    if(!((2u & flags) == 0u))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    tpi = type - 1;
    if(!(tpi >= 0) || tpi >= 51)
    {
      log_message(3, "%s:%d: %s", (const void *)"cache.c", 730, (const void *)"add_cent_rr: rr type value out of range");
      pdnsd_exit();
    }

    idx = (unsigned int)rrlkuptab[(signed long int)tpi];
    if(idx >= 47u)
    {
      log_message(3, "%s:%d: %s", (const void *)"cache.c", 732, (const void *)"add_cent_rr: illegal rr type value for caching");
      pdnsd_exit();
    }

    struct anonymous *tmp_if_expr$3;
    if(!((1 & (signed int)cent->flags) == 0))
      tmp_if_expr$3 = (struct anonymous *)(void *)0;

    else
    {
      if(!(idx >= 8u))
        tmp_if_expr$2 = cent->$anon0.rr.rrmu[(signed long int)idx];

      else
      {
        if(!(cent->$anon0.rr.rrext == ((struct anonymous **)NULL)))
          tmp_if_expr$1 = cent->$anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];

        else
          tmp_if_expr$1 = (struct anonymous *)(void *)0;
        tmp_if_expr$2 = tmp_if_expr$1;
      }
      tmp_if_expr$3 = tmp_if_expr$2;
    }
    rrset = tmp_if_expr$3;
    rtail = (struct rr_b_s *)(void *)0;
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      if(!(ttl >= rrset->ttl))
        rrset->ttl = ttl;

      rrb = rrset->rrs;
      while(!(rrb == ((struct rr_b_s *)NULL)))
      {
        if(rrb->rdlen == dlen)
        {
          return_value_memcmp$4=memcmp((const void *)rrb->data, data, (unsigned long int)dlen);
          if(return_value_memcmp$4 == 0)
            return 1;

        }

        rtail = rrb;
        rrb = rrb->next;
      }
    }

    signed int return_value_add_cent_rr_int$5;
    return_value_add_cent_rr_int$5=add_cent_rr_int(cent, idx, ttl, ts, flags, dlen, data, &rtail);
    return return_value_add_cent_rr_int$5;
  }
}

// add_cent_rr_int
// file cache.c line 668
static signed int add_cent_rr_int(struct anonymous$0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data, struct rr_b_s **rtail)
{
  struct rr_b_s *rr;
  struct anonymous *rrset;
  rr=create_rr(dlen, data);
  struct anonymous *tmp_if_expr$2;
  struct anonymous *tmp_if_expr$1;
  char *return_value_flags2str$8;
  if(rr == ((struct rr_b_s *)NULL))
    return 0;

  else
  {
    _Bool tmp_if_expr$6;
    if(!(rtail == ((struct rr_b_s **)NULL)))
      tmp_if_expr$6 = *rtail != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(!tmp_if_expr$6)
    {
      struct anonymous *tmp_if_expr$3;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr$3 = (struct anonymous *)(void *)0;

      else
      {
        if(!(idx >= 8u))
          tmp_if_expr$2 = cent->$anon0.rr.rrmu[(signed long int)idx];

        else
        {
          if(!(cent->$anon0.rr.rrext == ((struct anonymous **)NULL)))
            tmp_if_expr$1 = cent->$anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];

          else
            tmp_if_expr$1 = (struct anonymous *)(void *)0;
          tmp_if_expr$2 = tmp_if_expr$1;
        }
        tmp_if_expr$3 = tmp_if_expr$2;
      }
      rrset = tmp_if_expr$3;
      if(rrset == ((struct anonymous *)NULL))
      {
        signed int return_value_add_cent_rrset_by_index$4;
        return_value_add_cent_rrset_by_index$4=add_cent_rrset_by_index(cent, idx, ttl, ts, flags);
        if(return_value_add_cent_rrset_by_index$4 == 0)
          goto cleanup_return;

        struct anonymous *tmp_if_expr$5;
        if(!(idx >= 8u))
          tmp_if_expr$5 = cent->$anon0.rr.rrmu[(signed long int)idx];

        else
          tmp_if_expr$5 = cent->$anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];
        rrset = tmp_if_expr$5;
      }

      rr->next = rrset->rrs;
      rrset->rrs = rr;
    }

    else
    {
      rr->next = (*rtail)->next;
      (*rtail)->next = rr;
    }
    if(!(rtail == ((struct rr_b_s **)NULL)))
      *rtail = rr;

    cent->cs = cent->cs + sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rr->rdlen;
    if(!(debug_p == 0))
    {
      struct anonymous *tmp_if_expr$7;
      if(!(idx >= 8u))
        tmp_if_expr$7 = cent->$anon0.rr.rrmu[(signed long int)idx];

      else
        tmp_if_expr$7 = cent->$anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];
      rrset = tmp_if_expr$7;
      if(!((1 & (signed int)rrset->flags) == 0))
      {
        char cflagstr[28l];
        if(!(debug_p == 0))
        {
          return_value_flags2str$8=flags2str((unsigned int)rrset->flags, cflagstr, 7, cflgnames);
          debug_msg(0, "Tried to add rr to a rrset with CF_NEGATIVE set! flags=%s\n", return_value_flags2str$8);
        }

      }

    }

    return 1;

  cleanup_return:
    ;
    free((void *)rr);
    return 0;
  }
}

// add_cent_rrset_by_index
// file cache.c line 605
static signed int add_cent_rrset_by_index(struct anonymous$0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags)
{
  struct anonymous **rrext;
  struct anonymous **rrsetpa;
  struct anonymous *rrset;
  if(!((1 & (signed int)cent->flags) == 0))
  {
    signed int i;
    if(!(cent->$anon0.neg.lent == ((struct rr_lent_s *)NULL)))
      remove_rrl(cent->$anon0.neg.lent);

    cent->flags = cent->flags & (unsigned short int)~1;
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      cent->$anon0.rr.rrmu[(signed long int)i] = (struct anonymous *)(void *)0;
    cent->$anon0.rr.rrext = (struct anonymous **)(void *)0;
  }

  if(!(idx >= 8u))
    rrsetpa = &cent->$anon0.rr.rrmu[(signed long int)idx];

  else
  {
    idx = idx - (unsigned int)8;
    if(idx >= 39u)
    {
      log_message(3, "%s:%d: %s", (const void *)"cache.c", 625, (const void *)"add_cent_rrset_by_index: rr-set index out of range");
      pdnsd_exit();
    }

    rrext = cent->$anon0.rr.rrext;
    if(rrext == ((struct anonymous **)NULL))
    {
      signed int add_cent_rrset_by_index$$1$$2$$2$$i;
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39);
      rrext = (struct anonymous **)return_value_malloc$1;
      cent->$anon0.rr.rrext = rrext;
      if(rrext == ((struct anonymous **)NULL))
        return 0;

      add_cent_rrset_by_index$$1$$2$$2$$i = 0;
      for( ; !(add_cent_rrset_by_index$$1$$2$$2$$i >= 39); add_cent_rrset_by_index$$1$$2$$2$$i = add_cent_rrset_by_index$$1$$2$$2$$i + 1)
        rrext[(signed long int)add_cent_rrset_by_index$$1$$2$$2$$i] = (struct anonymous *)(void *)0;
      cent->cs = cent->cs + sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39;
    }

    rrsetpa = &rrext[(signed long int)idx];
  }
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct anonymous) /*40ul*/ );
  rrset = (struct anonymous *)return_value_malloc$2;
  *rrsetpa = rrset;
  if(rrset == ((struct anonymous *)NULL))
    return 0;

  else
  {
    rrset->lent = (struct rr_lent_s *)(void *)0;
    rrset->ttl = ttl;
    rrset->ts = ts;
    rrset->flags = (unsigned short int)flags;
    rrset->rrs = (struct rr_b_s *)(void *)0;
    cent->cs = cent->cs + sizeof(struct anonymous) /*40ul*/ ;
    cent->num_rrs = cent->num_rrs + 1;
    return 1;
  }
}

// add_cent_rrset_by_type
// file cache.h line 200
signed int add_cent_rrset_by_type(struct anonymous$0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags)
{
  signed int tpi = type - 1;
  if(!(tpi >= 0) || tpi >= 51)
  {
    log_message(3, "%s:%d: %s", (const void *)"cache.c", 659, (const void *)"add_cent_rrset_by_type: rr type value out of range");
    pdnsd_exit();
  }

  signed int return_value_add_cent_rrset_by_index$1;
  return_value_add_cent_rrset_by_index$1=add_cent_rrset_by_index(cent, (unsigned int)rrlkuptab[(signed long int)tpi], ttl, ts, flags);
  return return_value_add_cent_rrset_by_index$1;
}

// add_dns_hash
// file hash.h line 69
signed int add_dns_hash(struct anonymous$0 *data, struct anonymous$58 *loc)
{
  struct dns_hash_ent_s *he;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct dns_hash_ent_s) /*24ul*/ );
  he = (struct dns_hash_ent_s *)return_value_malloc$1;
  if(he == ((struct dns_hash_ent_s *)NULL))
    return 0;

  else
  {
    he->next = *loc->pos;
    he->rhash = loc->rhash;
    he->data = data;
    *loc->pos = he;
    return 1;
  }
}

// add_host
// file dns.c line 340
static signed int add_host(unsigned char *pn, unsigned char *rns, union anonymous$6 *a, signed int tp, signed int a_sz, signed long int ttl, unsigned int flags, signed int reverse)
{
  struct anonymous$0 ce;
  signed int return_value_init_cent$1;
  return_value_init_cent$1=init_cent(&ce, pn, (signed long int)0, (signed long int)0, flags);
  unsigned int return_value_rhnlen$3;
  signed int return_value_add_cent_rr$4;
  if(return_value_init_cent$1 == 0)
    return 0;

  else
  {
    signed int return_value_add_cent_rr$2;
    return_value_add_cent_rr$2=add_cent_rr(&ce, tp, ttl, (signed long int)0, (unsigned int)2, (unsigned int)a_sz, (void *)a);
    if(!(return_value_add_cent_rr$2 == 0))
    {
      return_value_rhnlen$3=rhnlen$link1(rns);
      return_value_add_cent_rr$4=add_cent_rr(&ce, 2, ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen$3, (void *)rns);
      if(return_value_add_cent_rr$4 == 0)
        goto free_cent_return0;

      add_cache(&ce);
      free_cent(&ce);
      if(!(reverse == 0))
      {
        unsigned char b2[256l];
        unsigned char rhn[256l];
        signed int return_value_a2ptrstr$5;
        return_value_a2ptrstr$5=a2ptrstr(a, tp, b2);
        if(return_value_a2ptrstr$5 == 0)
          return -1;

        signed int return_value_str2rhn$6;
        return_value_str2rhn$6=str2rhn(b2, rhn);
        if(return_value_str2rhn$6 == 0)
          return -1;

        signed int return_value_init_cent$7;
        return_value_init_cent$7=init_cent(&ce, rhn, (signed long int)0, (signed long int)0, flags);
        if(return_value_init_cent$7 == 0)
          return 0;

        unsigned int return_value_rhnlen$8;
        return_value_rhnlen$8=rhnlen$link1(pn);
        signed int return_value_add_cent_rr$9;
        return_value_add_cent_rr$9=add_cent_rr(&ce, 12, ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen$8, (void *)pn);
        if(return_value_add_cent_rr$9 == 0)
          goto free_cent_return0;

        unsigned int return_value_rhnlen$10;
        return_value_rhnlen$10=rhnlen$link1(rns);
        signed int return_value_add_cent_rr$11;
        return_value_add_cent_rr$11=add_cent_rr(&ce, 2, ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen$10, (void *)rns);
        if(return_value_add_cent_rr$11 == 0)
          goto free_cent_return0;

        add_cache(&ce);
        free_cent(&ce);
      }

      return 1;
    }

    else
    {

    free_cent_return0:
      ;
      free_cent(&ce);
      return 0;
    }
  }
}

// add_opt_pseudo_rr
// file dns_answer.c line 423
signed int add_opt_pseudo_rr(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned short int udpsize, unsigned short int rcode, unsigned short int ednsver, unsigned short int Zflags)
{
  unsigned char *ptr;
  unsigned long int newsz = (unsigned long int)2 + *sz + (unsigned long int)(1 + 10);
  if(!(*allocsz >= newsz))
  {
    unsigned long int newallocsz = newsz + (unsigned long int)0x7f & ~((unsigned long int)0x7f);
    struct anonymous$28 *newans;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)*ans, newallocsz);
    newans = (struct anonymous$28 *)return_value_realloc$1;
    if(newans == ((struct anonymous$28 *)NULL))
      return 0;

    *ans = newans;
    *allocsz = newallocsz;
  }

  ptr = (unsigned char *)&(*ans)->hdr + (signed long int)*sz;
  unsigned char *tmp_post$2 = ptr;
  ptr = ptr + 1l;
  *tmp_post$2 = (unsigned char)0;
  do
  {
    unsigned short int t_s = (unsigned short int)41;
    unsigned char *t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post$3 = t_cp;
    t_cp = t_cp + 1l;
    *tmp_post$3 = (unsigned char)((signed int)t_s >> 8);
    unsigned char *tmp_post$4 = t_cp;
    t_cp = t_cp + 1l;
    *tmp_post$4 = (unsigned char)t_s;
    ptr = (unsigned char *)(void *)t_cp;
  }
  while((_Bool)0);
  do
  {
    unsigned short int add_opt_pseudo_rr$$1$$3$$t_s = (unsigned short int)udpsize;
    unsigned char *add_opt_pseudo_rr$$1$$3$$t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post$5 = add_opt_pseudo_rr$$1$$3$$t_cp;
    add_opt_pseudo_rr$$1$$3$$t_cp = add_opt_pseudo_rr$$1$$3$$t_cp + 1l;
    *tmp_post$5 = (unsigned char)((signed int)add_opt_pseudo_rr$$1$$3$$t_s >> 8);
    unsigned char *tmp_post$6 = add_opt_pseudo_rr$$1$$3$$t_cp;
    add_opt_pseudo_rr$$1$$3$$t_cp = add_opt_pseudo_rr$$1$$3$$t_cp + 1l;
    *tmp_post$6 = (unsigned char)add_opt_pseudo_rr$$1$$3$$t_s;
    ptr = (unsigned char *)(void *)add_opt_pseudo_rr$$1$$3$$t_cp;
  }
  while((_Bool)0);
  unsigned char *tmp_post$7 = ptr;
  ptr = ptr + 1l;
  *tmp_post$7 = (unsigned char)((signed int)rcode >> 4);
  unsigned char *tmp_post$8 = ptr;
  ptr = ptr + 1l;
  *tmp_post$8 = (unsigned char)ednsver;
  do
  {
    unsigned short int add_opt_pseudo_rr$$1$$4$$t_s = (unsigned short int)Zflags;
    unsigned char *add_opt_pseudo_rr$$1$$4$$t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post$9 = add_opt_pseudo_rr$$1$$4$$t_cp;
    add_opt_pseudo_rr$$1$$4$$t_cp = add_opt_pseudo_rr$$1$$4$$t_cp + 1l;
    *tmp_post$9 = (unsigned char)((signed int)add_opt_pseudo_rr$$1$$4$$t_s >> 8);
    unsigned char *tmp_post$10 = add_opt_pseudo_rr$$1$$4$$t_cp;
    add_opt_pseudo_rr$$1$$4$$t_cp = add_opt_pseudo_rr$$1$$4$$t_cp + 1l;
    *tmp_post$10 = (unsigned char)add_opt_pseudo_rr$$1$$4$$t_s;
    ptr = (unsigned char *)(void *)add_opt_pseudo_rr$$1$$4$$t_cp;
  }
  while((_Bool)0);
  do
  {
    unsigned short int add_opt_pseudo_rr$$1$$5$$t_s = (unsigned short int)0;
    unsigned char *add_opt_pseudo_rr$$1$$5$$t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post$11 = add_opt_pseudo_rr$$1$$5$$t_cp;
    add_opt_pseudo_rr$$1$$5$$t_cp = add_opt_pseudo_rr$$1$$5$$t_cp + 1l;
    *tmp_post$11 = (unsigned char)((signed int)add_opt_pseudo_rr$$1$$5$$t_s >> 8);
    unsigned char *tmp_post$12 = add_opt_pseudo_rr$$1$$5$$t_cp;
    add_opt_pseudo_rr$$1$$5$$t_cp = add_opt_pseudo_rr$$1$$5$$t_cp + 1l;
    *tmp_post$12 = (unsigned char)add_opt_pseudo_rr$$1$$5$$t_s;
    ptr = (unsigned char *)(void *)add_opt_pseudo_rr$$1$$5$$t_cp;
  }
  while((_Bool)0);
  *sz = *sz + (unsigned long int)(1 + 10);
  unsigned short int return_value_ntohs$13;
  return_value_ntohs$13=ntohs((*ans)->hdr.arcount);
  (*ans)->hdr.arcount=htons((unsigned short int)((signed int)return_value_ntohs$13 + 1));
  return 1;
}

// add_qserv
// file dns_query.c line 1958
static signed int add_qserv(struct anonymous$4 **q, struct anonymous$15 *a, signed int port, signed long int timeout, unsigned int flags, signed int nocache, char lean_query, char edns_query, char auth_s, char needs_testing, char trusted, const unsigned char *nsdomain, struct rejectlist_s *rejectlist)
{
  struct anonymous$5 *qs;
  struct anonymous$3 *return_value_da_grow1$1;
  return_value_da_grow1$1=da_grow1((struct anonymous$3 *)*q, (unsigned long int)((struct anonymous$4 *)0)->elem, sizeof(struct anonymous$5) /*112ul*/ , (void (*)(void *))(void *)0);
  *q = (struct anonymous$4 *)return_value_da_grow1$1;
  if(*q == ((struct anonymous$4 *)NULL))
  {
    if(!(debug_p == 0))
      debug_msg(0, "Out of memory in add_qserv()\n");

    return 0;
  }

  else
  {
    qs = &(*q)->elem[(signed long int)((*q)->nel - (unsigned long int)1)];
    if(!(run_ipv4 == 0))
    {
      memset((void *)&qs->a.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      qs->a.sin4.sin_family = (unsigned short int)2;
      qs->a.sin4.sin_port=htons((unsigned short int)port);
      qs->a.sin4.sin_addr = a->ipv4;
    }

    else
    {
      memset((void *)&qs->a.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
      qs->a.sin6.sin6_family = (unsigned short int)10;
      qs->a.sin6.sin6_port=htons((unsigned short int)port);
      qs->a.sin6.sin6_flowinfo = (unsigned int)0;
      qs->a.sin6.sin6_addr = a->ipv6;
      qs->a4fallback = a->ipv4;
    }
    qs->timeout = timeout;
    qs->flags = (unsigned short int)flags;
    qs->nocache = (signed short int)nocache;
    qs->auth_serv = auth_s;
    qs->lean_query = lean_query;
    qs->edns_query = edns_query;
    qs->needs_testing = needs_testing;
    qs->trusted = trusted;
    qs->aa = (char)0;
    qs->tc = (char)0;
    qs->failed = (char)0;
    qs->nsdomain = nsdomain;
    qs->rejectlist = rejectlist;
    qs->state = (signed short int)0;
    qs->qm = (signed short int)global.query_method;
    qs->s_errno = 0;
    return 1;
  }
}

// add_rejectlist
// file dns_query.c line 2853
static struct rejectlist_s * add_rejectlist(struct rejectlist_s *rl, struct anonymous$7 *sp)
{
  signed int i;
  signed int na4;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link2((struct anonymous$3 *)sp->reject_a4);
  na4 = (signed int)return_value_da_nel$1;
  struct anonymous$11 *a4p;
  signed int na6;
  unsigned int return_value_da_nel$2;
  return_value_da_nel$2=da_nel$link2((struct anonymous$3 *)sp->reject_a6);
  na6 = (signed int)return_value_da_nel$2;
  struct anonymous$13 *a6p;
  struct rejectlist_s *rlist;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(sizeof(struct rejectlist_s) /*24ul*/  + (unsigned long int)na4 * sizeof(struct anonymous$11) /*8ul*/  + (unsigned long int)na6 * sizeof(struct anonymous$13) /*32ul*/ );
  rlist = (struct rejectlist_s *)return_value_malloc$3;
  if(!(rlist == ((struct rejectlist_s *)NULL)))
  {
    rlist->na6 = na6;
    a6p = (struct anonymous$13 *)rlist->rdata;
    i = 0;
    for( ; !(i >= na6); i = i + 1)
    {
      struct anonymous$13 *tmp_post$4 = a6p;
      a6p = a6p + 1l;
      *tmp_post$4 = sp->reject_a6->elem[(signed long int)i];
    }
    rlist->na4 = na4;
    a4p = (struct anonymous$11 *)a6p;
    i = 0;
    for( ; !(i >= na4); i = i + 1)
    {
      struct anonymous$11 *tmp_post$5 = a4p;
      a4p = a4p + 1l;
      *tmp_post$5 = sp->reject_a4->elem[(signed long int)i];
    }
    rlist->policy = sp->rejectpolicy;
    rlist->inherit = (signed short int)sp->rejectrecursively;
    rlist->next = rl;
  }

  return rlist;
}

// add_reverse_cache
// file cache.h line 174
signed int add_reverse_cache(struct anonymous$0 *cent)
{
  signed int tp = 1;
  struct anonymous *rrset;
  struct anonymous *tmp_if_expr$1;
  if((1 & (signed int)cent->flags) == 0)
    tmp_if_expr$1 = cent->$anon0.rr.rrmu[(signed long int)0];

  else
    tmp_if_expr$1 = (struct anonymous *)(void *)0;
  rrset = tmp_if_expr$1;
  signed int return_value_str2rhn$3;
  while((_Bool)1)
  {
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      struct rr_b_s *rr = rrset->rrs;
      for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
      {
        struct anonymous$0 ce;
        unsigned char buf[256l];
        unsigned char rhn[256l];
        signed int return_value_a2ptrstr$2;
        return_value_a2ptrstr$2=a2ptrstr((union anonymous$6 *)rr->data, tp, buf);
        _Bool tmp_if_expr$4;
        if(return_value_a2ptrstr$2 == 0)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_str2rhn$3=str2rhn(buf, rhn);
          tmp_if_expr$4 = !(return_value_str2rhn$3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          return 0;

        signed int return_value_init_cent$5;
        return_value_init_cent$5=init_cent(&ce, rhn, (signed long int)0, (signed long int)0, (unsigned int)cent->flags);
        if(return_value_init_cent$5 == 0)
          return 0;

        unsigned int return_value_rhnlen$6;
        return_value_rhnlen$6=rhnlen$link6(cent->qname);
        signed int return_value_add_cent_rr$7;
        return_value_add_cent_rr$7=add_cent_rr(&ce, 12, rrset->ttl, rrset->ts, (unsigned int)rrset->flags, return_value_rhnlen$6, (void *)cent->qname);
        if(return_value_add_cent_rr$7 == 0)
        {
          free_cent(&ce);
          return 0;
        }

        ce.$anon0.rr.rrmu[(signed long int)1] = cent->$anon0.rr.rrmu[(signed long int)1];
        ce.$anon0.rr.rrmu[(signed long int)3] = cent->$anon0.rr.rrmu[(signed long int)3];
        add_cache(&ce);
        ce.$anon0.rr.rrmu[(signed long int)1] = (struct anonymous *)(void *)0;
        ce.$anon0.rr.rrmu[(signed long int)3] = (struct anonymous *)(void *)0;
        free_cent(&ce);
      }
    }

    if(tp == 28)
      break;

    tp = 28;
    struct anonymous *tmp_if_expr$8;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr$8 = cent->$anon0.rr.rrmu[(signed long int)7];

    else
      tmp_if_expr$8 = (struct anonymous *)(void *)0;
    rrset = tmp_if_expr$8;
  }
  return 1;
}

// add_rr
// file dns_answer.c line 213
static signed int add_rr(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned short int type, unsigned int ttl, unsigned int dlen, void *data, char section, unsigned int *udp, struct _dynamic_list_head **cb)
{
  unsigned long int osz = *sz;
  unsigned int ilen;
  unsigned int blen;
  unsigned int rdlen;
  unsigned char *rrht;
  unsigned int nlen;
  unsigned char nbuf[256l];
  nlen=compress_name(rrn, nbuf, (unsigned int)*sz, cb);
  unsigned int return_value_rhnlen$2;
  unsigned int return_value_rhnlen$3;
  unsigned short int return_value_ntohs$14;
  unsigned short int return_value_ntohs$15;
  unsigned short int return_value_ntohs$16;
  if(nlen == 0u)
    return 0;

  else
  {
    unsigned long int newsz = (unsigned long int)2 + *sz + (unsigned long int)nlen + (unsigned long int)10 + (unsigned long int)dlen;
    if(!(*allocsz >= newsz))
    {
      unsigned long int newallocsz = newsz + (unsigned long int)0x7f & ~((unsigned long int)0x7f);
      struct anonymous$28 *newans;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)*ans, newallocsz);
      newans = (struct anonymous$28 *)return_value_realloc$1;
      if(newans == ((struct anonymous$28 *)NULL))
        return 0;

      *ans = newans;
      *allocsz = newallocsz;
    }

    memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)nbuf, (unsigned long int)nlen);
    *sz = *sz + (unsigned long int)nlen;
    rrht = (unsigned char *)&(*ans)->hdr + (signed long int)*sz;
    *sz = *sz + (unsigned long int)10;
    switch((signed int)type)
    {
      case 5:

      case 7:

      case 3:

      case 4:

      case 8:

      case 9:

      case 2:

      case 12:
      {
        rdlen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(rdlen == 0u)
          return 0;

        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 263, (const void *)"T_CNAME/T_MB/...: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)rdlen;
        break;
      }
      case 14:

      case 17:
      {
        rdlen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(rdlen == 0u)
          return 0;

        *sz = *sz + (unsigned long int)rdlen;
        ilen=rhnlen$link2((unsigned char *)data);
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 277, (const void *)"T_MINFO/T_RP: got longer");
          pdnsd_exit();
        }

        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = rdlen + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 281, (const void *)"T_MINFO/T_RP: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 15:

      case 18:

      case 21:

      case 36:
      {
        if(!(dlen >= 3u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 295, (const void *)"T_MX/T_AFSDB/...: rr botch");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)2);
        *sz = *sz + (unsigned long int)2;
        blen=compress_name((unsigned char *)data + (signed long int)2, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = (unsigned int)2 + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 301, (const void *)"T_MX/T_AFSDB/...: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 6:
      {
        rdlen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(rdlen == 0u)
          return 0;

        *sz = *sz + (unsigned long int)rdlen;
        ilen=rhnlen$link2((unsigned char *)data);
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 309, (const void *)"T_SOA: got longer");
          pdnsd_exit();
        }

        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = rdlen + blen;
        *sz = *sz + (unsigned long int)blen;
        return_value_rhnlen$2=rhnlen$link2((unsigned char *)data + (signed long int)ilen);
        ilen = ilen + return_value_rhnlen$2;
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 315, (const void *)"T_SOA: got longer");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)((unsigned char *)data + (signed long int)ilen), (unsigned long int)20);
        rdlen = rdlen + (unsigned int)20;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 318, (const void *)"T_SOA: rr botch");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)20;
        break;
      }
      case 26:
      {
        if(!(dlen >= 3u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 323, (const void *)"T_PX: rr botch");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)2);
        *sz = *sz + (unsigned long int)2;
        ilen = (unsigned int)2;
        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = (unsigned int)2 + blen;
        *sz = *sz + (unsigned long int)blen;
        return_value_rhnlen$3=rhnlen$link2((unsigned char *)data + (signed long int)ilen);
        ilen = ilen + return_value_rhnlen$3;
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 332, (const void *)"T_PX: got longer");
          pdnsd_exit();
        }

        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = rdlen + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 336, (const void *)"T_PX: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 33:
      {
        if(!(dlen >= 7u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 342, (const void *)"T_SRV: rr botch");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)6);
        *sz = *sz + (unsigned long int)6;
        blen=compress_name((unsigned char *)data + (signed long int)6, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = (unsigned int)6 + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 348, (const void *)"T_SRV: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 30:
      {
        blen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = blen;
        *sz = *sz + (unsigned long int)blen;
        ilen=rhnlen$link2((unsigned char *)data);
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 359, (const void *)"T_NXT: got longer");
          pdnsd_exit();
        }

        if(!(dlen >= ilen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 360, (const void *)"T_NXT: rr botch");
          pdnsd_exit();
        }

        if(!(ilen >= dlen))
        {
          unsigned int wlen = dlen - ilen;
          memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)((unsigned char *)data + (signed long int)ilen), (unsigned long int)wlen);
          *sz = *sz + (unsigned long int)wlen;
          rdlen = rdlen + wlen;
        }

        break;
      }
      case 35:
      {
        if(!(dlen >= 5u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 371, (const void *)"T_NAPTR: rr botch");
          pdnsd_exit();
        }

        ilen = (unsigned int)4;
        signed int j = 0;
        for( ; !(j >= 3); j = j + 1)
        {
          ilen = ilen + (unsigned int)((unsigned char *)data)[(signed long int)ilen] + (unsigned int)1;
          if(ilen >= dlen)
          {
            log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 377, (const void *)"T_NAPTR: rr botch 2");
            pdnsd_exit();
          }

        }
        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)ilen);
        *sz = *sz + (unsigned long int)ilen;
        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = ilen + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 386, (const void *)"T_NAPTR: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      default:
      {
        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)dlen);
        rdlen = dlen;
        *sz = *sz + (unsigned long int)dlen;
      }
    }
    _Bool tmp_if_expr$17;
    if(!(udp == ((unsigned int *)NULL)))
      tmp_if_expr$17 = *sz > (unsigned long int)*udp ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$17 = (_Bool)0;
    if((signed int)section == 3 && tmp_if_expr$17)
      *sz = osz;

    else
    {
      do
      {
        unsigned short int t_s = (unsigned short int)type;
        unsigned char *t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post$4 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post$4 = (unsigned char)((signed int)t_s >> 8);
        unsigned char *tmp_post$5 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post$5 = (unsigned char)t_s;
        rrht = (unsigned char *)(void *)t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned short int add_rr$$1$$3$$2$$t_s = (unsigned short int)1;
        unsigned char *add_rr$$1$$3$$2$$t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post$6 = add_rr$$1$$3$$2$$t_cp;
        add_rr$$1$$3$$2$$t_cp = add_rr$$1$$3$$2$$t_cp + 1l;
        *tmp_post$6 = (unsigned char)((signed int)add_rr$$1$$3$$2$$t_s >> 8);
        unsigned char *tmp_post$7 = add_rr$$1$$3$$2$$t_cp;
        add_rr$$1$$3$$2$$t_cp = add_rr$$1$$3$$2$$t_cp + 1l;
        *tmp_post$7 = (unsigned char)add_rr$$1$$3$$2$$t_s;
        rrht = (unsigned char *)(void *)add_rr$$1$$3$$2$$t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned int t_l = (unsigned int)ttl;
        unsigned char *add_rr$$1$$3$$3$$t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post$8 = add_rr$$1$$3$$3$$t_cp;
        add_rr$$1$$3$$3$$t_cp = add_rr$$1$$3$$3$$t_cp + 1l;
        *tmp_post$8 = (unsigned char)(t_l >> 24);
        unsigned char *tmp_post$9 = add_rr$$1$$3$$3$$t_cp;
        add_rr$$1$$3$$3$$t_cp = add_rr$$1$$3$$3$$t_cp + 1l;
        *tmp_post$9 = (unsigned char)(t_l >> 16);
        unsigned char *tmp_post$10 = add_rr$$1$$3$$3$$t_cp;
        add_rr$$1$$3$$3$$t_cp = add_rr$$1$$3$$3$$t_cp + 1l;
        *tmp_post$10 = (unsigned char)(t_l >> 8);
        unsigned char *tmp_post$11 = add_rr$$1$$3$$3$$t_cp;
        add_rr$$1$$3$$3$$t_cp = add_rr$$1$$3$$3$$t_cp + 1l;
        *tmp_post$11 = (unsigned char)t_l;
        rrht = (unsigned char *)(void *)add_rr$$1$$3$$3$$t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned short int add_rr$$1$$3$$4$$t_s = (unsigned short int)rdlen;
        unsigned char *add_rr$$1$$3$$4$$t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post$12 = add_rr$$1$$3$$4$$t_cp;
        add_rr$$1$$3$$4$$t_cp = add_rr$$1$$3$$4$$t_cp + 1l;
        *tmp_post$12 = (unsigned char)((signed int)add_rr$$1$$3$$4$$t_s >> 8);
        unsigned char *tmp_post$13 = add_rr$$1$$3$$4$$t_cp;
        add_rr$$1$$3$$4$$t_cp = add_rr$$1$$3$$4$$t_cp + 1l;
        *tmp_post$13 = (unsigned char)add_rr$$1$$3$$4$$t_s;
        rrht = (unsigned char *)(void *)add_rr$$1$$3$$4$$t_cp;
      }
      while((_Bool)0);
      switch((signed int)section)
      {
        case 1:
        {
          return_value_ntohs$14=ntohs((*ans)->hdr.ancount);
          (*ans)->hdr.ancount=htons((unsigned short int)((signed int)return_value_ntohs$14 + 1));
          break;
        }
        case 2:
        {
          return_value_ntohs$15=ntohs((*ans)->hdr.nscount);
          (*ans)->hdr.nscount=htons((unsigned short int)((signed int)return_value_ntohs$15 + 1));
          break;
        }
        case 3:
        {
          return_value_ntohs$16=ntohs((*ans)->hdr.arcount);
          (*ans)->hdr.arcount=htons((unsigned short int)((signed int)return_value_ntohs$16 + 1));
        }
      }
    }
    return 1;
  }
}

// add_rrset
// file dns_answer.c line 554
static signed int add_rrset(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int tp, signed long int queryts, struct anonymous$0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar)
{
  struct anonymous *crrset;
  crrset=getrrset(cached, (signed int)tp);
  if(!(crrset == ((struct anonymous *)NULL)))
  {
    if(!(crrset->rrs == ((struct rr_b_s *)NULL)))
    {
      struct rr_b_s *b;
      struct rr_b_s *first = (struct rr_b_s *)(void *)0;
      signed int i;
      signed short int rnd_recs = (signed short int)global.rnd_recs;
      b = crrset->rrs;
      if(!(rnd_recs == 0))
      {
        first=randrr(crrset->rrs);
        b = first;
      }

      while(!(b == ((struct rr_b_s *)NULL)))
      {
        signed long int return_value_ans_ttl$1;
        return_value_ans_ttl$1=ans_ttl(crrset, queryts);
        signed int return_value_add_rr$2;
        return_value_add_rr$2=add_rr(ans, sz, allocsz, rrn, (unsigned short int)tp, (unsigned int)return_value_ans_ttl$1, b->rdlen, (void *)b->data, (char)1, udp, cb);
        if(return_value_add_rr$2 == 0)
          return 0;

        if(tp == 1u || tp == 2u || tp == 28u)
        {
          signed int return_value_sva_add$3;
          return_value_sva_add$3=sva_add(sva, rrn, (unsigned short int)tp, (unsigned short int)b->rdlen, (void *)b->data);
          if(return_value_sva_add$3 == 0)
            return 0;

        }

        i = 0;
        for( ; !(i >= 6); i = i + 1)
          if((unsigned int)ar_recs[(signed long int)i] == tp)
          {
            signed int return_value_add_ar$4;
            return_value_add_ar$4=add_ar(ar, (unsigned short int)0, (unsigned short int)(b->rdlen - (unsigned int)ar_offs[(signed long int)i]), (void *)((unsigned char *)b->data + (signed long int)ar_offs[(signed long int)i]), (unsigned char *)"", (unsigned int)0);
            if(return_value_add_ar$4 == 0)
              return 0;

            break;
          }

        b = b->next;
        if(!(rnd_recs == 0))
        {
          if(b == ((struct rr_b_s *)NULL))
            b = crrset->rrs;

          if(b == first)
            break;

        }

      }
    }

  }

  return 1;
}

// add_to_response
// file dns_answer.c line 605
static signed int add_to_response(struct anonymous$28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int qtype, signed long int queryts, struct anonymous$0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar)
{
  signed int return_value_have_rr$2;
  signed int return_value_add_rrset$1;
  if(!(qtype == 5u) && !(qtype == 255u))
  {
    _Bool tmp_if_expr$3;
    if(qtype >= 1u && !(qtype >= 52u))
    {
      return_value_have_rr$2=have_rr(cached, (signed int)qtype);
      tmp_if_expr$3 = return_value_have_rr$2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
    {
      return_value_add_rrset$1=add_rrset(ans, sz, allocsz, rrn, (unsigned int)5, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset$1 == 0)
        return 0;

    }

  }

  const unsigned short int *tmp_if_expr$10;
  if(qtype == 251u || qtype == 252u)
    return 0;

  else
    if(qtype == 253u)
    {
      signed int return_value_add_rrset$4;
      return_value_add_rrset$4=add_rrset(ans, sz, allocsz, rrn, (unsigned int)7, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset$4 == 0)
        return 0;

      signed int return_value_add_rrset$5;
      return_value_add_rrset$5=add_rrset(ans, sz, allocsz, rrn, (unsigned int)8, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset$5 == 0)
        return 0;

      signed int return_value_add_rrset$6;
      return_value_add_rrset$6=add_rrset(ans, sz, allocsz, rrn, (unsigned int)9, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset$6 == 0)
        return 0;

    }

    else
      if(qtype == 254u)
      {
        signed int return_value_add_rrset$7;
        return_value_add_rrset$7=add_rrset(ans, sz, allocsz, rrn, (unsigned int)3, queryts, cached, udp, cb, sva, ar);
        if(return_value_add_rrset$7 == 0)
          return 0;

        signed int return_value_add_rrset$8;
        return_value_add_rrset$8=add_rrset(ans, sz, allocsz, rrn, (unsigned int)4, queryts, cached, udp, cb, sva, ar);
        if(return_value_add_rrset$8 == 0)
          return 0;

      }

      else
        if(qtype == 255u)
        {
          signed int i;
          signed int n;
          signed int tmp_if_expr$9;
          if(!((1 & (signed int)cached->flags) == 0))
            tmp_if_expr$9 = 0;

          else
            tmp_if_expr$9 = cached->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
          n = tmp_if_expr$9;
          const unsigned short int *iterlist;
          const unsigned short int *tmp_if_expr$11;
          if(!((1 & (signed int)cached->flags) == 0))
            tmp_if_expr$11 = (const unsigned short int *)(void *)0;

          else
          {
            if(!(cached->$anon0.rr.rrext == ((struct anonymous **)NULL)))
              tmp_if_expr$10 = rrcachiterlist;

            else
              tmp_if_expr$10 = rrmuiterlist;
            tmp_if_expr$11 = tmp_if_expr$10;
          }
          iterlist = tmp_if_expr$11;
          i = 0;
          for( ; !(i >= n); i = i + 1)
          {
            signed int return_value_add_rrset$12;
            return_value_add_rrset$12=add_rrset(ans, sz, allocsz, rrn, (unsigned int)iterlist[(signed long int)i], queryts, cached, udp, cb, sva, ar);
            if(return_value_add_rrset$12 == 0)
              return 0;

          }
        }

        else
          if(qtype >= 1u && !(qtype >= 52u))
          {
            signed int return_value_add_rrset$13;
            return_value_add_rrset$13=add_rrset(ans, sz, allocsz, rrn, qtype, queryts, cached, udp, cb, sva, ar);
            if(return_value_add_rrset$13 == 0)
              return 0;

          }

          else
            return 0;
  return 1;
}

// addr_add
// file conf-parser.c line 1871
static const char * addr_add(struct anonymous$19 **ata, const char *ipstr)
{
  struct anonymous$20 *at;
  union anonymous$6 addr;
  if(cmdlineipv == 0)
    cmdlineipv = (signed short int)-2;

  signed int return_value_str2pdnsd_a$2;
  return_value_str2pdnsd_a$2=str2pdnsd_a(ipstr, &addr);
  signed int return_value_inet_pton$1;
  if(return_value_str2pdnsd_a$2 == 0)
  {
    if(!(run_ipv4 == 0))
    {
      return_value_inet_pton$1=inet_pton(10, ipstr, (void *)&addr.ipv6);
      if(return_value_inet_pton$1 >= 1)
      {
        fprintf(stderr, "IPv6 address \"%s\" in config file ignored while running in IPv4 mode.\n", ipstr);
        return (const char *)(void *)0;
      }

    }

    return "bad IP address";
  }

  struct anonymous$3 *return_value_da_grow1$3;
  return_value_da_grow1$3=da_grow1((struct anonymous$3 *)*ata, (unsigned long int)((struct anonymous$19 *)0)->elem, sizeof(struct anonymous$20) /*32ul*/ , (void (*)(void *))(void *)0);
  *ata = (struct anonymous$19 *)return_value_da_grow1$3;
  if(*ata == ((struct anonymous$19 *)NULL))
    return "out of memory!";

  else
  {
    at = &(*ata)->elem[(signed long int)((*ata)->nel - (unsigned long int)1)];
    SET_PDNSD_A2(&at->a, &addr);
    at->is_up = (char)0;
    at->i_ts = (signed long int)0;
    return (const char *)(void *)0;
  }
}

// adjust_dom_ttl
// file cache.c line 1840
static inline void adjust_dom_ttl(struct anonymous$0 *cent)
{
  if(!((8 & (signed int)cent->flags) == 0))
  {
    cent->flags = cent->flags & (unsigned short int)~8;
    cent->$anon0.neg.ttl = (signed long int)0;
  }

  else
  {
    signed long int min_ttl = global.min_ttl;
    signed long int neg_ttl = global.neg_ttl;
    if(!(neg_ttl >= min_ttl))
      min_ttl = neg_ttl;

    if(!(cent->$anon0.neg.ttl >= min_ttl))
      cent->$anon0.neg.ttl = min_ttl;

    else
    {
      signed long int max_ttl = global.max_ttl;
      if(!(max_ttl >= cent->$anon0.neg.ttl))
        cent->$anon0.neg.ttl = max_ttl;

    }
  }
}

// adjust_ttl
// file cache.c line 1817
static inline void adjust_ttl(struct anonymous *rrset)
{
  if(!((8 & (signed int)rrset->flags) == 0))
  {
    rrset->flags = rrset->flags & (unsigned short int)~8;
    rrset->ttl = (signed long int)0;
  }

  else
  {
    signed long int min_ttl = global.min_ttl;
    signed long int neg_ttl = global.neg_ttl;
    if(!((1 & (signed int)rrset->flags) == 0))
    {
      if(!(neg_ttl >= min_ttl))
        min_ttl = neg_ttl;

    }

    if(!(rrset->ttl >= min_ttl))
      rrset->ttl = min_ttl;

    else
    {
      signed long int max_ttl = global.max_ttl;
      if(!(max_ttl >= rrset->ttl))
        rrset->ttl = max_ttl;

    }
  }
}

// alloc_nel
// file list.c line 57
static inline unsigned long int alloc_nel(unsigned long int n)
{
  return n == (unsigned long int)0 ? (unsigned long int)8 : n + (unsigned long int)7 & (unsigned long int)~7;
}

// ans_ttl
// file dns_answer.c line 170
static inline signed long int ans_ttl(struct anonymous *rrset, signed long int queryts)
{
  signed long int ttl = rrset->ttl;
  if((2 & (signed int)rrset->flags) == 0)
  {
    signed long int tpassed = queryts - rrset->ts;
    if(!(tpassed >= 0l))
      tpassed = (signed long int)0;

    ttl = ttl - tpassed;
    if(!(ttl >= 0l))
      ttl = (signed long int)0;

  }

  return ttl;
}

// auth_ok
// file dns_query.c line 2554
static signed int auth_ok(struct anonymous$4 *q, const unsigned char *name, signed int thint, struct anonymous$0 *ent, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, struct anonymous$5 *qse, struct _dynamic_list_head *ns, struct anonymous$4 **serv)
{
  signed int retval = 0;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  signed int return_value_have_rr$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  const char *return_value_pdnsd_a2str$13;
  const unsigned char *return_value_rhn2str$14;
  const unsigned char *return_value_rhn2str$15;
  const unsigned char *return_value_rhn2str$17;
  const unsigned char *return_value_rhn2str$18;
  const unsigned char *return_value_rhn2str$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$22;
  const unsigned char *return_value_rhn2str$26;
  signed int return_value_equiv_inaddr2$44;
  const char *return_value_pdnsd_a2str$42;
  const char *return_value_pdnsd_a2str$49;
  if((signed int)qse->failed >= 2)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(!(qse->auth_serv == 0))
      tmp_if_expr$1 = !(((signed int)ent->flags & 1) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    _Bool tmp_if_expr$8;
    if(tmp_if_expr$1)
    {
      if(thint >= 251 && !(thint >= 256))
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        if(thint >= 1 && !(thint >= 52))
        {
          return_value_have_rr$2=have_rr$link1(ent, thint);
          if(return_value_have_rr$2 == 0)
          {
            if((1 & (signed int)ent->flags) == 0)
              tmp_if_expr$3 = ent->$anon0.rr.rrmu[(signed long int)2] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = ent->$anon0.rr.rrmu[(signed long int)2]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            tmp_if_expr$5 = !tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$5 = (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$8 = (_Bool)0;
    if(!tmp_if_expr$8)
      return 1;

    else
    {
      if(!(qse->aa == 0))
      {
        unsigned char *nsdomain;
        if(qse->nsdomain == ((const unsigned char *)NULL))
          return 1;

        void *return_value_dlist_first$9;
        return_value_dlist_first$9=dlist_first$link2(ns);
        nsdomain = (unsigned char *)return_value_dlist_first$9;
        if(nsdomain == ((unsigned char *)NULL))
          return 1;

        do
        {
          unsigned int rem;
          unsigned int crem;
          domain_match(nsdomain, qse->nsdomain, &rem, &crem);
          if(!(crem == 0u) || !(rem >= 1u))
            return 1;

          domain_match(nsdomain, name, &rem, (unsigned int *)(void *)0);
          if(!(rem == 0u))
            return 1;

          do
          {
            void *return_value_dlist_next$10;
            return_value_dlist_next$10=dlist_next$link2((void *)nsdomain);
            nsdomain = (unsigned char *)return_value_dlist_next$10;
            if(nsdomain == ((unsigned char *)NULL))
              goto done_checkauth;

          }
          while((signed int)*nsdomain == 0xff);
        }
        while((_Bool)1);

      done_checkauth:
        ;
        if(!(debug_p == 0))
        {
          unsigned char dbuf[256l];
          unsigned char sdbuf[256l];
          void *return_value_dlist_first$11;
          return_value_dlist_first$11=dlist_first$link2(ns);
          nsdomain = (unsigned char *)return_value_dlist_first$11;
          char _debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous$6 *tmp_if_expr$12;
            if(!(run_ipv4 == 0))
              tmp_if_expr$12 = (union anonymous$6 *)&qse->a.sin4.sin_addr;

            else
              tmp_if_expr$12 = (union anonymous$6 *)&qse->a.sin6.sin6_addr;
            return_value_pdnsd_a2str$13=pdnsd_a2str(tmp_if_expr$12, _debugsockabuf, 46);
            return_value_rhn2str$14=rhn2str(qse->nsdomain, dbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            return_value_rhn2str$15=rhn2str(nsdomain, sdbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            debug_msg(0, "The name server %s which is responsible for the %s domain, raised the aa flag, but appears to delegate to the sub-domain %s\n", return_value_pdnsd_a2str$13, return_value_rhn2str$14, return_value_rhn2str$15);
          }

        }

      }

      if(hops >= 1)
      {
        unsigned char *nsdomp;
        unsigned char *auth_ok$$1$$2$$nsdomain = (unsigned char *)(void *)0;
        struct anonymous *localrrset = (struct anonymous *)(void *)0;
        struct rr_b_s *localrr = (struct rr_b_s *)(void *)0;
        void *return_value_dlist_first$16;
        return_value_dlist_first$16=dlist_first$link2(ns);
        nsdomp = (unsigned char *)return_value_dlist_first$16;
        do
        {
          unsigned char *nsname = (unsigned char *)(void *)0;
          struct anonymous$15 serva;
          if(!(localrr == ((struct rr_b_s *)NULL)))
          {
            nsname = (unsigned char *)localrr->data;
            localrr = localrr->next;
          }

          else
          {
            if(!(localrrset == ((struct anonymous *)NULL)))
            {
              del_rrset(localrrset);
              localrrset = (struct anonymous *)(void *)0;
            }

            if(nsdomp == ((unsigned char *)NULL))
              break;

            else
              if(!((signed int)*nsdomp == 0xff))
              {
                auth_ok$$1$$2$$nsdomain = nsdomp;
                if(!(global.paranoid == 0))
                {
                  unsigned int auth_ok$$1$$2$$1$$1$$2$$2$$1$$rem;
                  domain_match(auth_ok$$1$$2$$nsdomain, name, &auth_ok$$1$$2$$1$$1$$2$$2$$1$$rem, (unsigned int *)(void *)0);
                  if(!(auth_ok$$1$$2$$1$$1$$2$$2$$1$$rem == 0u))
                  {
                    unsigned char nmbuf[256l];
                    unsigned char auth_ok$$1$$2$$1$$1$$2$$2$$1$$1$$dbuf[256l];
                    unsigned char nsbuf[256l];
                    if(!(debug_p == 0))
                    {
                      return_value_rhn2str$17=rhn2str(nsname, nsbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                      return_value_rhn2str$18=rhn2str(auth_ok$$1$$2$$nsdomain, auth_ok$$1$$2$$1$$1$$2$$2$$1$$1$$dbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                      return_value_rhn2str$19=rhn2str(name, nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                      debug_msg(0, "The name server %s is responsible for the %s domain, which does not match %s\n", return_value_rhn2str$17, return_value_rhn2str$18, return_value_rhn2str$19);
                    }

                    do
                    {
                      void *return_value_dlist_next$21;
                      return_value_dlist_next$21=dlist_next$link2((void *)nsdomp);
                      nsdomp = (unsigned char *)return_value_dlist_next$21;
                      if(!(nsdomp == ((unsigned char *)NULL)))
                        tmp_if_expr$20 = (signed int)*nsdomp == 0xff ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr$20 = (_Bool)0;
                    }
                    while(tmp_if_expr$20);
                    continue;
                  }

                }

                localrrset=lookup_cache_local_rrset(auth_ok$$1$$2$$nsdomain, 2);
                if(!(localrrset == ((struct anonymous *)NULL)))
                {
                  do
                  {
                    void *return_value_dlist_next$23;
                    return_value_dlist_next$23=dlist_next$link2((void *)nsdomp);
                    nsdomp = (unsigned char *)return_value_dlist_next$23;
                    if(!(nsdomp == ((unsigned char *)NULL)))
                      tmp_if_expr$22 = (signed int)*nsdomp == 0xff ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$22 = (_Bool)0;
                  }
                  while(tmp_if_expr$22);
                  localrr = localrrset->rrs;
                  if(localrr == ((struct rr_b_s *)NULL))
                    continue;

                  nsname = (unsigned char *)localrr->data;
                  localrr = localrr->next;
                }

                else
                {
                  nsname=skiprhn$link1(nsdomp);
                  void *return_value_dlist_next$24;
                  return_value_dlist_next$24=dlist_next$link2((void *)nsdomp);
                  nsdomp = (unsigned char *)return_value_dlist_next$24;
                }
              }

              else
              {
                nsname = nsdomp + (signed long int)1;
                void *return_value_dlist_next$25;
                return_value_dlist_next$25=dlist_next$link2((void *)nsdomp);
                nsdomp = (unsigned char *)return_value_dlist_next$25;
              }
          }
          if(run_ipv4 == 0)
            serva.ipv6 = in6addr_any;

          serva.ipv4.s_addr = (unsigned int)0x00000000;
          const unsigned char *nm = name;
          signed int tp = thint;
          struct qhintnode_s *auth_ok$$1$$2$$1$$1$$3$$ql = qhlist;
          do
          {
            signed int return_value_rhnicmp$27;
            return_value_rhnicmp$27=rhnicmp$link1(nm, nsname);
            if(!(return_value_rhnicmp$27 == 0))
            {
              if(tp == 1)
              {
                unsigned char _debugstrbuf[256l];
                if(!(debug_p == 0))
                {
                  return_value_rhn2str$26=rhn2str(nsname, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                  debug_msg(0, "Not looking up address for name server \"%s\": risk of infinite recursion.\n", return_value_rhn2str$26);
                }

                goto skip_server;
              }

            }

            if(auth_ok$$1$$2$$1$$1$$3$$ql == ((struct qhintnode_s *)NULL))
              break;

            nm = auth_ok$$1$$2$$1$$1$$3$$ql->nm;
            tp = auth_ok$$1$$2$$1$$1$$3$$ql->tp;
            auth_ok$$1$$2$$1$$1$$3$$ql = auth_ok$$1$$2$$1$$1$$3$$ql->next;
          }
          while((_Bool)1);
          struct qhintnode_s qhn = { .nm=name, .tp=thint, .next=qhlist };
          struct anonymous$0 *servent;
          signed long int return_value_time$33;
          return_value_time$33=time((signed long int *)(void *)0);
          signed int return_value_r_dns_cached_resolve$34;
          return_value_r_dns_cached_resolve$34=r_dns_cached_resolve(nsname, 1, &servent, hops - 1, &qhn, return_value_time$33, (unsigned char *)(void *)0);
          if(return_value_r_dns_cached_resolve$34 == 0)
          {
            if(!(run_ipv4 == 0))
            {
              struct anonymous *rrset;
              struct anonymous *tmp_if_expr$28;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr$28 = servent->$anon0.rr.rrmu[(signed long int)0];

              else
                tmp_if_expr$28 = (struct anonymous *)(void *)0;
              rrset = tmp_if_expr$28;
              if(!(rrset == ((struct anonymous *)NULL)))
              {
                if(!(rrset->rrs == ((struct rr_b_s *)NULL)))
                  serva.ipv4 = *((struct in_addr *)rrset->rrs->data);

              }

            }

            else
            {
              struct anonymous *auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset;
              struct anonymous *tmp_if_expr$31;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr$31 = servent->$anon0.rr.rrmu[(signed long int)7];

              else
                tmp_if_expr$31 = (struct anonymous *)(void *)0;
              auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset = tmp_if_expr$31;
              _Bool tmp_if_expr$32;
              if(!(auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset == ((struct anonymous *)NULL)))
                tmp_if_expr$32 = auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$32 = (_Bool)0;
              if(tmp_if_expr$32)
              {
                serva.ipv6 = *((struct in6_addr *)auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset->rrs->data);
                struct anonymous *tmp_if_expr$29;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr$29 = servent->$anon0.rr.rrmu[(signed long int)0];

                else
                  tmp_if_expr$29 = (struct anonymous *)(void *)0;
                auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset = tmp_if_expr$29;
                if(!(auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset == ((struct anonymous *)NULL)))
                {
                  if(!(auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset->rrs == ((struct rr_b_s *)NULL)))
                    serva.ipv4 = *((struct in_addr *)auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset->rrs->data);

                }

              }

              else
              {
                struct anonymous *tmp_if_expr$30;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr$30 = servent->$anon0.rr.rrmu[(signed long int)0];

                else
                  tmp_if_expr$30 = (struct anonymous *)(void *)0;
                auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset = tmp_if_expr$30;
                if(!(auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset == ((struct anonymous *)NULL)))
                {
                  if(!(auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset->rrs == ((struct rr_b_s *)NULL)))
                  {
                    struct in_addr *ina = (struct in_addr *)auth_ok$$1$$2$$1$$1$$3$$2$$1$$2$$rrset->rrs->data;
                    ((unsigned int *)&serva.ipv6)[(signed long int)3] = ina->s_addr;
                    ((unsigned int *)&serva.ipv6)[(signed long int)2]=htonl((unsigned int)0xffff);
                    ((unsigned int *)&serva.ipv6)[(signed long int)0] = (unsigned int)0;
                    ((unsigned int *)&serva.ipv6)[(signed long int)1] = ((unsigned int *)&serva.ipv6)[(signed long int)0];
                  }

                }

              }
            }
            free_cent(servent);
            free((void *)servent);
          }

          signed int return_value_is_inaddr2_any$35;
          return_value_is_inaddr2_any$35=is_inaddr2_any(&serva);
          if(return_value_is_inaddr2_any$35 == 0)
          {
            union anonymous$6 *tmp_if_expr$36;
            if(!(run_ipv4 == 0))
              tmp_if_expr$36 = (union anonymous$6 *)&(&serva)->ipv4;

            else
              tmp_if_expr$36 = (union anonymous$6 *)&(&serva)->ipv6;
            signed int return_value_is_local_addr$37;
            return_value_is_local_addr$37=is_local_addr(tmp_if_expr$36);
            if(return_value_is_local_addr$37 == 0)
            {
              signed int i;
              signed int n;
              unsigned int return_value_da_nel$38;
              return_value_da_nel$38=da_nel$link2((struct anonymous$3 *)*serv);
              n = (signed int)return_value_da_nel$38;
              i = 0;
              for( ; !(i >= n); i = i + 1)
              {
                struct anonymous$5 *qs = &(*serv)->elem[(signed long int)i];
                signed int return_value_query_stat_same_inaddr2$39;
                return_value_query_stat_same_inaddr2$39=query_stat_same_inaddr2(qs, &serva);
                if(!(return_value_query_stat_same_inaddr2$39 == 0))
                  goto skip_server;

              }
              struct anonymous$4 *qa = q;
              struct qstatnode_s *ql = qslist;
              do
              {
                signed int auth_ok$$1$$2$$1$$1$$5$$1$$1$$i;
                signed int auth_ok$$1$$2$$1$$1$$5$$1$$1$$n;
                unsigned int return_value_da_nel$40;
                return_value_da_nel$40=da_nel$link2((struct anonymous$3 *)qa);
                auth_ok$$1$$2$$1$$1$$5$$1$$1$$n = (signed int)return_value_da_nel$40;
                auth_ok$$1$$2$$1$$1$$5$$1$$1$$i = 0;
                for( ; !(auth_ok$$1$$2$$1$$1$$5$$1$$1$$i >= auth_ok$$1$$2$$1$$1$$5$$1$$1$$n); auth_ok$$1$$2$$1$$1$$5$$1$$1$$i = auth_ok$$1$$2$$1$$1$$5$$1$$1$$i + 1)
                {
                  struct anonymous$5 *auth_ok$$1$$2$$1$$1$$5$$1$$1$$1$$1$$qs = &qa->elem[(signed long int)auth_ok$$1$$2$$1$$1$$5$$1$$1$$i];
                  if((signed int)auth_ok$$1$$2$$1$$1$$5$$1$$1$$1$$1$$qs->state == 8)
                  {
                    union anonymous$6 *tmp_if_expr$43;
                    if(!(run_ipv4 == 0))
                      tmp_if_expr$43 = (union anonymous$6 *)&auth_ok$$1$$2$$1$$1$$5$$1$$1$$1$$1$$qs->a.sin4.sin_addr;

                    else
                      tmp_if_expr$43 = (union anonymous$6 *)&auth_ok$$1$$2$$1$$1$$5$$1$$1$$1$$1$$qs->a.sin6.sin6_addr;
                    return_value_equiv_inaddr2$44=equiv_inaddr2$link1(tmp_if_expr$43, &serva);
                    if(!(return_value_equiv_inaddr2$44 == 0))
                    {
                      char auth_ok$$1$$2$$1$$1$$5$$1$$1$$1$$1$$1$$1$$_debugsockabuf[46l];
                      if(!(debug_p == 0))
                      {
                        union anonymous$6 *tmp_if_expr$41;
                        if(!(run_ipv4 == 0))
                          tmp_if_expr$41 = (union anonymous$6 *)&(&serva)->ipv4;

                        else
                          tmp_if_expr$41 = (union anonymous$6 *)&(&serva)->ipv6;
                        return_value_pdnsd_a2str$42=pdnsd_a2str(tmp_if_expr$41, auth_ok$$1$$2$$1$$1$$5$$1$$1$$1$$1$$1$$1$$_debugsockabuf, 46);
                        debug_msg(0, "Not trying name server %s, already queried.\n", return_value_pdnsd_a2str$42);
                      }

                      goto skip_server;
                    }

                  }

                }
                if(ql == ((struct qstatnode_s *)NULL))
                  break;

                qa = ql->qa;
                ql = ql->next;
              }
              while((_Bool)1);
              _Bool tmp_if_expr$45;
              if(!(qse->rejectlist == ((struct rejectlist_s *)NULL)))
                tmp_if_expr$45 = qse->rejectlist->inherit != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$45 = (_Bool)0;
              struct rejectlist_s *tmp_if_expr$46;
              if(tmp_if_expr$45)
                tmp_if_expr$46 = qse->rejectlist;

              else
                tmp_if_expr$46 = (struct rejectlist_s *)(void *)0;
              signed int return_value_add_qserv$47;
              return_value_add_qserv$47=add_qserv(serv, &serva, 53, qse->timeout, (unsigned int)((signed int)qse->flags & ~(2 | 4 | 16 | 64)), 0, qse->lean_query, qse->edns_query, (char)2, (char)0, (char)!(global.paranoid != 0), auth_ok$$1$$2$$nsdomain, tmp_if_expr$46);
              if(return_value_add_qserv$47 == 0)
                return -1;

              retval = 1;
            }

          }


        skip_server:
          ;
        }
        while((_Bool)1);
        if(retval == 0)
        {
          char auth_ok$$1$$2$$2$$1$$_debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous$6 *tmp_if_expr$48;
            if(!(run_ipv4 == 0))
              tmp_if_expr$48 = (union anonymous$6 *)&qse->a.sin4.sin_addr;

            else
              tmp_if_expr$48 = (union anonymous$6 *)&qse->a.sin6.sin6_addr;
            return_value_pdnsd_a2str$49=pdnsd_a2str(tmp_if_expr$48, auth_ok$$1$$2$$2$$1$$_debugsockabuf, 46);
            debug_msg(0, "No remaining authoritative name servers to try in authority section from %s.\n", return_value_pdnsd_a2str$49);
          }

        }

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "Maximum hops count reached; not trying any more name servers.\n");

      return retval;
    }
  }
}

// bind_socket
// file dns_query.c line 682
static signed int bind_socket(signed int s)
{
  signed int query_port_start = global.query_port_start;
  signed int query_port_end = global.query_port_end;
  signed int *return_value___errno_location$4;
  if(query_port_start >= 0)
  {
    /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'sin4'|lSYM#tag-sockaddr_in6#'sin6'] */
union anonymous$22
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

/* */
    ;
    union anonymous$22 sin;
    unsigned int sinl;
    signed int prt;
    signed int pstart;
    signed int range = (query_port_end - query_port_start) + 1;
    signed int m = 0xffff;
    unsigned int try1;
    unsigned int try2;
    unsigned int maxtry2;
    if(range >= 65537 || !(range >= 1))
    {
      log_message(4, "Illegal port range in %s line %d, dropping query!\n", (const void *)"dns_query.c", 704);
      return 0;
    }

    if(!(range >= 32769))
    {
      m = 1;
      for( ; !(m >= range); m = m << 1)
        ;
      m = m - 1;
    }

    try2 = (unsigned int)0;
    maxtry2 = (unsigned int)(range * 2);
    do
    {
      try1 = (unsigned int)0;
      do
      {
        unsigned short int return_value_get_rand16$1;
        return_value_get_rand16$1=get_rand16();
        prt = (signed int)return_value_get_rand16$1 & m;
        if(!(prt >= range))
          break;

        try1 = try1 + 1u;
        if(try1 >= 65536u)
        {
          log_message(4, "Cannot get random number < range after %d tries in %s line %d, bad random number generator?\n", try1, (const void *)"dns_query.c", 723);
          return 0;
        }

      }
      while((_Bool)1);
      prt = prt + query_port_start;
      pstart = prt;
      while((_Bool)1)
      {
        if(!(run_ipv4 == 0))
        {
          memset((void *)&sin.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
          sin.sin4.sin_family = (unsigned short int)2;
          sin.sin4.sin_port=htons((unsigned short int)prt);
          sin.sin4.sin_addr = global.out_a.ipv4;
          sinl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        }

        else
        {
          memset((void *)&sin.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
          sin.sin6.sin6_family = (unsigned short int)10;
          sin.sin6.sin6_port=htons((unsigned short int)prt);
          sin.sin6.sin6_flowinfo = (unsigned int)0;
          sin.sin6.sin6_addr = global.out_a.ipv6;
          sinl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
        }
        signed int return_value_bind$6;
        return_value_bind$6=bind(s, (struct sockaddr *)&sin, sinl);
        if(return_value_bind$6 == -1)
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          if(!(*return_value___errno_location$5 == 98))
          {
            return_value___errno_location$4=__errno_location();
            if(!(*return_value___errno_location$4 == 99))
            {
              signed int *return_value___errno_location$2;
              return_value___errno_location$2=__errno_location();
              char *return_value_strerror$3;
              return_value_strerror$3=strerror(*return_value___errno_location$2);
              log_message(4, "Could not bind to socket: %s\n", return_value_strerror$3);
              return 0;
            }

          }

        }

        else
          goto done;
        try2 = try2 + 1u;
        if(try2 >= maxtry2)
        {
          prt = prt + 1;
          if(!(query_port_end >= prt))
            prt = query_port_start;

          if(prt == pstart)
          {
            log_message(4, "Out of ports in the range %d-%d, dropping query!\n", query_port_start, query_port_end);
            return 0;
          }

        }

        else
          break;
      }
    }
    while((_Bool)1);
  }


done:
  ;
  return 1;
}

// binsearch_keyword
// file consts.h line 65
signed int binsearch_keyword(const char *name, signed int len, const struct anonymous$32 *dic, signed int range)
{
  signed int i = 0;
  signed int j = range;
  while(!(i >= j))
  {
    signed int k = (i + j) / 2;
    signed int cmp;
    cmp=keyncmp(name, len, (dic + (signed long int)k)->name);
    if(!(cmp >= 0))
      j = k;

    else
      if(cmp >= 1)
        i = k + 1;

      else
        return (dic + (signed long int)k)->val;
  }
  return 0;
}

// change_servers
// file servers.h line 45
signed int change_servers(signed int i, struct anonymous$54 *ar, signed int up)
{
  signed int retval = 0;
  signed int j;
  signed int change;
  signed int signal_test;
  signed int n;
  struct anonymous$7 *sp;
  pthread_mutex_lock(&servers_lock);
  signal_test = 0;
  change = 0;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link5((struct anonymous$3 *)ar);
  n = (signed int)return_value_da_nel$1;
  sp = &servers->elem[(signed long int)i];
  unsigned int return_value_da_nel$3;
  return_value_da_nel$3=da_nel$link5((struct anonymous$3 *)sp->atup_a);
  _Bool tmp_if_expr$4;
  if(!((unsigned int)n == return_value_da_nel$3))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed int)sp->rootserver > 1 ? (_Bool)1 : (_Bool)0;
  signed int return_value_same_inaddr2$2;
  if(tmp_if_expr$4)
    change = 1;

  else
  {
    signed int change_servers$$1$$1$$j = 0;
    for( ; !(change_servers$$1$$1$$j >= n); change_servers$$1$$1$$j = change_servers$$1$$1$$j + 1)
    {
      return_value_same_inaddr2$2=same_inaddr2(&ar->elem[(signed long int)change_servers$$1$$1$$j], &sp->atup_a->elem[(signed long int)change_servers$$1$$1$$j].a);
      if(return_value_same_inaddr2$2 == 0)
      {
        change = 1;
        break;
      }

    }
  }
  signed int return_value_pthread_equal$6;
  char *return_value_strerror$5;
  if(!(change == 0))
  {
    struct timeval now;
    struct timespec timeout;
    struct anonymous$19 *ata;
    if(server_status_ping >= 1)
    {
      return_value_pthread_equal$6=pthread_equal(servstat_thrid, main_thrid);
      if(return_value_pthread_equal$6 == 0)
      {
        signed int err;
        if(!(debug_p == 0))
          debug_msg(0, "Sending server status thread an interrupt signal.\n");

        err=pthread_kill(servstat_thrid, 1);
        if(!(err == 0))
        {
          if(!(debug_p == 0))
          {
            return_value_strerror$5=strerror(err);
            debug_msg(0, "pthread_kill failed: %s\n", return_value_strerror$5);
          }

        }

      }

    }

    if(!(debug_p == 0))
      debug_msg(0, "Changing IPs of server section #%d\n", i);

    gettimeofday(&now, (struct timezone *)(void *)0);
    timeout.tv_sec = now.tv_sec + (signed long int)60;
    timeout.tv_nsec = now.tv_usec * (signed long int)1000;
    while(server_data_users >= 1)
    {
      signed int return_value_pthread_cond_timedwait$7;
      return_value_pthread_cond_timedwait$7=pthread_cond_timedwait(&server_data_cond, &servers_lock, &timeout);
      if(return_value_pthread_cond_timedwait$7 == 110)
      {
        retval = 110;
        goto unlock_mutex;
      }

    }
    struct anonymous$3 *return_value_da_resize$8;
    return_value_da_resize$8=da_resize((struct anonymous$3 *)(void *)0, (unsigned long int)((struct anonymous$19 *)0)->elem, sizeof(struct anonymous$20) /*32ul*/ , (unsigned long int)n, (void (*)(void *))(void *)0);
    ata = (struct anonymous$19 *)return_value_da_resize$8;
    if(ata == ((struct anonymous$19 *)NULL))
    {
      log_message(4, "Out of memory in change_servers().");
      retval = 12;
      goto unlock_mutex;
    }

    free((void *)sp->atup_a);
    sp->atup_a = ata;
    if((signed int)sp->rootserver >= 2)
      sp->rootserver = (char)1;

  }

  j = 0;
  for( ; !(j >= n); j = j + 1)
  {
    struct anonymous$20 *at = &sp->atup_a->elem[(signed long int)j];
    if(!(change == 0))
    {
      SET_PDNSD_A2$link1(&at->a, &ar->elem[(signed long int)j]);
      at->is_up = sp->preset;
    }

    if(up >= 0)
    {
      at->is_up = (char)up;
      at->i_ts=time((signed long int *)(void *)0);
    }

    else
    {
      _Bool tmp_if_expr$9;
      if(!(change == 0))
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = at->i_ts != 0l ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
      {
        at->i_ts = (signed long int)0;
        signal_test = 1;
      }

    }
  }
  if(!(signal_test == 0))
  {
    signed int return_value_pthread_equal$10;
    return_value_pthread_equal$10=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal$10 == 0))
      retval=start_servstat_thread();

    else
    {
      retest_flag = (signed short int)1;
      retval=pthread_cond_signal(&server_test_cond);
    }
  }


unlock_mutex:
  ;
  pthread_mutex_unlock(&servers_lock);
  return retval;
}

// check_ipv6
// file main.c line 202
static signed int check_ipv6()
{
  signed int fd;
  fd=socket(10, 1, 0);
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$4;
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    _Bool tmp_if_expr$3;
    if(*return_value___errno_location$1 == 93)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 97 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$5;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value___errno_location$4=__errno_location();
      tmp_if_expr$5 = *return_value___errno_location$4 == 22 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      return 0;

    return -1;
  }

  close(fd);
  return 1;
}

// check_localaddrs
// file conf-parser.c line 1976
static void check_localaddrs(struct anonymous$7 *serv)
{
  struct anonymous$3 *return_value_da_resize$10;
  if((signed int)serv->port == global.port)
  {
    struct anonymous$19 *ata = serv->atup_a;
    signed int i;
    signed int j = 0;
    signed int n;
    unsigned int return_value_da_nel$1;
    return_value_da_nel$1=da_nel((struct anonymous$3 *)ata);
    n = (signed int)return_value_da_nel$1;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous$20 *at = &ata->elem[(signed long int)i];
      signed int return_value_is_inaddr_any$9;
      return_value_is_inaddr_any$9=is_inaddr_any(&global.a);
      if(!(return_value_is_inaddr_any$9 == 0))
      {
        union anonymous$6 *tmp_if_expr$4;
        if(!(run_ipv4 == 0))
          tmp_if_expr$4 = (union anonymous$6 *)&(&at->a)->ipv4;

        else
          tmp_if_expr$4 = (union anonymous$6 *)&(&at->a)->ipv6;
        signed int return_value_is_local_addr$5;
        return_value_is_local_addr$5=is_local_addr(tmp_if_expr$4);
        if(!(return_value_is_local_addr$5 == 0))
        {
          char buf[46l];
          union anonymous$6 *tmp_if_expr$2;
          if(!(run_ipv4 == 0))
            tmp_if_expr$2 = (union anonymous$6 *)&(&at->a)->ipv4;

          else
            tmp_if_expr$2 = (union anonymous$6 *)&(&at->a)->ipv6;
          const char *return_value_pdnsd_a2str$3;
          return_value_pdnsd_a2str$3=pdnsd_a2str(tmp_if_expr$2, buf, 46);
          fprintf(stderr, "Local name-server address \"%s\" ignored in config file.\n", return_value_pdnsd_a2str$3);
          goto __CPROVER_DUMP_L13;
        }

      }

      else
      {
        signed int return_value_equiv_inaddr2$8;
        return_value_equiv_inaddr2$8=equiv_inaddr2(&global.a, &at->a);
        if(!(return_value_equiv_inaddr2$8 == 0))
        {
          char check_localaddrs$$1$$1$$1$$1$$2$$1$$buf[46l];
          union anonymous$6 *tmp_if_expr$6;
          if(!(run_ipv4 == 0))
            tmp_if_expr$6 = (union anonymous$6 *)&(&at->a)->ipv4;

          else
            tmp_if_expr$6 = (union anonymous$6 *)&(&at->a)->ipv6;
          const char *return_value_pdnsd_a2str$7;
          return_value_pdnsd_a2str$7=pdnsd_a2str(tmp_if_expr$6, check_localaddrs$$1$$1$$1$$1$$2$$1$$buf, 46);
          fprintf(stderr, "Ignoring name-server address \"%s\" in config file (identical to server_ip address).\n", return_value_pdnsd_a2str$7);
          goto __CPROVER_DUMP_L13;
        }

      }
      if(!(j >= i))
        ata->elem[(signed long int)j] = *at;

      j = j + 1;

    __CPROVER_DUMP_L13:
      ;
    }
    if(!(j >= n))
    {
      return_value_da_resize$10=da_resize((struct anonymous$3 *)ata, (unsigned long int)((struct anonymous$19 *)0)->elem, sizeof(struct anonymous$20) /*32ul*/ , (unsigned long int)j, (void (*)(void *))(void *)0);
      serv->atup_a = (struct anonymous$19 *)return_value_da_resize$10;
    }

  }

}

// compose_answer
// file dns_answer.c line 752
static struct anonymous$28 * compose_answer(struct anonymous$40 *ql, struct anonymous$29 *hdr, unsigned long int *rlen, struct anonymous$17 *ednsinfo, unsigned int *udp, signed int *rcodep)
{
  unsigned short int rcode = (unsigned short int)0;
  unsigned short int aa = (unsigned short int)1;
  struct _dynamic_list_head *cb = (struct _dynamic_list_head *)(void *)0;
  struct _dynamic_list_head *sva = (struct _dynamic_list_head *)(void *)0;
  struct _dynamic_list_head *ar = (struct _dynamic_list_head *)(void *)0;
  signed long int queryts;
  queryts=time((signed long int *)(void *)0);
  struct anonymous$70 *qe;
  struct anonymous$28 *ans;
  unsigned long int allocsz = (unsigned long int)256;
  struct anonymous$0 *cached;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(allocsz);
  ans = (struct anonymous$28 *)return_value_malloc$1;
  void *return_value_llist_next$3;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$18;
  void *return_value_llist_next$12;
  const unsigned char *return_value_skipsegs$25;
  _Bool tmp_if_expr$60;
  _Bool tmp_if_expr$62;
  signed int return_value_have_rr$61;
  signed int return_value_follow_cname_chain$64;
  signed int return_value_have_rr$29;
  _Bool tmp_if_expr$34;
  _Bool tmp_if_expr$31;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$33;
  _Bool tmp_if_expr$38;
  _Bool tmp_if_expr$35;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$37;
  _Bool tmp_if_expr$42;
  _Bool tmp_if_expr$39;
  _Bool tmp_if_expr$40;
  _Bool tmp_if_expr$41;
  _Bool tmp_if_expr$47;
  _Bool tmp_if_expr$44;
  _Bool tmp_if_expr$45;
  _Bool tmp_if_expr$46;
  _Bool tmp_if_expr$51;
  _Bool tmp_if_expr$48;
  _Bool tmp_if_expr$49;
  _Bool tmp_if_expr$50;
  const unsigned char *return_value_skipsegs$54;
  void *return_value_llist_next$21;
  void *return_value_dlist_next$67;
  void *return_value_dlist_next$72;
  if(!(ans == ((struct anonymous$28 *)NULL)))
  {
    ans->hdr.id = hdr->id;
    ans->hdr.qr = (unsigned int)1;
    ans->hdr.opcode = (unsigned int)0;
    ans->hdr.aa = (unsigned int)0;
    ans->hdr.tc = (unsigned int)0;
    ans->hdr.rd = (unsigned int)hdr->rd;
    ans->hdr.ra = (unsigned int)1;
    ans->hdr.z = (unsigned int)0;
    ans->hdr.ad = (unsigned int)0;
    ans->hdr.cd = (unsigned int)0;
    ans->hdr.rcode = (unsigned int)rcode;
    ans->hdr.qdcount = (unsigned short int)0;
    ans->hdr.ancount = (unsigned short int)0;
    ans->hdr.nscount = (unsigned short int)0;
    ans->hdr.arcount = (unsigned short int)0;
    *rlen = sizeof(struct anonymous$29) /*12ul*/ ;
    void *return_value_llist_first$2;
    return_value_llist_first$2=llist_first(ql);
    qe = (struct anonymous$70 *)return_value_llist_first$2;
    for( ; !(qe == ((struct anonymous$70 *)NULL)); qe = (struct anonymous$70 *)return_value_llist_next$3)
    {
      unsigned int qclen;
      unsigned long int newsz;
      unsigned int return_value_rhnlen$4;
      return_value_rhnlen$4=rhnlen$link2(qe->query);
      newsz = (unsigned long int)2 + *rlen + (unsigned long int)return_value_rhnlen$4 + (unsigned long int)4;
      if(!(allocsz >= newsz))
      {
        unsigned long int newallocsz = newsz + (unsigned long int)0x7f & ~((unsigned long int)0x7f);
        struct anonymous$28 *newans;
        void *return_value_realloc$5;
        return_value_realloc$5=realloc((void *)ans, newallocsz);
        newans = (struct anonymous$28 *)return_value_realloc$5;
        if(newans == ((struct anonymous$28 *)NULL))
          goto error_ans;

        ans = newans;
        allocsz = newallocsz;
      }

      unsigned char *p = (unsigned char *)&ans->hdr + (signed long int)*rlen;
      qclen=compress_name(qe->query, p, (unsigned int)*rlen, &cb);
      if(qclen == 0u)
        goto error_ans;

      p = p + (signed long int)qclen;
      do
      {
        unsigned short int t_s = (unsigned short int)qe->qtype;
        unsigned char *t_cp = (unsigned char *)p;
        unsigned char *tmp_post$6 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post$6 = (unsigned char)((signed int)t_s >> 8);
        unsigned char *tmp_post$7 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post$7 = (unsigned char)t_s;
        p = (unsigned char *)(void *)t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned short int compose_answer$$1$$1$$1$$2$$2$$t_s = (unsigned short int)qe->qclass;
        unsigned char *compose_answer$$1$$1$$1$$2$$2$$t_cp = (unsigned char *)p;
        unsigned char *tmp_post$8 = compose_answer$$1$$1$$1$$2$$2$$t_cp;
        compose_answer$$1$$1$$1$$2$$2$$t_cp = compose_answer$$1$$1$$1$$2$$2$$t_cp + 1l;
        *tmp_post$8 = (unsigned char)((signed int)compose_answer$$1$$1$$1$$2$$2$$t_s >> 8);
        unsigned char *tmp_post$9 = compose_answer$$1$$1$$1$$2$$2$$t_cp;
        compose_answer$$1$$1$$1$$2$$2$$t_cp = compose_answer$$1$$1$$1$$2$$2$$t_cp + 1l;
        *tmp_post$9 = (unsigned char)compose_answer$$1$$1$$1$$2$$2$$t_s;
        p = (unsigned char *)(void *)compose_answer$$1$$1$$1$$2$$2$$t_cp;
      }
      while((_Bool)0);
      *rlen = *rlen + (unsigned long int)(qclen + (unsigned int)4);
      unsigned short int return_value_ntohs$10;
      return_value_ntohs$10=ntohs(ans->hdr.qdcount);
      ans->hdr.qdcount=htons((unsigned short int)((signed int)return_value_ntohs$10 + 1));
      return_value_llist_next$3=llist_next((void *)qe);
    }
    void *return_value_llist_first$11;
    return_value_llist_first$11=llist_first(ql);
    qe = (struct anonymous$70 *)return_value_llist_first$11;
    for( ; !(qe == ((struct anonymous$70 *)NULL)); qe = (struct anonymous$70 *)return_value_llist_next$12)
    {
      _Bool tmp_if_expr$13;
      if(!((signed int)qe->qtype >= 1))
        tmp_if_expr$13 = (_Bool)1;

      else
        tmp_if_expr$13 = (signed int)qe->qtype > 51 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$14;
      if(tmp_if_expr$13)
        tmp_if_expr$14 = (_Bool)1;

      else
        tmp_if_expr$14 = (signed int)rrlkuptab[(signed long int)((signed int)qe->qtype - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$17;
      if(tmp_if_expr$14)
      {
        if(!((signed int)qe->qtype == 253))
          tmp_if_expr$15 = (signed int)qe->qtype != 254 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$15 = (_Bool)0;
        if(tmp_if_expr$15)
          tmp_if_expr$16 = (signed int)qe->qtype != 255 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$16 = (_Bool)0;
        tmp_if_expr$17 = tmp_if_expr$16 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$17 = (_Bool)0;
      _Bool tmp_if_expr$19;
      if(tmp_if_expr$17)
        tmp_if_expr$19 = (_Bool)1;

      else
      {
        if(!((signed int)qe->qclass == 1))
          tmp_if_expr$18 = (signed int)qe->qclass != 255 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$18 = (_Bool)0;
        tmp_if_expr$19 = tmp_if_expr$18 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$19)
      {
        if(!(debug_p == 0))
          debug_msg(0, "Unsupported QTYPE or QCLASS.\n");

        rcode = (unsigned short int)4;
        ans->hdr.rcode = (unsigned int)rcode;
        goto cleanup_return;
      }

      return_value_llist_next$12=llist_next((void *)qe);
    }
    void *return_value_llist_first$20;
    return_value_llist_first$20=llist_first(ql);
    qe = (struct anonymous$70 *)return_value_llist_first$20;
    for( ; !(qe == ((struct anonymous$70 *)NULL)); qe = (struct anonymous$70 *)return_value_llist_next$21)
    {
      signed int hops;
      unsigned char qname[256l];
      rhncpy(qname, qe->query);
      hops = 20;
      do
      {
        signed int rc;
        unsigned char c_soa = (unsigned char)0xff;
        rc=r_dns_cached_resolve(qname, (signed int)qe->qtype, &cached, 20, (struct qhintnode_s *)(void *)0, queryts, &c_soa);
        if(!(rc == 0))
        {
          rcode = (unsigned short int)rc;
          ans->hdr.rcode = (unsigned int)rcode;
          if(rc == 3)
          {
            if(!((signed int)c_soa == 0xff))
            {
              unsigned int scnt;
              scnt=rhnsegcnt(qname);
              if(!((unsigned int)c_soa >= scnt))
              {
                return_value_skipsegs$25=skipsegs(qname, scnt - (unsigned int)c_soa);
                cached=lookup_cache(return_value_skipsegs$25, (signed int *)(void *)0);
                if(!(cached == ((struct anonymous$0 *)NULL)))
                {
                  struct anonymous *rrset;
                  struct anonymous *tmp_if_expr$22;
                  if((1 & (signed int)cached->flags) == 0)
                    tmp_if_expr$22 = cached->$anon0.rr.rrmu[(signed long int)3];

                  else
                    tmp_if_expr$22 = (struct anonymous *)(void *)0;
                  rrset = tmp_if_expr$22;
                  if(!(rrset == ((struct anonymous *)NULL)))
                  {
                    if((1 & (signed int)rrset->flags) == 0)
                    {
                      struct rr_b_s *rr = rrset->rrs;
                      for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
                      {
                        signed long int return_value_ans_ttl$23;
                        return_value_ans_ttl$23=ans_ttl(rrset, queryts);
                        signed int return_value_add_rr$24;
                        return_value_add_rr$24=add_rr(&ans, rlen, &allocsz, cached->qname, (unsigned short int)6, (unsigned int)return_value_ans_ttl$23, rr->rdlen, (void *)rr->data, (char)2, udp, &cb);
                        if(return_value_add_rr$24 == 0)
                          goto error_cached;

                      }
                    }

                  }

                  free_cent(cached);
                  free((void *)cached);
                }

              }

            }

            if(!(ednsinfo == ((struct anonymous$17 *)NULL)))
            {
              signed int return_value_add_opt_pseudo_rr$26;
              return_value_add_opt_pseudo_rr$26=add_opt_pseudo_rr(&ans, rlen, &allocsz, (unsigned short int)global.udpbufsize, rcode, (unsigned short int)0, (unsigned short int)0);
              if(return_value_add_opt_pseudo_rr$26 == 0)
                goto error_ans;

            }

          }

          goto cleanup_return;
        }

        if((2 & (signed int)cached->flags) == 0)
          aa = (unsigned short int)0;

        signed int return_value_add_to_response$27;
        return_value_add_to_response$27=add_to_response(&ans, rlen, &allocsz, qname, (unsigned int)qe->qtype, queryts, cached, udp, &cb, &sva, &ar);
        if(return_value_add_to_response$27 == 0)
          goto error_cached;

        _Bool tmp_if_expr$58;
        if(!(hdr->rd == 0u))
          tmp_if_expr$58 = (signed int)qe->qtype != 5 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$58 = (_Bool)0;
        _Bool tmp_if_expr$59;
        if(tmp_if_expr$58)
          tmp_if_expr$59 = (signed int)qe->qtype != 255 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$59 = (_Bool)0;
        _Bool tmp_if_expr$63;
        if(tmp_if_expr$59)
        {
          if((signed int)qe->qtype >= 1)
            tmp_if_expr$60 = (signed int)qe->qtype <= 51 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$60 = (_Bool)0;
          if(tmp_if_expr$60)
          {
            return_value_have_rr$61=have_rr(cached, (signed int)qe->qtype);
            tmp_if_expr$62 = return_value_have_rr$61 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$62 = (_Bool)0;
          tmp_if_expr$63 = !tmp_if_expr$62 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$63 = (_Bool)0;
        _Bool tmp_if_expr$65;
        if(tmp_if_expr$63)
        {
          return_value_follow_cname_chain$64=follow_cname_chain(cached, qname);
          tmp_if_expr$65 = return_value_follow_cname_chain$64 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$65 = (_Bool)0;
        if(!tmp_if_expr$65)
        {
          struct anonymous *compose_answer$$1$$3$$1$$1$$2$$rrset;
          signed int rretp = 2;
          _Bool tmp_if_expr$28;
          if((signed int)qe->qtype >= 1)
            tmp_if_expr$28 = (signed int)qe->qtype <= 51 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$28 = (_Bool)0;
          _Bool tmp_if_expr$30;
          if(tmp_if_expr$28)
          {
            return_value_have_rr$29=have_rr(cached, (signed int)qe->qtype);
            tmp_if_expr$30 = !(return_value_have_rr$29 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$30 = (_Bool)0;
          _Bool tmp_if_expr$43;
          if(tmp_if_expr$30)
            tmp_if_expr$43 = (_Bool)1;

          else
          {
            if((signed int)qe->qtype == 253)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr$31 = cached->$anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$31 = (_Bool)0;
              if(tmp_if_expr$31)
                tmp_if_expr$32 = cached->$anon0.rr.rrext[(signed long int)2] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$32 = (_Bool)0;
              if(tmp_if_expr$32)
                tmp_if_expr$33 = cached->$anon0.rr.rrext[(signed long int)2]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$33 = (_Bool)0;
              tmp_if_expr$34 = !tmp_if_expr$33 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$34 = (_Bool)0;
            if(tmp_if_expr$34)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr$35 = cached->$anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$35 = (_Bool)0;
              if(tmp_if_expr$35)
                tmp_if_expr$36 = cached->$anon0.rr.rrext[(signed long int)3] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$36 = (_Bool)0;
              if(tmp_if_expr$36)
                tmp_if_expr$37 = cached->$anon0.rr.rrext[(signed long int)3]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$37 = (_Bool)0;
              tmp_if_expr$38 = !tmp_if_expr$37 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$38 = (_Bool)0;
            if(tmp_if_expr$38)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr$39 = cached->$anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$39 = (_Bool)0;
              if(tmp_if_expr$39)
                tmp_if_expr$40 = cached->$anon0.rr.rrext[(signed long int)4] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$40 = (_Bool)0;
              if(tmp_if_expr$40)
                tmp_if_expr$41 = cached->$anon0.rr.rrext[(signed long int)4]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$41 = (_Bool)0;
              tmp_if_expr$42 = !tmp_if_expr$41 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$42 = (_Bool)0;
            tmp_if_expr$43 = tmp_if_expr$42 ? (_Bool)1 : (_Bool)0;
          }
          _Bool tmp_if_expr$52;
          if(tmp_if_expr$43)
            tmp_if_expr$52 = (_Bool)1;

          else
          {
            if((signed int)qe->qtype == 254)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr$44 = cached->$anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$44 = (_Bool)0;
              if(tmp_if_expr$44)
                tmp_if_expr$45 = cached->$anon0.rr.rrext[(signed long int)0] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$45 = (_Bool)0;
              if(tmp_if_expr$45)
                tmp_if_expr$46 = cached->$anon0.rr.rrext[(signed long int)0]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$46 = (_Bool)0;
              tmp_if_expr$47 = !tmp_if_expr$46 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$47 = (_Bool)0;
            if(tmp_if_expr$47)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr$48 = cached->$anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$48 = (_Bool)0;
              if(tmp_if_expr$48)
                tmp_if_expr$49 = cached->$anon0.rr.rrext[(signed long int)1] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$49 = (_Bool)0;
              if(tmp_if_expr$49)
                tmp_if_expr$50 = cached->$anon0.rr.rrext[(signed long int)1]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$50 = (_Bool)0;
              tmp_if_expr$51 = !tmp_if_expr$50 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$51 = (_Bool)0;
            tmp_if_expr$52 = tmp_if_expr$51 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$52)
            rretp = 6;

          compose_answer$$1$$3$$1$$1$$2$$rrset=getrrset(cached, rretp);
          if(!(compose_answer$$1$$3$$1$$1$$2$$rrset == ((struct anonymous *)NULL)))
          {
            if(!((1 & (signed int)compose_answer$$1$$3$$1$$1$$2$$rrset->flags) == 0))
              compose_answer$$1$$3$$1$$1$$2$$rrset = (struct anonymous *)(void *)0;

          }

          if(compose_answer$$1$$3$$1$$1$$2$$rrset == ((struct anonymous *)NULL))
          {
            struct anonymous$0 *prev = cached;
            unsigned int compose_answer$$1$$3$$1$$1$$2$$2$$scnt;
            compose_answer$$1$$3$$1$$1$$2$$2$$scnt=rhnsegcnt(prev->qname);
            unsigned int tcnt;
            signed int tmp_if_expr$53;
            if(rretp == 2)
              tmp_if_expr$53 = (signed int)prev->c_ns;

            else
              tmp_if_expr$53 = (signed int)prev->c_soa;
            tcnt = (unsigned int)tmp_if_expr$53;
            const unsigned char *tmp_if_expr$55;
            if(!(tcnt == 255u) && !(tcnt >= compose_answer$$1$$3$$1$$1$$2$$2$$scnt))
            {
              return_value_skipsegs$54=skipsegs(prev->qname, compose_answer$$1$$3$$1$$1$$2$$2$$scnt - tcnt);
              tmp_if_expr$55 = return_value_skipsegs$54;
            }

            else
              tmp_if_expr$55 = prev->qname;
            cached=lookup_cache(tmp_if_expr$55, (signed int *)(void *)0);
            if(!(cached == ((struct anonymous$0 *)NULL)))
            {
              compose_answer$$1$$3$$1$$1$$2$$rrset=getrrset(cached, rretp);
              if(!(compose_answer$$1$$3$$1$$1$$2$$rrset == ((struct anonymous *)NULL)))
              {
                if(!((1 & (signed int)compose_answer$$1$$3$$1$$1$$2$$rrset->flags) == 0))
                  compose_answer$$1$$3$$1$$1$$2$$rrset = (struct anonymous *)(void *)0;

              }

            }

            if(compose_answer$$1$$3$$1$$1$$2$$rrset == ((struct anonymous *)NULL))
            {
              if(!((2 & (signed int)prev->flags) == 0))
              {
                unsigned char *nm;
                nm=getlocalowner(prev->qname, rretp);
                if(!(nm == ((unsigned char *)NULL)))
                {
                  if(!(cached == ((struct anonymous$0 *)NULL)))
                  {
                    free_cent(cached);
                    free((void *)cached);
                  }

                  cached=lookup_cache(nm, (signed int *)(void *)0);
                  if(!(cached == ((struct anonymous$0 *)NULL)))
                    compose_answer$$1$$3$$1$$1$$2$$rrset=getrrset(cached, rretp);

                }

              }

            }

            free_cent(prev);
            free((void *)prev);
          }

          if(!(compose_answer$$1$$3$$1$$1$$2$$rrset == ((struct anonymous *)NULL)))
          {
            struct rr_b_s *compose_answer$$1$$3$$1$$1$$2$$3$$rr = compose_answer$$1$$3$$1$$1$$2$$rrset->rrs;
            for( ; !(compose_answer$$1$$3$$1$$1$$2$$3$$rr == ((struct rr_b_s *)NULL)); compose_answer$$1$$3$$1$$1$$2$$3$$rr = compose_answer$$1$$3$$1$$1$$2$$3$$rr->next)
            {
              signed long int return_value_ans_ttl$56;
              return_value_ans_ttl$56=ans_ttl(compose_answer$$1$$3$$1$$1$$2$$rrset, queryts);
              signed int return_value_add_ar$57;
              return_value_add_ar$57=add_ar(&ar, (unsigned short int)rretp, (unsigned short int)compose_answer$$1$$3$$1$$1$$2$$3$$rr->rdlen, (void *)compose_answer$$1$$3$$1$$1$$2$$3$$rr->data, cached->qname, (unsigned int)return_value_ans_ttl$56);
              if(return_value_add_ar$57 == 0)
                goto error_cached;

            }
          }

          hops = 0;
        }

        if(!(cached == ((struct anonymous$0 *)NULL)))
        {
          free_cent(cached);
          free((void *)cached);
        }

        hops = hops - 1;
      }
      while(hops >= 0);
      return_value_llist_next$21=llist_next((void *)qe);
    }
    struct rre_s *rre;
    void *return_value_dlist_first$66;
    return_value_dlist_first$66=dlist_first$link1(ar);
    rre = (struct rre_s *)return_value_dlist_first$66;
    for( ; !(rre == ((struct rre_s *)NULL)); rre = (struct rre_s *)return_value_dlist_next$67)
    {
      _Bool tmp_if_expr$69;
      if((signed int)rre->tp == 2)
        tmp_if_expr$69 = (_Bool)1;

      else
        tmp_if_expr$69 = (signed int)rre->tp == 6 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$69)
      {
        unsigned char *compose_answer$$1$$4$$1$$1$$1$$nm = rre->tnm + (signed long int)rre->tsz;
        signed int return_value_add_additional_rr$68;
        return_value_add_additional_rr$68=add_additional_rr(&ans, rlen, &allocsz, compose_answer$$1$$4$$1$$1$$1$$nm, (unsigned int)rre->tp, (signed long int)rre->ttl, (unsigned int)rre->tsz, (void *)rre->tnm, 2, udp, &cb, &sva);
        if(return_value_add_additional_rr$68 == 0)
          goto error_ans;

      }

      return_value_dlist_next$67=dlist_next$link1((void *)rre);
    }
    _Bool tmp_if_expr$75;
    if(!(udp == ((unsigned int *)NULL)))
      tmp_if_expr$75 = *rlen + (unsigned long int)(1 + 10) > (unsigned long int)*udp ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$75 = (_Bool)0;
    if(!tmp_if_expr$75)
    {
      if(!(ednsinfo == ((struct anonymous$17 *)NULL)))
      {
        signed int return_value_add_opt_pseudo_rr$70;
        return_value_add_opt_pseudo_rr$70=add_opt_pseudo_rr(&ans, rlen, &allocsz, (unsigned short int)global.udpbufsize, rcode, (unsigned short int)0, (unsigned short int)0);
        if(return_value_add_opt_pseudo_rr$70 == 0)
          goto error_ans;

      }

      void *return_value_dlist_first$71;
      return_value_dlist_first$71=dlist_first$link1(ar);
      rre = (struct rre_s *)return_value_dlist_first$71;
      for( ; !(rre == ((struct rre_s *)NULL)); rre = (struct rre_s *)return_value_dlist_next$72)
      {
        _Bool tmp_if_expr$74;
        if((signed int)rre->tp == 2)
          tmp_if_expr$74 = (_Bool)1;

        else
          tmp_if_expr$74 = (signed int)rre->tp == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$74)
        {
          signed int return_value_add_additional_a$73;
          return_value_add_additional_a$73=add_additional_a(&ans, rlen, &allocsz, rre->tnm, queryts, udp, &cb, &sva);
          if(return_value_add_additional_a$73 == 0)
            goto error_ans;

        }

        return_value_dlist_next$72=dlist_next$link1((void *)rre);
      }
    }

    if(!(aa == 0))
      ans->hdr.aa = (unsigned int)1;

    goto cleanup_return;

  error_cached:
    ;
    free_cent(cached);
    free((void *)cached);

  error_ans:
    ;
    free((void *)ans);
    ans = (struct anonymous$28 *)(void *)0;

  cleanup_return:
    ;
    free((void *)ar);
    free((void *)sva);
    free((void *)cb);
  }


return_ans:
  ;
  if(!(rcodep == ((signed int *)NULL)))
    *rcodep = (signed int)rcode;

  return ans;
}

// compress_name
// file dns.c line 248
unsigned int compress_name(unsigned char *in, unsigned char *out, unsigned int offs, struct _dynamic_list_head **cb)
{
  struct anonymous$64 *ci;
  unsigned int longest = (unsigned int)0;
  unsigned int lrem = (unsigned int)0;
  unsigned int coffs = (unsigned int)0;
  unsigned int rl = (unsigned int)0;
  unsigned int ilen;
  ilen=rhnlen$link1(in);
  unsigned short int add = (unsigned short int)1;
  if(ilen >= 257u)
  {
    log_message(3, "%s:%d: %s", (const void *)"dns.c", 256, (const void *)"compress_name: name too long");
    pdnsd_exit();
  }

  void *return_value_dlist_first$1;
  return_value_dlist_first$1=dlist_first(*cb);
  ci = (struct anonymous$64 *)return_value_dlist_first$1;
  void *return_value_dlist_next$2;
  for( ; !(ci == ((struct anonymous$64 *)NULL)); ci = (struct anonymous$64 *)return_value_dlist_next$2)
  {
    unsigned int rv;
    unsigned int rem;
    unsigned int to;
    rv=domain_match(in, ci->s, &rem, &to);
    if(!(longest >= rv))
    {
      unsigned int newoffs = ci->index + to;
      if(!(newoffs >= 16384u))
      {
        longest = rv;
        lrem = rem;
        coffs = newoffs;
      }

    }

    return_value_dlist_next$2=dlist_next((void *)ci);
  }
  if(longest >= 1u)
  {
    if(!(ilen >= 2u + lrem))
    {
      log_message(3, "%s:%d: %s", (const void *)"dns.c", 279, (const void *)"compress_name: length increased");
      pdnsd_exit();
    }

    memcpy((void *)out, (const void *)in, (unsigned long int)lrem);
    out[(signed long int)lrem] = (unsigned char)((unsigned int)0xc0 | (coffs & (unsigned int)0x3f00) >> 8);
    out[(signed long int)(lrem + (unsigned int)1)] = (unsigned char)(coffs & (unsigned int)0xff);
    rl = lrem + (unsigned int)2;
    add = (unsigned short int)(lrem != (unsigned int)0);
  }

  else
  {
    memcpy((void *)out, (const void *)in, (unsigned long int)ilen);
    rl = ilen;
  }
  if(!(add == 0))
  {
    *cb=dlist_grow(*cb, sizeof(struct anonymous$64) /*4ul*/  + (unsigned long int)ilen);
    if(*cb == ((struct _dynamic_list_head *)NULL))
      return (unsigned int)0;

    void *return_value_dlist_last$3;
    return_value_dlist_last$3=dlist_last(*cb);
    ci = (struct anonymous$64 *)return_value_dlist_last$3;
    ci->index = offs;
    memcpy((void *)ci->s, (const void *)in, (unsigned long int)ilen);
  }

  return rl;
}

// confparse
// file conf-parser.c line 488
signed int confparse(struct _IO_FILE *in, char *prestr, struct anonymous$21 *global, struct anonymous$18 **servers, signed int includedepth, char **errstr)
{
  char *linebuf = (char *)(void *)0;
  char *p;
  char *ps;
  char *getnextperr = (char *)(void *)0;
  char *scanstrerr = (char *)(void *)0;
  const char *conftype;
  unsigned long int buflen = (unsigned long int)256;
  unsigned int linenr = (unsigned int)0;
  signed int retval = 0;
  signed int sechdr;
  signed int option;
  signed int len;
  char strbuf[1024l];
  *errstr = (char *)(void *)0;
  if(!(in == ((struct _IO_FILE *)NULL)))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(buflen);
    linebuf = (char *)return_value_malloc$1;
    if(linebuf == ((char *)NULL))
      return 0;

    if(!(global == ((struct anonymous$21 *)NULL)))
      conftype = "config file";

    else
      conftype = "include file";
  }

  else
    conftype = "config string";
  p = prestr;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$5;
  _Bool tmp_if_expr$8;
  const unsigned short int **return_value___ctype_b_loc$6;
  _Bool tmp_if_expr$7;
  union anonymous$6 *ipaddrp;
  _Bool tmp_if_expr$11;
  const unsigned short int **return_value___ctype_b_loc$9;
  _Bool tmp_if_expr$10;
  const unsigned short int **return_value___ctype_b_loc$12;
  signed int return_value_ioctl$18;
  _Bool tmp_if_expr$23;
  const unsigned short int **return_value___ctype_b_loc$21;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$29;
  const unsigned short int **return_value___ctype_b_loc$27;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$33;
  const unsigned short int **return_value___ctype_b_loc$31;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$37;
  const unsigned short int **return_value___ctype_b_loc$35;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$41;
  const unsigned short int **return_value___ctype_b_loc$39;
  _Bool tmp_if_expr$40;
  _Bool tmp_if_expr$45;
  const unsigned short int **return_value___ctype_b_loc$43;
  _Bool tmp_if_expr$44;
  _Bool tmp_if_expr$49;
  const unsigned short int **return_value___ctype_b_loc$47;
  _Bool tmp_if_expr$48;
  _Bool tmp_if_expr$53;
  const unsigned short int **return_value___ctype_b_loc$51;
  _Bool tmp_if_expr$52;
  _Bool tmp_if_expr$59;
  const unsigned short int **return_value___ctype_b_loc$57;
  _Bool tmp_if_expr$58;
  _Bool tmp_if_expr$63;
  const unsigned short int **return_value___ctype_b_loc$61;
  _Bool tmp_if_expr$62;
  _Bool tmp_if_expr$68;
  const unsigned short int **return_value___ctype_b_loc$66;
  _Bool tmp_if_expr$67;
  _Bool tmp_if_expr$82;
  const unsigned short int **return_value___ctype_b_loc$80;
  _Bool tmp_if_expr$81;
  _Bool tmp_if_expr$87;
  const unsigned short int **return_value___ctype_b_loc$85;
  _Bool tmp_if_expr$86;
  _Bool tmp_if_expr$91;
  const unsigned short int **return_value___ctype_b_loc$89;
  _Bool tmp_if_expr$90;
  _Bool tmp_if_expr$95;
  const unsigned short int **return_value___ctype_b_loc$93;
  _Bool tmp_if_expr$94;
  const unsigned short int **return_value___ctype_b_loc$97;
  const unsigned short int **return_value___ctype_b_loc$103;
  _Bool tmp_if_expr$106;
  const unsigned short int **return_value___ctype_b_loc$104;
  _Bool tmp_if_expr$105;
  _Bool tmp_if_expr$112;
  const unsigned short int **return_value___ctype_b_loc$110;
  _Bool tmp_if_expr$111;
  const unsigned short int **return_value___ctype_b_loc$119;
  _Bool tmp_if_expr$118;
  const unsigned short int **return_value___ctype_b_loc$116;
  _Bool tmp_if_expr$117;
  const unsigned short int **return_value___ctype_b_loc$125;
  _Bool tmp_if_expr$123;
  const unsigned short int **return_value___ctype_b_loc$121;
  _Bool tmp_if_expr$122;
  const unsigned short int **return_value___ctype_b_loc$124;
  _Bool tmp_if_expr$128;
  const unsigned short int **return_value___ctype_b_loc$126;
  _Bool tmp_if_expr$127;
  _Bool tmp_if_expr$132;
  const unsigned short int **return_value___ctype_b_loc$130;
  _Bool tmp_if_expr$131;
  _Bool tmp_if_expr$136;
  const unsigned short int **return_value___ctype_b_loc$134;
  _Bool tmp_if_expr$135;
  _Bool tmp_if_expr$140;
  const unsigned short int **return_value___ctype_b_loc$138;
  _Bool tmp_if_expr$139;
  _Bool tmp_if_expr$144;
  const unsigned short int **return_value___ctype_b_loc$142;
  _Bool tmp_if_expr$143;
  _Bool tmp_if_expr$148;
  const unsigned short int **return_value___ctype_b_loc$146;
  _Bool tmp_if_expr$147;
  _Bool tmp_if_expr$152;
  const unsigned short int **return_value___ctype_b_loc$150;
  _Bool tmp_if_expr$151;
  _Bool tmp_if_expr$156;
  const unsigned short int **return_value___ctype_b_loc$154;
  _Bool tmp_if_expr$155;
  _Bool tmp_if_expr$160;
  const unsigned short int **return_value___ctype_b_loc$158;
  _Bool tmp_if_expr$159;
  _Bool tmp_if_expr$164;
  const unsigned short int **return_value___ctype_b_loc$162;
  _Bool tmp_if_expr$163;
  _Bool tmp_if_expr$168;
  const unsigned short int **return_value___ctype_b_loc$166;
  _Bool tmp_if_expr$167;
  const char *return_value_const_name$170;
  struct anonymous$0 confparse$$1$$2$$1$$5$$5$$c_cent;
  signed long int confparse$$1$$2$$1$$5$$5$$c_ttl;
  unsigned int c_flags;
  unsigned char reverse;
  const unsigned short int **return_value___ctype_b_loc$175;
  _Bool tmp_if_expr$178;
  const unsigned short int **return_value___ctype_b_loc$176;
  _Bool tmp_if_expr$177;
  signed int tp;
  const char *tpname;
  _Bool tmp_if_expr$183;
  const unsigned short int **return_value___ctype_b_loc$181;
  _Bool tmp_if_expr$182;
  _Bool tmp_if_expr$187;
  const unsigned short int **return_value___ctype_b_loc$185;
  _Bool tmp_if_expr$186;
  signed int return_value_inet_pton$189;
  const unsigned short int **return_value___ctype_b_loc$234;
  _Bool tmp_if_expr$237;
  const unsigned short int **return_value___ctype_b_loc$235;
  _Bool tmp_if_expr$236;
  _Bool tmp_if_expr$242;
  const unsigned short int **return_value___ctype_b_loc$240;
  _Bool tmp_if_expr$241;
  _Bool tmp_if_expr$246;
  const unsigned short int **return_value___ctype_b_loc$244;
  _Bool tmp_if_expr$245;
  const unsigned short int **return_value___ctype_b_loc$248;
  _Bool tmp_if_expr$251;
  const unsigned short int **return_value___ctype_b_loc$249;
  _Bool tmp_if_expr$250;
  const unsigned short int **return_value___ctype_b_loc$255;
  _Bool tmp_if_expr$258;
  const unsigned short int **return_value___ctype_b_loc$256;
  _Bool tmp_if_expr$257;
  const unsigned short int **return_value___ctype_b_loc$272;
  _Bool tmp_if_expr$262;
  const unsigned short int **return_value___ctype_b_loc$260;
  _Bool tmp_if_expr$261;
  signed int return_value_add_cent_rrset_by_type$266;
  _Bool tmp_if_expr$271;
  const unsigned short int **return_value___ctype_b_loc$269;
  _Bool tmp_if_expr$270;
  do
  {
    p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
    if(p == ((char *)NULL))
      break;

    const unsigned short int **return_value___ctype_b_loc$273;
    return_value___ctype_b_loc$273=__ctype_b_loc();
    if(!((1024 & (signed int)(*return_value___ctype_b_loc$273)[(signed long int)(signed int)*p]) == 0))
    {
      ps = p;
      do
      {
        p = p + 1l;
        if(!(*p == 0))
        {
          return_value___ctype_b_loc$2=__ctype_b_loc();
          if(!((8 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0))
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
      }
      while(tmp_if_expr$4);
      len = (signed int)(p - ps);
      sechdr=binsearch_keyword(ps, len, section_headers, (signed int)(sizeof(const struct anonymous$32 [6l]) /*96ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
      if(sechdr == 0)
      {
        *errstr=report_errorf(conftype, linenr, "invalid section header: %.*s", (signed int)len, ps);
        goto free_linebuf_return;
      }

      p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
      if(p == ((char *)NULL))
        goto unexpected_eof;

      if(!((signed int)*p == 123))
        goto expected_bropen;

      p = p + 1l;
      p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
      if(p == ((char *)NULL))
        goto unexpected_eof;

      switch(sechdr)
      {
        case 1:
        {
          if(global == ((struct anonymous$21 *)NULL))
          {
            *errstr=report_error(conftype, linenr, in != ((struct _IO_FILE *)NULL) ? "global section not allowed in include file" : "global section not allowed in eval string");
            goto free_linebuf_return;
          }

          do
          {
            return_value___ctype_b_loc$5=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc$6=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr$7 = (_Bool)1;

                else
                  tmp_if_expr$7 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$8 = (_Bool)0;
            }
            while(tmp_if_expr$8);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, global_options, (signed int)(sizeof(const struct anonymous$32 [39l]) /*624ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for global section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!(option == 7))
            {
              if(option == 8)
                goto __CPROVER_DUMP_L37;

              if(option == 9)
                goto __CPROVER_DUMP_L42;

              if(option == 11)
                goto __CPROVER_DUMP_L45;

              if(option == 10)
                goto __CPROVER_DUMP_L46;

              if(option == 12)
                goto __CPROVER_DUMP_L60;

              if(option == 13)
                goto __CPROVER_DUMP_L65;

              if(option == 14)
                goto __CPROVER_DUMP_L75;

              if(option == 15)
                goto __CPROVER_DUMP_L79;

              if(option == 16)
                goto __CPROVER_DUMP_L83;

              if(option == 17)
                goto __CPROVER_DUMP_L88;

              if(option == 18)
                goto __CPROVER_DUMP_L98;

              if(option == 19)
                goto __CPROVER_DUMP_L108;

              if(option == 20)
                goto __CPROVER_DUMP_L118;

              if(option == 21)
                goto __CPROVER_DUMP_L128;

              if(option == 22)
                goto __CPROVER_DUMP_L137;

              if(option == 23)
                goto __CPROVER_DUMP_L146;

              if(option == 24)
                goto __CPROVER_DUMP_L155;

              if(option == 25)
                goto __CPROVER_DUMP_L160;

              if(option == 26)
                goto __CPROVER_DUMP_L164;

              if(option == 27)
                goto __CPROVER_DUMP_L173;

              if(option == 28)
                goto __CPROVER_DUMP_L183;

              if(option == 29)
                goto __CPROVER_DUMP_L188;

              if(option == 30)
                goto __CPROVER_DUMP_L197;

              if(option == 31)
                goto __CPROVER_DUMP_L200;

              if(option == 32)
                goto __CPROVER_DUMP_L203;

              if(option == 33)
                goto __CPROVER_DUMP_L206;

              if(option == 47)
                goto __CPROVER_DUMP_L210;

              if(option == 34)
                goto __CPROVER_DUMP_L214;

              if(option == 35)
                goto __CPROVER_DUMP_L219;

              if(option == 36)
                goto __CPROVER_DUMP_L229;

              if(option == 37)
                goto __CPROVER_DUMP_L233;

              if(option == 38)
                goto __CPROVER_DUMP_L241;

              if(option == 39)
                goto __CPROVER_DUMP_L249;

              if(option == 40)
                goto __CPROVER_DUMP_L263;

              if(option == 41)
                goto __CPROVER_DUMP_L267;

              if(option == 42)
                goto __CPROVER_DUMP_L271;

              goto __CPROVER_DUMP_L279;
            }

            const unsigned short int **return_value___ctype_b_loc$13;
            return_value___ctype_b_loc$13=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)*p]) == 0))
            {
              signed int confparse$$1$$2$$1$$5$$2$$5$$1$$cnst;
              ps = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$9=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$10 = (_Bool)1;

                  else
                    tmp_if_expr$10 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$11 = (_Bool)0;
              }
              while(tmp_if_expr$11);
              len = (signed int)(p - ps);
              confparse$$1$$2$$1$$5$$2$$5$$1$$cnst=lookup_const(ps, len);
              if(confparse$$1$$2$$1$$5$$2$$5$$1$$cnst == 2)
                global->perm_cache = (signed long int)0;

              else
                goto bad_perm_cache_option;
            }

            else
            {
              return_value___ctype_b_loc$12=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$12)[(signed long int)(signed int)*p]) == 0))
                global->perm_cache=strtol(p, &p, 0);

              else
              {

              bad_perm_cache_option:
                ;
                *errstr=report_error(conftype, linenr, "bad qualifier in perm_cache= option.");
                goto free_linebuf_return;
              }
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L37:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(!(global->cache_dir == ((char *)NULL)))
              free((void *)global->cache_dir);

            global->cache_dir=strndup(strbuf, (unsigned long int)len);
            if(global->cache_dir == ((char *)NULL))
              goto out_of_memory;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L42:
            ;
            const unsigned short int **return_value___ctype_b_loc$15;
            return_value___ctype_b_loc$15=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$15)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$14;
              return_value_strtol$14=strtol(p, &p, 0);
              global->port = (signed int)return_value_strtol$14;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for server_port option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L45:
            ;
            ipaddrp = &global->out_a;
            goto scan_ip_or_interface;

          __CPROVER_DUMP_L46:
            ;
            ipaddrp = &global->a;

          scan_ip_or_interface:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            const char *confparse$$1$$2$$1$$5$$2$$5$$8$$err;
            confparse$$1$$2$$1$$5$$2$$5$$8$$err=parse_ip(strbuf, ipaddrp);
            if(!(confparse$$1$$2$$1$$5$$2$$5$$8$$err == ((const char *)NULL)))
            {
              signed int return_value_strcmp$20;
              return_value_strcmp$20=strcmp(confparse$$1$$2$$1$$5$$2$$5$$8$$err, "bad IP address");
              if(return_value_strcmp$20 == 0 && !(len >= 16))
              {
                signed int fd;
                struct ifreq req;
                memcpy((void *)req.ifr_ifrn.ifrn_name, (const void *)strbuf, (unsigned long int)len);
                req.ifr_ifrn.ifrn_name[(signed long int)len] = (char)0;
                req.ifr_ifru.ifru_addr.sa_family = (unsigned short int)(run_ipv4 != 0 ? 2 : 10);
                fd=socket(run_ipv4 != 0 ? 2 : 10, 2, 0);
                _Bool tmp_if_expr$19;
                if(!(fd == -1))
                {
                  return_value_ioctl$18=ioctl(fd, (unsigned long int)0x8915, &req);
                  tmp_if_expr$19 = return_value_ioctl$18 != -1 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$19 = (_Bool)0;
                if(tmp_if_expr$19)
                {
                  if(!(run_ipv4 == 0))
                    ipaddrp->ipv4 = ((struct sockaddr_in *)&req.ifr_ifru.ifru_addr)->sin_addr;

                  else
                    ipaddrp->ipv6 = ((struct sockaddr_in6 *)&req.ifr_ifru.ifru_addr)->sin6_addr;
                  close(fd);
                }

                else
                {
                  signed int *return_value___errno_location$16;
                  return_value___errno_location$16=__errno_location();
                  char *return_value_strerror$17;
                  return_value_strerror$17=strerror(*return_value___errno_location$16);
                  *errstr=report_errorf(conftype, linenr, "Failed to get IP address of %s: %s", (const void *)req.ifr_ifrn.ifrn_name, return_value_strerror$17);
                  if(!(fd == -1))
                    close(fd);

                  goto free_linebuf_return;
                }
              }

              else
              {
                *errstr=report_errorf(conftype, linenr, "%s for the %s= option.", confparse$$1$$2$$1$$5$$2$$5$$8$$err, option == 10 ? "server_ip" : "outgoing_ip");
                goto free_linebuf_return;
              }
            }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L60:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(!(global->scheme_file == ((char *)NULL)))
              free((void *)global->scheme_file);

            global->scheme_file=strndup(strbuf, (unsigned long int)len);
            if(global->scheme_file == ((char *)NULL))
              goto out_of_memory;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L65:
            ;
            const unsigned short int **return_value___ctype_b_loc$24;
            return_value___ctype_b_loc$24=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$24)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_len;
              signed int confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_cnst;
              confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$21=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$21)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$22 = (_Bool)1;

                  else
                    tmp_if_expr$22 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$23 = tmp_if_expr$22 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$23 = (_Bool)0;
              }
              while(tmp_if_expr$23);
              confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_len);
              if(confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_cnst == 2)
                global->lndown_kluge = (char)(confparse$$1$$2$$1$$5$$2$$5$$11$$1$$_cnst == 1);

              else
                goto ASSIGN_ON_OFF_656;
            }

            else
            {

            ASSIGN_ON_OFF_656:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in linkdown_kluge= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L75:
            ;
            const unsigned short int **return_value___ctype_b_loc$25;
            return_value___ctype_b_loc$25=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$25)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$12$$1$$_err;
              global->max_ttl=strtotime(p, &p, &confparse$$1$$2$$1$$5$$2$$5$$12$$1$$_err);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$12$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"max_ttl option", confparse$$1$$2$$1$$5$$2$$5$$12$$1$$_err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for max_ttl option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L79:
            ;
            const unsigned short int **return_value___ctype_b_loc$26;
            return_value___ctype_b_loc$26=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$26)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$13$$1$$_err;
              global->min_ttl=strtotime(p, &p, &confparse$$1$$2$$1$$5$$2$$5$$13$$1$$_err);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$13$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"min_ttl option", confparse$$1$$2$$1$$5$$2$$5$$13$$1$$_err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for min_ttl option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L83:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(!((unsigned long int)len >= sizeof(char [21l]) /*21ul*/ ))
            {
              memcpy((void *)global->run_as, (const void *)strbuf, (unsigned long int)len);
              global->run_as[(signed long int)len] = (char)0;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "run_as: string too long");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L88:
            ;
            const unsigned short int **return_value___ctype_b_loc$30;
            return_value___ctype_b_loc$30=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$30)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_len;
              signed int confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_cnst;
              confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$27=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$27)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$28 = (_Bool)1;

                  else
                    tmp_if_expr$28 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$29 = tmp_if_expr$28 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$29 = (_Bool)0;
              }
              while(tmp_if_expr$29);
              confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_len);
              if(confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_cnst == 2)
                global->strict_suid = (char)(confparse$$1$$2$$1$$5$$2$$5$$16$$1$$_cnst == 1);

              else
                goto ASSIGN_ON_OFF_673;
            }

            else
            {

            ASSIGN_ON_OFF_673:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in strict_setuid= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L98:
            ;
            const unsigned short int **return_value___ctype_b_loc$34;
            return_value___ctype_b_loc$34=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$34)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_len;
              signed int confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_cnst;
              confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$31=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$31)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$32 = (_Bool)1;

                  else
                    tmp_if_expr$32 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$33 = tmp_if_expr$32 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$33 = (_Bool)0;
              }
              while(tmp_if_expr$33);
              confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_len);
              if(confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_cnst == 2)
                global->use_nss = (char)(confparse$$1$$2$$1$$5$$2$$5$$17$$1$$_cnst == 1);

              else
                goto ASSIGN_ON_OFF_677;
            }

            else
            {

            ASSIGN_ON_OFF_677:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in use_nss= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L108:
            ;
            const unsigned short int **return_value___ctype_b_loc$38;
            return_value___ctype_b_loc$38=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$38)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_len;
              signed int confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_cnst;
              confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$35=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$35)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$36 = (_Bool)1;

                  else
                    tmp_if_expr$36 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$37 = tmp_if_expr$36 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$37 = (_Bool)0;
              }
              while(tmp_if_expr$37);
              confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_len);
              if(confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_cnst == 2)
                global->paranoid = (char)(confparse$$1$$2$$1$$5$$2$$5$$18$$1$$_cnst == 1);

              else
                goto ASSIGN_ON_OFF_681;
            }

            else
            {

            ASSIGN_ON_OFF_681:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in paranoid= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L118:
            ;
            signed int ignore_cd;
            const unsigned short int **return_value___ctype_b_loc$42;
            return_value___ctype_b_loc$42=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$42)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_len;
              signed int confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_cnst;
              confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$39=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$39)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$40 = (_Bool)1;

                  else
                    tmp_if_expr$40 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$41 = tmp_if_expr$40 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$41 = (_Bool)0;
              }
              while(tmp_if_expr$41);
              confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_len);
              if(confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_cnst == 2)
                ignore_cd = (signed int)(confparse$$1$$2$$1$$5$$2$$5$$19$$1$$1$$_cnst == 1);

              else
                goto ASSIGN_ON_OFF_686;
            }

            else
            {

            ASSIGN_ON_OFF_686:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in ignore_cd= option.");
              goto free_linebuf_return;
            }
            fprintf(stderr, "Warning: ignore_cd option in configuration file is obsolete and currently has no effect.\n");
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L128:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$20$$cnst;
            const unsigned short int **return_value___ctype_b_loc$46;
            return_value___ctype_b_loc$46=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$46)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$20$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$20$$1$$1$$_len;
              confparse$$1$$2$$1$$5$$2$$5$$20$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$43=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$43)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$44 = (_Bool)1;

                  else
                    tmp_if_expr$44 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$45 = tmp_if_expr$44 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$45 = (_Bool)0;
              }
              while(tmp_if_expr$45);
              confparse$$1$$2$$1$$5$$2$$5$$20$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$20$$1$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$20$$cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$20$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$20$$1$$1$$_len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$20$$cnst == 1) && !(confparse$$1$$2$$1$$5$$2$$5$$20$$cnst == 2))
                goto ASSIGN_CONST_693;

            }

            else
            {

            ASSIGN_CONST_693:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in status_pipe= option.");
              goto free_linebuf_return;
            }
            if(cmdline.stat_pipe == 0)
              global->stat_pipe = (char)(confparse$$1$$2$$1$$5$$2$$5$$20$$cnst == 1);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L137:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$21$$cnst;
            const unsigned short int **return_value___ctype_b_loc$50;
            return_value___ctype_b_loc$50=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$50)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$21$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$21$$1$$1$$_len;
              confparse$$1$$2$$1$$5$$2$$5$$21$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$47=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$47)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$48 = (_Bool)1;

                  else
                    tmp_if_expr$48 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$49 = tmp_if_expr$48 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$49 = (_Bool)0;
              }
              while(tmp_if_expr$49);
              confparse$$1$$2$$1$$5$$2$$5$$21$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$21$$1$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$21$$cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$21$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$21$$1$$1$$_len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$21$$cnst == 1) && !(confparse$$1$$2$$1$$5$$2$$5$$21$$cnst == 2))
                goto ASSIGN_CONST_700;

            }

            else
            {

            ASSIGN_CONST_700:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in daemon= option.");
              goto free_linebuf_return;
            }
            if(cmdline.daemon == 0)
              global->daemon = (char)(confparse$$1$$2$$1$$5$$2$$5$$21$$cnst == 1);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L146:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$22$$cnst;
            const unsigned short int **return_value___ctype_b_loc$54;
            return_value___ctype_b_loc$54=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$54)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$22$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$22$$1$$1$$_len;
              confparse$$1$$2$$1$$5$$2$$5$$22$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$51=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$51)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$52 = (_Bool)1;

                  else
                    tmp_if_expr$52 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$53 = tmp_if_expr$52 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$53 = (_Bool)0;
              }
              while(tmp_if_expr$53);
              confparse$$1$$2$$1$$5$$2$$5$$22$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$22$$1$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$22$$cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$22$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$22$$1$$1$$_len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$22$$cnst == 1) && !(confparse$$1$$2$$1$$5$$2$$5$$22$$cnst == 2))
                goto ASSIGN_CONST_707;

            }

            else
            {

            ASSIGN_CONST_707:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in tcp_server= option.");
              goto free_linebuf_return;
            }
            if(cmdline.notcp == 0)
              global->notcp = (char)(confparse$$1$$2$$1$$5$$2$$5$$22$$cnst == 2);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L155:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(cmdline.pidfile == 0)
            {
              if(!(global->pidfile == ((char *)NULL)))
                free((void *)global->pidfile);

              global->pidfile=strndup(strbuf, (unsigned long int)len);
              if(global->pidfile == ((char *)NULL))
                goto out_of_memory;

            }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L160:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$25$$val;
            const unsigned short int **return_value___ctype_b_loc$56;
            return_value___ctype_b_loc$56=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$56)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$55;
              return_value_strtol$55=strtol(p, &p, 0);
              confparse$$1$$2$$1$$5$$2$$5$$25$$val = (signed int)return_value_strtol$55;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for verbosity option");
              goto free_linebuf_return;
            }
            if(cmdline.verbosity == 0)
              global->verbosity = (signed short int)confparse$$1$$2$$1$$5$$2$$5$$25$$val;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L164:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$26$$cnst;
            const unsigned short int **return_value___ctype_b_loc$60;
            return_value___ctype_b_loc$60=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$60)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$26$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$26$$1$$1$$_len;
              confparse$$1$$2$$1$$5$$2$$5$$26$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$57=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$57)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$58 = (_Bool)1;

                  else
                    tmp_if_expr$58 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$59 = tmp_if_expr$58 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$59 = (_Bool)0;
              }
              while(tmp_if_expr$59);
              confparse$$1$$2$$1$$5$$2$$5$$26$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$26$$1$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$26$$cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$26$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$26$$1$$1$$_len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$26$$cnst == 12) && !(confparse$$1$$2$$1$$5$$2$$5$$26$$cnst == 13) && !(confparse$$1$$2$$1$$5$$2$$5$$26$$cnst == 14) && !(confparse$$1$$2$$1$$5$$2$$5$$26$$cnst == 15))
                goto ASSIGN_CONST_734;

            }

            else
            {

            ASSIGN_CONST_734:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in query_method= option.");
              goto free_linebuf_return;
            }
            if(cmdline.query_method == 0)
              global->query_method = confparse$$1$$2$$1$$5$$2$$5$$26$$cnst;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L173:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$27$$cnst;
            const unsigned short int **return_value___ctype_b_loc$64;
            return_value___ctype_b_loc$64=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$64)[(signed long int)(signed int)*p]) == 0))
            {
              char *_str;
              unsigned long int _len;
              _str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$61=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$61)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$62 = (_Bool)1;

                  else
                    tmp_if_expr$62 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$63 = tmp_if_expr$62 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$63 = (_Bool)0;
              }
              while(tmp_if_expr$63);
              _len = (unsigned long int)(p - _str);
              confparse$$1$$2$$1$$5$$2$$5$$27$$cnst=lookup_const(_str, (signed int)_len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$27$$cnst == 1) && !(confparse$$1$$2$$1$$5$$2$$5$$27$$cnst == 2))
                goto ASSIGN_CONST_766;

            }

            else
            {

            ASSIGN_CONST_766:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in run_ipv4= option.");
              goto free_linebuf_return;
            }
            if(cmdlineipv == 0)
            {
              run_ipv4 = (signed short int)(confparse$$1$$2$$1$$5$$2$$5$$27$$cnst == 1);
              cmdlineipv = (signed short int)-1;
            }

            else
              if(!((signed int)run_ipv4 == (signed int)(confparse$$1$$2$$1$$5$$2$$5$$27$$cnst == 1)) && !((signed int)cmdlineipv >= 0))
              {
                *errstr=report_error(conftype, linenr, (signed int)cmdlineipv == -1 ? "IPv4/IPv6 conflict: you are trying to set run_ipv4 to a value that conflicts with a previous run_ipv4 setting." : "You must set the run_ipv4 option before specifying IP addresses.");
                goto free_linebuf_return;
              }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L183:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(cmdline.prefix == 0)
            {
              signed int return_value_inet_pton$65;
              return_value_inet_pton$65=inet_pton(10, strbuf, (void *)&global->ipv4_6_prefix);
              if(!(return_value_inet_pton$65 >= 1))
              {
                *errstr=report_error(conftype, linenr, "ipv4_6_prefix: argument not a valid IPv6 address.");
                goto free_linebuf_return;
              }

            }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L188:
            ;
            signed int cnst;
            const unsigned short int **return_value___ctype_b_loc$69;
            return_value___ctype_b_loc$69=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$69)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$30$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$30$$1$$1$$_len;
              confparse$$1$$2$$1$$5$$2$$5$$30$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$66=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$66)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$67 = (_Bool)1;

                  else
                    tmp_if_expr$67 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$68 = tmp_if_expr$67 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$68 = (_Bool)0;
              }
              while(tmp_if_expr$68);
              confparse$$1$$2$$1$$5$$2$$5$$30$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$30$$1$$1$$_str);
              cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$30$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$30$$1$$1$$_len);
              if(!(cnst == 1) && !(cnst == 2))
                goto ASSIGN_CONST_809;

            }

            else
            {

            ASSIGN_CONST_809:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in debug= option.");
              goto free_linebuf_return;
            }
            if(cmdline.debug == 0)
              global->debug = (char)(cnst == 1);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L197:
            ;
            const unsigned short int **return_value___ctype_b_loc$71;
            return_value___ctype_b_loc$71=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$71)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$70;
              return_value_strtol$70=strtol(p, &p, 0);
              global->ctl_perms = (signed int)return_value_strtol$70;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for ctl_perms option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L200:
            ;
            const unsigned short int **return_value___ctype_b_loc$73;
            return_value___ctype_b_loc$73=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$73)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$72;
              return_value_strtol$72=strtol(p, &p, 0);
              global->proc_limit = (signed int)return_value_strtol$72;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for proc_limit option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L203:
            ;
            const unsigned short int **return_value___ctype_b_loc$75;
            return_value___ctype_b_loc$75=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$75)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$74;
              return_value_strtol$74=strtol(p, &p, 0);
              global->procq_limit = (signed int)return_value_strtol$74;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for procq_limit option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L206:
            ;
            const unsigned short int **return_value___ctype_b_loc$76;
            return_value___ctype_b_loc$76=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$76)[(signed long int)(signed int)*p]) == 0))
            {
              char *_err;
              global->tcp_qtimeout=strtotime(p, &p, &_err);
              if(!(_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"tcp_qtimeout option", _err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for tcp_qtimeout option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L210:
            ;
            const unsigned short int **return_value___ctype_b_loc$77;
            return_value___ctype_b_loc$77=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$77)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$35$$1$$_err;
              global->timeout=strtotime(p, &p, &confparse$$1$$2$$1$$5$$2$$5$$35$$1$$_err);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$35$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"global timeout option", confparse$$1$$2$$1$$5$$2$$5$$35$$1$$_err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for global timeout option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L214:
            ;
            signed int val;
            const unsigned short int **return_value___ctype_b_loc$79;
            return_value___ctype_b_loc$79=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$79)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$78;
              return_value_strtol$78=strtol(p, &p, 0);
              val = (signed int)return_value_strtol$78;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for par_queries option");
              goto free_linebuf_return;
            }
            if(!(val >= 1))
            {
              *errstr=report_error(conftype, linenr, "bad value for par_queries.");
              goto free_linebuf_return;
            }

            else
              global->par_queries = val;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L219:
            ;
            const unsigned short int **return_value___ctype_b_loc$83;
            return_value___ctype_b_loc$83=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$83)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$37$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$37$$1$$_len;
              signed int _cnst;
              confparse$$1$$2$$1$$5$$2$$5$$37$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$80=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$80)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$81 = (_Bool)1;

                  else
                    tmp_if_expr$81 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$82 = tmp_if_expr$81 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$82 = (_Bool)0;
              }
              while(tmp_if_expr$82);
              confparse$$1$$2$$1$$5$$2$$5$$37$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$37$$1$$_str);
              _cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$37$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$37$$1$$_len);
              if(_cnst == 1 || _cnst == 2)
                global->rnd_recs = (char)(_cnst == 1);

              else
                goto ASSIGN_ON_OFF_853;
            }

            else
            {

            ASSIGN_ON_OFF_853:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in randomize_recs= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L229:
            ;
            const unsigned short int **return_value___ctype_b_loc$84;
            return_value___ctype_b_loc$84=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$84)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$38$$1$$_err;
              global->neg_ttl=strtotime(p, &p, &confparse$$1$$2$$1$$5$$2$$5$$38$$1$$_err);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$38$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"neg_ttl option", confparse$$1$$2$$1$$5$$2$$5$$38$$1$$_err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for neg_ttl option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L233:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$39$$cnst;
            const unsigned short int **return_value___ctype_b_loc$88;
            return_value___ctype_b_loc$88=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$88)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$39$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$39$$1$$1$$_len;
              confparse$$1$$2$$1$$5$$2$$5$$39$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$85=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$85)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$86 = (_Bool)1;

                  else
                    tmp_if_expr$86 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$87 = tmp_if_expr$86 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$87 = (_Bool)0;
              }
              while(tmp_if_expr$87);
              confparse$$1$$2$$1$$5$$2$$5$$39$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$39$$1$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$39$$cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$39$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$39$$1$$1$$_len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$39$$cnst == 1) && !(confparse$$1$$2$$1$$5$$2$$5$$39$$cnst == 2) && !(confparse$$1$$2$$1$$5$$2$$5$$39$$cnst == 3) && !(confparse$$1$$2$$1$$5$$2$$5$$39$$cnst == 22))
                goto ASSIGN_CONST_863;

            }

            else
            {

            ASSIGN_CONST_863:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in neg_rrs_pol= option.");
              goto free_linebuf_return;
            }
            global->neg_rrs_pol = (signed short int)confparse$$1$$2$$1$$5$$2$$5$$39$$cnst;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L241:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$40$$cnst;
            const unsigned short int **return_value___ctype_b_loc$92;
            return_value___ctype_b_loc$92=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$92)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$2$$5$$40$$1$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$2$$5$$40$$1$$1$$_len;
              confparse$$1$$2$$1$$5$$2$$5$$40$$1$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$89=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$89)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$90 = (_Bool)1;

                  else
                    tmp_if_expr$90 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$91 = tmp_if_expr$90 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$91 = (_Bool)0;
              }
              while(tmp_if_expr$91);
              confparse$$1$$2$$1$$5$$2$$5$$40$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$2$$5$$40$$1$$1$$_str);
              confparse$$1$$2$$1$$5$$2$$5$$40$$cnst=lookup_const(confparse$$1$$2$$1$$5$$2$$5$$40$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$2$$5$$40$$1$$1$$_len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$40$$cnst == 1) && !(confparse$$1$$2$$1$$5$$2$$5$$40$$cnst == 2) && !(confparse$$1$$2$$1$$5$$2$$5$$40$$cnst == 22))
                goto ASSIGN_CONST_870;

            }

            else
            {

            ASSIGN_CONST_870:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in neg_domain_pol= option.");
              goto free_linebuf_return;
            }
            global->neg_domain_pol = (signed short int)confparse$$1$$2$$1$$5$$2$$5$$40$$cnst;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L249:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$41$$val;
            const unsigned short int **return_value___ctype_b_loc$98;
            return_value___ctype_b_loc$98=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$98)[(signed long int)(signed int)*p]) == 0))
            {
              signed int confparse$$1$$2$$1$$5$$2$$5$$41$$1$$cnst;
              ps = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$93=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$93)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$94 = (_Bool)1;

                  else
                    tmp_if_expr$94 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$95 = tmp_if_expr$94 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$95 = (_Bool)0;
              }
              while(tmp_if_expr$95);
              len = (signed int)(p - ps);
              confparse$$1$$2$$1$$5$$2$$5$$41$$1$$cnst=lookup_const(ps, len);
              if(confparse$$1$$2$$1$$5$$2$$5$$41$$1$$cnst == 5)
                confparse$$1$$2$$1$$5$$2$$5$$41$$val = -1;

              else
                goto bad_port_start_option;
            }

            else
            {
              return_value___ctype_b_loc$97=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$97)[(signed long int)(signed int)*p]) == 0))
              {
                signed long int return_value_strtol$96;
                return_value_strtol$96=strtol(p, &p, 0);
                confparse$$1$$2$$1$$5$$2$$5$$41$$val = (signed int)return_value_strtol$96;
                if(confparse$$1$$2$$1$$5$$2$$5$$41$$val >= 65536)
                {
                  *errstr=report_error(conftype, linenr, "value for query_port_start out of range.");
                  goto free_linebuf_return;
                }

                else
                  if(!(confparse$$1$$2$$1$$5$$2$$5$$41$$val >= 1024))
                    fprintf(stderr, "Warning: query_port_start=%i but source ports <1204 can only be used as root.\n", confparse$$1$$2$$1$$5$$2$$5$$41$$val);

              }

              else
              {

              bad_port_start_option:
                ;
                *errstr=report_error(conftype, linenr, "bad qualifier in query_port_start= option.");
                goto free_linebuf_return;
              }
            }
            global->query_port_start = confparse$$1$$2$$1$$5$$2$$5$$41$$val;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L263:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$42$$val;
            const unsigned short int **return_value___ctype_b_loc$100;
            return_value___ctype_b_loc$100=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$100)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$99;
              return_value_strtol$99=strtol(p, &p, 0);
              confparse$$1$$2$$1$$5$$2$$5$$42$$val = (signed int)return_value_strtol$99;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for query_port_end option");
              goto free_linebuf_return;
            }
            if(confparse$$1$$2$$1$$5$$2$$5$$42$$val >= 65536)
            {
              *errstr=report_error(conftype, linenr, "value for query_port_end out of range.");
              goto free_linebuf_return;
            }

            global->query_port_end = confparse$$1$$2$$1$$5$$2$$5$$42$$val;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L267:
            ;
            signed int confparse$$1$$2$$1$$5$$2$$5$$43$$val;
            const unsigned short int **return_value___ctype_b_loc$102;
            return_value___ctype_b_loc$102=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$102)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$101;
              return_value_strtol$101=strtol(p, &p, 0);
              confparse$$1$$2$$1$$5$$2$$5$$43$$val = (signed int)return_value_strtol$101;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for udpbufsize");
              goto free_linebuf_return;
            }
            if(confparse$$1$$2$$1$$5$$2$$5$$43$$val >= 65508 || !(confparse$$1$$2$$1$$5$$2$$5$$43$$val >= 512))
            {
              *errstr=report_error(conftype, linenr, "value for udpbufsize out of range.");
              goto free_linebuf_return;
            }

            global->udpbufsize = confparse$$1$$2$$1$$5$$2$$5$$43$$val;
            goto __CPROVER_DUMP_L280;
            do
            {

            __CPROVER_DUMP_L271:
              ;
              const char *confparse$$1$$2$$1$$5$$2$$5$$44$$1$$1$$_err;
              len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
              if(len == -1)
                goto string_err;

              else
                if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  goto string_too_long;

              confparse$$1$$2$$1$$5$$2$$5$$44$$1$$1$$_err=zone_add(&global->deleg_only_zones, strbuf, (unsigned int)len);
              if(!(confparse$$1$$2$$1$$5$$2$$5$$44$$1$$1$$_err == ((const char *)NULL)))
              {
                *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$2$$5$$44$$1$$1$$_err);
                goto free_linebuf_return;
              }

              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
                goto unexpected_eof;

              if(!((signed int)*p == 44))
                break;

              p = p + 1l;
              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
                goto unexpected_eof;

            }
            while((_Bool)1);
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L279:
            ;
            goto internal_parse_error;

          __CPROVER_DUMP_L280:
            ;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          if(!((signed int)*p == 125))
            goto expected_closing_brace;

          if(!(global->query_port_end >= global->query_port_start))
          {
            *errstr=report_error(conftype, linenr, "query_port_end may not be smaller than query_port_start.");
            goto free_linebuf_return;
          }

          break;
        }
        case 2:
        {
          struct anonymous$7 server;
          if(servers == ((struct anonymous$18 **)NULL))
          {
            *errstr=report_error(conftype, linenr, in != ((struct _IO_FILE *)NULL) ? "server section not allowed in include file" : "server section not allowed in eval string");
            goto free_linebuf_return;
          }

          server = serv_presets;
          do
          {
            return_value___ctype_b_loc$103=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc$103)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc$104=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc$104)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr$105 = (_Bool)1;

                else
                  tmp_if_expr$105 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$106 = tmp_if_expr$105 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$106 = (_Bool)0;
            }
            while(tmp_if_expr$106);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, server_options, (signed int)(sizeof(const struct anonymous$32 [28l]) /*448ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for server section: %.*s", (signed int)len, ps);
              free_servparm(&server);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 61))
            {
              free_servparm(&server);
              goto expected_equals;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

            switch(option)
            {
              case 43:
              {
                do
                {
                  const char *confparse$$1$$2$$1$$5$$4$$2$$6$$1$$1$$1$$_err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse$$1$$2$$1$$5$$4$$2$$6$$1$$1$$1$$_err=addr_add(&server.atup_a, strbuf);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$1$$1$$1$$_err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$4$$2$$6$$1$$1$$1$$_err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 81:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                char *errmsg;
                signed int return_value_read_resolv_conf$107;
                return_value_read_resolv_conf$107=read_resolv_conf(strbuf, &server.atup_a, &errmsg);
                if(return_value_read_resolv_conf$107 == 0)
                {
                  if(!(errmsg == ((char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, errmsg);
                    free((void *)errmsg);
                  }

                  else
                    *errstr = (char *)(void *)0;
                  free_servparm(&server);
                  goto free_linebuf_return;
                }

                break;
              }
              case 44:
              {
                const unsigned short int **return_value___ctype_b_loc$109;
                return_value___ctype_b_loc$109=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc$109)[(signed long int)(signed int)*p]) == 0))
                {
                  signed long int return_value_strtol$108;
                  return_value_strtol$108=strtol(p, &p, 0);
                  server.port = (unsigned short int)return_value_strtol$108;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected unsigned integer value for port option");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 45:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!((unsigned long int)len >= sizeof(char [32l]) /*32ul*/ ))
                {
                  memcpy((void *)server.scheme, (const void *)strbuf, (unsigned long int)len);
                  server.scheme[(signed long int)len] = (char)0;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "scheme: string too long");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 46:
              {
                signed int confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst;
                const unsigned short int **return_value___ctype_b_loc$113;
                return_value___ctype_b_loc$113=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$113)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$7$$1$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$7$$1$$1$$_len;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$7$$1$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$110=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$110)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$111 = (_Bool)1;

                      else
                        tmp_if_expr$111 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$112 = tmp_if_expr$111 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$112 = (_Bool)0;
                  }
                  while(tmp_if_expr$112);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$7$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$7$$1$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$7$$1$$1$$_len);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst == 5) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst == 6) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst == 7) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst == 8) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst == 9) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst == 16) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst == 17))
                    goto ASSIGN_CONST_1001;

                }

                else
                {

                ASSIGN_CONST_1001:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in uptest= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.uptest = (signed short int)confparse$$1$$2$$1$$5$$4$$2$$6$$7$$cnst;
                break;
              }
              case 47:
              {
                const unsigned short int **return_value___ctype_b_loc$114;
                return_value___ctype_b_loc$114=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc$114)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$8$$1$$_err;
                  server.timeout=strtotime(p, &p, &confparse$$1$$2$$1$$5$$4$$2$$6$$8$$1$$_err);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$8$$1$$_err == ((char *)NULL)))
                  {
                    *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"timeout option", confparse$$1$$2$$1$$5$$4$$2$$6$$8$$1$$_err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected a time specification for timeout option");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 48:
              {
                const unsigned short int **return_value___ctype_b_loc$115;
                return_value___ctype_b_loc$115=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc$115)[(signed long int)(signed int)*p]) == 0))
                  server.ping_timeout=strtol(p, &p, 0);

                else
                {
                  *errstr=report_error(conftype, linenr, "expected unsigned integer value for ping_timeout option");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 49:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                const char *err;
                err=parse_ip(strbuf, &server.ping_a);
                if(!(err == ((const char *)NULL)))
                {
                  *errstr=report_errorf(conftype, linenr, "%s for the ping_ip= option.", err);
                  free_servparm(&server);
                  goto free_linebuf_return;
                }

                break;
              }
              case 50:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!(server.uptest_cmd == ((char *)NULL)))
                  free((void *)server.uptest_cmd);

                server.uptest_cmd=strndup(strbuf, (unsigned long int)len);
                if(server.uptest_cmd == ((char *)NULL))
                {
                  free_servparm(&server);
                  goto out_of_memory;
                }

                p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                if(p == ((char *)NULL))
                {
                  free_servparm(&server);
                  goto unexpected_eof;
                }

                if((signed int)*p == 44)
                {
                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  if(!((unsigned long int)len >= sizeof(char [21l]) /*21ul*/ ))
                  {
                    memcpy((void *)server.uptest_usr, (const void *)strbuf, (unsigned long int)len);
                    server.uptest_usr[(signed long int)len] = (char)0;
                  }

                  else
                  {
                    *errstr=report_error(conftype, linenr, "second argument of uptest_cmd: string too long");
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }
                }

                break;
              }
              case 51:
              {
                return_value___ctype_b_loc$119=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$119)[(signed long int)(signed int)*p]) == 0))
                {
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$16$$cnst;
                  ps = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$116=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$116)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$117 = (_Bool)1;

                      else
                        tmp_if_expr$117 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$118 = tmp_if_expr$117 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$118 = (_Bool)0;
                  }
                  while(tmp_if_expr$118);
                  len = (signed int)(p - ps);
                  if(!((signed int)*p == 46))
                  {
                    if(!((signed int)*p == 45))
                    {
                      confparse$$1$$2$$1$$5$$4$$2$$6$$16$$cnst=lookup_const(ps, len);
                      if(confparse$$1$$2$$1$$5$$4$$2$$6$$16$$cnst == 5)
                      {
                        if(!(server.query_test_name == ((unsigned char *)NULL)))
                          free((void *)server.query_test_name);

                        server.query_test_name = (unsigned char *)(void *)0;
                        break;
                      }

                    }

                  }

                  p = ps;
                }

                unsigned char tname[256l];
                unsigned char *copy;
                unsigned int confparse$$1$$2$$1$$5$$4$$2$$6$$17$$sz;
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                const char *confparse$$1$$2$$1$$5$$4$$2$$6$$17$$2$$_err;
                confparse$$1$$2$$1$$5$$4$$2$$6$$17$$2$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, tname);
                if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$17$$2$$_err == ((const char *)NULL)))
                {
                  *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$4$$2$$6$$17$$2$$_err);
                  free_servparm(&server);
                  goto free_linebuf_return;
                }

                confparse$$1$$2$$1$$5$$4$$2$$6$$17$$sz=rhnlen(tname);
                void *return_value_malloc$120;
                return_value_malloc$120=malloc((unsigned long int)confparse$$1$$2$$1$$5$$4$$2$$6$$17$$sz);
                copy = (unsigned char *)return_value_malloc$120;
                if(copy == ((unsigned char *)NULL))
                {
                  free_servparm(&server);
                  goto out_of_memory;
                }

                memcpy((void *)copy, (const void *)tname, (unsigned long int)confparse$$1$$2$$1$$5$$4$$2$$6$$17$$sz);
                if(!(server.query_test_name == ((unsigned char *)NULL)))
                  free((void *)server.query_test_name);

                server.query_test_name = copy;
                break;
              }
              case 52:
              {
                return_value___ctype_b_loc$125=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$125)[(signed long int)(signed int)*p]) == 0))
                {
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$18$$cnst;
                  ps = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$121=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$121)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$122 = (_Bool)1;

                      else
                        tmp_if_expr$122 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$123 = tmp_if_expr$122 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$123 = (_Bool)0;
                  }
                  while(tmp_if_expr$123);
                  len = (signed int)(p - ps);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$18$$cnst=lookup_const(ps, len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$18$$cnst == 10)
                    server.interval = (signed long int)-1;

                  else
                    if(confparse$$1$$2$$1$$5$$4$$2$$6$$18$$cnst == 11)
                      server.interval = (signed long int)-2;

                    else
                      goto bad_interval_option;
                }

                else
                {
                  return_value___ctype_b_loc$124=__ctype_b_loc();
                  if(!((2048 & (signed int)(*return_value___ctype_b_loc$124)[(signed long int)(signed int)*p]) == 0))
                  {
                    char *confparse$$1$$2$$1$$5$$4$$2$$6$$19$$err;
                    server.interval=strtotime(p, &p, &confparse$$1$$2$$1$$5$$4$$2$$6$$19$$err);
                    if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$19$$err == ((char *)NULL)))
                    {
                      *errstr=report_errorf(conftype, linenr, "bad time specification in interval= option: %s", confparse$$1$$2$$1$$5$$4$$2$$6$$19$$err);
                      free_servparm(&server);
                      goto free_linebuf_return;
                    }

                  }

                  else
                  {

                  bad_interval_option:
                    ;
                    *errstr=report_error(conftype, linenr, "bad qualifier in interval= option.");
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }
                }
                break;
              }
              case 53:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!((unsigned long int)len >= sizeof(char [16l]) /*16ul*/ ))
                {
                  memcpy((void *)server.interface, (const void *)strbuf, (unsigned long int)len);
                  server.interface[(signed long int)len] = (char)0;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "interface: string too long");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 54:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!((unsigned long int)len >= sizeof(char [16l]) /*16ul*/ ))
                {
                  memcpy((void *)server.device, (const void *)strbuf, (unsigned long int)len);
                  server.device[(signed long int)len] = (char)0;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "device: string too long");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 55:
              {
                const unsigned short int **return_value___ctype_b_loc$129;
                return_value___ctype_b_loc$129=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$129)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$126=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$126)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$127 = (_Bool)1;

                      else
                        tmp_if_expr$127 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$128 = tmp_if_expr$127 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$128 = (_Bool)0;
                  }
                  while(tmp_if_expr$128);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_cnst == 2)
                    server.purge_cache = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$25$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1111;
                }

                else
                {

                ASSIGN_ON_OFF_1111:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in purge_cache= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 56:
              {
                const unsigned short int **return_value___ctype_b_loc$133;
                return_value___ctype_b_loc$133=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$133)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$130=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$130)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$131 = (_Bool)1;

                      else
                        tmp_if_expr$131 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$132 = tmp_if_expr$131 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$132 = (_Bool)0;
                  }
                  while(tmp_if_expr$132);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_cnst == 2)
                    server.nocache = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$26$$1$$_cnst == 2);

                  else
                    goto ASSIGN_ON_OFF_1115;
                }

                else
                {

                ASSIGN_ON_OFF_1115:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in caching= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 57:
              {
                const unsigned short int **return_value___ctype_b_loc$137;
                return_value___ctype_b_loc$137=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$137)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$134=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$134)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$135 = (_Bool)1;

                      else
                        tmp_if_expr$135 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$136 = tmp_if_expr$135 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$136 = (_Bool)0;
                  }
                  while(tmp_if_expr$136);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_cnst == 2)
                    server.lean_query = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$27$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1119;
                }

                else
                {

                ASSIGN_ON_OFF_1119:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in lean_query= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 58:
              {
                const unsigned short int **return_value___ctype_b_loc$141;
                return_value___ctype_b_loc$141=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$141)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$138=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$138)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$139 = (_Bool)1;

                      else
                        tmp_if_expr$139 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$140 = tmp_if_expr$139 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$140 = (_Bool)0;
                  }
                  while(tmp_if_expr$140);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_cnst == 2)
                    server.edns_query = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$28$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1123;
                }

                else
                {

                ASSIGN_ON_OFF_1123:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in edns_query= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 59:
              {
                const unsigned short int **return_value___ctype_b_loc$145;
                return_value___ctype_b_loc$145=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$145)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$142=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$142)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$143 = (_Bool)1;

                      else
                        tmp_if_expr$143 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$144 = tmp_if_expr$143 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$144 = (_Bool)0;
                  }
                  while(tmp_if_expr$144);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_cnst == 2)
                    server.preset = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$29$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1127;
                }

                else
                {

                ASSIGN_ON_OFF_1127:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in preset= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 60:
              {
                const unsigned short int **return_value___ctype_b_loc$149;
                return_value___ctype_b_loc$149=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$149)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$146=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$146)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$147 = (_Bool)1;

                      else
                        tmp_if_expr$147 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$148 = tmp_if_expr$147 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$148 = (_Bool)0;
                  }
                  while(tmp_if_expr$148);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_cnst == 2)
                    server.is_proxy = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$30$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1131;
                }

                else
                {

                ASSIGN_ON_OFF_1131:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in proxy_only= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 61:
              {
                signed int confparse$$1$$2$$1$$5$$4$$2$$6$$31$$cnst;
                const unsigned short int **return_value___ctype_b_loc$153;
                return_value___ctype_b_loc$153=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$153)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$31$$1$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$31$$1$$1$$_len;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$31$$1$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$150=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$150)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$151 = (_Bool)1;

                      else
                        tmp_if_expr$151 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$152 = tmp_if_expr$151 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$152 = (_Bool)0;
                  }
                  while(tmp_if_expr$152);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$31$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$31$$1$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$31$$cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$31$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$31$$1$$1$$_len);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$31$$cnst == 1) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$31$$cnst == 2) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$31$$cnst == 4))
                    goto ASSIGN_CONST_1136;

                }

                else
                {

                ASSIGN_CONST_1136:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in root_server= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.rootserver = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$31$$cnst == 4 ? 2 : (signed int)(confparse$$1$$2$$1$$5$$4$$2$$6$$31$$cnst == 1));
                break;
              }
              case 62:
              {
                const unsigned short int **return_value___ctype_b_loc$157;
                return_value___ctype_b_loc$157=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$157)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$154=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$154)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$155 = (_Bool)1;

                      else
                        tmp_if_expr$155 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$156 = tmp_if_expr$155 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$156 = (_Bool)0;
                  }
                  while(tmp_if_expr$156);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_cnst == 2)
                    server.rand_servers = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$32$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1142;
                }

                else
                {

                ASSIGN_ON_OFF_1142:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in randomize_servers= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 65:
              {
                signed int confparse$$1$$2$$1$$5$$4$$2$$6$$33$$cnst;
                const unsigned short int **return_value___ctype_b_loc$161;
                return_value___ctype_b_loc$161=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$161)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$33$$1$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$33$$1$$1$$_len;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$33$$1$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$158=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$158)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$159 = (_Bool)1;

                      else
                        tmp_if_expr$159 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$160 = tmp_if_expr$159 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$160 = (_Bool)0;
                  }
                  while(tmp_if_expr$160);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$33$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$33$$1$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$33$$cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$33$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$33$$1$$1$$_len);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$33$$cnst == 18) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$33$$cnst == 19) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$33$$cnst == 20) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$33$$cnst == 21))
                    goto ASSIGN_CONST_1147;

                }

                else
                {

                ASSIGN_CONST_1147:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in policy= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.policy = (signed short int)confparse$$1$$2$$1$$5$$4$$2$$6$$33$$cnst;
                break;
              }
              case 63:
              {
                do
                {
                  const char *confparse$$1$$2$$1$$5$$4$$2$$6$$34$$1$$1$$_err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse$$1$$2$$1$$5$$4$$2$$6$$34$$1$$1$$_err=slist_add(&server.alist, strbuf, (unsigned int)len, 18);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$34$$1$$1$$_err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$4$$2$$6$$34$$1$$1$$_err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 64:
              {
                do
                {
                  const char *confparse$$1$$2$$1$$5$$4$$2$$6$$35$$1$$1$$_err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse$$1$$2$$1$$5$$4$$2$$6$$35$$1$$1$$_err=slist_add(&server.alist, strbuf, (unsigned int)len, 19);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$35$$1$$1$$_err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$4$$2$$6$$35$$1$$1$$_err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 66:
              {
                do
                {
                  const char *confparse$$1$$2$$1$$5$$4$$2$$6$$36$$1$$1$$_err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse$$1$$2$$1$$5$$4$$2$$6$$36$$1$$1$$_err=reject_add(&server, strbuf);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$36$$1$$1$$_err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$4$$2$$6$$36$$1$$1$$_err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 67:
              {
                signed int confparse$$1$$2$$1$$5$$4$$2$$6$$37$$cnst;
                const unsigned short int **return_value___ctype_b_loc$165;
                return_value___ctype_b_loc$165=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$165)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$37$$1$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$37$$1$$1$$_len;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$37$$1$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$162=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$162)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$163 = (_Bool)1;

                      else
                        tmp_if_expr$163 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$164 = tmp_if_expr$163 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$164 = (_Bool)0;
                  }
                  while(tmp_if_expr$164);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$37$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$37$$1$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$37$$cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$37$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$37$$1$$1$$_len);
                  if(!(confparse$$1$$2$$1$$5$$4$$2$$6$$37$$cnst == 24) && !(confparse$$1$$2$$1$$5$$4$$2$$6$$37$$cnst == 25))
                    goto ASSIGN_CONST_1166;

                }

                else
                {

                ASSIGN_CONST_1166:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in reject_policy= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.rejectpolicy = (signed short int)confparse$$1$$2$$1$$5$$4$$2$$6$$37$$cnst;
                break;
              }
              case 68:
              {
                const unsigned short int **return_value___ctype_b_loc$169;
                return_value___ctype_b_loc$169=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$169)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$166=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$166)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$167 = (_Bool)1;

                      else
                        tmp_if_expr$167 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$168 = tmp_if_expr$167 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$168 = (_Bool)0;
                  }
                  while(tmp_if_expr$168);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_str);
                  confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_cnst == 2)
                    server.rejectrecursively = (char)(confparse$$1$$2$$1$$5$$4$$2$$6$$38$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1172;
                }

                else
                {

                ASSIGN_ON_OFF_1172:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in reject_recursively= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 69:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!(server.label == ((char *)NULL)))
                  free((void *)server.label);

                server.label=strndup(strbuf, (unsigned long int)len);
                if(server.label == ((char *)NULL))
                {
                  free_servparm(&server);
                  goto out_of_memory;
                }

                break;
              }
              default:
              {
                free_servparm(&server);
                goto internal_parse_error;
              }
            }
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 59))
            {
              free_servparm(&server);
              goto expected_semicolon;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

          }
          while((_Bool)1);
          if(!((signed int)*p == 125))
          {
            free_servparm(&server);
            goto expected_closing_brace;
          }

          if((signed int)server.uptest == 7)
          {
            if(server.uptest_cmd == ((char *)NULL))
            {
              *errstr=report_error(conftype, linenr, "you must specify uptest_cmd if you specify uptest=exec!");
              free_servparm(&server);
              goto free_linebuf_return;
            }

          }

          if(!(server.is_proxy == 0) && !(server.rootserver == 0))
          {
            *errstr=report_error(conftype, linenr, "A server may not be specified as both a proxy and a root-server.");
            free_servparm(&server);
            goto free_linebuf_return;
          }

          if(!(server.rootserver == 0) && ((signed int)server.policy == 20 || (signed int)server.policy == 21))
          {
            return_value_const_name$170=const_name((signed int)server.policy);
            fprintf(stderr, "Warning: using policy=%s with a root-server usually makes no sense.", return_value_const_name$170);
          }

          unsigned int return_value_da_nel$172;
          return_value_da_nel$172=da_nel((struct anonymous$3 *)server.atup_a);
          if(!(return_value_da_nel$172 == 0u))
          {
            check_localaddrs(&server);
            unsigned int return_value_da_nel$171;
            return_value_da_nel$171=da_nel((struct anonymous$3 *)server.atup_a);
            if(return_value_da_nel$171 == 0u)
            {
              *errstr=report_error(conftype, linenr, "Server section contains only local IP addresses.\nBind pdnsd to a different local IP address or specify different port numbers in global section and server section if you want pdnsd to query servers on the same machine.");
              free_servparm(&server);
              goto free_linebuf_return;
            }

          }

          signed int j;
          signed int confparse$$1$$2$$1$$5$$4$$7$$n;
          unsigned int return_value_da_nel$173;
          return_value_da_nel$173=da_nel((struct anonymous$3 *)server.atup_a);
          confparse$$1$$2$$1$$5$$4$$7$$n = (signed int)return_value_da_nel$173;
          j = 0;
          for( ; !(j >= confparse$$1$$2$$1$$5$$4$$7$$n); j = j + 1)
          {
            struct anonymous$20 *at = &server.atup_a->elem[(signed long int)j];
            at->is_up = server.preset;
            if(!(server.interval >= 0l))
              at->i_ts=time((signed long int *)(void *)0);

          }
          if(server.interval == -1l)
            global->onquery = (char)1;

          struct anonymous$3 *return_value_da_grow1$174;
          return_value_da_grow1$174=da_grow1((struct anonymous$3 *)*servers, (unsigned long int)((struct anonymous$18 *)0)->elem, sizeof(struct anonymous$7) /*208ul*/ , (void (*)(void *))free_servparm);
          *servers = (struct anonymous$18 *)return_value_da_grow1$174;
          if(*servers == ((struct anonymous$18 *)NULL))
          {
            free_servparm(&server);
            goto out_of_memory;
          }

          (*servers)->elem[(signed long int)((*servers)->nel - (unsigned long int)1)] = server;
          break;
        }
        case 3:
        {
          confparse$$1$$2$$1$$5$$5$$c_cent = (struct anonymous$0){ .qname=((unsigned char *)NULL), .cs=0ul, .num_rrs=0,
    .flags=0, .$anon0={ .rr={ .rrmu={ ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL) }, .rrext=((struct anonymous **)NULL) } }, .c_ns=0,
    .c_soa=0 };
          confparse$$1$$2$$1$$5$$5$$c_ttl = (signed long int)86400;
          c_flags = (unsigned int)2;
          reverse = (unsigned char)0;
          do
          {
            return_value___ctype_b_loc$175=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc$175)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc$176=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc$176)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr$177 = (_Bool)1;

                else
                  tmp_if_expr$177 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$178 = tmp_if_expr$177 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$178 = (_Bool)0;
            }
            while(tmp_if_expr$178);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, rr_options, (signed int)(sizeof(const struct anonymous$32 [13l]) /*208ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for rr section: %.*s", (signed int)len, ps);
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 61))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto expected_equals;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!(option == 77))
            {
              if(option == 79)
                goto __CPROVER_DUMP_L553;

              if(option == 83)
                goto __CPROVER_DUMP_L557;

              if(option == 84)
                goto __CPROVER_DUMP_L566;

              if(option == 70)
                goto __CPROVER_DUMP_L576;

              if(option == 78)
                goto __CPROVER_DUMP_L583;

              if(option == 74)
                goto __CPROVER_DUMP_L584;

              if(option == 71)
                goto __CPROVER_DUMP_L585;

              if(option == 72)
                goto __CPROVER_DUMP_L590;

              if(option == 73)
                goto __CPROVER_DUMP_L600;

              if(option == 76)
                goto __CPROVER_DUMP_L644;

              if(option == 75)
                goto __CPROVER_DUMP_L645;

              goto __CPROVER_DUMP_L656;
            }

            unsigned char c_name[256l];
            if(!(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, "You may specify only one name in a rr section.");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto string_too_long;
              }

            const char *confparse$$1$$2$$1$$5$$5$$1$$6$$1$$3$$_err;
            confparse$$1$$2$$1$$5$$5$$1$$6$$1$$3$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, c_name);
            if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$1$$3$$_err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$5$$1$$6$$1$$3$$_err);
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            signed int return_value_init_cent$179;
            return_value_init_cent$179=init_cent(&confparse$$1$$2$$1$$5$$5$$c_cent, c_name, (signed long int)0, (signed long int)0, c_flags);
            if(return_value_init_cent$179 == 0)
              goto out_of_memory;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L553:
            ;
            const unsigned short int **return_value___ctype_b_loc$180;
            return_value___ctype_b_loc$180=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$180)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$5$$1$$6$$2$$1$$_err;
              confparse$$1$$2$$1$$5$$5$$c_ttl=strtotime(p, &p, &confparse$$1$$2$$1$$5$$5$$1$$6$$2$$1$$_err);
              if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$2$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"ttl option", confparse$$1$$2$$1$$5$$5$$1$$6$$2$$1$$_err);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for ttl option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L557:
            ;
            signed int confparse$$1$$2$$1$$5$$5$$1$$6$$3$$cnst;
            if(!(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, "The authrec= option has no effect unless it precedes name= in a rr section.");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            const unsigned short int **return_value___ctype_b_loc$184;
            return_value___ctype_b_loc$184=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$184)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$5$$1$$6$$3$$2$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$5$$1$$6$$3$$2$$1$$_len;
              confparse$$1$$2$$1$$5$$5$$1$$6$$3$$2$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$181=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$181)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$182 = (_Bool)1;

                  else
                    tmp_if_expr$182 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$183 = tmp_if_expr$182 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$183 = (_Bool)0;
              }
              while(tmp_if_expr$183);
              confparse$$1$$2$$1$$5$$5$$1$$6$$3$$2$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$5$$1$$6$$3$$2$$1$$_str);
              confparse$$1$$2$$1$$5$$5$$1$$6$$3$$cnst=lookup_const(confparse$$1$$2$$1$$5$$5$$1$$6$$3$$2$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$5$$1$$6$$3$$2$$1$$_len);
              if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$3$$cnst == 1) && !(confparse$$1$$2$$1$$5$$5$$1$$6$$3$$cnst == 2))
                goto ASSIGN_CONST_1282;

            }

            else
            {

            ASSIGN_CONST_1282:
              ;
              *errstr=report_error(conftype, linenr, "Bad qualifier in authrec= option.");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            c_flags = (unsigned int)(confparse$$1$$2$$1$$5$$5$$1$$6$$3$$cnst == 1 ? 2 : 0);
            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L566:
            ;
            const unsigned short int **return_value___ctype_b_loc$188;
            return_value___ctype_b_loc$188=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc$188)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_str;
              unsigned long int confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_len;
              signed int confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_cnst;
              confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc$185=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc$185)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr$186 = (_Bool)1;

                  else
                    tmp_if_expr$186 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr$187 = tmp_if_expr$186 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$187 = (_Bool)0;
              }
              while(tmp_if_expr$187);
              confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_str);
              confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_len);
              if(confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_cnst == 2)
                reverse = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$4$$1$$_cnst == 1);

              else
                goto ASSIGN_ON_OFF_1288;
            }

            else
            {

            ASSIGN_ON_OFF_1288:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in reverse= option.");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L576:
            ;
            unsigned int sz;
            union anonymous$6 c_a;
            if(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto string_too_long;
              }

            signed int return_value_inet_aton$190;
            return_value_inet_aton$190=inet_aton(strbuf, &c_a.ipv4);
            if(!(return_value_inet_aton$190 == 0))
            {
              tp = 1;
              sz = (unsigned int)sizeof(struct in_addr) /*4ul*/ ;
            }

            else
            {
              return_value_inet_pton$189=inet_pton(10, strbuf, (void *)&c_a.ipv6);
              if(return_value_inet_pton$189 >= 1)
              {
                tp = 28;
                sz = (unsigned int)sizeof(struct in6_addr) /*16ul*/ ;
              }

              else
              {
                *errstr=report_error(conftype, linenr, "bad IP address in a= option.");
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }
            }
            signed int return_value_add_cent_rr$191;
            return_value_add_cent_rr$191=add_cent_rr(&confparse$$1$$2$$1$$5$$5$$c_cent, tp, confparse$$1$$2$$1$$5$$5$$c_ttl, (signed long int)0, (unsigned int)2, sz, (void *)&c_a);
            if(return_value_add_cent_rr$191 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L583:
            ;
            tp = 2;
            goto scan_name;

          __CPROVER_DUMP_L584:
            ;
            tp = 5;
            goto scan_name;

          __CPROVER_DUMP_L585:
            ;
            tp = 12;

          scan_name:
            ;
            unsigned char confparse$$1$$2$$1$$5$$5$$1$$6$$6$$c_name[256l];
            if(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto string_too_long;
              }

            const char *confparse$$1$$2$$1$$5$$5$$1$$6$$6$$2$$_err;
            confparse$$1$$2$$1$$5$$5$$1$$6$$6$$2$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, confparse$$1$$2$$1$$5$$5$$1$$6$$6$$c_name);
            if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$6$$2$$_err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$5$$1$$6$$6$$2$$_err);
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            unsigned int return_value_rhnlen$192;
            return_value_rhnlen$192=rhnlen(confparse$$1$$2$$1$$5$$5$$1$$6$$6$$c_name);
            signed int return_value_add_cent_rr$193;
            return_value_add_cent_rr$193=add_cent_rr(&confparse$$1$$2$$1$$5$$5$$c_cent, tp, confparse$$1$$2$$1$$5$$5$$c_ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen$192, (void *)confparse$$1$$2$$1$$5$$5$$1$$6$$6$$c_name);
            if(return_value_add_cent_rr$193 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L590:
            ;
            unsigned char *cp;
            unsigned int pref;
            unsigned char c_mx[258l];
            if(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            cp = c_mx + (signed long int)2;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto string_too_long;
              }

            const char *confparse$$1$$2$$1$$5$$5$$1$$6$$7$$2$$_err;
            confparse$$1$$2$$1$$5$$5$$1$$6$$7$$2$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, cp);
            if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$7$$2$$_err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$5$$1$$6$$7$$2$$_err);
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing second argument (preference level) of mx= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc$195;
            return_value___ctype_b_loc$195=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$195)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$194;
              return_value_strtol$194=strtol(p, &p, 0);
              pref = (unsigned int)return_value_strtol$194;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for second argument of mx= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            cp = c_mx;
            do
            {
              unsigned short int t_s = (unsigned short int)pref;
              unsigned char *t_cp = (unsigned char *)cp;
              unsigned char *tmp_post$196 = t_cp;
              t_cp = t_cp + 1l;
              *tmp_post$196 = (unsigned char)((signed int)t_s >> 8);
              unsigned char *tmp_post$197 = t_cp;
              t_cp = t_cp + 1l;
              *tmp_post$197 = (unsigned char)t_s;
              cp = (unsigned char *)(void *)t_cp;
            }
            while((_Bool)0);
            unsigned int return_value_rhnlen$198;
            return_value_rhnlen$198=rhnlen(cp);
            signed int return_value_add_cent_rr$199;
            return_value_add_cent_rr$199=add_cent_rr(&confparse$$1$$2$$1$$5$$5$$c_cent, 15, confparse$$1$$2$$1$$5$$5$$c_ttl, (signed long int)0, (unsigned int)2, (unsigned int)2 + return_value_rhnlen$198, (void *)c_mx);
            if(return_value_add_cent_rr$199 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L600:
            ;
            unsigned int blen;
            unsigned int rlen;
            unsigned char *bp;
            unsigned int confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val;
            unsigned char buf[532l];
            if(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto string_too_long;
              }

            const char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$2$$_err;
            confparse$$1$$2$$1$$5$$5$$1$$6$$8$$2$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, buf);
            if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$2$$_err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$5$$1$$6$$8$$2$$_err);
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            rlen=rhnlen(buf);
            blen = rlen;
            bp = buf + (signed long int)rlen;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 2nd argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto string_too_long;
              }

            const char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$5$$_err;
            confparse$$1$$2$$1$$5$$5$$1$$6$$8$$5$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, bp);
            if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$5$$_err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$5$$1$$6$$8$$5$$_err);
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            rlen=rhnlen(bp);
            blen = blen + rlen;
            bp = bp + (signed long int)rlen;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 3rd argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc$201;
            return_value___ctype_b_loc$201=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$201)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol$200;
              return_value_strtol$200=strtol(p, &p, 0);
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val = (unsigned int)return_value_strtol$200;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for 3rd argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int t_l = (unsigned int)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val;
              unsigned char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp = (unsigned char *)bp;
              unsigned char *tmp_post$202 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp + 1l;
              *tmp_post$202 = (unsigned char)(t_l >> 24);
              unsigned char *tmp_post$203 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp + 1l;
              *tmp_post$203 = (unsigned char)(t_l >> 16);
              unsigned char *tmp_post$204 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp + 1l;
              *tmp_post$204 = (unsigned char)(t_l >> 8);
              unsigned char *tmp_post$205 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp + 1l;
              *tmp_post$205 = (unsigned char)t_l;
              bp = (unsigned char *)(void *)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$8$$t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 4th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc$207;
            return_value___ctype_b_loc$207=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$207)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$10$$1$$_err;
              signed long int return_value_strtotime$206;
              return_value_strtotime$206=strtotime(p, &p, &confparse$$1$$2$$1$$5$$5$$1$$6$$8$$10$$1$$_err);
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val = (unsigned int)return_value_strtotime$206;
              if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$10$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"4th argument of soa= option", confparse$$1$$2$$1$$5$$5$$1$$6$$8$$10$$1$$_err);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 4th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_l = (unsigned int)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val;
              unsigned char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp = (unsigned char *)bp;
              unsigned char *tmp_post$208 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp + 1l;
              *tmp_post$208 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_l >> 24);
              unsigned char *tmp_post$209 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp + 1l;
              *tmp_post$209 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_l >> 16);
              unsigned char *tmp_post$210 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp + 1l;
              *tmp_post$210 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_l >> 8);
              unsigned char *tmp_post$211 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp + 1l;
              *tmp_post$211 = (unsigned char)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_l;
              bp = (unsigned char *)(void *)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$11$$t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 5th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc$213;
            return_value___ctype_b_loc$213=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$213)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$13$$1$$_err;
              signed long int return_value_strtotime$212;
              return_value_strtotime$212=strtotime(p, &p, &confparse$$1$$2$$1$$5$$5$$1$$6$$8$$13$$1$$_err);
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val = (unsigned int)return_value_strtotime$212;
              if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$13$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"5th argument of soa= option", confparse$$1$$2$$1$$5$$5$$1$$6$$8$$13$$1$$_err);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 5th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_l = (unsigned int)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val;
              unsigned char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp = (unsigned char *)bp;
              unsigned char *tmp_post$214 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp + 1l;
              *tmp_post$214 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_l >> 24);
              unsigned char *tmp_post$215 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp + 1l;
              *tmp_post$215 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_l >> 16);
              unsigned char *tmp_post$216 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp + 1l;
              *tmp_post$216 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_l >> 8);
              unsigned char *tmp_post$217 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp + 1l;
              *tmp_post$217 = (unsigned char)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_l;
              bp = (unsigned char *)(void *)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$14$$t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 6th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc$219;
            return_value___ctype_b_loc$219=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$219)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$16$$1$$_err;
              signed long int return_value_strtotime$218;
              return_value_strtotime$218=strtotime(p, &p, &confparse$$1$$2$$1$$5$$5$$1$$6$$8$$16$$1$$_err);
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val = (unsigned int)return_value_strtotime$218;
              if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$16$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"6th argument of soa= option", confparse$$1$$2$$1$$5$$5$$1$$6$$8$$16$$1$$_err);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 6th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_l = (unsigned int)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val;
              unsigned char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp = (unsigned char *)bp;
              unsigned char *tmp_post$220 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp + 1l;
              *tmp_post$220 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_l >> 24);
              unsigned char *tmp_post$221 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp + 1l;
              *tmp_post$221 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_l >> 16);
              unsigned char *tmp_post$222 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp + 1l;
              *tmp_post$222 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_l >> 8);
              unsigned char *tmp_post$223 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp + 1l;
              *tmp_post$223 = (unsigned char)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_l;
              bp = (unsigned char *)(void *)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$17$$t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 7th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc$225;
            return_value___ctype_b_loc$225=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc$225)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$19$$1$$_err;
              signed long int return_value_strtotime$224;
              return_value_strtotime$224=strtotime(p, &p, &confparse$$1$$2$$1$$5$$5$$1$$6$$8$$19$$1$$_err);
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val = (unsigned int)return_value_strtotime$224;
              if(!(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$19$$1$$_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"7th argument of soa= option", confparse$$1$$2$$1$$5$$5$$1$$6$$8$$19$$1$$_err);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 7th argument of soa= option");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_l = (unsigned int)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$val;
              unsigned char *confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp = (unsigned char *)bp;
              unsigned char *tmp_post$226 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp + 1l;
              *tmp_post$226 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_l >> 24);
              unsigned char *tmp_post$227 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp + 1l;
              *tmp_post$227 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_l >> 16);
              unsigned char *tmp_post$228 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp + 1l;
              *tmp_post$228 = (unsigned char)(confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_l >> 8);
              unsigned char *tmp_post$229 = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp;
              confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp = confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp + 1l;
              *tmp_post$229 = (unsigned char)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_l;
              bp = (unsigned char *)(void *)confparse$$1$$2$$1$$5$$5$$1$$6$$8$$20$$t_cp;
            }
            while((_Bool)0);
            blen = blen + (unsigned int)20;
            signed int return_value_add_cent_rr$230;
            return_value_add_cent_rr$230=add_cent_rr(&confparse$$1$$2$$1$$5$$5$$c_cent, 6, confparse$$1$$2$$1$$5$$5$$c_ttl, (signed long int)0, (unsigned int)2, blen, (void *)buf);
            if(return_value_add_cent_rr$230 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L644:
            ;
            *errstr=report_error(conftype, linenr, "Missing support for caching SPF records in rr section");
            free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
            goto free_linebuf_return;

          __CPROVER_DUMP_L645:
            ;
            tp = 16;
            tpname = "txt";
            unsigned char *rbuf;
            unsigned int confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz;
            unsigned int allocsz;
            signed int rv;
            if(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            rbuf = (unsigned char *)(void *)0;
            allocsz = (unsigned int)0;
            confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz = allocsz;
            do
            {
              unsigned char *newbuf;
              unsigned char *confparse$$1$$2$$1$$5$$5$$1$$6$$10$$1$$1$$cp;
              unsigned int newsz = confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz + (unsigned int)256;
              signed int n;
              if(!(allocsz >= newsz))
              {
                allocsz = allocsz + (unsigned int)512;
                void *return_value_realloc$231;
                return_value_realloc$231=realloc((void *)rbuf, (unsigned long int)allocsz);
                newbuf = (unsigned char *)return_value_realloc$231;
                if(newbuf == ((unsigned char *)NULL))
                {
                  free((void *)rbuf);
                  free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                  goto out_of_memory;
                }

                rbuf = newbuf;
              }

              confparse$$1$$2$$1$$5$$5$$1$$6$$10$$1$$1$$cp = rbuf + (signed long int)confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz;
              n=scan_string(&p, (char *)(confparse$$1$$2$$1$$5$$5$$1$$6$$10$$1$$1$$cp + (signed long int)1), (unsigned int)255, &scanstrerr);
              if(n == -1)
              {
                *errstr=report_errorf(conftype, linenr, "%s in %s= option", scanstrerr, tpname);
                free((void *)rbuf);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

              if(n >= 256)
              {
                *errstr=report_errorf(conftype, linenr, "string longer than 255 bytes in %s= option", tpname);
                free((void *)rbuf);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

              *confparse$$1$$2$$1$$5$$5$$1$$6$$10$$1$$1$$cp = (unsigned char)n;
              confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz = confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz + (unsigned int)(n + 1);
              if(confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz >= 65536u)
              {
                *errstr=report_errorf(conftype, linenr, "data exceeds maximum size (65535 bytes) in %s= option", tpname);
                free((void *)rbuf);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
              {
                free((void *)rbuf);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto unexpected_eof;
              }

              if(!((signed int)*p == 44))
                break;

              p = p + 1l;
              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
              {
                free((void *)rbuf);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto unexpected_eof;
              }

            }
            while((_Bool)1);
            rv=add_cent_rr(&confparse$$1$$2$$1$$5$$5$$c_cent, tp, confparse$$1$$2$$1$$5$$5$$c_ttl, (signed long int)0, (unsigned int)2, confparse$$1$$2$$1$$5$$5$$1$$6$$10$$sz, (void *)rbuf);
            free((void *)rbuf);
            if(rv == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L656:
            ;
            free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
            goto internal_parse_error;

          __CPROVER_DUMP_L657:
            ;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 59))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto expected_semicolon;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto unexpected_eof;
            }

          }
          while((_Bool)1);
          if(!((signed int)*p == 125))
          {
            free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
            goto expected_closing_brace;
          }

          if(confparse$$1$$2$$1$$5$$5$$c_cent.qname == ((unsigned char *)NULL))
            goto no_name_spec;

          if((signed int)*confparse$$1$$2$$1$$5$$5$$c_cent.qname == 1)
          {
            if((signed int)confparse$$1$$2$$1$$5$$5$$c_cent.qname[1l] == 42)
            {
              signed int return_value_set_cent_flags$232;
              return_value_set_cent_flags$232=set_cent_flags(&confparse$$1$$2$$1$$5$$5$$c_cent.qname[(signed long int)2], (unsigned int)16);
              if(return_value_set_cent_flags$232 == 0)
              {
                unsigned char confparse$$1$$2$$1$$5$$5$$3$$1$$buf[256l];
                rhn2str(confparse$$1$$2$$1$$5$$5$$c_cent.qname, confparse$$1$$2$$1$$5$$5$$3$$1$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                *errstr=report_errorf(conftype, linenr, "You must define some records for '%s' before you can define records for the wildcard name '%s'", &confparse$$1$$2$$1$$5$$5$$3$$1$$buf[(signed long int)2], (const void *)confparse$$1$$2$$1$$5$$5$$3$$1$$buf);
                free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
                goto free_linebuf_return;
              }

            }

          }

          add_cache(&confparse$$1$$2$$1$$5$$5$$c_cent);
          if(!(reverse == 0))
          {
            signed int return_value_add_reverse_cache$233;
            return_value_add_reverse_cache$233=add_reverse_cache(&confparse$$1$$2$$1$$5$$5$$c_cent);
            if(return_value_add_reverse_cache$233 == 0)
            {
              *errstr=report_error(conftype, linenr, "Can't convert IP address in a= option into form suitable for reverse resolving.");
              free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
              goto free_linebuf_return;
            }

          }

          free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
          break;

        add_rr_failed:
          ;
          free_cent(&confparse$$1$$2$$1$$5$$5$$c_cent);
          goto out_of_memory;
        }
        case 5:
        {
          unsigned char c_owner[256l];
          signed long int c_ttl;
          unsigned int confparse$$1$$2$$1$$5$$6$$c_flags;
          unsigned char c_aliases;
          c_owner[(signed long int)0] = (unsigned char)0;
          c_ttl = (signed long int)86400;
          confparse$$1$$2$$1$$5$$6$$c_flags = (unsigned int)2;
          c_aliases = (unsigned char)0;
          do
          {
            return_value___ctype_b_loc$234=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc$234)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc$235=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc$235)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr$236 = (_Bool)1;

                else
                  tmp_if_expr$236 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$237 = tmp_if_expr$236 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$237 = (_Bool)0;
            }
            while(tmp_if_expr$237);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, source_options, (signed int)(sizeof(const struct anonymous$32 [6l]) /*96ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for source section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            switch(option)
            {
              case 78:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                  goto string_err;

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    goto string_too_long;

                const char *confparse$$1$$2$$1$$5$$6$$1$$5$$2$$_err;
                confparse$$1$$2$$1$$5$$6$$1$$5$$2$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, c_owner);
                if(!(confparse$$1$$2$$1$$5$$6$$1$$5$$2$$_err == ((const char *)NULL)))
                {
                  *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$6$$1$$5$$2$$_err);
                  goto free_linebuf_return;
                }

                break;
              }
              case 79:
              {
                const unsigned short int **return_value___ctype_b_loc$238;
                return_value___ctype_b_loc$238=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc$238)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$6$$1$$5$$3$$1$$_err;
                  c_ttl=strtotime(p, &p, &confparse$$1$$2$$1$$5$$6$$1$$5$$3$$1$$_err);
                  if(!(confparse$$1$$2$$1$$5$$6$$1$$5$$3$$1$$_err == ((char *)NULL)))
                  {
                    *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"ttl option", confparse$$1$$2$$1$$5$$6$$1$$5$$3$$1$$_err);
                    goto free_linebuf_return;
                  }

                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected a time specification for ttl option");
                  goto free_linebuf_return;
                }
                break;
              }
              case 81:
              {
                if(c_owner[0l] == 0)
                {
                  *errstr=report_error(conftype, linenr, "you must specify owner before file= in source records.");
                  goto free_linebuf_return;
                }

                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                  goto string_err;

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    goto string_too_long;

                char *confparse$$1$$2$$1$$5$$6$$1$$5$$6$$errmsg;
                signed int return_value_read_hosts$239;
                return_value_read_hosts$239=read_hosts(strbuf, c_owner, c_ttl, confparse$$1$$2$$1$$5$$6$$c_flags, (signed int)c_aliases, &confparse$$1$$2$$1$$5$$6$$1$$5$$6$$errmsg);
                if(return_value_read_hosts$239 == 0)
                {
                  if(!(confparse$$1$$2$$1$$5$$6$$1$$5$$6$$errmsg == ((char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$6$$1$$5$$6$$errmsg);
                    free((void *)confparse$$1$$2$$1$$5$$6$$1$$5$$6$$errmsg);
                  }

                  else
                    *errstr = (char *)(void *)0;
                  goto free_linebuf_return;
                }

                break;
              }
              case 82:
              {
                const unsigned short int **return_value___ctype_b_loc$243;
                return_value___ctype_b_loc$243=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$243)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_len;
                  signed int confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_cnst;
                  confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$240=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$240)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$241 = (_Bool)1;

                      else
                        tmp_if_expr$241 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$242 = tmp_if_expr$241 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$242 = (_Bool)0;
                  }
                  while(tmp_if_expr$242);
                  confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_str);
                  confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_cnst=lookup_const(confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_len);
                  if(confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_cnst == 1 || confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_cnst == 2)
                    c_aliases = (unsigned char)(confparse$$1$$2$$1$$5$$6$$1$$5$$7$$1$$_cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1564;
                }

                else
                {

                ASSIGN_ON_OFF_1564:
                  ;
                  *errstr=report_error(conftype, linenr, "Bad qualifier in serve_aliases= option.");
                  goto free_linebuf_return;
                }
                break;
              }
              case 83:
              {
                signed int confparse$$1$$2$$1$$5$$6$$1$$5$$8$$cnst;
                const unsigned short int **return_value___ctype_b_loc$247;
                return_value___ctype_b_loc$247=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$247)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$6$$1$$5$$8$$1$$1$$_str;
                  unsigned long int confparse$$1$$2$$1$$5$$6$$1$$5$$8$$1$$1$$_len;
                  confparse$$1$$2$$1$$5$$6$$1$$5$$8$$1$$1$$_str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$244=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$244)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$245 = (_Bool)1;

                      else
                        tmp_if_expr$245 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$246 = tmp_if_expr$245 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$246 = (_Bool)0;
                  }
                  while(tmp_if_expr$246);
                  confparse$$1$$2$$1$$5$$6$$1$$5$$8$$1$$1$$_len = (unsigned long int)(p - confparse$$1$$2$$1$$5$$6$$1$$5$$8$$1$$1$$_str);
                  confparse$$1$$2$$1$$5$$6$$1$$5$$8$$cnst=lookup_const(confparse$$1$$2$$1$$5$$6$$1$$5$$8$$1$$1$$_str, (signed int)confparse$$1$$2$$1$$5$$6$$1$$5$$8$$1$$1$$_len);
                  if(!(confparse$$1$$2$$1$$5$$6$$1$$5$$8$$cnst == 1) && !(confparse$$1$$2$$1$$5$$6$$1$$5$$8$$cnst == 2))
                    goto ASSIGN_CONST_1569;

                }

                else
                {

                ASSIGN_CONST_1569:
                  ;
                  *errstr=report_error(conftype, linenr, "Bad qualifier in authrec= option.");
                  goto free_linebuf_return;
                }
                confparse$$1$$2$$1$$5$$6$$c_flags = (unsigned int)(confparse$$1$$2$$1$$5$$6$$1$$5$$8$$cnst == 1 ? 2 : 0);
                break;
              }
              default:
                goto internal_parse_error;
            }
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          break;
        }
        case 6:
        {
          do
          {
            return_value___ctype_b_loc$248=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc$248)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc$249=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc$249)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr$250 = (_Bool)1;

                else
                  tmp_if_expr$250 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$251 = tmp_if_expr$250 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$251 = (_Bool)0;
            }
            while(tmp_if_expr$251);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, include_options, (signed int)(sizeof(const struct anonymous$32 [1l]) /*16ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for include section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(option == 81)
            {
              if(includedepth >= 100)
              {
                *errstr=report_errorf(conftype, linenr, "maximum include depth (%d) exceeded.", 100);
                goto free_linebuf_return;
              }

              len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
              if(len == -1)
                goto string_err;

              else
                if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  goto string_too_long;

              char *confparse$$1$$2$$1$$5$$7$$1$$5$$3$$errmsg;
              signed int return_value_read_config_file$254;
              return_value_read_config_file$254=read_config_file(strbuf, (struct anonymous$21 *)(void *)0, (struct anonymous$18 **)(void *)0, includedepth + 1, &confparse$$1$$2$$1$$5$$7$$1$$5$$3$$errmsg);
              if(return_value_read_config_file$254 == 0)
              {
                if(!(confparse$$1$$2$$1$$5$$7$$1$$5$$3$$errmsg == ((char *)NULL)))
                {
                  if(!(linenr == 0u))
                  {
                    signed int return_value_asprintf$252;
                    return_value_asprintf$252=asprintf(errstr, "In file %s included at line %u:\n%s", (const void *)strbuf, linenr, confparse$$1$$2$$1$$5$$7$$1$$5$$3$$errmsg);
                    if(!(return_value_asprintf$252 >= 0))
                      *errstr = (char *)(void *)0;

                  }

                  else
                  {
                    signed int return_value_asprintf$253;
                    return_value_asprintf$253=asprintf(errstr, "In file %s:\n%s", (const void *)strbuf, confparse$$1$$2$$1$$5$$7$$1$$5$$3$$errmsg);
                    if(!(return_value_asprintf$253 >= 0))
                      *errstr = (char *)(void *)0;

                  }
                  free((void *)confparse$$1$$2$$1$$5$$7$$1$$5$$3$$errmsg);
                }

                else
                  *errstr = (char *)(void *)0;
                goto free_linebuf_return;
              }

              goto __CPROVER_DUMP_L737;
            }

            goto internal_parse_error;

          __CPROVER_DUMP_L737:
            ;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          break;
        }
        case 4:
        {
          unsigned char confparse$$1$$2$$1$$5$$8$$c_name[256l];
          signed long int confparse$$1$$2$$1$$5$$8$$c_ttl;
          unsigned char htp;
          unsigned char hdtp;
          htp = (unsigned char)0;
          hdtp = (unsigned char)0;
          confparse$$1$$2$$1$$5$$8$$c_name[(signed long int)0] = (unsigned char)0;
          confparse$$1$$2$$1$$5$$8$$c_ttl = (signed long int)86400;
          do
          {
            return_value___ctype_b_loc$255=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc$255)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc$256=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc$256)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr$257 = (_Bool)1;

                else
                  tmp_if_expr$257 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$258 = tmp_if_expr$257 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$258 = (_Bool)0;
            }
            while(tmp_if_expr$258);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, neg_options, (signed int)(sizeof(const struct anonymous$32 [3l]) /*48ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for neg section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            switch(option)
            {
              case 77:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                  goto string_err;

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    goto string_too_long;

                const char *confparse$$1$$2$$1$$5$$8$$1$$5$$2$$_err;
                confparse$$1$$2$$1$$5$$8$$1$$5$$2$$_err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, confparse$$1$$2$$1$$5$$8$$c_name);
                if(!(confparse$$1$$2$$1$$5$$8$$1$$5$$2$$_err == ((const char *)NULL)))
                {
                  *errstr=report_error(conftype, linenr, confparse$$1$$2$$1$$5$$8$$1$$5$$2$$_err);
                  goto free_linebuf_return;
                }

                break;
              }
              case 79:
              {
                const unsigned short int **return_value___ctype_b_loc$259;
                return_value___ctype_b_loc$259=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc$259)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse$$1$$2$$1$$5$$8$$1$$5$$3$$1$$_err;
                  confparse$$1$$2$$1$$5$$8$$c_ttl=strtotime(p, &p, &confparse$$1$$2$$1$$5$$8$$1$$5$$3$$1$$_err);
                  if(!(confparse$$1$$2$$1$$5$$8$$1$$5$$3$$1$$_err == ((char *)NULL)))
                  {
                    *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"ttl option", confparse$$1$$2$$1$$5$$8$$1$$5$$3$$1$$_err);
                    goto free_linebuf_return;
                  }

                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected a time specification for ttl option");
                  goto free_linebuf_return;
                }
                break;
              }
              case 80:
              {
                if(confparse$$1$$2$$1$$5$$8$$c_name[0l] == 0)
                {
                  *errstr=report_error(conftype, linenr, "you must specify a name before the types= option.");
                  goto free_linebuf_return;
                }

                return_value___ctype_b_loc$272=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc$272)[(signed long int)(signed int)*p]) == 0))
                {
                  signed int confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst;
                  struct anonymous$0 c_cent;
                  ps = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc$260=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc$260)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr$261 = (_Bool)1;

                      else
                        tmp_if_expr$261 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr$262 = tmp_if_expr$261 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$262 = (_Bool)0;
                  }
                  while(tmp_if_expr$262);
                  len = (signed int)(p - ps);
                  confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst=lookup_const(ps, len);
                  if(confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst == 23)
                  {
                    if(!(htp == 0))
                    {
                      *errstr=report_error(conftype, linenr, "You may not specify types=domain together with other types!");
                      goto free_linebuf_return;
                    }

                    hdtp = (unsigned char)1;
                    signed int return_value_init_cent$263;
                    return_value_init_cent$263=init_cent(&c_cent, confparse$$1$$2$$1$$5$$8$$c_name, confparse$$1$$2$$1$$5$$8$$c_ttl, (signed long int)0, (unsigned int)(2 | 1));
                    if(return_value_init_cent$263 == 0)
                      goto out_of_memory;

                  }

                  else
                    if(confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst == 0)
                    {
                      if(!(hdtp == 0))
                      {
                        *errstr=report_error(conftype, linenr, "You may not specify types=domain together with other types!");
                        goto free_linebuf_return;
                      }

                      htp = (unsigned char)1;
                      signed int return_value_init_cent$264;
                      return_value_init_cent$264=init_cent(&c_cent, confparse$$1$$2$$1$$5$$8$$c_name, (signed long int)0, (signed long int)0, (unsigned int)0);
                      if(return_value_init_cent$264 == 0)
                        goto out_of_memory;

                      do
                      {
                        const signed long int c_cent$array_size0 = (signed long int)(len + 1);
                        char confparse$$1$$2$$1$$5$$8$$1$$5$$5$$3$$2$$1$$1$$buf[c_cent$array_size0];
                        memcpy((void *)confparse$$1$$2$$1$$5$$8$$1$$5$$5$$3$$2$$1$$1$$buf, (const void *)ps, (unsigned long int)len);
                        confparse$$1$$2$$1$$5$$8$$1$$5$$5$$3$$2$$1$$1$$buf[(signed long int)len] = (char)0;
                        confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst=rr_tp_byname(confparse$$1$$2$$1$$5$$8$$1$$5$$5$$3$$2$$1$$1$$buf);
                        if(confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst == -1)
                        {
                          *errstr=report_errorf(conftype, linenr, "unrecognized rr type '%.*s' used as argument for types= option.", (signed int)len, ps);
                          free_cent(&c_cent);
                          goto free_linebuf_return;
                        }

                        _Bool tmp_if_expr$265;
                        if(confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst >= 52 || !(confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst >= 1))
                          tmp_if_expr$265 = (_Bool)1;

                        else
                          tmp_if_expr$265 = (signed int)rrlkuptab[(signed long int)(confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
                        if(tmp_if_expr$265)
                        {
                          *errstr=report_errorf(conftype, linenr, "illegal rr type '%.*s' used as argument for types= option.", (signed int)len, ps);
                          free_cent(&c_cent);
                          goto free_linebuf_return;
                        }

                        struct anonymous *return_value_getrrset_eff$267;
                        return_value_getrrset_eff$267=getrrset_eff(&c_cent, confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst);
                        if(return_value_getrrset_eff$267 == ((struct anonymous *)NULL))
                        {
                          return_value_add_cent_rrset_by_type$266=add_cent_rrset_by_type(&c_cent, confparse$$1$$2$$1$$5$$8$$1$$5$$5$$cnst, confparse$$1$$2$$1$$5$$8$$c_ttl, (signed long int)0, (unsigned int)(2 | 1));
                          if(return_value_add_cent_rrset_by_type$266 == 0)
                          {
                            free_cent(&c_cent);
                            goto out_of_memory;
                          }

                        }

                        p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                        if(p == ((char *)NULL))
                        {
                          free_cent(&c_cent);
                          goto unexpected_eof;
                        }

                        if(!((signed int)*p == 44))
                          break;

                        p = p + 1l;
                        p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                        if(p == ((char *)NULL))
                        {
                          free_cent(&c_cent);
                          goto unexpected_eof;
                        }

                        const unsigned short int **return_value___ctype_b_loc$268;
                        return_value___ctype_b_loc$268=__ctype_b_loc();
                        if((1024 & (signed int)(*return_value___ctype_b_loc$268)[(signed long int)(signed int)*p]) == 0)
                        {
                          free_cent(&c_cent);
                          goto bad_types_option;
                        }

                        ps = p;
                        do
                        {
                          p = p + 1l;
                          if(!(*p == 0))
                          {
                            return_value___ctype_b_loc$269=__ctype_b_loc();
                            if(!((8 & (signed int)(*return_value___ctype_b_loc$269)[(signed long int)(signed int)*p]) == 0))
                              tmp_if_expr$270 = (_Bool)1;

                            else
                              tmp_if_expr$270 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                            tmp_if_expr$271 = tmp_if_expr$270 ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr$271 = (_Bool)0;
                        }
                        while(tmp_if_expr$271);
                        len = (signed int)(p - ps);
                      }
                      while((_Bool)1);
                    }

                    else
                      goto bad_types_option;
                  add_cache(&c_cent);
                  free_cent(&c_cent);
                }

                else
                {

                bad_types_option:
                  ;
                  *errstr=report_error(conftype, linenr, "Bad argument for types= option.");
                  goto free_linebuf_return;
                }
                break;
              }
              default:
                goto internal_parse_error;
            }
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          break;
        }
        default:
          goto internal_parse_error;
      }
      if(!((signed int)*p == 125))
        goto expected_closing_brace;

      p = p + 1l;
    }

    else
    {
      *errstr=report_error(conftype, linenr, "expected section header");
      goto free_linebuf_return;
    }
  }
  while((_Bool)1);
  _Bool tmp_if_expr$275;
  signed int return_value_feof$274;
  if(in == ((struct _IO_FILE *)NULL))
    tmp_if_expr$275 = (_Bool)1;

  else
  {
    return_value_feof$274=feof(in);
    tmp_if_expr$275 = return_value_feof$274 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$275)
  {
    if(!(getnextperr == ((char *)NULL)))
    {
      *errstr=report_error(conftype, linenr, getnextperr);
      goto free_linebuf_return;
    }

    retval = 1;
  }

  else
    goto input_error;
  goto free_linebuf_return;

expected_bropen:
  ;
  *errstr=report_error(conftype, linenr, "expected opening brace after section name");
  goto free_linebuf_return;

expected_closing_brace:
  ;
  *errstr=report_error(conftype, linenr, "expected beginning of new option or closing brace");
  goto free_linebuf_return;

expected_equals:
  ;
  *errstr=report_error(conftype, linenr, "expected equals sign after option name");
  goto free_linebuf_return;

expected_semicolon:
  ;
  *errstr=report_error(conftype, linenr, "too many arguments to option or missing semicolon");
  goto free_linebuf_return;

string_err:
  ;
  *errstr=report_error(conftype, linenr, scanstrerr);
  goto free_linebuf_return;

string_too_long:
  ;
  *errstr=report_error(conftype, linenr, "string length exceeds buffer size");
  goto free_linebuf_return;

no_name_spec:
  ;
  *errstr=report_error(conftype, linenr, "you must specify a name before a,ptr,cname,mx,ns(owner) and soa records.");
  goto free_linebuf_return;

internal_parse_error:
  ;
  signed int return_value_asprintf$276;
  return_value_asprintf$276=asprintf(errstr, "Internal inconsistency detected while parsing line %u of %s.\nPlease consider reporting this error to one of the maintainers.\n", linenr, conftype);
  if(!(return_value_asprintf$276 >= 0))
    *errstr = (char *)(void *)0;

  goto free_linebuf_return;

out_of_memory:
  ;
  *errstr = (char *)(void *)0;
  goto free_linebuf_return;

unexpected_eof:
  ;
  _Bool tmp_if_expr$281;
  signed int return_value_feof$280;
  if(in == ((struct _IO_FILE *)NULL))
    tmp_if_expr$281 = (_Bool)1;

  else
  {
    return_value_feof$280=feof(in);
    tmp_if_expr$281 = return_value_feof$280 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$281)
    *errstr=report_error(conftype, linenr, getnextperr != ((char *)NULL) ? getnextperr : (in != ((struct _IO_FILE *)NULL) ? "unexpected end of file" : "unexpected end of input string"));

  else
  {

  input_error:
    ;
    signed int *return_value___errno_location$277;
    return_value___errno_location$277=__errno_location();
    char *return_value_strerror$278;
    return_value_strerror$278=strerror(*return_value___errno_location$277);
    signed int return_value_asprintf$279;
    return_value_asprintf$279=asprintf(errstr, "Error while reading config file: %s", return_value_strerror$278);
    if(!(return_value_asprintf$279 >= 0))
      *errstr = (char *)(void *)0;

  }

free_linebuf_return:
  ;
  free((void *)linebuf);
  return retval;
}

// const_name
// file consts.h line 67
const char * const_name(signed int c)
{
  const char *tmp_if_expr$1;
  if(c >= 0 && !((unsigned long int)c >= 26ul))
    tmp_if_expr$1 = const_names[(signed long int)c];

  else
    tmp_if_expr$1 = "ILLEGAL!";
  return tmp_if_expr$1;
}

// copy_cent
// file cache.c line 1098
struct anonymous$0 * copy_cent(struct anonymous$0 *cent)
{
  struct anonymous$0 *copy;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$0) /*104ul*/ );
  copy = (struct anonymous$0 *)return_value_malloc$1;
  if(copy == ((struct anonymous$0 *)NULL))
    return (struct anonymous$0 *)(void *)0;

  else
  {
    unsigned long int namesz;
    unsigned int return_value_rhnlen$2;
    return_value_rhnlen$2=rhnlen$link6(cent->qname);
    namesz = (unsigned long int)return_value_rhnlen$2;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(namesz);
    copy->qname = (unsigned char *)return_value_malloc$3;
    if(!(copy->qname == ((unsigned char *)NULL)))
    {
      memcpy((void *)copy->qname, (const void *)cent->qname, namesz);
      copy->cs = cent->cs;
      copy->num_rrs = cent->num_rrs;
      copy->flags = cent->flags;
      copy->c_ns = cent->c_ns;
      copy->c_soa = cent->c_soa;
      if(!((1 & (signed int)cent->flags) == 0))
      {
        copy->$anon0.neg.lent = (struct rr_lent_s *)(void *)0;
        copy->$anon0.neg.ttl = cent->$anon0.neg.ttl;
        copy->$anon0.neg.ts = cent->$anon0.neg.ts;
      }

      else
      {
        signed int i;
        signed int ilim;
        i = 0;
        for( ; !(i >= 8); i = i + 1)
          copy->$anon0.rr.rrmu[(signed long int)i] = (struct anonymous *)(void *)0;
        copy->$anon0.rr.rrext = (struct anonymous **)(void *)0;
        ilim = 8;
        if(!(cent->$anon0.rr.rrext == ((struct anonymous **)NULL)))
        {
          struct anonymous **rrextc;
          ilim = 47;
          void *return_value_malloc$4;
          return_value_malloc$4=malloc(sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39);
          rrextc = (struct anonymous **)return_value_malloc$4;
          copy->$anon0.rr.rrext = rrextc;
          if(rrextc == ((struct anonymous **)NULL))
            goto free_cent_return_null;

          i = 0;
          for( ; !(i >= 39); i = i + 1)
            rrextc[(signed long int)i] = (struct anonymous *)(void *)0;
        }

        i = 0;
        for( ; !(i >= ilim); i = i + 1)
        {
          struct anonymous *rrset;
          struct anonymous *tmp_if_expr$5;
          if(!(i >= 8))
            tmp_if_expr$5 = cent->$anon0.rr.rrmu[(signed long int)i];

          else
            tmp_if_expr$5 = cent->$anon0.rr.rrext[(signed long int)(i - 8)];
          rrset = tmp_if_expr$5;
          if(!(rrset == ((struct anonymous *)NULL)))
          {
            struct anonymous *rrsc;
            void *return_value_malloc$6;
            return_value_malloc$6=malloc(sizeof(struct anonymous) /*40ul*/ );
            rrsc = (struct anonymous *)return_value_malloc$6;
            struct rr_b_s *rr;
            struct rr_b_s **rrp;
            struct anonymous **tmp_if_expr$7;
            if(!(i >= 8))
              tmp_if_expr$7 = &copy->$anon0.rr.rrmu[(signed long int)i];

            else
              tmp_if_expr$7 = &copy->$anon0.rr.rrext[(signed long int)(i - 8)];
            *tmp_if_expr$7 = rrsc;
            if(rrsc == ((struct anonymous *)NULL))
              goto free_cent_return_null;

            *rrsc = *rrset;
            rrsc->lent = (struct rr_lent_s *)(void *)0;
            rrp = &rrsc->rrs;
            rr = rrset->rrs;
            while(!(rr == ((struct rr_b_s *)NULL)))
            {
              struct rr_b_s *rrc;
              rrc=copy_rr(rr);
              *rrp = rrc;
              if(rrc == ((struct rr_b_s *)NULL))
                goto free_cent_return_null;

              rrp = &rrc->next;
              rr = rr->next;
            }
          }

        }
      }
      return copy;

    free_cent_return_null:
      ;
      free_cent(copy);
    }


  free_return_null:
    ;
    free((void *)copy);
    return (struct anonymous$0 *)(void *)0;
  }
}

// copy_rr
// file cache.c line 1059
static inline struct rr_b_s * copy_rr(struct rr_b_s *rr)
{
  struct rr_b_s *rrn;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rr->rdlen);
  rrn = (struct rr_b_s *)return_value_malloc$1;
  if(rrn == ((struct rr_b_s *)NULL))
    return (struct rr_b_s *)(void *)0;

  else
  {
    memcpy((void *)rrn, (const void *)rr, sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rr->rdlen);
    rrn->next = (struct rr_b_s *)(void *)0;
    return rrn;
  }
}

// copy_rrset
// file cache.c line 1072
static struct anonymous * copy_rrset(struct anonymous *rrset)
{
  struct anonymous *rrsc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous) /*40ul*/ );
  rrsc = (struct anonymous *)return_value_malloc$1;
  struct rr_b_s *rr;
  struct rr_b_s **rrp;
  if(!(rrsc == ((struct anonymous *)NULL)))
  {
    *rrsc = *rrset;
    rrsc->lent = (struct rr_lent_s *)(void *)0;
    rrp = &rrsc->rrs;
    rr = rrset->rrs;
    while(!(rr == ((struct rr_b_s *)NULL)))
    {
      struct rr_b_s *rrc;
      rrc=copy_rr(rr);
      *rrp = rrc;
      if(rrc == ((struct rr_b_s *)NULL))
        goto cleanup_return;

      rrp = &rrc->next;
      rr = rr->next;
    }
  }

  return rrsc;

cleanup_return:
  ;
  del_rrset(rrsc);
  return (struct anonymous *)(void *)0;
}

// cr_check_add
// file cache.c line 1759
static signed int cr_check_add(struct anonymous$0 *cent, signed int idx, signed long int ttl, signed long int ts, unsigned int flags)
{
  signed long int nttl;
  struct rr_infos *rri;
  if(!((1u & flags) == 0u))
    return 1;

  else
  {
    nttl = (signed long int)0;
    rri = &rr_info[(signed long int)idx];
    if((2u & flags) == 0u)
    {
      signed int i;
      signed int cr_check_add$$1$$1$$ilim;
      signed int ncf;
      if(!((2 & (signed int)cent->flags) == 0))
        return 0;

      ncf = 0;
      signed int tmp_if_expr$1;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr$1 = 0;

      else
        tmp_if_expr$1 = cent->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      cr_check_add$$1$$1$$ilim = tmp_if_expr$1;
      i = 0;
      for( ; !(i >= cr_check_add$$1$$1$$ilim); i = i + 1)
      {
        struct anonymous *cr_check_add$$1$$1$$1$$1$$rrs;
        struct anonymous *tmp_if_expr$2;
        if(!(i >= 8))
          tmp_if_expr$2 = cent->$anon0.rr.rrmu[(signed long int)i];

        else
          tmp_if_expr$2 = cent->$anon0.rr.rrext[(signed long int)(i - 8)];
        cr_check_add$$1$$1$$1$$1$$rrs = tmp_if_expr$2;
        if(!(cr_check_add$$1$$1$$1$$1$$rrs == ((struct anonymous *)NULL)))
        {
          if((1 & (signed int)cr_check_add$$1$$1$$1$$1$$rrs->flags) == 0)
          {
            _Bool tmp_if_expr$4;
            if(!(((signed int)rri->class & (signed int)rr_info[(signed long int)i].excludes) == 0))
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = ((signed int)rri->excludes & (signed int)rr_info[(signed long int)i].class) != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$4)
            {
              signed long int rttl;
              if(!((2 & (signed int)cr_check_add$$1$$1$$1$$1$$rrs->flags) == 0))
                return 0;

              ncf = ncf + 1;
              signed long int return_value_time$3;
              return_value_time$3=time((signed long int *)(void *)0);
              rttl = (cr_check_add$$1$$1$$1$$1$$rrs->ttl + cr_check_add$$1$$1$$1$$1$$rrs->ts) - return_value_time$3;
              if(rttl >= 1l)
                nttl = nttl + rttl;

            }

          }

        }

      }
      if(ncf == 0)
        return 1;

      nttl = nttl / (signed long int)ncf;
    }

    if(!((2u & flags) == 0u) || !(nttl >= ttl))
    {
      signed int cr_check_add$$1$$2$$i;
      signed int ilim;
      signed int tmp_if_expr$5;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr$5 = 0;

      else
        tmp_if_expr$5 = cent->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      ilim = tmp_if_expr$5;
      cr_check_add$$1$$2$$i = 0;
      for( ; !(cr_check_add$$1$$2$$i >= ilim); cr_check_add$$1$$2$$i = cr_check_add$$1$$2$$i + 1)
      {
        struct anonymous *rrs;
        struct anonymous *tmp_if_expr$6;
        if(!(cr_check_add$$1$$2$$i >= 8))
          tmp_if_expr$6 = cent->$anon0.rr.rrmu[(signed long int)cr_check_add$$1$$2$$i];

        else
          tmp_if_expr$6 = cent->$anon0.rr.rrext[(signed long int)(cr_check_add$$1$$2$$i - 8)];
        rrs = tmp_if_expr$6;
        if(!(rrs == ((struct anonymous *)NULL)))
        {
          if((1 & (signed int)rrs->flags) == 0)
          {
            _Bool tmp_if_expr$7;
            if(!(((signed int)rri->class & (signed int)rr_info[(signed long int)cr_check_add$$1$$2$$i].excludes) == 0))
              tmp_if_expr$7 = (_Bool)1;

            else
              tmp_if_expr$7 = ((signed int)rri->excludes & (signed int)rr_info[(signed long int)cr_check_add$$1$$2$$i].class) != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$7)
              del_cent_rrset_by_index(cent, cr_check_add$$1$$2$$i);

          }

        }

      }
      return 1;
    }

    return 0;
  }
}

// crash_msg
// file error.c line 52
void crash_msg(char *msg)
{
  log_message(3, "%s", msg);
  log_message(3, "pdnsd probably crashed due to a bug. Please consider sending a bug");
  log_message(3, "report to p.a.rombouts@home.nl or tmoestl@gmx.net");
}

// create_rr
// file cache.c line 588
static struct rr_b_s * create_rr(unsigned int dlen, void *data)
{
  struct rr_b_s *rrb;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)dlen);
  rrb = (struct rr_b_s *)return_value_malloc$1;
  if(rrb == ((struct rr_b_s *)NULL))
    return (struct rr_b_s *)(void *)0;

  else
  {
    rrb->next = (struct rr_b_s *)(void *)0;
    rrb->rdlen = dlen;
    memcpy((void *)rrb->data, data, (unsigned long int)dlen);
    return rrb;
  }
}

// da_grow1
// file list.h line 54
struct anonymous$3 * da_grow1(struct anonymous$3 *a, unsigned long int headsz, unsigned long int elemsz, void (*cleanuproutine)(void *))
{
  unsigned long int k;
  unsigned long int tmp_if_expr$1;
  if(!(a == ((struct anonymous$3 *)NULL)))
    tmp_if_expr$1 = a->nel;

  else
    tmp_if_expr$1 = (unsigned long int)0;
  k = tmp_if_expr$1;
  if(a == ((struct anonymous$3 *)NULL) || (7ul & k) == 0ul && !(k == 0ul))
  {
    struct anonymous$3 *tmp;
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)a, headsz + elemsz * (k + (unsigned long int)8));
    tmp = (struct anonymous$3 *)return_value_realloc$2;
    if(tmp == ((struct anonymous$3 *)NULL) && !(a == ((struct anonymous$3 *)NULL)))
    {
      if(!(cleanuproutine == ((void (*)(void *))NULL)))
      {
        unsigned long int i = (unsigned long int)0;
        if(!(i >= k))
        {
          cleanuproutine((void *)((char *)a + (signed long int)headsz + (signed long int)(elemsz * i)));
          i = i + 1ul;
        }

      }

      free((void *)a);
    }

    a = tmp;
  }

  if(!(a == ((struct anonymous$3 *)NULL)))
    a->nel = k + (unsigned long int)1;

  return a;
}

// da_nel
// file list.h line 59
static inline unsigned int da_nel(struct anonymous$3 *a)
{
  if(a == ((struct anonymous$3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a->nel;
}

// da_nel$link1
// file list.h line 59
static inline unsigned int da_nel$link1(struct anonymous$3 *a$link1)
{
  if(a$link1 == ((struct anonymous$3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a$link1->nel;
}

// da_nel$link2
// file list.h line 59
static inline unsigned int da_nel$link2(struct anonymous$3 *a$link2)
{
  if(a$link2 == ((struct anonymous$3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a$link2->nel;
}

// da_nel$link3
// file list.h line 59
static inline unsigned int da_nel$link3(struct anonymous$3 *a$link3)
{
  if(a$link3 == ((struct anonymous$3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a$link3->nel;
}

// da_nel$link4
// file list.h line 59
static inline unsigned int da_nel$link4(struct anonymous$3 *a$link4)
{
  if(a$link4 == ((struct anonymous$3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a$link4->nel;
}

// da_nel$link5
// file list.h line 59
static inline unsigned int da_nel$link5(struct anonymous$3 *a$link5)
{
  if(a$link5 == ((struct anonymous$3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a$link5->nel;
}

// da_nel$link6
// file list.h line 59
static inline unsigned int da_nel$link6(struct anonymous$3 *a$link6)
{
  if(a$link6 == ((struct anonymous$3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a$link6->nel;
}

// da_resize
// file list.h line 55
struct anonymous$3 * da_resize(struct anonymous$3 *a, unsigned long int headsz, unsigned long int elemsz, unsigned long int n, void (*cleanuproutine)(void *))
{
  unsigned long int ael;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_alloc_nel$1;
  if(!(a == ((struct anonymous$3 *)NULL)))
  {
    return_value_alloc_nel$1=alloc_nel(a->nel);
    tmp_if_expr$2 = return_value_alloc_nel$1;
  }

  else
    tmp_if_expr$2 = (unsigned long int)0;
  ael = tmp_if_expr$2;
  unsigned long int new_ael;
  new_ael=alloc_nel(n);
  if(!(new_ael == ael))
  {
    struct anonymous$3 *tmp;
    void *return_value_realloc$3;
    return_value_realloc$3=realloc((void *)a, headsz + elemsz * new_ael);
    tmp = (struct anonymous$3 *)return_value_realloc$3;
    if(tmp == ((struct anonymous$3 *)NULL) && !(a == ((struct anonymous$3 *)NULL)))
    {
      if(!(cleanuproutine == ((void (*)(void *))NULL)))
      {
        unsigned long int i;
        unsigned long int k = a->nel;
        i = (unsigned long int)0;
        if(!(i >= k))
        {
          cleanuproutine((void *)((char *)a + (signed long int)headsz + (signed long int)(elemsz * i)));
          i = i + 1ul;
        }

      }

      free((void *)a);
    }

    a = tmp;
  }

  if(!(a == ((struct anonymous$3 *)NULL)))
    a->nel = n;

  return a;
}

// debug_msg
// file error.h line 74
void debug_msg(signed int c, const char *fmt, ...)
{
  void **va;
  unsigned long int return_value_strftime$2;
  if(c == 0)
  {
    char ts[(signed long int)sizeof(char [15l]) /*15l*/ ];
    signed long int tt;
    tt=time((signed long int *)(void *)0);
    struct tm tm;
    unsigned int *id;
    struct tm *return_value_localtime_r$3;
    return_value_localtime_r$3=localtime_r(&tt, &tm);
    if(!(return_value_localtime_r$3 == ((struct tm *)NULL)))
    {
      return_value_strftime$2=strftime(ts, sizeof(char [15l]) /*15ul*/ , "%m/%d %T", &tm);
      if(return_value_strftime$2 >= 1ul)
      {
        void *return_value_pthread_getspecific$1;
        return_value_pthread_getspecific$1=pthread_getspecific(thrid_key);
        id = (unsigned int *)return_value_pthread_getspecific$1;
        if(!(id == ((unsigned int *)NULL)))
          fprintf(dbg_file, "%u %s| ", *id, (const void *)ts);

        else
          fprintf(dbg_file, "- %s| ", (const void *)ts);
      }

    }

  }

  va = (void **)&fmt;
  vfprintf(dbg_file, fmt, va);
  va = ((void **)NULL);
  fflush(dbg_file);
}

// decode_query
// file dns_answer.c line 1003
static signed int decode_query(unsigned char *data, unsigned long int rlen, unsigned char **ptrrem, unsigned long int *lenrem, struct anonymous$40 *qp)
{
  signed int i;
  signed int res = 0;
  struct anonymous$29 *hdr = (struct anonymous$29 *)data;
  unsigned char *ptr = (unsigned char *)(hdr + (signed long int)1);
  unsigned long int sz = rlen - sizeof(struct anonymous$29) /*12ul*/ ;
  unsigned short int qdcount;
  qdcount=ntohs(hdr->qdcount);
  llist_init(qp);
  i = 0;
  for( ; !(i >= (signed int)qdcount); i = i + 1)
  {
    struct anonymous$70 *qe;
    unsigned int qlen;
    unsigned char qbuf[256l];
    res=decompress_name(data, rlen, &ptr, &sz, qbuf, &qlen);
    if(res == 0xfffe)
      break;

    if(!(res == 0))
    {
      llist_free(qp);
      break;
    }

    if(!(sz >= 4ul))
    {
      if(!(debug_p == 0))
        debug_msg(0, "decode_query: query truncated in qtype or qclass.\n");

      res = 0xfffe;
      break;
    }

    signed int return_value_llist_grow$1;
    return_value_llist_grow$1=llist_grow(qp, sizeof(struct anonymous$70) /*4ul*/  + (unsigned long int)qlen);
    if(return_value_llist_grow$1 == 0)
    {
      res = 2;
      break;
    }

    void *return_value_llist_last$2;
    return_value_llist_last$2=llist_last(qp);
    qe = (struct anonymous$70 *)return_value_llist_last$2;
    do
    {
      unsigned short int t_s;
      const unsigned char *t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post$3 = t_cp;
      t_cp = t_cp + 1l;
      t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$3 << 8);
      const unsigned char *tmp_post$4 = t_cp;
      t_cp = t_cp + 1l;
      t_s = t_s | (unsigned short int)*tmp_post$4;
      qe->qtype = t_s;
      ptr = (unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int decode_query$$1$$1$$1$$5$$t_s;
      const unsigned char *decode_query$$1$$1$$1$$5$$t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post$5 = decode_query$$1$$1$$1$$5$$t_cp;
      decode_query$$1$$1$$1$$5$$t_cp = decode_query$$1$$1$$1$$5$$t_cp + 1l;
      decode_query$$1$$1$$1$$5$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$5 << 8);
      const unsigned char *tmp_post$6 = decode_query$$1$$1$$1$$5$$t_cp;
      decode_query$$1$$1$$1$$5$$t_cp = decode_query$$1$$1$$1$$5$$t_cp + 1l;
      decode_query$$1$$1$$1$$5$$t_s = decode_query$$1$$1$$1$$5$$t_s | (unsigned short int)*tmp_post$6;
      qe->qclass = decode_query$$1$$1$$1$$5$$t_s;
      ptr = (unsigned char *)(void *)decode_query$$1$$1$$1$$5$$t_cp;
    }
    while((_Bool)0);
    sz = sz - (unsigned long int)4;
    memcpy((void *)qe->query, (const void *)qbuf, (unsigned long int)qlen);
  }
  if(!(ptrrem == ((unsigned char **)NULL)))
    *ptrrem = ptr;

  if(!(lenrem == ((unsigned long int *)NULL)))
    *lenrem = sz;

  return res;
}

// decode_query_additional
// file dns_answer.c line 1058
static signed int decode_query_additional(unsigned char *data, unsigned long int rlen, unsigned char *ptr, unsigned long int sz, signed int numrr, signed int *numopt, struct anonymous$17 *ep)
{
  signed int i;
  signed int res;
  i = 0;
  const char *return_value_getrrtpname$8;
  for( ; !(i >= numrr); i = i + 1)
  {
    unsigned char nmbuf[256l];
    unsigned short int type;
    unsigned short int class;
    unsigned char *ttlp;
    unsigned short int rdlen;
    res=decompress_name(data, rlen, &ptr, &sz, nmbuf, (unsigned int *)(void *)0);
    if(!(res == 0))
      return res;

    if(!(sz >= 10ul))
    {
      if(!(debug_p == 0))
        debug_msg(0, "decode_query_additional: additional section truncated in RR header.\n");

      return 0xfffe;
    }

    sz = sz - (unsigned long int)10;
    do
    {
      unsigned short int t_s;
      const unsigned char *t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post$1 = t_cp;
      t_cp = t_cp + 1l;
      t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$1 << 8);
      const unsigned char *tmp_post$2 = t_cp;
      t_cp = t_cp + 1l;
      t_s = t_s | (unsigned short int)*tmp_post$2;
      type = t_s;
      ptr = (unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int decode_query_additional$$1$$1$$1$$3$$t_s;
      const unsigned char *decode_query_additional$$1$$1$$1$$3$$t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post$3 = decode_query_additional$$1$$1$$1$$3$$t_cp;
      decode_query_additional$$1$$1$$1$$3$$t_cp = decode_query_additional$$1$$1$$1$$3$$t_cp + 1l;
      decode_query_additional$$1$$1$$1$$3$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$3 << 8);
      const unsigned char *tmp_post$4 = decode_query_additional$$1$$1$$1$$3$$t_cp;
      decode_query_additional$$1$$1$$1$$3$$t_cp = decode_query_additional$$1$$1$$1$$3$$t_cp + 1l;
      decode_query_additional$$1$$1$$1$$3$$t_s = decode_query_additional$$1$$1$$1$$3$$t_s | (unsigned short int)*tmp_post$4;
      class = decode_query_additional$$1$$1$$1$$3$$t_s;
      ptr = (unsigned char *)(void *)decode_query_additional$$1$$1$$1$$3$$t_cp;
    }
    while((_Bool)0);
    ttlp = ptr;
    ptr = ptr + (signed long int)4;
    do
    {
      unsigned short int decode_query_additional$$1$$1$$1$$4$$t_s;
      const unsigned char *decode_query_additional$$1$$1$$1$$4$$t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post$5 = decode_query_additional$$1$$1$$1$$4$$t_cp;
      decode_query_additional$$1$$1$$1$$4$$t_cp = decode_query_additional$$1$$1$$1$$4$$t_cp + 1l;
      decode_query_additional$$1$$1$$1$$4$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$5 << 8);
      const unsigned char *tmp_post$6 = decode_query_additional$$1$$1$$1$$4$$t_cp;
      decode_query_additional$$1$$1$$1$$4$$t_cp = decode_query_additional$$1$$1$$1$$4$$t_cp + 1l;
      decode_query_additional$$1$$1$$1$$4$$t_s = decode_query_additional$$1$$1$$1$$4$$t_s | (unsigned short int)*tmp_post$6;
      rdlen = decode_query_additional$$1$$1$$1$$4$$t_s;
      ptr = (unsigned char *)(void *)decode_query_additional$$1$$1$$1$$4$$t_cp;
    }
    while((_Bool)0);
    if(!(sz >= (unsigned long int)rdlen))
    {
      if(!(debug_p == 0))
        debug_msg(0, "decode_query_additional: additional section truncated in RDATA field.\n");

      return 0xfffe;
    }

    if((signed int)type == 41)
    {
      signed int tmp_post$7 = *numopt;
      *numopt = *numopt + 1;
      if(tmp_post$7 == 0)
      {
        if(!((signed int)nmbuf[0l] == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "decode_query_additional: name in OPT record not empty!\n");

        }

        ep->udpsize = class;
        ep->rcode = (unsigned short int)((signed int)(unsigned short int)ttlp[(signed long int)0] << 4 | (signed int)((struct anonymous$29 *)data)->rcode);
        ep->version = (unsigned short int)ttlp[(signed long int)1];
        ep->do_flg = (unsigned char)((signed int)ttlp[(signed long int)2] >> 7 & 1);
        if(!(debug_p == 0))
        {
          unsigned int Zflags = (unsigned int)((signed int)(unsigned short int)ttlp[(signed long int)2] << 8 | (signed int)ttlp[(signed long int)3]);
          if(!((32767u & Zflags) == 0u))
          {
            if(!(debug_p == 0))
              debug_msg(0, "decode_query_additional: Z field contains unknown nonzero bits (%04x).\n", Zflags);

          }

          if(!(rdlen == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "decode_query_additional: RDATA field in OPT record not empty!\n");

          }

        }

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "decode_query_additional: ingnoring surplus OPT record.\n");

    }

    else
      if(!(debug_p == 0))
      {
        return_value_getrrtpname$8=getrrtpname((signed int)type);
        debug_msg(0, "decode_query_additional: ignoring record of type %s (%d).\n", return_value_getrrtpname$8, type);
      }

    sz = sz - (unsigned long int)rdlen;
    ptr = ptr + (signed long int)rdlen;
  }
  return 0;
}

// decompress_name
// file dns.c line 44
signed int decompress_name(unsigned char *msg, unsigned long int msgsz, unsigned char **src, unsigned long int *sz, unsigned char *tgt, unsigned int *len)
{
  unsigned int lb;
  unsigned int offs;
  unsigned int hops = (unsigned int)0;
  unsigned int tpos = (unsigned int)0;
  unsigned char *lptr = *src;
  unsigned long int oldsz = *sz;
  unsigned long int newsz = oldsz;
  if(!(newsz == 0ul))
  {
    if((unsigned long int)(lptr - msg) >= msgsz)
      goto name_outside_msg;

    do
    {
      newsz = newsz - 1ul;
      unsigned char *tmp_post$1 = lptr;
      lptr = lptr + 1l;
      lb = (unsigned int)*tmp_post$1;
      if(lb >= 64u)
      {
        if(!(lb >= 192u))
          goto unsupported_lbl_bits;

        if(newsz == 0ul)
          goto name_outside_data;

        if((unsigned long int)(lptr - msg) >= msgsz)
          goto name_outside_msg;

        newsz = newsz - 1ul;
        offs = (lb & (unsigned int)0x3f) << 8 | (unsigned int)*lptr;
        if((unsigned long int)offs >= msgsz)
          goto offset_outside_msg;

        lptr = msg + (signed long int)offs;
        goto jumped;
      }

      unsigned int tmp_post$2 = tpos;
      tpos = tpos + 1u;
      tgt[(signed long int)tmp_post$2] = (unsigned char)lb;
      if(lb == 0u)
        break;

      if((unsigned long int)lb >= newsz)
        goto name_outside_data;

      if((unsigned long int)((lptr + (signed long int)lb) - msg) >= msgsz)
        goto name_outside_msg;

      if(lb + tpos >= 256u)
        goto name_buf_full;

      newsz = newsz - (unsigned long int)lb;
      do
      {
        unsigned int tmp_post$3 = tpos;
        tpos = tpos + 1u;
        unsigned char *tmp_post$4 = lptr;
        lptr = lptr + 1l;
        tgt[(signed long int)tmp_post$3] = *tmp_post$4;
        lb = lb - 1u;
      }
      while(!(lb == 0u));
    }
    while((_Bool)1);
    goto return_OK;

  jumped:
    ;
    hops = hops + 1u;
    do
    {
      unsigned char *tmp_post$5 = lptr;
      lptr = lptr + 1l;
      lb = (unsigned int)*tmp_post$5;
      while(lb >= 64u)
      {
        if(!(lb >= 192u))
          goto unsupported_lbl_bits;

        if((unsigned long int)(lptr - msg) >= msgsz)
          goto name_outside_msg;

        hops = hops + 1u;
        if(hops >= 256u)
          goto too_many_hops;

        offs = (lb & (unsigned int)0x3f) << 8 | (unsigned int)*lptr;
        if((unsigned long int)offs >= msgsz)
          goto offset_outside_msg;

        lptr = msg + (signed long int)offs;
        unsigned char *tmp_post$6 = lptr;
        lptr = lptr + 1l;
        lb = (unsigned int)*tmp_post$6;
      }
      unsigned int tmp_post$7 = tpos;
      tpos = tpos + 1u;
      tgt[(signed long int)tmp_post$7] = (unsigned char)lb;
      if(lb == 0u)
        break;

      if((unsigned long int)((lptr + (signed long int)lb) - msg) >= msgsz)
        goto name_outside_msg;

      if(lb + tpos >= 256u)
        goto name_buf_full;

      do
      {
        unsigned int tmp_post$8 = tpos;
        tpos = tpos + 1u;
        unsigned char *tmp_post$9 = lptr;
        lptr = lptr + 1l;
        tgt[(signed long int)tmp_post$8] = *tmp_post$9;
        lb = lb - 1u;
      }
      while(!(lb == 0u));
    }
    while((_Bool)1);

  return_OK:
    ;
    *src = *src + (signed long int)(oldsz - newsz);
    *sz = newsz;
    if(!(len == ((unsigned int *)NULL)))
      *len = tpos;

    return 0;
  }

  else
  {

  name_outside_data:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: compressed name extends outside data field.\n");

    return 0xfffe;

  name_outside_msg:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: compressed name extends outside message.\n");

    return 1;

  unsupported_lbl_bits:
    ;
    if(!(debug_p == 0))
      debug_msg(0, lb == (unsigned int)0x41 ? "decompress_name: Bit-string labels not supported.\n" : "decompress_name: unsupported label type.\n");

    return 1;

  offset_outside_msg:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: offset points outside message.\n");

    return 1;

  name_buf_full:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: decompressed name larger than %u bytes.\n", 256);

    return 1;

  too_many_hops:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: too many offsets in compressed name.\n");

    return 1;
  }
}

// decrease_procs
// file dns_answer.c line 1347
static inline void decrease_procs()
{
  pthread_mutex_lock(&proc_lock);
  procs = procs - 1;
  qprocs = qprocs - 1;
  pthread_mutex_unlock(&proc_lock);
}

// del_cache
// file cache.h line 175
void del_cache(const unsigned char *name)
{
  struct anonymous$0 *cent;
  lock_cache_rw();
  cent=del_dns_hash(name);
  if(!(cent == ((struct anonymous$0 *)NULL)))
    del_cent(cent);

  unlock_cache_rw();
}

// del_cache_ent
// file cache.c line 2075
static void del_cache_ent(struct anonymous$0 *cent, struct anonymous$58 *loc)
{
  struct anonymous$0 *data;
  if(!(loc == ((struct anonymous$58 *)NULL)))
    data=del_dns_hash_ent(loc);

  else
    data=del_dns_hash(cent->qname);
  if(data == ((struct anonymous$0 *)NULL))
    log_message(4, "Cache entry not found by del_dns_hash() in %s, line %d", (const void *)"cache.c", 2085);

  else
    if(!(data == cent))
      log_message(4, "pointer returned by del_dns_hash() does not match cache entry in %s, line %d", (const void *)"cache.c", 2088);

  del_cent(cent);
}

// del_cent
// file cache.c line 2061
void del_cent(struct anonymous$0 *cent)
{
  cache_size = cache_size - (volatile signed long int)cent->cs;
  free_cent(cent);
  free((void *)cent);
  ent_num = ent_num - 1l;
}

// del_cent_rrset_by_index
// file cache.c line 776
static signed int del_cent_rrset_by_index(struct anonymous$0 *cent, signed int i)
{
  signed int rv = 0;
  struct anonymous **rrspa;
  struct anonymous **tmp_if_expr$3;
  struct anonymous **tmp_if_expr$2;
  struct anonymous **tmp_if_expr$1;
  if(!((1 & (signed int)cent->flags) == 0))
    tmp_if_expr$3 = (struct anonymous **)(void *)0;

  else
  {
    if(!(i >= 8))
      tmp_if_expr$2 = &cent->$anon0.rr.rrmu[(signed long int)i];

    else
    {
      if(!(cent->$anon0.rr.rrext == ((struct anonymous **)NULL)))
        tmp_if_expr$1 = &cent->$anon0.rr.rrext[(signed long int)(i - 8)];

      else
        tmp_if_expr$1 = (struct anonymous **)(void *)0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }
    tmp_if_expr$3 = tmp_if_expr$2;
  }
  rrspa = tmp_if_expr$3;
  if(!(rrspa == ((struct anonymous **)NULL)))
  {
    struct anonymous *rrs = *rrspa;
    if(!(rrs == ((struct anonymous *)NULL)))
    {
      rv=del_rrset(rrs);
      *rrspa = (struct anonymous *)(void *)0;
      cent->num_rrs = cent->num_rrs - 1;
      cent->cs = cent->cs - (unsigned long int)rv;
      cent->flags = cent->flags & (unsigned short int)~4;
    }

  }

  return rv;
}

// del_dns_hash
// file hash.h line 71
struct anonymous$0 * del_dns_hash(const unsigned char *key)
{
  unsigned int idx;
  unsigned long int rh;
  struct dns_hash_ent_s **hep;
  struct dns_hash_ent_s *he;
  struct anonymous$0 *data;
  idx=dns_hash(key, &rh);
  hep = &hash_buckets[(signed long int)idx];
  signed int return_value_rhnicmp$1;
  do
  {
    he = *hep;
    if(he == ((struct dns_hash_ent_s *)NULL))
      break;

    if(!(rh >= he->rhash))
      break;

    if(he->rhash == rh)
    {
      return_value_rhnicmp$1=rhnicmp$link2(key, he->data->qname);
      if(!(return_value_rhnicmp$1 == 0))
      {
        *hep = he->next;
        data = he->data;
        free((void *)he);
        return data;
      }

    }

    hep = &he->next;
  }
  while((_Bool)1);
  return (struct anonymous$0 *)(void *)0;
}

// del_dns_hash_ent
// file hash.h line 70
struct anonymous$0 * del_dns_hash_ent(struct anonymous$58 *loc)
{
  struct dns_hash_ent_s *he = *loc->pos;
  struct anonymous$0 *data;
  *loc->pos = he->next;
  data = he->data;
  free((void *)he);
  return data;
}

// del_qserv
// file dns_query.c line 2025
static inline void del_qserv(struct anonymous$4 *q)
{
  free((void *)q);
}

// del_rrset
// file cache.h line 202
signed int del_rrset(struct anonymous *rrs)
{
  signed int rv = (signed int)sizeof(struct anonymous) /*40ul*/ ;
  struct rr_b_s *rrb;
  struct rr_b_s *rrn;
  if(!(rrs->lent == ((struct rr_lent_s *)NULL)))
    remove_rrl(rrs->lent);

  rrb = rrs->rrs;
  for( ; !(rrb == ((struct rr_b_s *)NULL)); rrb = rrn)
  {
    rv = rv + (signed int)(sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rrb->rdlen);
    rrn = rrb->next;
    free((void *)rrb);
  }
  free((void *)rrs);
  return rv;
}

// destroy_cache
// file cache.h line 163
void destroy_cache(void)
{
  signed int return_value_softlock_cache_rw$1;
  return_value_softlock_cache_rw$1=softlock_cache_rw();
  if(return_value_softlock_cache_rw$1 == 0)
    log_message(3, "Lock failed; could not destroy cache on exit.");

  else
  {
    free_dns_hash();
    if(!(cache_size == 0l) || !(ent_num == 0l))
    {
      if(!(debug_p == 0))
        debug_msg(0, "After destroying cache, %ld entries (%ld bytes) remaining.\n", ent_num, cache_size);

    }

  }
}

// dev_up
// file netdev.c line 135
signed int dev_up(char *ifname, char *devname)
{
  struct _IO_FILE *fd;
  signed int pidi;
  signed int pidd;
  signed int rv;
  signed long int rv$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(ifname);
  rv$array_size0 = (signed long int)(sizeof(char [14l]) /*14ul*/  + return_value_strlen$1);
  char path[rv$array_size0];
  char *return_value_stpcpy$2;
  return_value_stpcpy$2=stpcpy(path, "/var/run/");
  char *return_value_stpcpy$3;
  return_value_stpcpy$3=stpcpy(return_value_stpcpy$2, ifname);
  stpcpy(return_value_stpcpy$3, ".pid");
  fd=fopen(path, "r");
  _Bool tmp_if_expr$9;
  signed int *return_value___errno_location$8;
  if(fd == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    signed int return_value_fscanf$4;
    return_value_fscanf$4=fscanf(fd, "%d", &pidi);
    if(!(return_value_fscanf$4 == 1))
    {
      fclose(fd);
      return 0;
    }

    else
    {
      fclose(fd);
      signed long int path$array_size0;
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(devname);
      path$array_size0 = (signed long int)(sizeof(char [16l]) /*16ul*/  + return_value_strlen$5);
      char dev_up$$1$$2$$path[path$array_size0];
      char *return_value_stpcpy$6;
      return_value_stpcpy$6=stpcpy(dev_up$$1$$2$$path, "/var/lock/LCK..");
      stpcpy(return_value_stpcpy$6, devname);
      fd=fopen(dev_up$$1$$2$$path, "r");
      if(fd == ((struct _IO_FILE *)NULL))
        return 0;

      else
      {
        signed int return_value_fscanf$7;
        return_value_fscanf$7=fscanf(fd, "%d", &pidd);
        if(!(return_value_fscanf$7 == 1))
        {
          fclose(fd);
          return 0;
        }

        else
        {
          fclose(fd);
          if(!(pidi == pidd))
            return 0;

          else
          {
            rv=kill(pidi, 0);
            _Bool tmp_if_expr$10;
            if(rv == 0)
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              if(rv == -1)
              {
                return_value___errno_location$8=__errno_location();
                tmp_if_expr$9 = *return_value___errno_location$8 != 3 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$9 = (_Bool)0;
              tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
            }
            return (signed int)tmp_if_expr$10;
          }
        }
      }
    }
  }
}

// dlist_first
// file list.h line 87
static inline void * dlist_first(struct _dynamic_list_head *a)
{
  char *tmp_if_expr$1;
  if(!(a == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr$1 = &a->data[(signed long int)sizeof(unsigned long int) /*8ul*/ ];

  else
    tmp_if_expr$1 = (char *)(void *)0;
  return (void *)tmp_if_expr$1;
}

// dlist_first$link1
// file list.h line 87
static inline void * dlist_first$link1(struct _dynamic_list_head *a$link1)
{
  char *tmp_if_expr$1$link1;
  if(!(a$link1 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr$1$link1 = &a$link1->data[(signed long int)sizeof(unsigned long int) /*8ul*/ ];

  else
    tmp_if_expr$1$link1 = (char *)(void *)0;
  return (void *)tmp_if_expr$1$link1;
}

// dlist_first$link2
// file list.h line 87
static inline void * dlist_first$link2(struct _dynamic_list_head *a$link2)
{
  char *tmp_if_expr$1$link2;
  if(!(a$link2 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr$1$link2 = &a$link2->data[(signed long int)sizeof(unsigned long int) /*8ul*/ ];

  else
    tmp_if_expr$1$link2 = (char *)(void *)0;
  return (void *)tmp_if_expr$1$link2;
}

// dlist_grow
// file list.h line 112
struct _dynamic_list_head * dlist_grow(struct _dynamic_list_head *a, unsigned long int len)
{
  unsigned long int sz = (unsigned long int)0;
  unsigned long int allocsz = (unsigned long int)0;
  unsigned long int szincr;
  unsigned long int newsz;
  if(!(a == ((struct _dynamic_list_head *)NULL)))
  {
    sz = a->last + a->lastsz;
    allocsz = sz + (unsigned long int)0x3ff & ~((unsigned long int)0x3ff);
    *((unsigned long int *)&a->data[(signed long int)a->last]) = a->lastsz;
  }

  szincr = len + sizeof(unsigned long int) /*8ul*/  + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1) & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1);
  newsz = sz + szincr;
  if(!(allocsz >= newsz))
  {
    struct _dynamic_list_head *tmp;
    allocsz = newsz + (unsigned long int)0x3ff & ~((unsigned long int)0x3ff);
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)a, sizeof(struct _dynamic_list_head) /*16ul*/  + allocsz);
    tmp = (struct _dynamic_list_head *)return_value_realloc$1;
    if(tmp == ((struct _dynamic_list_head *)NULL))
      free((void *)a);

    a = tmp;
  }

  if(!(a == ((struct _dynamic_list_head *)NULL)))
  {
    a->last = sz;
    a->lastsz = szincr;
    *((unsigned long int *)&a->data[(signed long int)sz]) = (unsigned long int)0;
  }

  return a;
}

// dlist_last
// file list.h line 107
static inline void * dlist_last(struct _dynamic_list_head *a)
{
  char *tmp_if_expr$1;
  if(!(a == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr$1 = &a->data[(signed long int)(a->last + sizeof(unsigned long int) /*8ul*/ )];

  else
    tmp_if_expr$1 = (char *)(void *)0;
  return (void *)tmp_if_expr$1;
}

// dlist_last$link1
// file list.h line 107
static inline void * dlist_last$link1(struct _dynamic_list_head *a$link1)
{
  char *tmp_if_expr$1$link1;
  if(!(a$link1 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr$1$link1 = &a$link1->data[(signed long int)(a$link1->last + sizeof(unsigned long int) /*8ul*/ )];

  else
    tmp_if_expr$1$link1 = (char *)(void *)0;
  return (void *)tmp_if_expr$1$link1;
}

// dlist_last$link2
// file list.h line 107
static inline void * dlist_last$link2(struct _dynamic_list_head *a$link2)
{
  char *tmp_if_expr$1$link2;
  if(!(a$link2 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr$1$link2 = &a$link2->data[(signed long int)(a$link2->last + sizeof(unsigned long int) /*8ul*/ )];

  else
    tmp_if_expr$1$link2 = (char *)(void *)0;
  return (void *)tmp_if_expr$1$link2;
}

// dlist_next
// file list.h line 98
static inline void * dlist_next(void *ref)
{
  unsigned long int incr = *((unsigned long int *)ref - (signed long int)1);
  return (void *)(incr != 0ul ? (char *)ref + (signed long int)incr : (char *)(void *)0);
}

// dlist_next$link1
// file list.h line 98
static inline void * dlist_next$link1(void *ref$link1)
{
  unsigned long int incr$link1 = *((unsigned long int *)ref$link1 - (signed long int)1);
  return (void *)(incr$link1 != 0ul ? (char *)ref$link1 + (signed long int)incr$link1 : (char *)(void *)0);
}

// dlist_next$link2
// file list.h line 98
static inline void * dlist_next$link2(void *ref$link2)
{
  unsigned long int incr$link2 = *((unsigned long int *)ref$link2 - (signed long int)1);
  return (void *)(incr$link2 != 0ul ? (char *)ref$link2 + (signed long int)incr$link2 : (char *)(void *)0);
}

// dns_hash
// file hash.c line 57
static unsigned int dns_hash(const unsigned char *str, unsigned long int *rhash)
{
  unsigned int s;
  unsigned int i;
  unsigned int lb;
  unsigned int c;
  unsigned long int r;
  s = (unsigned int)0;
  r = (unsigned long int)0;
  i = (unsigned int)0;
  do
  {
    lb = (unsigned int)str[(signed long int)i];
    if(lb == 0u)
      break;

    s = s + (lb << i % (unsigned int)(10 - 5));
    r = r + ((unsigned long int)lb << (unsigned long int)i % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/  - (unsigned long int)7));
    i = i + 1u;
    do
    {
      signed int return_value_toupper$1;
      return_value_toupper$1=toupper((signed int)str[(signed long int)i]);
      c = (unsigned int)return_value_toupper$1;
      s = s + (c << i % (unsigned int)(10 - 5));
      r = r + ((unsigned long int)c << (unsigned long int)i % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/  - (unsigned long int)7));
      i = i + 1u;
      lb = lb - 1u;
    }
    while(!(lb == 0u));
  }
  while((_Bool)1);
  s = (s & (unsigned int)((1 << 10) - 1)) + ((s & (unsigned int)~((1 << 10) - 1)) >> 10);
  s = (s & (unsigned int)((1 << 10) - 1)) + ((s & (unsigned int)~((1 << 10) - 1)) >> 10);
  s = s & (unsigned int)((1 << 10) - 1);
  if(!(rhash == ((unsigned long int *)NULL)))
    *rhash = r;

  return s;
}

// dns_lookup
// file hash.h line 68
struct anonymous$0 * dns_lookup(const unsigned char *key, struct anonymous$58 *loc)
{
  struct anonymous$0 *retval = (struct anonymous$0 *)(void *)0;
  unsigned int idx;
  unsigned long int rh;
  struct dns_hash_ent_s **hep;
  struct dns_hash_ent_s *he;
  idx=dns_hash(key, &rh);
  hep = &hash_buckets[(signed long int)idx];
  signed int return_value_rhnicmp$1;
  do
  {
    he = *hep;
    if(he == ((struct dns_hash_ent_s *)NULL))
      break;

    if(!(rh >= he->rhash))
      break;

    if(he->rhash == rh)
    {
      return_value_rhnicmp$1=rhnicmp$link2(key, he->data->qname);
      if(!(return_value_rhnicmp$1 == 0))
      {
        retval = he->data;
        break;
      }

    }

    hep = &he->next;
  }
  while((_Bool)1);
  if(!(loc == ((struct anonymous$58 *)NULL)))
  {
    loc->pos = hep;
    loc->rhash = rh;
  }

  return retval;
}

// dns_rootserver_resolv
// file dns_query.c line 2978
struct anonymous$14 * dns_rootserver_resolv(struct anonymous$19 *atup_a, signed int port, char edns_query, signed long int timeout)
{
  struct anonymous$14 *res = (struct anonymous$14 *)(void *)0;
  struct anonymous$0 *cent;
  signed int rc;
  static const unsigned char rdomain[1l] = { (const unsigned char)0 };
  rc=simple_dns_cached_resolve(atup_a, port, edns_query, timeout, rdomain, 2, &cent);
  const unsigned char *return_value_rhn2str$7;
  const char *return_value_get_ename$8;
  const unsigned char *return_value_rhn2str$9;
  unsigned int return_value_da_nel$12;
  const char *return_value_get_ename$14;
  if(rc == 0)
  {
    struct anonymous *dns_rootserver_resolv$$1$$1$$rrset;
    struct anonymous *tmp_if_expr$1;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr$1 = cent->$anon0.rr.rrmu[(signed long int)1];

    else
      tmp_if_expr$1 = (struct anonymous *)(void *)0;
    dns_rootserver_resolv$$1$$1$$rrset = tmp_if_expr$1;
    if(!(dns_rootserver_resolv$$1$$1$$rrset == ((struct anonymous *)NULL)))
    {
      struct rr_b_s *rr;
      unsigned int nfail = (unsigned int)0;
      rr = dns_rootserver_resolv$$1$$1$$rrset->rrs;
      for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
      {
        struct anonymous$15 serva;
        struct anonymous$0 *servent;
        if(run_ipv4 == 0)
          serva.ipv6 = in6addr_any;

        serva.ipv4.s_addr = (unsigned int)0x00000000;
        rc=simple_dns_cached_resolve(atup_a, port, edns_query, timeout, (const unsigned char *)rr->data, 1, &servent);
        if(rc == 0)
        {
          if(!(run_ipv4 == 0))
          {
            struct anonymous *rrset;
            struct anonymous *tmp_if_expr$2;
            if((1 & (signed int)servent->flags) == 0)
              tmp_if_expr$2 = servent->$anon0.rr.rrmu[(signed long int)0];

            else
              tmp_if_expr$2 = (struct anonymous *)(void *)0;
            rrset = tmp_if_expr$2;
            if(!(rrset == ((struct anonymous *)NULL)))
            {
              if(!(rrset->rrs == ((struct rr_b_s *)NULL)))
                serva.ipv4 = *((struct in_addr *)rrset->rrs->data);

            }

          }

          else
          {
            struct anonymous *dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset;
            struct anonymous *tmp_if_expr$5;
            if((1 & (signed int)servent->flags) == 0)
              tmp_if_expr$5 = servent->$anon0.rr.rrmu[(signed long int)7];

            else
              tmp_if_expr$5 = (struct anonymous *)(void *)0;
            dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset = tmp_if_expr$5;
            _Bool tmp_if_expr$6;
            if(!(dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset == ((struct anonymous *)NULL)))
              tmp_if_expr$6 = dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$6 = (_Bool)0;
            if(tmp_if_expr$6)
            {
              serva.ipv6 = *((struct in6_addr *)dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset->rrs->data);
              struct anonymous *tmp_if_expr$3;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr$3 = servent->$anon0.rr.rrmu[(signed long int)0];

              else
                tmp_if_expr$3 = (struct anonymous *)(void *)0;
              dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset = tmp_if_expr$3;
              if(!(dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset == ((struct anonymous *)NULL)))
              {
                if(!(dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset->rrs == ((struct rr_b_s *)NULL)))
                  serva.ipv4 = *((struct in_addr *)dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset->rrs->data);

              }

            }

            else
            {
              struct anonymous *tmp_if_expr$4;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr$4 = servent->$anon0.rr.rrmu[(signed long int)0];

              else
                tmp_if_expr$4 = (struct anonymous *)(void *)0;
              dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset = tmp_if_expr$4;
              if(!(dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset == ((struct anonymous *)NULL)))
              {
                if(!(dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset->rrs == ((struct rr_b_s *)NULL)))
                {
                  struct in_addr *ina = (struct in_addr *)dns_rootserver_resolv$$1$$1$$1$$1$$1$$1$$2$$rrset->rrs->data;
                  ((unsigned int *)&serva.ipv6)[(signed long int)3] = ina->s_addr;
                  ((unsigned int *)&serva.ipv6)[(signed long int)2]=htonl((unsigned int)0xffff);
                  ((unsigned int *)&serva.ipv6)[(signed long int)0] = (unsigned int)0;
                  ((unsigned int *)&serva.ipv6)[(signed long int)1] = ((unsigned int *)&serva.ipv6)[(signed long int)0];
                }

              }

            }
          }
          free_cent(servent);
          free((void *)servent);
        }

        else
        {
          unsigned char _debugstrbuf[256l];
          if(!(debug_p == 0))
          {
            return_value_rhn2str$7=rhn2str((const unsigned char *)rr->data, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            return_value_get_ename$8=get_ename(rc);
            debug_msg(0, "Simple query for %s type A failed (rc: %s)\n", return_value_rhn2str$7, return_value_get_ename$8);
          }

        }
        signed int return_value_is_inaddr2_any$10;
        return_value_is_inaddr2_any$10=is_inaddr2_any(&serva);
        if(!(return_value_is_inaddr2_any$10 == 0))
        {
          unsigned char dns_rootserver_resolv$$1$$1$$1$$1$$1$$3$$1$$_debugstrbuf[256l];
          if(!(debug_p == 0))
          {
            return_value_rhn2str$9=rhn2str((const unsigned char *)rr->data, dns_rootserver_resolv$$1$$1$$1$$1$$1$$3$$1$$_debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            debug_msg(0, "Failed to obtain address of root server %s in dns_rootserver_resolv()\n", return_value_rhn2str$9);
          }

          nfail = nfail + 1u;
        }

        else
        {
          struct anonymous$3 *return_value_da_grow1$11;
          return_value_da_grow1$11=da_grow1((struct anonymous$3 *)res, (unsigned long int)((struct anonymous$14 *)0)->elem, sizeof(struct anonymous$15) /*20ul*/ , (void (*)(void *))(void *)0);
          res = (struct anonymous$14 *)return_value_da_grow1$11;
          if(res == ((struct anonymous$14 *)NULL))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Out of memory in dns_rootserver_resolv()\n");

            goto free_cent_return;
          }

          res->elem[(signed long int)(res->nel - (unsigned long int)1)] = serva;
        }
      }
      unsigned int return_value_da_nel$13;
      return_value_da_nel$13=da_nel$link2((struct anonymous$3 *)res);
      if(!(return_value_da_nel$13 >= nfail))
      {
        if(!(debug_p == 0))
        {
          return_value_da_nel$12=da_nel$link2((struct anonymous$3 *)res);
          debug_msg(0, "Too many root-server resolve failures (%u succeeded, %u failed), rejecting the result.\n", return_value_da_nel$12, nfail);
        }

        free((void *)res);
        res = (struct anonymous$14 *)(void *)0;
      }

    }


  free_cent_return:
    ;
    free_cent(cent);
    free((void *)cent);
  }

  else
    if(!(debug_p == 0))
    {
      return_value_get_ename$14=get_ename(rc);
      debug_msg(0, "Simple query for root domain type NS failed (rc: %s)\n", return_value_get_ename$14);
    }

  return res;
}

// dnsflags2str
// file dns.c line 544
char * dnsflags2str(struct anonymous$29 *hdr, char *buf)
{
  char *p = buf;
  void *return_value_mempcpy$1;
  if(!(hdr->aa == 0u))
  {
    return_value_mempcpy$1=mempcpy((void *)p, (const void *)" AA", (unsigned long int)3);
    p = (char *)return_value_mempcpy$1;
  }

  void *return_value_mempcpy$2;
  if(!(hdr->tc == 0u))
  {
    return_value_mempcpy$2=mempcpy((void *)p, (const void *)" TC", (unsigned long int)3);
    p = (char *)return_value_mempcpy$2;
  }

  void *return_value_mempcpy$3;
  if(!(hdr->rd == 0u))
  {
    return_value_mempcpy$3=mempcpy((void *)p, (const void *)" RD", (unsigned long int)3);
    p = (char *)return_value_mempcpy$3;
  }

  void *return_value_mempcpy$4;
  if(!(hdr->ra == 0u))
  {
    return_value_mempcpy$4=mempcpy((void *)p, (const void *)" RA", (unsigned long int)3);
    p = (char *)return_value_mempcpy$4;
  }

  void *return_value_mempcpy$5;
  if(!(hdr->z == 0u))
  {
    return_value_mempcpy$5=mempcpy((void *)p, (const void *)" Z", (unsigned long int)2);
    p = (char *)return_value_mempcpy$5;
  }

  void *return_value_mempcpy$6;
  if(!(hdr->ad == 0u))
  {
    return_value_mempcpy$6=mempcpy((void *)p, (const void *)" AD", (unsigned long int)3);
    p = (char *)return_value_mempcpy$6;
  }

  void *return_value_mempcpy$7;
  if(!(hdr->cd == 0u))
  {
    return_value_mempcpy$7=mempcpy((void *)p, (const void *)" CD", (unsigned long int)3);
    p = (char *)return_value_mempcpy$7;
  }

  *p = (char)0;
  return buf;
}

// domain_match
// file dns.c line 204
unsigned int domain_match(const unsigned char *ms, const unsigned char *md, unsigned int *os, unsigned int *od)
{
  unsigned int i;
  unsigned int j;
  unsigned int k;
  unsigned int n;
  unsigned int ns = (unsigned int)0;
  unsigned int nd = (unsigned int)0;
  unsigned int offs;
  unsigned int offd;
  unsigned char lb;
  unsigned char ls[128l];
  unsigned char ld[128l];
  i = (unsigned int)0;
  do
  {
    lb = ms[(signed long int)i];
    if(lb == 0)
      break;

    if(ns >= 128u)
    {
      log_message(3, "%s:%d: %s", (const void *)"dns.c", 212, (const void *)"domain_match: too many name segments");
      pdnsd_exit();
    }

    unsigned int tmp_post$1 = ns;
    ns = ns + 1u;
    ls[(signed long int)tmp_post$1] = lb;
    i = i + (unsigned int)lb + (unsigned int)1;
  }
  while((_Bool)1);
  j = (unsigned int)0;
  do
  {
    lb = md[(signed long int)j];
    if(lb == 0)
      break;

    if(nd >= 128u)
    {
      log_message(3, "%s:%d: %s", (const void *)"dns.c", 219, (const void *)"domain_match: too many name segments");
      pdnsd_exit();
    }

    unsigned int tmp_post$2 = nd;
    nd = nd + 1u;
    ld[(signed long int)tmp_post$2] = lb;
    j = j + (unsigned int)lb + (unsigned int)1;
  }
  while((_Bool)1);
  n = ns;
  if(!(nd >= n))
    n = nd;

  k = (unsigned int)1;
  signed int return_value_tolower$3;
  signed int return_value_tolower$4;
  do
  {
    offs = i;
    offd = j;
    if(!(n >= k))
      break;

    lb = ls[(signed long int)(ns - k)];
    if(!(lb == ld[(signed long int)(nd + -k)]))
      break;

    for( ; !(lb == 0); lb = lb - 1)
    {
      i = i - 1u;
      return_value_tolower$3=tolower((signed int)ms[(signed long int)i]);
      j = j - 1u;
      return_value_tolower$4=tolower((signed int)md[(signed long int)j]);
      if(!(return_value_tolower$3 == return_value_tolower$4))
        goto mismatch;

    }
    i = i - 1u;
    j = j - 1u;
    k = k + 1u;
  }
  while((_Bool)1);

mismatch:
  ;
  if(!(os == ((unsigned int *)NULL)))
    *os = offs;

  if(!(od == ((unsigned int *)NULL)))
    *od = offd;

  return k - (unsigned int)1;
}

// dump_cache
// file cache.h line 168
signed int dump_cache(signed int fd, const unsigned char *name, signed int exact)
{
  signed int rv = 0;
  lock_cache_r();
  if(!(name == ((const unsigned char *)NULL)) && !(exact == 0))
  {
    struct anonymous$0 *cent;
    cent=dns_lookup(name, (struct anonymous$58 *)(void *)0);
    if(!(cent == ((struct anonymous$0 *)NULL)))
      rv=dump_cent(fd, cent);

  }

  else
  {
    struct anonymous$0 *dump_cache$$1$$2$$cent;
    struct anonymous$59 pos;
    dump_cache$$1$$2$$cent=fetch_first(&pos);
    while(!(dump_cache$$1$$2$$cent == ((struct anonymous$0 *)NULL)))
    {
      unsigned int nrem;
      _Bool tmp_if_expr$1;
      if(name == ((const unsigned char *)NULL))
        tmp_if_expr$1 = (_Bool)1;

      else
      {
        domain_match(name, dump_cache$$1$$2$$cent->qname, &nrem, (unsigned int *)(void *)0);
        tmp_if_expr$1 = nrem == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$1)
      {
        rv=dump_cent(fd, dump_cache$$1$$2$$cent);
        if(!(rv >= 0))
          break;

      }

      dump_cache$$1$$2$$cent=fetch_next(&pos);
    }
  }
  unlock_cache_r();
  return rv;
}

// dump_cent
// file cache.c line 2395
static signed int dump_cent(signed int fd, struct anonymous$0 *cent)
{
  signed long int now;
  char tstr[(signed long int)sizeof(char [20l]) /*20l*/ ];
  char dbuf[1024l];
  signed int dump_cent$$1$$1$$_retval;
  const unsigned char *return_value_rhn2str$1;
  return_value_rhn2str$1=rhn2str(cent->qname, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
  dump_cent$$1$$1$$_retval=fsprintf(fd, "%s\n", return_value_rhn2str$1);
  struct tm *return_value_localtime_r$2;
  _Bool tmp_if_expr$4;
  unsigned long int return_value_strftime$5;
  const unsigned short int *tmp_if_expr$8;
  struct tm *return_value_localtime_r$10;
  _Bool tmp_if_expr$12;
  unsigned long int return_value_strftime$13;
  const char *return_value_loc2str$70;
  const char *return_value_inet_ntop$71;
  const char *return_value_inet_ntop$72;
  if(!(dump_cent$$1$$1$$_retval >= 0))
    return dump_cent$$1$$1$$_retval;

  else
  {
    now=time((signed long int *)(void *)0);
    if(!((1 & (signed int)cent->flags) == 0))
    {
      struct tm tstm;
      _Bool tmp_if_expr$3;
      if(!(cent->$anon0.neg.ts == 0l))
      {
        return_value_localtime_r$2=localtime_r(&cent->$anon0.neg.ts, &tstm);
        tmp_if_expr$3 = return_value_localtime_r$2 != ((struct tm *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      _Bool tmp_if_expr$6;
      if(tmp_if_expr$3)
      {
        if(now >= cent->$anon0.neg.ts)
          tmp_if_expr$4 = now - cent->$anon0.neg.ts < (signed long int)((365 * 24 * 60 * 60) / 2) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        return_value_strftime$5=strftime(tstr, sizeof(char [20l]) /*20ul*/ , tmp_if_expr$4 ? "    %m/%d %T" : "%Y/%m/%d %T", &tstm);
        tmp_if_expr$6 = return_value_strftime$5 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        strcpy(tstr, "                  ");

      signed int dump_cent$$1$$2$$2$$_retval;
      dump_cent$$1$$2$$2$$_retval=fsprintf(fd, "%s    (domain negated)\n", (const void *)tstr);
      if(!(dump_cent$$1$$2$$2$$_retval >= 0))
        return dump_cent$$1$$2$$2$$_retval;

    }

    else
    {
      signed int i;
      signed int dump_cent$$1$$3$$n;
      signed int tmp_if_expr$7;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr$7 = 0;

      else
        tmp_if_expr$7 = cent->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      dump_cent$$1$$3$$n = tmp_if_expr$7;
      const unsigned short int *iterlist;
      const unsigned short int *tmp_if_expr$9;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr$9 = (const unsigned short int *)(void *)0;

      else
      {
        if(!(cent->$anon0.rr.rrext == ((struct anonymous **)NULL)))
          tmp_if_expr$8 = rrcachiterlist;

        else
          tmp_if_expr$8 = rrmuiterlist;
        tmp_if_expr$9 = tmp_if_expr$8;
      }
      iterlist = tmp_if_expr$9;
      i = 0;
      for( ; !(i >= dump_cent$$1$$3$$n); i = i + 1)
      {
        signed int tp = (signed int)iterlist[(signed long int)i];
        struct anonymous *rrset;
        rrset=getrrset_eff$link3(cent, tp);
        if(!(rrset == ((struct anonymous *)NULL)))
        {
          struct tm dump_cent$$1$$3$$1$$1$$1$$1$$tstm;
          _Bool tmp_if_expr$11;
          if(!(rrset->ts == 0l))
          {
            return_value_localtime_r$10=localtime_r(&rrset->ts, &dump_cent$$1$$3$$1$$1$$1$$1$$tstm);
            tmp_if_expr$11 = return_value_localtime_r$10 != ((struct tm *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$11 = (_Bool)0;
          _Bool tmp_if_expr$14;
          if(tmp_if_expr$11)
          {
            if(now >= rrset->ts)
              tmp_if_expr$12 = now - rrset->ts < (signed long int)((365 * 24 * 60 * 60) / 2) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$12 = (_Bool)0;
            return_value_strftime$13=strftime(tstr, sizeof(char [20l]) /*20ul*/ , tmp_if_expr$12 ? "    %m/%d %T" : "%Y/%m/%d %T", &dump_cent$$1$$3$$1$$1$$1$$1$$tstm);
            tmp_if_expr$14 = return_value_strftime$13 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$14 = (_Bool)0;
          if(!tmp_if_expr$14)
            strcpy(tstr, "                  ");

          if(!((1 & (signed int)rrset->flags) == 0))
          {
            signed int dump_cent$$1$$3$$1$$1$$1$$2$$1$$_retval;
            dump_cent$$1$$3$$1$$1$$1$$2$$1$$_retval=fsprintf(fd, "%s    %-7s (negated)\n", (const void *)tstr, rrnames[(signed long int)(tp - 1)]);
            if(!(dump_cent$$1$$3$$1$$1$$1$$2$$1$$_retval >= 0))
              return dump_cent$$1$$3$$1$$1$$1$$2$$1$$_retval;

          }

          else
          {
            struct rr_b_s *rr = rrset->rrs;
            for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
            {
              switch(tp)
              {
                case 5:

                case 7:

                case 3:

                case 4:

                case 8:

                case 9:

                case 2:

                case 12:
                {
                  rhn2str((unsigned char *)rr->data, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  break;
                }
                case 14:

                case 17:
                {
                  unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$p = (unsigned char *)rr->data;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n;
                  rhn2str(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$p, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  unsigned long int return_value_strlen$15;
                  return_value_strlen$15=strlen(dbuf);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n = (signed int)return_value_strlen$15;
                  signed int tmp_post$16 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n + 1;
                  dbuf[(signed long int)tmp_post$16] = (char)32;
                  if((unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n >= sizeof(char [1024l]) /*1024ul*/ )
                    goto hex_dump;

                  unsigned char *return_value_skiprhn$17;
                  return_value_skiprhn$17=skiprhn$link2(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$p);
                  rhn2str(return_value_skiprhn$17, (unsigned char *)dbuf + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n, (unsigned int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$1$$n));
                  break;
                }
                case 15:

                case 18:

                case 21:

                case 36:
                {
                  unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$p = (unsigned char *)rr->data;
                  unsigned int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$pref;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$n;
                  do
                  {
                    unsigned short int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_s;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$p;
                    const unsigned char *tmp_post$18 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$18 << 8);
                    const unsigned char *tmp_post$19 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_s = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_s | (unsigned short int)*tmp_post$19;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$pref = (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_s;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$1$$t_cp;
                  }
                  while((_Bool)0);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$n=sprintf(dbuf, "%u ", dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$pref);
                  if(!(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$n >= 0))
                    goto hex_dump;

                  rhn2str(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$p, (unsigned char *)dbuf + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$n, (unsigned int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$2$$n));
                  break;
                }
                case 6:
                {
                  unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p = (unsigned char *)rr->data;
                  char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem;
                  unsigned int serial;
                  unsigned int refresh;
                  unsigned int retry;
                  unsigned int expire;
                  unsigned int minimum;
                  rhn2str(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  unsigned long int return_value_strlen$20;
                  return_value_strlen$20=strlen(dbuf);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n = (signed int)return_value_strlen$20;
                  signed int tmp_post$21 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n + 1;
                  dbuf[(signed long int)tmp_post$21] = (char)32;
                  if((unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n >= sizeof(char [1024l]) /*1024ul*/ )
                    goto hex_dump;

                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q = dbuf + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p=skiprhn$link2(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p);
                  rhn2str(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p, (unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q, (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem);
                  unsigned long int return_value_strlen$22;
                  return_value_strlen$22=strlen(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n = (signed int)return_value_strlen$22;
                  signed int tmp_post$23 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n + 1;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q[(signed long int)tmp_post$23] = (char)32;
                  if(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n >= dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem)
                    goto hex_dump;

                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem - dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p=skiprhn$link2(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p);
                  do
                  {
                    unsigned int t_l;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p;
                    const unsigned char *tmp_post$24 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp + 1l;
                    t_l = (unsigned int)*tmp_post$24 << 24;
                    const unsigned char *tmp_post$25 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp + 1l;
                    t_l = t_l | (unsigned int)*tmp_post$25 << 16;
                    const unsigned char *tmp_post$26 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp + 1l;
                    t_l = t_l | (unsigned int)*tmp_post$26 << 8;
                    const unsigned char *tmp_post$27 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp + 1l;
                    t_l = t_l | (unsigned int)*tmp_post$27;
                    serial = t_l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$1$$t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p;
                    const unsigned char *tmp_post$28 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l = (unsigned int)*tmp_post$28 << 24;
                    const unsigned char *tmp_post$29 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l | (unsigned int)*tmp_post$29 << 16;
                    const unsigned char *tmp_post$30 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l | (unsigned int)*tmp_post$30 << 8;
                    const unsigned char *tmp_post$31 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l | (unsigned int)*tmp_post$31;
                    refresh = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$2$$t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p;
                    const unsigned char *tmp_post$32 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l = (unsigned int)*tmp_post$32 << 24;
                    const unsigned char *tmp_post$33 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l | (unsigned int)*tmp_post$33 << 16;
                    const unsigned char *tmp_post$34 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l | (unsigned int)*tmp_post$34 << 8;
                    const unsigned char *tmp_post$35 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l | (unsigned int)*tmp_post$35;
                    retry = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$3$$t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p;
                    const unsigned char *tmp_post$36 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l = (unsigned int)*tmp_post$36 << 24;
                    const unsigned char *tmp_post$37 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l | (unsigned int)*tmp_post$37 << 16;
                    const unsigned char *tmp_post$38 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l | (unsigned int)*tmp_post$38 << 8;
                    const unsigned char *tmp_post$39 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l | (unsigned int)*tmp_post$39;
                    expire = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$4$$t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p;
                    const unsigned char *tmp_post$40 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l = (unsigned int)*tmp_post$40 << 24;
                    const unsigned char *tmp_post$41 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l | (unsigned int)*tmp_post$41 << 16;
                    const unsigned char *tmp_post$42 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l | (unsigned int)*tmp_post$42 << 8;
                    const unsigned char *tmp_post$43 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l | (unsigned int)*tmp_post$43;
                    minimum = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$5$$t_cp;
                  }
                  while((_Bool)0);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n=snprintf(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$q, (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem, "%lu %lu %lu %lu %lu", (unsigned long int)serial, (unsigned long int)refresh, (unsigned long int)retry, (unsigned long int)expire, (unsigned long int)minimum);
                  if(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n >= dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$rem || !(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$3$$n >= 0))
                    goto hex_dump;

                  break;
                }
                case 13:

                case 16:
                {
                  unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$4$$p = (unsigned char *)rr->data;
                  char *q = dbuf;
                  signed int j = 0;
                  signed int n;
                  signed int rem = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
                  while(!((unsigned int)j >= rr->rdlen))
                  {
                    unsigned int lb;
                    if(!(rem >= 3))
                      goto hex_dump;

                    if(!(j == 0))
                    {
                      char *tmp_post$44 = q;
                      q = q + 1l;
                      *tmp_post$44 = (char)32;
                      rem = rem - 1;
                    }

                    char *tmp_post$45 = q;
                    q = q + 1l;
                    *tmp_post$45 = (char)34;
                    rem = rem - 1;
                    unsigned char *tmp_post$46 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$4$$p;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$4$$p = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$4$$p + 1l;
                    lb = (unsigned int)*tmp_post$46;
                    j = j + (signed int)(lb + (unsigned int)1);
                    if(!(rr->rdlen >= (unsigned int)j))
                      goto hex_dump;

                    n=escapestr((char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$4$$p, (signed int)lb, q, rem);
                    if(1 + n >= rem || !(n >= 0))
                      goto hex_dump;

                    q = q + (signed long int)n;
                    char *tmp_post$47 = q;
                    q = q + 1l;
                    *tmp_post$47 = (char)34;
                    rem = rem - (n + 1);
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$4$$p = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$4$$p + (signed long int)lb;
                  }
                  *q = (char)0;
                  break;
                }
                case 26:
                {
                  unsigned char *p = (unsigned char *)rr->data;
                  char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$q;
                  unsigned int pref;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$rem;
                  do
                  {
                    unsigned short int t_s;
                    const unsigned char *t_cp = (const unsigned char *)p;
                    const unsigned char *tmp_post$48 = t_cp;
                    t_cp = t_cp + 1l;
                    t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$48 << 8);
                    const unsigned char *tmp_post$49 = t_cp;
                    t_cp = t_cp + 1l;
                    t_s = t_s | (unsigned short int)*tmp_post$49;
                    pref = (unsigned int)t_s;
                    p = (unsigned char *)(void *)t_cp;
                  }
                  while((_Bool)0);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n=sprintf(dbuf, "%u ", pref);
                  if(!(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n >= 0))
                    goto hex_dump;

                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$q = dbuf + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$rem = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n);
                  rhn2str(p, (unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$q, (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$rem);
                  unsigned long int return_value_strlen$50;
                  return_value_strlen$50=strlen(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$q);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n = (signed int)return_value_strlen$50;
                  signed int tmp_post$51 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n + 1;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$q[(signed long int)tmp_post$51] = (char)32;
                  if(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n >= dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$rem)
                    goto hex_dump;

                  unsigned char *return_value_skiprhn$52;
                  return_value_skiprhn$52=skiprhn$link2(p);
                  rhn2str(return_value_skiprhn$52, (unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$q + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n, (unsigned int)(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$rem - dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$5$$n));
                  break;
                }
                case 33:
                {
                  unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p = (unsigned char *)rr->data;
                  unsigned int priority;
                  unsigned int weight;
                  unsigned int port;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$n;
                  do
                  {
                    unsigned short int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_s;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p;
                    const unsigned char *tmp_post$53 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$53 << 8);
                    const unsigned char *tmp_post$54 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_s = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_s | (unsigned short int)*tmp_post$54;
                    priority = (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_s;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$1$$t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned short int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_s;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p;
                    const unsigned char *tmp_post$55 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$55 << 8);
                    const unsigned char *tmp_post$56 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_s = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_s | (unsigned short int)*tmp_post$56;
                    weight = (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_s;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$2$$t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned short int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_s;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p;
                    const unsigned char *tmp_post$57 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$57 << 8);
                    const unsigned char *tmp_post$58 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_s = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_s | (unsigned short int)*tmp_post$58;
                    port = (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_s;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$3$$t_cp;
                  }
                  while((_Bool)0);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$n=sprintf(dbuf, "%u %u %u ", priority, weight, port);
                  if(!(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$n >= 0))
                    goto hex_dump;

                  rhn2str(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$p, (unsigned char *)dbuf + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$n, (unsigned int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$6$$n));
                  break;
                }
                case 30:
                {
                  unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$p = (unsigned char *)rr->data;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n;
                  signed int rlen;
                  rhn2str(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$p, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  unsigned long int return_value_strlen$59;
                  return_value_strlen$59=strlen(dbuf);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n = (signed int)return_value_strlen$59;
                  signed int tmp_post$60 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n + 1;
                  dbuf[(signed long int)tmp_post$60] = (char)32;
                  if((unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n >= sizeof(char [1024l]) /*1024ul*/ )
                    goto hex_dump;

                  unsigned int return_value_rhnlen$61;
                  return_value_rhnlen$61=rhnlen$link6(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$p);
                  rlen = (signed int)return_value_rhnlen$61;
                  hexdump((const void *)(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$p + (signed long int)rlen), (signed int)(rr->rdlen - (unsigned int)rlen), dbuf + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n, (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$7$$n));
                  break;
                }
                case 35:
                {
                  unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p = (unsigned char *)rr->data;
                  char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q;
                  unsigned int order;
                  unsigned int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$pref;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem;
                  signed int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$j;
                  do
                  {
                    unsigned short int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_s;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p;
                    const unsigned char *tmp_post$62 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$62 << 8);
                    const unsigned char *tmp_post$63 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_s = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_s | (unsigned short int)*tmp_post$63;
                    order = (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_s;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$1$$t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned short int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_s;
                    const unsigned char *dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp = (const unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p;
                    const unsigned char *tmp_post$64 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$64 << 8);
                    const unsigned char *tmp_post$65 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_s = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_s | (unsigned short int)*tmp_post$65;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$pref = (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_s;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p = (unsigned char *)(void *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$2$$t_cp;
                  }
                  while((_Bool)0);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n=sprintf(dbuf, "%u %u ", order, dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$pref);
                  if(!(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n >= 0))
                    goto hex_dump;

                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q = dbuf + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n;
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n);
                  dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$j = 0;
                  for( ; !(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$j >= 3); dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$j = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$j + 1)
                  {
                    unsigned int dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$3$$1$$lb;
                    if(!(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem >= 2))
                      goto hex_dump;

                    char *tmp_post$66 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q + 1l;
                    *tmp_post$66 = (char)34;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem - 1;
                    unsigned char *tmp_post$67 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p + 1l;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$3$$1$$lb = (unsigned int)*tmp_post$67;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n=escapestr((char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p, (signed int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$3$$1$$lb, dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q, dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem);
                    if(2 + dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n >= dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem || !(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n >= 0))
                      goto hex_dump;

                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n;
                    char *tmp_post$68 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q + 1l;
                    *tmp_post$68 = (char)34;
                    char *tmp_post$69 = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q + 1l;
                    *tmp_post$69 = (char)32;
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem - (dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$n + 2);
                    dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p = dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p + (signed long int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$3$$1$$lb;
                  }
                  rhn2str(dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$p, (unsigned char *)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$q, (unsigned int)dump_cent$$1$$3$$1$$1$$1$$3$$1$$1$$1$$8$$rem);
                  break;
                }
                case 29:
                {
                  if(!(rr->rdlen == 16u))
                    goto hex_dump;

                  return_value_loc2str$70=loc2str((const void *)rr->data, dbuf, sizeof(char [1024l]) /*1024ul*/ );
                  if(return_value_loc2str$70 == ((const char *)NULL))
                    goto hex_dump;

                  break;
                }
                case 1:
                {
                  return_value_inet_ntop$71=inet_ntop(2, (const void *)rr->data, dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  if(return_value_inet_ntop$71 == ((const char *)NULL))
                    goto hex_dump;

                  break;
                }
                case 28:
                {
                  return_value_inet_ntop$72=inet_ntop(10, (const void *)rr->data, dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  if(!(return_value_inet_ntop$72 == ((const char *)NULL)))
                    break;

                }
                default:
                {

                hex_dump:
                  ;
                  hexdump((const void *)rr->data, (signed int)rr->rdlen, dbuf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
                }
              }
              signed int _retval;
              _retval=fsprintf(fd, "%s    %-7s %s\n", (const void *)tstr, rrnames[(signed long int)(tp - 1)], (const void *)dbuf);
              if(!(_retval >= 0))
                return _retval;

            }
          }
        }

      }
    }
    signed int dump_cent$$1$$4$$_retval;
    dump_cent$$1$$4$$_retval=fsprintf(fd, "\n");
    if(!(dump_cent$$1$$4$$_retval >= 0))
      return dump_cent$$1$$4$$_retval;

    else
      return 1;
  }
}

// empty_cache
// file cache.h line 162
signed int empty_cache(struct anonymous$8 *sla)
{
  signed int i;
  signed int return_value_timedlock_cache_rw$1;
  return_value_timedlock_cache_rw$1=timedlock_cache_rw(60);
  if(return_value_timedlock_cache_rw$1 == 0)
    return 0;

  else
  {
    i = 0;
    while((_Bool)1)
    {
      if(!(sla == ((struct anonymous$8 *)NULL)))
        free_dns_hash_selected(i, sla);

      else
        free_dns_hash_bucket(i);
      i = i + 1;
      if(i >= 1024)
        break;

      yield_lock_cache_rw();
    }
    unlock_cache_rw();
    return 1;
  }
}

// equiv_inaddr2
// file helpers.h line 149
static inline signed int equiv_inaddr2(union anonymous$6 *a, struct anonymous$15 *b)
{
  signed int tmp_if_expr$10;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$5;
  unsigned int return_value_htonl$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  if(!(run_ipv4 == 0))
    tmp_if_expr$10 = (signed int)(a->ipv4.s_addr == b->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a->ipv6) == *((unsigned int *)&b->ipv6))
      tmp_if_expr$1 = ((unsigned int *)&a->ipv6)[(signed long int)1] == ((unsigned int *)&b->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ((unsigned int *)&a->ipv6)[(signed long int)2] == ((unsigned int *)&b->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = ((unsigned int *)&a->ipv6)[(signed long int)3] == ((unsigned int *)&b->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      if(!(b->ipv4.s_addr == 0u))
      {
        if(((unsigned int *)&a->ipv6)[3l] == b->ipv4.s_addr)
        {
          return_value_htonl$4=htonl((unsigned int)0xffff);
          tmp_if_expr$5 = ((unsigned int *)&a->ipv6)[(signed long int)2] == return_value_htonl$4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = ((unsigned int *)&a->ipv6)[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = ((unsigned int *)&a->ipv6)[(signed long int)0] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr$10 = (signed int)tmp_if_expr$9;
  }
  return tmp_if_expr$10;
}

// equiv_inaddr2$link1
// file helpers.h line 149
static inline signed int equiv_inaddr2$link1(union anonymous$6 *a$link1, struct anonymous$15 *b$link1)
{
  signed int tmp_if_expr$10$link1;
  _Bool tmp_if_expr$1$link1;
  _Bool tmp_if_expr$2$link1;
  _Bool tmp_if_expr$3$link1;
  _Bool tmp_if_expr$9$link1;
  _Bool tmp_if_expr$8$link1;
  _Bool tmp_if_expr$5$link1;
  unsigned int return_value_htonl$4$link1;
  _Bool tmp_if_expr$6$link1;
  _Bool tmp_if_expr$7$link1;
  if(!(run_ipv4 == 0))
    tmp_if_expr$10$link1 = (signed int)(a$link1->ipv4.s_addr == b$link1->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a$link1->ipv6) == *((unsigned int *)&b$link1->ipv6))
      tmp_if_expr$1$link1 = ((unsigned int *)&a$link1->ipv6)[(signed long int)1] == ((unsigned int *)&b$link1->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1$link1 = (_Bool)0;
    if(tmp_if_expr$1$link1)
      tmp_if_expr$2$link1 = ((unsigned int *)&a$link1->ipv6)[(signed long int)2] == ((unsigned int *)&b$link1->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2$link1 = (_Bool)0;
    if(tmp_if_expr$2$link1)
      tmp_if_expr$3$link1 = ((unsigned int *)&a$link1->ipv6)[(signed long int)3] == ((unsigned int *)&b$link1->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3$link1 = (_Bool)0;
    if(tmp_if_expr$3$link1)
      tmp_if_expr$9$link1 = (_Bool)1;

    else
    {
      if(!(b$link1->ipv4.s_addr == 0u))
      {
        if(((unsigned int *)&a$link1->ipv6)[3l] == b$link1->ipv4.s_addr)
        {
          return_value_htonl$4$link1=htonl((unsigned int)0xffff);
          tmp_if_expr$5$link1 = ((unsigned int *)&a$link1->ipv6)[(signed long int)2] == return_value_htonl$4$link1 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5$link1 = (_Bool)0;
        if(tmp_if_expr$5$link1)
          tmp_if_expr$6$link1 = ((unsigned int *)&a$link1->ipv6)[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6$link1 = (_Bool)0;
        if(tmp_if_expr$6$link1)
          tmp_if_expr$7$link1 = ((unsigned int *)&a$link1->ipv6)[(signed long int)0] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7$link1 = (_Bool)0;
        tmp_if_expr$8$link1 = tmp_if_expr$7$link1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8$link1 = (_Bool)0;
      tmp_if_expr$9$link1 = tmp_if_expr$8$link1 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr$10$link1 = (signed int)tmp_if_expr$9$link1;
  }
  return tmp_if_expr$10$link1;
}

// equiv_inaddr2$link2
// file helpers.h line 149
static inline signed int equiv_inaddr2$link2(union anonymous$6 *a$link2, struct anonymous$15 *b$link2)
{
  signed int tmp_if_expr$10$link2;
  _Bool tmp_if_expr$1$link2;
  _Bool tmp_if_expr$2$link2;
  _Bool tmp_if_expr$3$link2;
  _Bool tmp_if_expr$9$link2;
  _Bool tmp_if_expr$8$link2;
  _Bool tmp_if_expr$5$link2;
  unsigned int return_value_htonl$4$link2;
  _Bool tmp_if_expr$6$link2;
  _Bool tmp_if_expr$7$link2;
  if(!(run_ipv4 == 0))
    tmp_if_expr$10$link2 = (signed int)(a$link2->ipv4.s_addr == b$link2->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a$link2->ipv6) == *((unsigned int *)&b$link2->ipv6))
      tmp_if_expr$1$link2 = ((unsigned int *)&a$link2->ipv6)[(signed long int)1] == ((unsigned int *)&b$link2->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1$link2 = (_Bool)0;
    if(tmp_if_expr$1$link2)
      tmp_if_expr$2$link2 = ((unsigned int *)&a$link2->ipv6)[(signed long int)2] == ((unsigned int *)&b$link2->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2$link2 = (_Bool)0;
    if(tmp_if_expr$2$link2)
      tmp_if_expr$3$link2 = ((unsigned int *)&a$link2->ipv6)[(signed long int)3] == ((unsigned int *)&b$link2->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3$link2 = (_Bool)0;
    if(tmp_if_expr$3$link2)
      tmp_if_expr$9$link2 = (_Bool)1;

    else
    {
      if(!(b$link2->ipv4.s_addr == 0u))
      {
        if(((unsigned int *)&a$link2->ipv6)[3l] == b$link2->ipv4.s_addr)
        {
          return_value_htonl$4$link2=htonl((unsigned int)0xffff);
          tmp_if_expr$5$link2 = ((unsigned int *)&a$link2->ipv6)[(signed long int)2] == return_value_htonl$4$link2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5$link2 = (_Bool)0;
        if(tmp_if_expr$5$link2)
          tmp_if_expr$6$link2 = ((unsigned int *)&a$link2->ipv6)[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6$link2 = (_Bool)0;
        if(tmp_if_expr$6$link2)
          tmp_if_expr$7$link2 = ((unsigned int *)&a$link2->ipv6)[(signed long int)0] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7$link2 = (_Bool)0;
        tmp_if_expr$8$link2 = tmp_if_expr$7$link2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8$link2 = (_Bool)0;
      tmp_if_expr$9$link2 = tmp_if_expr$8$link2 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr$10$link2 = (signed int)tmp_if_expr$9$link2;
  }
  return tmp_if_expr$10$link2;
}

// escapestr
// file helpers.c line 583
signed int escapestr(const char *in, signed int ilen, char *str, signed int size)
{
  signed int i;
  signed int j = 0;
  i = 0;
  for( ; !(i >= ilen); i = i + 1)
  {
    unsigned char c;
    if(1 + j >= size)
      return -1;

    c = (unsigned char)in[(signed long int)i];
    const unsigned short int **return_value___ctype_b_loc$3;
    return_value___ctype_b_loc$3=__ctype_b_loc();
    if((16384 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)c]) == 0)
    {
      signed int rem = size - j;
      signed int n;
      n=snprintf(&str[(signed long int)j], (unsigned long int)rem, "\\%03o", c);
      if(n >= rem || !(n >= 0))
        return -1;

      j = j + n;
    }

    else
    {
      if((signed int)c == 34 || (signed int)c == 92)
      {
        signed int tmp_post$1 = j;
        j = j + 1;
        str[(signed long int)tmp_post$1] = (char)92;
        if(1 + j >= size)
          return -1;

      }

      signed int tmp_post$2 = j;
      j = j + 1;
      str[(signed long int)tmp_post$2] = (char)c;
    }
  }
  str[(signed long int)j] = (char)0;
  return j;
}

// exclusive_lock_server_data
// file servers.h line 43
signed int exclusive_lock_server_data(signed int tm)
{
  struct timeval now;
  struct timespec timeout;
  pthread_mutex_lock(&servers_lock);
  signed int return_value_pthread_equal$2;
  char *return_value_strerror$1;
  if(server_status_ping >= 1)
  {
    return_value_pthread_equal$2=pthread_equal(servstat_thrid, main_thrid);
    if(return_value_pthread_equal$2 == 0)
    {
      signed int err;
      if(!(debug_p == 0))
        debug_msg(0, "Sending server status thread an interrupt signal.\n");

      err=pthread_kill(servstat_thrid, 1);
      if(!(err == 0))
      {
        if(!(debug_p == 0))
        {
          return_value_strerror$1=strerror(err);
          debug_msg(0, "pthread_kill failed: %s\n", return_value_strerror$1);
        }

      }

    }

  }

  gettimeofday(&now, (struct timezone *)(void *)0);
  timeout.tv_sec = now.tv_sec + (signed long int)tm;
  timeout.tv_nsec = now.tv_usec * (signed long int)1000;
  while(server_data_users >= 1)
  {
    signed int return_value_pthread_cond_timedwait$3;
    return_value_pthread_cond_timedwait$3=pthread_cond_timedwait(&server_data_cond, &servers_lock, &timeout);
    if(return_value_pthread_cond_timedwait$3 == 110)
    {
      pthread_mutex_unlock(&servers_lock);
      return 0;
    }

  }
  return 1;
}

// exclusive_unlock_server_data
// file servers.h line 44
void exclusive_unlock_server_data(signed int retest)
{
  if(!(retest == 0))
  {
    signed int return_value_pthread_equal$1;
    return_value_pthread_equal$1=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal$1 == 0))
      start_servstat_thread();

    else
      pthread_cond_signal(&server_test_cond);
  }

  pthread_mutex_unlock(&servers_lock);
}

// fetch_first
// file hash.h line 76
struct anonymous$0 * fetch_first(struct anonymous$59 *pos)
{
  signed int i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    struct dns_hash_ent_s *he = hash_buckets[(signed long int)i];
    if(!(he == ((struct dns_hash_ent_s *)NULL)))
    {
      pos->bucket = i;
      pos->ent = he->next;
      return he->data;
    }

  }
  return (struct anonymous$0 *)(void *)0;
}

// fetch_next
// file hash.h line 77
struct anonymous$0 * fetch_next(struct anonymous$59 *pos)
{
  struct dns_hash_ent_s *he = pos->ent;
  signed int i;
  if(!(he == ((struct dns_hash_ent_s *)NULL)))
  {
    pos->ent = he->next;
    return he->data;
  }

  else
  {
    i = pos->bucket + 1;
    for( ; !(i >= 1024); i = i + 1)
    {
      he = hash_buckets[(signed long int)i];
      if(!(he == ((struct dns_hash_ent_s *)NULL)))
      {
        pos->bucket = i;
        pos->ent = he->next;
        return he->data;
      }

    }
    return (struct anonymous$0 *)(void *)0;
  }
}

// final_init
// file main.c line 179
signed int final_init()
{
  if(global.notcp == 0)
    tcp_socket=init_tcp_socket();

  udp_socket=init_udp_socket();
  if(tcp_socket == -1 && udp_socket == -1)
  {
    log_message(3, "tcp and udp initialization failed. Exiting.");
    return 0;
  }

  else
  {
    if(!(global.strict_suid == 0))
    {
      signed int return_value_run_as$1;
      return_value_run_as$1=run_as(global.run_as);
      if(return_value_run_as$1 == 0)
        return 0;

    }

    return 1;
  }
}

// flags2str
// file cache.h line 119
char * flags2str(unsigned int flags, char *buf, signed int nflags, const char *flgnames)
{
  char *p = buf;
  signed int i;
  signed int nflgchars = 3 * nflags;
  i = 0;
  for( ; !(i >= nflgchars); i = i + 3)
  {
    if(!((1u & flags) == 0u))
    {
      if(!(buf >= p))
      {
        char *tmp_post$1 = p;
        p = p + 1l;
        *tmp_post$1 = (char)124;
      }

      void *return_value_mempcpy$2;
      return_value_mempcpy$2=mempcpy((void *)p, (const void *)&flgnames[(signed long int)i], (unsigned long int)3);
      p = (char *)return_value_mempcpy$2;
    }

    flags = flags >> 1;
  }
  if(p == buf)
  {
    char *tmp_post$3 = p;
    p = p + 1l;
    *tmp_post$3 = (char)48;
  }

  *p = (char)0;
  return buf;
}

// follow_cname_chain
// file dns_answer.c line 188
static inline signed int follow_cname_chain(struct anonymous$0 *c, unsigned char *name)
{
  struct anonymous *rrset;
  struct anonymous *tmp_if_expr$1;
  if((1 & (signed int)c->flags) == 0)
    tmp_if_expr$1 = c->$anon0.rr.rrmu[(signed long int)2];

  else
    tmp_if_expr$1 = (struct anonymous *)(void *)0;
  rrset = tmp_if_expr$1;
  struct rr_b_s *rr;
  _Bool tmp_if_expr$2;
  if(rrset == ((struct anonymous *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    rr = rrset->rrs;
    tmp_if_expr$2 = !(rr != ((struct rr_b_s *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return 0;

  else
  {
    if(rr->rdlen >= 257u)
    {
      log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 194, (const void *)"follow_cname_chain: record too long");
      pdnsd_exit();
    }

    memcpy((void *)name, (const void *)rr->data, (unsigned long int)rr->rdlen);
    return 1;
  }
}

// free_cent
// file cache.h line 203
void free_cent(struct anonymous$0 *cent)
{
  free((void *)cent->qname);
  if(!((1 & (signed int)cent->flags) == 0))
  {
    if(!(cent->$anon0.neg.lent == ((struct rr_lent_s *)NULL)))
      remove_rrl(cent->$anon0.neg.lent);

  }

  else
  {
    signed int i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      struct anonymous *free_cent$$1$$3$$1$$1$$rrs = cent->$anon0.rr.rrmu[(signed long int)i];
      if(!(free_cent$$1$$3$$1$$1$$rrs == ((struct anonymous *)NULL)))
        del_rrset(free_cent$$1$$3$$1$$1$$rrs);

    }
    struct anonymous **rrext = cent->$anon0.rr.rrext;
    if(!(rrext == ((struct anonymous **)NULL)))
    {
      i = 0;
      for( ; !(i >= 39); i = i + 1)
      {
        struct anonymous *rrs = rrext[(signed long int)i];
        if(!(rrs == ((struct anonymous *)NULL)))
          del_rrset(rrs);

      }
      free((void *)rrext);
    }

  }
}

// free_cent0
// file cache.h line 204
void free_cent0(void *ptr)
{
  free_cent((struct anonymous$0 *)ptr);
}

// free_dns_hash
// file hash.h line 74
void free_dns_hash()
{
  signed int i;
  struct dns_hash_ent_s *he;
  struct dns_hash_ent_s *hen;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    he = hash_buckets[(signed long int)i];
    hash_buckets[(signed long int)i] = (struct dns_hash_ent_s *)(void *)0;
    for( ; !(he == ((struct dns_hash_ent_s *)NULL)); he = hen)
    {
      hen = he->next;
      del_cent(he->data);
      free((void *)he);
    }
  }
}

// free_dns_hash_bucket
// file hash.h line 72
void free_dns_hash_bucket(signed int i)
{
  struct dns_hash_ent_s *he;
  struct dns_hash_ent_s *hen;
  he = hash_buckets[(signed long int)i];
  hash_buckets[(signed long int)i] = (struct dns_hash_ent_s *)(void *)0;
  for( ; !(he == ((struct dns_hash_ent_s *)NULL)); he = hen)
  {
    hen = he->next;
    del_cent(he->data);
    free((void *)he);
  }
}

// free_dns_hash_selected
// file hash.h line 73
void free_dns_hash_selected(signed int i, struct anonymous$8 *sla)
{
  struct dns_hash_ent_s **hep;
  struct dns_hash_ent_s *he;
  struct dns_hash_ent_s *hen;
  signed int j;
  signed int m;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link6((struct anonymous$3 *)sla);
  m = (signed int)return_value_da_nel$1;
  hep = &hash_buckets[(signed long int)i];
  he = *hep;
  while(!(he == ((struct dns_hash_ent_s *)NULL)))
  {
    unsigned char *name = he->data->qname;
    j = 0;
    for( ; !(j >= m); j = j + 1)
    {
      struct anonymous$9 *sl = &sla->elem[(signed long int)j];
      unsigned int nrem;
      unsigned int lrem;
      domain_match(name, sl->domain, &nrem, &lrem);
      if(lrem == 0u)
      {
        if(sl->exact == 0 || nrem == 0u)
        {
          if((signed int)sl->rule == 18)
            goto delete_entry;

          else
            break;
        }

      }

    }
    hep = &he->next;
    he = *hep;
    continue;

  delete_entry:
    ;
    hen = he->next;
    *hep = hen;
    del_cent(he->data);
    free((void *)he);
    he = hen;
  }
}

// free_rejectlist
// file dns_query.c line 2892
static inline void free_rejectlist(struct rejectlist_s *rl)
{
  while(!(rl == ((struct rejectlist_s *)NULL)))
  {
    struct rejectlist_s *next = rl->next;
    free((void *)rl);
    rl = next;
  }
}

// free_server_data
// file conff.c line 390
static void free_server_data(struct anonymous$18 *sa)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link1((struct anonymous$3 *)sa);
  n = (signed int)return_value_da_nel$1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
    free_servparm(&sa->elem[(signed long int)i]);
  free((void *)sa);
}

// free_servparm
// file conff.h line 187
void free_servparm(struct anonymous$7 *serv)
{
  free((void *)serv->uptest_cmd);
  free((void *)serv->query_test_name);
  free((void *)serv->label);
  free((void *)serv->atup_a);
  free_slist_array(serv->alist);
  free((void *)serv->reject_a4);
  free((void *)serv->reject_a6);
}

// free_slist_array
// file conff.c line 368
void free_slist_array(struct anonymous$8 *sla)
{
  signed int j;
  signed int m;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link1((struct anonymous$3 *)sla);
  m = (signed int)return_value_da_nel$1;
  j = 0;
  for( ; !(j >= m); j = j + 1)
    free((void *)sla->elem[(signed long int)j].domain);
  free((void *)sla);
}

// free_slist_domain
// file conff.h line 185
void free_slist_domain(void *ptr)
{
  free((void *)((struct anonymous$9 *)ptr)->domain);
}

// free_zone
// file conff.h line 184
void free_zone(void *ptr)
{
  free((void *)*((unsigned char **)ptr));
}

// free_zones
// file conff.c line 354
static void free_zones(struct anonymous$30 *za)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link1((struct anonymous$3 *)za);
  n = (signed int)return_value_da_nel$1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
    free((void *)za->elem[(signed long int)i]);
  free((void *)za);
}

// fsprintf
// file helpers.h line 170
signed int fsprintf(signed int fd, const char *format, ...)
{
  signed int n;
  void **va;
  char buf[256l];
  va = (void **)&format;
  n=vsnprintf(buf, sizeof(char [256l]) /*256ul*/ , format, va);
  va = ((void **)NULL);
  signed long int return_value_write_all$1;
  if(!(n >= (signed int)sizeof(char [256l]) /*256*/ ))
  {
    if(n >= 1)
    {
      return_value_write_all$1=write_all$link1(fd, (const void *)buf, (unsigned long int)n);
      n = (signed int)return_value_write_all$1;
    }

    return n;
  }

  unsigned int bufsize = (unsigned int)(n + 1);
  const signed long int bufsize$array_size0 = (signed long int)bufsize;
  char fsprintf$$1$$2$$buf[bufsize$array_size0];
  va = (void **)&format;
  n=vsnprintf(fsprintf$$1$$2$$buf, (unsigned long int)bufsize, format, va);
  va = ((void **)NULL);
  signed long int return_value_write_all$2;
  if(n >= 1)
  {
    return_value_write_all$2=write_all$link1(fd, (const void *)fsprintf$$1$$2$$buf, (unsigned long int)n);
    n = (signed int)return_value_write_all$2;
  }

  return n;
}

// get_cname
// file dns.c line 492
const char * get_cname(signed int id)
{
  if(id >= 1 && !(id >= 5))
    return c_names[(signed long int)(id - 1)];

  else
    if(id == 255)
      return "*";

    else
      return "[unknown]";
}

// get_ename
// file dns.c line 532
const char * get_ename(signed int id)
{
  if(id >= 0 && !(id >= 17))
    return e_names[(signed long int)id];

  else
    return "[unknown]";
}

// get_rand16
// file helpers.h line 168
unsigned short int get_rand16(void)
{
  signed long int return_value_random$1;
  return_value_random$1=random();
  return (unsigned short int)(return_value_random$1 & (signed long int)0xffff);
}

// get_rrlent_ts
// file cache.c line 880
static inline signed long int get_rrlent_ts(struct rr_lent_s *le)
{
  signed long int tmp_if_expr$1;
  if(!(le->rrset == ((struct anonymous *)NULL)))
    tmp_if_expr$1 = le->rrset->ts;

  else
    tmp_if_expr$1 = le->cent->$anon0.neg.ts;
  return tmp_if_expr$1;
}

// get_tname
// file dns.c line 501
const char * get_tname(signed int id)
{
  if(id >= 1 && !(id >= 52))
    return rrnames[(signed long int)(id - 1)];

  else
    if(id >= 251 && !(id >= 256))
      return qt_names[(signed long int)(id - 251)];

  return "[unknown]";
}

// getlocalowner
// file cache.h line 178
unsigned char * getlocalowner(unsigned char *name, signed int tp)
{
  unsigned char *ret = (unsigned char *)(void *)0;
  struct anonymous$0 *ce;
  unsigned int lb;
  lock_cache_r();
  lb = (unsigned int)*name;
  if(!(lb == 0u))
    do
    {
      name = name + (signed long int)(lb + (unsigned int)1);
      lb = (unsigned int)*name;
      if(lb == 0u)
        break;

      ce=dns_lookup(name, (struct anonymous$58 *)(void *)0);
      if(!(ce == ((struct anonymous$0 *)NULL)))
      {
        if((2 & (signed int)ce->flags) == 0)
          break;

        signed int return_value_have_rr$1;
        return_value_have_rr$1=have_rr$link2(ce, tp);
        if(!(return_value_have_rr$1 == 0))
        {
          ret = name;
          break;
        }

      }

    }
    while((_Bool)1);

  unlock_cache_r();
  return ret;
}

// getnextp
// file conf-parser.c line 84
static char * getnextp(char **buf, unsigned long int *n, struct _IO_FILE *in, char *p, unsigned int *linenr, char **errstr)
{
  if(!(p == ((char *)NULL)))
  {

  tryagain:
    ;
    if(!(*p == 0))
      goto __CPROVER_DUMP_L6;

  }

  signed long int return_value_getline$1;
  do
  {

  nextline:
    ;
    _Bool tmp_if_expr$2;
    if(in == ((struct _IO_FILE *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_getline$1=getline(buf, n, in);
      tmp_if_expr$2 = return_value_getline$1 < (signed long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
    {
      *errstr = (char *)(void *)0;
      return (char *)(void *)0;
    }

    *linenr = *linenr + 1u;
    p = *buf;
  }
  while(*p == 0);

__CPROVER_DUMP_L6:
  ;
  const unsigned short int **return_value___ctype_b_loc$3;
  return_value___ctype_b_loc$3=__ctype_b_loc();
  if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p]) == 0))
  {
    p = p + 1l;
    goto tryagain;
  }

  if((signed int)*p == 35)
  {

  skip_rest_of_line:
    ;
    if(!(*linenr == 0u))
      goto nextline;

    else
    {
      p=strchr(p, 10);
      if(!(p == ((char *)NULL)))
      {
        p = p + 1l;
        goto tryagain;
      }

      else
        goto nextline;
    }
  }

  signed long int return_value_getline$5;
  if((signed int)*p == 47)
  {
    if((signed int)p[1l] == 47)
      goto skip_rest_of_line;

    if((signed int)p[1l] == 42)
    {
      signed int lev = 1;
      p = p + (signed long int)2;

    __CPROVER_DUMP_L12:
      ;
      while((_Bool)1)
      {
        if(!(*p == 0))
        {
          _Bool tmp_if_expr$4;
          if((signed int)*p == 47)
            tmp_if_expr$4 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            lev = lev + 1;
            p = p + (signed long int)2;
            goto __CPROVER_DUMP_L17;
          }

          else
            if((signed int)*p == 42)
            {
              if((signed int)p[1l] == 47)
              {
                p = p + (signed long int)2;
                lev = lev - 1;
                if(lev == 0)
                  goto tryagain;

                goto __CPROVER_DUMP_L17;
              }

            }

          p = p + 1l;

        __CPROVER_DUMP_L17:
          ;
          goto __CPROVER_DUMP_L12;
        }

        _Bool tmp_if_expr$6;
        if(in == ((struct _IO_FILE *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value_getline$5=getline(buf, n, in);
          tmp_if_expr$6 = return_value_getline$5 < (signed long int)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
        {
          *errstr = "comment without closing */";
          return (char *)(void *)0;
        }

        *linenr = *linenr + 1u;
        p = *buf;
      }
    }

  }

  return p;
}

// getrrset
// file cache.h line 221
static inline struct anonymous * getrrset(struct anonymous$0 *cent, signed int type)
{
  if((1 & (signed int)cent->flags) == 0)
  {
    signed int tpi = type - 1;
    if(tpi >= 0 && !(tpi >= 51))
    {
      unsigned int idx = (unsigned int)rrlkuptab[(signed long int)tpi];
      if(!(idx >= 8u))
        return cent->$anon0.rr.rrmu[(signed long int)idx];

      else
      {
        idx = idx - (unsigned int)8;
        if(!(idx >= 39u))
        {
          struct anonymous **rrext = cent->$anon0.rr.rrext;
          if(!(rrext == ((struct anonymous **)NULL)))
            return rrext[(signed long int)idx];

        }

      }
    }

  }

  return (struct anonymous *)(void *)0;
}

// getrrset$link1
// file cache.h line 221
static inline struct anonymous * getrrset$link1(struct anonymous$0 *cent$link1, signed int type$link1)
{
  if((1 & (signed int)cent$link1->flags) == 0)
  {
    signed int tpi$link1 = type$link1 - 1;
    if(tpi$link1 >= 0 && !(tpi$link1 >= 51))
    {
      unsigned int idx$link1 = (unsigned int)rrlkuptab[(signed long int)tpi$link1];
      if(!(idx$link1 >= 8u))
        return cent$link1->$anon0.rr.rrmu[(signed long int)idx$link1];

      else
      {
        idx$link1 = idx$link1 - (unsigned int)8;
        if(!(idx$link1 >= 39u))
        {
          struct anonymous **rrext$link1 = cent$link1->$anon0.rr.rrext;
          if(!(rrext$link1 == ((struct anonymous **)NULL)))
            return rrext$link1[(signed long int)idx$link1];

        }

      }
    }

  }

  return (struct anonymous *)(void *)0;
}

// getrrset$link2
// file cache.h line 221
static inline struct anonymous * getrrset$link2(struct anonymous$0 *cent$link2, signed int type$link2)
{
  if((1 & (signed int)cent$link2->flags) == 0)
  {
    signed int tpi$link2 = type$link2 - 1;
    if(tpi$link2 >= 0 && !(tpi$link2 >= 51))
    {
      unsigned int idx$link2 = (unsigned int)rrlkuptab[(signed long int)tpi$link2];
      if(!(idx$link2 >= 8u))
        return cent$link2->$anon0.rr.rrmu[(signed long int)idx$link2];

      else
      {
        idx$link2 = idx$link2 - (unsigned int)8;
        if(!(idx$link2 >= 39u))
        {
          struct anonymous **rrext$link2 = cent$link2->$anon0.rr.rrext;
          if(!(rrext$link2 == ((struct anonymous **)NULL)))
            return rrext$link2[(signed long int)idx$link2];

        }

      }
    }

  }

  return (struct anonymous *)(void *)0;
}

// getrrset_eff
// file cache.h line 251
static inline struct anonymous * getrrset_eff(struct anonymous$0 *cent, signed int type)
{
  unsigned int idx = (unsigned int)rrlkuptab[(signed long int)(type - 1)];
  if(!(idx >= 8u))
    return cent->$anon0.rr.rrmu[(signed long int)idx];

  else
  {
    idx = idx - (unsigned int)8;
    if(!(idx >= 39u))
    {
      struct anonymous **rrext = cent->$anon0.rr.rrext;
      if(!(rrext == ((struct anonymous **)NULL)))
        return rrext[(signed long int)idx];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrset_eff$link1
// file cache.h line 251
static inline struct anonymous * getrrset_eff$link1(struct anonymous$0 *cent$link1, signed int type$link1)
{
  unsigned int idx$link1 = (unsigned int)rrlkuptab[(signed long int)(type$link1 - 1)];
  if(!(idx$link1 >= 8u))
    return cent$link1->$anon0.rr.rrmu[(signed long int)idx$link1];

  else
  {
    idx$link1 = idx$link1 - (unsigned int)8;
    if(!(idx$link1 >= 39u))
    {
      struct anonymous **rrext$link1 = cent$link1->$anon0.rr.rrext;
      if(!(rrext$link1 == ((struct anonymous **)NULL)))
        return rrext$link1[(signed long int)idx$link1];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrset_eff$link2
// file cache.h line 251
static inline struct anonymous * getrrset_eff$link2(struct anonymous$0 *cent$link2, signed int type$link2)
{
  unsigned int idx$link2 = (unsigned int)rrlkuptab[(signed long int)(type$link2 - 1)];
  if(!(idx$link2 >= 8u))
    return cent$link2->$anon0.rr.rrmu[(signed long int)idx$link2];

  else
  {
    idx$link2 = idx$link2 - (unsigned int)8;
    if(!(idx$link2 >= 39u))
    {
      struct anonymous **rrext$link2 = cent$link2->$anon0.rr.rrext;
      if(!(rrext$link2 == ((struct anonymous **)NULL)))
        return rrext$link2[(signed long int)idx$link2];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrset_eff$link3
// file cache.h line 251
static inline struct anonymous * getrrset_eff$link3(struct anonymous$0 *cent$link3, signed int type$link3)
{
  unsigned int idx$link3 = (unsigned int)rrlkuptab[(signed long int)(type$link3 - 1)];
  if(!(idx$link3 >= 8u))
    return cent$link3->$anon0.rr.rrmu[(signed long int)idx$link3];

  else
  {
    idx$link3 = idx$link3 - (unsigned int)8;
    if(!(idx$link3 >= 39u))
    {
      struct anonymous **rrext$link3 = cent$link3->$anon0.rr.rrext;
      if(!(rrext$link3 == ((struct anonymous **)NULL)))
        return rrext$link3[(signed long int)idx$link3];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrtpname
// file dns.c line 480
const char * getrrtpname(signed int tp)
{
  const char *tmp_if_expr$1;
  if(tp >= 1 && !(tp >= 52))
    tmp_if_expr$1 = rrnames[(signed long int)(tp - 1)];

  else
    tmp_if_expr$1 = "[unknown]";
  return tmp_if_expr$1;
}

// have_rr
// file cache.h line 274
static inline signed int have_rr(struct anonymous$0 *cent, signed int type)
{
  struct anonymous *rrset;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)cent->flags) == 0)
  {
    rrset=getrrset_eff$link1(cent, type);
    tmp_if_expr$1 = rrset != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  return (signed int)tmp_if_expr$2;
}

// have_rr$link1
// file cache.h line 274
static inline signed int have_rr$link1(struct anonymous$0 *cent$link1, signed int type$link1)
{
  struct anonymous *rrset$link1;
  _Bool tmp_if_expr$1$link1;
  if((1 & (signed int)cent$link1->flags) == 0)
  {
    rrset$link1=getrrset_eff$link2(cent$link1, type$link1);
    tmp_if_expr$1$link1 = rrset$link1 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$1$link1 = (_Bool)0;
  _Bool tmp_if_expr$2$link1;
  if(tmp_if_expr$1$link1)
    tmp_if_expr$2$link1 = rrset$link1->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2$link1 = (_Bool)0;
  return (signed int)tmp_if_expr$2$link1;
}

// have_rr$link2
// file cache.h line 274
static inline signed int have_rr$link2(struct anonymous$0 *cent$link2, signed int type$link2)
{
  struct anonymous *rrset$link2;
  _Bool tmp_if_expr$1$link2;
  if((1 & (signed int)cent$link2->flags) == 0)
  {
    rrset$link2=getrrset_eff$link3(cent$link2, type$link2);
    tmp_if_expr$1$link2 = rrset$link2 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$1$link2 = (_Bool)0;
  _Bool tmp_if_expr$2$link2;
  if(tmp_if_expr$1$link2)
    tmp_if_expr$2$link2 = rrset$link2->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2$link2 = (_Bool)0;
  return (signed int)tmp_if_expr$2$link2;
}

// hexdump
// file helpers.c line 546
void hexdump(const void *data, signed int dlen, char *buf, signed int buflen)
{
  const unsigned char *p = (const unsigned char *)data;
  signed int i;
  signed int j = 0;
  i = 0;
  for( ; !(i >= dlen); i = i + 1)
  {
    signed int rem = buflen - j;
    signed int n;
    n=snprintf(buf + (signed long int)j, (unsigned long int)rem, i == 0 ? "%02x" : " %02x", p[(signed long int)i]);
    if(n >= rem || !(n >= 0))
      goto truncated;

    j = j + n;
  }
  goto done;

truncated:
  ;
  if(j >= 6)
  {
    j = j - 3;
    if(4 + j >= buflen)
      j = j - 3;

    signed int tmp_post$1 = j;
    j = j + 1;
    buf[(signed long int)tmp_post$1] = (char)32;
    signed int tmp_post$2 = j;
    j = j + 1;
    buf[(signed long int)tmp_post$2] = (char)46;
    signed int tmp_post$3 = j;
    j = j + 1;
    buf[(signed long int)tmp_post$3] = (char)46;
    signed int tmp_post$4 = j;
    j = j + 1;
    buf[(signed long int)tmp_post$4] = (char)46;
  }

  else
  {
    signed int ndots = buflen - 1;
    if(ndots >= 4)
      ndots = 3;

    j = 0;
    while(!(j >= ndots))
    {
      signed int tmp_post$5 = j;
      j = j + 1;
      buf[(signed long int)tmp_post$5] = (char)46;
    }
  }

done:
  ;
  buf[(signed long int)j] = (char)0;
}

// icmp4_errcmp
// file icmp.c line 136
static signed int icmp4_errcmp(char *packet, signed int plen, struct in_addr *to, char *errmsg, signed int elen, signed int errtype)
{
  struct iphdr iph;
  struct icmphdr icmph;
  struct iphdr eiph;
  char *data;
  signed int return_value_memcmp$1;
  signed int return_value_memcmp$3;
  if(!((unsigned long int)elen >= sizeof(struct iphdr) /*20ul*/ ))
    return 0;

  else
  {
    memcpy((void *)&iph, (const void *)errmsg, sizeof(struct iphdr) /*20ul*/ );
    if(!((signed int)iph.protocol == 1) || !((unsigned long int)elen >= sizeof(struct iphdr) /*20ul*/  + (unsigned long int)(4 * (signed int)iph.ihl + 8)))
      return 0;

    else
    {
      memcpy((void *)&icmph, (const void *)(errmsg + (signed long int)((signed int)iph.ihl * 4)), (unsigned long int)8);
      memcpy((void *)&eiph, (const void *)(errmsg + (signed long int)((signed int)iph.ihl * 4) + (signed long int)8), sizeof(struct iphdr) /*20ul*/ );
      if(!(elen >= 4 * (signed int)eiph.ihl + 4 * (signed int)iph.ihl + 8))
        return 0;

      else
      {
        data = errmsg + (signed long int)((signed int)iph.ihl * 4) + (signed long int)8 + (signed long int)((signed int)eiph.ihl * 4);
        _Bool tmp_if_expr$2;
        if((signed int)icmph.type == errtype)
        {
          return_value_memcmp$1=memcmp((const void *)&to->s_addr, (const void *)&eiph.daddr, sizeof(unsigned int) /*4ul*/ );
          tmp_if_expr$2 = return_value_memcmp$1 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
        _Bool tmp_if_expr$4;
        if(tmp_if_expr$2)
        {
          return_value_memcmp$3=memcmp((const void *)data, (const void *)packet, (unsigned long int)(plen < 8 ? plen : 8));
          tmp_if_expr$4 = return_value_memcmp$3 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
        return (signed int)tmp_if_expr$4;
      }
    }
  }
}

// icmp6_errcmp
// file icmp.c line 330
static signed int icmp6_errcmp(char *packet, signed int plen, struct in6_addr *to, char *errmsg, signed int elen, signed int errtype)
{
  struct icmp6_hdr icmph;
  struct ip6_hdr eiph;
  struct ip6_hbh hbh;
  char *data;
  signed int rlen;
  signed int nxt;
  signed int return_value_memcmp$4;
  if(!((unsigned long int)elen >= sizeof(struct icmp6_hdr) * 6 /*48ul*/ ))
    return 0;

  else
  {
    memcpy((void *)&icmph, (const void *)errmsg, sizeof(struct icmp6_hdr) /*8ul*/ );
    memcpy((void *)&eiph, (const void *)(errmsg + (signed long int)sizeof(struct icmp6_hdr) /*8ul*/ ), sizeof(struct ip6_hdr) /*40ul*/ );
    _Bool tmp_if_expr$1;
    if(*((unsigned int *)&eiph.ip6_dst) == *((unsigned int *)to))
      tmp_if_expr$1 = ((unsigned int *)&eiph.ip6_dst)[(signed long int)1] == ((unsigned int *)to)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ((unsigned int *)&eiph.ip6_dst)[(signed long int)2] == ((unsigned int *)to)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = ((unsigned int *)&eiph.ip6_dst)[(signed long int)3] == ((unsigned int *)to)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      return 0;

    else
    {
      rlen = (signed int)(((unsigned long int)elen - sizeof(struct icmp6_hdr) /*8ul*/ ) - sizeof(struct ip6_hdr) /*40ul*/ );
      data = errmsg + (signed long int)sizeof(struct icmp6_hdr) /*8ul*/  + (signed long int)sizeof(struct ip6_hdr) /*40ul*/ ;
      nxt = (signed int)eiph.ip6_ctlun.ip6_un1.ip6_un1_nxt;
      for( ; !(nxt == 58); data = data + (signed long int)hbh.ip6h_len)
      {
        if(!(nxt == 0) && !(nxt == 43) && !(nxt == 60))
          return 0;

        if(!((unsigned long int)rlen >= sizeof(struct ip6_hbh) /*2ul*/ ))
          return 0;

        memcpy((void *)&hbh, (const void *)data, sizeof(struct ip6_hbh) /*2ul*/ );
        if(!(rlen >= (signed int)hbh.ip6h_len))
          return 0;

        rlen = rlen - (signed int)hbh.ip6h_len;
        nxt = (signed int)hbh.ip6h_nxt;
      }
      if(!((unsigned long int)rlen >= sizeof(struct icmp6_hdr) /*8ul*/ ))
        return 0;

      else
      {
        memset((void *)((char *)data + (signed long int)2ul), 0, sizeof(unsigned short int) /*2ul*/ );
        _Bool tmp_if_expr$5;
        if((signed int)icmph.icmp6_type == errtype)
        {
          return_value_memcmp$4=memcmp((const void *)data, (const void *)packet, (unsigned long int)(plen < rlen ? plen : rlen));
          tmp_if_expr$5 = return_value_memcmp$4 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        return (signed int)tmp_if_expr$5;
      }
    }
  }
}

// if_up
// file netdev.c line 186
signed int if_up(char *devname)
{
  signed int sock;
  struct ifreq ifr;
  unsigned int devnamelen;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(devname);
  devnamelen = (unsigned int)return_value_strlen$1;
  signed int return_value_strncmp$3;
  if(devnamelen >= 5u && !(devnamelen >= 7u))
  {
    return_value_strncmp$3=strncmp(devname, "ippp", (unsigned long int)4);
    if(return_value_strncmp$3 == 0)
    {
      signed int return_value_statusif$2;
      return_value_statusif$2=statusif(devname);
      return return_value_statusif$2;
    }

  }

  sock=socket(2, 2, 17);
  if(sock == -1)
  {
    socketopen_errs = socketopen_errs + 1ul;
    if(!(socketopen_errs >= 11ul))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_message(4, "Could not open socket in if_up(): %s", return_value_strerror$5);
    }

    return 0;
  }

  else
  {
    strncp$link2(ifr.ifr_ifrn.ifrn_name, devname, (unsigned long int)16);
    signed int return_value_ioctl$6;
    return_value_ioctl$6=ioctl(sock, (unsigned long int)0x8913, &ifr);
    if(return_value_ioctl$6 == -1)
    {
      close(sock);
      return 0;
    }

    else
    {
      close(sock);
      return (signed int)(((signed int)ifr.ifr_ifru.ifru_flags & 1) != 0 && ((signed int)ifr.ifr_ifru.ifru_flags & 64) != 0);
    }
  }
}

// init_cache_lock
// file cache.h line 157
static inline void init_cache_lock()
{
  use_cache_lock = (volatile signed short int)1;
}

// init_cent
// file cache.h line 199
signed int init_cent(struct anonymous$0 *cent, const unsigned char *qname, signed long int ttl, signed long int ts, unsigned int flags)
{
  signed int i;
  unsigned long int namesz;
  unsigned int return_value_rhnlen$1;
  return_value_rhnlen$1=rhnlen$link6(qname);
  namesz = (unsigned long int)return_value_rhnlen$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(namesz);
  cent->qname = (unsigned char *)return_value_malloc$2;
  if(cent->qname == ((unsigned char *)NULL))
    return 0;

  else
  {
    memcpy((void *)cent->qname, (const void *)qname, namesz);
    cent->cs = sizeof(struct anonymous$0) /*104ul*/  + namesz;
    cent->num_rrs = (unsigned short int)0;
    cent->flags = (unsigned short int)flags;
    if(!((1u & flags) == 0u))
    {
      cent->$anon0.neg.lent = (struct rr_lent_s *)(void *)0;
      cent->$anon0.neg.ttl = ttl;
      cent->$anon0.neg.ts = ts;
    }

    else
    {
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        cent->$anon0.rr.rrmu[(signed long int)i] = (struct anonymous *)(void *)0;
      cent->$anon0.rr.rrext = (struct anonymous **)(void *)0;
    }
    cent->c_ns = (unsigned char)0xff;
    cent->c_soa = (unsigned char)0xff;
    return 1;
  }
}

// init_crandom
// file helpers.c line 447
void init_crandom()
{
  struct timeval tv;
  struct timezone tz;
  gettimeofday(&tv, &tz);
  srandom((unsigned int)(tv.tv_sec ^ tv.tv_usec));
}

// init_log_lock
// file error.h line 45
static inline void init_log_lock(void)
{
  use_log_lock = (volatile signed short int)1;
}

// init_ping_socket
// file icmp.c line 114
void init_ping_socket(void)
{
  ping_isocket=socket(2, 3, 1);
  if(ping_isocket == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_message(4, "icmp ping: socket() failed: %s", return_value_strerror$2);
  }

  if(run_ipv4 == 0)
  {
    ping6_isocket=socket(10, 3, 58);
    if(ping6_isocket == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_message(4, "icmpv6 ping: socket() failed: %s", return_value_strerror$4);
    }

  }

}

// init_rng
// file helpers.c line 458
signed int init_rng(void)
{
  init_crandom();
  return 1;
}

// init_stat_sock
// file status.h line 56
void init_stat_sock(void)
{
  struct sockaddr_un *sa;
  unsigned int sa_len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(global.cache_dir);
  sa_len = (unsigned int)(2ul + (sizeof(char [14l]) /*14ul*/  - (unsigned long int)1) + return_value_strlen$1);
  void *return_value___builtin_alloca$2;
  return_value___builtin_alloca$2=__builtin_alloca((unsigned long int)(sa_len + (unsigned int)1));
  sa = (struct sockaddr_un *)return_value___builtin_alloca$2;
  char *return_value_stpcpy$3;
  return_value_stpcpy$3=stpcpy(sa->sun_path, global.cache_dir);
  stpcpy(return_value_stpcpy$3, "/pdnsd.status");
  signed int return_value_unlink$7;
  return_value_unlink$7=unlink(sa->sun_path);
  signed int *return_value___errno_location$6;
  if(!(return_value_unlink$7 == 0))
  {
    return_value___errno_location$6=__errno_location();
    if(!(*return_value___errno_location$6 == 2))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_message(4, "Failed to unlink %s: %s.\nStatus readback will be disabled", (const void *)sa->sun_path, return_value_strerror$5);
      stat_pipe = (signed short int)0;
      goto __CPROVER_DUMP_L6;
    }

  }

  stat_sock=socket(1, 1, 0);
  if(stat_sock == -1)
  {
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    char *return_value_strerror$9;
    return_value_strerror$9=strerror(*return_value___errno_location$8);
    log_message(4, "Failed to open socket: %s. Status readback will be impossible", return_value_strerror$9);
    stat_pipe = (signed short int)0;
    goto __CPROVER_DUMP_L6;
  }

  sa->sun_family = (unsigned short int)1;
  unsigned int old_mask;
  old_mask=umask((unsigned int)((0400 | 0200 | 0100 | (0400 | 0200 | 0100) >> 3 | ((0400 | 0200 | 0100) >> 3) >> 3) & ~global.ctl_perms));
  signed int return_value_bind$12;
  return_value_bind$12=bind(stat_sock, (struct sockaddr *)sa, sa_len);
  if(return_value_bind$12 == -1)
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    char *return_value_strerror$11;
    return_value_strerror$11=strerror(*return_value___errno_location$10);
    log_message(4, "Error: could not bind socket: %s.\nStatus readback will be impossible", return_value_strerror$11);
    close(stat_sock);
    stat_pipe = (signed short int)0;
  }

  umask(old_mask);
  if(!(stat_pipe == 0))
    sock_path=strdup(sa->sun_path);


__CPROVER_DUMP_L6:
  ;
}

// init_tcp_socket
// file dns_answer.c line 1967
signed int init_tcp_socket(void)
{
  signed int sock;
  /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'sin4'|lSYM#tag-sockaddr_in6#'sin6'] */
union anonymous$22
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

/* */
  ;
  union anonymous$22 sin;
  unsigned int sinl;
  if(!(run_ipv4 == 0))
  {
    sock=socket(2, 1, 6);
    if(sock == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_message(3, "Could not open tcp socket: %s", return_value_strerror$2);
      return -1;
    }

    memset((void *)&sin.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    sin.sin4.sin_family = (unsigned short int)2;
    sin.sin4.sin_port=htons((unsigned short int)global.port);
    sin.sin4.sin_addr = global.a.ipv4;
    sinl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  }

  else
  {
    sock=socket(10, 1, 6);
    if(sock == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_message(3, "Could not open tcp socket: %s", return_value_strerror$4);
      return -1;
    }

    memset((void *)&sin.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
    sin.sin6.sin6_family = (unsigned short int)10;
    sin.sin6.sin6_port=htons((unsigned short int)global.port);
    sin.sin6.sin6_flowinfo = (unsigned int)0;
    sin.sin6.sin6_addr = global.a.ipv6;
    sinl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
  }
  signed int so = 1;
  signed int return_value_setsockopt$7;
  return_value_setsockopt$7=setsockopt(sock, 1, 2, (const void *)&so, (unsigned int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(!(return_value_setsockopt$7 == 0))
  {
    return_value___errno_location$5=__errno_location();
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    log_message(4, "Could not set options on tcp socket: %s", return_value_strerror$6);
  }

  signed int return_value_bind$10;
  return_value_bind$10=bind(sock, (struct sockaddr *)&sin, sinl);
  if(!(return_value_bind$10 == 0))
  {
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    char *return_value_strerror$9;
    return_value_strerror$9=strerror(*return_value___errno_location$8);
    log_message(3, "Could not bind tcp socket: %s", return_value_strerror$9);
    close(sock);
    return -1;
  }

  return sock;
}

// init_udp_socket
// file dns_answer.c line 1536
signed int init_udp_socket(void)
{
  signed int sock;
  signed int so = 1;
  /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'sin4'|lSYM#tag-sockaddr_in6#'sin6'] */
union anonymous$22
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

/* */
  ;
  union anonymous$22 sin;
  unsigned int sinl;
  if(!(run_ipv4 == 0))
  {
    sock=socket(2, 2, 17);
    if(sock == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_message(3, "Could not open udp socket: %s", return_value_strerror$2);
      return -1;
    }

    memset((void *)&sin.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    sin.sin4.sin_family = (unsigned short int)2;
    sin.sin4.sin_port=htons((unsigned short int)global.port);
    sin.sin4.sin_addr = global.a.ipv4;
    sinl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  }

  else
  {
    sock=socket(10, 2, 17);
    if(sock == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_message(3, "Could not open udp socket: %s", return_value_strerror$4);
      return -1;
    }

    memset((void *)&sin.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
    sin.sin6.sin6_family = (unsigned short int)10;
    sin.sin6.sin6_port=htons((unsigned short int)global.port);
    sin.sin6.sin6_flowinfo = (unsigned int)0;
    sin.sin6.sin6_addr = global.a.ipv6;
    sinl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
  }
  signed int return_value_setsockopt$7;
  return_value_setsockopt$7=setsockopt(sock, 0, 8, (const void *)&so, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt$7 == 0))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(*return_value___errno_location$5);
    log_message(3, "Could not set options on udp socket: %s", return_value_strerror$6);
    close(sock);
    return -1;
  }

  if(run_ipv4 == 0)
  {
    signed int return_value_setsockopt$10;
    return_value_setsockopt$10=setsockopt(sock, 41, 49, (const void *)&so, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt$10 == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_message(3, "Could not set options on udp socket: %s", return_value_strerror$9);
      close(sock);
      return -1;
    }

  }

  signed int return_value_bind$13;
  return_value_bind$13=bind(sock, (struct sockaddr *)&sin, sinl);
  if(!(return_value_bind$13 == 0))
  {
    signed int *return_value___errno_location$11;
    return_value___errno_location$11=__errno_location();
    char *return_value_strerror$12;
    return_value_strerror$12=strerror(*return_value___errno_location$11);
    log_message(3, "Could not bind to udp socket: %s", return_value_strerror$12);
    close(sock);
    return -1;
  }

  return sock;
}

// insert_rrl
// file cache.c line 889
static signed int insert_rrl(struct anonymous *rrs, struct anonymous$0 *cent, signed int idx)
{
  signed long int ts;
  struct rr_lent_s *le;
  struct rr_lent_s *ne;
  _Bool tmp_if_expr$1;
  if(!(rrs == ((struct anonymous *)NULL)))
    tmp_if_expr$1 = ((signed int)rrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ((signed int)cent->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 1;

  else
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct rr_lent_s) /*40ul*/ );
    ne = (struct rr_lent_s *)return_value_malloc$3;
    if(ne == ((struct rr_lent_s *)NULL))
      return 0;

    else
    {
      ne->rrset = rrs;
      ne->cent = cent;
      ne->idx = idx;
      ne->next = (struct rr_lent_s *)(void *)0;
      ne->prev = (struct rr_lent_s *)(void *)0;
      if(!(insert_sort == 0))
      {
        ts=get_rrlent_ts(ne);
        le = rrset_l_tail;
        while(!(le == ((struct rr_lent_s *)NULL)))
        {
          signed long int return_value_get_rrlent_ts$4;
          return_value_get_rrlent_ts$4=get_rrlent_ts(le);
          if(ts >= return_value_get_rrlent_ts$4)
            goto found;

          le = le->prev;
        }
        ne->next = rrset_l;
        if(!(rrset_l == ((struct rr_lent_s *)NULL)))
          rrset_l->prev = ne;

        else
          rrset_l_tail = ne;
        rrset_l = ne;
        goto finish;

      found:
        ;
        ne->next = le->next;
        ne->prev = le;
        if(!(le->next == ((struct rr_lent_s *)NULL)))
          le->next->prev = ne;

        else
          rrset_l_tail = ne;
        le->next = ne;
      }

      else
      {
        ne->prev = rrset_l_tail;
        if(!(rrset_l_tail == ((struct rr_lent_s *)NULL)))
          rrset_l_tail->next = ne;

        else
          rrset_l = ne;
        rrset_l_tail = ne;
      }

    finish:
      ;
      if(!(rrs == ((struct anonymous *)NULL)))
        rrs->lent = ne;

      else
        cent->$anon0.neg.lent = ne;
      return 1;
    }
  }
}

// invalidate_record
// file cache.h line 176
void invalidate_record(const unsigned char *name)
{
  struct anonymous$0 *ce;
  signed int i;
  signed int ilim;
  lock_cache_rw();
  ce=dns_lookup(name, (struct anonymous$58 *)(void *)0);
  if(!(ce == ((struct anonymous$0 *)NULL)))
  {
    if((1 & (signed int)ce->flags) == 0)
    {
      signed int tmp_if_expr$1;
      if(!((1 & (signed int)ce->flags) == 0))
        tmp_if_expr$1 = 0;

      else
        tmp_if_expr$1 = ce->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      ilim = tmp_if_expr$1;
      i = 0;
      for( ; !(i >= ilim); i = i + 1)
      {
        struct anonymous *rrs;
        struct anonymous *tmp_if_expr$2;
        if(!(i >= 8))
          tmp_if_expr$2 = ce->$anon0.rr.rrmu[(signed long int)i];

        else
          tmp_if_expr$2 = ce->$anon0.rr.rrext[(signed long int)(i - 8)];
        rrs = tmp_if_expr$2;
        if(!(rrs == ((struct anonymous *)NULL)))
        {
          rrs->ts = (signed long int)0;
          rrs->flags = rrs->flags & (unsigned short int)~4;
        }

      }
    }

    else
      ce->$anon0.neg.ts = (signed long int)0;
    ce->flags = ce->flags & (unsigned short int)~4;
  }

  unlock_cache_rw();
}

// is_inaddr2_any
// file helpers.h line 123
static inline signed int is_inaddr2_any(struct anonymous$15 *a)
{
  signed int tmp_if_expr$5;
  _Bool tmp_statement_expression$1;
  if(!(run_ipv4 == 0))
    tmp_if_expr$5 = (signed int)(a->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a = (struct in6_addr *)&a->ipv6;
    _Bool tmp_if_expr$2;
    if(__a->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr$2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    _Bool tmp_if_expr$4;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_statement_expression$1 = tmp_if_expr$4;
    tmp_if_expr$5 = (signed int)tmp_statement_expression$1;
  }
  return tmp_if_expr$5;
}

// is_inaddr_any
// file helpers.h line 115
static inline signed int is_inaddr_any(union anonymous$6 *a)
{
  signed int tmp_if_expr$5;
  _Bool tmp_statement_expression$1;
  if(!(run_ipv4 == 0))
    tmp_if_expr$5 = (signed int)(a->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a = (struct in6_addr *)&a->ipv6;
    _Bool tmp_if_expr$2;
    if(__a->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr$2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    _Bool tmp_if_expr$4;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_statement_expression$1 = tmp_if_expr$4;
    tmp_if_expr$5 = (signed int)tmp_statement_expression$1;
  }
  return tmp_if_expr$5;
}

// is_inaddr_any$link1
// file helpers.h line 115
static inline signed int is_inaddr_any$link1(union anonymous$6 *a$link1)
{
  signed int tmp_if_expr$5$link1;
  _Bool tmp_statement_expression$1$link1;
  if(!(run_ipv4 == 0))
    tmp_if_expr$5$link1 = (signed int)(a$link1->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a$link1 = (struct in6_addr *)&a$link1->ipv6;
    _Bool tmp_if_expr$2$link1;
    if(__a$link1->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr$2$link1 = __a$link1->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2$link1 = (_Bool)0;
    _Bool tmp_if_expr$3$link1;
    if(tmp_if_expr$2$link1)
      tmp_if_expr$3$link1 = __a$link1->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3$link1 = (_Bool)0;
    _Bool tmp_if_expr$4$link1;
    if(tmp_if_expr$3$link1)
      tmp_if_expr$4$link1 = __a$link1->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4$link1 = (_Bool)0;
    tmp_statement_expression$1$link1 = tmp_if_expr$4$link1;
    tmp_if_expr$5$link1 = (signed int)tmp_statement_expression$1$link1;
  }
  return tmp_if_expr$5$link1;
}

// is_inaddr_any$link2
// file helpers.h line 115
static inline signed int is_inaddr_any$link2(union anonymous$6 *a$link2)
{
  signed int tmp_if_expr$5$link2;
  _Bool tmp_statement_expression$1$link2;
  if(!(run_ipv4 == 0))
    tmp_if_expr$5$link2 = (signed int)(a$link2->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a$link2 = (struct in6_addr *)&a$link2->ipv6;
    _Bool tmp_if_expr$2$link2;
    if(__a$link2->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr$2$link2 = __a$link2->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2$link2 = (_Bool)0;
    _Bool tmp_if_expr$3$link2;
    if(tmp_if_expr$2$link2)
      tmp_if_expr$3$link2 = __a$link2->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3$link2 = (_Bool)0;
    _Bool tmp_if_expr$4$link2;
    if(tmp_if_expr$3$link2)
      tmp_if_expr$4$link2 = __a$link2->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4$link2 = (_Bool)0;
    tmp_statement_expression$1$link2 = tmp_if_expr$4$link2;
    tmp_if_expr$5$link2 = (signed int)tmp_statement_expression$1$link2;
  }
  return tmp_if_expr$5$link2;
}

// is_interrupted_servstat_thread
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread()
{
  _Bool tmp_if_expr$3;
  unsigned long int return_value_pthread_self$1;
  signed int return_value_pthread_equal$2;
  if(!(signal_interrupt == 0))
  {
    return_value_pthread_self$1=pthread_self();
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, servstat_thrid);
    tmp_if_expr$3 = return_value_pthread_equal$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return (signed int)tmp_if_expr$3;
}

// is_interrupted_servstat_thread$link1
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread$link1()
{
  _Bool tmp_if_expr$3$link1;
  unsigned long int return_value_pthread_self$1$link1;
  signed int return_value_pthread_equal$2$link1;
  if(!(signal_interrupt == 0))
  {
    return_value_pthread_self$1$link1=pthread_self();
    return_value_pthread_equal$2$link1=pthread_equal(return_value_pthread_self$1$link1, servstat_thrid);
    tmp_if_expr$3$link1 = return_value_pthread_equal$2$link1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1 = (_Bool)0;
  return (signed int)tmp_if_expr$3$link1;
}

// is_local_addr
// file netdev.h line 30
signed int is_local_addr(union anonymous$6 *a)
{
  signed int res = 0;
  if(!(run_ipv4 == 0))
  {
    signed int i;
    signed int sock;
    struct ifreq ifr;
    sock=socket(2, 2, 17);
    if(sock == -1)
    {
      socketopen_errs = socketopen_errs + 1ul;
      if(!(socketopen_errs >= 11ul))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        log_message(4, "Could not open socket in is_local_addr(): %s", return_value_strerror$2);
      }

      return 0;
    }

    i = 1;
    for( ; !(i >= 255); i = i + 1)
    {
      ifr.ifr_ifru.ifru_ivalue = i;
      signed int return_value_ioctl$3;
      return_value_ioctl$3=ioctl(sock, (unsigned long int)0x8910, &ifr);
      if(!(return_value_ioctl$3 == -1))
      {
        signed int return_value_ioctl$4;
        return_value_ioctl$4=ioctl(sock, (unsigned long int)0x8915, &ifr);
        if(!(return_value_ioctl$4 == -1))
        {
          if(((struct sockaddr_in *)&ifr.ifr_ifru.ifru_addr)->sin_addr.s_addr == a->ipv4.s_addr)
          {
            res = 1;
            break;
          }

        }

      }

    }
    close(sock);
  }

  else
  {
    char buf[40l];
    struct _IO_FILE *f;
    struct in6_addr b;
    f=fopen("/proc/net/if_inet6", "r");
    if(f == ((struct _IO_FILE *)NULL))
      return 0;

    do
    {
      signed int is_local_addr$$1$$2$$1$$1$$i;
      signed int ch;
      char *p = buf;
      is_local_addr$$1$$2$$1$$1$$i = 0;
      for( ; !(is_local_addr$$1$$2$$1$$1$$i >= 32); is_local_addr$$1$$2$$1$$1$$i = is_local_addr$$1$$2$$1$$1$$i + 1)
      {
        if(is_local_addr$$1$$2$$1$$1$$i % 4 == 0 && !(is_local_addr$$1$$2$$1$$1$$i == 0))
        {
          char *tmp_post$5 = p;
          p = p + 1l;
          *tmp_post$5 = (char)58;
        }

        ch=fgetc(f);
        if(ch == -1)
          goto fclose_return;

        if(ch == 10)
          goto nextline;

        char *tmp_post$6 = p;
        p = p + 1l;
        *tmp_post$6 = (char)ch;
      }
      *p = (char)0;
      signed int return_value_inet_pton$7;
      return_value_inet_pton$7=inet_pton(10, buf, (void *)&b);
      if(return_value_inet_pton$7 >= 1)
      {
        if(*((unsigned int *)&b) == *((unsigned int *)&a->ipv6))
        {
          if(((unsigned int *)&b)[1l] == ((unsigned int *)&a->ipv6)[1l])
          {
            if(((unsigned int *)&b)[2l] == ((unsigned int *)&a->ipv6)[2l])
            {
              if(((unsigned int *)&b)[3l] == ((unsigned int *)&a->ipv6)[3l])
              {
                res = 1;
                break;
              }

            }

          }

        }

      }

      do
      {
        ch=fgetc(f);
        if(ch == -1)
          goto fclose_return;

      }
      while(!(ch == 10));

    nextline:
      ;
    }
    while((_Bool)1);

  fclose_return:
    ;
    fclose(f);
  }
  return res;
}

// isnormalencdomname
// file helpers.h line 112
signed int isnormalencdomname(const unsigned char *rhn, unsigned int maxlen)
{
  unsigned int i;
  unsigned int lb;
  if(maxlen >= 257u)
    maxlen = (unsigned int)256;

  i = (unsigned int)0;
  for( ; (_Bool)1; i = i + lb)
  {
    if(i >= maxlen)
      return 0;

    unsigned int tmp_post$1 = i;
    i = i + 1u;
    lb = (unsigned int)rhn[(signed long int)tmp_post$1];
    if(lb == 0u)
      break;

    if(lb >= 64u)
      return 0;

  }
  return 1;
}

// keyncmp
// file consts.c line 98
static inline signed int keyncmp(const char *key1, signed int len, const char *key2)
{
  signed int cmp;
  cmp=strncmp(key1, key2, (unsigned long int)len);
  if(!(cmp == 0))
    return cmp;

  else
    return -((signed int)(unsigned char)key2[(signed long int)len]);
}

// listmerge
// file cache.c line 972
static struct rr_lent_s * listmerge(struct rr_lent_s *p, struct rr_lent_s *q)
{
  if(p == ((struct rr_lent_s *)NULL))
    return q;

  else
    if(q == ((struct rr_lent_s *)NULL))
      return p;

    else
    {
      struct rr_lent_s *l = (struct rr_lent_s *)(void *)0;
      struct rr_lent_s **s = &l;
      do
      {
        signed long int return_value_get_rrlent_ts$1;
        return_value_get_rrlent_ts$1=get_rrlent_ts(p);
        signed long int return_value_get_rrlent_ts$2;
        return_value_get_rrlent_ts$2=get_rrlent_ts(q);
        if(return_value_get_rrlent_ts$2 >= return_value_get_rrlent_ts$1)
        {
          *s = p;
          s = &p->next;
          p = *s;
          if(p == ((struct rr_lent_s *)NULL))
          {
            *s = q;
            break;
          }

        }

        else
        {
          *s = q;
          s = &q->next;
          q = *s;
          if(q == ((struct rr_lent_s *)NULL))
          {
            *s = p;
            break;
          }

        }
      }
      while((_Bool)1);
      return l;
    }
}

// llist_first
// file list.h line 145
static inline void * llist_first(struct anonymous$40 *a)
{
  struct llistnode_s *p = a->first;
  char **tmp_if_expr$1;
  if(!(p == ((struct llistnode_s *)NULL)))
    tmp_if_expr$1 = p->data;

  else
    tmp_if_expr$1 = (char **)(void *)0;
  return (void *)tmp_if_expr$1;
}

// llist_free
// file list.h line 168
void llist_free(struct anonymous$40 *a)
{
  struct llistnode_s *p = a->first;
  while(!(p == ((struct llistnode_s *)NULL)))
  {
    struct llistnode_s *next = p->next;
    free((void *)p);
    p = next;
  }
  a->first = (struct llistnode_s *)(void *)0;
  a->last = (struct llistnode_s *)(void *)0;
}

// llist_grow
// file list.h line 167
signed int llist_grow(struct anonymous$40 *a, unsigned long int len)
{
  struct llistnode_s *new;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct llistnode_s) /*8ul*/  + len);
  new = (struct llistnode_s *)return_value_malloc$1;
  if(new == ((struct llistnode_s *)NULL))
  {
    llist_free(a);
    return 0;
  }

  else
  {
    new->next = (struct llistnode_s *)(void *)0;
    if(a->first == ((struct llistnode_s *)NULL))
      a->first = new;

    else
      a->last->next = new;
    a->last = new;
    return 1;
  }
}

// llist_init
// file list.h line 130
static inline void llist_init(struct anonymous$40 *a)
{
  a->first = (struct llistnode_s *)(void *)0;
  a->last = (struct llistnode_s *)(void *)0;
}

// llist_isempty
// file list.h line 138
static inline signed int llist_isempty(struct anonymous$40 *a)
{
  return (signed int)(a->first == (struct llistnode_s *)(void *)0);
}

// llist_last
// file list.h line 161
static inline void * llist_last(struct anonymous$40 *a)
{
  struct llistnode_s *p = a->last;
  char **tmp_if_expr$1;
  if(!(p == ((struct llistnode_s *)NULL)))
    tmp_if_expr$1 = p->data;

  else
    tmp_if_expr$1 = (char **)(void *)0;
  return (void *)tmp_if_expr$1;
}

// llist_next
// file list.h line 153
static inline void * llist_next(void *ref)
{
  struct llistnode_s *next = *((struct llistnode_s **)ref - (signed long int)1);
  char **tmp_if_expr$1;
  if(!(next == ((struct llistnode_s *)NULL)))
    tmp_if_expr$1 = next->data;

  else
    tmp_if_expr$1 = (char **)(void *)0;
  return (void *)tmp_if_expr$1;
}

// loc2str
// file rr_types.c line 80
const char * loc2str(const void *binary, char *ascii, unsigned long int asclen)
{
  const unsigned char *cp = (const unsigned char *)binary;
  signed int latdeg;
  signed int latmin;
  signed int latsec;
  signed int latsecfrac;
  signed int longdeg;
  signed int longmin;
  signed int longsec;
  signed int longsecfrac;
  char northsouth;
  char eastwest;
  const char *altsign;
  signed int altmeters;
  signed int altfrac;
  const unsigned int referencealt = (const unsigned int)(100000 * 100);
  signed int latval;
  signed int longval;
  signed int altval;
  unsigned int templ;
  unsigned char sizeval;
  unsigned char hpval;
  unsigned char vpval;
  unsigned char versionval;
  char sizestr[(signed long int)sizeof(char [9l]) /*9l*/ ];
  char hpstr[(signed long int)sizeof(char [9l]) /*9l*/ ];
  char vpstr[(signed long int)sizeof(char [9l]) /*9l*/ ];
  const unsigned char *tmp_post$1 = cp;
  cp = cp + 1l;
  versionval = *tmp_post$1;
  const char *return_value_precsize_ntoa$18;
  const char *return_value_precsize_ntoa$20;
  if(!(versionval == 0))
    return (const char *)(void *)0;

  else
  {
    const unsigned char *tmp_post$2 = cp;
    cp = cp + 1l;
    sizeval = *tmp_post$2;
    const unsigned char *tmp_post$3 = cp;
    cp = cp + 1l;
    hpval = *tmp_post$3;
    const unsigned char *tmp_post$4 = cp;
    cp = cp + 1l;
    vpval = *tmp_post$4;
    do
    {
      unsigned int t_l;
      const unsigned char *t_cp = (const unsigned char *)cp;
      const unsigned char *tmp_post$5 = t_cp;
      t_cp = t_cp + 1l;
      t_l = (unsigned int)*tmp_post$5 << 24;
      const unsigned char *tmp_post$6 = t_cp;
      t_cp = t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post$6 << 16;
      const unsigned char *tmp_post$7 = t_cp;
      t_cp = t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post$7 << 8;
      const unsigned char *tmp_post$8 = t_cp;
      t_cp = t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post$8;
      templ = t_l;
      cp = (const unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    latval = (signed int)(templ - ((unsigned int)1 << 31));
    do
    {
      unsigned int loc2str$$1$$3$$t_l;
      const unsigned char *loc2str$$1$$3$$t_cp = (const unsigned char *)cp;
      const unsigned char *tmp_post$9 = loc2str$$1$$3$$t_cp;
      loc2str$$1$$3$$t_cp = loc2str$$1$$3$$t_cp + 1l;
      loc2str$$1$$3$$t_l = (unsigned int)*tmp_post$9 << 24;
      const unsigned char *tmp_post$10 = loc2str$$1$$3$$t_cp;
      loc2str$$1$$3$$t_cp = loc2str$$1$$3$$t_cp + 1l;
      loc2str$$1$$3$$t_l = loc2str$$1$$3$$t_l | (unsigned int)*tmp_post$10 << 16;
      const unsigned char *tmp_post$11 = loc2str$$1$$3$$t_cp;
      loc2str$$1$$3$$t_cp = loc2str$$1$$3$$t_cp + 1l;
      loc2str$$1$$3$$t_l = loc2str$$1$$3$$t_l | (unsigned int)*tmp_post$11 << 8;
      const unsigned char *tmp_post$12 = loc2str$$1$$3$$t_cp;
      loc2str$$1$$3$$t_cp = loc2str$$1$$3$$t_cp + 1l;
      loc2str$$1$$3$$t_l = loc2str$$1$$3$$t_l | (unsigned int)*tmp_post$12;
      templ = loc2str$$1$$3$$t_l;
      cp = (const unsigned char *)(void *)loc2str$$1$$3$$t_cp;
    }
    while((_Bool)0);
    longval = (signed int)(templ - ((unsigned int)1 << 31));
    do
    {
      unsigned int loc2str$$1$$4$$t_l;
      const unsigned char *loc2str$$1$$4$$t_cp = (const unsigned char *)cp;
      const unsigned char *tmp_post$13 = loc2str$$1$$4$$t_cp;
      loc2str$$1$$4$$t_cp = loc2str$$1$$4$$t_cp + 1l;
      loc2str$$1$$4$$t_l = (unsigned int)*tmp_post$13 << 24;
      const unsigned char *tmp_post$14 = loc2str$$1$$4$$t_cp;
      loc2str$$1$$4$$t_cp = loc2str$$1$$4$$t_cp + 1l;
      loc2str$$1$$4$$t_l = loc2str$$1$$4$$t_l | (unsigned int)*tmp_post$14 << 16;
      const unsigned char *tmp_post$15 = loc2str$$1$$4$$t_cp;
      loc2str$$1$$4$$t_cp = loc2str$$1$$4$$t_cp + 1l;
      loc2str$$1$$4$$t_l = loc2str$$1$$4$$t_l | (unsigned int)*tmp_post$15 << 8;
      const unsigned char *tmp_post$16 = loc2str$$1$$4$$t_cp;
      loc2str$$1$$4$$t_cp = loc2str$$1$$4$$t_cp + 1l;
      loc2str$$1$$4$$t_l = loc2str$$1$$4$$t_l | (unsigned int)*tmp_post$16;
      templ = loc2str$$1$$4$$t_l;
      cp = (const unsigned char *)(void *)loc2str$$1$$4$$t_cp;
    }
    while((_Bool)0);
    if(!(templ >= referencealt))
    {
      altval = (signed int)(referencealt - templ);
      altsign = "-";
    }

    else
    {
      altval = (signed int)(templ - referencealt);
      altsign = "";
    }
    if(!(latval >= 0))
    {
      northsouth = (char)83;
      latval = -latval;
    }

    else
      northsouth = (char)78;
    latsecfrac = latval % 1000;
    latval = latval / 1000;
    latsec = latval % 60;
    latval = latval / 60;
    latmin = latval % 60;
    latval = latval / 60;
    latdeg = latval;
    if(!(longval >= 0))
    {
      eastwest = (char)87;
      longval = -longval;
    }

    else
      eastwest = (char)69;
    longsecfrac = longval % 1000;
    longval = longval / 1000;
    longsec = longval % 60;
    longval = longval / 60;
    longmin = longval % 60;
    longval = longval / 60;
    longdeg = longval;
    altfrac = altval % 100;
    altmeters = altval / 100;
    const char *return_value_precsize_ntoa$17;
    return_value_precsize_ntoa$17=precsize_ntoa(sizeval, sizestr);
    _Bool tmp_if_expr$19;
    if(return_value_precsize_ntoa$17 == ((const char *)NULL))
      tmp_if_expr$19 = (_Bool)1;

    else
    {
      return_value_precsize_ntoa$18=precsize_ntoa(hpval, hpstr);
      tmp_if_expr$19 = !(return_value_precsize_ntoa$18 != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$21;
    if(tmp_if_expr$19)
      tmp_if_expr$21 = (_Bool)1;

    else
    {
      return_value_precsize_ntoa$20=precsize_ntoa(vpval, vpstr);
      tmp_if_expr$21 = !(return_value_precsize_ntoa$20 != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$21)
      return (const char *)(void *)0;

    else
    {
      signed int n;
      n=snprintf(ascii, asclen, "%d %.2d %.2d.%.3d %c %d %.2d %.2d.%.3d %c %s%d.%.2dm %sm %sm %sm", latdeg, latmin, latsec, latsecfrac, northsouth, longdeg, longmin, longsec, longsecfrac, eastwest, altsign, altmeters, altfrac, (const void *)sizestr, (const void *)hpstr, (const void *)vpstr);
      if((unsigned long int)n >= asclen || !(n >= 0))
        return (const char *)(void *)0;

      else
        return ascii;
    }
  }
}

// lock_cache_r
// file cache.c line 235
static void lock_cache_r(void)
{
  volatile signed int tmp_if_expr$1;
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    r_pend = r_pend + 1;
    do
    {
      if(!(r_pend / 2 + 2 >= rw_pend))
      {
        r_susp = 1;
        tmp_if_expr$1 = r_susp;
      }

      else
        tmp_if_expr$1 = r_susp;
      if(tmp_if_expr$1 == 0)
      {
        if(cache_w_lock == 0)
          break;

      }

      pthread_cond_wait(&r_cond, &lock_mutex);
    }
    while((_Bool)1);
    cache_r_lock = cache_r_lock + 1;
    r_pend = r_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
  }

}

// lock_cache_rw
// file cache.c line 269
static void lock_cache_rw(void)
{
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    rw_pend = rw_pend + 1;
    while(!(cache_r_lock == 0) || !(cache_w_lock == 0))
      pthread_cond_wait(&rw_cond, &lock_mutex);
    cache_w_lock = 1;
    rw_pend = rw_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
  }

}

// lock_server_data
// file servers.h line 41
void lock_server_data()
{
  pthread_mutex_lock(&servers_lock);
  server_data_users = server_data_users + 1;
  pthread_mutex_unlock(&servers_lock);
}

// log_message
// file error.h line 50
void log_message(signed int prior, const char *s, ...)
{
  signed int gotlock = 0;
  void **va;
  struct _IO_FILE *f;
  unsigned long int return_value_strftime$2;
  if(!(use_log_lock == 0))
  {
    gotlock=softlock_mutex(&loglock);
    if(!(gotlock == 0) || !(prior >= 6))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(global.daemon == 0))
    {
      openlog("pdnsd", 0x01, 3 << 3);
      va = (void **)&s;
      vsyslog(prior, s, va);
      va = ((void **)NULL);
      closelog();
    }

    else
    {
      f = stderr;
      goto printtofile;
    }
    if(!(debug_p == 0))
    {
      f = dbg_file;

    printtofile:
      ;
      char ts[(signed long int)sizeof(char [19l]) /*19l*/ ];
      signed long int tt;
      tt=time((signed long int *)(void *)0);
      struct tm tm;
      struct tm *return_value_localtime_r$1;
      return_value_localtime_r$1=localtime_r(&tt, &tm);
      _Bool tmp_if_expr$3;
      if(return_value_localtime_r$1 == ((struct tm *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strftime$2=strftime(ts, sizeof(char [19l]) /*19ul*/ , "* %m/%d %T| ", &tm);
        tmp_if_expr$3 = return_value_strftime$2 <= (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        ts[(signed long int)0] = (char)0;

      fprintf(f, "%spdnsd: %s: ", (const void *)ts, prior <= 2 ? "critical" : (prior == 3 ? "error" : (prior == 4 ? "warning" : "info")));
      va = (void **)&s;
      vfprintf(f, s, va);
      va = ((void **)NULL);
      const char *p;
      p=strchr(s, 0);
      _Bool tmp_if_expr$4;
      if(p == ((const char *)NULL) || p == s)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)*(p - (signed long int)1) != 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        fputc(10, f);

    }

    if(!(gotlock == 0))
      pthread_mutex_unlock(&loglock);

  }
}

// lookup_cache
// file cache.h line 179
struct anonymous$0 * lookup_cache(const unsigned char *name, signed int *wild)
{
  signed int purge = 0;
  struct anonymous$0 *ret;
  lock_cache_r();
  ret=dns_lookup(name, (struct anonymous$58 *)(void *)0);
  if(!(wild == ((signed int *)NULL)))
  {
    *wild = 0;
    if(ret == ((struct anonymous$0 *)NULL))
    {
      const unsigned char *lookup_cache$$1$$1$$1$$nm = name;
      unsigned int lb = (unsigned int)*lookup_cache$$1$$1$$1$$nm;
      if(!(lb == 0u))
        do
        {
          lookup_cache$$1$$1$$1$$nm = lookup_cache$$1$$1$$1$$nm + (signed long int)(lb + (unsigned int)1);
          lb = (unsigned int)*lookup_cache$$1$$1$$1$$nm;
          if(lb == 0u)
            break;

          ret=dns_lookup(lookup_cache$$1$$1$$1$$nm, (struct anonymous$58 *)(void *)0);
          if(!(ret == ((struct anonymous$0 *)NULL)))
          {
            if(!((1 & (signed int)ret->flags) == 0))
              *wild = 2;

            else
              if(!((16 & (signed int)ret->flags) == 0))
              {
                unsigned char buf[256l];
                buf[(signed long int)0] = (unsigned char)1;
                buf[(signed long int)1] = (unsigned char)42;
                rhncpy(&buf[(signed long int)2], lookup_cache$$1$$1$$1$$nm);
                ret=dns_lookup(buf, (struct anonymous$58 *)(void *)0);
                if(!(ret == ((struct anonymous$0 *)NULL)))
                  *wild = 1;

              }

              else
                if(!((2 & (signed int)ret->flags) == 0))
                  *wild = 3;

                else
                  ret = (struct anonymous$0 *)(void *)0;
            break;
          }

        }
        while((_Bool)1);

    }

  }

  if(!(ret == ((struct anonymous$0 *)NULL)))
  {
    purge=purge_cent(ret, 1, 1);
    if(purge == 0)
      ret=copy_cent(ret);

  }

  unlock_cache_r();
  if(!(purge == 0))
  {
    lock_cache_rw();
    ret=dns_lookup(name, (struct anonymous$58 *)(void *)0);
    if(!(wild == ((signed int *)NULL)))
    {
      *wild = 0;
      if(ret == ((struct anonymous$0 *)NULL))
      {
        const unsigned char *nm = name;
        unsigned int lookup_cache$$1$$3$$1$$1$$lb = (unsigned int)*nm;
        if(!(lookup_cache$$1$$3$$1$$1$$lb == 0u))
          do
          {
            nm = nm + (signed long int)(lookup_cache$$1$$3$$1$$1$$lb + (unsigned int)1);
            lookup_cache$$1$$3$$1$$1$$lb = (unsigned int)*nm;
            if(lookup_cache$$1$$3$$1$$1$$lb == 0u)
              break;

            ret=dns_lookup(nm, (struct anonymous$58 *)(void *)0);
            if(!(ret == ((struct anonymous$0 *)NULL)))
            {
              if(!((1 & (signed int)ret->flags) == 0))
                *wild = 2;

              else
                if(!((16 & (signed int)ret->flags) == 0))
                {
                  unsigned char lookup_cache$$1$$3$$1$$1$$1$$1$$1$$1$$buf[256l];
                  lookup_cache$$1$$3$$1$$1$$1$$1$$1$$1$$buf[(signed long int)0] = (unsigned char)1;
                  lookup_cache$$1$$3$$1$$1$$1$$1$$1$$1$$buf[(signed long int)1] = (unsigned char)42;
                  rhncpy(&lookup_cache$$1$$3$$1$$1$$1$$1$$1$$1$$buf[(signed long int)2], nm);
                  ret=dns_lookup(lookup_cache$$1$$3$$1$$1$$1$$1$$1$$1$$buf, (struct anonymous$58 *)(void *)0);
                  if(!(ret == ((struct anonymous$0 *)NULL)))
                    *wild = 1;

                }

                else
                  if(!((2 & (signed int)ret->flags) == 0))
                    *wild = 3;

                  else
                    ret = (struct anonymous$0 *)(void *)0;
              break;
            }

          }
          while((_Bool)1);

      }

    }

    if(!(ret == ((struct anonymous$0 *)NULL)))
    {
      signed int return_value_purge_cent$1;
      return_value_purge_cent$1=purge_cent(ret, 1, 0);
      if(!(return_value_purge_cent$1 >= 0))
        ret = (struct anonymous$0 *)(void *)0;

      else
        ret=copy_cent(ret);
    }

    unlock_cache_rw();
  }

  return ret;
}

// lookup_cache_local_rrset
// file cache.h line 180
struct anonymous * lookup_cache_local_rrset(const unsigned char *name, signed int type)
{
  struct anonymous *ret = (struct anonymous *)(void *)0;
  struct anonymous$0 *cent;
  lock_cache_r();
  cent=dns_lookup(name, (struct anonymous$58 *)(void *)0);
  if(!(cent == ((struct anonymous$0 *)NULL)))
  {
    struct anonymous *rrset;
    rrset=getrrset$link2(cent, type);
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      if(!((2 & (signed int)rrset->flags) == 0))
        ret=copy_rrset(rrset);

    }

  }

  unlock_cache_r();
  return ret;
}

// lookup_cache_status
// file dns_query.c line 3235
static signed int lookup_cache_status(const unsigned char *name, signed int thint, struct anonymous$0 **cachedp, unsigned short int *flagsp, signed long int queryts, unsigned char *c_soa)
{
  struct anonymous$0 *cached;
  signed int rc = 0xfffa;
  signed int wild = 0;
  unsigned short int flags = (unsigned short int)0;
  cached=lookup_cache(name, &wild);
  const unsigned char *return_value_rhn2str$1;
  char *return_value_flags2str$2;
  unsigned int return_value_rhnsegcnt$3;
  unsigned int return_value_rhnsegcnt$4;
  const unsigned char *return_value_rhn2str$7;
  signed int return_value_set_flags_ttl$11;
  struct anonymous *tmp_if_expr$12;
  struct anonymous *return_value_getrrset$9;
  char *return_value_flags2str$14;
  char *return_value_flags2str$15;
  if(!(cached == ((struct anonymous$0 *)NULL)))
  {
    signed short int neg = (signed short int)0;
    signed short int timed = (signed short int)0;
    signed short int need_req = (signed short int)0;
    signed long int ttl = (signed long int)0;
    if(!((2 & (signed int)cached->flags) == 0))
    {
      char dflagstr[20l];
      unsigned char _debugstrbuf[256l];
      if(!(debug_p == 0))
      {
        return_value_rhn2str$1=rhn2str(cached->qname, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
        return_value_flags2str$2=flags2str((unsigned int)cached->flags, dflagstr, 5, dflgnames);
        debug_msg(0, "Entry found in cache for '%s' with dflags=%s.\n", return_value_rhn2str$1, return_value_flags2str$2);
      }

      if(wild == 3 || !((1 & (signed int)cached->flags) == 0))
      {
        if(!(c_soa == ((unsigned char *)NULL)))
        {
          if(!((signed int)cached->c_soa == 0xff))
            *c_soa = cached->c_soa;

          else
          {
            _Bool tmp_if_expr$5;
            if((1 & (signed int)cached->flags) == 0)
              tmp_if_expr$5 = cached->$anon0.rr.rrmu[(signed long int)3] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$5 = (_Bool)0;
            _Bool tmp_if_expr$6;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = cached->$anon0.rr.rrmu[(signed long int)3]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$6 = (_Bool)0;
            if(tmp_if_expr$6)
            {
              return_value_rhnsegcnt$3=rhnsegcnt$link1(cached->qname);
              *c_soa = (unsigned char)return_value_rhnsegcnt$3;
            }

            else
            {
              unsigned char *owner;
              owner=getlocalowner(cached->qname, 6);
              if(!(owner == ((unsigned char *)NULL)))
              {
                return_value_rhnsegcnt$4=rhnsegcnt$link1(owner);
                *c_soa = (unsigned char)return_value_rhnsegcnt$4;
              }

            }
          }
        }

        free_cent(cached);
        free((void *)cached);
        rc = 3;
        goto return_rc;
      }

      rc = 0;
    }

    else
    {
      unsigned char lookup_cache_status$$1$$1$$2$$_debugstrbuf[256l];
      if(!(debug_p == 0))
      {
        return_value_rhn2str$7=rhn2str(cached->qname, lookup_cache_status$$1$$1$$2$$_debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
        debug_msg(0, "Record found in cache for %s\n", return_value_rhn2str$7);
      }

      if(!((1 & (signed int)cached->flags) == 0))
      {
        signed long int tmp_if_expr$8;
        if(!(cached->$anon0.neg.ttl >= 120l))
          tmp_if_expr$8 = (signed long int)120;

        else
          tmp_if_expr$8 = cached->$anon0.neg.ttl;
        ttl = cached->$anon0.neg.ts + tmp_if_expr$8;
        if(ttl >= queryts)
          neg = (signed short int)1;

        else
          timed = (signed short int)1;
      }

      else
      {
        if(thint == 255)
          set_all_flags_ttl(&flags, &ttl, cached);

        else
        {
          return_value_set_flags_ttl$11=set_flags_ttl(&flags, &ttl, cached, 5);
          _Bool tmp_if_expr$13;
          if(return_value_set_flags_ttl$11 == 0)
            tmp_if_expr$13 = (_Bool)1;

          else
          {
            if((1 & (signed int)cached->flags) == 0)
              tmp_if_expr$12 = cached->$anon0.rr.rrmu[(signed long int)2];

            else
              tmp_if_expr$12 = (struct anonymous *)(void *)0;
            tmp_if_expr$13 = ((signed int)tmp_if_expr$12->flags & 1) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$13)
          {
            flags = (unsigned short int)0;
            ttl = (signed long int)0;
            if(thint >= 1 && !(thint >= 52))
            {
              signed int return_value_set_flags_ttl$10;
              return_value_set_flags_ttl$10=set_flags_ttl(&flags, &ttl, cached, thint);
              if(!(return_value_set_flags_ttl$10 == 0))
              {
                return_value_getrrset$9=getrrset$link1(cached, thint);
                neg = (signed short int)(((signed int)return_value_getrrset$9->flags & 1) != 0 ? (ttl >= queryts ? (_Bool)1 : (_Bool)0) : (_Bool)0);
              }

            }

            else
              if(thint == 253)
              {
                set_flags_ttl(&flags, &ttl, cached, 7);
                set_flags_ttl(&flags, &ttl, cached, 8);
                set_flags_ttl(&flags, &ttl, cached, 9);
              }

              else
                if(thint == 254)
                {
                  set_flags_ttl(&flags, &ttl, cached, 3);
                  set_flags_ttl(&flags, &ttl, cached, 4);
                }

          }

        }
        if((2 & (signed int)flags) == 0)
        {
          if(thint == 255)
          {
            if((4 & (signed int)cached->flags) == 0)
              need_req = (signed short int)1;

          }

          else
            if(thint >= 251 && !(thint >= 256))
            {
              if(!((16 & (signed int)flags) == 0) || (4 & (signed int)flags) == 0)
                need_req = (signed short int)1;

            }

          if(!(ttl >= queryts))
            timed = (signed short int)1;

        }

      }
      char lookup_cache_status$$1$$1$$5$$dflagstr[20l];
      char cflagstr[28l];
      if(!(debug_p == 0))
      {
        return_value_flags2str$14=flags2str((unsigned int)cached->flags, lookup_cache_status$$1$$1$$5$$dflagstr, 5, dflgnames);
        return_value_flags2str$15=flags2str((unsigned int)flags, cflagstr, 7, cflgnames);
        debug_msg(0, "Requery decision: dflags=%s, cflags=%s, req=%i, neg=%i, timed=%i, %s=%li\n", return_value_flags2str$14, return_value_flags2str$15, need_req, neg, timed, ttl != 0l ? "ttl" : "timestamp", (signed long int)(ttl != 0l ? ttl - queryts : ttl));
      }

      rc = !(neg != 0) && (need_req != 0 || timed != 0) ? 0xfffc : 0xfffb;
    }

  return_rc_cent:
    ;
    *cachedp = cached;
  }


return_rc:
  ;
  if(!(flagsp == ((unsigned short int *)NULL)))
    *flagsp = flags;

  return rc;
}

// lookup_cent_array
// file dns_query.c line 1094
static struct anonymous$0 * lookup_cent_array(struct anonymous$16 *ca, const unsigned char *nm)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link2((struct anonymous$3 *)ca);
  n = (signed int)return_value_da_nel$1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous$0 *ce = &ca->elem[(signed long int)i];
    signed int return_value_rhnicmp$2;
    return_value_rhnicmp$2=rhnicmp$link1(ce->qname, nm);
    if(!(return_value_rhnicmp$2 == 0))
      return ce;

  }
  return (struct anonymous$0 *)(void *)0;
}

// lookup_const
// file consts.h line 66
signed int lookup_const(const char *name, signed int len)
{
  signed int return_value_binsearch_keyword$1;
  return_value_binsearch_keyword$1=binsearch_keyword(name, len, const_dic, (signed int)(sizeof(const struct anonymous$32 [29l]) /*464ul*/  / sizeof(struct anonymous$32) /*16ul*/ ));
  return return_value_binsearch_keyword$1;
}

// lookup_ns
// file dns_query.c line 2904
static struct anonymous$14 * lookup_ns(const unsigned char *domain)
{
  struct anonymous$14 *res = (struct anonymous$14 *)(void *)0;
  struct anonymous$0 *cent;
  cent=lookup_cache(domain, (signed int *)(void *)0);
  signed long int return_value_time$19;
  signed long int return_value_time$5;
  signed long int return_value_time$13;
  if(!(cent == ((struct anonymous$0 *)NULL)))
  {
    struct anonymous *lookup_ns$$1$$1$$rrset;
    struct anonymous *tmp_if_expr$1;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr$1 = cent->$anon0.rr.rrmu[(signed long int)1];

    else
      tmp_if_expr$1 = (struct anonymous *)(void *)0;
    lookup_ns$$1$$1$$rrset = tmp_if_expr$1;
    if(!(lookup_ns$$1$$1$$rrset == ((struct anonymous *)NULL)))
    {
      if(!((64 & (signed int)lookup_ns$$1$$1$$rrset->flags) == 0))
      {
        signed long int tmp_if_expr$18;
        if(!(lookup_ns$$1$$1$$rrset->ttl >= 120l))
          tmp_if_expr$18 = (signed long int)120;

        else
          tmp_if_expr$18 = lookup_ns$$1$$1$$rrset->ttl;
        return_value_time$19=time((signed long int *)(void *)0);
        if(lookup_ns$$1$$1$$rrset->ts + tmp_if_expr$18 >= return_value_time$19)
        {
          struct rr_b_s *rr = lookup_ns$$1$$1$$rrset->rrs;
          for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
          {
            struct anonymous$15 *serva;
            struct anonymous$0 *servent;
            struct anonymous$3 *return_value_da_grow1$2;
            return_value_da_grow1$2=da_grow1((struct anonymous$3 *)res, (unsigned long int)((struct anonymous$14 *)0)->elem, sizeof(struct anonymous$15) /*20ul*/ , (void (*)(void *))(void *)0);
            res = (struct anonymous$14 *)return_value_da_grow1$2;
            if(res == ((struct anonymous$14 *)NULL))
            {
              if(!(debug_p == 0))
                debug_msg(0, "Out of memory in lookup_ns()\n");

              break;
            }

            serva = &res->elem[(signed long int)(res->nel - (unsigned long int)1)];
            if(run_ipv4 == 0)
              serva->ipv6 = in6addr_any;

            serva->ipv4.s_addr = (unsigned int)0x00000000;
            servent=lookup_cache((unsigned char *)rr->data, (signed int *)(void *)0);
            if(!(servent == ((struct anonymous$0 *)NULL)))
            {
              if(!(run_ipv4 == 0))
              {
                struct anonymous *rrset;
                struct anonymous *tmp_if_expr$3;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr$3 = servent->$anon0.rr.rrmu[(signed long int)0];

                else
                  tmp_if_expr$3 = (struct anonymous *)(void *)0;
                rrset = tmp_if_expr$3;
                if(!(rrset == ((struct anonymous *)NULL)))
                {
                  signed long int tmp_if_expr$4;
                  if(!(rrset->ttl >= 120l))
                    tmp_if_expr$4 = (signed long int)120;

                  else
                    tmp_if_expr$4 = rrset->ttl;
                  return_value_time$5=time((signed long int *)(void *)0);
                  if(rrset->ts + tmp_if_expr$4 >= return_value_time$5)
                  {
                    if(!(rrset->rrs == ((struct rr_b_s *)NULL)))
                      serva->ipv4 = *((struct in_addr *)rrset->rrs->data);

                  }

                }

              }

              else
              {
                struct anonymous *lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset;
                struct anonymous *tmp_if_expr$15;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr$15 = servent->$anon0.rr.rrmu[(signed long int)7];

                else
                  tmp_if_expr$15 = (struct anonymous *)(void *)0;
                lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset = tmp_if_expr$15;
                _Bool tmp_if_expr$16;
                if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset == ((struct anonymous *)NULL)))
                  tmp_if_expr$16 = !(((signed int)lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->flags & 1) != 0) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$16 = (_Bool)0;
                if(tmp_if_expr$16)
                {
                  signed long int tmp_if_expr$10;
                  if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ttl >= 120l))
                    tmp_if_expr$10 = (signed long int)120;

                  else
                    tmp_if_expr$10 = lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ttl;
                  signed long int return_value_time$11;
                  return_value_time$11=time((signed long int *)(void *)0);
                  if(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ts + tmp_if_expr$10 >= return_value_time$11)
                  {
                    if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->rrs == ((struct rr_b_s *)NULL)))
                    {
                      serva->ipv6 = *((struct in6_addr *)lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->rrs->data);
                      struct anonymous *tmp_if_expr$9;
                      if((1 & (signed int)servent->flags) == 0)
                        tmp_if_expr$9 = servent->$anon0.rr.rrmu[(signed long int)0];

                      else
                        tmp_if_expr$9 = (struct anonymous *)(void *)0;
                      lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset = tmp_if_expr$9;
                      if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset == ((struct anonymous *)NULL)))
                      {
                        if((1 & (signed int)lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->flags) == 0)
                        {
                          signed long int tmp_if_expr$6;
                          if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ttl >= 120l))
                            tmp_if_expr$6 = (signed long int)120;

                          else
                            tmp_if_expr$6 = lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ttl;
                          signed long int return_value_time$7;
                          return_value_time$7=time((signed long int *)(void *)0);
                          _Bool tmp_if_expr$8;
                          if(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ts + tmp_if_expr$6 >= return_value_time$7)
                            tmp_if_expr$8 = lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr$8 = (_Bool)0;
                          if(tmp_if_expr$8)
                            serva->ipv4 = *((struct in_addr *)lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->rrs->data);

                          else
                            serva->ipv6 = in6addr_any;
                        }

                      }

                    }

                  }

                }

                else
                {
                  struct anonymous *tmp_if_expr$14;
                  if((1 & (signed int)servent->flags) == 0)
                    tmp_if_expr$14 = servent->$anon0.rr.rrmu[(signed long int)0];

                  else
                    tmp_if_expr$14 = (struct anonymous *)(void *)0;
                  lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset = tmp_if_expr$14;
                  if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset == ((struct anonymous *)NULL)))
                  {
                    signed long int tmp_if_expr$12;
                    if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ttl >= 120l))
                      tmp_if_expr$12 = (signed long int)120;

                    else
                      tmp_if_expr$12 = lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ttl;
                    return_value_time$13=time((signed long int *)(void *)0);
                    if(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->ts + tmp_if_expr$12 >= return_value_time$13)
                    {
                      if(!(lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->rrs == ((struct rr_b_s *)NULL)))
                      {
                        struct in_addr *ina = (struct in_addr *)lookup_ns$$1$$1$$1$$1$$1$$2$$2$$rrset->rrs->data;
                        ((unsigned int *)&serva->ipv6)[(signed long int)3] = ina->s_addr;
                        ((unsigned int *)&serva->ipv6)[(signed long int)2]=htonl((unsigned int)0xffff);
                        ((unsigned int *)&serva->ipv6)[(signed long int)0] = (unsigned int)0;
                        ((unsigned int *)&serva->ipv6)[(signed long int)1] = ((unsigned int *)&serva->ipv6)[(signed long int)0];
                      }

                    }

                  }

                }
              }
              free_cent(servent);
              free((void *)servent);
            }

            signed int return_value_is_inaddr2_any$17;
            return_value_is_inaddr2_any$17=is_inaddr2_any(serva);
            if(!(return_value_is_inaddr2_any$17 == 0))
            {
              free((void *)res);
              res = (struct anonymous$14 *)(void *)0;
              break;
            }

          }
        }

      }

    }

    free_cent(cent);
    free((void *)cent);
  }

  return res;
}

// main
// file main.c line 220
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int sig;
  signed int pfd = -1;
  main_thrid=pthread_self();
  servstat_thrid = main_thrid;
  statsock_thrid = main_thrid;
  tcps_thrid = main_thrid;
  udps_thrid = main_thrid;
  init_uid=getuid();
  signed int main$$1$$1$$err;
  main$$1$$1$$err=inet_pton(10, "::ffff:0.0.0.0", (void *)&global.ipv4_6_prefix);
  if(!(main$$1$$1$$err >= 1))
  {
    fprintf(stderr, "Error: inet_pton() wont accept default prefix %s in %s, line %d\n", (const void *)"::ffff:0.0.0.0", (const void *)"main.c", 235);
    if(!(main$$1$$1$$err == 0))
      perror("inet_pton");

    exit(1);
  }

  i = 1;
  signed int return_value_strcmp$48;
  signed int return_value_strcmp$44;
  signed int return_value_strcmp$45;
  signed int return_value_strcmp$41;
  signed int return_value_strcmp$42;
  signed int return_value_strcmp$40;
  signed int return_value_strcmp$39;
  signed int return_value_strcmp$38;
  signed int return_value_strcmp$35;
  signed int return_value_strcmp$36;
  signed int return_value_strcmp$32;
  signed int return_value_strcmp$33;
  signed int return_value_strcmp$31;
  signed int return_value_strcmp$28;
  signed int return_value_strcmp$29;
  signed int return_value_strcmp$27;
  signed int return_value_strcmp$24;
  signed int return_value_strcmp$25;
  signed int return_value_strcmp$23;
  signed int return_value_strcmp$22;
  signed int return_value_strncmp$21;
  const unsigned short int **return_value___ctype_b_loc$5;
  signed int return_value_strncmp$20;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strncmp$13;
  for( ; !(i >= argc); i = i + 1)
  {
    char *arg = argv[(signed long int)i];
    signed int return_value_strcmp$47;
    return_value_strcmp$47=strcmp(arg, "-h");
    _Bool tmp_if_expr$49;
    if(return_value_strcmp$47 == 0)
      tmp_if_expr$49 = (_Bool)1;

    else
    {
      return_value_strcmp$48=strcmp(arg, "--help");
      tmp_if_expr$49 = return_value_strcmp$48 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$49)
    {
      fputs(info_message, stdout);
      fputs(help_message, stdout);
      exit(1);
    }

    else
    {
      return_value_strcmp$44=strcmp(arg, "-V");
      _Bool tmp_if_expr$46;
      if(return_value_strcmp$44 == 0)
        tmp_if_expr$46 = (_Bool)1;

      else
      {
        return_value_strcmp$45=strcmp(arg, "--version");
        tmp_if_expr$46 = return_value_strcmp$45 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$46)
      {
        fputs(info_message, stdout);
        exit(1);
      }

      else
      {
        return_value_strcmp$41=strcmp(arg, "-c");
        _Bool tmp_if_expr$43;
        if(return_value_strcmp$41 == 0)
          tmp_if_expr$43 = (_Bool)1;

        else
        {
          return_value_strcmp$42=strcmp(arg, "--config-file");
          tmp_if_expr$43 = return_value_strcmp$42 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$43)
        {
          i = i + 1;
          if(!(i >= argc))
            conf_file = argv[(signed long int)i];

          else
          {
            fprintf(stderr, "Error: file name expected after %s option.\n", arg);
            exit(1);
          }
        }

        else
        {
          return_value_strcmp$40=strcmp(arg, "-4");
          if(return_value_strcmp$40 == 0)
          {
            run_ipv4 = (signed short int)1;
            cmdlineipv = (signed short int)1;
          }

          else
          {
            return_value_strcmp$39=strcmp(arg, "-6");
            if(return_value_strcmp$39 == 0)
            {
              run_ipv4 = (signed short int)0;
              cmdlineipv = (signed short int)1;
            }

            else
            {
              return_value_strcmp$38=strcmp(arg, "-a");
              if(return_value_strcmp$38 == 0)
              {
                signed int rv;
                rv=check_ipv6();
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location$1;
                  return_value___errno_location$1=__errno_location();
                  char *return_value_strerror$2;
                  return_value_strerror$2=strerror(*return_value___errno_location$1);
                  fprintf(stderr, "Error: -a: can't check availability of IPv6: %s\nTry using -4 or -6 option instead.\n", return_value_strerror$2);
                  exit(1);
                }

                run_ipv4 = (signed short int)!(rv != 0);
                if(!(run_ipv4 == 0))
                  fprintf(stderr, "Switching to IPv4 mode.\n");

                cmdlineipv = (signed short int)1;
              }

              else
              {
                return_value_strcmp$35=strcmp(arg, "-i");
                _Bool tmp_if_expr$37;
                if(return_value_strcmp$35 == 0)
                  tmp_if_expr$37 = (_Bool)1;

                else
                {
                  return_value_strcmp$36=strcmp(arg, "--ipv4_6_prefix");
                  tmp_if_expr$37 = return_value_strcmp$36 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$37)
                {
                  i = i + 1;
                  if(!(i >= argc))
                  {
                    signed int return_value_inet_pton$3;
                    return_value_inet_pton$3=inet_pton(10, argv[(signed long int)i], (void *)&global.ipv4_6_prefix);
                    if(!(return_value_inet_pton$3 >= 1))
                    {
                      fprintf(stderr, "Error: %s: argument not a valid IPv6 address.\n", arg);
                      exit(1);
                    }

                    cmdline.prefix = (char)1;
                  }

                  else
                  {
                    fprintf(stderr, "Error: IPv6 address expected after %s option.\n", arg);
                    exit(1);
                  }
                }

                else
                {
                  return_value_strcmp$32=strcmp(arg, "-s");
                  _Bool tmp_if_expr$34;
                  if(return_value_strcmp$32 == 0)
                    tmp_if_expr$34 = (_Bool)1;

                  else
                  {
                    return_value_strcmp$33=strcmp(arg, "--status");
                    tmp_if_expr$34 = return_value_strcmp$33 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$34)
                  {
                    global.stat_pipe = (char)1;
                    cmdline.stat_pipe = (char)1;
                  }

                  else
                  {
                    return_value_strcmp$31=strcmp(arg, "--nostatus");
                    if(return_value_strcmp$31 == 0)
                    {
                      global.stat_pipe = (char)0;
                      cmdline.stat_pipe = (char)1;
                    }

                    else
                    {
                      return_value_strcmp$28=strcmp(arg, "-d");
                      _Bool tmp_if_expr$30;
                      if(return_value_strcmp$28 == 0)
                        tmp_if_expr$30 = (_Bool)1;

                      else
                      {
                        return_value_strcmp$29=strcmp(arg, "--daemon");
                        tmp_if_expr$30 = return_value_strcmp$29 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$30)
                      {
                        global.daemon = (char)1;
                        cmdline.daemon = (char)1;
                      }

                      else
                      {
                        return_value_strcmp$27=strcmp(arg, "--nodaemon");
                        if(return_value_strcmp$27 == 0)
                        {
                          global.daemon = (char)0;
                          cmdline.daemon = (char)1;
                        }

                        else
                        {
                          return_value_strcmp$24=strcmp(arg, "-t");
                          _Bool tmp_if_expr$26;
                          if(return_value_strcmp$24 == 0)
                            tmp_if_expr$26 = (_Bool)1;

                          else
                          {
                            return_value_strcmp$25=strcmp(arg, "--tcp");
                            tmp_if_expr$26 = return_value_strcmp$25 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr$26)
                          {
                            global.notcp = (char)0;
                            cmdline.notcp = (char)1;
                          }

                          else
                          {
                            return_value_strcmp$23=strcmp(arg, "--notcp");
                            if(return_value_strcmp$23 == 0)
                            {
                              global.notcp = (char)1;
                              cmdline.notcp = (char)1;
                            }

                            else
                            {
                              return_value_strcmp$22=strcmp(arg, "-p");
                              if(return_value_strcmp$22 == 0)
                              {
                                i = i + 1;
                                if(!(i >= argc))
                                {
                                  global.pidfile = argv[(signed long int)i];
                                  cmdline.pidfile = (char)1;
                                }

                                else
                                {
                                  fprintf(stderr, "Error: file name expected after -p option.\n");
                                  exit(1);
                                }
                              }

                              else
                              {
                                return_value_strncmp$21=strncmp(arg, "-v", (unsigned long int)2);
                                if(return_value_strncmp$21 == 0)
                                {
                                  unsigned long int return_value_strlen$4;
                                  return_value_strlen$4=strlen(arg);
                                  _Bool tmp_if_expr$6;
                                  if(!(return_value_strlen$4 == 3ul))
                                    tmp_if_expr$6 = (_Bool)1;

                                  else
                                  {
                                    return_value___ctype_b_loc$5=__ctype_b_loc();
                                    tmp_if_expr$6 = !(((signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)arg[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
                                  }
                                  if(tmp_if_expr$6)
                                  {
                                    fprintf(stderr, "Error: one digit expected after -v option (like -v2).\n");
                                    exit(1);
                                  }

                                  global.verbosity = (signed short int)((signed int)arg[(signed long int)2] - 48);
                                  cmdline.verbosity = (char)1;
                                }

                                else
                                {
                                  return_value_strncmp$20=strncmp(arg, "-m", (unsigned long int)2);
                                  if(return_value_strncmp$20 == 0)
                                  {
                                    unsigned long int return_value_strlen$7;
                                    return_value_strlen$7=strlen(arg);
                                    if(!(return_value_strlen$7 == 4ul))
                                    {
                                      fprintf(stderr, "Error: uo, to or tu expected after the  -m option (like -muo).\n");
                                      exit(1);
                                    }

                                    signed int return_value_strcmp$11;
                                    return_value_strcmp$11=strcmp(&arg[(signed long int)2], "uo");
                                    if(return_value_strcmp$11 == 0)
                                      global.query_method = 12;

                                    else
                                    {
                                      return_value_strcmp$10=strcmp(&arg[(signed long int)2], "to");
                                      if(return_value_strcmp$10 == 0)
                                        global.query_method = 13;

                                      else
                                      {
                                        return_value_strcmp$9=strcmp(&arg[(signed long int)2], "tu");
                                        if(return_value_strcmp$9 == 0)
                                          global.query_method = 14;

                                        else
                                        {
                                          return_value_strcmp$8=strcmp(&arg[(signed long int)2], "ut");
                                          if(return_value_strcmp$8 == 0)
                                            global.query_method = 15;

                                          else
                                          {
                                            fprintf(stderr, "Error: uo, to, tu or ut expected after the  -m option (like -muo).\n");
                                            exit(1);
                                          }
                                        }
                                      }
                                    }
                                    cmdline.query_method = (char)1;
                                  }

                                  else
                                  {
                                    return_value_strcmp$17=strcmp(arg, "-g");
                                    _Bool tmp_if_expr$19;
                                    if(return_value_strcmp$17 == 0)
                                      tmp_if_expr$19 = (_Bool)1;

                                    else
                                    {
                                      return_value_strcmp$18=strcmp(arg, "--debug");
                                      tmp_if_expr$19 = return_value_strcmp$18 == 0 ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr$19)
                                    {
                                      global.debug = (char)1;
                                      cmdline.debug = (char)1;
                                    }

                                    else
                                    {
                                      return_value_strcmp$16=strcmp(arg, "--nodebug");
                                      if(return_value_strcmp$16 == 0)
                                      {
                                        global.debug = (char)0;
                                        cmdline.debug = (char)1;
                                      }

                                      else
                                      {
                                        return_value_strcmp$15=strcmp(arg, "--pdnsd-user");
                                        if(return_value_strcmp$15 == 0)
                                          cmdline.pdnsduser = (char)1;

                                        else
                                        {
                                          char *equ;
                                          equ=strchr(arg, 61);
                                          if(!(equ == ((char *)NULL)))
                                          {
                                            signed int plen = (signed int)(equ - arg);
                                            char *valstr = equ + (signed long int)1;
                                            signed int return_value_strncmp$14;
                                            return_value_strncmp$14=strncmp(arg, "--config-file", sizeof(char [14l]) /*14ul*/  - (unsigned long int)1);
                                            if(return_value_strncmp$14 == 0 && (unsigned long int)plen == 13ul)
                                              conf_file = valstr;

                                            else
                                            {
                                              return_value_strncmp$13=strncmp(arg, "--ipv4_6_prefix", sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
                                              if(return_value_strncmp$13 == 0 && (unsigned long int)plen == 15ul)
                                              {
                                                signed int return_value_inet_pton$12;
                                                return_value_inet_pton$12=inet_pton(10, valstr, (void *)&global.ipv4_6_prefix);
                                                if(!(return_value_inet_pton$12 >= 1))
                                                {
                                                  fprintf(stderr, "Error: --ipv4_6_prefix: argument not a valid IPv6 address.\n");
                                                  exit(1);
                                                }

                                                cmdline.prefix = (char)1;
                                              }

                                              else
                                              {
                                                fprintf(stderr, "Error: unknown option: %.*s\n", plen, arg);
                                                exit(1);
                                              }
                                            }
                                          }

                                          else
                                          {
                                            fprintf(stderr, "Error: unknown option: %s\n", arg);
                                            exit(1);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  mk_dns_hash();
  char *errmsg;
  signed int return_value_read_config_file$50;
  return_value_read_config_file$50=read_config_file(conf_file, &global, &servers, 0, &errmsg);
  if(return_value_read_config_file$50 == 0)
  {
    fputs((_Bool)errmsg ? errmsg : "Out of memory.", stderr);
    fputc(10, stderr);
    exit(3);
  }

  if(!(cmdline.pdnsduser == 0))
  {
    if(!(global.run_as[0l] == 0))
      printf("%s\n", (const void *)global.run_as);

    else
    {
      unsigned int uid;
      uid=getuid();
      struct passwd *pws;
      pws=getpwuid(uid);
      if(!(pws == ((struct passwd *)NULL)))
        printf("%s\n", pws->pw_name);

      else
        printf("%i\n", uid);
    }
    exit(0);
  }

  if(global.cache_dir == ((char *)NULL))
    global.cache_dir = "/var/cache/pdnsd";

  if(global.scheme_file == ((char *)NULL))
    global.scheme_file = "/var/lib/pcmcia/scheme";

  stat_pipe = (signed short int)global.stat_pipe;
  unsigned int return_value_da_nel$51;
  if(global.run_as[0l] == 0 || global.strict_suid == 0)
  {
    i = 0;
    do
    {
      return_value_da_nel$51=da_nel$link3((struct anonymous$3 *)servers);
      if((unsigned int)i >= return_value_da_nel$51)
        break;

      struct anonymous$7 *sp = &servers->elem[(signed long int)i];
      if((signed int)sp->uptest == 7)
      {
        if((signed int)sp->uptest_usr[0l] == 0)
        {
          unsigned int main$$1$$5$$1$$1$$1$$uid;
          main$$1$$5$$1$$1$$1$$uid=getuid();
          struct passwd *main$$1$$5$$1$$1$$1$$pws;
          main$$1$$5$$1$$1$$1$$pws=getpwuid(main$$1$$5$$1$$1$$1$$uid);
          fprintf(stderr, "Warning: uptest command \"%s\" will implicitly be executed as user ", sp->uptest_cmd);
          if(!(main$$1$$5$$1$$1$$1$$pws == ((struct passwd *)NULL)))
            fprintf(stderr, "%s\n", main$$1$$5$$1$$1$$1$$pws->pw_name);

          else
            fprintf(stderr, "%i\n", main$$1$$5$$1$$1$$1$$uid);
        }

      }

      i = i + 1;
    }
    while((_Bool)1);
  }

  signed int *return_value___errno_location$54;
  if(!(global.pidfile == ((char *)NULL)) && !(global.daemon == 0))
  {
    signed int return_value_unlink$55;
    return_value_unlink$55=unlink(global.pidfile);
    if(!(return_value_unlink$55 == 0))
    {
      return_value___errno_location$54=__errno_location();
      if(!(*return_value___errno_location$54 == 2))
      {
        signed int *return_value___errno_location$52;
        return_value___errno_location$52=__errno_location();
        char *return_value_strerror$53;
        return_value_strerror$53=strerror(*return_value___errno_location$52);
        log_message(3, "Error: could not unlink pid file %s: %s", global.pidfile, return_value_strerror$53);
        exit(1);
      }

    }

    pfd=open(global.pidfile, 01 | 0100 | 0200 | 0400000, 0600);
    if(pfd == -1)
    {
      signed int *return_value___errno_location$56;
      return_value___errno_location$56=__errno_location();
      char *return_value_strerror$57;
      return_value_strerror$57=strerror(*return_value___errno_location$56);
      log_message(3, "Error: could not open pid file %s: %s", global.pidfile, return_value_strerror$57);
      exit(1);
    }

  }

  i = 0;
  unsigned int return_value_da_nel$58;
  do
  {
    return_value_da_nel$58=da_nel$link3((struct anonymous$3 *)servers);
    if((unsigned int)i >= return_value_da_nel$58)
      break;

    if((signed int)servers->elem[(signed long int)i].uptest == 8)
    {
      init_ping_socket();
      break;
    }

    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_init_rng$59;
  return_value_init_rng$59=init_rng();
  if(return_value_init_rng$59 == 0)
    exit(1);

  signed int return_value_final_init$60;
  return_value_final_init$60=final_init();
  if(return_value_final_init$60 == 0)
    exit(1);

  struct sigaction action;
  action.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$63;
  return_value_sigaction$63=sigaction(13, &action, (struct sigaction *)(void *)0);
  signed int *return_value___errno_location$61;
  char *return_value_strerror$62;
  if(!(return_value_sigaction$63 == 0))
  {
    return_value___errno_location$61=__errno_location();
    return_value_strerror$62=strerror(*return_value___errno_location$61);
    log_message(3, "Could not call sigaction to ignore SIGPIPE: %s", return_value_strerror$62);
  }

  umask((unsigned int)0077);
  signed int *return_value___errno_location$77;
  char *return_value_strerror$78;
  signed int *return_value___errno_location$86;
  char *return_value_strerror$87;
  if(!(global.daemon == 0))
  {
    signed int pid;
    signed int fd;
    pid=fork();
    if(pid == -1)
    {
      signed int *return_value___errno_location$64;
      return_value___errno_location$64=__errno_location();
      char *return_value_strerror$65;
      return_value_strerror$65=strerror(*return_value___errno_location$64);
      log_message(3, "Could not become a daemon: fork #1 failed: %s", return_value_strerror$65);
      exit(1);
    }

    if(!(pid == 0))
      exit(0);

    signed int return_value_setsid$68;
    return_value_setsid$68=setsid();
    if(return_value_setsid$68 == -1)
    {
      signed int *return_value___errno_location$66;
      return_value___errno_location$66=__errno_location();
      char *return_value_strerror$67;
      return_value_strerror$67=strerror(*return_value___errno_location$66);
      log_message(3, "Could not become a daemon: setsid failed: %s", return_value_strerror$67);
      _exit(1);
    }

    pid=fork();
    if(pid == -1)
    {
      signed int *return_value___errno_location$69;
      return_value___errno_location$69=__errno_location();
      char *return_value_strerror$70;
      return_value_strerror$70=strerror(*return_value___errno_location$69);
      log_message(3, "Could not become a daemon: fork #2 failed: %s", return_value_strerror$70);
      _exit(1);
    }

    if(!(pid == 0))
    {
      signed int exitval = 0;
      if(!(global.pidfile == ((char *)NULL)))
      {
        signed int return_value_fsprintf$73;
        return_value_fsprintf$73=fsprintf(pfd, "%i\n", (signed int)pid);
        if(!(return_value_fsprintf$73 >= 0))
        {
          signed int *return_value___errno_location$71;
          return_value___errno_location$71=__errno_location();
          char *return_value_strerror$72;
          return_value_strerror$72=strerror(*return_value___errno_location$71);
          log_message(3, "Error: could not write to pid file %s: %s", global.pidfile, return_value_strerror$72);
          exitval = 1;
        }

        signed int return_value_close$76;
        return_value_close$76=close(pfd);
        if(!(return_value_close$76 >= 0))
        {
          signed int *return_value___errno_location$74;
          return_value___errno_location$74=__errno_location();
          char *return_value_strerror$75;
          return_value_strerror$75=strerror(*return_value___errno_location$74);
          log_message(3, "Error: could not close pid file %s: %s", global.pidfile, return_value_strerror$75);
          exitval = 1;
        }

      }

      _exit(exitval);
    }

    if(!(global.pidfile == ((char *)NULL)))
      close(pfd);

    signed int return_value_chdir$79;
    return_value_chdir$79=chdir("/");
    if(!(return_value_chdir$79 == 0))
    {
      return_value___errno_location$77=__errno_location();
      return_value_strerror$78=strerror(*return_value___errno_location$77);
      log_message(4, "Cannot chdir to root directory: %s", return_value_strerror$78);
    }

    fd=open("/dev/null", 00);
    if(fd == -1)
    {
      signed int *return_value___errno_location$80;
      return_value___errno_location$80=__errno_location();
      char *return_value_strerror$81;
      return_value_strerror$81=strerror(*return_value___errno_location$80);
      log_message(3, "Could not become a daemon: open for /dev/null failed: %s", return_value_strerror$81);
      _exit(1);
    }

    dup2(fd, 0);
    close(fd);
    fd=open("/dev/null", 01);
    if(fd == -1)
    {
      signed int *return_value___errno_location$82;
      return_value___errno_location$82=__errno_location();
      char *return_value_strerror$83;
      return_value_strerror$83=strerror(*return_value___errno_location$82);
      log_message(3, "Could not become a daemon: open for /dev/null failed: %s", return_value_strerror$83);
      _exit(1);
    }

    dup2(fd, 1);
    dup2(fd, 2);
    close(fd);
    if(!(global.debug == 0))
    {
      signed long int exitval$array_size0;
      unsigned long int return_value_strlen$84;
      return_value_strlen$84=strlen(global.cache_dir);
      exitval$array_size0 = (signed long int)(return_value_strlen$84 + sizeof(char [13l]) /*13ul*/ );
      char dbgpath[exitval$array_size0];
      char *return_value_stpcpy$85;
      return_value_stpcpy$85=stpcpy(dbgpath, global.cache_dir);
      stpcpy(return_value_stpcpy$85, "/pdnsd.debug");
      dbg_file=fopen(dbgpath, "w");
      if(dbg_file == ((struct _IO_FILE *)NULL))
      {
        return_value___errno_location$86=__errno_location();
        return_value_strerror$87=strerror(*return_value___errno_location$86);
        log_message(4, "Warning: could not open debug file %s: %s", (const void *)dbgpath, return_value_strerror$87);
      }

    }

  }

  else
    dbg_file = stdout;
  debug_p = (signed short int)(global.debug != 0 && dbg_file != ((struct _IO_FILE *)NULL));
  if((signed int)global.verbosity >= 0)
    log_message(6, "pdnsd-%s starting.\n", (const void *)"1.2.9a-par");

  if(!(debug_p == 0))
    debug_msg(0, "Debug messages activated\n");

  if(!(debug_p == 0))
    debug_msg(0, run_ipv4 != 0 ? "Using IPv4.\n" : "Using IPv6.\n");

  pthread_attr_init(&attr_detached);
  pthread_attr_setdetachstate(&attr_detached, 1);
  read_disk_cache();
  if(!(stat_pipe == 0))
    init_stat_sock();

  init_log_lock();
  init_cache_lock();
  sigemptyset(&sigs_msk);
  sigaddset(&sigs_msk, 1);
  sigaddset(&sigs_msk, 2);
  sigaddset(&sigs_msk, 6);
  sigaddset(&sigs_msk, 8);
  sigaddset(&sigs_msk, 15);
  pthread_sigmask(0, &sigs_msk, (struct anonymous$41 *)(void *)0);
  signed int err;
  err=pthread_key_create(&thrid_key, (void (*)(void *))(void *)0);
  if(!(err == 0))
  {
    char *return_value_strerror$88;
    return_value_strerror$88=strerror(err);
    log_message(3, "pthread_key_create failed: %s", return_value_strerror$88);
    _exit(1);
  }

  signed int thrdsucc = 1;
  signed int return_value_start_servstat_thread$89;
  return_value_start_servstat_thread$89=start_servstat_thread();
  if(!(return_value_start_servstat_thread$89 == 0))
    thrdsucc = 0;

  if(global.strict_suid == 0)
  {
    signed int return_value_run_as$90;
    return_value_run_as$90=run_as(global.run_as);
    if(return_value_run_as$90 == 0)
      _exit(1);

  }

  signed int return_value_start_stat_sock$91;
  if(!(stat_pipe == 0))
  {
    return_value_start_stat_sock$91=start_stat_sock();
    if(!(return_value_start_stat_sock$91 == 0))
      thrdsucc = 0;

  }

  start_dns_servers();
  if(!(thrdsucc == 0))
  {
    if(!(debug_p == 0))
      debug_msg(0, "All threads started successfully.\n");

  }

  signed int main$$1$$16$$err;
  do
  {
    main$$1$$16$$err=sigwait(&sigs_msk, &sig);
    if(main$$1$$16$$err == 0)
      break;

    if(!(main$$1$$16$$err == 4))
    {
      char *return_value_strerror$92;
      return_value_strerror$92=strerror(main$$1$$16$$err);
      log_message(3, "sigwait failed: %s", return_value_strerror$92);
      sig = 0;
      break;
    }

  }
  while((_Bool)1);
  if(!(sig == 0))
  {
    if(!(debug_p == 0))
      debug_msg(0, "Signal %i caught.\n", sig);

  }

  write_disk_cache();
  destroy_cache();
  if(!(sig == 0))
    log_message(4, "Caught signal %i. Exiting.", sig);

  if(sig == 4 || sig == 7 || sig == 11)
    crash_msg("This is a fatal signal probably triggered by a bug.");

  if(!(ping_isocket == -1))
    close(ping_isocket);

  if(!(ping6_isocket == -1))
    close(ping6_isocket);

  if(!(stat_pipe == 0))
    close(stat_sock);

  signed int return_value_unlink$95;
  signed int *return_value___errno_location$93;
  char *return_value_strerror$94;
  if(!(sock_path == ((char *)NULL)))
  {
    return_value_unlink$95=unlink(sock_path);
    if(!(return_value_unlink$95 == 0))
    {
      return_value___errno_location$93=__errno_location();
      return_value_strerror$94=strerror(*return_value___errno_location$93);
      log_message(4, "Failed to unlink %s: %s", sock_path, return_value_strerror$94);
    }

  }

  signed int return_value_fclose$98;
  if(!(global.daemon == 0) && !(debug_p == 0))
  {
    return_value_fclose$98=fclose(dbg_file);
    if(!(return_value_fclose$98 >= 0))
    {
      signed int *return_value___errno_location$96;
      return_value___errno_location$96=__errno_location();
      char *return_value_strerror$97;
      return_value_strerror$97=strerror(*return_value___errno_location$96);
      log_message(4, "Could not close debug file: %s", return_value_strerror$97);
    }

  }

  _exit(0);
}

// mark_servers
// file servers.h line 39
signed int mark_servers(signed int i, char *label, signed int up)
{
  signed int retval = 0;
  signed int n;
  signed int signal_test;
  pthread_mutex_lock(&servers_lock);
  signal_test = 0;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link5((struct anonymous$3 *)servers);
  n = (signed int)return_value_da_nel$1;
  if(i >= 0)
  {
    if(!(i >= n))
      n = i + 1;

  }

  else
    i = 0;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous$7 *sp = &servers->elem[(signed long int)i];
    _Bool tmp_if_expr$5;
    if(label == ((char *)NULL))
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if(!(sp->label == ((char *)NULL)))
      {
        return_value_strcmp$3=strcmp(sp->label, label);
        tmp_if_expr$4 = !(return_value_strcmp$3 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      signed int j;
      signed int m;
      unsigned int return_value_da_nel$2;
      return_value_da_nel$2=da_nel$link5((struct anonymous$3 *)sp->atup_a);
      m = (signed int)return_value_da_nel$2;
      if(!(m == 0))
      {
        if((signed int)sp->rootserver >= 2)
        {
          if(up >= 1)
            signal_test = 1;

        }

      }

      j = 0;
      for( ; !(j >= m); j = j + 1)
      {
        struct anonymous$20 *at = &sp->atup_a->elem[(signed long int)j];
        if(up >= 0)
        {
          at->is_up = (char)up;
          at->i_ts=time((signed long int *)(void *)0);
        }

        else
          if(!(at->i_ts == 0l))
          {
            at->i_ts = (signed long int)0;
            signal_test = 1;
          }

      }
    }

  }
  if(!(signal_test == 0))
  {
    signed int return_value_pthread_equal$6;
    return_value_pthread_equal$6=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal$6 == 0))
      retval=start_servstat_thread();

    else
    {
      retest_flag = (signed short int)1;
      retval=pthread_cond_signal(&server_test_cond);
    }
  }

  pthread_mutex_unlock(&servers_lock);
  return retval;
}

// mk_dns_hash
// file hash.h line 61
static inline void mk_dns_hash()
{
  signed int i = 0;
  for( ; !(i >= 1024); i = i + 1)
    hash_buckets[(signed long int)i] = (struct dns_hash_ent_s *)(void *)0;
}

// mk_error_reply
// file dns_answer.c line 1133
static void mk_error_reply(unsigned short int id, unsigned short int opcode, unsigned short int rescode, struct anonymous$29 *rep)
{
  rep->id = id;
  rep->qr = (unsigned int)1;
  rep->opcode = (unsigned int)opcode;
  rep->aa = (unsigned int)0;
  rep->tc = (unsigned int)0;
  rep->rd = (unsigned int)0;
  rep->ra = (unsigned int)1;
  rep->z = (unsigned int)0;
  rep->ad = (unsigned int)0;
  rep->cd = (unsigned int)0;
  rep->rcode = (unsigned int)rescode;
  rep->qdcount = (unsigned short int)0;
  rep->ancount = (unsigned short int)0;
  rep->nscount = (unsigned short int)0;
  rep->arcount = (unsigned short int)0;
}

// mk_flag_val
// file cache.h line 187
static inline unsigned int mk_flag_val(struct anonymous$7 *server)
{
  unsigned int fl = (unsigned int)0;
  if(server->purge_cache == 0)
    fl = fl | (unsigned int)32;

  if(!(server->nocache == 0))
    fl = fl | (unsigned int)8;

  if(!(server->rootserver == 0))
    fl = fl | (unsigned int)64;

  return fl;
}

// mk_netmask4
// file conf-parser.c line 1903
static inline unsigned int mk_netmask4(signed int len)
{
  unsigned int m;
  unsigned int return_value_htonl$1;
  if(!(len >= 1))
    return (unsigned int)0;

  else
  {
    m = ~((unsigned int)0);
    unsigned int tmp_if_expr$2;
    if(!(len >= 32))
    {
      return_value_htonl$1=htonl(m << 32 - len);
      tmp_if_expr$2 = return_value_htonl$1;
    }

    else
      tmp_if_expr$2 = m;
    return tmp_if_expr$2;
  }
}

// mk_netmask6
// file conf-parser.c line 1915
static inline void mk_netmask6(struct in6_addr *m, signed int len)
{
  unsigned int *ma = (unsigned int *)m;
  ma[(signed long int)0]=mk_netmask4(len);
  len = len - 32;
  ma[(signed long int)1]=mk_netmask4(len);
  len = len - 32;
  ma[(signed long int)2]=mk_netmask4(len);
  len = len - 32;
  ma[(signed long int)3]=mk_netmask4(len);
}

// needs_intermittent_testing
// file servers.h line 56
static inline signed int needs_intermittent_testing(struct anonymous$7 *sp)
{
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(sp->interval >= 1l)
  {
    if(!((signed int)sp->uptest == 5))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = sp->scheme[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  return (signed int)tmp_if_expr$2;
}

// needs_testing
// file servers.h line 49
static inline signed int needs_testing(struct anonymous$7 *sp)
{
  _Bool tmp_if_expr$1;
  if(sp->interval >= 1l)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = sp->interval == (signed long int)-2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
  {
    if(!((signed int)sp->uptest == 5))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = sp->scheme[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return (signed int)tmp_if_expr$3;
}

// needs_testing$link1
// file servers.h line 49
static inline signed int needs_testing$link1(struct anonymous$7 *sp$link1)
{
  _Bool tmp_if_expr$1$link1;
  if(sp$link1->interval >= 1l)
    tmp_if_expr$1$link1 = (_Bool)1;

  else
    tmp_if_expr$1$link1 = sp$link1->interval == (signed long int)-2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3$link1;
  _Bool tmp_if_expr$2$link1;
  if(tmp_if_expr$1$link1)
  {
    if(!((signed int)sp$link1->uptest == 5))
      tmp_if_expr$2$link1 = (_Bool)1;

    else
      tmp_if_expr$2$link1 = sp$link1->scheme[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$3$link1 = tmp_if_expr$2$link1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3$link1 = (_Bool)0;
  return (signed int)tmp_if_expr$3$link1;
}

// negate_cent
// file cache.h line 205
void negate_cent(struct anonymous$0 *cent, signed long int ttl, signed long int ts)
{
  signed int i;
  signed int return_value_del_rrset$2;
  if((1 & (signed int)cent->flags) == 0)
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      struct anonymous *negate_cent$$1$$1$$1$$1$$rrs = cent->$anon0.rr.rrmu[(signed long int)i];
      if(!(negate_cent$$1$$1$$1$$1$$rrs == ((struct anonymous *)NULL)))
      {
        signed int return_value_del_rrset$1;
        return_value_del_rrset$1=del_rrset(negate_cent$$1$$1$$1$$1$$rrs);
        cent->cs = cent->cs - (unsigned long int)return_value_del_rrset$1;
      }

    }
    struct anonymous **rrext = cent->$anon0.rr.rrext;
    if(!(rrext == ((struct anonymous **)NULL)))
    {
      i = 0;
      for( ; !(i >= 39); i = i + 1)
      {
        struct anonymous *rrs = rrext[(signed long int)i];
        if(!(rrs == ((struct anonymous *)NULL)))
        {
          return_value_del_rrset$2=del_rrset(rrs);
          cent->cs = cent->cs - (unsigned long int)return_value_del_rrset$2;
        }

      }
      free((void *)rrext);
      cent->cs = cent->cs - sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39;
    }

    cent->num_rrs = (unsigned short int)0;
    cent->flags = cent->flags | (unsigned short int)1;
    cent->$anon0.neg.lent = (struct rr_lent_s *)(void *)0;
  }

  cent->$anon0.neg.ttl = ttl;
  cent->$anon0.neg.ts = ts;
}

// p_cancel_query
// file dns_query.c line 1926
static void p_cancel_query(struct anonymous$5 *st)
{
  switch((signed int)st->state)
  {
    case 2:

    case 3:

    case 5:
      close(st->sock);
    case 1:

    case 4:
    {
      free((void *)st->recvbuf);
      free((void *)st->msg);
    }
    default:
      if(!((signed int)st->state == 0))
      {
        if(!((signed int)st->state == 8))
          st->state = (signed short int)7;

      }

  }
}

// p_dns_cached_resolve
// file dns_query.c line 3340
static signed int p_dns_cached_resolve(struct anonymous$4 *q, const unsigned char *name, signed int thint, struct anonymous$0 **cachedp, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa)
{
  struct anonymous$0 *cached = (struct anonymous$0 *)(void *)0;
  signed int rc;
  unsigned short int flags = (unsigned short int)0;
  unsigned char _debugstrbuf[256l];
  const unsigned char *return_value_rhn2str$1;
  const char *return_value_get_tname$2;
  if(!(debug_p == 0))
  {
    return_value_rhn2str$1=rhn2str(name, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
    return_value_get_tname$2=get_tname(thint);
    debug_msg(0, "Starting cached resolve for: %s, query %s\n", return_value_rhn2str$1, return_value_get_tname$2);
  }

  rc=lookup_cache_status(name, thint, &cached, &flags, queryts, c_soa);
  if(rc == 0)
  {
    *cachedp = cached;
    return 0;
  }

  else
    if(rc == 3)
      return 3;

  if(!(global.onquery == 0))
    test_onquery();

  if((2 & (signed int)flags) == 0 && !(global.lndown_kluge == 0))
  {
    signed int i;
    signed int n;
    signed int linkdown = 1;
    lock_server_data();
    unsigned int return_value_da_nel$3;
    return_value_da_nel$3=da_nel$link2((struct anonymous$3 *)servers);
    n = (signed int)return_value_da_nel$3;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous$7 *sp = &servers->elem[(signed long int)i];
      if(!((signed int)sp->rootserver >= 2))
      {
        signed int j;
        signed int m;
        unsigned int return_value_da_nel$4;
        return_value_da_nel$4=da_nel$link2((struct anonymous$3 *)sp->atup_a);
        m = (signed int)return_value_da_nel$4;
        j = 0;
        for( ; !(j >= m); j = j + 1)
          if(!(sp->atup_a->elem[(signed long int)j].is_up == 0))
          {
            linkdown = 0;
            goto done;
          }

      }

    }

  done:
    ;
    unlock_server_data();
    if(!(linkdown == 0))
    {
      if(!(debug_p == 0))
        debug_msg(0, "Link is down.\n");

      rc = 2;
      goto cleanup_return;
    }

  }

  if(!(rc == 0xfffb))
  {
    struct anonymous$0 *ent;
    if(!(debug_p == 0))
      debug_msg(0, "Trying name servers.\n");

    if(!(q == ((struct anonymous$4 *)NULL)))
      rc=p_recursive_query(q, name, thint, &ent, (signed int *)(void *)0, hops, qslist, qhlist, c_soa);

    else
      rc=p_dns_resolve(name, thint, &ent, hops, qhlist, c_soa);
    if(!(rc == 0))
    {
      if(rc == 2 && !((32 & (signed int)flags) == 0) && !(cached == ((struct anonymous$0 *)NULL)))
      {
        if(!(debug_p == 0))
          debug_msg(0, "Falling back to cached record.\n");

      }

      else
        goto cleanup_return;
    }

    else
    {
      if(!(cached == ((struct anonymous$0 *)NULL)))
      {
        free_cent(cached);
        free((void *)cached);
      }

      cached = ent;
    }
  }

  else
    if(!(debug_p == 0))
      debug_msg(0, "Using cached record.\n");

  *cachedp = cached;
  return 0;

cleanup_return:
  ;
  if(!(cached == ((struct anonymous$0 *)NULL)))
  {
    free_cent(cached);
    free((void *)cached);
  }

  return rc;
}

// p_dns_resolve
// file dns_query.c line 3066
static signed int p_dns_resolve(const unsigned char *name, signed int thint, struct anonymous$0 **cachedp, signed int hops, struct qhintnode_s *qhlist, unsigned char *c_soa)
{
  signed int i;
  signed int n;
  signed int rc;
  signed int one_up = 0;
  signed int seenrootserv = 0;
  struct anonymous$4 *serv = (struct anonymous$4 *)(void *)0;
  struct rejectlist_s *rejectlist = (struct rejectlist_s *)(void *)0;
  lock_server_data();
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link2((struct anonymous$3 *)servers);
  n = (signed int)return_value_da_nel$1;
  i = 0;
  signed int return_value_use_server$15;
  signed long int return_value_random$3;
  signed long int return_value_random$6;
  const char *return_value_pdnsd_a2str$10;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous$7 *sp = &servers->elem[(signed long int)i];
    if(!((signed int)sp->rootserver >= 2))
    {
      return_value_use_server$15=use_server(sp, name);
      if(!(return_value_use_server$15 == 0))
      {
        signed int m;
        unsigned int return_value_da_nel$2;
        return_value_da_nel$2=da_nel$link2((struct anonymous$3 *)sp->atup_a);
        m = (signed int)return_value_da_nel$2;
        if(m >= 1)
        {
          struct rejectlist_s *rjl = (struct rejectlist_s *)(void *)0;
          signed int j = 0;
          signed int jstart = 0;
          if(!(sp->rand_servers == 0))
          {
            return_value_random$3=random();
            jstart = (signed int)(return_value_random$3 % (signed long int)m);
            j = jstart;
          }

          do
          {
            struct anonymous$20 *at = &sp->atup_a->elem[(signed long int)j];
            if(!(at->is_up == 0))
            {
              if(!(sp->rootserver == 0))
              {
                if(seenrootserv == 0)
                {
                  signed int nseg;
                  signed int mseg = 1;
                  signed int l = 0;
                  const unsigned char *topdomain = (const unsigned char *)(void *)0;
                  struct anonymous$14 *adrs = (struct anonymous$14 *)(void *)0;
                  seenrootserv = 1;
                  unsigned int return_value_rhnsegcnt$4;
                  return_value_rhnsegcnt$4=rhnsegcnt$link1(name);
                  nseg = (signed int)return_value_rhnsegcnt$4;
                  if(nseg >= 2)
                  {
                    unsigned int rem;
                    static const unsigned char rhn_arpa[6l] = { (const unsigned char)4, (const unsigned char)97, (const unsigned char)114, (const unsigned char)112, (const unsigned char)97, (const unsigned char)0 };
                    domain_match(rhn_arpa, name, &rem, (unsigned int *)(void *)0);
                    if(rem == 0u)
                      mseg = 3;

                  }

                  if(mseg >= nseg)
                  {
                    if(nseg >= 1)
                      mseg = nseg - 1;

                    else
                      mseg = 0;
                  }

                  for( ; mseg >= 1; mseg = mseg - 1)
                  {
                    topdomain=skipsegs$link1(name, (unsigned int)(nseg - mseg));
                    adrs=lookup_ns(topdomain);
                    unsigned int return_value_da_nel$5;
                    return_value_da_nel$5=da_nel$link2((struct anonymous$3 *)adrs);
                    l = (signed int)return_value_da_nel$5;
                    if(l >= 1)
                      break;

                    if(!(adrs == ((struct anonymous$14 *)NULL)))
                      free((void *)adrs);

                  }
                  if(l >= 1)
                  {
                    signed int k = 0;
                    signed int kstart = 0;
                    if(!(sp->rand_servers == 0))
                    {
                      return_value_random$6=random();
                      kstart = (signed int)(return_value_random$6 % (signed long int)l);
                      k = kstart;
                    }

                    _Bool tmp_if_expr$7;
                    if(!(sp->reject_a4 == ((struct anonymous$10 *)NULL)))
                      tmp_if_expr$7 = (_Bool)1;

                    else
                      tmp_if_expr$7 = sp->reject_a6 != (struct anonymous$12 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$7)
                    {
                      if(!(sp->rejectrecursively == 0))
                      {
                        if(rjl == ((struct rejectlist_s *)NULL))
                        {
                          rjl=add_rejectlist(rejectlist, sp);
                          if(rjl == ((struct rejectlist_s *)NULL))
                          {
                            one_up = 0;
                            free((void *)adrs);
                            goto done;
                          }

                          rejectlist = rjl;
                        }

                      }

                    }

                    do
                    {
                      unsigned int return_value_mk_flag_val$8;
                      return_value_mk_flag_val$8=mk_flag_val(sp);
                      one_up=add_qserv(&serv, &adrs->elem[(signed long int)k], 53, sp->timeout, return_value_mk_flag_val$8 & (unsigned int)~(2 | 4 | 16 | 64), (signed int)sp->nocache, sp->lean_query, sp->edns_query, (char)2, (char)0, (char)!(global.paranoid != 0), topdomain, rjl);
                      if(one_up == 0)
                      {
                        free((void *)adrs);
                        goto done;
                      }

                      k = k + 1;
                      if(k == l)
                        k = 0;

                    }
                    while(!(k == kstart));
                    free((void *)adrs);
                    char _debugsockabuf[46l];
                    if(!(debug_p == 0))
                    {
                      union anonymous$6 *tmp_if_expr$9;
                      if(!(run_ipv4 == 0))
                        tmp_if_expr$9 = (union anonymous$6 *)&(&at->a)->ipv4;

                      else
                        tmp_if_expr$9 = (union anonymous$6 *)&(&at->a)->ipv6;
                      return_value_pdnsd_a2str$10=pdnsd_a2str(tmp_if_expr$9, _debugsockabuf, 46);
                      debug_msg(0, "Not querying root-server %s, using cached information instead.\n", return_value_pdnsd_a2str$10);
                    }

                    seenrootserv = 2;
                    break;
                  }

                }

                else
                  if(seenrootserv == 2)
                    break;

              }

              _Bool tmp_if_expr$11;
              if(!(sp->reject_a4 == ((struct anonymous$10 *)NULL)))
                tmp_if_expr$11 = (_Bool)1;

              else
                tmp_if_expr$11 = sp->reject_a6 != (struct anonymous$12 *)(void *)0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$11)
              {
                if(rjl == ((struct rejectlist_s *)NULL))
                {
                  rjl=add_rejectlist(rejectlist, sp);
                  if(rjl == ((struct rejectlist_s *)NULL))
                  {
                    one_up = 0;
                    goto done;
                  }

                  rejectlist = rjl;
                }

              }

              unsigned int return_value_mk_flag_val$12;
              return_value_mk_flag_val$12=mk_flag_val(sp);
              signed int tmp_if_expr$13;
              if(!(sp->rootserver == 0))
                tmp_if_expr$13 = 3;

              else
                tmp_if_expr$13 = (signed int)!(sp->is_proxy != 0);
              signed int return_value_needs_testing$14;
              return_value_needs_testing$14=needs_testing(sp);
              one_up=add_qserv(&serv, &at->a, (signed int)sp->port, sp->timeout, return_value_mk_flag_val$12, (signed int)sp->nocache, sp->lean_query, sp->edns_query, (char)tmp_if_expr$13, (char)return_value_needs_testing$14, (char)1, (const unsigned char *)(void *)0, rjl);
              if(one_up == 0)
                goto done;

            }

            j = j + 1;
            if(j == m)
              j = 0;

          }
          while(!(j == jstart));
        }

      }

    }

  }

done:
  ;
  unlock_server_data();
  if(!(one_up == 0))
  {
    struct anonymous$0 *cached;
    signed int nocache;
    rc=p_recursive_query(serv, name, thint, &cached, &nocache, hops, (struct qstatnode_s *)(void *)0, qhlist, c_soa);
    if(rc == 0)
    {
      if(nocache == 0)
      {
        struct anonymous$0 *tc;
        add_cache(cached);
        tc=lookup_cache(name, (signed int *)(void *)0);
        if(!(tc == ((struct anonymous$0 *)NULL)))
        {
          free_cent(cached);
          free((void *)cached);
          cached = tc;
        }

        else
          if(!(debug_p == 0))
            debug_msg(0, "p_dns_resolve: merging answer with cache failed, using local cent copy.\n");

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "p_dns_resolve: nocache.\n");

      *cachedp = cached;
    }

  }

  else
  {
    if(!(debug_p == 0))
      debug_msg(0, "No server is marked up and allowed for this domain.\n");

    rc = 2;
  }
  del_qserv(serv);
  free_rejectlist(rejectlist);
  return rc;
}

// p_exec_query
// file dns_query.c line 1137
static signed int p_exec_query(struct anonymous$0 **entp, const unsigned char *name, signed int thint, struct anonymous$5 *st, struct _dynamic_list_head **ns, unsigned char *c_soa)
{
  signed int rv;
  signed int rcode;
  unsigned short int rd;
  const char *return_value_pdnsd_a2str$11;
  const char *return_value_get_ename$12;
  char *return_value_dnsflags2str$13;
  const char *return_value_pdnsd_a2str$16;
  const char *return_value_get_ename$17;
  const char *return_value_pdnsd_a2str$19;
  const char *return_value_get_ename$20;
  unsigned long int p_exec_query$$1$$1$$13$$2$$transl;
  const char *return_value_pdnsd_a2str$25;
  const char *return_value_get_ename$26;
  _Bool tmp_if_expr$30;
  const char *return_value_pdnsd_a2str$29;
  const char *return_value_pdnsd_a2str$32;
  switch((signed int)st->state)
  {
    case 0:
    {
      unsigned long int transl;
      unsigned long int allocsz;
      unsigned int rrnlen = (unsigned int)0;
      allocsz = sizeof(struct anonymous$28) /*14ul*/ ;
      if(!(name == ((const unsigned char *)NULL)))
      {
        rrnlen=rhnlen$link3(name);
        allocsz = allocsz + (unsigned long int)(rrnlen + (unsigned int)4);
        if(!(st->edns_query == 0))
          allocsz = allocsz + (unsigned long int)(1 + 10);

      }

      void *return_value_malloc$1;
      return_value_malloc$1=malloc(allocsz);
      st->msg = (struct anonymous$28 *)return_value_malloc$1;
      if(st->msg == ((struct anonymous$28 *)NULL))
      {
        st->state = (signed short int)8;
        return 0xffff;
      }

      st->myrid=get_rand16();
      st->msg->hdr.id=htons(st->myrid);
      st->msg->hdr.qr = (unsigned int)0;
      st->msg->hdr.opcode = (unsigned int)0;
      st->msg->hdr.aa = (unsigned int)0;
      st->msg->hdr.tc = (unsigned int)0;
      _Bool tmp_if_expr$2;
      if(!(name == ((const unsigned char *)NULL)))
        tmp_if_expr$2 = st->trusted != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      st->msg->hdr.rd = (unsigned int)tmp_if_expr$2;
      st->msg->hdr.ra = (unsigned int)0;
      st->msg->hdr.z = (unsigned int)0;
      st->msg->hdr.ad = (unsigned int)0;
      st->msg->hdr.cd = (unsigned int)0;
      st->msg->hdr.rcode = (unsigned int)0;
      st->msg->hdr.qdcount=htons((unsigned short int)(name != (const unsigned char *)(void *)0));
      st->msg->hdr.ancount = (unsigned short int)0;
      st->msg->hdr.nscount = (unsigned short int)0;
      st->msg->hdr.arcount = (unsigned short int)0;
      transl = sizeof(struct anonymous$29) /*12ul*/ ;
      if(!(name == ((const unsigned char *)NULL)))
      {
        unsigned char *p;
        void *return_value_mempcpy$3;
        return_value_mempcpy$3=mempcpy((void *)(unsigned char *)(&st->msg->hdr + (signed long int)1), (const void *)name, (unsigned long int)rrnlen);
        p = (unsigned char *)return_value_mempcpy$3;
        unsigned short int qtype = (unsigned short int)(st->lean_query != 0 ? thint : 255);
        do
        {
          unsigned short int t_s = (unsigned short int)qtype;
          unsigned char *t_cp = (unsigned char *)p;
          unsigned char *tmp_post$4 = t_cp;
          t_cp = t_cp + 1l;
          *tmp_post$4 = (unsigned char)((signed int)t_s >> 8);
          unsigned char *tmp_post$5 = t_cp;
          t_cp = t_cp + 1l;
          *tmp_post$5 = (unsigned char)t_s;
          p = (unsigned char *)(void *)t_cp;
        }
        while((_Bool)0);
        do
        {
          unsigned short int p_exec_query$$1$$1$$1$$3$$2$$t_s = (unsigned short int)1;
          unsigned char *p_exec_query$$1$$1$$1$$3$$2$$t_cp = (unsigned char *)p;
          unsigned char *tmp_post$6 = p_exec_query$$1$$1$$1$$3$$2$$t_cp;
          p_exec_query$$1$$1$$1$$3$$2$$t_cp = p_exec_query$$1$$1$$1$$3$$2$$t_cp + 1l;
          *tmp_post$6 = (unsigned char)((signed int)p_exec_query$$1$$1$$1$$3$$2$$t_s >> 8);
          unsigned char *tmp_post$7 = p_exec_query$$1$$1$$1$$3$$2$$t_cp;
          p_exec_query$$1$$1$$1$$3$$2$$t_cp = p_exec_query$$1$$1$$1$$3$$2$$t_cp + 1l;
          *tmp_post$7 = (unsigned char)p_exec_query$$1$$1$$1$$3$$2$$t_s;
          p = (unsigned char *)(void *)p_exec_query$$1$$1$$1$$3$$2$$t_cp;
        }
        while((_Bool)0);
        transl = transl + (unsigned long int)(rrnlen + (unsigned int)4);
        if(!(st->edns_query == 0))
          add_opt_pseudo_rr(&st->msg, &transl, &allocsz, (unsigned short int)global.udpbufsize, (unsigned short int)0, (unsigned short int)0, (unsigned short int)0);

      }

      st->transl = (unsigned short int)transl;
      st->msg->len=htons(st->transl);
      st->recvbuf = (struct anonymous$29 *)(void *)0;
      _Bool tmp_if_expr$8;
      if((signed int)st->qm == 12)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)st->qm == 15 ? (_Bool)1 : (_Bool)0;
      st->state = (signed short int)(tmp_if_expr$8 ? 4 : 1);
    }
    case 1:

    case 2:

    case 3:

    case 4:

    case 5:
    {
      do
      {

      tryagain:
        ;
        rv=p_query_sm(st);
        if(rv == -1)
          return -1;

        if(!(rv == 0))
        {
          free((void *)st->msg);
          free((void *)st->recvbuf);
          st->state = (signed short int)8;
          if(!(st->needs_testing == 0))
          {
            if(st->s_errno == 64 || st->s_errno == 92 || st->s_errno == 100 || st->s_errno == 101 || st->s_errno == 111 || st->s_errno == 112 || st->s_errno == 113)
            {
              union anonymous$6 *tmp_if_expr$9;
              if(!(run_ipv4 == 0))
                tmp_if_expr$9 = (union anonymous$6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr$9 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
              sched_server_test(tmp_if_expr$9, 1, 0);
              st->needs_testing = (char)0;
            }

          }

          return rv;
        }

        char p_exec_query$$1$$1$$4$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$10;
          if(!(run_ipv4 == 0))
            tmp_if_expr$10 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$10 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$11=pdnsd_a2str(tmp_if_expr$10, p_exec_query$$1$$1$$4$$_debugsockabuf, 46);
          debug_msg(0, "Received reply from %s (msg len=%u).\n", return_value_pdnsd_a2str$11, st->recvl);
        }

        if(!((unsigned long int)st->recvl >= sizeof(struct anonymous$29) /*12ul*/ ))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Message too short!\n");

          goto discard_reply;
        }

        unsigned short int recvid;
        recvid=ntohs(st->recvbuf->id);
        if(!(recvid == st->myrid))
        {
          if(!(debug_p == 0))
            debug_msg(0, "ID mismatch: expected %04x, got %04x!\n", st->myrid, recvid);

          goto discard_reply;
        }

        if(!((signed int)st->recvbuf->qr == 1))
        {
          if(!(debug_p == 0))
            debug_msg(0, "The QR bit indicates this is a query, not a response!\n");

          goto discard_reply;
        }

        if(!((signed int)st->recvbuf->opcode == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Not a reply to a standard query (opcode=%u).\n", st->recvbuf->opcode);

          goto discard_reply;
        }

        rcode = (signed int)st->recvbuf->rcode;
        char flgsbuf[22l];
        if(!(debug_p == 0))
        {
          return_value_get_ename$12=get_ename(rcode);
          return_value_dnsflags2str$13=dnsflags2str(st->recvbuf, flgsbuf);
          debug_msg(0, "rcode=%u (%s), flags:%s\n", rcode, return_value_get_ename$12, return_value_dnsflags2str$13);
        }

        if(!((signed int)st->recvbuf->z == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Malformed response (nonzero Z bit).\n");

          goto discard_reply;
        }

        if(!(st->needs_testing == 0))
        {
          union anonymous$6 *tmp_if_expr$14;
          if(!(run_ipv4 == 0))
            tmp_if_expr$14 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$14 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          sched_server_test(tmp_if_expr$14, 1, 1);
          st->needs_testing = (char)0;
        }

        rv = rcode;
        if(rcode == 0 || rcode == 3)
        {
          st->state = (signed short int)8;
          goto __CPROVER_DUMP_L75;
        }

        if(entp == ((struct anonymous$0 **)NULL))
          goto discard_reply;

        if(rcode == 2 || rcode == 4 || rcode == 5)
        {
          _Bool tmp_if_expr$23;
          if(!(st->msg->hdr.rd == 0u))
            tmp_if_expr$23 = !(st->recvbuf->ra != 0u) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$23 = (_Bool)0;
          if(tmp_if_expr$23)
          {
            char p_exec_query$$1$$1$$13$$1$$1$$1$$_debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              union anonymous$6 *tmp_if_expr$15;
              if(!(run_ipv4 == 0))
                tmp_if_expr$15 = (union anonymous$6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr$15 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
              return_value_pdnsd_a2str$16=pdnsd_a2str(tmp_if_expr$15, p_exec_query$$1$$1$$13$$1$$1$$1$$_debugsockabuf, 46);
              return_value_get_ename$17=get_ename(rcode);
              debug_msg(0, "Server %s returned error code: %s. Maybe does not support recursive query? Querying non-recursively.\n", return_value_pdnsd_a2str$16, return_value_get_ename$17);
            }

            st->msg->hdr.rd = (unsigned int)0;
            goto resetstate_tryagain;
          }

          else
          {
            _Bool tmp_if_expr$21;
            if(!(rcode == 2))
              tmp_if_expr$21 = st->edns_query != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$21 = (_Bool)0;
            _Bool tmp_if_expr$22;
            if(tmp_if_expr$21)
              tmp_if_expr$22 = st->msg->hdr.arcount != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$22 = (_Bool)0;
            if(tmp_if_expr$22)
              goto try_withoutedns;

            else
              if(!(st->recvbuf->ancount == 0))
              {
                if((signed int)st->auth_serv == 2)
                {
                  char p_exec_query$$1$$1$$13$$1$$2$$1$$_debugsockabuf[46l];
                  if(!(debug_p == 0))
                  {
                    union anonymous$6 *tmp_if_expr$18;
                    if(!(run_ipv4 == 0))
                      tmp_if_expr$18 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                    else
                      tmp_if_expr$18 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                    return_value_pdnsd_a2str$19=pdnsd_a2str(tmp_if_expr$18, p_exec_query$$1$$1$$13$$1$$2$$1$$_debugsockabuf, 46);
                    return_value_get_ename$20=get_ename(rcode);
                    debug_msg(0, "Server %s returned error code: %s, but the answer section is not empty. Using the answer tentatively.\n", return_value_pdnsd_a2str$19, return_value_get_ename$20);
                  }

                  st->failed = (char)3;
                  st->state = (signed short int)8;
                  goto __CPROVER_DUMP_L75;
                }

              }

          }
          goto discard_reply;
        }

        if(!(rcode == 1))
          goto discard_reply;

        if(st->edns_query == 0)
          goto discard_reply;

        if(st->msg->hdr.arcount == 0)
          goto discard_reply;


      try_withoutedns:
        ;
        char p_exec_query$$1$$1$$13$$2$$1$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$24;
          if(!(run_ipv4 == 0))
            tmp_if_expr$24 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$24 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$25=pdnsd_a2str(tmp_if_expr$24, p_exec_query$$1$$1$$13$$2$$1$$_debugsockabuf, 46);
          return_value_get_ename$26=get_ename(rcode);
          debug_msg(0, "Server %s returned error code: %s. Maybe cannot handle EDNS? Querying with empty additional section.\n", return_value_pdnsd_a2str$25, return_value_get_ename$26);
        }

        p_exec_query$$1$$1$$13$$2$$transl=remove_opt_pseudo_rr(st->msg, (unsigned long int)st->transl);
        if(!(p_exec_query$$1$$1$$13$$2$$transl == 0ul))
          tmp_if_expr$30 = (signed int)st->msg->hdr.arcount == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$30 = (_Bool)0;
        if(!tmp_if_expr$30)
          break;

        st->transl = (unsigned short int)p_exec_query$$1$$1$$13$$2$$transl;
        st->msg->len=htons(st->transl);
        st->edns_query = (char)0;

      resetstate_tryagain:
        ;
        st->myrid=get_rand16();
        st->msg->hdr.id=htons(st->myrid);
        _Bool tmp_if_expr$27;
        if((signed int)st->qm == 12)
          tmp_if_expr$27 = (_Bool)1;

        else
          tmp_if_expr$27 = (signed int)st->qm == 15 ? (_Bool)1 : (_Bool)0;
        st->state = (signed short int)(tmp_if_expr$27 ? 4 : 1);
      }
      while((_Bool)1);
      char p_exec_query$$1$$1$$13$$2$$3$$1$$_debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous$6 *tmp_if_expr$28;
        if(!(run_ipv4 == 0))
          tmp_if_expr$28 = (union anonymous$6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr$28 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str$29=pdnsd_a2str(tmp_if_expr$28, p_exec_query$$1$$1$$13$$2$$3$$1$$_debugsockabuf, 46);
        debug_msg(0, "Internal error: could not remove additional section from query to server %s\n", return_value_pdnsd_a2str$29);
      }


    discard_reply:
      ;
      free((void *)st->msg);
      free((void *)st->recvbuf);
      st->state = (signed short int)8;
      if(!(entp == ((struct anonymous$0 **)NULL)))
      {
        char p_exec_query$$1$$1$$14$$1$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$31;
          if(!(run_ipv4 == 0))
            tmp_if_expr$31 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$31 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$32=pdnsd_a2str(tmp_if_expr$31, p_exec_query$$1$$1$$14$$1$$_debugsockabuf, 46);
          debug_msg(0, "Discarding reply from server %s\n", return_value_pdnsd_a2str$32);
        }

      }

      if(!(rv == 0))
        return rv;

      return 2;
    }
    default:
    {
      st->state = (signed short int)8;
      return 2;
    }
  }

__CPROVER_DUMP_L75:
  ;
  rd = (unsigned short int)st->msg->hdr.rd;
  free((void *)st->msg);
  const char *return_value_pdnsd_a2str$34;
  const char *return_value_pdnsd_a2str$37;
  const char *return_value_pdnsd_a2str$39;
  const char *return_value_pdnsd_a2str$42;
  const char *return_value_pdnsd_a2str$48;
  unsigned short int return_value_ntohs$53;
  const char *return_value_pdnsd_a2str$55;
  const char *return_value_pdnsd_a2str$57;
  const char *return_value_get_ename$58;
  _Bool tmp_if_expr$61;
  const char *return_value_pdnsd_a2str$60;
  struct anonymous *return_value_getrrset$72;
  _Bool tmp_if_expr$74;
  const char *return_value_pdnsd_a2str$79;
  const unsigned char *return_value_rhn2str$80;
  const char *return_value_inet_ntop$81;
  const char *return_value_pdnsd_a2str$84;
  const unsigned char *return_value_rhn2str$85;
  const char *return_value_inet_ntop$86;
  const char *return_value_pdnsd_a2str$88;
  const char *return_value_get_ename$89;
  _Bool tmp_if_expr$93;
  const unsigned char *return_value_skipsegs$91;
  const unsigned char *return_value_rhn2str$92;
  struct anonymous *tmp_if_expr$101;
  const unsigned char *return_value_rhn2str$103;
  const unsigned char *return_value_rhn2str$104;
  const char *return_value_pdnsd_a2str$106;
  struct anonymous *return_value_getrrset$124;
  _Bool tmp_if_expr$122;
  _Bool tmp_if_expr$121;
  _Bool tmp_if_expr$120;
  _Bool tmp_if_expr$110;
  const unsigned char *tmp_if_expr$112;
  const unsigned char *return_value_skipsegs$111;
  _Bool tmp_if_expr$114;
  struct anonymous *tmp_if_expr$113;
  _Bool tmp_if_expr$115;
  const char *return_value_getrrtpname$117;
  const unsigned char *return_value_rhn2str$118;
  unsigned char *return_value_skiprhn$128;
  void *return_value_dlist_next$127;
  unsigned int return_value_rhnlen$131;
  const char *return_value_pdnsd_a2str$141;
  void *return_value_malloc$142;
  const char *return_value_pdnsd_a2str$145;
  const unsigned char *return_value_rhn2str$146;
  const unsigned char *return_value_rhn2str$147;
  const unsigned char *return_value_rhn2str$149;
  const unsigned char *return_value_rhn2str$150;
  const char *return_value_pdnsd_a2str$154;
  unsigned int return_value_da_nel$156;
  if(!(entp == ((struct anonymous$0 **)NULL)))
  {
    signed long int queryts;
    queryts=time((signed long int *)(void *)0);
    unsigned long int lcnt = (unsigned long int)st->recvl - sizeof(struct anonymous$29) /*12ul*/ ;
    unsigned char *rrp = (unsigned char *)(st->recvbuf + (signed long int)1);
    struct anonymous$16 *secs[3l] = { (struct anonymous$16 *)(void *)0, (struct anonymous$16 *)(void *)0, (struct anonymous$16 *)(void *)0 };
    unsigned short int p_exec_query$$1$$2$$qtype;
    unsigned short int flags;
    unsigned short int aa;
    unsigned short int neg_ans = (unsigned short int)0;
    unsigned short int reject_ans = (unsigned short int)0;
    unsigned short int num_ns = (unsigned short int)0;
    signed int numoptrr;
    struct anonymous$17 ednsinfo = { .udpsize=(unsigned short int)0, .rcode=0, .version=0,
    .do_flg=0 };
    unsigned short int return_value_ntohs$35;
    return_value_ntohs$35=ntohs(st->recvbuf->qdcount);
    if(!((signed int)return_value_ntohs$35 == 1))
    {
      char p_exec_query$$1$$2$$1$$1$$_debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous$6 *tmp_if_expr$33;
        if(!(run_ipv4 == 0))
          tmp_if_expr$33 = (union anonymous$6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr$33 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str$34=pdnsd_a2str(tmp_if_expr$33, p_exec_query$$1$$2$$1$$1$$_debugsockabuf, 46);
        debug_msg(0, "Bad number of query records in answer from %s\n", return_value_pdnsd_a2str$34);
      }

      rv = 2;
    }

    else
    {
      unsigned char nbuf[256l];
      rv=decompress_name((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, nbuf, (unsigned int *)(void *)0);
      if(!(rv == 0))
      {
        char p_exec_query$$1$$2$$2$$1$$1$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$36;
          if(!(run_ipv4 == 0))
            tmp_if_expr$36 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$36 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$37=pdnsd_a2str(tmp_if_expr$36, p_exec_query$$1$$2$$2$$1$$1$$_debugsockabuf, 46);
          debug_msg(0, "Cannot decompress QNAME in answer from %s\n", return_value_pdnsd_a2str$37);
        }

        rv = 2;
      }

      else
      {
        signed int return_value_rhnicmp$40;
        return_value_rhnicmp$40=rhnicmp$link1(nbuf, name);
        if(return_value_rhnicmp$40 == 0)
        {
          char p_exec_query$$1$$2$$2$$2$$1$$_debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous$6 *tmp_if_expr$38;
            if(!(run_ipv4 == 0))
              tmp_if_expr$38 = (union anonymous$6 *)&st->a.sin4.sin_addr;

            else
              tmp_if_expr$38 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
            return_value_pdnsd_a2str$39=pdnsd_a2str(tmp_if_expr$38, p_exec_query$$1$$2$$2$$2$$1$$_debugsockabuf, 46);
            debug_msg(0, "Answer from %s does not match query.\n", return_value_pdnsd_a2str$39);
          }

          rv = 2;
        }

        else
        {
          p_exec_query$$1$$2$$qtype = (unsigned short int)(st->lean_query != 0 ? thint : 255);
          if(!(lcnt >= 4ul))
          {
            char p_exec_query$$1$$2$$3$$1$$_debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              union anonymous$6 *tmp_if_expr$41;
              if(!(run_ipv4 == 0))
                tmp_if_expr$41 = (union anonymous$6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr$41 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
              return_value_pdnsd_a2str$42=pdnsd_a2str(tmp_if_expr$41, p_exec_query$$1$$2$$3$$1$$_debugsockabuf, 46);
              debug_msg(0, "Format error in reply from %s (message truncated in qtype or qclass).\n", return_value_pdnsd_a2str$42);
            }

            rv = 2;
          }

          else
          {
            unsigned short int qt;
            unsigned short int qc;
            do
            {
              unsigned short int p_exec_query$$1$$2$$4$$1$$t_s;
              const unsigned char *p_exec_query$$1$$2$$4$$1$$t_cp = (const unsigned char *)rrp;
              const unsigned char *tmp_post$43 = p_exec_query$$1$$2$$4$$1$$t_cp;
              p_exec_query$$1$$2$$4$$1$$t_cp = p_exec_query$$1$$2$$4$$1$$t_cp + 1l;
              p_exec_query$$1$$2$$4$$1$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$43 << 8);
              const unsigned char *tmp_post$44 = p_exec_query$$1$$2$$4$$1$$t_cp;
              p_exec_query$$1$$2$$4$$1$$t_cp = p_exec_query$$1$$2$$4$$1$$t_cp + 1l;
              p_exec_query$$1$$2$$4$$1$$t_s = p_exec_query$$1$$2$$4$$1$$t_s | (unsigned short int)*tmp_post$44;
              qt = p_exec_query$$1$$2$$4$$1$$t_s;
              rrp = (unsigned char *)(void *)p_exec_query$$1$$2$$4$$1$$t_cp;
            }
            while((_Bool)0);
            do
            {
              unsigned short int p_exec_query$$1$$2$$4$$2$$t_s;
              const unsigned char *p_exec_query$$1$$2$$4$$2$$t_cp = (const unsigned char *)rrp;
              const unsigned char *tmp_post$45 = p_exec_query$$1$$2$$4$$2$$t_cp;
              p_exec_query$$1$$2$$4$$2$$t_cp = p_exec_query$$1$$2$$4$$2$$t_cp + 1l;
              p_exec_query$$1$$2$$4$$2$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$45 << 8);
              const unsigned char *tmp_post$46 = p_exec_query$$1$$2$$4$$2$$t_cp;
              p_exec_query$$1$$2$$4$$2$$t_cp = p_exec_query$$1$$2$$4$$2$$t_cp + 1l;
              p_exec_query$$1$$2$$4$$2$$t_s = p_exec_query$$1$$2$$4$$2$$t_s | (unsigned short int)*tmp_post$46;
              qc = p_exec_query$$1$$2$$4$$2$$t_s;
              rrp = (unsigned char *)(void *)p_exec_query$$1$$2$$4$$2$$t_cp;
            }
            while((_Bool)0);
            if(!(qt == p_exec_query$$1$$2$$qtype))
            {
              char _debugsockabuf[46l];
              if(!(debug_p == 0))
              {
                union anonymous$6 *tmp_if_expr$47;
                if(!(run_ipv4 == 0))
                  tmp_if_expr$47 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                else
                  tmp_if_expr$47 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                return_value_pdnsd_a2str$48=pdnsd_a2str(tmp_if_expr$47, _debugsockabuf, 46);
                debug_msg(0, "qtype in answer (%u) from %s does not match expected qtype (%u).\n", qt, return_value_pdnsd_a2str$48, p_exec_query$$1$$2$$qtype);
              }

              rv = 2;
            }

            else
            {
              lcnt = lcnt - (unsigned long int)4;
              _Bool tmp_if_expr$49;
              if(!(st->recvbuf->aa == 0u))
                tmp_if_expr$49 = !(st->failed != 0) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$49 = (_Bool)0;
              st->aa = (char)tmp_if_expr$49;
              st->tc = (char)st->recvbuf->tc;
              _Bool tmp_if_expr$50;
              if(!(st->aa == 0))
                tmp_if_expr$50 = !(st->tc != 0) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$50 = (_Bool)0;
              aa = (unsigned short int)tmp_if_expr$50;
              flags = st->flags;
              if(!(aa == 0))
                flags = flags | (unsigned short int)4;

              struct anonymous$3 *return_value_da_grow1$51;
              return_value_da_grow1$51=da_grow1((struct anonymous$3 *)secs[(signed long int)0], (unsigned long int)((struct anonymous$16 *)0)->elem, sizeof(struct anonymous$0) /*104ul*/ , (void (*)(void *))(void *)0);
              secs[(signed long int)0] = (struct anonymous$16 *)return_value_da_grow1$51;
              if(secs[0l] == ((struct anonymous$16 *)NULL))
                rv = 0xffff;

              else
              {
                signed int return_value_init_cent$52;
                return_value_init_cent$52=init_cent(&secs[(signed long int)0]->elem[(signed long int)0], name, (signed long int)0, (signed long int)0, (unsigned int)(aa != 0 && (signed int)p_exec_query$$1$$2$$qtype == 255 ? 4 : 0));
                if(return_value_init_cent$52 == 0)
                  rv = 0xffff;

                else
                {
                  numoptrr = 0;
                  return_value_ntohs$53=ntohs(st->recvbuf->ancount);
                  rv=rrs2cent((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, (signed int)return_value_ntohs$53, (unsigned int)flags, queryts, &secs[(signed long int)0], &numoptrr, &ednsinfo);
                  if(!(numoptrr == 0))
                  {
                    if(!(debug_p == 0))
                      debug_msg(0, "Answer section in reply contains %d OPT pseudo-RRs!\n", numoptrr);

                  }

                  numoptrr = 0;
                  if(rv == 0)
                  {
                    unsigned short int nscount;
                    nscount=ntohs(st->recvbuf->nscount);
                    if(!(nscount == 0))
                    {
                      rv=rrs2cent((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, (signed int)nscount, (unsigned int)((signed int)flags | 16), queryts, &secs[(signed long int)1], &numoptrr, &ednsinfo);
                      if(!(numoptrr == 0))
                      {
                        if(!(debug_p == 0))
                          debug_msg(0, "Authority section in reply contains %d OPT pseudo-RRs!\n", numoptrr);

                      }

                    }

                  }

                  numoptrr = 0;
                  if(rv == 0)
                  {
                    unsigned short int arcount;
                    arcount=ntohs(st->recvbuf->arcount);
                    if(!(arcount == 0))
                    {
                      rv=rrs2cent((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, (signed int)arcount, (unsigned int)((signed int)flags | 16), queryts, &secs[(signed long int)2], &numoptrr, &ednsinfo);
                      if(!(numoptrr == 0))
                      {
                        if(!(numoptrr == 1))
                        {
                          if(!(debug_p == 0))
                            debug_msg(0, "Additional section in reply contains %d OPT pseudo-RRs!\n", numoptrr);

                        }

                        char p_exec_query$$1$$2$$9$$1$$1$$2$$_debugsockabuf[46l];
                        if(!(debug_p == 0))
                        {
                          union anonymous$6 *tmp_if_expr$54;
                          if(!(run_ipv4 == 0))
                            tmp_if_expr$54 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                          else
                            tmp_if_expr$54 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                          return_value_pdnsd_a2str$55=pdnsd_a2str(tmp_if_expr$54, p_exec_query$$1$$2$$9$$1$$1$$2$$_debugsockabuf, 46);
                          debug_msg(0, "Reply from %s contains OPT pseudosection: EDNS version = %u, udp size = %u, flag DO=%u\n", return_value_pdnsd_a2str$55, ednsinfo.version, ednsinfo.udpsize, ednsinfo.do_flg);
                        }

                        if(!(rcode == (signed int)ednsinfo.rcode))
                        {
                          char p_exec_query$$1$$2$$9$$1$$1$$3$$1$$_debugsockabuf[46l];
                          if(!(debug_p == 0))
                          {
                            union anonymous$6 *tmp_if_expr$56;
                            if(!(run_ipv4 == 0))
                              tmp_if_expr$56 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                            else
                              tmp_if_expr$56 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                            return_value_pdnsd_a2str$57=pdnsd_a2str(tmp_if_expr$56, p_exec_query$$1$$2$$9$$1$$1$$3$$1$$_debugsockabuf, 46);
                            return_value_get_ename$58=get_ename((signed int)ednsinfo.rcode);
                            debug_msg(0, "Reply from %s contains unexpected EDNS rcode %u (%s)!\n", return_value_pdnsd_a2str$57, ednsinfo.rcode, return_value_get_ename$58);
                          }

                          rcode = (signed int)ednsinfo.rcode;
                          if(st->failed == 0)
                            st->failed = (char)1;

                        }

                      }

                    }

                  }

                  _Bool tmp_if_expr$62;
                  if(rv == 0)
                    tmp_if_expr$62 = (_Bool)1;

                  else
                  {
                    if(rv == 0xfffe)
                      tmp_if_expr$61 = st->recvbuf->tc != 0u ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$61 = (_Bool)0;
                    tmp_if_expr$62 = tmp_if_expr$61 ? (_Bool)1 : (_Bool)0;
                  }
                  if(!tmp_if_expr$62)
                  {
                    char p_exec_query$$1$$2$$10$$1$$_debugsockabuf[46l];
                    if(!(debug_p == 0))
                    {
                      union anonymous$6 *tmp_if_expr$59;
                      if(!(run_ipv4 == 0))
                        tmp_if_expr$59 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                      else
                        tmp_if_expr$59 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                      return_value_pdnsd_a2str$60=pdnsd_a2str(tmp_if_expr$59, p_exec_query$$1$$2$$10$$1$$_debugsockabuf, 46);
                      debug_msg(0, rv == 1 ? "Format error in reply from %s.\n" : (rv == 0xfffe ? "Format error in reply from %s (message unexpectedly truncated).\n" : (rv == 2 ? "Inconsistent timestamps in reply from %s.\n" : "Out of memory while processing reply from %s.\n")), return_value_pdnsd_a2str$60);
                    }

                    if(rv == 2)
                    {
                      if(st->failed == 0)
                        st->failed = (char)1;

                      goto __CPROVER_DUMP_L127;
                    }

                    if(!(rv == 0xffff))
                      rv = 2;

                  }

                  else
                  {

                  __CPROVER_DUMP_L127:
                    ;
                    signed int p_exec_query$$1$$2$$11$$i;
                    signed int p_exec_query$$1$$2$$11$$n;
                    unsigned int return_value_da_nel$63;
                    return_value_da_nel$63=da_nel$link2((struct anonymous$3 *)secs[(signed long int)0]);
                    p_exec_query$$1$$2$$11$$n = (signed int)return_value_da_nel$63;
                    p_exec_query$$1$$2$$11$$i = 0;
                    for( ; !(p_exec_query$$1$$2$$11$$i >= p_exec_query$$1$$2$$11$$n); p_exec_query$$1$$2$$11$$i = p_exec_query$$1$$2$$11$$i + 1)
                    {
                      struct anonymous$0 *p_exec_query$$1$$2$$11$$1$$1$$cent = &secs[(signed long int)0]->elem[(signed long int)p_exec_query$$1$$2$$11$$i];
                      unsigned int p_exec_query$$1$$2$$11$$1$$1$$scnt;
                      p_exec_query$$1$$2$$11$$1$$1$$scnt=rhnsegcnt$link1(p_exec_query$$1$$2$$11$$1$$1$$cent->qname);
                      struct anonymous *tmp_if_expr$64;
                      if((1 & (signed int)p_exec_query$$1$$2$$11$$1$$1$$cent->flags) == 0)
                        tmp_if_expr$64 = p_exec_query$$1$$2$$11$$1$$1$$cent->$anon0.rr.rrmu[(signed long int)1];

                      else
                        tmp_if_expr$64 = (struct anonymous *)(void *)0;
                      if(!(tmp_if_expr$64 == ((struct anonymous *)NULL)))
                        p_exec_query$$1$$2$$11$$1$$1$$cent->c_ns = (unsigned char)p_exec_query$$1$$2$$11$$1$$1$$scnt;

                      struct anonymous *tmp_if_expr$65;
                      if((1 & (signed int)p_exec_query$$1$$2$$11$$1$$1$$cent->flags) == 0)
                        tmp_if_expr$65 = p_exec_query$$1$$2$$11$$1$$1$$cent->$anon0.rr.rrmu[(signed long int)3];

                      else
                        tmp_if_expr$65 = (struct anonymous *)(void *)0;
                      if(!(tmp_if_expr$65 == ((struct anonymous *)NULL)))
                        p_exec_query$$1$$2$$11$$1$$1$$cent->c_soa = (unsigned char)p_exec_query$$1$$2$$11$$1$$1$$scnt;

                      _Bool tmp_if_expr$73;
                      if((signed int)p_exec_query$$1$$2$$qtype >= 251 && !((signed int)p_exec_query$$1$$2$$qtype >= 256))
                        tmp_if_expr$73 = (_Bool)1;

                      else
                      {
                        return_value_getrrset$72=getrrset$link1(p_exec_query$$1$$2$$11$$1$$1$$cent, (signed int)p_exec_query$$1$$2$$qtype);
                        tmp_if_expr$73 = return_value_getrrset$72 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
                      }
                      _Bool tmp_if_expr$75;
                      if(tmp_if_expr$73)
                        tmp_if_expr$75 = (_Bool)1;

                      else
                      {
                        if(p_exec_query$$1$$2$$11$$n == 1)
                          tmp_if_expr$74 = (signed int)p_exec_query$$1$$2$$11$$1$$1$$cent->num_rrs == 0 ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr$74 = (_Bool)0;
                        tmp_if_expr$75 = tmp_if_expr$74 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$75)
                      {
                        signed int p_exec_query$$1$$2$$11$$1$$1$$1$$j;
                        signed int p_exec_query$$1$$2$$11$$1$$1$$1$$m;
                        unsigned int return_value_da_nel$66;
                        return_value_da_nel$66=da_nel$link2((struct anonymous$3 *)secs[(signed long int)1]);
                        p_exec_query$$1$$2$$11$$1$$1$$1$$m = (signed int)return_value_da_nel$66;
                        p_exec_query$$1$$2$$11$$1$$1$$1$$j = 0;
                        for( ; !(p_exec_query$$1$$2$$11$$1$$1$$1$$j >= p_exec_query$$1$$2$$11$$1$$1$$1$$m); p_exec_query$$1$$2$$11$$1$$1$$1$$j = p_exec_query$$1$$2$$11$$1$$1$$1$$j + 1)
                        {
                          struct anonymous$0 *p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$ce = &secs[(signed long int)1]->elem[(signed long int)p_exec_query$$1$$2$$11$$1$$1$$1$$j];
                          unsigned int ml;
                          unsigned int p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$rem;
                          ml=domain_match(p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$ce->qname, p_exec_query$$1$$2$$11$$1$$1$$cent->qname, &p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$rem, (unsigned int *)(void *)0);
                          if(p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$rem == 0u)
                          {
                            _Bool tmp_if_expr$71;
                            if(!(ml == 0u))
                              tmp_if_expr$71 = (_Bool)1;

                            else
                              tmp_if_expr$71 = (signed int)st->auth_serv != 2 ? (_Bool)1 : (_Bool)0;
                            if(tmp_if_expr$71)
                            {
                              struct anonymous *tmp_if_expr$68;
                              if((1 & (signed int)p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$ce->flags) == 0)
                                tmp_if_expr$68 = p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$ce->$anon0.rr.rrmu[(signed long int)1];

                              else
                                tmp_if_expr$68 = (struct anonymous *)(void *)0;
                              if(!(tmp_if_expr$68 == ((struct anonymous *)NULL)))
                              {
                                _Bool tmp_if_expr$67;
                                if((signed int)p_exec_query$$1$$2$$11$$1$$1$$cent->c_ns == 0xff)
                                  tmp_if_expr$67 = (_Bool)1;

                                else
                                  tmp_if_expr$67 = (unsigned int)p_exec_query$$1$$2$$11$$1$$1$$cent->c_ns < ml ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr$67)
                                  p_exec_query$$1$$2$$11$$1$$1$$cent->c_ns = (unsigned char)ml;

                              }

                              struct anonymous *tmp_if_expr$70;
                              if((1 & (signed int)p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$ce->flags) == 0)
                                tmp_if_expr$70 = p_exec_query$$1$$2$$11$$1$$1$$1$$1$$1$$ce->$anon0.rr.rrmu[(signed long int)3];

                              else
                                tmp_if_expr$70 = (struct anonymous *)(void *)0;
                              if(!(tmp_if_expr$70 == ((struct anonymous *)NULL)))
                              {
                                _Bool tmp_if_expr$69;
                                if((signed int)p_exec_query$$1$$2$$11$$1$$1$$cent->c_soa == 0xff)
                                  tmp_if_expr$69 = (_Bool)1;

                                else
                                  tmp_if_expr$69 = (unsigned int)p_exec_query$$1$$2$$11$$1$$1$$cent->c_soa < ml ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr$69)
                                  p_exec_query$$1$$2$$11$$1$$1$$cent->c_soa = (unsigned char)ml;

                              }

                            }

                          }

                        }
                      }

                    }
                    if(!(st->rejectlist == ((struct rejectlist_s *)NULL)))
                    {
                      signed int p_exec_query$$1$$2$$12$$i;
                      signed int na4 = st->rejectlist->na4;
                      struct anonymous$11 *a4arr = (struct anonymous$11 *)((struct anonymous$13 *)st->rejectlist->rdata + (signed long int)st->rejectlist->na6);
                      signed int na6 = st->rejectlist->na6;
                      struct anonymous$13 *a6arr = (struct anonymous$13 *)st->rejectlist->rdata;
                      p_exec_query$$1$$2$$12$$i = 0;
                      for( ; !(p_exec_query$$1$$2$$12$$i >= 3); p_exec_query$$1$$2$$12$$i = p_exec_query$$1$$2$$12$$i + 1)
                      {
                        struct anonymous$16 *p_exec_query$$1$$2$$12$$1$$1$$sec = secs[(signed long int)p_exec_query$$1$$2$$12$$i];
                        signed int p_exec_query$$1$$2$$12$$1$$1$$j;
                        signed int nce;
                        unsigned int return_value_da_nel$76;
                        return_value_da_nel$76=da_nel$link2((struct anonymous$3 *)p_exec_query$$1$$2$$12$$1$$1$$sec);
                        nce = (signed int)return_value_da_nel$76;
                        p_exec_query$$1$$2$$12$$1$$1$$j = 0;
                        for( ; !(p_exec_query$$1$$2$$12$$1$$1$$j >= nce); p_exec_query$$1$$2$$12$$1$$1$$j = p_exec_query$$1$$2$$12$$1$$1$$j + 1)
                        {
                          struct anonymous$0 *p_exec_query$$1$$2$$12$$1$$1$$1$$1$$cent = &p_exec_query$$1$$2$$12$$1$$1$$sec->elem[(signed long int)p_exec_query$$1$$2$$12$$1$$1$$j];
                          struct anonymous *p_exec_query$$1$$2$$12$$1$$1$$1$$1$$rrset;
                          struct anonymous *tmp_if_expr$77;
                          if((1 & (signed int)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$cent->flags) == 0)
                            tmp_if_expr$77 = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$cent->$anon0.rr.rrmu[(signed long int)0];

                          else
                            tmp_if_expr$77 = (struct anonymous *)(void *)0;
                          p_exec_query$$1$$2$$12$$1$$1$$1$$1$$rrset = tmp_if_expr$77;
                          if(!(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$rrset == ((struct anonymous *)NULL)) && !(na4 == 0))
                          {
                            struct rr_b_s *p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$rr = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$rrset->rrs;
                            for( ; !(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$rr == ((struct rr_b_s *)NULL)); p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$rr = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$rr->next)
                            {
                              struct in_addr *a = (struct in_addr *)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$rr->data;
                              signed int p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$k = 0;
                              for( ; !(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$k >= na4); p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$k = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$k + 1)
                              {
                                struct anonymous$11 *am = &a4arr[(signed long int)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$k];
                                if(((a->s_addr ^ am->a.s_addr) & am->mask.s_addr) == 0u)
                                {
                                  unsigned char p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$nmbuf[256l];
                                  char abuf[46l];
                                  char p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$_debugsockabuf[46l];
                                  if(!(debug_p == 0))
                                  {
                                    union anonymous$6 *tmp_if_expr$78;
                                    if(!(run_ipv4 == 0))
                                      tmp_if_expr$78 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                                    else
                                      tmp_if_expr$78 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                                    return_value_pdnsd_a2str$79=pdnsd_a2str(tmp_if_expr$78, p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$_debugsockabuf, 46);
                                    return_value_rhn2str$80=rhn2str(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$cent->qname, p_exec_query$$1$$2$$12$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                    return_value_inet_ntop$81=inet_ntop(2, (const void *)a, abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                    debug_msg(0, "Rejecting answer from server %s because it contains an A record for \"%s\" with an address in the reject list: %s\n", return_value_pdnsd_a2str$79, return_value_rhn2str$80, return_value_inet_ntop$81);
                                  }

                                  reject_ans = (unsigned short int)1;
                                  goto rejectlist_scan_done;
                                }

                              }
                            }
                          }

                          struct anonymous *tmp_if_expr$82;
                          if((1 & (signed int)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$cent->flags) == 0)
                            tmp_if_expr$82 = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$cent->$anon0.rr.rrmu[(signed long int)7];

                          else
                            tmp_if_expr$82 = (struct anonymous *)(void *)0;
                          p_exec_query$$1$$2$$12$$1$$1$$1$$1$$rrset = tmp_if_expr$82;
                          if(!(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$rrset == ((struct anonymous *)NULL)) && !(na6 == 0))
                          {
                            struct rr_b_s *p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$rr = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$rrset->rrs;
                            for( ; !(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$rr == ((struct rr_b_s *)NULL)); p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$rr = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$rr->next)
                            {
                              struct in6_addr *p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$a = (struct in6_addr *)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$rr->data;
                              signed int p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$k = 0;
                              for( ; !(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$k >= na6); p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$k = p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$k + 1)
                              {
                                struct anonymous$13 *p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am = &a6arr[(signed long int)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$k];
                                if(((*((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->a) ^ *((unsigned int *)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$a)) & *((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->mask)) == 0u)
                                {
                                  if(((((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->a)[1l] ^ ((unsigned int *)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$a)[1l]) & ((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->mask)[1l]) == 0u)
                                  {
                                    if(((((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->a)[2l] ^ ((unsigned int *)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$a)[2l]) & ((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->mask)[2l]) == 0u)
                                    {
                                      if(((((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->a)[3l] ^ ((unsigned int *)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$a)[3l]) & ((unsigned int *)&p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$am->mask)[3l]) == 0u)
                                      {
                                        unsigned char p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$1$$nmbuf[256l];
                                        char p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$1$$abuf[46l];
                                        char p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$1$$1$$_debugsockabuf[46l];
                                        if(!(debug_p == 0))
                                        {
                                          union anonymous$6 *tmp_if_expr$83;
                                          if(!(run_ipv4 == 0))
                                            tmp_if_expr$83 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                                          else
                                            tmp_if_expr$83 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                                          return_value_pdnsd_a2str$84=pdnsd_a2str(tmp_if_expr$83, p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$1$$1$$_debugsockabuf, 46);
                                          return_value_rhn2str$85=rhn2str(p_exec_query$$1$$2$$12$$1$$1$$1$$1$$cent->qname, p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$1$$nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                          return_value_inet_ntop$86=inet_ntop(10, (const void *)p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$a, p_exec_query$$1$$2$$12$$1$$1$$1$$1$$2$$1$$1$$1$$1$$1$$abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                          debug_msg(0, "Rejecting answer from server %s because it contains an AAAA record for \"%s\" with an address in the reject list: %s\n", return_value_pdnsd_a2str$84, return_value_rhn2str$85, return_value_inet_ntop$86);
                                        }

                                        reject_ans = (unsigned short int)1;
                                        goto rejectlist_scan_done;
                                      }

                                    }

                                  }

                                }

                              }
                            }
                          }

                        }
                      }
                    }


                  rejectlist_scan_done:
                    ;
                    if(rcode == 3)
                    {
                      char p_exec_query$$1$$2$$13$$1$$_debugsockabuf[46l];
                      if(!(debug_p == 0))
                      {
                        union anonymous$6 *tmp_if_expr$87;
                        if(!(run_ipv4 == 0))
                          tmp_if_expr$87 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                        else
                          tmp_if_expr$87 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                        return_value_pdnsd_a2str$88=pdnsd_a2str(tmp_if_expr$87, p_exec_query$$1$$2$$13$$1$$_debugsockabuf, 46);
                        return_value_get_ename$89=get_ename(rcode);
                        debug_msg(0, "Server %s returned error code: %s\n", return_value_pdnsd_a2str$88, return_value_get_ename$89);
                      }


                    name_error:
                      ;
                      neg_ans = (unsigned short int)1;
                      struct anonymous$0 *p_exec_query$$1$$2$$13$$2$$ent = &secs[(signed long int)0]->elem[(signed long int)0];
                      signed int neg_domain_pol = (signed int)global.neg_domain_pol;
                      _Bool tmp_if_expr$94;
                      if(neg_domain_pol == 1)
                        tmp_if_expr$94 = (_Bool)1;

                      else
                      {
                        if(neg_domain_pol == 22)
                          tmp_if_expr$93 = st->recvbuf->aa != 0u ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr$93 = (_Bool)0;
                        tmp_if_expr$94 = tmp_if_expr$93 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$94)
                      {
                        signed long int p_exec_query$$1$$2$$13$$2$$1$$ttl = global.neg_ttl;
                        if(!((signed int)p_exec_query$$1$$2$$13$$2$$ent->c_soa == 0xff))
                        {
                          unsigned int p_exec_query$$1$$2$$13$$2$$1$$1$$scnt;
                          p_exec_query$$1$$2$$13$$2$$1$$1$$scnt=rhnsegcnt$link1(name);
                          struct anonymous$0 *p_exec_query$$1$$2$$13$$2$$1$$1$$cent;
                          if(!((unsigned int)p_exec_query$$1$$2$$13$$2$$ent->c_soa >= p_exec_query$$1$$2$$13$$2$$1$$1$$scnt))
                          {
                            return_value_skipsegs$91=skipsegs$link1(name, p_exec_query$$1$$2$$13$$2$$1$$1$$scnt - (unsigned int)p_exec_query$$1$$2$$13$$2$$ent->c_soa);
                            p_exec_query$$1$$2$$13$$2$$1$$1$$cent=lookup_cent_array(secs[(signed long int)1], return_value_skipsegs$91);
                            if(!(p_exec_query$$1$$2$$13$$2$$1$$1$$cent == ((struct anonymous$0 *)NULL)))
                            {
                              struct anonymous *p_exec_query$$1$$2$$13$$2$$1$$1$$1$$rrset;
                              struct anonymous *tmp_if_expr$90;
                              if((1 & (signed int)p_exec_query$$1$$2$$13$$2$$1$$1$$cent->flags) == 0)
                                tmp_if_expr$90 = p_exec_query$$1$$2$$13$$2$$1$$1$$cent->$anon0.rr.rrmu[(signed long int)3];

                              else
                                tmp_if_expr$90 = (struct anonymous *)(void *)0;
                              p_exec_query$$1$$2$$13$$2$$1$$1$$1$$rrset = tmp_if_expr$90;
                              if(!(p_exec_query$$1$$2$$13$$2$$1$$1$$1$$rrset == ((struct anonymous *)NULL)))
                              {
                                if(!(p_exec_query$$1$$2$$13$$2$$1$$1$$1$$rrset->rrs == ((struct rr_b_s *)NULL)))
                                {
                                  signed long int p_exec_query$$1$$2$$13$$2$$1$$1$$1$$1$$min;
                                  p_exec_query$$1$$2$$13$$2$$1$$1$$1$$1$$min=soa_minimum(p_exec_query$$1$$2$$13$$2$$1$$1$$1$$rrset->rrs);
                                  p_exec_query$$1$$2$$13$$2$$1$$ttl = p_exec_query$$1$$2$$13$$2$$1$$1$$1$$rrset->ttl;
                                  if(!(p_exec_query$$1$$2$$13$$2$$1$$1$$1$$1$$min >= p_exec_query$$1$$2$$13$$2$$1$$ttl))
                                    p_exec_query$$1$$2$$13$$2$$1$$ttl = p_exec_query$$1$$2$$13$$2$$1$$1$$1$$1$$min;

                                }

                              }

                            }

                          }

                        }

                        unsigned char p_exec_query$$1$$2$$13$$2$$1$$2$$_debugstrbuf[256l];
                        if(!(debug_p == 0))
                        {
                          return_value_rhn2str$92=rhn2str(name, p_exec_query$$1$$2$$13$$2$$1$$2$$_debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                          debug_msg(0, "Caching domain %s negative with ttl %li\n", return_value_rhn2str$92, (signed long int)p_exec_query$$1$$2$$13$$2$$1$$ttl);
                        }

                        negate_cent(p_exec_query$$1$$2$$13$$2$$ent, p_exec_query$$1$$2$$13$$2$$1$$ttl, queryts);
                        if(!(st->nocache == 0))
                          p_exec_query$$1$$2$$13$$2$$ent->flags = p_exec_query$$1$$2$$13$$2$$ent->flags | (unsigned short int)8;

                        goto cleanup_return_OK;
                      }

                      else
                      {
                        if(!(c_soa == ((unsigned char *)NULL)))
                          *c_soa = p_exec_query$$1$$2$$13$$2$$ent->c_soa;

                        free_cent(p_exec_query$$1$$2$$13$$2$$ent);
                        rv = 3;
                        goto add_additional;
                      }
                    }

                    if(!(reject_ans == 0))
                    {
                      _Bool tmp_if_expr$95;
                      if((signed int)st->rejectlist->policy == 25)
                        tmp_if_expr$95 = (signed int)st->failed <= 1 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr$95 = (_Bool)0;
                      if(tmp_if_expr$95)
                        goto name_error;

                      else
                      {
                        rv = 2;
                        goto free_ent_centarrays_recvbuf_return;
                      }
                    }

                    if(!(global.deleg_only_zones == ((struct anonymous$30 *)NULL)))
                    {
                      if(!((signed int)st->auth_serv >= 3))
                      {
                        signed int missingdelegation;
                        signed int authcnt;
                        lock_server_data();
                        missingdelegation = 0;
                        authcnt = 0;
                        signed int i;
                        signed int n;
                        unsigned int return_value_da_nel$96;
                        return_value_da_nel$96=da_nel$link2((struct anonymous$3 *)global.deleg_only_zones);
                        n = (signed int)return_value_da_nel$96;
                        unsigned int rem;
                        unsigned int zrem;
                        i = 0;
                        for( ; !(i >= n); i = i + 1)
                        {
                          unsigned int return_value_domain_match$97;
                          return_value_domain_match$97=domain_match(name, global.deleg_only_zones->elem[(signed long int)i], &rem, &zrem);
                          if(!(return_value_domain_match$97 == 0u))
                          {
                            if(zrem == 0u)
                              goto zone_match;

                          }

                        }
                        goto delegation_OK;

                      zone_match:
                        ;
                        if(!(rem == 0u))
                        {
                          signed int j = 0;
                          for( ; !(j >= 2); j = j + 1)
                          {
                            struct anonymous$16 *sec = secs[(signed long int)j];
                            signed int k;
                            signed int m;
                            unsigned int return_value_da_nel$98;
                            return_value_da_nel$98=da_nel$link2((struct anonymous$3 *)sec);
                            m = (signed int)return_value_da_nel$98;
                            k = 0;
                            for( ; !(k >= m); k = k + 1)
                            {
                              struct anonymous$0 *ce = &sec->elem[(signed long int)k];
                              struct anonymous *tmp_if_expr$100;
                              if((1 & (signed int)ce->flags) == 0)
                                tmp_if_expr$100 = ce->$anon0.rr.rrmu[(signed long int)1];

                              else
                                tmp_if_expr$100 = (struct anonymous *)(void *)0;
                              _Bool tmp_if_expr$102;
                              if(!(tmp_if_expr$100 == ((struct anonymous *)NULL)))
                                tmp_if_expr$102 = (_Bool)1;

                              else
                              {
                                if((1 & (signed int)ce->flags) == 0)
                                  tmp_if_expr$101 = ce->$anon0.rr.rrmu[(signed long int)3];

                                else
                                  tmp_if_expr$101 = (struct anonymous *)(void *)0;
                                tmp_if_expr$102 = tmp_if_expr$101 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr$102)
                              {
                                signed int l;
                                authcnt = authcnt + 1;
                                l = 0;
                                for( ; !(l >= n); l = l + 1)
                                {
                                  unsigned int return_value_domain_match$99;
                                  return_value_domain_match$99=domain_match(ce->qname, global.deleg_only_zones->elem[(signed long int)l], &rem, &zrem);
                                  if(!(return_value_domain_match$99 == 0u))
                                  {
                                    if(zrem == 0u)
                                    {
                                      if(!(rem == 0u))
                                        break;

                                      else
                                        goto try_next_auth;
                                    }

                                  }

                                }
                                goto delegation_OK;
                              }


                            try_next_auth:
                              ;
                            }
                          }
                          unsigned char nmbuf[256l];
                          unsigned char zbuf[256l];
                          char p_exec_query$$1$$2$$15$$1$$2$$2$$1$$_debugsockabuf[46l];
                          if(!(debug_p == 0))
                          {
                            return_value_rhn2str$103=rhn2str(name, nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                            return_value_rhn2str$104=rhn2str(global.deleg_only_zones->elem[(signed long int)i], zbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                            union anonymous$6 *tmp_if_expr$105;
                            if(!(run_ipv4 == 0))
                              tmp_if_expr$105 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                            else
                              tmp_if_expr$105 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                            return_value_pdnsd_a2str$106=pdnsd_a2str(tmp_if_expr$105, p_exec_query$$1$$2$$15$$1$$2$$2$$1$$_debugsockabuf, 46);
                            debug_msg(0, authcnt != 0 ? "%s is in %s zone, but no delegation found in answer returned by server %s\n" : "%s is in %s zone, but no authority information provided by server %s\n", return_value_rhn2str$103, return_value_rhn2str$104, return_value_pdnsd_a2str$106);
                          }

                          missingdelegation = 1;
                        }


                      delegation_OK:
                        ;
                        unlock_server_data();
                        if(!(missingdelegation == 0))
                        {
                          _Bool tmp_if_expr$107;
                          if(!(authcnt == 0))
                            tmp_if_expr$107 = (signed int)st->failed <= 1 ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr$107 = (_Bool)0;
                          if(tmp_if_expr$107)
                            goto name_error;

                          else
                            if(!((signed int)st->auth_serv >= 2))
                            {
                              rv = 2;
                              goto free_ent_centarrays_recvbuf_return;
                            }

                        }

                      }

                    }

                    struct anonymous$0 *ent = &secs[(signed long int)0]->elem[(signed long int)0];
                    if(ent->num_rrs == 0)
                      neg_ans = (unsigned short int)1;

                    if(thint >= 1 && !(thint >= 52))
                    {
                      return_value_getrrset$124=getrrset$link1(ent, thint);
                      if(return_value_getrrset$124 == ((struct anonymous *)NULL))
                      {
                        if(st->tc == 0)
                        {
                          if(!((signed int)st->failed >= 2))
                          {
                            signed int neg_rrs_pol = (signed int)global.neg_rrs_pol;
                            _Bool tmp_if_expr$123;
                            if(neg_rrs_pol == 1 || neg_rrs_pol == 22 && !(aa == 0))
                              tmp_if_expr$123 = (_Bool)1;

                            else
                            {
                              if(neg_rrs_pol == 3)
                              {
                                if(!(aa == 0))
                                  tmp_if_expr$121 = (_Bool)1;

                                else
                                {
                                  if(!(rd == 0))
                                    tmp_if_expr$120 = st->recvbuf->ra != 0u ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr$120 = (_Bool)0;
                                  tmp_if_expr$121 = tmp_if_expr$120 ? (_Bool)1 : (_Bool)0;
                                }
                                tmp_if_expr$122 = tmp_if_expr$121 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr$122 = (_Bool)0;
                              tmp_if_expr$123 = tmp_if_expr$122 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr$123)
                            {
                              signed long int ttl = global.neg_ttl;
                              struct anonymous *rrset;
                              struct anonymous *tmp_if_expr$108;
                              if((1 & (signed int)ent->flags) == 0)
                                tmp_if_expr$108 = ent->$anon0.rr.rrmu[(signed long int)3];

                              else
                                tmp_if_expr$108 = (struct anonymous *)(void *)0;
                              rrset = tmp_if_expr$108;
                              struct anonymous$0 *cent;
                              unsigned int scnt;
                              _Bool tmp_if_expr$109;
                              if(!(rrset == ((struct anonymous *)NULL)))
                                tmp_if_expr$109 = rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$109 = (_Bool)0;
                              _Bool tmp_if_expr$116;
                              if(tmp_if_expr$109)
                                tmp_if_expr$116 = (_Bool)1;

                              else
                              {
                                if(!((signed int)ent->c_soa == 0xff))
                                {
                                  scnt=rhnsegcnt$link1(name);
                                  tmp_if_expr$110 = (unsigned int)ent->c_soa < scnt ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr$110 = (_Bool)0;
                                if(tmp_if_expr$110)
                                {
                                  return_value_skipsegs$111=skipsegs$link1(name, scnt - (unsigned int)ent->c_soa);
                                  tmp_if_expr$112 = return_value_skipsegs$111;
                                }

                                else
                                  tmp_if_expr$112 = name;
                                cent=lookup_cent_array(secs[(signed long int)1], tmp_if_expr$112);
                                if(!(cent == ((struct anonymous$0 *)NULL)))
                                {
                                  if((1 & (signed int)cent->flags) == 0)
                                    tmp_if_expr$113 = cent->$anon0.rr.rrmu[(signed long int)3];

                                  else
                                    tmp_if_expr$113 = (struct anonymous *)(void *)0;
                                  rrset = tmp_if_expr$113;
                                  tmp_if_expr$114 = rrset != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr$114 = (_Bool)0;
                                if(tmp_if_expr$114)
                                  tmp_if_expr$115 = rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr$115 = (_Bool)0;
                                tmp_if_expr$116 = tmp_if_expr$115 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr$116)
                              {
                                signed long int min;
                                min=soa_minimum(rrset->rrs);
                                ttl = rrset->ttl;
                                if(!(min >= ttl))
                                  ttl = min;

                              }

                              unsigned char _debugstrbuf[256l];
                              if(!(debug_p == 0))
                              {
                                return_value_getrrtpname$117=getrrtpname(thint);
                                return_value_rhn2str$118=rhn2str(name, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                debug_msg(0, "Caching type %s for domain %s negative with ttl %li\n", return_value_getrrtpname$117, return_value_rhn2str$118, (signed long int)ttl);
                              }

                              signed int return_value_add_cent_rrset_by_type$119;
                              return_value_add_cent_rrset_by_type$119=add_cent_rrset_by_type(ent, thint, ttl, queryts, (unsigned int)(1 | (signed int)flags));
                              if(return_value_add_cent_rrset_by_type$119 == 0)
                              {
                                rv = 0xffff;
                                goto free_ent_centarrays_recvbuf_return;
                              }

                            }

                          }

                        }

                      }

                    }

                    if(!((signed int)st->failed >= 2))
                    {
                      signed int p_exec_query$$1$$2$$17$$i = 0;
                      for( ; !(p_exec_query$$1$$2$$17$$i >= 2); p_exec_query$$1$$2$$17$$i = p_exec_query$$1$$2$$17$$i + 1)
                      {
                        struct anonymous$16 *p_exec_query$$1$$2$$17$$1$$1$$sec = secs[(signed long int)p_exec_query$$1$$2$$17$$i];
                        signed int p_exec_query$$1$$2$$17$$1$$1$$j;
                        signed int p_exec_query$$1$$2$$17$$1$$1$$n;
                        unsigned int return_value_da_nel$125;
                        return_value_da_nel$125=da_nel$link2((struct anonymous$3 *)p_exec_query$$1$$2$$17$$1$$1$$sec);
                        p_exec_query$$1$$2$$17$$1$$1$$n = (signed int)return_value_da_nel$125;
                        p_exec_query$$1$$2$$17$$1$$1$$j = 0;
                        for( ; !(p_exec_query$$1$$2$$17$$1$$1$$j >= p_exec_query$$1$$2$$17$$1$$1$$n); p_exec_query$$1$$2$$17$$1$$1$$j = p_exec_query$$1$$2$$17$$1$$1$$j + 1)
                        {
                          struct anonymous$0 *p_exec_query$$1$$2$$17$$1$$1$$1$$1$$cent = &p_exec_query$$1$$2$$17$$1$$1$$sec->elem[(signed long int)p_exec_query$$1$$2$$17$$1$$1$$j];
                          unsigned int p_exec_query$$1$$2$$17$$1$$1$$1$$1$$rem;
                          _Bool tmp_if_expr$139;
                          if(!(*p_exec_query$$1$$2$$17$$1$$1$$1$$1$$cent->qname == 0))
                            tmp_if_expr$139 = (_Bool)1;

                          else
                            tmp_if_expr$139 = (signed int)st->auth_serv != 2 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$139)
                          {
                            _Bool tmp_if_expr$137;
                            if(!(st->trusted == 0))
                              tmp_if_expr$137 = (_Bool)1;

                            else
                              tmp_if_expr$137 = !(st->nsdomain != ((const unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
                            _Bool tmp_if_expr$138;
                            if(tmp_if_expr$137)
                              tmp_if_expr$138 = (_Bool)1;

                            else
                            {
                              domain_match(st->nsdomain, p_exec_query$$1$$2$$17$$1$$1$$1$$1$$cent->qname, &p_exec_query$$1$$2$$17$$1$$1$$1$$1$$rem, (unsigned int *)(void *)0);
                              tmp_if_expr$138 = p_exec_query$$1$$2$$17$$1$$1$$1$$1$$rem == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr$138)
                            {
                              if(!((signed int)*p_exec_query$$1$$2$$17$$1$$1$$1$$1$$cent->qname == 0xff))
                              {
                                signed int p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$k = 0;
                                for( ; !(p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$k >= 2); p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$k = p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$k + 1)
                                {
                                  struct anonymous *p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$rrset;
                                  static const unsigned short int nstypes[2l] = { (const unsigned short int)2, (const unsigned short int)6 };
                                  p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$rrset=getrrset$link1(p_exec_query$$1$$2$$17$$1$$1$$1$$1$$cent, (signed int)nstypes[(signed long int)p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$k]);
                                  if(!(p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$rrset == ((struct anonymous *)NULL)))
                                  {
                                    struct rr_b_s *rr;
                                    unsigned short int first = (unsigned short int)1;
                                    rr = p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$rrset->rrs;
                                    for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
                                    {
                                      unsigned long int sz1;
                                      unsigned long int sz2;
                                      unsigned char *p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p;
                                      void *return_value_dlist_first$126;
                                      return_value_dlist_first$126=dlist_first$link2(*ns);
                                      p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p = (unsigned char *)return_value_dlist_first$126;
                                      for( ; !(p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p == ((unsigned char *)NULL)); p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p = (unsigned char *)return_value_dlist_next$127)
                                      {
                                        unsigned char *tmp_if_expr$129;
                                        if((signed int)*p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p == 0xff)
                                          tmp_if_expr$129 = p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p + (signed long int)1;

                                        else
                                        {
                                          return_value_skiprhn$128=skiprhn$link1(p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p);
                                          tmp_if_expr$129 = return_value_skiprhn$128;
                                        }
                                        signed int return_value_rhnicmp$130;
                                        return_value_rhnicmp$130=rhnicmp$link1(tmp_if_expr$129, (unsigned char *)rr->data);
                                        if(!(return_value_rhnicmp$130 == 0))
                                          goto next_nsr;

                                        return_value_dlist_next$127=dlist_next$link2((void *)p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p);
                                      }
                                      unsigned int tmp_if_expr$132;
                                      if(!(first == 0))
                                      {
                                        return_value_rhnlen$131=rhnlen$link3(p_exec_query$$1$$2$$17$$1$$1$$1$$1$$cent->qname);
                                        tmp_if_expr$132 = return_value_rhnlen$131;
                                      }

                                      else
                                        tmp_if_expr$132 = (unsigned int)1;
                                      sz1 = (unsigned long int)tmp_if_expr$132;
                                      unsigned int return_value_rhnlen$133;
                                      return_value_rhnlen$133=rhnlen$link3((unsigned char *)rr->data);
                                      sz2 = (unsigned long int)return_value_rhnlen$133;
                                      *ns=dlist_grow(*ns, sz1 + sz2);
                                      if(*ns == ((struct _dynamic_list_head *)NULL))
                                      {
                                        rv = 0xffff;
                                        goto free_ent_centarrays_recvbuf_return;
                                      }

                                      void *return_value_dlist_last$134;
                                      return_value_dlist_last$134=dlist_last$link2(*ns);
                                      p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p = (unsigned char *)return_value_dlist_last$134;
                                      if(!(first == 0))
                                      {
                                        first = (unsigned short int)0;
                                        void *return_value_mempcpy$135;
                                        return_value_mempcpy$135=mempcpy((void *)p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p, (const void *)p_exec_query$$1$$2$$17$$1$$1$$1$$1$$cent->qname, sz1);
                                        p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p = (unsigned char *)return_value_mempcpy$135;
                                      }

                                      else
                                      {
                                        unsigned char *tmp_post$136 = p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p;
                                        p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p = p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p + 1l;
                                        *tmp_post$136 = (unsigned char)0xff;
                                      }
                                      memcpy((void *)p_exec_query$$1$$2$$17$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$p, (const void *)(unsigned char *)rr->data, sz2);
                                      num_ns = num_ns + 1;

                                    next_nsr:
                                      ;
                                    }
                                  }

                                }
                              }

                            }

                          }

                        }
                      }
                    }


                  cleanup_return_OK:
                    ;
                    if(!(st->failed == 0))
                    {
                      if(neg_ans == 0)
                        goto __CPROVER_DUMP_L307;

                      if(!((signed int)num_ns == 0))
                        goto __CPROVER_DUMP_L307;

                      char p_exec_query$$1$$2$$18$$1$$_debugsockabuf[46l];
                      if(!(debug_p == 0))
                      {
                        union anonymous$6 *tmp_if_expr$140;
                        if(!(run_ipv4 == 0))
                          tmp_if_expr$140 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                        else
                          tmp_if_expr$140 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                        return_value_pdnsd_a2str$141=pdnsd_a2str(tmp_if_expr$140, p_exec_query$$1$$2$$18$$1$$_debugsockabuf, 46);
                        debug_msg(0, "Answer from server %s does not contain usable records.\n", return_value_pdnsd_a2str$141);
                      }

                      rv = 2;
                    }

                    else
                    {

                    __CPROVER_DUMP_L307:
                      ;
                      return_value_malloc$142=malloc(sizeof(struct anonymous$0) /*104ul*/ );
                      *entp = (struct anonymous$0 *)return_value_malloc$142;
                      if(*entp == ((struct anonymous$0 *)NULL))
                        rv = 0xffff;

                      else
                      {
                        *(*entp) = secs[(signed long int)0]->elem[(signed long int)0];
                        rv = 0;

                      add_additional:
                        ;
                        if(st->failed == 0)
                        {
                          if(reject_ans == 0)
                          {
                            signed int p_exec_query$$1$$2$$20$$i;
                            if(!(debug_p == 0) && !(neg_ans == 0))
                            {
                              signed int p_exec_query$$1$$2$$20$$1$$j;
                              signed int p_exec_query$$1$$2$$20$$1$$n;
                              unsigned int return_value_da_nel$143;
                              return_value_da_nel$143=da_nel$link2((struct anonymous$3 *)secs[(signed long int)0]);
                              p_exec_query$$1$$2$$20$$1$$n = (signed int)return_value_da_nel$143;
                              p_exec_query$$1$$2$$20$$1$$j = 1;
                              for( ; !(p_exec_query$$1$$2$$20$$1$$j >= p_exec_query$$1$$2$$20$$1$$n); p_exec_query$$1$$2$$20$$1$$j = p_exec_query$$1$$2$$20$$1$$j + 1)
                              {
                                unsigned char p_exec_query$$1$$2$$20$$1$$1$$1$$nmbuf[256l];
                                unsigned char nmbuf2[256l];
                                char p_exec_query$$1$$2$$20$$1$$1$$1$$1$$_debugsockabuf[46l];
                                if(!(debug_p == 0))
                                {
                                  union anonymous$6 *tmp_if_expr$144;
                                  if(!(run_ipv4 == 0))
                                    tmp_if_expr$144 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                                  else
                                    tmp_if_expr$144 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                                  return_value_pdnsd_a2str$145=pdnsd_a2str(tmp_if_expr$144, p_exec_query$$1$$2$$20$$1$$1$$1$$1$$_debugsockabuf, 46);
                                  return_value_rhn2str$146=rhn2str(name, p_exec_query$$1$$2$$20$$1$$1$$1$$nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                  return_value_rhn2str$147=rhn2str(secs[(signed long int)0]->elem[(signed long int)p_exec_query$$1$$2$$20$$1$$j].qname, nmbuf2, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                  debug_msg(0, "Reply from %s is negative for %s, dropping record(s) for %s in answer section.\n", return_value_pdnsd_a2str$145, return_value_rhn2str$146, return_value_rhn2str$147);
                                }

                              }
                            }

                            p_exec_query$$1$$2$$20$$i = (signed int)neg_ans;
                            for( ; !(p_exec_query$$1$$2$$20$$i >= 3); p_exec_query$$1$$2$$20$$i = p_exec_query$$1$$2$$20$$i + 1)
                            {
                              struct anonymous$16 *p_exec_query$$1$$2$$20$$2$$1$$sec = secs[(signed long int)p_exec_query$$1$$2$$20$$i];
                              signed int p_exec_query$$1$$2$$20$$2$$1$$j;
                              signed int p_exec_query$$1$$2$$20$$2$$1$$n;
                              unsigned int return_value_da_nel$148;
                              return_value_da_nel$148=da_nel$link2((struct anonymous$3 *)p_exec_query$$1$$2$$20$$2$$1$$sec);
                              p_exec_query$$1$$2$$20$$2$$1$$n = (signed int)return_value_da_nel$148;
                              p_exec_query$$1$$2$$20$$2$$1$$j = (signed int)!(p_exec_query$$1$$2$$20$$i != 0);
                              for( ; !(p_exec_query$$1$$2$$20$$2$$1$$j >= p_exec_query$$1$$2$$20$$2$$1$$n); p_exec_query$$1$$2$$20$$2$$1$$j = p_exec_query$$1$$2$$20$$2$$1$$j + 1)
                              {
                                struct anonymous$0 *p_exec_query$$1$$2$$20$$2$$1$$1$$1$$cent = &p_exec_query$$1$$2$$20$$2$$1$$sec->elem[(signed long int)p_exec_query$$1$$2$$20$$2$$1$$j];
                                _Bool tmp_if_expr$155;
                                if(!(*p_exec_query$$1$$2$$20$$2$$1$$1$$1$$cent->qname == 0))
                                  tmp_if_expr$155 = (_Bool)1;

                                else
                                  tmp_if_expr$155 = (signed int)st->auth_serv != 2 ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr$155)
                                {
                                  unsigned int p_exec_query$$1$$2$$20$$2$$1$$1$$1$$1$$rem;
                                  _Bool tmp_if_expr$151;
                                  if(!(st->trusted == 0))
                                    tmp_if_expr$151 = (_Bool)1;

                                  else
                                    tmp_if_expr$151 = !(st->nsdomain != ((const unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
                                  _Bool tmp_if_expr$152;
                                  if(tmp_if_expr$151)
                                    tmp_if_expr$152 = (_Bool)1;

                                  else
                                  {
                                    domain_match(st->nsdomain, p_exec_query$$1$$2$$20$$2$$1$$1$$1$$cent->qname, &p_exec_query$$1$$2$$20$$2$$1$$1$$1$$1$$rem, (unsigned int *)(void *)0);
                                    tmp_if_expr$152 = p_exec_query$$1$$2$$20$$2$$1$$1$$1$$1$$rem == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
                                  }
                                  if(tmp_if_expr$152)
                                    add_cache(p_exec_query$$1$$2$$20$$2$$1$$1$$1$$cent);

                                  else
                                  {
                                    unsigned char p_exec_query$$1$$2$$20$$2$$1$$1$$1$$1$$1$$nmbuf[256l];
                                    unsigned char nsbuf[256l];
                                    if(!(debug_p == 0))
                                    {
                                      return_value_rhn2str$149=rhn2str(p_exec_query$$1$$2$$20$$2$$1$$1$$1$$cent->qname, p_exec_query$$1$$2$$20$$2$$1$$1$$1$$1$$1$$nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                      return_value_rhn2str$150=rhn2str(st->nsdomain, nsbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                      debug_msg(0, "Record for %s not in nsdomain %s; dropped.\n", return_value_rhn2str$149, return_value_rhn2str$150);
                                    }

                                  }
                                }

                                else
                                {
                                  char p_exec_query$$1$$2$$20$$2$$1$$1$$1$$2$$1$$_debugsockabuf[46l];
                                  if(!(debug_p == 0))
                                  {
                                    union anonymous$6 *tmp_if_expr$153;
                                    if(!(run_ipv4 == 0))
                                      tmp_if_expr$153 = (union anonymous$6 *)&st->a.sin4.sin_addr;

                                    else
                                      tmp_if_expr$153 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
                                    return_value_pdnsd_a2str$154=pdnsd_a2str(tmp_if_expr$153, p_exec_query$$1$$2$$20$$2$$1$$1$$1$$2$$1$$_debugsockabuf, 46);
                                    static const char * const secname[3l] = { "answer", "authority", "additional" };
                                    debug_msg(0, "Record(s) for root domain in %s section from %s dropped.\n", secname[(signed long int)p_exec_query$$1$$2$$20$$i], return_value_pdnsd_a2str$154);
                                  }

                                }
                              }
                            }
                          }

                        }

                        goto free_centarrays_recvbuf_return;
                      }
                    }

                  free_ns_ent_centarrays_recvbuf_return:
                    ;
                    free((void *)*ns);
                    *ns = (struct _dynamic_list_head *)(void *)0;
                  }

                free_ent_centarrays_recvbuf_return:
                  ;
                  return_value_da_nel$156=da_nel$link2((struct anonymous$3 *)secs[(signed long int)0]);
                  if(return_value_da_nel$156 >= 1u)
                    free_cent(&secs[(signed long int)0]->elem[(signed long int)0]);

                }

              free_centarrays_recvbuf_return:
                ;
                signed int p_exec_query$$1$$2$$21$$i = 0;
                for( ; !(p_exec_query$$1$$2$$21$$i >= 3); p_exec_query$$1$$2$$21$$i = p_exec_query$$1$$2$$21$$i + 1)
                {
                  struct anonymous$16 *p_exec_query$$1$$2$$21$$1$$1$$sec = secs[(signed long int)p_exec_query$$1$$2$$21$$i];
                  signed int p_exec_query$$1$$2$$21$$1$$1$$j;
                  signed int p_exec_query$$1$$2$$21$$1$$1$$n;
                  unsigned int return_value_da_nel$157;
                  return_value_da_nel$157=da_nel$link2((struct anonymous$3 *)p_exec_query$$1$$2$$21$$1$$1$$sec);
                  p_exec_query$$1$$2$$21$$1$$1$$n = (signed int)return_value_da_nel$157;
                  p_exec_query$$1$$2$$21$$1$$1$$j = (signed int)!(p_exec_query$$1$$2$$21$$i != 0);
                  for( ; !(p_exec_query$$1$$2$$21$$1$$1$$j >= p_exec_query$$1$$2$$21$$1$$1$$n); p_exec_query$$1$$2$$21$$1$$1$$j = p_exec_query$$1$$2$$21$$1$$1$$j + 1)
                    free_cent(&p_exec_query$$1$$2$$21$$1$$1$$sec->elem[(signed long int)p_exec_query$$1$$2$$21$$1$$1$$j]);
                  free((void *)p_exec_query$$1$$2$$21$$1$$1$$sec);
                }
              }
            }
          }
        }
      }
    }
  }


free_recvbuf_return:
  ;
  free((void *)st->recvbuf);
  return rv;
}

// p_query_sm
// file dns_query.c line 847
static signed int p_query_sm(struct anonymous$5 *st)
{
  signed int retval = 2;
  signed int rv;

tryagain:
  ;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int return_value_bind_socket$3;
  signed int return_value_fcntl$8;
  const char *return_value_pdnsd_a2str$5;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int return_value_connect$29;
  signed int *return_value___errno_location$26;
  _Bool tmp_if_expr$28;
  signed int *return_value___errno_location$27;
  signed int *return_value___errno_location$25;
  const char *return_value_pdnsd_a2str$12;
  signed int *return_value___errno_location$18;
  _Bool tmp_if_expr$20;
  signed int *return_value___errno_location$19;
  char p_query_sm$$1$$1$$4$$3$$1$$abuf[46l];
  const char *return_value_pdnsd_a2str$14;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  const char *return_value_inet_ntop$17;
  const char *return_value_pdnsd_a2str$22;
  signed int *return_value___errno_location$23;
  char *return_value_strerror$24;
  const char *return_value_pdnsd_a2str$34;
  char *return_value_strerror$35;
  const char *return_value_pdnsd_a2str$39;
  char *return_value_strerror$40;
  signed int *return_value___errno_location$42;
  signed int *return_value___errno_location$46;
  const char *return_value_pdnsd_a2str$48;
  signed int *return_value___errno_location$49;
  char *return_value_strerror$50;
  _Bool tmp_if_expr$51;
  const char *return_value_pdnsd_a2str$54;
  while((_Bool)1)
  {
    if(!((signed int)st->state == 1))
    {
      if((signed int)st->state == 2)
        goto __CPROVER_DUMP_L33;

      if((signed int)st->state == 3)
        goto __CPROVER_DUMP_L50;

      if((signed int)st->state == 4)
        goto __CPROVER_DUMP_L74;

      if((signed int)st->state == 5)
        goto __CPROVER_DUMP_L95;

      goto __CPROVER_DUMP_L106;
    }

    st->sock=socket(run_ipv4 != 0 ? 2 : 10, 1, 6);
    if(st->sock == -1)
    {
      if(!(debug_p == 0))
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        debug_msg(0, "Could not open socket: %s\n", return_value_strerror$2);
      }

      goto __CPROVER_DUMP_L106;
    }

    return_value_bind_socket$3=bind_socket(st->sock);
    if(return_value_bind_socket$3 == 0)
    {
      close(st->sock);
      goto __CPROVER_DUMP_L106;
    }

    signed int oldflags;
    oldflags=fcntl(st->sock, 3, 0);
    _Bool tmp_if_expr$9;
    if(oldflags == -1)
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      return_value_fcntl$8=fcntl(st->sock, 4, oldflags | 04000);
      tmp_if_expr$9 = return_value_fcntl$8 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$9)
    {
      char p_query_sm$$1$$1$$3$$1$$1$$_debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous$6 *tmp_if_expr$4;
        if(!(run_ipv4 == 0))
          tmp_if_expr$4 = (union anonymous$6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr$4 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str$5=pdnsd_a2str(tmp_if_expr$4, p_query_sm$$1$$1$$3$$1$$1$$_debugsockabuf, 46);
        return_value___errno_location$6=__errno_location();
        return_value_strerror$7=strerror(*return_value___errno_location$6);
        debug_msg(0, "fcntl error while trying to make socket to %s non-blocking: %s\n", return_value_pdnsd_a2str$5, return_value_strerror$7);
      }

      close(st->sock);
      goto __CPROVER_DUMP_L106;
    }

    st->iolen = 0;
    do
    {

    retry_tcp_connect:
      ;
      return_value_connect$29=connect(st->sock, (struct sockaddr *)&st->a, (unsigned int)(run_ipv4 != 0 ? sizeof(struct sockaddr_in) /*16ul*/  : sizeof(struct sockaddr_in6) /*28ul*/ ));
      if(!(return_value_connect$29 == -1))
        goto __CPROVER_DUMP_L32;

      return_value___errno_location$26=__errno_location();
      if(*return_value___errno_location$26 == 115)
        tmp_if_expr$28 = (_Bool)1;

      else
      {
        return_value___errno_location$27=__errno_location();
        tmp_if_expr$28 = *return_value___errno_location$27 == 32 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$28)
      {
        st->state = (signed short int)2;
        return -1;
      }

      return_value___errno_location$25=__errno_location();
      if(*return_value___errno_location$25 == 111)
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        st->s_errno = *return_value___errno_location$10;
        char p_query_sm$$1$$1$$4$$2$$1$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$11;
          if(!(run_ipv4 == 0))
            tmp_if_expr$11 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$11 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$12=pdnsd_a2str(tmp_if_expr$11, p_query_sm$$1$$1$$4$$2$$1$$_debugsockabuf, 46);
          debug_msg(0, "TCP connection refused by %s\n", return_value_pdnsd_a2str$12);
        }

        close(st->sock);
        goto tcp_failed;
      }

      if(!(run_ipv4 == 0))
        goto __CPROVER_DUMP_L26;

      return_value___errno_location$18=__errno_location();
      if(*return_value___errno_location$18 == 101)
        tmp_if_expr$20 = (_Bool)1;

      else
      {
        return_value___errno_location$19=__errno_location();
        tmp_if_expr$20 = *return_value___errno_location$19 == 100 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$20)
        break;

      if(st->a4fallback.s_addr == 0u)
        break;

      char p_query_sm$$1$$1$$4$$3$$1$$1$$_debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous$6 *tmp_if_expr$13;
        if(!(run_ipv4 == 0))
          tmp_if_expr$13 = (union anonymous$6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr$13 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str$14=pdnsd_a2str(tmp_if_expr$13, p_query_sm$$1$$1$$4$$3$$1$$1$$_debugsockabuf, 46);
        return_value___errno_location$15=__errno_location();
        return_value_strerror$16=strerror(*return_value___errno_location$15);
        return_value_inet_ntop$17=inet_ntop(2, (const void *)&st->a4fallback, p_query_sm$$1$$1$$4$$3$$1$$abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
        debug_msg(0, "Connecting to %s failed: %s, retrying with IPv4 address %s\n", return_value_pdnsd_a2str$14, return_value_strerror$16, return_value_inet_ntop$17);
      }

      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)3] = (&st->a4fallback)->s_addr;
      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)2]=htonl((unsigned int)0xffff);
      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0] = (unsigned int)0;
      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)1] = ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0];
      st->a4fallback.s_addr = (unsigned int)0x00000000;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L26:
    ;
    char p_query_sm$$1$$1$$4$$3$$2$$_debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous$6 *tmp_if_expr$21;
      if(!(run_ipv4 == 0))
        tmp_if_expr$21 = (union anonymous$6 *)&st->a.sin4.sin_addr;

      else
        tmp_if_expr$21 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
      return_value_pdnsd_a2str$22=pdnsd_a2str(tmp_if_expr$21, p_query_sm$$1$$1$$4$$3$$2$$_debugsockabuf, 46);
      return_value___errno_location$23=__errno_location();
      return_value_strerror$24=strerror(*return_value___errno_location$23);
      debug_msg(0, "Error while connecting to %s: %s\n", return_value_pdnsd_a2str$22, return_value_strerror$24);
    }

    close(st->sock);
    goto __CPROVER_DUMP_L106;

  __CPROVER_DUMP_L32:
    ;
    st->state = (signed short int)2;

  __CPROVER_DUMP_L33:
    ;
    signed int p_query_sm$$1$$1$$5$$rem = (2 + (signed int)st->transl) - st->iolen;
    if(p_query_sm$$1$$1$$5$$rem >= 1)
    {
      signed long int return_value_write$30;
      return_value_write$30=write(st->sock, (const void *)((unsigned char *)st->msg + (signed long int)st->iolen), (unsigned long int)p_query_sm$$1$$1$$5$$rem);
      rv = (signed int)return_value_write$30;
      if(rv == -1)
      {
        signed int *return_value___errno_location$31;
        return_value___errno_location$31=__errno_location();
        if(*return_value___errno_location$31 == 11)
          return -1;

        signed int *return_value___errno_location$32;
        return_value___errno_location$32=__errno_location();
        st->s_errno = *return_value___errno_location$32;
        close(st->sock);
        if(st->iolen == 0)
        {
          _Bool tmp_if_expr$36;
          if(st->s_errno == 111)
            tmp_if_expr$36 = (_Bool)1;

          else
            tmp_if_expr$36 = st->s_errno == 104 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$37;
          if(tmp_if_expr$36)
            tmp_if_expr$37 = (_Bool)1;

          else
            tmp_if_expr$37 = st->s_errno == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$37)
          {
            char p_query_sm$$1$$1$$5$$1$$1$$1$$1$$_debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              union anonymous$6 *tmp_if_expr$33;
              if(!(run_ipv4 == 0))
                tmp_if_expr$33 = (union anonymous$6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr$33 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
              return_value_pdnsd_a2str$34=pdnsd_a2str(tmp_if_expr$33, p_query_sm$$1$$1$$5$$1$$1$$1$$1$$_debugsockabuf, 46);
              return_value_strerror$35=strerror(st->s_errno);
              debug_msg(0, "TCP connection to %s failed: %s\n", return_value_pdnsd_a2str$34, return_value_strerror$35);
            }

            goto tcp_failed;
          }

        }

        char _debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$38;
          if(!(run_ipv4 == 0))
            tmp_if_expr$38 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$38 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$39=pdnsd_a2str(tmp_if_expr$38, _debugsockabuf, 46);
          return_value_strerror$40=strerror(st->s_errno);
          debug_msg(0, "Error while sending data to %s: %s\n", return_value_pdnsd_a2str$39, return_value_strerror$40);
        }

        goto __CPROVER_DUMP_L106;
      }

      st->iolen = st->iolen + rv;
      if(!(rv >= p_query_sm$$1$$1$$5$$rem))
        return -1;

    }

    st->state = (signed short int)3;
    st->iolen = 0;

  __CPROVER_DUMP_L50:
    ;
    if(st->iolen == 0)
    {
      unsigned short int recvl_net;
      signed long int return_value_read$41;
      return_value_read$41=read(st->sock, (void *)&recvl_net, sizeof(unsigned short int) /*2ul*/ );
      rv = (signed int)return_value_read$41;
      if(rv == -1)
      {
        return_value___errno_location$42=__errno_location();
        if(*return_value___errno_location$42 == 11)
          return -1;

      }

      if(!((unsigned long int)rv == sizeof(unsigned short int) /*2ul*/ ))
        goto error_receiv_data;

      st->iolen = rv;
      st->recvl=ntohs(recvl_net);
      void *return_value_realloc_or_cleanup$43;
      return_value_realloc_or_cleanup$43=realloc_or_cleanup((void *)st->recvbuf, (unsigned long int)st->recvl);
      st->recvbuf = (struct anonymous$29 *)return_value_realloc_or_cleanup$43;
      if(st->recvbuf == ((struct anonymous$29 *)NULL))
      {
        close(st->sock);
        if(!(debug_p == 0))
          debug_msg(0, "Out of memory in query.\n");

        retval = 0xffff;
        goto __CPROVER_DUMP_L106;
      }

    }

    signed int offset = (signed int)((unsigned long int)st->iolen - sizeof(unsigned short int) /*2ul*/ );
    signed int rem = (signed int)st->recvl - offset;
    if(rem >= 1)
    {
      signed long int return_value_read$44;
      return_value_read$44=read(st->sock, (void *)((unsigned char *)st->recvbuf + (signed long int)offset), (unsigned long int)rem);
      rv = (signed int)return_value_read$44;
      if(rv == -1)
      {
        signed int *return_value___errno_location$45;
        return_value___errno_location$45=__errno_location();
        if(*return_value___errno_location$45 == 11)
          return -1;

        goto error_receiv_data;
      }

      if(rv == 0)
        goto error_receiv_data;

      st->iolen = st->iolen + rv;
      if(!(rv >= rem))
        return -1;

    }

    close(st->sock);
    st->state = (signed short int)8;
    return 0;

  error_receiv_data:
    ;
    if(rv == -1)
    {
      return_value___errno_location$46=__errno_location();
      st->s_errno = *return_value___errno_location$46;
    }

    char p_query_sm$$1$$1$$8$$_debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous$6 *tmp_if_expr$47;
      if(!(run_ipv4 == 0))
        tmp_if_expr$47 = (union anonymous$6 *)&st->a.sin4.sin_addr;

      else
        tmp_if_expr$47 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
      return_value_pdnsd_a2str$48=pdnsd_a2str(tmp_if_expr$47, p_query_sm$$1$$1$$8$$_debugsockabuf, 46);
      char *tmp_if_expr$52;
      if(rv == -1)
      {
        return_value___errno_location$49=__errno_location();
        return_value_strerror$50=strerror(*return_value___errno_location$49);
        tmp_if_expr$52 = return_value_strerror$50;
      }

      else
      {
        if(rv == 0)
          tmp_if_expr$51 = st->iolen == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$51 = (_Bool)0;
        tmp_if_expr$52 = tmp_if_expr$51 ? "no data" : "incomplete data";
      }
      debug_msg(0, "Error while receiving data from %s: %s\n", return_value_pdnsd_a2str$48, tmp_if_expr$52);
    }

    close(st->sock);

  tcp_failed:
    ;
    if(!((signed int)st->qm == 14))
      break;

    switch_to_udp(st);
    char p_query_sm$$1$$1$$9$$1$$_debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous$6 *tmp_if_expr$53;
      if(!(run_ipv4 == 0))
        tmp_if_expr$53 = (union anonymous$6 *)&st->a.sin4.sin_addr;

      else
        tmp_if_expr$53 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
      return_value_pdnsd_a2str$54=pdnsd_a2str(tmp_if_expr$53, p_query_sm$$1$$1$$9$$1$$_debugsockabuf, 46);
      debug_msg(0, "TCP query to %s failed. Trying to use UDP.\n", return_value_pdnsd_a2str$54);
    }

  }
  goto __CPROVER_DUMP_L106;

__CPROVER_DUMP_L74:
  ;
  st->sock=socket(run_ipv4 != 0 ? 2 : 10, 2, 17);
  signed int *return_value___errno_location$55;
  char *return_value_strerror$56;
  signed int return_value_connect$72;
  signed int *return_value___errno_location$67;
  signed int *return_value___errno_location$58;
  signed int *return_value___errno_location$64;
  _Bool tmp_if_expr$66;
  signed int *return_value___errno_location$65;
  char abuf[46l];
  const char *return_value_pdnsd_a2str$60;
  signed int *return_value___errno_location$61;
  char *return_value_strerror$62;
  const char *return_value_inet_ntop$63;
  const char *return_value_pdnsd_a2str$69;
  signed int *return_value___errno_location$70;
  char *return_value_strerror$71;
  const char *return_value_pdnsd_a2str$75;
  signed int *return_value___errno_location$76;
  char *return_value_strerror$77;
  const char *return_value_pdnsd_a2str$82;
  signed int *return_value___errno_location$83;
  char *return_value_strerror$84;
  unsigned short int return_value_ntohs$86;
  if(st->sock == -1)
  {
    if(!(debug_p == 0))
    {
      return_value___errno_location$55=__errno_location();
      return_value_strerror$56=strerror(*return_value___errno_location$55);
      debug_msg(0, "Could not open socket: %s\n", return_value_strerror$56);
    }

  }

  else
  {
    signed int return_value_bind_socket$57;
    return_value_bind_socket$57=bind_socket(st->sock);
    if(return_value_bind_socket$57 == 0)
      close(st->sock);

    else
    {
      do
      {

      retry_udp_connect:
        ;
        return_value_connect$72=connect(st->sock, (struct sockaddr *)&st->a, (unsigned int)(run_ipv4 != 0 ? sizeof(struct sockaddr_in) /*16ul*/  : sizeof(struct sockaddr_in6) /*28ul*/ ));
        if(!(return_value_connect$72 == -1))
          goto __CPROVER_DUMP_L90;

        return_value___errno_location$67=__errno_location();
        if(*return_value___errno_location$67 == 111)
        {
          return_value___errno_location$58=__errno_location();
          st->s_errno = *return_value___errno_location$58;
          goto __CPROVER_DUMP_L86;
        }

        if(!(run_ipv4 == 0))
          goto __CPROVER_DUMP_L86;

        return_value___errno_location$64=__errno_location();
        if(*return_value___errno_location$64 == 101)
          tmp_if_expr$66 = (_Bool)1;

        else
        {
          return_value___errno_location$65=__errno_location();
          tmp_if_expr$66 = *return_value___errno_location$65 == 100 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$66)
          break;

        if(st->a4fallback.s_addr == 0u)
          break;

        char p_query_sm$$1$$1$$12$$1$$1$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$59;
          if(!(run_ipv4 == 0))
            tmp_if_expr$59 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$59 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$60=pdnsd_a2str(tmp_if_expr$59, p_query_sm$$1$$1$$12$$1$$1$$_debugsockabuf, 46);
          return_value___errno_location$61=__errno_location();
          return_value_strerror$62=strerror(*return_value___errno_location$61);
          return_value_inet_ntop$63=inet_ntop(2, (const void *)&st->a4fallback, abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
          debug_msg(0, "Connecting to %s failed: %s, retrying with IPv4 address %s\n", return_value_pdnsd_a2str$60, return_value_strerror$62, return_value_inet_ntop$63);
        }

        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)3] = (&st->a4fallback)->s_addr;
        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)2]=htonl((unsigned int)0xffff);
        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0] = (unsigned int)0;
        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)1] = ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0];
        st->a4fallback.s_addr = (unsigned int)0x00000000;
      }
      while((_Bool)1);

    __CPROVER_DUMP_L86:
      ;
      char p_query_sm$$1$$1$$12$$2$$_debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous$6 *tmp_if_expr$68;
        if(!(run_ipv4 == 0))
          tmp_if_expr$68 = (union anonymous$6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr$68 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str$69=pdnsd_a2str(tmp_if_expr$68, p_query_sm$$1$$1$$12$$2$$_debugsockabuf, 46);
        return_value___errno_location$70=__errno_location();
        return_value_strerror$71=strerror(*return_value___errno_location$70);
        debug_msg(0, "Error while connecting to %s: %s\n", return_value_pdnsd_a2str$69, return_value_strerror$71);
      }

      close(st->sock);
      goto __CPROVER_DUMP_L106;

    __CPROVER_DUMP_L90:
      ;
      signed long int return_value_send$78;
      return_value_send$78=send(st->sock, (const void *)&st->msg->hdr, (unsigned long int)st->transl, 0);
      if(return_value_send$78 == -1l)
      {
        signed int *return_value___errno_location$73;
        return_value___errno_location$73=__errno_location();
        st->s_errno = *return_value___errno_location$73;
        char p_query_sm$$1$$1$$13$$1$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$74;
          if(!(run_ipv4 == 0))
            tmp_if_expr$74 = (union anonymous$6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr$74 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$75=pdnsd_a2str(tmp_if_expr$74, p_query_sm$$1$$1$$13$$1$$_debugsockabuf, 46);
          return_value___errno_location$76=__errno_location();
          return_value_strerror$77=strerror(*return_value___errno_location$76);
          debug_msg(0, "Error while sending data to %s: %s\n", return_value_pdnsd_a2str$75, return_value_strerror$77);
        }

        close(st->sock);
        goto __CPROVER_DUMP_L106;
      }

      st->state = (signed short int)5;
      return -1;

    __CPROVER_DUMP_L95:
      ;
      signed int udpbufsize = st->edns_query != 0 ? global.udpbufsize : 512;
      void *return_value_realloc_or_cleanup$79;
      return_value_realloc_or_cleanup$79=realloc_or_cleanup((void *)st->recvbuf, (unsigned long int)udpbufsize);
      st->recvbuf = (struct anonymous$29 *)return_value_realloc_or_cleanup$79;
      if(st->recvbuf == ((struct anonymous$29 *)NULL))
      {
        close(st->sock);
        if(!(debug_p == 0))
          debug_msg(0, "Out of memory in query.\n");

        retval = 0xffff;
      }

      else
      {
        signed long int return_value_recv$85;
        return_value_recv$85=recv(st->sock, (void *)st->recvbuf, (unsigned long int)udpbufsize, 0);
        rv = (signed int)return_value_recv$85;
        if(rv == -1)
        {
          signed int *return_value___errno_location$80;
          return_value___errno_location$80=__errno_location();
          st->s_errno = *return_value___errno_location$80;
          char p_query_sm$$1$$1$$14$$2$$1$$_debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous$6 *tmp_if_expr$81;
            if(!(run_ipv4 == 0))
              tmp_if_expr$81 = (union anonymous$6 *)&st->a.sin4.sin_addr;

            else
              tmp_if_expr$81 = (union anonymous$6 *)&st->a.sin6.sin6_addr;
            return_value_pdnsd_a2str$82=pdnsd_a2str(tmp_if_expr$81, p_query_sm$$1$$1$$14$$2$$1$$_debugsockabuf, 46);
            return_value___errno_location$83=__errno_location();
            return_value_strerror$84=strerror(*return_value___errno_location$83);
            debug_msg(0, "Error while receiving data from %s: %s\n", return_value_pdnsd_a2str$82, return_value_strerror$84);
          }

          close(st->sock);
          goto __CPROVER_DUMP_L106;
        }

        st->recvl = (unsigned short int)rv;
        _Bool tmp_if_expr$87;
        if(!((unsigned long int)st->recvl >= sizeof(struct anonymous$29) /*12ul*/ ))
          tmp_if_expr$87 = (_Bool)1;

        else
        {
          return_value_ntohs$86=ntohs(st->recvbuf->id);
          tmp_if_expr$87 = return_value_ntohs$86 != st->myrid ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$87)
        {
          if(!(debug_p == 0))
            debug_msg(0, "Bad answer received. Ignoring it.\n");

          st->state = (signed short int)5;
          return -1;
        }

        close(st->sock);
        st->state = (signed short int)8;
        return 0;
      }
    }
  }

__CPROVER_DUMP_L106:
  ;
  st->state = (signed short int)8;
  return retval;
}

// p_recursive_query
// file dns_query.c line 2070
static signed int p_recursive_query(struct anonymous$4 *q, const unsigned char *name, signed int thint, struct anonymous$0 **entp, signed int *nocache, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, unsigned char *c_soa)
{
  struct anonymous$0 *ent;
  struct anonymous$0 *entsave = (struct anonymous$0 *)(void *)0;
  signed int i;
  signed int j;
  signed int k;
  signed int rv = 2;
  signed int qualval = 0;
  struct anonymous$5 *qse = (struct anonymous$5 *)(void *)0;
  struct _dynamic_list_head *ns = (struct _dynamic_list_head *)(void *)0;
  struct _dynamic_list_head *nssave = (struct _dynamic_list_head *)(void *)0;
  struct anonymous$4 *serv = (struct anonymous$4 *)(void *)0;
  struct anonymous$4 *servsave = (struct anonymous$4 *)(void *)0;
  signed long int ts0;
  ts0=time((signed long int *)(void *)0);
  signed long int global_timeout = global.timeout;
  signed int dc = 0;
  signed int mc = 0;
  signed int nq;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link2((struct anonymous$3 *)q);
  nq = (signed int)return_value_da_nel$1;
  signed int parqueries = global.par_queries;
  j = 0;
  const char *return_value_pdnsd_a2str$3;
  signed int p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$authok;
  const char *return_value_pdnsd_a2str$5;
  const char *return_value_pdnsd_a2str$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$19;
  const char *return_value_pdnsd_a2str$15;
  const char *return_value_pdnsd_a2str$17;
  signed long int return_value_time$21;
  signed int authok;
  const char *return_value_pdnsd_a2str$24;
  const char *return_value_pdnsd_a2str$28;
  for( ; !(j >= nq); j = j + parqueries)
  {
    mc = j + parqueries;
    if(!(nq >= mc))
      mc = nq;

    i = dc;
    for( ; !(i >= mc); i = i + 1)
    {
      struct anonymous$5 *p_recursive_query$$1$$1$$1$$1$$1$$1$$qs = &q->elem[(signed long int)i];
      if(i >= j)
      {
        char p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$1$$_debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous$6 *tmp_if_expr$2;
          if(!(run_ipv4 == 0))
            tmp_if_expr$2 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->a.sin4.sin_addr;

          else
            tmp_if_expr$2 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->a.sin6.sin6_addr;
          return_value_pdnsd_a2str$3=pdnsd_a2str(tmp_if_expr$2, p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$1$$_debugsockabuf, 46);
          debug_msg(0, "Sending query to %s\n", return_value_pdnsd_a2str$3);
        }

        do
        {

        retryquery:
          ;
          rv=p_exec_query(&ent, name, thint, p_recursive_query$$1$$1$$1$$1$$1$$1$$qs, &ns, c_soa);
          if(!(rv == 0))
            goto __CPROVER_DUMP_L26;

          char p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$1$$_debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous$6 *tmp_if_expr$4;
            if(!(run_ipv4 == 0))
              tmp_if_expr$4 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->a.sin4.sin_addr;

            else
              tmp_if_expr$4 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->a.sin6.sin6_addr;
            return_value_pdnsd_a2str$5=pdnsd_a2str(tmp_if_expr$4, p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$1$$_debugsockabuf, 46);
            debug_msg(0, "Query to %s succeeded.\n", return_value_pdnsd_a2str$5);
          }

          p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$authok=auth_ok(q, name, thint, ent, hops, qslist, qhlist, p_recursive_query$$1$$1$$1$$1$$1$$1$$qs, ns, &serv);
          if(!(p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$authok == 0))
          {
            if(p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$authok >= 0)
            {
              if(p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->failed == 0)
              {
                _Bool tmp_if_expr$6;
                if((signed int)p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->qm == 15)
                  tmp_if_expr$6 = p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->tc != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$6 = (_Bool)0;
                if(!tmp_if_expr$6)
                {
                  qse = p_recursive_query$$1$$1$$1$$1$$1$$1$$qs;
                  mc = i;
                  goto done;
                }

              }

            }

            else
            {
              mc = i;
              goto free_ent_return_failed;
            }
          }

          signed int p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$3$$qval = p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$authok * 8 + (3 - (signed int)p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->failed) * 2 + (signed int)!(p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->tc != 0) * 1;
          if(!(entsave == ((struct anonymous$0 *)NULL)) && !(qualval >= p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$3$$qval))
          {
            free_cent(entsave);
            free((void *)entsave);
            entsave = (struct anonymous$0 *)(void *)0;
            del_qserv(servsave);
            free((void *)nssave);
          }

          if(entsave == ((struct anonymous$0 *)NULL))
          {
            entsave = ent;
            servsave = serv;
            unsigned int return_value_da_nel$7;
            return_value_da_nel$7=da_nel$link2((struct anonymous$3 *)serv);
            if(return_value_da_nel$7 >= 1u)
              nssave = ns;

            else
            {
              nssave = (struct _dynamic_list_head *)(void *)0;
              free((void *)ns);
            }
            qualval = p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$3$$qval;
            qse = p_recursive_query$$1$$1$$1$$1$$1$$1$$qs;
          }

          else
          {
            free_cent(ent);
            free((void *)ent);
            del_qserv(serv);
            free((void *)ns);
          }
          serv = (struct anonymous$4 *)(void *)0;
          ns = (struct _dynamic_list_head *)(void *)0;
          if(!((signed int)p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->qm == 15))
            break;

          if(p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->tc == 0)
            break;

          switch_to_tcp(p_recursive_query$$1$$1$$1$$1$$1$$1$$qs);
          char p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$4$$1$$_debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous$6 *tmp_if_expr$8;
            if(!(run_ipv4 == 0))
              tmp_if_expr$8 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->a.sin4.sin_addr;

            else
              tmp_if_expr$8 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->a.sin6.sin6_addr;
            return_value_pdnsd_a2str$9=pdnsd_a2str(tmp_if_expr$8, p_recursive_query$$1$$1$$1$$1$$1$$1$$1$$2$$4$$1$$_debugsockabuf, 46);
            debug_msg(0, "Reply from %s was truncated. Trying again using TCP.\n", return_value_pdnsd_a2str$9);
          }

        }
        while((_Bool)1);
        goto __CPROVER_DUMP_L27;

      __CPROVER_DUMP_L26:
        ;
        if(rv == 3 || rv == 0xffff)
        {
          mc = i;
          goto done;
        }

      }


    __CPROVER_DUMP_L27:
      ;
      if((signed int)p_recursive_query$$1$$1$$1$$1$$1$$1$$qs->state == 8)
      {
        if(i == dc)
          dc = dc + 1;

      }

    }
    if(!(dc >= mc))
    {
      signed long int ts;
      signed long int maxto;
      signed long int now;
      signed int pc;
      signed int nevents;
      signed int ic;
      const signed long int ic$array_size0 = (signed long int)(mc - dc);
      struct pollfd polls[ic$array_size0];
      ts=time((signed long int *)(void *)0);
      do
      {
        maxto = (signed long int)0;
        pc = 0;
        rv = 2;
        i = dc;
        for( ; !(i >= mc); i = i + 1)
        {
          struct anonymous$5 *p_recursive_query$$1$$1$$1$$1$$2$$1$$1$$1$$qs = &q->elem[(signed long int)i];
          if(!((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$1$$1$$qs->state == 8))
          {
            if(i >= j)
            {
              if(!(maxto >= p_recursive_query$$1$$1$$1$$1$$2$$1$$1$$1$$qs->timeout))
                maxto = p_recursive_query$$1$$1$$1$$1$$2$$1$$1$$1$$qs->timeout;

            }

            polls[(signed long int)pc].fd = p_recursive_query$$1$$1$$1$$1$$2$$1$$1$$1$$qs->sock;
            switch((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$1$$1$$qs->state)
            {
              case 3:

              case 5:
              {
                polls[(signed long int)pc].events = (signed short int)0x001;
                break;
              }
              case 2:
              {
                polls[(signed long int)pc].events = (signed short int)0x004;
                break;
              }
              default:
                polls[(signed long int)pc].events = (signed short int)0;
            }
            pc = pc + 1;
          }

        }
        if(pc == 0)
        {
          dc = mc;
          break;
        }

        now=time((signed long int *)(void *)0);
        maxto = maxto - (now - ts);
        if(mc == nq)
        {
          i = j;
          for( ; !(i >= mc); i = i + 1)
          {
            struct anonymous$5 *p_recursive_query$$1$$1$$1$$1$$2$$1$$3$$1$$1$$qs = &q->elem[(signed long int)i];
            if((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$3$$1$$1$$qs->qm == 14)
            {
              _Bool tmp_if_expr$11;
              if((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$3$$1$$1$$qs->state == 2)
                tmp_if_expr$11 = (_Bool)1;

              else
              {
                if((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$3$$1$$1$$qs->state == 3)
                  tmp_if_expr$10 = p_recursive_query$$1$$1$$1$$1$$2$$1$$3$$1$$1$$qs->iolen == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$10 = (_Bool)0;
                tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$11)
                goto skip_globto;

            }

          }
          signed long int globto = global_timeout - (now - ts0);
          if(!(maxto >= globto))
            maxto = globto;

        }


      skip_globto:
        ;
        nevents=poll(polls, (unsigned long int)pc, (signed int)(maxto > (signed long int)0 ? maxto * (signed long int)1000 : (signed long int)0));
        if(!(nevents >= 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          char *return_value_strerror$13;
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log_message(4, "poll/select failed: %s", return_value_strerror$13);
          goto done;
        }

        if(nevents == 0)
        {
          i = j;
          for( ; !(i >= mc); i = i + 1)
          {
            struct anonymous$5 *p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs = &q->elem[(signed long int)i];
            if(!((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->state == 8))
            {
              if(!(p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->needs_testing == 0))
                p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->needs_testing = (char)2;

            }

            if((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->qm == 14)
            {
              _Bool tmp_if_expr$20;
              if((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->state == 2)
                tmp_if_expr$20 = (_Bool)1;

              else
              {
                if((signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->state == 3)
                  tmp_if_expr$19 = p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->iolen == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$19 = (_Bool)0;
                tmp_if_expr$20 = tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$20)
              {
                close(p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->sock);
                switch_to_udp(p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs);
                char p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$1$$1$$_debugsockabuf[46l];
                if(!(debug_p == 0))
                {
                  union anonymous$6 *tmp_if_expr$14;
                  if(!(run_ipv4 == 0))
                    tmp_if_expr$14 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->a.sin4.sin_addr;

                  else
                    tmp_if_expr$14 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->a.sin6.sin6_addr;
                  return_value_pdnsd_a2str$15=pdnsd_a2str(tmp_if_expr$14, p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$1$$1$$_debugsockabuf, 46);
                  debug_msg(0, "TCP connection to %s timed out. Trying to use UDP.\n", return_value_pdnsd_a2str$15);
                }

                rv=p_exec_query(&ent, name, thint, p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs, &ns, c_soa);
                if(rv == 0)
                {
                  signed int p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$1$$2$$authok;
                  char _debugsockabuf[46l];
                  if(!(debug_p == 0))
                  {
                    union anonymous$6 *tmp_if_expr$16;
                    if(!(run_ipv4 == 0))
                      tmp_if_expr$16 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->a.sin4.sin_addr;

                    else
                      tmp_if_expr$16 = (union anonymous$6 *)&p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->a.sin6.sin6_addr;
                    return_value_pdnsd_a2str$17=pdnsd_a2str(tmp_if_expr$16, _debugsockabuf, 46);
                    debug_msg(0, "Query to %s succeeded.\n", return_value_pdnsd_a2str$17);
                  }

                  p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$1$$2$$authok=auth_ok(q, name, thint, ent, hops, qslist, qhlist, p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs, ns, &serv);
                  if(!(p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$1$$2$$authok == 0))
                  {
                    if(p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$1$$2$$authok >= 0)
                    {
                      if(p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->failed == 0)
                      {
                        qse = p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs;
                        goto done;
                      }

                    }

                    else
                      goto free_ent_return_failed;
                  }

                  signed int qval = p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$1$$2$$authok * 8 + (3 - (signed int)p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->failed) * 2 + (signed int)!(p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs->tc != 0) * 1;
                  if(!(entsave == ((struct anonymous$0 *)NULL)) && !(qualval >= qval))
                  {
                    free_cent(entsave);
                    free((void *)entsave);
                    entsave = (struct anonymous$0 *)(void *)0;
                    del_qserv(servsave);
                    free((void *)nssave);
                  }

                  if(entsave == ((struct anonymous$0 *)NULL))
                  {
                    entsave = ent;
                    servsave = serv;
                    unsigned int return_value_da_nel$18;
                    return_value_da_nel$18=da_nel$link2((struct anonymous$3 *)serv);
                    if(return_value_da_nel$18 >= 1u)
                      nssave = ns;

                    else
                    {
                      nssave = (struct _dynamic_list_head *)(void *)0;
                      free((void *)ns);
                    }
                    qualval = qval;
                    qse = p_recursive_query$$1$$1$$1$$1$$2$$1$$5$$1$$1$$qs;
                  }

                  else
                  {
                    free_cent(ent);
                    free((void *)ent);
                    del_qserv(serv);
                    free((void *)ns);
                  }
                  serv = (struct anonymous$4 *)(void *)0;
                  ns = (struct _dynamic_list_head *)(void *)0;
                }

                else
                  if(rv == 3 || rv == 0xffff)
                    goto done;

                nevents = nevents + 1;
              }

            }

          }
          if(mc == nq)
          {
            if(!(nevents == 0))
            {
              return_value_time$21=time((signed long int *)(void *)0);
              if(!(return_value_time$21 + -ts0 >= global_timeout))
                continue;

            }

          }

          break;
        }

        ic = 0;
        i = dc;
        for( ; !(i >= mc); i = i + 1)
        {
          struct anonymous$5 *qs = &q->elem[(signed long int)i];
          if(!((signed int)qs->state == 8))
          {
            signed int srv_event = 0;
            while((_Bool)1)
            {
              if(ic >= pc)
              {
                log_message(3, "%s:%d: %s", (const void *)"dns_query.c", 2364, (const void *)"file descriptor not found in poll() array");
                pdnsd_exit();
              }

              signed int tmp_post$22 = ic;
              ic = ic + 1;
              k = tmp_post$22;
              if(polls[(signed long int)k].fd == qs->sock)
                break;

            }
            switch((signed int)qs->state)
            {
              case 3:

              case 5:
              {
                srv_event = (signed int)polls[(signed long int)k].revents & (0x001 | 0x008 | 0x010 | 0x020);
                break;
              }
              case 2:
                srv_event = (signed int)polls[(signed long int)k].revents & (0x004 | 0x008 | 0x010 | 0x020);
            }
            if(!(srv_event == 0))
            {
              nevents = nevents - 1;
              do
              {

              retryquery2:
                ;
                rv=p_exec_query(&ent, name, thint, qs, &ns, c_soa);
                if(!(rv == 0))
                  goto __CPROVER_DUMP_L104;

                char p_recursive_query$$1$$1$$1$$1$$2$$1$$6$$1$$1$$3$$1$$1$$_debugsockabuf[46l];
                if(!(debug_p == 0))
                {
                  union anonymous$6 *tmp_if_expr$23;
                  if(!(run_ipv4 == 0))
                    tmp_if_expr$23 = (union anonymous$6 *)&qs->a.sin4.sin_addr;

                  else
                    tmp_if_expr$23 = (union anonymous$6 *)&qs->a.sin6.sin6_addr;
                  return_value_pdnsd_a2str$24=pdnsd_a2str(tmp_if_expr$23, p_recursive_query$$1$$1$$1$$1$$2$$1$$6$$1$$1$$3$$1$$1$$_debugsockabuf, 46);
                  debug_msg(0, "Query to %s succeeded.\n", return_value_pdnsd_a2str$24);
                }

                authok=auth_ok(q, name, thint, ent, hops, qslist, qhlist, qs, ns, &serv);
                if(!(authok == 0))
                {
                  if(authok >= 0)
                  {
                    if(qs->failed == 0)
                    {
                      _Bool tmp_if_expr$25;
                      if((signed int)qs->qm == 15)
                        tmp_if_expr$25 = qs->tc != 0 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr$25 = (_Bool)0;
                      if(!tmp_if_expr$25)
                      {
                        qse = qs;
                        goto done;
                      }

                    }

                  }

                  else
                    goto free_ent_return_failed;
                }

                signed int p_recursive_query$$1$$1$$1$$1$$2$$1$$6$$1$$1$$3$$1$$3$$qval = authok * 8 + (3 - (signed int)qs->failed) * 2 + (signed int)!(qs->tc != 0) * 1;
                if(!(entsave == ((struct anonymous$0 *)NULL)) && !(qualval >= p_recursive_query$$1$$1$$1$$1$$2$$1$$6$$1$$1$$3$$1$$3$$qval))
                {
                  free_cent(entsave);
                  free((void *)entsave);
                  entsave = (struct anonymous$0 *)(void *)0;
                  del_qserv(servsave);
                  free((void *)nssave);
                }

                if(entsave == ((struct anonymous$0 *)NULL))
                {
                  entsave = ent;
                  servsave = serv;
                  unsigned int return_value_da_nel$26;
                  return_value_da_nel$26=da_nel$link2((struct anonymous$3 *)serv);
                  if(return_value_da_nel$26 >= 1u)
                    nssave = ns;

                  else
                  {
                    nssave = (struct _dynamic_list_head *)(void *)0;
                    free((void *)ns);
                  }
                  qualval = p_recursive_query$$1$$1$$1$$1$$2$$1$$6$$1$$1$$3$$1$$3$$qval;
                  qse = qs;
                }

                else
                {
                  free_cent(ent);
                  free((void *)ent);
                  del_qserv(serv);
                  free((void *)ns);
                }
                serv = (struct anonymous$4 *)(void *)0;
                ns = (struct _dynamic_list_head *)(void *)0;
                if(!((signed int)qs->qm == 15))
                  break;

                if(qs->tc == 0)
                  break;

                switch_to_tcp(qs);
                char p_recursive_query$$1$$1$$1$$1$$2$$1$$6$$1$$1$$3$$1$$4$$1$$_debugsockabuf[46l];
                if(!(debug_p == 0))
                {
                  union anonymous$6 *tmp_if_expr$27;
                  if(!(run_ipv4 == 0))
                    tmp_if_expr$27 = (union anonymous$6 *)&qs->a.sin4.sin_addr;

                  else
                    tmp_if_expr$27 = (union anonymous$6 *)&qs->a.sin6.sin6_addr;
                  return_value_pdnsd_a2str$28=pdnsd_a2str(tmp_if_expr$27, p_recursive_query$$1$$1$$1$$1$$2$$1$$6$$1$$1$$3$$1$$4$$1$$_debugsockabuf, 46);
                  debug_msg(0, "Reply from %s was truncated. Trying again using TCP.\n", return_value_pdnsd_a2str$28);
                }

              }
              while((_Bool)1);
              goto __CPROVER_DUMP_L105;

            __CPROVER_DUMP_L104:
              ;
              if(rv == 3 || rv == 0xffff)
                goto done;

            }

          }


        __CPROVER_DUMP_L105:
          ;
          if((signed int)qs->state == 8)
          {
            if(i == dc)
              dc = dc + 1;

          }

        }
        if(nevents >= 1)
        {
          poll_errs = poll_errs + 1ul;
          if(!(poll_errs >= 11ul))
            log_message(3, "%d unhandled poll/select event(s) in p_recursive_query() at %s, line %d.", nevents, (const void *)"dns_query.c", 2426);

          rv = 2;
          goto done;
        }

      }
      while(!(dc >= mc));
    }

  }
  goto cancel_queries;

free_ent_return_failed:
  ;
  free_cent(ent);
  free((void *)ent);
  rv = 0xffff;

done:
  ;
  if(!(entsave == ((struct anonymous$0 *)NULL)))
  {
    free_cent(entsave);
    free((void *)entsave);
    entsave = (struct anonymous$0 *)(void *)0;
    del_qserv(servsave);
    free((void *)nssave);
  }


cancel_queries:
  ;
  i = dc;
  for( ; !(i >= mc); i = i + 1)
    p_cancel_query(&q->elem[(signed long int)i]);
  signed int n = 0;
  i = 0;
  for( ; !(i >= mc); i = i + 1)
    if((signed int)q->elem[(signed long int)i].needs_testing >= 2)
      n = n + 1;

  if(n >= 1)
  {
    const signed long int n$array_size0 = (signed long int)n;
    union anonymous$6 addrs[n$array_size0];
    k = 0;
    i = 0;
    for( ; !(i >= mc); i = i + 1)
    {
      struct anonymous$5 *p_recursive_query$$1$$1$$4$$2$$1$$1$$qs = &q->elem[(signed long int)i];
      if((signed int)p_recursive_query$$1$$1$$4$$2$$1$$1$$qs->needs_testing >= 2)
      {
        signed int tmp_post$29 = k;
        k = k + 1;
        union anonymous$6 *tmp_if_expr$30;
        if(!(run_ipv4 == 0))
          tmp_if_expr$30 = (union anonymous$6 *)&p_recursive_query$$1$$1$$4$$2$$1$$1$$qs->a.sin4.sin_addr;

        else
          tmp_if_expr$30 = (union anonymous$6 *)&p_recursive_query$$1$$1$$4$$2$$1$$1$$qs->a.sin6.sin6_addr;
        addrs[(signed long int)tmp_post$29] = *tmp_if_expr$30;
      }

    }
    sched_server_test(addrs, n, -1);
  }

  const char *return_value_pdnsd_a2str$32;
  const char *return_value_get_ename$35;
  if(!(entsave == ((struct anonymous$0 *)NULL)))
  {
    char p_recursive_query$$1$$2$$1$$_debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous$6 *tmp_if_expr$31;
      if(!(run_ipv4 == 0))
        tmp_if_expr$31 = (union anonymous$6 *)&qse->a.sin4.sin_addr;

      else
        tmp_if_expr$31 = (union anonymous$6 *)&qse->a.sin6.sin6_addr;
      return_value_pdnsd_a2str$32=pdnsd_a2str(tmp_if_expr$31, p_recursive_query$$1$$2$$1$$_debugsockabuf, 46);
      debug_msg(0, "Using %s reply from %s.\n", !((qualval & 6) != 0) ? "reportedly failed" : (!((qualval & 2) != 0) ? "inconsistent" : (!((qualval & 1) != 0) ? "truncated" : (!((qualval & 8) != 0) ? "non-authoritative" : "good"))), return_value_pdnsd_a2str$32);
    }

    ent = entsave;
    serv = servsave;
    ns = nssave;
    if(!(qualval >= 2))
    {
      if((1 & (signed int)ent->flags) == 0)
      {
        signed int jlim;
        signed int tmp_if_expr$33;
        if(!((1 & (signed int)ent->flags) == 0))
          tmp_if_expr$33 = 0;

        else
          tmp_if_expr$33 = ent->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        jlim = tmp_if_expr$33;
        j = 0;
        for( ; !(j >= jlim); j = j + 1)
        {
          struct anonymous *rrs;
          struct anonymous *tmp_if_expr$34;
          if(!(j >= 8))
            tmp_if_expr$34 = ent->$anon0.rr.rrmu[(signed long int)j];

          else
            tmp_if_expr$34 = ent->$anon0.rr.rrext[(signed long int)(j - 8)];
          rrs = tmp_if_expr$34;
          if(!(rrs == ((struct anonymous *)NULL)))
            rrs->flags = rrs->flags | (unsigned short int)8;

        }
      }

      else
        ent->flags = ent->flags | (unsigned short int)8;
    }

    rv = 0;
  }

  else
    if(!(rv == 0))
    {
      if(rv == 0xffff)
      {
        if(!(debug_p == 0))
          debug_msg(0, "Unrecoverable error encountered while processing query.\n");

        rv = 2;
      }

      if(!(debug_p == 0))
      {
        return_value_get_ename$35=get_ename(rv);
        debug_msg(0, "No query succeeded. Returning error code \"%s\"\n", return_value_get_ename$35);
      }

      goto clean_up_return;
    }

  if(!(nocache == ((signed int *)NULL)))
    *nocache = (signed int)qse->nocache;

  unsigned int return_value_da_nel$40;
  return_value_da_nel$40=da_nel$link2((struct anonymous$3 *)serv);
  if(return_value_da_nel$40 >= 1u)
  {
    struct qstatnode_s qsn = { .qa=q, .next=qslist };
    unsigned char save_ns = ent->c_ns;
    unsigned char save_soa = ent->c_soa;
    free_cent(ent);
    free((void *)ent);
    signed long int return_value_time$36;
    return_value_time$36=time((signed long int *)(void *)0);
    rv=p_dns_cached_resolve(serv, name, thint, &ent, hops - 1, &qsn, qhlist, return_value_time$36, c_soa);
    if(rv == 0)
    {
      if(!((signed int)save_ns == 0xff))
      {
        _Bool tmp_if_expr$37;
        if((signed int)ent->c_ns == 0xff)
          tmp_if_expr$37 = (_Bool)1;

        else
          tmp_if_expr$37 = (signed int)ent->c_ns < (signed int)save_ns ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$37)
          ent->c_ns = save_ns;

      }

      if(!((signed int)save_soa == 0xff))
      {
        _Bool tmp_if_expr$38;
        if((signed int)ent->c_soa == 0xff)
          tmp_if_expr$38 = (_Bool)1;

        else
          tmp_if_expr$38 = (signed int)ent->c_soa < (signed int)save_soa ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$38)
          ent->c_soa = save_soa;

      }

    }

    else
      if(rv == 3 && !(c_soa == ((unsigned char *)NULL)))
      {
        if(!((signed int)save_soa == 0xff))
        {
          _Bool tmp_if_expr$39;
          if((signed int)*c_soa == 0xff)
            tmp_if_expr$39 = (_Bool)1;

          else
            tmp_if_expr$39 = (signed int)*c_soa < (signed int)save_soa ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$39)
            *c_soa = save_soa;

        }

      }

  }


clean_up_return:
  ;
  del_qserv(serv);
  free((void *)ns);
  if(rv == 0)
    *entp = ent;

  return rv;
}

// parse_ip
// file conf-parser.c line 1841
static const char * parse_ip(const char *ipstr, union anonymous$6 *a)
{
  if(cmdlineipv == 0)
    cmdlineipv = (signed short int)-2;

  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(ipstr, "any");
  signed int return_value_str2pdnsd_a$2;
  signed int return_value_inet_pton$1;
  if(return_value_strcmp$3 == 0)
  {
    if(!(run_ipv4 == 0))
      a->ipv4.s_addr = (unsigned int)0x00000000;

    else
      a->ipv6 = in6addr_any;
  }

  else
  {
    return_value_str2pdnsd_a$2=str2pdnsd_a(ipstr, a);
    if(return_value_str2pdnsd_a$2 == 0)
    {
      if(!(run_ipv4 == 0))
      {
        return_value_inet_pton$1=inet_pton(10, ipstr, (void *)&a->ipv6);
        if(return_value_inet_pton$1 >= 1)
          return "You should set run_ipv4=off or use the command-line option -6 before specifying an IPv6 address";

      }

      return "bad IP address";
    }

  }
  return (const char *)(void *)0;
}

// parsestr2rhn
// file helpers.h line 54
const char * parsestr2rhn(const unsigned char *str, unsigned int len, unsigned char *rhn)
{
  unsigned int i;
  unsigned int j;
  if(len >= 1u)
  {
    if((signed int)*str == 46)
    {
      _Bool tmp_if_expr$1;
      if(len == 1u)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = !(str[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        rhn[(signed long int)0] = (unsigned char)0;
        return (const char *)(void *)0;
      }

    }

  }

  i = (unsigned int)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$2;
  do
  {
    unsigned int jlim = i + (unsigned int)63;
    if(jlim >= 255u)
      jlim = (unsigned int)(256 - 2);

    j = i;
    do
    {
      if(!(j >= len))
        tmp_if_expr$3 = str[(signed long int)j] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (signed int)str[(signed long int)j] != 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      if(j >= jlim)
        return "Domain name element too long";

      rhn[(signed long int)(j + (unsigned int)1)] = str[(signed long int)j];
      j = j + 1u;
    }
    while((_Bool)1);
    if(i >= j)
    {
      _Bool tmp_if_expr$5;
      if(!(j >= len))
        tmp_if_expr$5 = str[(signed long int)j] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        return "Empty name element in domain name";

      else
        break;
    }

    rhn[(signed long int)i] = (unsigned char)(j - i);
    i = j + (unsigned int)1;
    if(!(j >= len))
      tmp_if_expr$2 = str[(signed long int)j] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  rhn[(signed long int)i] = (unsigned char)0;
  if(i == 0u)
    return "Empty domain name not allowed";

  else
    return (const char *)(void *)0;
}

// pdnsd_a2str
// file helpers.h line 157
const char * pdnsd_a2str(union anonymous$6 *a, char *buf, signed int maxlen)
{
  const char *res;
  const char *tmp_if_expr$3;
  const char *return_value_inet_ntop$1;
  const char *return_value_inet_ntop$2;
  if(!(run_ipv4 == 0))
  {
    return_value_inet_ntop$1=inet_ntop(2, (const void *)&a->ipv4, buf, (unsigned int)maxlen);
    tmp_if_expr$3 = return_value_inet_ntop$1;
  }

  else
  {
    return_value_inet_ntop$2=inet_ntop(10, (const void *)&a->ipv6, buf, (unsigned int)maxlen);
    tmp_if_expr$3 = return_value_inet_ntop$2;
  }
  res = tmp_if_expr$3;
  if(res == ((const char *)NULL))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    log_message(3, "inet_ntop: %s", return_value_strerror$5);
    return "?.?.?.?";
  }

  return res;
}

// pdnsd_exit
// file pdnsd_assert.h line 38
void pdnsd_exit(void)
{
  pthread_kill(main_thrid, 15);
  pthread_exit((void *)0);
}

// ping
// file icmp.c line 514
signed int ping(union anonymous$6 *addr, signed int timeout, signed int rep)
{
  signed int return_value_ping4$1;
  _Bool tmp_statement_expression$4;
  unsigned int return_value_htonl$6;
  signed int return_value_ping6$3;
  if(run_ipv4 == 0 ? ping6_isocket == -1 : ping_isocket == -1)
    return -1;

  else
  {
    timeout = timeout / 10;
    if(!(run_ipv4 == 0))
    {
      return_value_ping4$1=ping4(addr->ipv4, timeout, rep);
      return return_value_ping4$1;
    }

    else
    {
      _Bool tmp_if_expr$8;
      if(!(ping_isocket == -1))
      {
        struct in6_addr *__a = (struct in6_addr *)&addr->ipv6;
        _Bool tmp_if_expr$5;
        if(__a->__in6_u.__u6_addr32[0l] == 0u)
          tmp_if_expr$5 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        _Bool tmp_if_expr$7;
        if(tmp_if_expr$5)
        {
          return_value_htonl$6=htonl((unsigned int)0xffff);
          tmp_if_expr$7 = __a->__in6_u.__u6_addr32[(signed long int)2] == return_value_htonl$6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        tmp_statement_expression$4 = tmp_if_expr$7;
        tmp_if_expr$8 = tmp_statement_expression$4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
      {
        struct in_addr v4;
        v4.s_addr = ((unsigned int *)&addr->ipv6)[(signed long int)3];
        signed int return_value_ping4$2;
        return_value_ping4$2=ping4(v4, timeout, rep);
        return return_value_ping4$2;
      }

      else
      {
        return_value_ping6$3=ping6(addr->ipv6, timeout, rep);
        return return_value_ping6$3;
      }
    }
    return -1;
  }
}

// ping4
// file icmp.c line 160
static signed int ping4(struct in_addr addr, signed int timeout, signed int rep)
{
  signed int i;
  signed int isock;
  struct icmp_filter f;
  unsigned short int id;
  unsigned short int return_value_get_rand16$1;
  return_value_get_rand16$1=get_rand16();
  id = (unsigned short int)return_value_get_rand16$1;
  isock = ping_isocket;
  f.data = 0xfffff7f6;
  signed int return_value_setsockopt$4;
  return_value_setsockopt$4=setsockopt(isock, 255, 1, (const void *)&f, (unsigned int)sizeof(struct icmp_filter) /*4ul*/ );
  signed int return_value_is_interrupted_servstat_thread$13;
  unsigned short int return_value_ntohs$20;
  unsigned short int return_value_ntohs$22;
  signed int return_value_icmp4_errcmp$18;
  if(return_value_setsockopt$4 == -1)
  {
    icmp_errs = icmp_errs + 1ul;
    if(!(icmp_errs >= 11ul))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_message(4, "icmp ping: setsockopt() failed: %s", return_value_strerror$3);
    }

    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= rep); i = i + 1)
    {
      struct sockaddr_in from;
      struct sockaddr_in to;
      struct icmphdr icmpd;
      unsigned long int sum;
      unsigned short int *ptr;
      signed long int tm;
      signed long int tpassed;
      signed int j;
      icmpd.type = (unsigned char)8;
      icmpd.code = (unsigned char)0;
      icmpd.checksum = (unsigned short int)0;
      icmpd.un.echo.id=htons((unsigned short int)id);
      icmpd.un.echo.sequence=htons((unsigned short int)i);
      ptr = (unsigned short int *)&icmpd;
      sum = (unsigned long int)0;
      j = 0;
      for( ; !(j >= 4); j = j + 1)
      {
        unsigned short int *tmp_post$5 = ptr;
        ptr = ptr + 1l;
        sum = sum + (unsigned long int)*tmp_post$5;
      }
      sum = (sum >> 16) + (sum & (unsigned long int)0xffff);
      sum = sum + (sum >> 16);
      icmpd.checksum = (unsigned short int)~sum;
      memset((void *)&to, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      to.sin_family = (unsigned short int)2;
      to.sin_port = (unsigned short int)0;
      to.sin_addr = addr;
      signed long int return_value_sendto$8;
      return_value_sendto$8=sendto(isock, (const void *)&icmpd, (unsigned long int)8, 0, (struct sockaddr *)&to, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_sendto$8 == -1l)
      {
        icmp_errs = icmp_errs + 1ul;
        if(!(icmp_errs >= 11ul))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          log_message(4, "icmp ping: sendto() failed: %s.", return_value_strerror$7);
        }

        return -1;
      }

      tm=time((signed long int *)(void *)0);
      tpassed = (signed long int)0;
      do
      {
        signed int psres;
        struct pollfd pfd;
        pfd.fd = isock;
        pfd.events = (signed short int)0x001;
        signed int return_value_is_interrupted_servstat_thread$9;
        return_value_is_interrupted_servstat_thread$9=is_interrupted_servstat_thread$link1();
        if(!(return_value_is_interrupted_servstat_thread$9 == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "server status thread interrupted.\n");

          return -1;
        }

        psres=poll(&pfd, (unsigned long int)1, (signed int)((signed long int)timeout > tpassed ? ((signed long int)timeout - tpassed) * (signed long int)1000 : (signed long int)0));
        if(!(psres >= 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          _Bool tmp_if_expr$14;
          if(*return_value___errno_location$12 == 4)
          {
            return_value_is_interrupted_servstat_thread$13=is_interrupted_servstat_thread$link1();
            tmp_if_expr$14 = return_value_is_interrupted_servstat_thread$13 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$14 = (_Bool)0;
          if(tmp_if_expr$14)
          {
            if(!(debug_p == 0))
              debug_msg(0, "poll/select interrupted in server status thread.\n");

          }

          else
          {
            icmp_errs = icmp_errs + 1ul;
            if(!(icmp_errs >= 11ul))
            {
              signed int *return_value___errno_location$10;
              return_value___errno_location$10=__errno_location();
              char *return_value_strerror$11;
              return_value_strerror$11=strerror(*return_value___errno_location$10);
              log_message(4, "poll/select failed: %s", return_value_strerror$11);
            }

          }
          return -1;
        }

        if(psres == 0)
          break;

        if(!((9 & (signed int)pfd.revents) == 0))
        {
          char buf[1024l];
          unsigned int sl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
          signed int len;
          signed long int return_value_recvfrom$24;
          return_value_recvfrom$24=recvfrom(isock, (void *)&buf, sizeof(char [1024l]) /*1024ul*/ , 0, (struct sockaddr *)&from, &sl);
          len = (signed int)return_value_recvfrom$24;
          if(!(len == -1))
          {
            if((unsigned long int)len >= 21ul)
            {
              struct iphdr iph;
              memcpy((void *)&iph, (const void *)buf, sizeof(struct iphdr) /*20ul*/ );
              if(len + -(4 * (signed int)iph.ihl) >= 8)
              {
                struct icmphdr icmpp;
                memcpy((void *)&icmpp, (const void *)((unsigned int *)buf + (signed long int)iph.ihl), sizeof(struct icmphdr) /*8ul*/ );
                _Bool tmp_if_expr$21;
                if(iph.saddr == addr.s_addr && (signed int)icmpp.type == 0)
                {
                  return_value_ntohs$20=ntohs(icmpp.un.echo.id);
                  tmp_if_expr$21 = return_value_ntohs$20 == id ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$21 = (_Bool)0;
                _Bool tmp_if_expr$23;
                if(tmp_if_expr$21)
                {
                  return_value_ntohs$22=ntohs(icmpp.un.echo.sequence);
                  tmp_if_expr$23 = (signed int)return_value_ntohs$22 <= i ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$23 = (_Bool)0;
                if(tmp_if_expr$23)
                {
                  unsigned short int return_value_ntohs$15;
                  return_value_ntohs$15=ntohs(icmpp.un.echo.sequence);
                  signed long int return_value_time$16;
                  return_value_time$16=time((signed long int *)(void *)0);
                  return (signed int)((signed long int)((i - (signed int)return_value_ntohs$15) * timeout) + (return_value_time$16 - tm));
                }

                else
                {
                  signed int return_value_icmp4_errcmp$17;
                  return_value_icmp4_errcmp$17=icmp4_errcmp((char *)&icmpd, 8, &to.sin_addr, buf, len, 3);
                  _Bool tmp_if_expr$19;
                  if(!(return_value_icmp4_errcmp$17 == 0))
                    tmp_if_expr$19 = (_Bool)1;

                  else
                  {
                    return_value_icmp4_errcmp$18=icmp4_errcmp((char *)&icmpd, 8, &to.sin_addr, buf, len, 11);
                    tmp_if_expr$19 = return_value_icmp4_errcmp$18 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$19)
                    return -1;

                }
              }

            }

          }

          else
            return -1;
        }

        else
        {
          icmp_errs = icmp_errs + 1ul;
          if(!(icmp_errs >= 11ul))
            log_message(3, "Unhandled poll/select event in ping4() at %s, line %d.", (const void *)"icmp.c", 310);

          return -1;
        }
        signed long int return_value_time$25;
        return_value_time$25=time((signed long int *)(void *)0);
        tpassed = return_value_time$25 - tm;
      }
      while(!(tpassed >= (signed long int)timeout));
    }
    return -1;
  }
}

// ping6
// file icmp.c line 371
static signed int ping6(struct in6_addr a, signed int timeout, signed int rep)
{
  signed int i;
  signed int isock;
  struct icmp6_filter f;
  unsigned short int id;
  signed int return_value_rand$1;
  return_value_rand$1=rand();
  id = (unsigned short int)(return_value_rand$1 & 0xffff);
  isock = ping6_isocket;
  memset((void *)&f, 0xFF, sizeof(struct icmp6_filter) /*32ul*/ );
  (&f)->icmp6_filt[(signed long int)(129 >> 5)] = (&f)->icmp6_filt[(signed long int)(129 >> 5)] & (unsigned int)~(1 << (129 & 31));
  (&f)->icmp6_filt[(signed long int)(1 >> 5)] = (&f)->icmp6_filt[(signed long int)(1 >> 5)] & (unsigned int)~(1 << (1 & 31));
  (&f)->icmp6_filt[(signed long int)(3 >> 5)] = (&f)->icmp6_filt[(signed long int)(3 >> 5)] & (unsigned int)~(1 << (3 & 31));
  signed int return_value_setsockopt$4;
  return_value_setsockopt$4=setsockopt(isock, 58, 1, (const void *)&f, (unsigned int)sizeof(struct icmp6_filter) /*32ul*/ );
  signed int return_value_is_interrupted_servstat_thread$12;
  unsigned short int return_value_ntohs$22;
  unsigned short int return_value_ntohs$24;
  signed int return_value_icmp6_errcmp$17;
  if(return_value_setsockopt$4 == -1)
  {
    icmp_errs = icmp_errs + 1ul;
    if(!(icmp_errs >= 11ul))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_message(4, "icmpv6 ping: setsockopt() failed: %s", return_value_strerror$3);
    }

    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= rep); i = i + 1)
    {
      struct sockaddr_in6 from;
      struct icmp6_hdr icmpd;
      signed long int tm;
      signed long int tpassed;
      icmpd.icmp6_type = (unsigned char)128;
      icmpd.icmp6_code = (unsigned char)0;
      icmpd.icmp6_cksum = (unsigned short int)0;
      icmpd.icmp6_dataun.icmp6_un_data16[(signed long int)0]=htons((unsigned short int)id);
      icmpd.icmp6_dataun.icmp6_un_data16[(signed long int)1]=htons((unsigned short int)i);
      memset((void *)&from, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
      from.sin6_family = (unsigned short int)10;
      from.sin6_flowinfo = (unsigned int)0;
      from.sin6_port = (unsigned short int)0;
      from.sin6_addr = a;
      signed long int return_value_sendto$7;
      return_value_sendto$7=sendto(isock, (const void *)&icmpd, sizeof(struct icmp6_hdr) /*8ul*/ , 0, (struct sockaddr *)&from, (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ );
      if(return_value_sendto$7 == -1l)
      {
        icmp_errs = icmp_errs + 1ul;
        if(!(icmp_errs >= 11ul))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          char *return_value_strerror$6;
          return_value_strerror$6=strerror(*return_value___errno_location$5);
          log_message(4, "icmpv6 ping: sendto() failed: %s.", return_value_strerror$6);
        }

        return -1;
      }

      tm=time((signed long int *)(void *)0);
      tpassed = (signed long int)0;
      do
      {
        signed int psres;
        struct pollfd pfd;
        pfd.fd = isock;
        pfd.events = (signed short int)0x001;
        signed int return_value_is_interrupted_servstat_thread$8;
        return_value_is_interrupted_servstat_thread$8=is_interrupted_servstat_thread$link1();
        if(!(return_value_is_interrupted_servstat_thread$8 == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "server status thread interrupted.\n");

          return -1;
        }

        psres=poll(&pfd, (unsigned long int)1, (signed int)((signed long int)timeout > tpassed ? ((signed long int)timeout - tpassed) * (signed long int)1000 : (signed long int)0));
        if(!(psres >= 0))
        {
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          _Bool tmp_if_expr$13;
          if(*return_value___errno_location$11 == 4)
          {
            return_value_is_interrupted_servstat_thread$12=is_interrupted_servstat_thread$link1();
            tmp_if_expr$13 = return_value_is_interrupted_servstat_thread$12 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
          {
            if(!(debug_p == 0))
              debug_msg(0, "poll/select interrupted in server status thread.\n");

          }

          else
          {
            icmp_errs = icmp_errs + 1ul;
            if(!(icmp_errs >= 11ul))
            {
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              char *return_value_strerror$10;
              return_value_strerror$10=strerror(*return_value___errno_location$9);
              log_message(4, "poll/select failed: %s", return_value_strerror$10);
            }

          }
          return -1;
        }

        if(psres == 0)
          break;

        if(!((9 & (signed int)pfd.revents) == 0))
        {
          char buf[1024l];
          unsigned int sl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
          signed int len;
          signed long int return_value_recvfrom$26;
          return_value_recvfrom$26=recvfrom(isock, (void *)&buf, sizeof(char [1024l]) /*1024ul*/ , 0, (struct sockaddr *)&from, &sl);
          len = (signed int)return_value_recvfrom$26;
          if(!(len == -1))
          {
            if((unsigned long int)len >= sizeof(struct icmp6_hdr) /*8ul*/ )
            {
              struct icmp6_hdr icmpp;
              memcpy((void *)&icmpp, (const void *)buf, sizeof(struct icmp6_hdr) /*8ul*/ );
              _Bool tmp_if_expr$19;
              if(*((unsigned int *)&from.sin6_addr) == *((unsigned int *)&a))
                tmp_if_expr$19 = ((unsigned int *)&from.sin6_addr)[(signed long int)1] == ((unsigned int *)&a)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$19 = (_Bool)0;
              _Bool tmp_if_expr$20;
              if(tmp_if_expr$19)
                tmp_if_expr$20 = ((unsigned int *)&from.sin6_addr)[(signed long int)2] == ((unsigned int *)&a)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$20 = (_Bool)0;
              _Bool tmp_if_expr$21;
              if(tmp_if_expr$20)
                tmp_if_expr$21 = ((unsigned int *)&from.sin6_addr)[(signed long int)3] == ((unsigned int *)&a)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$21 = (_Bool)0;
              _Bool tmp_if_expr$23;
              if(tmp_if_expr$21)
              {
                return_value_ntohs$22=ntohs(icmpp.icmp6_dataun.icmp6_un_data16[(signed long int)0]);
                tmp_if_expr$23 = return_value_ntohs$22 == id ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$23 = (_Bool)0;
              _Bool tmp_if_expr$25;
              if(tmp_if_expr$23)
              {
                return_value_ntohs$24=ntohs(icmpp.icmp6_dataun.icmp6_un_data16[(signed long int)1]);
                tmp_if_expr$25 = (signed int)return_value_ntohs$24 <= i ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$25 = (_Bool)0;
              if(tmp_if_expr$25)
              {
                unsigned short int return_value_ntohs$14;
                return_value_ntohs$14=ntohs(icmpp.icmp6_dataun.icmp6_un_data16[(signed long int)1]);
                signed long int return_value_time$15;
                return_value_time$15=time((signed long int *)(void *)0);
                return (signed int)((signed long int)((i - (signed int)return_value_ntohs$14) * timeout) + (return_value_time$15 - tm));
              }

              else
              {
                signed int return_value_icmp6_errcmp$16;
                return_value_icmp6_errcmp$16=icmp6_errcmp((char *)&icmpd, (signed int)sizeof(struct icmp6_hdr) /*8ul*/ , &from.sin6_addr, buf, len, 1);
                _Bool tmp_if_expr$18;
                if(!(return_value_icmp6_errcmp$16 == 0))
                  tmp_if_expr$18 = (_Bool)1;

                else
                {
                  return_value_icmp6_errcmp$17=icmp6_errcmp((char *)&icmpd, (signed int)sizeof(struct icmp6_hdr) /*8ul*/ , &from.sin6_addr, buf, len, 3);
                  tmp_if_expr$18 = return_value_icmp6_errcmp$17 != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$18)
                  return -1;

              }
            }

          }

          else
            return -1;
        }

        else
        {
          icmp_errs = icmp_errs + 1ul;
          if(!(icmp_errs >= 11ul))
            log_message(3, "Unhandled poll/select event in ping6() at %s, line %d.", (const void *)"icmp.c", 497);

          return -1;
        }
        signed long int return_value_time$27;
        return_value_time$27=time((signed long int *)(void *)0);
        tpassed = return_value_time$27 - tm;
      }
      while(!(tpassed >= (signed long int)timeout));
    }
    return -1;
  }
}

// precsize_ntoa
// file rr_types.c line 60
static const char * precsize_ntoa(unsigned char prec, char *retbuf)
{
  unsigned int mantissa;
  unsigned int exponent;
  mantissa = (unsigned int)((signed int)prec >> 4);
  exponent = (unsigned int)((signed int)prec & 0x0f);
  if(exponent >= 10u || mantissa >= 10u)
    return (const char *)(void *)0;

  else
  {
    if(exponent >= 2u)
      sprintf(retbuf, "%u", mantissa * poweroften[(signed long int)(exponent - (unsigned int)2)]);

    else
      sprintf(retbuf, "0.%.2u", mantissa * poweroften[(signed long int)exponent]);
    return retbuf;
  }
}

// print_serr
// file status.c line 61
static signed int print_serr(signed int rs, const char *msg)
{
  unsigned short int cmd;
  if(!(debug_p == 0))
    debug_msg(0, "Sending error message to control socket: '%s'\n", msg);

  cmd=htons((unsigned short int)1);
  signed long int return_value_write$3;
  return_value_write$3=write(rs, (const void *)&cmd, sizeof(unsigned short int) /*2ul*/ );
  _Bool tmp_if_expr$6;
  unsigned long int return_value_strlen$4;
  signed long int return_value_write_all$5;
  if(!((unsigned long int)return_value_write$3 == sizeof(unsigned short int) /*2ul*/ ))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_strlen$4=strlen(msg);
    return_value_write_all$5=write_all$link2(rs, (const void *)msg, return_value_strlen$4);
    tmp_if_expr$6 = return_value_write_all$5 < (signed long int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(tmp_if_expr$6)
  {
    if(!(debug_p == 0))
    {
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      debug_msg(0, "Error writing to control socket: %s\n", return_value_strerror$2);
    }

    return 0;
  }

  else
    return 1;
}

// print_succ
// file status.c line 77
static signed int print_succ(signed int rs)
{
  unsigned short int cmd;
  cmd=htons((unsigned short int)0);
  signed long int return_value_write$3;
  return_value_write$3=write(rs, (const void *)&cmd, sizeof(unsigned short int) /*2ul*/ );
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!((unsigned long int)return_value_write$3 == sizeof(unsigned short int) /*2ul*/ ))
  {
    if(!(debug_p == 0))
    {
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      debug_msg(0, "Error writing to control socket: %s\nFailed to send success code.\n", return_value_strerror$2);
    }

    return 0;
  }

  else
    return 1;
}

// process_query
// file dns_answer.c line 1156
static struct anonymous$28 * process_query(unsigned char *data, unsigned long int *rlenp, unsigned int *udp, signed int *rcodep)
{
  unsigned long int rlen = *rlenp;
  signed int res;
  struct anonymous$29 *hdr;
  struct anonymous$40 ql;
  struct anonymous$28 *ans;
  struct anonymous$17 ednsinfo = { .udpsize=(unsigned short int)0, .rcode=0, .version=0,
    .do_flg=0 };
  struct anonymous$17 *ednsinfop = (struct anonymous$17 *)(void *)0;
  if(!(debug_p == 0))
    debug_msg(0, "Received query (msg len=%u).\n", (unsigned int)rlen);

  hdr = (struct anonymous$29 *)data;
  signed int return_value_llist_isempty$1;
  _Bool tmp_if_expr$3;
  const char *return_value_get_cname$7;
  const char *return_value_get_tname$8;
  const unsigned char *return_value_rhn2str$9;
  void *return_value_llist_next$6;
  signed int return_value_llist_isempty$11;
  if(!(rlen >= 2ul))
  {
    if(!(debug_p == 0))
      debug_msg(0, "Message too short.\n");

    return (struct anonymous$28 *)(void *)0;
  }

  else
  {
    if(!(rlen >= sizeof(struct anonymous$29) /*12ul*/ ))
    {
      if(!(debug_p == 0))
        debug_msg(0, "Message too short.\n");

      res = 1;
    }

    else
    {
      if(!((signed int)hdr->qr == 0))
      {
        if(!(debug_p == 0))
          debug_msg(0, "The QR bit indicates this is a response, not a query.\n");

        return (struct anonymous$28 *)(void *)0;
      }

      if(!((signed int)hdr->opcode == 0))
      {
        if(!(debug_p == 0))
          debug_msg(0, "Not a standard query (opcode=%u).\n", hdr->opcode);

        res = 4;
      }

      else
      {
        if(!(debug_p == 0))
        {
          char flgsbuf[22l];
          dnsflags2str(hdr, flgsbuf);
          if(!(flgsbuf[0l] == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Flags:%s\n", (const void *)flgsbuf);

          }

        }

        if(!((signed int)hdr->z == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Malformed query (nonzero Z bit).\n");

          res = 1;
        }

        else
        {
          if(!((signed int)hdr->rcode == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Bad rcode(%u).\n", hdr->rcode);

            return (struct anonymous$28 *)(void *)0;
          }

          if(!(hdr->ancount == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Query has a non-empty answer section!\n");

            res = 1;
          }

          else
            if(!(hdr->nscount == 0))
            {
              if(!(debug_p == 0))
                debug_msg(0, "Query has a non-empty authority section!\n");

              res = 1;
            }

            else
            {
              unsigned char *ptr;
              unsigned long int sz;
              unsigned short int arcount;
              res=decode_query(data, rlen, &ptr, &sz, &ql);
              if(!(res == 0))
              {
                if(res == 0xfffe)
                {
                  _Bool tmp_if_expr$2;
                  if(hdr->tc == 0u)
                    tmp_if_expr$2 = (_Bool)1;

                  else
                  {
                    return_value_llist_isempty$1=llist_isempty(&ql);
                    tmp_if_expr$2 = return_value_llist_isempty$1 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$2)
                  {
                    res = 1;
                    goto free_ql_error_reply;
                  }

                  goto __CPROVER_DUMP_L24;
                }

              }

              else
              {

              __CPROVER_DUMP_L24:
                ;
                arcount=ntohs(hdr->arcount);
                if(!(arcount == 0))
                {
                  signed int numoptrr = 0;
                  if(!(debug_p == 0))
                    debug_msg(0, "Query has a non-empty additional section: checking for OPT pseudo-RR.\n");

                  if(res == 0xfffe)
                  {
                    if(!(debug_p == 0))
                      debug_msg(0, "Additional section cannot be read due to truncation!\n");

                    res = 1;
                    goto free_ql_error_reply;
                  }

                  res=decode_query_additional(data, rlen, ptr, sz, (signed int)arcount, &numoptrr, &ednsinfo);
                  _Bool tmp_if_expr$4;
                  if(res == 0)
                    tmp_if_expr$4 = (_Bool)1;

                  else
                  {
                    if(res == 0xfffe)
                      tmp_if_expr$3 = hdr->tc != 0u ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$3 = (_Bool)0;
                    tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
                  }
                  if(!tmp_if_expr$4)
                  {
                    res = 1;
                    goto free_ql_error_reply;
                  }

                  if(!(numoptrr == 0))
                  {
                    if(!(numoptrr == 1))
                    {
                      if(!(debug_p == 0))
                        debug_msg(0, "Additional section in query contains %d OPT pseudo-RRs!\n", numoptrr);

                    }

                    if(!((signed int)ednsinfo.version == 0))
                    {
                      if(!(debug_p == 0))
                        debug_msg(0, "Query contains unsupported EDNS version %d!\n", ednsinfo.version);

                      res = 16;
                      goto free_ql_error_reply;
                    }

                    if(!((signed int)ednsinfo.rcode == 0))
                    {
                      if(!(debug_p == 0))
                        debug_msg(0, "Query contains non-zero EDNS rcode (%d)!\n", ednsinfo.rcode);

                      res = 1;
                      goto free_ql_error_reply;
                    }

                    if(!(debug_p == 0))
                      debug_msg(0, "Query contains OPT pseudosection: EDNS udp size = %u, flag DO=%u\n", ednsinfo.udpsize, ednsinfo.do_flg);

                    ednsinfop = &ednsinfo;
                    if((signed int)ednsinfo.udpsize >= 513 && !(udp == ((unsigned int *)NULL)))
                    {
                      unsigned int udpbufsize = (unsigned int)global.udpbufsize;
                      if(!((unsigned int)ednsinfo.udpsize >= udpbufsize))
                        udpbufsize = (unsigned int)ednsinfo.udpsize;

                      *udp = udpbufsize;
                    }

                  }

                }

                if(!(debug_p == 0))
                {
                  signed int return_value_llist_isempty$10;
                  return_value_llist_isempty$10=llist_isempty(&ql);
                  if(return_value_llist_isempty$10 == 0)
                  {
                    struct anonymous$70 *qe;
                    if(!(debug_p == 0))
                      debug_msg(0, "Questions are:\n");

                    void *return_value_llist_first$5;
                    return_value_llist_first$5=llist_first(&ql);
                    qe = (struct anonymous$70 *)return_value_llist_first$5;
                    for( ; !(qe == ((struct anonymous$70 *)NULL)); qe = (struct anonymous$70 *)return_value_llist_next$6)
                    {
                      unsigned char _debugstrbuf[256l];
                      if(!(debug_p == 0))
                      {
                        return_value_get_cname$7=get_cname((signed int)qe->qclass);
                        return_value_get_tname$8=get_tname((signed int)qe->qtype);
                        return_value_rhn2str$9=rhn2str(qe->query, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                        debug_msg(0, "\tqc=%s (%u), qt=%s (%u), query=\"%s\"\n", return_value_get_cname$7, qe->qclass, return_value_get_tname$8, qe->qtype, return_value_rhn2str$9);
                      }

                      return_value_llist_next$6=llist_next((void *)qe);
                    }
                  }

                  else
                    if(!(debug_p == 0))
                      debug_msg(0, "Query contains no questions.\n");

                }

                return_value_llist_isempty$11=llist_isempty(&ql);
                if(!(return_value_llist_isempty$11 == 0))
                  res = 1;

                else
                {
                  ans=compose_answer(&ql, hdr, rlenp, ednsinfop, udp, rcodep);
                  if(ans == ((struct anonymous$28 *)NULL))
                    res = 2;

                  else
                  {
                    llist_free(&ql);
                    return ans;
                  }

                free_ql_error_reply:
                  ;
                  llist_free(&ql);
                }
              }
            }
        }
      }
    }

  error_reply:
    ;
    *rlenp = sizeof(struct anonymous$29) /*12ul*/ ;
    unsigned long int allocsz = sizeof(struct anonymous$28) /*14ul*/ ;
    if(!((-16 & res) == 0))
      allocsz = allocsz + (unsigned long int)(1 + 10);

    void *return_value_malloc$12;
    return_value_malloc$12=malloc(allocsz);
    ans = (struct anonymous$28 *)return_value_malloc$12;
    if(!(ans == ((struct anonymous$28 *)NULL)))
    {
      signed int tmp_if_expr$13;
      if(rlen >= 3ul)
        tmp_if_expr$13 = (signed int)hdr->opcode;

      else
        tmp_if_expr$13 = 0;
      mk_error_reply(hdr->id, (unsigned short int)tmp_if_expr$13, (unsigned short int)res, &ans->hdr);
      if(!((-16 & res) == 0))
        add_opt_pseudo_rr(&ans, rlenp, &allocsz, (unsigned short int)global.udpbufsize, (unsigned short int)res, (unsigned short int)0, (unsigned short int)0);

    }

    else
    {
      da_mem_errs = da_mem_errs + 1ul;
      if(!(da_mem_errs >= 11ul))
        log_message(3, "Out of memory in query processing.");

    }
    if(!(rcodep == ((signed int *)NULL)))
      *rcodep = res;

    return ans;
  }
}

// purge_all_rrsets
// file cache.c line 1207
static signed int purge_all_rrsets(struct anonymous$0 *cent, signed int test, signed int *numrrsrem)
{
  signed int rv = 0;
  signed int numrrs = 0;
  signed int numrrext = 0;
  signed long int tmp_if_expr$5;
  signed long int return_value_time$6;
  signed int return_value_del_cent_rrset_by_index$3;
  if((1 & (signed int)cent->flags) == 0)
  {
    signed int i;
    signed int ilim;
    signed int tmp_if_expr$1;
    if(!((1 & (signed int)cent->flags) == 0))
      tmp_if_expr$1 = 0;

    else
      tmp_if_expr$1 = cent->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
    ilim = tmp_if_expr$1;
    i = 0;
    for( ; !(i >= ilim); i = i + 1)
    {
      struct anonymous *rrs;
      struct anonymous *tmp_if_expr$2;
      if(!(i >= 8))
        tmp_if_expr$2 = cent->$anon0.rr.rrmu[(signed long int)i];

      else
        tmp_if_expr$2 = cent->$anon0.rr.rrext[(signed long int)(i - 8)];
      rrs = tmp_if_expr$2;
      if(!(rrs == ((struct anonymous *)NULL)))
      {
        _Bool tmp_if_expr$4;
        if(!((32 & (signed int)rrs->flags) == 0))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = ((signed int)rrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$7;
        if(!tmp_if_expr$4)
        {
          if(!(rrs->ttl >= 120l))
            tmp_if_expr$5 = (signed long int)120;

          else
            tmp_if_expr$5 = rrs->ttl;
          return_value_time$6=time((signed long int *)(void *)0);
          tmp_if_expr$7 = rrs->ts + tmp_if_expr$5 < return_value_time$6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
        {
          if(test == 0)
          {
            return_value_del_cent_rrset_by_index$3=del_cent_rrset_by_index(cent, i);
            cache_size = cache_size - (volatile signed long int)return_value_del_cent_rrset_by_index$3;
          }

          rv = rv + 1;
        }

        else
        {
          numrrs = numrrs + 1;
          if(i >= 8)
            numrrext = numrrext + 1;

        }
      }

    }
    if(!(cent->$anon0.rr.rrext == ((struct anonymous **)NULL)))
    {
      if(numrrext == 0)
      {
        if(test == 0)
        {
          free((void *)cent->$anon0.rr.rrext);
          cent->$anon0.rr.rrext = (struct anonymous **)(void *)0;
          cent->cs = cent->cs - sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39;
          cache_size = cache_size - (volatile signed long int)(sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39);
        }

        rv = rv + 1;
      }

    }

  }

  if(!(numrrsrem == ((signed int *)NULL)))
    *numrrsrem = numrrs;

  return rv;
}

// purge_cache
// file cache.c line 1314
static void purge_cache(signed long int sz, signed int lazy)
{
  struct rr_lent_s *le = rrset_l;
  _Bool tmp_if_expr$3;
  signed long int tmp_if_expr$1;
  signed long int return_value_time$2;
  while(!(le == ((struct rr_lent_s *)NULL)) && (lazy == 0 || !(sz >= cache_size)))
  {
    struct rr_lent_s *purge_cache$$1$$1$$next = le->next;
    _Bool tmp_if_expr$5;
    if(!(le->rrset == ((struct anonymous *)NULL)))
      tmp_if_expr$5 = ((signed int)le->rrset->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    _Bool tmp_if_expr$6;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = ((signed int)le->cent->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$6)
    {
      struct anonymous$0 *purge_cache$$1$$1$$1$$ce = le->cent;
      if(!(le->rrset == ((struct anonymous *)NULL)))
        purge_rrset(purge_cache$$1$$1$$1$$ce, le->idx, 0);

      if((signed int)purge_cache$$1$$1$$1$$ce->num_rrs == 0)
      {
        _Bool tmp_if_expr$4;
        if((1 & (signed int)purge_cache$$1$$1$$1$$ce->flags) == 0)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          if((2 & (signed int)purge_cache$$1$$1$$1$$ce->flags) == 0)
          {
            if(!(purge_cache$$1$$1$$1$$ce->$anon0.neg.ttl >= 120l))
              tmp_if_expr$1 = (signed long int)120;

            else
              tmp_if_expr$1 = purge_cache$$1$$1$$1$$ce->$anon0.neg.ttl;
            return_value_time$2=time((signed long int *)(void *)0);
            tmp_if_expr$3 = purge_cache$$1$$1$$1$$ce->$anon0.neg.ts + tmp_if_expr$1 < return_value_time$2 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$3 = (_Bool)0;
          tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          del_cache_ent(purge_cache$$1$$1$$1$$ce, (struct anonymous$58 *)(void *)0);

      }

    }

    le = purge_cache$$1$$1$$next;
  }
  signed int return_value_del_cent_rrset_by_index$7;
  if(!(sz >= cache_size))
  {
    if(insert_sort == 0)
    {
      sort_rrl();
      insert_sort = (signed short int)1;
    }

    le = rrset_l;
    while(!(le == ((struct rr_lent_s *)NULL)) && !(sz >= cache_size))
    {
      struct rr_lent_s *next = le->next;
      _Bool tmp_if_expr$8;
      if(!(le->rrset == ((struct anonymous *)NULL)))
        tmp_if_expr$8 = ((signed int)le->rrset->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      _Bool tmp_if_expr$9;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = ((signed int)le->cent->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$9)
      {
        struct anonymous$0 *ce = le->cent;
        if(!(le->rrset == ((struct anonymous *)NULL)))
        {
          return_value_del_cent_rrset_by_index$7=del_cent_rrset_by_index(ce, le->idx);
          cache_size = cache_size - (volatile signed long int)return_value_del_cent_rrset_by_index$7;
        }

        if((signed int)ce->num_rrs == 0)
          del_cache_ent(ce, (struct anonymous$58 *)(void *)0);

      }

      le = next;
    }
  }

}

// purge_cent
// file cache.c line 1257
static signed int purge_cent(struct anonymous$0 *cent, signed int delete, signed int test)
{
  signed int npurge;
  signed int numrrs;
  npurge=purge_all_rrsets(cent, test, &numrrs);
  _Bool tmp_if_expr$3;
  signed long int tmp_if_expr$1;
  signed long int return_value_time$2;
  if(numrrs == 0 && !(delete == 0))
  {
    _Bool tmp_if_expr$4;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      if((2 & (signed int)cent->flags) == 0)
      {
        if(!(cent->$anon0.neg.ttl >= 120l))
          tmp_if_expr$1 = (signed long int)120;

        else
          tmp_if_expr$1 = cent->$anon0.neg.ttl;
        return_value_time$2=time((signed long int *)(void *)0);
        tmp_if_expr$3 = cent->$anon0.neg.ts + tmp_if_expr$1 < return_value_time$2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      if(test == 0)
        del_cache_ent(cent, (struct anonymous$58 *)(void *)0);

      return -1;
    }

  }

  _Bool tmp_if_expr$11;
  signed long int tmp_if_expr$9;
  signed long int return_value_time$10;
  _Bool tmp_if_expr$19;
  signed long int tmp_if_expr$17;
  signed long int return_value_time$18;
  if((2 & (signed int)cent->flags) == 0)
  {
    unsigned int scnt;
    scnt=rhnsegcnt$link2(cent->qname);
    if(!((signed int)cent->c_ns == 0xff))
    {
      struct anonymous *rrset = (struct anonymous *)(void *)0;
      if((unsigned int)cent->c_ns == scnt)
      {
        struct anonymous *tmp_if_expr$5;
        if((1 & (signed int)cent->flags) == 0)
          tmp_if_expr$5 = cent->$anon0.rr.rrmu[(signed long int)1];

        else
          tmp_if_expr$5 = (struct anonymous *)(void *)0;
        rrset = tmp_if_expr$5;
      }

      else
        if(!((unsigned int)cent->c_ns >= scnt))
        {
          struct anonymous$0 *ce;
          const unsigned char *return_value_skipsegs$6;
          return_value_skipsegs$6=skipsegs$link2(cent->qname, scnt - (unsigned int)cent->c_ns);
          ce=dns_lookup(return_value_skipsegs$6, (struct anonymous$58 *)(void *)0);
          if(!(ce == ((struct anonymous$0 *)NULL)))
          {
            struct anonymous *tmp_if_expr$7;
            if((1 & (signed int)ce->flags) == 0)
              tmp_if_expr$7 = ce->$anon0.rr.rrmu[(signed long int)1];

            else
              tmp_if_expr$7 = (struct anonymous *)(void *)0;
            rrset = tmp_if_expr$7;
          }

        }

      _Bool tmp_if_expr$8;
      if(rrset == ((struct anonymous *)NULL))
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = !(rrset->rrs != ((struct rr_b_s *)NULL)) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$12;
      if(tmp_if_expr$8)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        if((2 & (signed int)rrset->flags) == 0)
        {
          if(!(rrset->ttl >= 120l))
            tmp_if_expr$9 = (signed long int)120;

          else
            tmp_if_expr$9 = rrset->ttl;
          return_value_time$10=time((signed long int *)(void *)0);
          tmp_if_expr$11 = rrset->ts + tmp_if_expr$9 < return_value_time$10 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$11 = (_Bool)0;
        tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
      {
        if(test == 0)
          cent->c_ns = (unsigned char)0xff;

        npurge = npurge + 1;
      }

    }

    if(!((signed int)cent->c_soa == 0xff))
    {
      struct anonymous *purge_cent$$1$$2$$2$$rrset = (struct anonymous *)(void *)0;
      if((unsigned int)cent->c_soa == scnt)
      {
        struct anonymous *tmp_if_expr$13;
        if((1 & (signed int)cent->flags) == 0)
          tmp_if_expr$13 = cent->$anon0.rr.rrmu[(signed long int)3];

        else
          tmp_if_expr$13 = (struct anonymous *)(void *)0;
        purge_cent$$1$$2$$2$$rrset = tmp_if_expr$13;
      }

      else
        if(!((unsigned int)cent->c_soa >= scnt))
        {
          struct anonymous$0 *purge_cent$$1$$2$$2$$1$$ce;
          const unsigned char *return_value_skipsegs$14;
          return_value_skipsegs$14=skipsegs$link2(cent->qname, scnt - (unsigned int)cent->c_soa);
          purge_cent$$1$$2$$2$$1$$ce=dns_lookup(return_value_skipsegs$14, (struct anonymous$58 *)(void *)0);
          if(!(purge_cent$$1$$2$$2$$1$$ce == ((struct anonymous$0 *)NULL)))
          {
            struct anonymous *tmp_if_expr$15;
            if((1 & (signed int)purge_cent$$1$$2$$2$$1$$ce->flags) == 0)
              tmp_if_expr$15 = purge_cent$$1$$2$$2$$1$$ce->$anon0.rr.rrmu[(signed long int)3];

            else
              tmp_if_expr$15 = (struct anonymous *)(void *)0;
            purge_cent$$1$$2$$2$$rrset = tmp_if_expr$15;
          }

        }

      _Bool tmp_if_expr$16;
      if(purge_cent$$1$$2$$2$$rrset == ((struct anonymous *)NULL))
        tmp_if_expr$16 = (_Bool)1;

      else
        tmp_if_expr$16 = !(purge_cent$$1$$2$$2$$rrset->rrs != ((struct rr_b_s *)NULL)) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$20;
      if(tmp_if_expr$16)
        tmp_if_expr$20 = (_Bool)1;

      else
      {
        if((2 & (signed int)purge_cent$$1$$2$$2$$rrset->flags) == 0)
        {
          if(!(purge_cent$$1$$2$$2$$rrset->ttl >= 120l))
            tmp_if_expr$17 = (signed long int)120;

          else
            tmp_if_expr$17 = purge_cent$$1$$2$$2$$rrset->ttl;
          return_value_time$18=time((signed long int *)(void *)0);
          tmp_if_expr$19 = purge_cent$$1$$2$$2$$rrset->ts + tmp_if_expr$17 < return_value_time$18 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$19 = (_Bool)0;
        tmp_if_expr$20 = tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$20)
      {
        if(test == 0)
          cent->c_soa = (unsigned char)0xff;

        npurge = npurge + 1;
      }

    }

  }

  return npurge;
}

// purge_rrset
// file cache.c line 1188
static signed int purge_rrset(struct anonymous$0 *cent, signed int idx, signed int test)
{
  struct anonymous *rrs;
  struct anonymous *tmp_if_expr$3;
  struct anonymous *tmp_if_expr$2;
  struct anonymous *tmp_if_expr$1;
  if(!((1 & (signed int)cent->flags) == 0))
    tmp_if_expr$3 = (struct anonymous *)(void *)0;

  else
  {
    if(!(idx >= 8))
      tmp_if_expr$2 = cent->$anon0.rr.rrmu[(signed long int)idx];

    else
    {
      if(!(cent->$anon0.rr.rrext == ((struct anonymous **)NULL)))
        tmp_if_expr$1 = cent->$anon0.rr.rrext[(signed long int)(idx - 8)];

      else
        tmp_if_expr$1 = (struct anonymous *)(void *)0;
      tmp_if_expr$2 = tmp_if_expr$1;
    }
    tmp_if_expr$3 = tmp_if_expr$2;
  }
  rrs = tmp_if_expr$3;
  signed long int return_value_time$6;
  signed int return_value_del_cent_rrset_by_index$4;
  if(!(rrs == ((struct anonymous *)NULL)))
  {
    _Bool tmp_if_expr$7;
    if(!((32 & (signed int)rrs->flags) == 0))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = ((signed int)rrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$7)
    {
      signed long int tmp_if_expr$5;
      if(!(rrs->ttl >= 120l))
        tmp_if_expr$5 = (signed long int)120;

      else
        tmp_if_expr$5 = rrs->ttl;
      return_value_time$6=time((signed long int *)(void *)0);
      if(!(rrs->ts + tmp_if_expr$5 >= return_value_time$6))
      {
        if(test == 0)
        {
          return_value_del_cent_rrset_by_index$4=del_cent_rrset_by_index(cent, idx);
          cache_size = cache_size - (volatile signed long int)return_value_del_cent_rrset_by_index$4;
        }

        return 1;
      }

    }

  }

  return 0;
}

// query_stat_same_inaddr2
// file dns_query.c line 2013
static inline signed int query_stat_same_inaddr2(struct anonymous$5 *qs, struct anonymous$15 *b)
{
  signed int tmp_if_expr$5;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!(run_ipv4 == 0))
    tmp_if_expr$5 = (signed int)(qs->a.sin4.sin_addr.s_addr == b->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&qs->a.sin6.sin6_addr) == *((unsigned int *)&b->ipv6))
      tmp_if_expr$1 = ((unsigned int *)&qs->a.sin6.sin6_addr)[(signed long int)1] == ((unsigned int *)&b->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ((unsigned int *)&qs->a.sin6.sin6_addr)[(signed long int)2] == ((unsigned int *)&b->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = ((unsigned int *)&qs->a.sin6.sin6_addr)[(signed long int)3] == ((unsigned int *)&b->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = qs->a4fallback.s_addr == b->ipv4.s_addr ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = (signed int)tmp_if_expr$4;
  }
  return tmp_if_expr$5;
}

// query_uptest
// file dns_query.c line 3513
signed int query_uptest(union anonymous$6 *addr, signed int port, const unsigned char *name, signed long int timeout, signed int rep)
{
  struct anonymous$5 qs;
  signed int iter = 0;
  signed int rv;
  if(!(run_ipv4 == 0))
  {
    memset((void *)&qs.a.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    qs.a.sin4.sin_family = (unsigned short int)2;
    qs.a.sin4.sin_port=htons((unsigned short int)port);
    qs.a.sin4.sin_addr = addr->ipv4;
  }

  else
  {
    memset((void *)&qs.a.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
    qs.a.sin6.sin6_family = (unsigned short int)10;
    qs.a.sin6.sin6_port=htons((unsigned short int)port);
    qs.a.sin6.sin6_flowinfo = (unsigned int)0;
    qs.a.sin6.sin6_addr = addr->ipv6;
    qs.a4fallback.s_addr = (unsigned int)0x00000000;
  }
  qs.timeout = timeout;
  qs.flags = (unsigned short int)0;
  qs.nocache = (signed short int)0;
  qs.auth_serv = (char)0;
  qs.lean_query = (char)1;
  qs.edns_query = (char)0;
  qs.needs_testing = (char)0;
  qs.trusted = (char)1;
  qs.aa = (char)0;
  qs.tc = (char)0;
  qs.nsdomain = (const unsigned char *)(void *)0;
  qs.rejectlist = (struct rejectlist_s *)(void *)0;
  signed long int ts;
  signed long int tpassed;
  signed int event;
  struct pollfd pfd;
  signed int return_value_is_interrupted_servstat_thread$2;
  signed int return_value_is_interrupted_servstat_thread$6;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  do
  {

  try_again:
    ;
    qs.state = (signed short int)0;
    qs.qm = (signed short int)global.query_method;
    qs.s_errno = 0;
    rv=p_exec_query((struct anonymous$0 **)(void *)0, name, 1, &qs, (struct _dynamic_list_head **)(void *)0, (unsigned char *)(void *)0);
    if(!(rv == -1))
      goto __CPROVER_DUMP_L25;

    ts=time((signed long int *)(void *)0);
    tpassed = (signed long int)0;

  __CPROVER_DUMP_L4:
    ;
    pfd.fd = qs.sock;
    switch((signed int)qs.state)
    {
      case 3:

      case 5:
      {
        pfd.events = (signed short int)0x001;
        break;
      }
      case 2:
      {
        pfd.events = (signed short int)0x004;
        break;
      }
      default:
        pfd.events = (signed short int)0;
    }
    return_value_is_interrupted_servstat_thread$2=is_interrupted_servstat_thread();
    if(!(return_value_is_interrupted_servstat_thread$2 == 0))
    {
      if(!(debug_p == 0))
        debug_msg(0, "server status thread interrupted.\n");

      p_cancel_query(&qs);
      return 0;
    }

    event=poll(&pfd, (unsigned long int)1, (signed int)(timeout > tpassed ? (timeout - tpassed) * (signed long int)1000 : (signed long int)0));
    if(!(event >= 0))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      _Bool tmp_if_expr$7;
      if(*return_value___errno_location$5 == 4)
      {
        return_value_is_interrupted_servstat_thread$6=is_interrupted_servstat_thread();
        tmp_if_expr$7 = return_value_is_interrupted_servstat_thread$6 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$7 = (_Bool)0;
      if(tmp_if_expr$7)
      {
        if(!(debug_p == 0))
          debug_msg(0, "poll/select interrupted in server status thread.\n");

      }

      else
      {
        return_value___errno_location$3=__errno_location();
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        log_message(4, "poll/select failed: %s", return_value_strerror$4);
      }
      p_cancel_query(&qs);
      return 0;
    }

    if(!(event == 0))
      goto __CPROVER_DUMP_L17;

    p_cancel_query(&qs);
    iter = iter + 1;
  }
  while(!(iter >= rep));
  return 0;

__CPROVER_DUMP_L17:
  ;
  event = 0;
  switch((signed int)qs.state)
  {
    case 3:

    case 5:
    {
      event = (signed int)pfd.revents & (0x001 | 0x008 | 0x010 | 0x020);
      break;
    }
    case 2:
      event = (signed int)pfd.revents & (0x004 | 0x008 | 0x010 | 0x020);
  }
  if(!(event == 0))
  {
    rv=p_exec_query((struct anonymous$0 **)(void *)0, name, 1, &qs, (struct _dynamic_list_head **)(void *)0, (unsigned char *)(void *)0);
    if(!(rv == -1))
      goto __CPROVER_DUMP_L24;

  }

  else
  {
    poll_errs = poll_errs + 1ul;
    if(!(poll_errs >= 11ul))
      log_message(3, "Unhandled poll/select event in query_uptest() at %s, line %d.", (const void *)"dns_query.c", 3653);

    p_cancel_query(&qs);
    return 0;
  }
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  tpassed = return_value_time$1 - ts;
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L24:
  ;

__CPROVER_DUMP_L25:
  ;
  return (signed int)(rv != 2 && rv != 0xffff);
}

// r_dns_cached_resolve
// file dns_query.h line 36
signed int r_dns_cached_resolve(unsigned char *name, signed int thint, struct anonymous$0 **cachedp, signed int hops, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa)
{
  struct anonymous$0 *cached;
  signed int rc;
  rc=p_dns_cached_resolve((struct anonymous$4 *)(void *)0, name, thint, &cached, hops, (struct qstatnode_s *)(void *)0, qhlist, queryts, c_soa);
  if(rc == 0)
  {
    if(!((1 & (signed int)cached->flags) == 0))
    {
      if(!(c_soa == ((unsigned char *)NULL)))
        *c_soa = cached->c_soa;

      free_cent(cached);
      free((void *)cached);
      rc = 3;
    }

    else
      *cachedp = cached;
  }

  return rc;
}

// randrr
// file dns_answer.c line 519
static inline struct rr_b_s * randrr(struct rr_b_s *rrb)
{
  struct rr_b_s *rr;
  unsigned int cnt = (unsigned int)0;
  rr = rrb;
  for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
    cnt = cnt + 1u;
  if(!(cnt == 0u))
  {
    signed long int return_value_random$1;
    return_value_random$1=random();
    cnt = (unsigned int)(return_value_random$1 % (signed long int)cnt);
    for( ; !(cnt == 0u); cnt = cnt - 1u)
      rrb = rrb->next;
  }

  return rrb;
}

// read_allocstring
// file status.c line 122
static signed int read_allocstring(signed int fh, char **res, unsigned int *len)
{
  unsigned short int count;
  char *buf;
  unsigned int nread;
  signed int return_value_read_short$1;
  return_value_read_short$1=read_short(fh, &count);
  if(return_value_read_short$1 == 0)
    return 0;

  else
    if(count == 65535)
    {
      *res = (char *)(void *)0;
      return -1;
    }

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)((signed int)count + 1));
      buf = (char *)return_value_malloc$2;
      if(buf == ((char *)NULL))
        return 0;

      else
      {
        nread = (unsigned int)0;
        while(!(nread >= (unsigned int)count))
        {
          signed long int m;
          m=read(fh, (void *)(buf + (signed long int)nread), (unsigned long int)((unsigned int)count - nread));
          if(!(m >= 1l))
          {
            free((void *)buf);
            return 0;
          }

          nread = nread + (unsigned int)m;
        }
        buf[(signed long int)count] = (char)0;
        *res = buf;
        if(!(len == ((unsigned int *)NULL)))
          *len = (unsigned int)count;

        return 1;
      }
    }
}

// read_config_file
// file conff.h line 182
signed int read_config_file(const char *nm, struct anonymous$21 *global, struct anonymous$18 **servers, signed int includedepth, char **errstr)
{
  signed int retval = 0;
  const char *conftype = global != ((struct anonymous$21 *)NULL) ? "config" : "include";
  struct _IO_FILE *in;
  if(nm == ((const char *)NULL))
    nm = conf_file;

  in=fopen(nm, "r");
  if(in == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    signed int return_value_asprintf$3;
    return_value_asprintf$3=asprintf(errstr, "Error: Could not open %s file %s: %s", conftype, nm, return_value_strerror$2);
    if(!(return_value_asprintf$3 >= 0))
      *errstr = (char *)(void *)0;

    return 0;
  }

  signed int return_value_fstat$9;
  if(!(servers == ((struct anonymous$18 **)NULL)) || !(global == ((struct anonymous$21 *)NULL)))
  {
    signed int fd;
    fd=fileno(in);
    struct stat sb;
    _Bool tmp_if_expr$10;
    if(fd == -1)
      tmp_if_expr$10 = (_Bool)1;

    else
    {
      return_value_fstat$9=fstat(fd, &sb);
      tmp_if_expr$10 = return_value_fstat$9 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$10)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      signed int return_value_asprintf$6;
      return_value_asprintf$6=asprintf(errstr, "Error: Could not stat %s file %s: %s", conftype, nm, return_value_strerror$5);
      if(!(return_value_asprintf$6 >= 0))
        *errstr = (char *)(void *)0;

      goto close_file;
    }

    else
      if(!(sb.st_uid == init_uid))
      {
        struct passwd *pws;
        char owner[24l];
        char user[24l];
        pws=getpwuid(sb.st_uid);
        if(!(pws == ((struct passwd *)NULL)))
          strncp(owner, pws->pw_name, sizeof(char [24l]) /*24ul*/ );

        else
          sprintf(owner, "%i", sb.st_uid);
        pws=getpwuid(init_uid);
        if(!(pws == ((struct passwd *)NULL)))
          strncp(user, pws->pw_name, sizeof(char [24l]) /*24ul*/ );

        else
          sprintf(user, "%i", init_uid);
        signed int return_value_asprintf$7;
        return_value_asprintf$7=asprintf(errstr, "Error: %s file %s is owned by '%s', but pdnsd was started as user '%s'.", conftype, nm, (const void *)owner, (const void *)user);
        if(!(return_value_asprintf$7 >= 0))
          *errstr = (char *)(void *)0;

        goto close_file;
      }

      else
        if(!((18u & sb.st_mode) == 0u))
        {
          signed int return_value_asprintf$8;
          return_value_asprintf$8=asprintf(errstr, "Error: Bad %s file permissions: file %s must be only writeable by the user.", conftype, nm);
          if(!(return_value_asprintf$8 >= 0))
            *errstr = (char *)(void *)0;

          goto close_file;
        }

  }

  retval=confparse(in, (char *)(void *)0, global, servers, includedepth, errstr);

close_file:
  ;
  signed int return_value_fclose$14;
  return_value_fclose$14=fclose(in);
  if(!(return_value_fclose$14 == 0))
  {
    if(!(retval == 0))
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      char *return_value_strerror$12;
      return_value_strerror$12=strerror(*return_value___errno_location$11);
      signed int return_value_asprintf$13;
      return_value_asprintf$13=asprintf(errstr, "Error: Could not close %s file %s: %s", conftype, nm, return_value_strerror$12);
      if(!(return_value_asprintf$13 >= 0))
        *errstr = (char *)(void *)0;

      return 0;
    }

  }

  unsigned int return_value_da_nel$16;
  if(!(servers == ((struct anonymous$18 **)NULL)) && !(retval == 0))
  {
    return_value_da_nel$16=da_nel$link1((struct anonymous$3 *)*servers);
    if(return_value_da_nel$16 == 0u)
    {
      signed int return_value_asprintf$15;
      return_value_asprintf$15=asprintf(errstr, "Error: no server sections defined in config file %s", nm);
      if(!(return_value_asprintf$15 >= 0))
        *errstr = (char *)(void *)0;

      return 0;
    }

  }

  return retval;
}

// read_disk_cache
// file cache.h line 164
void read_disk_cache(void)
{
  struct anonymous$0 ce;
  signed int dtsz = 512;
  unsigned char *data;
  unsigned long int cnt;
  struct _IO_FILE *f;
  signed long int f$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(global.cache_dir);
  f$array_size0 = (signed long int)(return_value_strlen$1 + sizeof(char [13l]) /*13ul*/ );
  char path[f$array_size0];
  char *return_value_stpcpy$2;
  return_value_stpcpy$2=stpcpy(path, global.cache_dir);
  stpcpy(return_value_stpcpy$2, "/pdnsd.cache");
  f=fopen(path, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    log_message(4, "Could not open disk cache file %s: %s", (const void *)path, return_value_strerror$4);
    goto __CPROVER_DUMP_L55;
  }

  void *return_value_malloc$5;
  return_value_malloc$5=malloc((unsigned long int)dtsz);
  data = (unsigned char *)return_value_malloc$5;
  signed int return_value_feof$10;
  signed int return_value_feof$8;
  unsigned long int return_value_fread$16;
  signed int return_value_feof$14;
  signed int return_value_feof$18;
  signed int return_value_feof$22;
  signed int return_value_feof$26;
  signed int return_value_feof$32;
  signed int return_value_feof$38;
  unsigned long int return_value_fread$45;
  signed int return_value_feof$43;
  if(!(data == ((unsigned char *)NULL)))
  {
    insert_sort = (signed short int)0;
    unsigned int read_disk_cache$$1$$3$$nb;
    char buf[(signed long int)sizeof(const char [4l]) /*4l*/ ];
    unsigned long int return_value_fread$6;
    return_value_fread$6=fread((void *)buf, (unsigned long int)1, sizeof(const char [4l]) /*4ul*/ , f);
    read_disk_cache$$1$$3$$nb = (unsigned int)return_value_fread$6;
    if(!((unsigned long int)read_disk_cache$$1$$3$$nb == sizeof(const char [4l]) /*4ul*/ ))
    {
      _Bool tmp_if_expr$11;
      if(!(read_disk_cache$$1$$3$$nb == 0u))
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value_feof$10=feof(f);
        tmp_if_expr$11 = !(return_value_feof$10 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
      {
        signed int return_value_ferror$7;
        return_value_ferror$7=ferror(f);
        char *tmp_if_expr$9;
        if(!(return_value_ferror$7 == 0))
          tmp_if_expr$9 = "Error";

        else
        {
          return_value_feof$8=feof(f);
          tmp_if_expr$9 = return_value_feof$8 != 0 ? "EOF" : "Incomplete item";
        }
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$9, (const void *)"cache version identifier");
      }

      goto free_data_fclose;
    }

    signed int return_value_memcmp$12;
    return_value_memcmp$12=memcmp((const void *)buf, (const void *)cachverid, sizeof(const char [4l]) /*4ul*/ );
    if(!(return_value_memcmp$12 == 0))
      log_message(4, "Cache file %s ignored because of incompatible version identifier", (const void *)path);

    else
    {
      return_value_fread$16=fread((void *)&cnt, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, f);
      if(!(return_value_fread$16 == 1ul))
      {
        signed int return_value_ferror$13;
        return_value_ferror$13=ferror(f);
        char *tmp_if_expr$15;
        if(!(return_value_ferror$13 == 0))
          tmp_if_expr$15 = "Error";

        else
        {
          return_value_feof$14=feof(f);
          tmp_if_expr$15 = return_value_feof$14 != 0 ? "EOF" : "Incomplete item";
        }
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$15, (const void *)"entry count");
        goto free_data_fclose;
      }

      for( ; cnt >= 1ul; cnt = cnt - 1ul)
      {
        struct anonymous$62 fe;
        struct anonymous$63 fttlts = { .ttl=(signed long int)0, .ts=(signed long int)0 };
        unsigned char nb[256l];
        unsigned int num_rrs;
        unsigned char prevtp;
        unsigned long int return_value_fread$20;
        return_value_fread$20=fread((void *)&fe, sizeof(struct anonymous$62) /*6ul*/ , (unsigned long int)1, f);
        if(!(return_value_fread$20 == 1ul))
        {
          signed int return_value_ferror$17;
          return_value_ferror$17=ferror(f);
          char *tmp_if_expr$19;
          if(!(return_value_ferror$17 == 0))
            tmp_if_expr$19 = "Error";

          else
          {
            return_value_feof$18=feof(f);
            tmp_if_expr$19 = return_value_feof$18 != 0 ? "EOF" : "Incomplete item";
          }
          log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$19, (const void *)"cache entry header");
          goto free_data_fclose;
        }

        if(!((1 & (signed int)fe.flags) == 0))
        {
          unsigned long int return_value_fread$24;
          return_value_fread$24=fread((void *)&fttlts, sizeof(struct anonymous$63) /*16ul*/ , (unsigned long int)1, f);
          if(!(return_value_fread$24 == 1ul))
          {
            signed int return_value_ferror$21;
            return_value_ferror$21=ferror(f);
            char *tmp_if_expr$23;
            if(!(return_value_ferror$21 == 0))
              tmp_if_expr$23 = "Error";

            else
            {
              return_value_feof$22=feof(f);
              tmp_if_expr$23 = return_value_feof$22 != 0 ? "EOF" : "Incomplete item";
            }
            log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$23, (const void *)"cache TTL and timestamp");
            goto free_data_fclose;
          }

        }

        if(!(fe.qlen == 0))
        {
          signed int i;
          unsigned long int return_value_fread$28;
          return_value_fread$28=fread((void *)nb, (unsigned long int)fe.qlen, (unsigned long int)1, f);
          if(!(return_value_fread$28 == 1ul))
          {
            signed int return_value_ferror$25;
            return_value_ferror$25=ferror(f);
            char *tmp_if_expr$27;
            if(!(return_value_ferror$25 == 0))
              tmp_if_expr$27 = "Error";

            else
            {
              return_value_feof$26=feof(f);
              tmp_if_expr$27 = return_value_feof$26 != 0 ? "EOF" : "Incomplete item";
            }
            log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$27, (const void *)"domain name");
            goto free_data_fclose;
          }

          i = 0;
          while(!(i >= (signed int)fe.qlen))
          {
            unsigned int lb = (unsigned int)nb[(signed long int)i];
            _Bool tmp_if_expr$29;
            if(lb == 0u || lb >= 64u)
              tmp_if_expr$29 = (_Bool)1;

            else
            {
              i = i + (signed int)(lb + (unsigned int)1);
              tmp_if_expr$29 = i > (signed int)fe.qlen ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$29)
            {
              log_message(4, "Invalid domain name encountered while reading disk cache file.");
              goto free_data_fclose;
            }

          }
        }

        nb[(signed long int)fe.qlen] = (unsigned char)0;
        signed int return_value_init_cent$30;
        return_value_init_cent$30=init_cent(&ce, nb, fttlts.ttl, fttlts.ts, (unsigned int)fe.flags);
        if(return_value_init_cent$30 == 0)
          goto free_data_fclose_exit;

        ce.c_ns = fe.c_ns;
        ce.c_soa = fe.c_soa;
        prevtp = (unsigned char)0;
        num_rrs = (unsigned int)fe.num_rrs;
        for( ; !(num_rrs == 0u); num_rrs = num_rrs - 1u)
        {
          struct anonymous$61 sh;
          unsigned int num_rr;
          unsigned long int return_value_fread$34;
          return_value_fread$34=fread((void *)&sh, sizeof(struct anonymous$61) /*20ul*/ , (unsigned long int)1, f);
          if(!(return_value_fread$34 == 1ul))
          {
            signed int return_value_ferror$31;
            return_value_ferror$31=ferror(f);
            char *tmp_if_expr$33;
            if(!(return_value_ferror$31 == 0))
              tmp_if_expr$33 = "Error";

            else
            {
              return_value_feof$32=feof(f);
              tmp_if_expr$33 = return_value_feof$32 != 0 ? "EOF" : "Incomplete item";
            }
            log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$33, (const void *)"rr header");
            goto free_cent_data_fclose;
          }

          _Bool tmp_if_expr$35;
          if((signed int)sh.tp >= 52 || !((signed int)sh.tp >= 1))
            tmp_if_expr$35 = (_Bool)1;

          else
            tmp_if_expr$35 = (signed int)rrlkuptab[(signed long int)((signed int)sh.tp - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$35)
          {
            log_message(4, "Invalid rr type encountered while reading disk cache file.");
            goto free_data_fclose;
          }

          if((signed int)prevtp >= (signed int)sh.tp)
          {
            log_message(4, "Unexpected rr type encountered (not in strict ascending order) while reading disk cache file.");
            goto free_data_fclose;
          }

          prevtp = sh.tp;
          signed int return_value_add_cent_rrset_by_type$36;
          return_value_add_cent_rrset_by_type$36=add_cent_rrset_by_type(&ce, (signed int)sh.tp, sh.ttl, sh.ts, (unsigned int)sh.flags);
          if(return_value_add_cent_rrset_by_type$36 == 0)
            goto free_cent_data_fclose_exit;

          num_rr = (unsigned int)sh.num_rr;
          for( ; !(num_rr == 0u); num_rr = num_rr - 1u)
          {
            struct anonymous$60 rr;
            unsigned long int return_value_fread$40;
            return_value_fread$40=fread((void *)&rr, sizeof(struct anonymous$60) /*2ul*/ , (unsigned long int)1, f);
            if(!(return_value_fread$40 == 1ul))
            {
              signed int return_value_ferror$37;
              return_value_ferror$37=ferror(f);
              char *tmp_if_expr$39;
              if(!(return_value_ferror$37 == 0))
                tmp_if_expr$39 = "Error";

              else
              {
                return_value_feof$38=feof(f);
                tmp_if_expr$39 = return_value_feof$38 != 0 ? "EOF" : "Incomplete item";
              }
              log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$39, (const void *)"rr data length");
              goto free_cent_data_fclose;
            }

            if(!(dtsz >= (signed int)rr.rdlen))
            {
              unsigned char *tmp;
              dtsz = (signed int)rr.rdlen;
              void *return_value_realloc$41;
              return_value_realloc$41=realloc((void *)data, (unsigned long int)dtsz);
              tmp = (unsigned char *)return_value_realloc$41;
              if(tmp == ((unsigned char *)NULL))
                goto free_cent_data_fclose_exit;

              data = tmp;
            }

            if(!(rr.rdlen == 0))
            {
              return_value_fread$45=fread((void *)data, (unsigned long int)rr.rdlen, (unsigned long int)1, f);
              if(!(return_value_fread$45 == 1ul))
              {
                signed int return_value_ferror$42;
                return_value_ferror$42=ferror(f);
                char *tmp_if_expr$44;
                if(!(return_value_ferror$42 == 0))
                  tmp_if_expr$44 = "Error";

                else
                {
                  return_value_feof$43=feof(f);
                  tmp_if_expr$44 = return_value_feof$43 != 0 ? "EOF" : "Incomplete item";
                }
                log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr$44, (const void *)"rr data");
                goto free_cent_data_fclose;
              }

            }

            signed int return_value_add_cent_rr$46;
            return_value_add_cent_rr$46=add_cent_rr(&ce, (signed int)sh.tp, sh.ttl, sh.ts, (unsigned int)sh.flags, (unsigned int)rr.rdlen, (void *)data);
            if(return_value_add_cent_rr$46 == 0)
              goto free_cent_data_fclose_exit;

          }
        }
        add_cache(&ce);
        free_cent(&ce);
      }
      goto free_data_fclose;

    free_cent_data_fclose:
      ;
      free_cent(&ce);
    }

  free_data_fclose:
    ;
    free((void *)data);
    fclose(f);
    lock_cache_r();
    if(insert_sort == 0)
    {
      sort_rrl();
      insert_sort = (signed short int)1;
    }

    unlock_cache_r();
    goto __CPROVER_DUMP_L55;

  free_cent_data_fclose_exit:
    ;
    free_cent(&ce);

  free_data_fclose_exit:
    ;
    free((void *)data);
  }


fclose_exit:
  ;
  fclose(f);
  log_message(3, "Out of memory in reading cache file. Exiting.");
  pdnsd_exit();

__CPROVER_DUMP_L55:
  ;
}

// read_domain
// file status.c line 148
static signed int read_domain(signed int fh, char *buf, unsigned int buflen)
{
  unsigned short int count;
  unsigned int nread;
  signed int return_value_read_short$1;
  return_value_read_short$1=read_short(fh, &count);
  if(return_value_read_short$1 == 0)
    return 0;

  else
    if(count == 65535)
      return -1;

    else
      if((unsigned int)count >= buflen)
        return 0;

      else
      {
        nread = (unsigned int)0;
        while(!(nread >= (unsigned int)count))
        {
          signed long int m;
          m=read(fh, (void *)(buf + (signed long int)nread), (unsigned long int)((unsigned int)count - nread));
          if(!(m >= 1l))
            return 0;

          nread = nread + (unsigned int)m;
        }
        buf[(signed long int)count] = (char)0;
        return 1;
      }
}

// read_hosts
// file dns.h line 291
signed int read_hosts(const char *fn, unsigned char *rns, signed long int ttl, unsigned int flags, signed int aliases, char **errstr)
{
  signed int rv = 0;
  struct _IO_FILE *f;
  char *buf;
  unsigned long int buflen = (unsigned long int)256;
  f=fopen(fn, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    signed int return_value_asprintf$3;
    return_value_asprintf$3=asprintf(errstr, "Failed to source %s: %s", fn, return_value_strerror$2);
    if(!(return_value_asprintf$3 >= 0))
      *errstr = (char *)(void *)0;

    return 0;
  }

  void *return_value_malloc$4;
  return_value_malloc$4=malloc(buflen);
  buf = (char *)return_value_malloc$4;
  signed long int return_value_getline$5;
  const unsigned short int **return_value___ctype_b_loc$8;
  const unsigned short int **return_value___ctype_b_loc$9;
  _Bool tmp_if_expr$11;
  const unsigned short int **return_value___ctype_b_loc$10;
  _Bool tmp_if_expr$17;
  const unsigned short int **return_value___ctype_b_loc$16;
  signed int return_value_feof$23;
  signed int *return_value___errno_location$20;
  char *return_value_strerror$21;
  signed int return_value_asprintf$22;
  if(buf == ((char *)NULL))
    *errstr = (char *)(void *)0;

  else
  {
    do
    {
      return_value_getline$5=getline(&buf, &buflen, f);
      if(!(return_value_getline$5 >= 0l))
        break;

      unsigned int len;
      unsigned char *p;
      unsigned char *pn;
      unsigned char *pi;
      unsigned char rhn[256l];
      signed int tp;
      signed int sz;
      union anonymous$6 a;
      char *return_value_strchr$6;
      return_value_strchr$6=strchr(buf, 35);
      p = (unsigned char *)return_value_strchr$6;
      if(!(p == ((unsigned char *)NULL)))
        *p = (unsigned char)0;

      p = (unsigned char *)buf;
      while((_Bool)1)
      {
        if(*p == 0)
          goto nextline;

        const unsigned short int **return_value___ctype_b_loc$7;
        return_value___ctype_b_loc$7=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*p]) == 0)
          break;

        p = p + 1l;
      }
      pi = p;
      do
      {
        p = p + 1l;
        if(*p == 0)
          goto nextline;

        return_value___ctype_b_loc$8=__ctype_b_loc();
      }
      while((8192 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*p]) == 0);
      *p = (unsigned char)0;
      do
      {
        p = p + 1l;
        if(*p == 0)
          goto nextline;

        return_value___ctype_b_loc$9=__ctype_b_loc();
      }
      while(!((8192 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)*p]) == 0));
      pn = p;
      do
      {
        p = p + 1l;
        if(!(*p == 0))
        {
          return_value___ctype_b_loc$10=__ctype_b_loc();
          tmp_if_expr$11 = !(((signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$11 = (_Bool)0;
      }
      while(tmp_if_expr$11);
      len = (unsigned int)(p - pn);
      const char *return_value_parsestr2rhn$12;
      return_value_parsestr2rhn$12=parsestr2rhn(pn, len, rhn);
      if(return_value_parsestr2rhn$12 == ((const char *)NULL))
      {
        signed int return_value_inet_aton$14;
        return_value_inet_aton$14=inet_aton((char *)pi, &a.ipv4);
        if(!(return_value_inet_aton$14 == 0))
        {
          tp = 1;
          sz = (signed int)sizeof(struct in_addr) /*4ul*/ ;
        }

        else
        {
          signed int return_value_inet_pton$13;
          return_value_inet_pton$13=inet_pton(10, (char *)pi, (void *)&a.ipv6);
          if(return_value_inet_pton$13 >= 1)
          {
            tp = 28;
            sz = (signed int)sizeof(struct in6_addr) /*16ul*/ ;
          }

          else
            continue;
        }
        signed int res;
        res=add_host(rhn, rns, &a, tp, sz, ttl, flags, 1);
        if(res == 0)
        {
          *errstr = (char *)(void *)0;
          goto cleanup_return;
        }

        else
          if(!(res >= 0))
            continue;

        if(!(aliases == 0))
        {

        __CPROVER_DUMP_L18:
          ;
          while(!(*p == 0))
          {
            const unsigned short int **return_value___ctype_b_loc$15;
            return_value___ctype_b_loc$15=__ctype_b_loc();
            if(!((8192 & (signed int)(*return_value___ctype_b_loc$15)[(signed long int)(signed int)*p]) == 0))
            {
              p = p + 1l;
              goto __CPROVER_DUMP_L18;
            }

            pn = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc$16=__ctype_b_loc();
                tmp_if_expr$17 = !(((signed int)(*return_value___ctype_b_loc$16)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$17 = (_Bool)0;
            }
            while(tmp_if_expr$17);
            len = (unsigned int)(p - pn);
            const char *return_value_parsestr2rhn$18;
            return_value_parsestr2rhn$18=parsestr2rhn(pn, len, rhn);
            if(!(return_value_parsestr2rhn$18 == ((const char *)NULL)))
              break;

            signed int return_value_add_host$19;
            return_value_add_host$19=add_host(rhn, rns, &a, tp, sz, ttl, flags, 0);
            if(return_value_add_host$19 == 0)
            {
              *errstr = (char *)(void *)0;
              goto cleanup_return;
            }

          }
        }

      }


    nextline:
      ;
    }
    while((_Bool)1);
    return_value_feof$23=feof(f);
    if(!(return_value_feof$23 == 0))
      rv = 1;

    else
    {
      return_value___errno_location$20=__errno_location();
      return_value_strerror$21=strerror(*return_value___errno_location$20);
      return_value_asprintf$22=asprintf(errstr, "Failed to source %s: %s", fn, return_value_strerror$21);
      if(!(return_value_asprintf$22 >= 0))
        *errstr = (char *)(void *)0;

    }

  cleanup_return:
    ;
    free((void *)buf);
  }

fclose_return:
  ;
  fclose(f);
  return rv;
}

// read_long
// file status.c line 104
static signed int read_long(signed int fh, unsigned int *res)
{
  unsigned int cmd;
  signed long int return_value_read$1;
  return_value_read$1=read(fh, (void *)&cmd, sizeof(unsigned int) /*4ul*/ );
  if(!((unsigned long int)return_value_read$1 == sizeof(unsigned int) /*4ul*/ ))
    return 0;

  else
  {
    *res=ntohl(cmd);
    return 1;
  }
}

// read_resolv_conf
// file conf-parser.c line 2009
static signed int read_resolv_conf(const char *fn, struct anonymous$19 **ata, char **errstr)
{
  signed int rv = 0;
  struct _IO_FILE *f;
  char *buf;
  unsigned long int buflen = (unsigned long int)256;
  unsigned int linenr = (unsigned int)0;
  f=fopen(fn, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    signed int return_value_asprintf$3;
    return_value_asprintf$3=asprintf(errstr, "Failed to open %s: %s", fn, return_value_strerror$2);
    if(!(return_value_asprintf$3 >= 0))
      *errstr = (char *)(void *)0;

    return 0;
  }

  void *return_value_malloc$4;
  return_value_malloc$4=malloc(buflen);
  buf = (char *)return_value_malloc$4;
  signed long int return_value_getline$5;
  const unsigned short int **return_value___ctype_b_loc$7;
  signed int return_value_strncmp$12;
  const unsigned short int **return_value___ctype_b_loc$8;
  _Bool tmp_if_expr$10;
  const unsigned short int **return_value___ctype_b_loc$9;
  signed int return_value_feof$16;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  signed int return_value_asprintf$15;
  if(buf == ((char *)NULL))
    *errstr = (char *)(void *)0;

  else
  {
    do
    {
      return_value_getline$5=getline(&buf, &buflen, f);
      if(!(return_value_getline$5 >= 0l))
        break;

      unsigned long int len;
      char *p;
      char *ps;
      linenr = linenr + 1u;
      p = buf;
      for( ; (_Bool)1; p = p + 1l)
      {
        if(*p == 0)
          goto nextline;

        const unsigned short int **return_value___ctype_b_loc$6;
        return_value___ctype_b_loc$6=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*p]) == 0)
          break;

      }
      ps = p;
      do
      {
        p = p + 1l;
        if(*p == 0)
          goto nextline;

        return_value___ctype_b_loc$7=__ctype_b_loc();
      }
      while((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*p]) == 0);
      len = (unsigned long int)(p - ps);
      if(len == 10ul)
      {
        return_value_strncmp$12=strncmp(ps, "nameserver", len);
        if(return_value_strncmp$12 == 0)
        {
          const char *errmsg;
          do
          {
            p = p + 1l;
            if(*p == 0)
              goto nextline;

            return_value___ctype_b_loc$8=__ctype_b_loc();
          }
          while(!((8192 & (signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*p]) == 0));
          ps = p;
          do
          {
            p = p + 1l;
            if(!(*p == 0))
            {
              return_value___ctype_b_loc$9=__ctype_b_loc();
              tmp_if_expr$10 = !(((signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$10 = (_Bool)0;
          }
          while(tmp_if_expr$10);
          len = (unsigned long int)(p - ps);
          const signed long int errmsg$array_size0 = (signed long int)(len + (unsigned long int)1);
          char ipstr[errmsg$array_size0];
          memcpy((void *)ipstr, (const void *)ps, len);
          ipstr[(signed long int)len] = (char)0;
          errmsg=addr_add(ata, ipstr);
          if(!(errmsg == ((const char *)NULL)))
          {
            signed int return_value_asprintf$11;
            return_value_asprintf$11=asprintf(errstr, "%s in line %u of file %s", errmsg, linenr, fn);
            if(!(return_value_asprintf$11 >= 0))
              *errstr = (char *)(void *)0;

            goto cleanup_return;
          }

        }

      }


    nextline:
      ;
    }
    while((_Bool)1);
    return_value_feof$16=feof(f);
    if(!(return_value_feof$16 == 0))
      rv = 1;

    else
    {
      return_value___errno_location$13=__errno_location();
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      return_value_asprintf$15=asprintf(errstr, "Failed to read %s: %s", fn, return_value_strerror$14);
      if(!(return_value_asprintf$15 >= 0))
        *errstr = (char *)(void *)0;

    }

  cleanup_return:
    ;
    free((void *)buf);
  }

fclose_return:
  ;
  fclose(f);
  return rv;
}

// read_short
// file status.c line 91
static signed int read_short(signed int fh, unsigned short int *res)
{
  unsigned short int cmd;
  signed long int return_value_read$1;
  return_value_read$1=read(fh, (void *)&cmd, sizeof(unsigned short int) /*2ul*/ );
  if(!((unsigned long int)return_value_read$1 == sizeof(unsigned short int) /*2ul*/ ))
    return 0;

  else
  {
    *res=ntohs(cmd);
    return 1;
  }
}

// realloc_or_cleanup
// file dns_query.c line 784
static inline void * realloc_or_cleanup(void *ptr, unsigned long int size)
{
  void *retval;
  retval=realloc(ptr, size);
  if(retval == NULL)
    free(ptr);

  return retval;
}

// reject_add
// file conf-parser.c line 1926
static const char * reject_add(struct anonymous$7 *serv, const char *ipstr)
{
  char *slash;
  slash=strchr(ipstr, 47);
  signed int mlen = 0;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(!(slash == ((char *)NULL)))
  {
    char *tmp_post$1 = slash;
    slash = slash + 1l;
    *tmp_post$1 = (char)0;
    if(!(*slash == 0))
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*slash]) == 0))
      {
        char *endptr;
        signed int l;
        signed long int return_value_strtol$2;
        return_value_strtol$2=strtol(slash, &endptr, 10);
        l = (signed int)return_value_strtol$2;
        if(*endptr == 0)
        {
          mlen = l;
          slash = (char *)(void *)0;
        }

      }

    }

  }

  else
    mlen = 128;
  struct anonymous$11 am;
  am.mask.s_addr=mk_netmask4(mlen);
  signed int return_value_inet_aton$7;
  return_value_inet_aton$7=inet_aton(ipstr, &am.a);
  signed int return_value_inet_aton$5;
  if(!(return_value_inet_aton$7 == 0))
  {
    _Bool tmp_if_expr$6;
    if(slash == ((char *)NULL))
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_inet_aton$5=inet_aton(slash, &am.mask);
      tmp_if_expr$6 = return_value_inet_aton$5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      struct anonymous$3 *return_value_da_grow1$4;
      return_value_da_grow1$4=da_grow1((struct anonymous$3 *)serv->reject_a4, (unsigned long int)((struct anonymous$10 *)0)->elem, sizeof(struct anonymous$11) /*8ul*/ , (void (*)(void *))(void *)0);
      serv->reject_a4 = (struct anonymous$10 *)return_value_da_grow1$4;
      if(serv->reject_a4 == ((struct anonymous$10 *)NULL))
        return "out of memory!";

      serv->reject_a4->elem[(signed long int)(serv->reject_a4->nel - (unsigned long int)1)] = am;
      return (const char *)(void *)0;
    }

  }

  struct anonymous$13 reject_add$$1$$3$$am;
  mk_netmask6(&reject_add$$1$$3$$am.mask, mlen);
  signed int return_value_inet_pton$11;
  return_value_inet_pton$11=inet_pton(10, ipstr, (void *)&reject_add$$1$$3$$am.a);
  signed int return_value_inet_pton$9;
  if(return_value_inet_pton$11 >= 1)
  {
    _Bool tmp_if_expr$10;
    if(slash == ((char *)NULL))
      tmp_if_expr$10 = (_Bool)1;

    else
    {
      return_value_inet_pton$9=inet_pton(10, slash, (void *)&reject_add$$1$$3$$am.mask);
      tmp_if_expr$10 = return_value_inet_pton$9 > 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$10)
    {
      struct anonymous$3 *return_value_da_grow1$8;
      return_value_da_grow1$8=da_grow1((struct anonymous$3 *)serv->reject_a6, (unsigned long int)((struct anonymous$12 *)0)->elem, sizeof(struct anonymous$13) /*32ul*/ , (void (*)(void *))(void *)0);
      serv->reject_a6 = (struct anonymous$12 *)return_value_da_grow1$8;
      if(serv->reject_a6 == ((struct anonymous$12 *)NULL))
        return "out of memory!";

      serv->reject_a6->elem[(signed long int)(serv->reject_a6->nel - (unsigned long int)1)] = reject_add$$1$$3$$am;
      return (const char *)(void *)0;
    }

  }

  return "bad IP address";
}

// reload_config_file
// file conff.c line 222
signed int reload_config_file(const char *nm, char **errstr)
{
  struct anonymous$21 global_new;
  struct anonymous$18 *servers_new;
  global_new = global;
  global_new.cache_dir = (char *)(void *)0;
  global_new.pidfile = (char *)(void *)0;
  global_new.scheme_file = (char *)(void *)0;
  global_new.deleg_only_zones = (struct anonymous$30 *)(void *)0;
  global_new.onquery = (char)0;
  servers_new = (struct anonymous$18 *)(void *)0;
  signed int return_value_read_config_file$16;
  return_value_read_config_file$16=read_config_file(nm, &global_new, &servers_new, 0, errstr);
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  if(!(return_value_read_config_file$16 == 0))
  {
    if(!(global_new.cache_dir == ((char *)NULL)))
    {
      return_value_strcmp$1=strcmp(global_new.cache_dir, global.cache_dir);
      if(!(return_value_strcmp$1 == 0))
      {
        *errstr=strdup("Cannot reload config file: the specified cache_dir directory has changed.\nTry restarting pdnsd instead.");
        goto cleanup_return;
      }

    }

    if(!(global_new.pidfile == ((char *)NULL)))
    {
      _Bool tmp_if_expr$3;
      if(global.pidfile == ((char *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strcmp$2=strcmp(global_new.pidfile, global.pidfile);
        tmp_if_expr$3 = return_value_strcmp$2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
      {
        *errstr=strdup("Cannot reload config file: the specified pid_file has changed.\nTry restarting pdnsd instead.");
        goto cleanup_return;
      }

    }

    if(!(global_new.scheme_file == ((char *)NULL)))
    {
      return_value_strcmp$4=strcmp(global_new.scheme_file, global.scheme_file);
      if(!(return_value_strcmp$4 == 0))
      {
        *errstr=strdup("Cannot reload config file: the specified scheme_file has changed.\nTry restarting pdnsd instead.");
        goto cleanup_return;
      }

    }

    if(!(global_new.port == global.port))
    {
      *errstr=strdup("Cannot reload config file: the specified server_port has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    signed int tmp_if_expr$8;
    if(!(run_ipv4 == 0))
      tmp_if_expr$8 = (signed int)(((struct in_addr *)&global_new.a)->s_addr == ((struct in_addr *)&global.a)->s_addr);

    else
    {
      if(*((unsigned int *)&global_new.a) == *((unsigned int *)&global.a))
        tmp_if_expr$5 = ((unsigned int *)(struct in6_addr *)&global_new.a)[(signed long int)1] == ((unsigned int *)(struct in6_addr *)&global.a)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = ((unsigned int *)(struct in6_addr *)&global_new.a)[(signed long int)2] == ((unsigned int *)(struct in6_addr *)&global.a)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = ((unsigned int *)(struct in6_addr *)&global_new.a)[(signed long int)3] == ((unsigned int *)(struct in6_addr *)&global.a)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      tmp_if_expr$8 = (signed int)tmp_if_expr$7;
    }
    if(tmp_if_expr$8 == 0)
    {
      *errstr=strdup("Cannot reload config file: the specified interface address (server_ip) has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    _Bool tmp_if_expr$9;
    if(*((unsigned int *)&global_new.ipv4_6_prefix) == *((unsigned int *)&global.ipv4_6_prefix))
      tmp_if_expr$9 = ((unsigned int *)&global_new.ipv4_6_prefix)[(signed long int)1] == ((unsigned int *)&global.ipv4_6_prefix)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    _Bool tmp_if_expr$10;
    if(tmp_if_expr$9)
      tmp_if_expr$10 = ((unsigned int *)&global_new.ipv4_6_prefix)[(signed long int)2] == ((unsigned int *)&global.ipv4_6_prefix)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    _Bool tmp_if_expr$11;
    if(tmp_if_expr$10)
      tmp_if_expr$11 = ((unsigned int *)&global_new.ipv4_6_prefix)[(signed long int)3] == ((unsigned int *)&global.ipv4_6_prefix)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$11 = (_Bool)0;
    if(!tmp_if_expr$11)
    {
      *errstr=strdup("Cannot reload config file: the specified ipv4_6_prefix has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    signed int return_value_strcmp$12;
    return_value_strcmp$12=strcmp(global_new.run_as, global.run_as);
    if(!(return_value_strcmp$12 == 0))
    {
      *errstr=strdup("Cannot reload config file: the specified run_as id has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.daemon == global.daemon))
    {
      *errstr=strdup("Cannot reload config file: the daemon option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.debug == global.debug))
    {
      *errstr=strdup("Cannot reload config file: the debug option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.stat_pipe == global.stat_pipe))
    {
      *errstr=strdup("Cannot reload config file: the status_ctl option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.notcp == global.notcp))
    {
      *errstr=strdup("Cannot reload config file: the tcp_server option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.strict_suid == global.strict_suid))
    {
      *errstr=strdup("Cannot reload config file: the strict_setuid option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.ctl_perms == global.ctl_perms))
    {
      *errstr=strdup("Cannot reload config file: the specified ctl_perms has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(ping6_isocket == -1 && ping_isocket == -1)
    {
      signed int i;
      signed int n;
      unsigned int return_value_da_nel$13;
      return_value_da_nel$13=da_nel$link1((struct anonymous$3 *)servers_new);
      n = (signed int)return_value_da_nel$13;
      i = 0;
      for( ; !(i >= n); i = i + 1)
        if((signed int)servers_new->elem[(signed long int)i].uptest == 8)
        {
          signed int return_value_asprintf$14;
          return_value_asprintf$14=asprintf(errstr, "Cannot reload config file: the ping socket is not initialized and the new config contains uptest=ping in server section %i.\nTry restarting pdnsd instead.", i);
          if(!(return_value_asprintf$14 >= 0))
            *errstr = (char *)(void *)0;

          goto cleanup_return;
        }

    }

    signed int return_value_exclusive_lock_server_data$15;
    return_value_exclusive_lock_server_data$15=exclusive_lock_server_data(60);
    if(return_value_exclusive_lock_server_data$15 == 0)
    {
      *errstr=strdup("Cannot reload config file: Timed out while waiting for access to config data.");
      goto cleanup_return;
    }

    free((void *)global_new.cache_dir);
    global_new.cache_dir = global.cache_dir;
    free((void *)global_new.pidfile);
    global_new.pidfile = global.pidfile;
    free((void *)global_new.scheme_file);
    global_new.scheme_file = global.scheme_file;
    free_zones(global.deleg_only_zones);
    global = global_new;
    free_server_data(servers);
    servers = servers_new;
    exclusive_unlock_server_data(1);
    return 1;
  }


cleanup_return:
  ;
  free((void *)global_new.cache_dir);
  free((void *)global_new.pidfile);
  free((void *)global_new.scheme_file);
  free_zones(global_new.deleg_only_zones);
  free_server_data(servers_new);
  return 0;
}

// remove_opt_pseudo_rr
// file dns_answer.c line 462
unsigned long int remove_opt_pseudo_rr(struct anonymous$28 *ans, unsigned long int sz)
{
  unsigned short int acnt;
  acnt=ntohs(ans->hdr.arcount);
  unsigned short int type;
  unsigned char *ptr;
  if(!(sz >= 23ul) || !((signed int)acnt >= 1))
    return (unsigned long int)0;

  else
  {
    sz = sz - (unsigned long int)(1 + 10);
    ptr = (unsigned char *)&ans->hdr + (signed long int)sz;
    unsigned char *tmp_post$1 = ptr;
    ptr = ptr + 1l;
    if(!(*tmp_post$1 == 0))
      return (unsigned long int)0;

    else
    {
      do
      {
        unsigned short int t_s;
        const unsigned char *t_cp = (const unsigned char *)ptr;
        const unsigned char *tmp_post$2 = t_cp;
        t_cp = t_cp + 1l;
        t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$2 << 8);
        const unsigned char *tmp_post$3 = t_cp;
        t_cp = t_cp + 1l;
        t_s = t_s | (unsigned short int)*tmp_post$3;
        type = t_s;
        ptr = (unsigned char *)(void *)t_cp;
      }
      while((_Bool)0);
      if(!((signed int)type == 41))
        return (unsigned long int)0;

      else
      {
        ans->hdr.arcount=htons((unsigned short int)((signed int)acnt - 1));
        return sz;
      }
    }
  }
}

// remove_rrl
// file cache.c line 953
static void remove_rrl(struct rr_lent_s *le)
{
  struct rr_lent_s *next = le->next;
  struct rr_lent_s *prev = le->prev;
  if(!(next == ((struct rr_lent_s *)NULL)))
    next->prev = prev;

  else
    rrset_l_tail = prev;
  if(!(prev == ((struct rr_lent_s *)NULL)))
    prev->next = next;

  else
    rrset_l = next;
  free((void *)le);
}

// report_cache_stat
// file cache.h line 167
signed int report_cache_stat(signed int f)
{
  signed long int mc = (signed long int)global.perm_cache * (signed long int)1024 + (signed long int)10240;
  signed int _retval;
  _retval=fsprintf(f, "\nCache status:\n=============\n");
  if(!(_retval >= 0))
    return _retval;

  else
  {
    signed int report_cache_stat$$1$$2$$_retval;
    report_cache_stat$$1$$2$$_retval=fsprintf(f, "%ld kB maximum disk cache size.\n", global.perm_cache);
    if(!(report_cache_stat$$1$$2$$_retval >= 0))
      return report_cache_stat$$1$$2$$_retval;

    else
    {
      signed int report_cache_stat$$1$$3$$_retval;
      report_cache_stat$$1$$3$$_retval=fsprintf(f, "%ld of %ld bytes (%.3g%%) memory cache used in %ld entries (avg %.5g bytes/entry).\n", cache_size, mc, ((double)cache_size / (double)mc) * (double)100, ent_num, (double)cache_size / (double)ent_num);
      if(!(report_cache_stat$$1$$3$$_retval >= 0))
        return report_cache_stat$$1$$3$$_retval;

      else
        return 0;
    }
  }
}

// report_conf_stat
// file conff.c line 399
signed int report_conf_stat(signed int f)
{
  signed int i;
  signed int n;
  signed int retval = 0;
  signed int report_conf_stat$$1$$1$$_retval;
  report_conf_stat$$1$$1$$_retval=fsprintf(f, "\nConfiguration:\n==============\nGlobal:\n-------\n");
  unsigned int return_value_da_nel$10;
  if(!(report_conf_stat$$1$$1$$_retval >= 0))
    return report_conf_stat$$1$$1$$_retval;

  else
  {
    signed int report_conf_stat$$1$$2$$_retval;
    report_conf_stat$$1$$2$$_retval=fsprintf(f, "\tCache size: %li kB\n", global.perm_cache);
    if(!(report_conf_stat$$1$$2$$_retval >= 0))
      return report_conf_stat$$1$$2$$_retval;

    else
    {
      signed int report_conf_stat$$1$$3$$_retval;
      report_conf_stat$$1$$3$$_retval=fsprintf(f, "\tServer directory: %s\n", global.cache_dir);
      if(!(report_conf_stat$$1$$3$$_retval >= 0))
        return report_conf_stat$$1$$3$$_retval;

      else
      {
        signed int report_conf_stat$$1$$4$$_retval;
        report_conf_stat$$1$$4$$_retval=fsprintf(f, "\tScheme file (for Linux pcmcia support): %s\n", global.scheme_file);
        if(!(report_conf_stat$$1$$4$$_retval >= 0))
          return report_conf_stat$$1$$4$$_retval;

        else
        {
          signed int report_conf_stat$$1$$5$$_retval;
          report_conf_stat$$1$$5$$_retval=fsprintf(f, "\tServer port: %i\n", global.port);
          if(!(report_conf_stat$$1$$5$$_retval >= 0))
            return report_conf_stat$$1$$5$$_retval;

          else
          {
            char report_conf_stat$$1$$6$$buf[46l];
            signed int report_conf_stat$$1$$6$$1$$_retval;
            const char *return_value_pdnsd_a2str$1;
            return_value_pdnsd_a2str$1=pdnsd_a2str(&global.a, report_conf_stat$$1$$6$$buf, 46);
            report_conf_stat$$1$$6$$1$$_retval=fsprintf(f, "\tServer IP (%s=any available one): %s\n", run_ipv4 != 0 ? "0.0.0.0" : "::", return_value_pdnsd_a2str$1);
            if(!(report_conf_stat$$1$$6$$1$$_retval >= 0))
              return report_conf_stat$$1$$6$$1$$_retval;

            else
            {
              signed int return_value_is_inaddr_any$3;
              return_value_is_inaddr_any$3=is_inaddr_any$link1(&global.out_a);
              if(return_value_is_inaddr_any$3 == 0)
              {
                signed int report_conf_stat$$1$$6$$2$$1$$_retval;
                const char *return_value_pdnsd_a2str$2;
                return_value_pdnsd_a2str$2=pdnsd_a2str(&global.out_a, report_conf_stat$$1$$6$$buf, 46);
                report_conf_stat$$1$$6$$2$$1$$_retval=fsprintf(f, "\tIP bound to interface used for querying remote servers: %s\n", return_value_pdnsd_a2str$2);
                if(!(report_conf_stat$$1$$6$$2$$1$$_retval >= 0))
                  return report_conf_stat$$1$$6$$2$$1$$_retval;

              }

              if(run_ipv4 == 0)
              {
                char report_conf_stat$$1$$7$$buf[46l];
                signed int report_conf_stat$$1$$7$$1$$_retval;
                const char *return_value_inet_ntop$4;
                return_value_inet_ntop$4=inet_ntop(10, (const void *)&global.ipv4_6_prefix, report_conf_stat$$1$$7$$buf, (unsigned int)46);
                report_conf_stat$$1$$7$$1$$_retval=fsprintf(f, "\tIPv4 to IPv6 prefix: %s\n", (_Bool)return_value_inet_ntop$4 ? return_value_inet_ntop$4 : "?.?.?.?");
                if(!(report_conf_stat$$1$$7$$1$$_retval >= 0))
                  return report_conf_stat$$1$$7$$1$$_retval;

              }

              signed int report_conf_stat$$1$$8$$_retval;
              report_conf_stat$$1$$8$$_retval=fsprintf(f, "\tIgnore cache when link is down: %s\n", global.lndown_kluge != 0 ? "on" : "off");
              if(!(report_conf_stat$$1$$8$$_retval >= 0))
                return report_conf_stat$$1$$8$$_retval;

              else
              {
                signed int report_conf_stat$$1$$9$$_retval;
                report_conf_stat$$1$$9$$_retval=fsprintf(f, "\tMaximum ttl: %li\n", (signed long int)global.max_ttl);
                if(!(report_conf_stat$$1$$9$$_retval >= 0))
                  return report_conf_stat$$1$$9$$_retval;

                else
                {
                  signed int report_conf_stat$$1$$10$$_retval;
                  report_conf_stat$$1$$10$$_retval=fsprintf(f, "\tMinimum ttl: %li\n", (signed long int)global.min_ttl);
                  if(!(report_conf_stat$$1$$10$$_retval >= 0))
                    return report_conf_stat$$1$$10$$_retval;

                  else
                  {
                    signed int report_conf_stat$$1$$11$$_retval;
                    report_conf_stat$$1$$11$$_retval=fsprintf(f, "\tNegative ttl: %li\n", (signed long int)global.neg_ttl);
                    if(!(report_conf_stat$$1$$11$$_retval >= 0))
                      return report_conf_stat$$1$$11$$_retval;

                    else
                    {
                      signed int report_conf_stat$$1$$12$$_retval;
                      const char *return_value_const_name$5;
                      return_value_const_name$5=const_name((signed int)global.neg_rrs_pol);
                      report_conf_stat$$1$$12$$_retval=fsprintf(f, "\tNegative RRS policy: %s\n", return_value_const_name$5);
                      if(!(report_conf_stat$$1$$12$$_retval >= 0))
                        return report_conf_stat$$1$$12$$_retval;

                      else
                      {
                        signed int report_conf_stat$$1$$13$$_retval;
                        const char *return_value_const_name$6;
                        return_value_const_name$6=const_name((signed int)global.neg_domain_pol);
                        report_conf_stat$$1$$13$$_retval=fsprintf(f, "\tNegative domain policy: %s\n", return_value_const_name$6);
                        if(!(report_conf_stat$$1$$13$$_retval >= 0))
                          return report_conf_stat$$1$$13$$_retval;

                        else
                        {
                          signed int report_conf_stat$$1$$14$$_retval;
                          report_conf_stat$$1$$14$$_retval=fsprintf(f, "\tRun as: %s\n", (const void *)global.run_as);
                          if(!(report_conf_stat$$1$$14$$_retval >= 0))
                            return report_conf_stat$$1$$14$$_retval;

                          else
                          {
                            signed int report_conf_stat$$1$$15$$_retval;
                            report_conf_stat$$1$$15$$_retval=fsprintf(f, "\tStrict run as: %s\n", global.strict_suid != 0 ? "on" : "off");
                            if(!(report_conf_stat$$1$$15$$_retval >= 0))
                              return report_conf_stat$$1$$15$$_retval;

                            else
                            {
                              signed int report_conf_stat$$1$$16$$_retval;
                              report_conf_stat$$1$$16$$_retval=fsprintf(f, "\tUse NSS: %s\n", global.use_nss != 0 ? "on" : "off");
                              if(!(report_conf_stat$$1$$16$$_retval >= 0))
                                return report_conf_stat$$1$$16$$_retval;

                              else
                              {
                                signed int report_conf_stat$$1$$17$$_retval;
                                report_conf_stat$$1$$17$$_retval=fsprintf(f, "\tParanoid mode (cache pollution prevention): %s\n", global.paranoid != 0 ? "on" : "off");
                                if(!(report_conf_stat$$1$$17$$_retval >= 0))
                                  return report_conf_stat$$1$$17$$_retval;

                                else
                                {
                                  signed int report_conf_stat$$1$$18$$_retval;
                                  report_conf_stat$$1$$18$$_retval=fsprintf(f, "\tControl socket permissions (mode): %o\n", global.ctl_perms);
                                  if(!(report_conf_stat$$1$$18$$_retval >= 0))
                                    return report_conf_stat$$1$$18$$_retval;

                                  else
                                  {
                                    signed int report_conf_stat$$1$$19$$_retval;
                                    report_conf_stat$$1$$19$$_retval=fsprintf(f, "\tMaximum parallel queries served: %i\n", global.proc_limit);
                                    if(!(report_conf_stat$$1$$19$$_retval >= 0))
                                      return report_conf_stat$$1$$19$$_retval;

                                    else
                                    {
                                      signed int report_conf_stat$$1$$20$$_retval;
                                      report_conf_stat$$1$$20$$_retval=fsprintf(f, "\tMaximum queries queued for serving: %i\n", global.procq_limit);
                                      if(!(report_conf_stat$$1$$20$$_retval >= 0))
                                        return report_conf_stat$$1$$20$$_retval;

                                      else
                                      {
                                        signed int report_conf_stat$$1$$21$$_retval;
                                        report_conf_stat$$1$$21$$_retval=fsprintf(f, "\tGlobal timeout setting: %li\n", (signed long int)global.timeout);
                                        if(!(report_conf_stat$$1$$21$$_retval >= 0))
                                          return report_conf_stat$$1$$21$$_retval;

                                        else
                                        {
                                          signed int report_conf_stat$$1$$22$$_retval;
                                          report_conf_stat$$1$$22$$_retval=fsprintf(f, "\tParallel queries increment: %i\n", global.par_queries);
                                          if(!(report_conf_stat$$1$$22$$_retval >= 0))
                                            return report_conf_stat$$1$$22$$_retval;

                                          else
                                          {
                                            signed int report_conf_stat$$1$$23$$_retval;
                                            report_conf_stat$$1$$23$$_retval=fsprintf(f, "\tRandomize records in answer: %s\n", global.rnd_recs != 0 ? "on" : "off");
                                            if(!(report_conf_stat$$1$$23$$_retval >= 0))
                                              return report_conf_stat$$1$$23$$_retval;

                                            else
                                            {
                                              signed int _retval;
                                              const char *return_value_const_name$7;
                                              return_value_const_name$7=const_name(global.query_method);
                                              _retval=fsprintf(f, "\tQuery method: %s\n", return_value_const_name$7);
                                              if(!(_retval >= 0))
                                                return _retval;

                                              else
                                              {
                                                signed int query_port_start = global.query_port_start;
                                                if(query_port_start == -1)
                                                {
                                                  signed int report_conf_stat$$1$$25$$1$$1$$_retval;
                                                  report_conf_stat$$1$$25$$1$$1$$_retval=fsprintf(f, "\tQuery port start: (let kernel choose)\n");
                                                  if(!(report_conf_stat$$1$$25$$1$$1$$_retval >= 0))
                                                    return report_conf_stat$$1$$25$$1$$1$$_retval;

                                                }

                                                else
                                                {
                                                  signed int report_conf_stat$$1$$25$$2$$1$$_retval;
                                                  report_conf_stat$$1$$25$$2$$1$$_retval=fsprintf(f, "\tQuery port start: %i\n", query_port_start);
                                                  if(!(report_conf_stat$$1$$25$$2$$1$$_retval >= 0))
                                                    return report_conf_stat$$1$$25$$2$$1$$_retval;

                                                  signed int report_conf_stat$$1$$25$$2$$2$$_retval;
                                                  report_conf_stat$$1$$25$$2$$2$$_retval=fsprintf(f, "\tQuery port end: %i\n", global.query_port_end);
                                                  if(!(report_conf_stat$$1$$25$$2$$2$$_retval >= 0))
                                                    return report_conf_stat$$1$$25$$2$$2$$_retval;

                                                }
                                                signed int report_conf_stat$$1$$26$$_retval;
                                                report_conf_stat$$1$$26$$_retval=fsprintf(f, "\tTCP server thread: %s\n", global.notcp != 0 ? "off" : "on");
                                                if(!(report_conf_stat$$1$$26$$_retval >= 0))
                                                  return report_conf_stat$$1$$26$$_retval;

                                                else
                                                {
                                                  if(global.notcp == 0)
                                                  {
                                                    signed int report_conf_stat$$1$$27$$1$$_retval;
                                                    report_conf_stat$$1$$27$$1$$_retval=fsprintf(f, "\tTCP query timeout: %li\n", (signed long int)global.tcp_qtimeout);
                                                    if(!(report_conf_stat$$1$$27$$1$$_retval >= 0))
                                                      return report_conf_stat$$1$$27$$1$$_retval;

                                                  }

                                                  signed int report_conf_stat$$1$$28$$_retval;
                                                  report_conf_stat$$1$$28$$_retval=fsprintf(f, "\tMaximum udp buffer size: %i\n", global.udpbufsize);
                                                  if(!(report_conf_stat$$1$$28$$_retval >= 0))
                                                    return report_conf_stat$$1$$28$$_retval;

                                                  else
                                                  {
                                                    lock_server_data();
                                                    signed int rv;
                                                    rv=fsprintf(f, "\tDelegation-only zones: ");
                                                    if(!(rv >= 0))
                                                      retval = rv;

                                                    else
                                                    {
                                                      if(global.deleg_only_zones == ((struct anonymous$30 *)NULL))
                                                      {
                                                        signed int report_conf_stat$$1$$30$$rv;
                                                        report_conf_stat$$1$$30$$rv=fsprintf(f, "(none)\n");
                                                        if(!(report_conf_stat$$1$$30$$rv >= 0))
                                                        {
                                                          retval = report_conf_stat$$1$$30$$rv;
                                                          goto unlock_return;
                                                        }

                                                      }

                                                      else
                                                      {
                                                        signed int report_conf_stat$$1$$31$$rv;
                                                        unsigned int return_value_da_nel$8;
                                                        return_value_da_nel$8=da_nel$link1((struct anonymous$3 *)global.deleg_only_zones);
                                                        n = (signed int)return_value_da_nel$8;
                                                        i = 0;
                                                        for( ; !(i >= n); i = i + 1)
                                                        {
                                                          unsigned char buf[256l];
                                                          const unsigned char *return_value_rhn2str$9;
                                                          return_value_rhn2str$9=rhn2str(global.deleg_only_zones->elem[(signed long int)i], buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                                          report_conf_stat$$1$$31$$rv=fsprintf(f, i == 0 ? "%s" : ", %s", return_value_rhn2str$9);
                                                          if(!(report_conf_stat$$1$$31$$rv >= 0))
                                                          {
                                                            retval = report_conf_stat$$1$$31$$rv;
                                                            goto unlock_return;
                                                          }

                                                        }
                                                        report_conf_stat$$1$$31$$rv=fsprintf(f, "\n");
                                                        if(!(report_conf_stat$$1$$31$$rv >= 0))
                                                        {
                                                          retval = report_conf_stat$$1$$31$$rv;
                                                          goto unlock_return;
                                                        }

                                                      }
                                                      return_value_da_nel$10=da_nel$link1((struct anonymous$3 *)servers);
                                                      n = (signed int)return_value_da_nel$10;
                                                      i = 0;
                                                      for( ; !(i >= n); i = i + 1)
                                                      {
                                                        signed int report_conf_stat$$1$$32$$1$$rv;
                                                        report_conf_stat$$1$$32$$1$$rv=report_server_stat(f, i);
                                                        if(!(report_conf_stat$$1$$32$$1$$rv >= 0))
                                                        {
                                                          retval = report_conf_stat$$1$$32$$1$$rv;
                                                          break;
                                                        }

                                                      }
                                                    }

                                                  unlock_return:
                                                    ;
                                                    unlock_server_data();
                                                    return retval;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// report_error
// file conf-parser.c line 54
static char * report_error(const char *conftype, unsigned int linenr, const char *msg)
{
  char *retval;
  if(!(linenr == 0u))
  {
    signed int return_value_asprintf$1;
    return_value_asprintf$1=asprintf(&retval, "Error in %s (line %u): %s", conftype, linenr, msg);
    if(!(return_value_asprintf$1 >= 0))
      retval = (char *)(void *)0;

  }

  else
  {
    signed int return_value_asprintf$2;
    return_value_asprintf$2=asprintf(&retval, "Error in %s: %s", conftype, msg);
    if(!(return_value_asprintf$2 >= 0))
      retval = (char *)(void *)0;

  }
  return retval;
}

// report_errorf
// file conf-parser.c line 70
static char * report_errorf(const char *conftype, unsigned int linenr, const char *frm, ...)
{
  char *msg;
  char *retval;
  signed int mlen;
  void **va = (void **)&frm;
  mlen=vasprintf(&msg, frm, va);
  va = ((void **)NULL);
  if(!(mlen >= 0))
    return (char *)(void *)0;

  else
  {
    retval=report_error(conftype, linenr, msg);
    free((void *)msg);
    return retval;
  }
}

// report_server_stat
// file conff.c line 501
static signed int report_server_stat(signed int f, signed int i)
{
  struct anonymous$7 *st = &servers->elem[(signed long int)i];
  signed int j;
  signed int m;
  signed int report_server_stat$$1$$1$$_retval;
  report_server_stat$$1$$1$$_retval=fsprintf(f, "Server %i:\n------\n", i);
  const char *return_value_pdnsd_a2str$8;
  unsigned int return_value_da_nel$14;
  if(!(report_server_stat$$1$$1$$_retval >= 0))
    return report_server_stat$$1$$1$$_retval;

  else
  {
    signed int report_server_stat$$1$$2$$_retval;
    char *tmp_if_expr$1;
    if(!(st->label == ((char *)NULL)))
      tmp_if_expr$1 = st->label;

    else
      tmp_if_expr$1 = "(none)";
    report_server_stat$$1$$2$$_retval=fsprintf(f, "\tlabel: %s\n", tmp_if_expr$1);
    if(!(report_server_stat$$1$$2$$_retval >= 0))
      return report_server_stat$$1$$2$$_retval;

    else
    {
      unsigned int return_value_da_nel$2;
      return_value_da_nel$2=da_nel$link1((struct anonymous$3 *)st->atup_a);
      m = (signed int)return_value_da_nel$2;
      if((signed int)st->rootserver >= 2)
      {
        if(!(m == 0))
        {
          signed int report_server_stat$$1$$3$$_retval;
          report_server_stat$$1$$3$$_retval=fsprintf(f, "\tThe following name servers will be used for discovery of rootservers only:\n");
          if(!(report_server_stat$$1$$3$$_retval >= 0))
            return report_server_stat$$1$$3$$_retval;

        }

      }

      j = 0;
      for( ; !(j >= m); j = j + 1)
      {
        struct anonymous$20 *at = &st->atup_a->elem[(signed long int)j];
        char buf[46l];
        signed int report_server_stat$$1$$4$$1$$1$$1$$_retval;
        union anonymous$6 *tmp_if_expr$3;
        if(!(run_ipv4 == 0))
          tmp_if_expr$3 = (union anonymous$6 *)&(&at->a)->ipv4;

        else
          tmp_if_expr$3 = (union anonymous$6 *)&(&at->a)->ipv6;
        const char *return_value_pdnsd_a2str$4;
        return_value_pdnsd_a2str$4=pdnsd_a2str(tmp_if_expr$3, buf, 46);
        report_server_stat$$1$$4$$1$$1$$1$$_retval=fsprintf(f, "\tip: %s\n", return_value_pdnsd_a2str$4);
        if(!(report_server_stat$$1$$4$$1$$1$$1$$_retval >= 0))
          return report_server_stat$$1$$4$$1$$1$$1$$_retval;

        signed int report_server_stat$$1$$4$$1$$2$$_retval;
        report_server_stat$$1$$4$$1$$2$$_retval=fsprintf(f, "\tserver assumed available: %s\n", at->is_up != 0 ? "yes" : "no");
        if(!(report_server_stat$$1$$4$$1$$2$$_retval >= 0))
          return report_server_stat$$1$$4$$1$$2$$_retval;

      }
      signed int report_server_stat$$1$$5$$_retval;
      report_server_stat$$1$$5$$_retval=fsprintf(f, "\tport: %hu\n", st->port);
      if(!(report_server_stat$$1$$5$$_retval >= 0))
        return report_server_stat$$1$$5$$_retval;

      else
      {
        signed int report_server_stat$$1$$6$$_retval;
        const char *return_value_const_name$5;
        return_value_const_name$5=const_name((signed int)st->uptest);
        report_server_stat$$1$$6$$_retval=fsprintf(f, "\tuptest: %s\n", return_value_const_name$5);
        if(!(report_server_stat$$1$$6$$_retval >= 0))
          return report_server_stat$$1$$6$$_retval;

        else
        {
          signed int report_server_stat$$1$$7$$_retval;
          report_server_stat$$1$$7$$_retval=fsprintf(f, "\ttimeout: %li\n", (signed long int)st->timeout);
          if(!(report_server_stat$$1$$7$$_retval >= 0))
            return report_server_stat$$1$$7$$_retval;

          else
          {
            if(st->interval >= 1l)
            {
              signed int report_server_stat$$1$$8$$1$$_retval;
              report_server_stat$$1$$8$$1$$_retval=fsprintf(f, "\tuptest interval: %li\n", (signed long int)st->interval);
              if(!(report_server_stat$$1$$8$$1$$_retval >= 0))
                return report_server_stat$$1$$8$$1$$_retval;

            }

            else
            {
              signed int report_server_stat$$1$$9$$1$$_retval;
              char *tmp_if_expr$6;
              if(st->interval == -1l)
                tmp_if_expr$6 = "onquery";

              else
                tmp_if_expr$6 = st->interval == (signed long int)-2 ? "ontimeout" : "(never retest)";
              report_server_stat$$1$$9$$1$$_retval=fsprintf(f, "\tuptest interval: %s\n", tmp_if_expr$6);
              if(!(report_server_stat$$1$$9$$1$$_retval >= 0))
                return report_server_stat$$1$$9$$1$$_retval;

            }
            signed int report_server_stat$$1$$10$$_retval;
            report_server_stat$$1$$10$$_retval=fsprintf(f, "\tping timeout: %li\n", (signed long int)st->ping_timeout);
            if(!(report_server_stat$$1$$10$$_retval >= 0))
              return report_server_stat$$1$$10$$_retval;

            else
            {
              char report_server_stat$$1$$11$$buf[46l];
              signed int report_server_stat$$1$$11$$1$$_retval;
              signed int return_value_is_inaddr_any$7;
              return_value_is_inaddr_any$7=is_inaddr_any$link1(&st->ping_a);
              char *tmp_if_expr$9;
              if(!(return_value_is_inaddr_any$7 == 0))
                tmp_if_expr$9 = "(using server ip)";

              else
              {
                return_value_pdnsd_a2str$8=pdnsd_a2str(&st->ping_a, report_server_stat$$1$$11$$buf, 46);
                tmp_if_expr$9 = return_value_pdnsd_a2str$8;
              }
              report_server_stat$$1$$11$$1$$_retval=fsprintf(f, "\tping ip: %s\n", tmp_if_expr$9);
              if(!(report_server_stat$$1$$11$$1$$_retval >= 0))
                return report_server_stat$$1$$11$$1$$_retval;

              else
              {
                if(!(st->interface[0l] == 0))
                {
                  signed int report_server_stat$$1$$12$$1$$_retval;
                  report_server_stat$$1$$12$$1$$_retval=fsprintf(f, "\tinterface: %s\n", (const void *)st->interface);
                  if(!(report_server_stat$$1$$12$$1$$_retval >= 0))
                    return report_server_stat$$1$$12$$1$$_retval;

                }

                if(!(st->device[0l] == 0))
                {
                  signed int report_server_stat$$1$$13$$1$$_retval;
                  report_server_stat$$1$$13$$1$$_retval=fsprintf(f, "\tdevice (for special Linux ppp device support): %s\n", (const void *)st->device);
                  if(!(report_server_stat$$1$$13$$1$$_retval >= 0))
                    return report_server_stat$$1$$13$$1$$_retval;

                }

                if(!(st->uptest_cmd == ((char *)NULL)))
                {
                  signed int report_server_stat$$1$$14$$1$$_retval;
                  report_server_stat$$1$$14$$1$$_retval=fsprintf(f, "\tuptest command: %s\n", st->uptest_cmd);
                  if(!(report_server_stat$$1$$14$$1$$_retval >= 0))
                    return report_server_stat$$1$$14$$1$$_retval;

                  signed int report_server_stat$$1$$14$$2$$_retval;
                  char *tmp_if_expr$10;
                  if(!(st->uptest_usr[0l] == 0))
                    tmp_if_expr$10 = st->uptest_usr;

                  else
                    tmp_if_expr$10 = "(process owner)";
                  report_server_stat$$1$$14$$2$$_retval=fsprintf(f, "\tuptest user: %s\n", tmp_if_expr$10);
                  if(!(report_server_stat$$1$$14$$2$$_retval >= 0))
                    return report_server_stat$$1$$14$$2$$_retval;

                }

                if(!(st->query_test_name == ((unsigned char *)NULL)))
                {
                  unsigned char nmbuf[256l];
                  signed int report_server_stat$$1$$15$$1$$_retval;
                  const unsigned char *return_value_rhn2str$11;
                  return_value_rhn2str$11=rhn2str(st->query_test_name, nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                  report_server_stat$$1$$15$$1$$_retval=fsprintf(f, "\tname used in query uptest: %s\n", return_value_rhn2str$11);
                  if(!(report_server_stat$$1$$15$$1$$_retval >= 0))
                    return report_server_stat$$1$$15$$1$$_retval;

                }

                if(!(st->scheme[0l] == 0))
                {
                  signed int report_server_stat$$1$$16$$1$$_retval;
                  report_server_stat$$1$$16$$1$$_retval=fsprintf(f, "\tscheme: %s\n", (const void *)st->scheme);
                  if(!(report_server_stat$$1$$16$$1$$_retval >= 0))
                    return report_server_stat$$1$$16$$1$$_retval;

                }

                signed int report_server_stat$$1$$17$$_retval;
                report_server_stat$$1$$17$$_retval=fsprintf(f, "\tforce cache purging: %s\n", st->purge_cache != 0 ? "on" : "off");
                if(!(report_server_stat$$1$$17$$_retval >= 0))
                  return report_server_stat$$1$$17$$_retval;

                else
                {
                  signed int report_server_stat$$1$$18$$_retval;
                  report_server_stat$$1$$18$$_retval=fsprintf(f, "\tserver is cached: %s\n", st->nocache != 0 ? "off" : "on");
                  if(!(report_server_stat$$1$$18$$_retval >= 0))
                    return report_server_stat$$1$$18$$_retval;

                  else
                  {
                    signed int report_server_stat$$1$$19$$_retval;
                    report_server_stat$$1$$19$$_retval=fsprintf(f, "\tlean query: %s\n", st->lean_query != 0 ? "on" : "off");
                    if(!(report_server_stat$$1$$19$$_retval >= 0))
                      return report_server_stat$$1$$19$$_retval;

                    else
                    {
                      signed int report_server_stat$$1$$20$$_retval;
                      report_server_stat$$1$$20$$_retval=fsprintf(f, "\tUse EDNS in outgoing queries: %s\n", st->edns_query != 0 ? "on" : "off");
                      if(!(report_server_stat$$1$$20$$_retval >= 0))
                        return report_server_stat$$1$$20$$_retval;

                      else
                      {
                        signed int report_server_stat$$1$$21$$_retval;
                        report_server_stat$$1$$21$$_retval=fsprintf(f, "\tUse only proxy?: %s\n", st->is_proxy != 0 ? "on" : "off");
                        if(!(report_server_stat$$1$$21$$_retval >= 0))
                          return report_server_stat$$1$$21$$_retval;

                        else
                        {
                          signed int report_server_stat$$1$$22$$_retval;
                          char *tmp_if_expr$12;
                          if(!(st->rootserver == 0))
                            tmp_if_expr$12 = (signed int)st->rootserver == 1 ? "yes" : "discover";

                          else
                            tmp_if_expr$12 = "no";
                          report_server_stat$$1$$22$$_retval=fsprintf(f, "\tAssumed root server: %s\n", tmp_if_expr$12);
                          if(!(report_server_stat$$1$$22$$_retval >= 0))
                            return report_server_stat$$1$$22$$_retval;

                          else
                          {
                            signed int report_server_stat$$1$$23$$_retval;
                            report_server_stat$$1$$23$$_retval=fsprintf(f, "\tRandomize server query order: %s\n", st->rand_servers != 0 ? "yes" : "no");
                            if(!(report_server_stat$$1$$23$$_retval >= 0))
                              return report_server_stat$$1$$23$$_retval;

                            else
                            {
                              signed int report_server_stat$$1$$24$$_retval;
                              const char *return_value_const_name$13;
                              return_value_const_name$13=const_name((signed int)st->policy);
                              report_server_stat$$1$$24$$_retval=fsprintf(f, "\tDefault policy: %s\n", return_value_const_name$13);
                              if(!(report_server_stat$$1$$24$$_retval >= 0))
                                return report_server_stat$$1$$24$$_retval;

                              else
                              {
                                signed int report_server_stat$$1$$25$$_retval;
                                report_server_stat$$1$$25$$_retval=fsprintf(f, "\tPolicies:%s\n", st->alist != ((struct anonymous$8 *)NULL) ? "" : " (none)");
                                if(!(report_server_stat$$1$$25$$_retval >= 0))
                                  return report_server_stat$$1$$25$$_retval;

                                else
                                {
                                  j = 0;
                                  do
                                  {
                                    return_value_da_nel$14=da_nel$link1((struct anonymous$3 *)st->alist);
                                    if((unsigned int)j >= return_value_da_nel$14)
                                      break;

                                    struct anonymous$9 *sl = &st->alist->elem[(signed long int)j];
                                    unsigned char report_server_stat$$1$$26$$1$$buf[256l];
                                    signed int report_server_stat$$1$$26$$1$$1$$_retval;
                                    const unsigned char *return_value_rhn2str$15;
                                    return_value_rhn2str$15=rhn2str(sl->domain, report_server_stat$$1$$26$$1$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                    report_server_stat$$1$$26$$1$$1$$_retval=fsprintf(f, "\t\t%s: %s%s\n", (signed int)sl->rule == 18 ? "include" : "exclude", sl->exact != 0 ? "" : ".", return_value_rhn2str$15);
                                    if(!(report_server_stat$$1$$26$$1$$1$$_retval >= 0))
                                      return report_server_stat$$1$$26$$1$$1$$_retval;

                                    j = j + 1;
                                  }
                                  while((_Bool)1);
                                  _Bool tmp_if_expr$23;
                                  if(!(st->reject_a4 == ((struct anonymous$10 *)NULL)))
                                    tmp_if_expr$23 = (_Bool)1;

                                  else
                                    tmp_if_expr$23 = st->reject_a6 != (struct anonymous$12 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                                  if(tmp_if_expr$23)
                                  {
                                    signed int report_server_stat$$1$$27$$1$$_retval;
                                    report_server_stat$$1$$27$$1$$_retval=fsprintf(f, "\tAddresses which should be rejected in replies:\n");
                                    if(!(report_server_stat$$1$$27$$1$$_retval >= 0))
                                      return report_server_stat$$1$$27$$1$$_retval;

                                    unsigned int return_value_da_nel$16;
                                    return_value_da_nel$16=da_nel$link1((struct anonymous$3 *)st->reject_a4);
                                    m = (signed int)return_value_da_nel$16;
                                    j = 0;
                                    for( ; !(j >= m); j = j + 1)
                                    {
                                      struct anonymous$11 *am = &st->reject_a4->elem[(signed long int)j];
                                      char abuf[46l];
                                      char mbuf[46l];
                                      signed int _retval;
                                      const char *return_value_inet_ntop$17;
                                      return_value_inet_ntop$17=inet_ntop(2, (const void *)&am->a, abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      const char *return_value_inet_ntop$18;
                                      return_value_inet_ntop$18=inet_ntop(2, (const void *)&am->mask, mbuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      _retval=fsprintf(f, "\t\t%s/%s\n", return_value_inet_ntop$17, return_value_inet_ntop$18);
                                      if(!(_retval >= 0))
                                        return _retval;

                                    }
                                    unsigned int return_value_da_nel$19;
                                    return_value_da_nel$19=da_nel$link1((struct anonymous$3 *)st->reject_a6);
                                    m = (signed int)return_value_da_nel$19;
                                    j = 0;
                                    for( ; !(j >= m); j = j + 1)
                                    {
                                      struct anonymous$13 *report_server_stat$$1$$27$$3$$1$$am = &st->reject_a6->elem[(signed long int)j];
                                      char report_server_stat$$1$$27$$3$$1$$abuf[46l];
                                      char report_server_stat$$1$$27$$3$$1$$mbuf[46l];
                                      signed int report_server_stat$$1$$27$$3$$1$$1$$_retval;
                                      const char *return_value_inet_ntop$20;
                                      return_value_inet_ntop$20=inet_ntop(10, (const void *)&report_server_stat$$1$$27$$3$$1$$am->a, report_server_stat$$1$$27$$3$$1$$abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      const char *return_value_inet_ntop$21;
                                      return_value_inet_ntop$21=inet_ntop(10, (const void *)&report_server_stat$$1$$27$$3$$1$$am->mask, report_server_stat$$1$$27$$3$$1$$mbuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      report_server_stat$$1$$27$$3$$1$$1$$_retval=fsprintf(f, "\t\t%s/%s\n", return_value_inet_ntop$20, return_value_inet_ntop$21);
                                      if(!(report_server_stat$$1$$27$$3$$1$$1$$_retval >= 0))
                                        return report_server_stat$$1$$27$$3$$1$$1$$_retval;

                                    }
                                    signed int report_server_stat$$1$$27$$4$$_retval;
                                    const char *return_value_const_name$22;
                                    return_value_const_name$22=const_name((signed int)st->rejectpolicy);
                                    report_server_stat$$1$$27$$4$$_retval=fsprintf(f, "\tReject policy: %s\n", return_value_const_name$22);
                                    if(!(report_server_stat$$1$$27$$4$$_retval >= 0))
                                      return report_server_stat$$1$$27$$4$$_retval;

                                    signed int report_server_stat$$1$$27$$5$$_retval;
                                    report_server_stat$$1$$27$$5$$_retval=fsprintf(f, "\tReject recursively: %s\n", st->rejectrecursively != 0 ? "yes" : "no");
                                    if(!(report_server_stat$$1$$27$$5$$_retval >= 0))
                                      return report_server_stat$$1$$27$$5$$_retval;

                                  }

                                  return 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// report_thread_stat
// file dns_answer.c line 2141
signed int report_thread_stat(signed int f)
{
  unsigned long int nspawned;
  unsigned long int ndropped;
  signed int nactive;
  signed int ncurrent;
  signed int nqueued;
  pthread_mutex_lock(&proc_lock);
  nspawned = spawned;
  ndropped = dropped;
  nactive = procs;
  ncurrent = qprocs;
  nqueued = ncurrent - nactive;
  pthread_mutex_unlock(&proc_lock);
  signed int _retval;
  _retval=fsprintf(f, "\nThread status:\n==============\n");
  if(!(_retval >= 0))
    return _retval;

  else
  {
    signed int return_value_pthread_equal$1;
    return_value_pthread_equal$1=pthread_equal(servstat_thrid, main_thrid);
    if(return_value_pthread_equal$1 == 0)
    {
      signed int report_thread_stat$$1$$2$$_retval;
      report_thread_stat$$1$$2$$_retval=fsprintf(f, "server status thread is running.\n");
      if(!(report_thread_stat$$1$$2$$_retval >= 0))
        return report_thread_stat$$1$$2$$_retval;

    }

    signed int return_value_pthread_equal$2;
    return_value_pthread_equal$2=pthread_equal(statsock_thrid, main_thrid);
    if(return_value_pthread_equal$2 == 0)
    {
      signed int report_thread_stat$$1$$3$$_retval;
      report_thread_stat$$1$$3$$_retval=fsprintf(f, "pdnsd control thread is running.\n");
      if(!(report_thread_stat$$1$$3$$_retval >= 0))
        return report_thread_stat$$1$$3$$_retval;

    }

    signed int return_value_pthread_equal$3;
    return_value_pthread_equal$3=pthread_equal(tcps_thrid, main_thrid);
    if(return_value_pthread_equal$3 == 0)
    {
      signed int report_thread_stat$$1$$4$$_retval;
      report_thread_stat$$1$$4$$_retval=fsprintf(f, "tcp server thread is running.\n");
      if(!(report_thread_stat$$1$$4$$_retval >= 0))
        return report_thread_stat$$1$$4$$_retval;

    }

    signed int return_value_pthread_equal$4;
    return_value_pthread_equal$4=pthread_equal(udps_thrid, main_thrid);
    if(return_value_pthread_equal$4 == 0)
    {
      signed int report_thread_stat$$1$$5$$_retval;
      report_thread_stat$$1$$5$$_retval=fsprintf(f, "udp server thread is running.\n");
      if(!(report_thread_stat$$1$$5$$_retval >= 0))
        return report_thread_stat$$1$$5$$_retval;

    }

    signed int report_thread_stat$$1$$6$$_retval;
    report_thread_stat$$1$$6$$_retval=fsprintf(f, "%lu query threads spawned in total (%lu queries dropped).\n", nspawned, ndropped);
    if(!(report_thread_stat$$1$$6$$_retval >= 0))
      return report_thread_stat$$1$$6$$_retval;

    else
    {
      signed int report_thread_stat$$1$$7$$_retval;
      report_thread_stat$$1$$7$$_retval=fsprintf(f, "%i running query threads (%i active, %i queued).\n", ncurrent, nactive, nqueued);
      if(!(report_thread_stat$$1$$7$$_retval >= 0))
        return report_thread_stat$$1$$7$$_retval;

      else
        return 0;
    }
  }
}

// resolv_rootserver_addrs
// file servers.c line 289
static struct anonymous$14 * resolv_rootserver_addrs(struct anonymous$19 *a, signed int port, char edns_query, signed long int timeout)
{
  struct anonymous$14 *retval = (struct anonymous$14 *)(void *)0;
  server_data_users = server_data_users + 1;
  pthread_mutex_unlock(&servers_lock);
  retval=dns_rootserver_resolv(a, port, edns_query, timeout);
  pthread_mutex_lock(&servers_lock);
  if(!(server_data_users >= 1))
  {
    log_message(3, "%s:%d: %s", (const void *)"servers.c", 300, (const void *)"server_data_users non-positive before attempt to decrement it");
    pdnsd_exit();
  }

  server_data_users = server_data_users - 1;
  if(server_data_users == 0)
    pthread_cond_broadcast(&server_data_cond);

  return retval;
}

// retest
// file servers.c line 230
static void retest(signed int i, signed int j)
{
  signed long int s_ts;
  struct anonymous$7 *srv = &servers->elem[(signed long int)i];
  signed int nsrvs;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link5((struct anonymous$3 *)srv->atup_a);
  nsrvs = (signed int)return_value_da_nel$1;
  _Bool tmp_if_expr$4;
  signed int return_value_is_inaddr_any$3;
  if(!(nsrvs == 0))
  {
    if(j >= 0)
    {
      if(!(j >= nsrvs))
        nsrvs = j + 1;

    }

    else
      j = 0;
    signed int return_value_scheme_ok$6;
    return_value_scheme_ok$6=scheme_ok(srv);
    if(return_value_scheme_ok$6 == 0)
    {
      s_ts=time((signed long int *)(void *)0);
      for( ; !(j >= nsrvs); j = j + 1)
      {
        struct anonymous$20 *at = &srv->atup_a->elem[(signed long int)j];
        at->is_up = (char)0;
        at->i_ts = s_ts;
      }
    }

    else
      if((signed int)srv->uptest == 5)
      {
        s_ts=time((signed long int *)(void *)0);
        for( ; !(j >= nsrvs); j = j + 1)
          srv->atup_a->elem[(signed long int)j].i_ts = s_ts;
      }

      else
      {
        _Bool tmp_if_expr$5;
        if((signed int)srv->uptest == 9)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          if((signed int)srv->uptest == 8)
          {
            return_value_is_inaddr_any$3=is_inaddr_any$link2(&srv->ping_a);
            tmp_if_expr$4 = return_value_is_inaddr_any$3 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$4 = (_Bool)0;
          tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
          for( ; !(j >= nsrvs); j = j + 1)
          {
            struct anonymous$20 *retest$$1$$5$$1$$1$$at = &srv->atup_a->elem[(signed long int)j];
            s_ts=time((signed long int *)(void *)0);
            signed int return_value_uptest$2;
            return_value_uptest$2=uptest(srv, j);
            retest$$1$$5$$1$$1$$at->is_up = (char)return_value_uptest$2;
            if(!(signal_interrupt == 0))
              break;

            retest$$1$$5$$1$$1$$at->i_ts = s_ts;
          }

        else
        {
          signed int res;
          s_ts=time((signed long int *)(void *)0);
          res=uptest(srv, j);
          for( ; !(j >= nsrvs); j = j + 1)
          {
            struct anonymous$20 *retest$$1$$6$$1$$1$$at = &srv->atup_a->elem[(signed long int)j];
            retest$$1$$6$$1$$1$$at->is_up = (char)res;
            if(!(signal_interrupt == 0))
            {
              if(!((signed int)srv->uptest == 8))
                goto __CPROVER_DUMP_L20;

            }

            else
            {

            __CPROVER_DUMP_L20:
              ;
              retest$$1$$6$$1$$1$$at->i_ts = s_ts;
            }
          }
        }
      }
  }

}

// rhn2str
// file helpers.h line 52
const unsigned char * rhn2str(const unsigned char *rhn, unsigned char *str, unsigned int size)
{
  unsigned int i;
  unsigned int j;
  unsigned int lb;
  if(size == 0u)
    return (const unsigned char *)(void *)0;

  else
  {
    i = (unsigned int)0;
    j = (unsigned int)0;
    unsigned int tmp_post$1 = i;
    i = i + 1u;
    lb = (unsigned int)rhn[(signed long int)tmp_post$1];
    if(lb == 0u)
    {
      if(size >= 2u)
      {
        unsigned int tmp_post$2 = j;
        j = j + 1u;
        str[(signed long int)tmp_post$2] = (unsigned char)46;
      }

    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      while((_Bool)1)
      {
        if(!(lb == 0u))
        {
          unsigned char c;
          if(2u + j >= size)
            goto overflow;

          unsigned int tmp_post$3 = i;
          i = i + 1u;
          c = rhn[(signed long int)tmp_post$3];
          const unsigned short int **return_value___ctype_b_loc$7;
          return_value___ctype_b_loc$7=__ctype_b_loc();
          if(!((32768 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)c]) == 0))
          {
            if((signed int)c == 34 || (signed int)c == 46 || (signed int)c == 92)
            {
              unsigned int tmp_post$4 = j;
              j = j + 1u;
              str[(signed long int)tmp_post$4] = (unsigned char)92;
              if(2u + j >= size)
                goto overflow;

            }

            unsigned int tmp_post$5 = j;
            j = j + 1u;
            str[(signed long int)tmp_post$5] = c;
          }

          else
          {
            unsigned int rem = (size - (unsigned int)1) - j;
            signed int n;
            n=snprintf((char *)&str[(signed long int)j], (unsigned long int)rem, "\\%03o", c);
            if((unsigned int)n >= rem || !(n >= 0))
            {
              unsigned int tmp_post$6 = j;
              j = j + 1u;
              str[(signed long int)tmp_post$6] = (unsigned char)46;
              goto overflow;
            }

            j = j + (unsigned int)n;
          }
          lb = lb - 1u;
          goto __CPROVER_DUMP_L3;
        }

        unsigned int tmp_post$8 = j;
        j = j + 1u;
        str[(signed long int)tmp_post$8] = (unsigned char)46;
        unsigned int tmp_post$9 = i;
        i = i + 1u;
        lb = (unsigned int)rhn[(signed long int)tmp_post$9];
        if(lb == 0u)
          break;

      }
    }
    str[(signed long int)j] = (unsigned char)0;
    return str;

  overflow:
    ;
    j = size;
    j = j - 1u;
    str[(signed long int)j] = (unsigned char)0;
    if(j >= 1u)
    {
      j = j - 1u;
      str[(signed long int)j] = (unsigned char)46;
      if(j >= 1u)
      {
        j = j - 1u;
        str[(signed long int)j] = (unsigned char)46;
        if(j >= 1u)
        {
          j = j - 1u;
          str[(signed long int)j] = (unsigned char)46;
        }

      }

    }

    return str;
  }
}

// rhncpy
// file helpers.h line 111
unsigned int rhncpy(unsigned char *dst, const unsigned char *src)
{
  unsigned int len;
  len=rhnlen$link4(src);
  if(len >= 257u)
  {
    log_message(3, "%s:%d: %s", (const void *)"helpers.c", 359, (const void *)"rhncpy: src too long!");
    pdnsd_exit();
  }

  memcpy((void *)dst, (const void *)src, (unsigned long int)(len > (unsigned int)256 ? (unsigned int)256 : len));
  return len;
}

// rhnicmp
// file helpers.h line 214
static inline signed int rhnicmp(const unsigned char *a, const unsigned char *b)
{
  unsigned int i = (unsigned int)0;
  unsigned char lb;
  do
  {
    lb = a[(signed long int)i];
    if(!(lb == b[(signed long int)i]))
      return 0;

    if(lb == 0)
      break;

    i = i + 1u;
    do
    {
      signed int return_value_tolower$1;
      return_value_tolower$1=tolower((signed int)a[(signed long int)i]);
      signed int return_value_tolower$2;
      return_value_tolower$2=tolower((signed int)b[(signed long int)i]);
      if(!(return_value_tolower$1 == return_value_tolower$2))
        return 0;

      i = i + 1u;
      lb = lb - 1;
    }
    while(!(lb == 0));
  }
  while((_Bool)1);
  return 1;
}

// rhnicmp$link1
// file helpers.h line 214
static inline signed int rhnicmp$link1(const unsigned char *a$link1, const unsigned char *b$link1)
{
  unsigned int i$link1 = (unsigned int)0;
  unsigned char lb$link1;
  do
  {
    lb$link1 = a$link1[(signed long int)i$link1];
    if(!(lb$link1 == b$link1[(signed long int)i$link1]))
      return 0;

    if(lb$link1 == 0)
      break;

    i$link1 = i$link1 + 1u;
    do
    {
      signed int return_value_tolower$1$link1;
      return_value_tolower$1$link1=tolower((signed int)a$link1[(signed long int)i$link1]);
      signed int return_value_tolower$2$link1;
      return_value_tolower$2$link1=tolower((signed int)b$link1[(signed long int)i$link1]);
      if(!(return_value_tolower$1$link1 == return_value_tolower$2$link1))
        return 0;

      i$link1 = i$link1 + 1u;
      lb$link1 = lb$link1 - 1;
    }
    while(!(lb$link1 == 0));
  }
  while((_Bool)1);
  return 1;
}

// rhnicmp$link2
// file helpers.h line 214
static inline signed int rhnicmp$link2(const unsigned char *a$link2, const unsigned char *b$link2)
{
  unsigned int i$link2 = (unsigned int)0;
  unsigned char lb$link2;
  do
  {
    lb$link2 = a$link2[(signed long int)i$link2];
    if(!(lb$link2 == b$link2[(signed long int)i$link2]))
      return 0;

    if(lb$link2 == 0)
      break;

    i$link2 = i$link2 + 1u;
    do
    {
      signed int return_value_tolower$1$link2;
      return_value_tolower$1$link2=tolower((signed int)a$link2[(signed long int)i$link2]);
      signed int return_value_tolower$2$link2;
      return_value_tolower$2$link2=tolower((signed int)b$link2[(signed long int)i$link2]);
      if(!(return_value_tolower$1$link2 == return_value_tolower$2$link2))
        return 0;

      i$link2 = i$link2 + 1u;
      lb$link2 = lb$link2 - 1;
    }
    while(!(lb$link2 == 0));
  }
  while((_Bool)1);
  return 1;
}

// rhnlen
// file helpers.h line 62
static inline unsigned int rhnlen(const unsigned char *rhn)
{
  unsigned int i = (unsigned int)0;
  unsigned int lb;
  unsigned int tmp_post$1;
  do
  {
    tmp_post$1 = i;
    i = i + 1u;
    lb = (unsigned int)rhn[(signed long int)tmp_post$1];
    if(lb == 0u)
      break;

    i = i + lb;
  }
  while((_Bool)1);
  return i;
}

// rhnlen$link1
// file helpers.h line 62
static inline unsigned int rhnlen$link1(const unsigned char *rhn$link1)
{
  unsigned int i$link1 = (unsigned int)0;
  unsigned int lb$link1;
  unsigned int tmp_post$1$link1;
  do
  {
    tmp_post$1$link1 = i$link1;
    i$link1 = i$link1 + 1u;
    lb$link1 = (unsigned int)rhn$link1[(signed long int)tmp_post$1$link1];
    if(lb$link1 == 0u)
      break;

    i$link1 = i$link1 + lb$link1;
  }
  while((_Bool)1);
  return i$link1;
}

// rhnlen$link2
// file helpers.h line 62
static inline unsigned int rhnlen$link2(const unsigned char *rhn$link2)
{
  unsigned int i$link2 = (unsigned int)0;
  unsigned int lb$link2;
  unsigned int tmp_post$1$link2;
  do
  {
    tmp_post$1$link2 = i$link2;
    i$link2 = i$link2 + 1u;
    lb$link2 = (unsigned int)rhn$link2[(signed long int)tmp_post$1$link2];
    if(lb$link2 == 0u)
      break;

    i$link2 = i$link2 + lb$link2;
  }
  while((_Bool)1);
  return i$link2;
}

// rhnlen$link3
// file helpers.h line 62
static inline unsigned int rhnlen$link3(const unsigned char *rhn$link3)
{
  unsigned int i$link3 = (unsigned int)0;
  unsigned int lb$link3;
  unsigned int tmp_post$1$link3;
  do
  {
    tmp_post$1$link3 = i$link3;
    i$link3 = i$link3 + 1u;
    lb$link3 = (unsigned int)rhn$link3[(signed long int)tmp_post$1$link3];
    if(lb$link3 == 0u)
      break;

    i$link3 = i$link3 + lb$link3;
  }
  while((_Bool)1);
  return i$link3;
}

// rhnlen$link4
// file helpers.h line 62
static inline unsigned int rhnlen$link4(const unsigned char *rhn$link4)
{
  unsigned int i$link4 = (unsigned int)0;
  unsigned int lb$link4;
  unsigned int tmp_post$1$link4;
  do
  {
    tmp_post$1$link4 = i$link4;
    i$link4 = i$link4 + 1u;
    lb$link4 = (unsigned int)rhn$link4[(signed long int)tmp_post$1$link4];
    if(lb$link4 == 0u)
      break;

    i$link4 = i$link4 + lb$link4;
  }
  while((_Bool)1);
  return i$link4;
}

// rhnlen$link5
// file helpers.h line 62
static inline unsigned int rhnlen$link5(const unsigned char *rhn$link5)
{
  unsigned int i$link5 = (unsigned int)0;
  unsigned int lb$link5;
  unsigned int tmp_post$1$link5;
  do
  {
    tmp_post$1$link5 = i$link5;
    i$link5 = i$link5 + 1u;
    lb$link5 = (unsigned int)rhn$link5[(signed long int)tmp_post$1$link5];
    if(lb$link5 == 0u)
      break;

    i$link5 = i$link5 + lb$link5;
  }
  while((_Bool)1);
  return i$link5;
}

// rhnlen$link6
// file helpers.h line 62
static inline unsigned int rhnlen$link6(const unsigned char *rhn$link6)
{
  unsigned int i$link6 = (unsigned int)0;
  unsigned int lb$link6;
  unsigned int tmp_post$1$link6;
  do
  {
    tmp_post$1$link6 = i$link6;
    i$link6 = i$link6 + 1u;
    lb$link6 = (unsigned int)rhn$link6[(signed long int)tmp_post$1$link6];
    if(lb$link6 == 0u)
      break;

    i$link6 = i$link6 + lb$link6;
  }
  while((_Bool)1);
  return i$link6;
}

// rhnsegcnt
// file helpers.h line 100
static inline unsigned int rhnsegcnt(const unsigned char *rhn)
{
  unsigned int res = (unsigned int)0;
  unsigned int lb;
  do
  {
    lb = (unsigned int)*rhn;
    if(lb == 0u)
      break;

    res = res + 1u;
    rhn = rhn + (signed long int)(lb + (unsigned int)1);
  }
  while((_Bool)1);
  return res;
}

// rhnsegcnt$link1
// file helpers.h line 100
static inline unsigned int rhnsegcnt$link1(const unsigned char *rhn$link1)
{
  unsigned int res$link1 = (unsigned int)0;
  unsigned int lb$link1;
  do
  {
    lb$link1 = (unsigned int)*rhn$link1;
    if(lb$link1 == 0u)
      break;

    res$link1 = res$link1 + 1u;
    rhn$link1 = rhn$link1 + (signed long int)(lb$link1 + (unsigned int)1);
  }
  while((_Bool)1);
  return res$link1;
}

// rhnsegcnt$link2
// file helpers.h line 100
static inline unsigned int rhnsegcnt$link2(const unsigned char *rhn$link2)
{
  unsigned int res$link2 = (unsigned int)0;
  unsigned int lb$link2;
  do
  {
    lb$link2 = (unsigned int)*rhn$link2;
    if(lb$link2 == 0u)
      break;

    res$link2 = res$link2 + 1u;
    rhn$link2 = rhn$link2 + (signed long int)(lb$link2 + (unsigned int)1);
  }
  while((_Bool)1);
  return res$link2;
}

// rr_to_cache
// file dns_query.c line 183
static signed int rr_to_cache(struct anonymous$16 **centa, unsigned char *oname, signed int tp, signed long int ttl, unsigned int dlen, void *data, unsigned int flags, signed long int queryts)
{
  signed int i;
  signed int n;
  struct anonymous$0 *cent;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link2((struct anonymous$3 *)*centa);
  n = (signed int)return_value_da_nel$1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    cent = &(*centa)->elem[(signed long int)i];
    signed int return_value_rhnicmp$3;
    return_value_rhnicmp$3=rhnicmp$link1(cent->qname, oname);
    if(!(return_value_rhnicmp$3 == 0))
    {
      signed int retval = 0;
      signed int return_value_add_cent_rr$2;
      return_value_add_cent_rr$2=add_cent_rr(cent, tp, ttl, queryts, flags, dlen, data);
      return return_value_add_cent_rr$2 != 0 ? retval : 0xffff;
    }

  }
  struct anonymous$3 *return_value_da_grow1$4;
  return_value_da_grow1$4=da_grow1((struct anonymous$3 *)*centa, (unsigned long int)((struct anonymous$16 *)0)->elem, sizeof(struct anonymous$0) /*104ul*/ , free_cent0);
  *centa = (struct anonymous$16 *)return_value_da_grow1$4;
  if(*centa == ((struct anonymous$16 *)NULL))
    return 0xffff;

  else
  {
    cent = &(*centa)->elem[(signed long int)((*centa)->nel - (unsigned long int)1)];
    signed int return_value_init_cent$6;
    return_value_init_cent$6=init_cent(cent, oname, (signed long int)0, (signed long int)0, (unsigned int)0);
    if(return_value_init_cent$6 == 0)
    {
      struct anonymous$3 *return_value_da_resize$5;
      return_value_da_resize$5=da_resize((struct anonymous$3 *)*centa, (unsigned long int)((struct anonymous$16 *)0)->elem, sizeof(struct anonymous$0) /*104ul*/ , (unsigned long int)n, (void (*)(void *))(void *)0);
      *centa = (struct anonymous$16 *)return_value_da_resize$5;
      return 0xffff;
    }

    signed int return_value_add_cent_rr$7;
    return_value_add_cent_rr$7=add_cent_rr(cent, tp, ttl, queryts, flags, dlen, data);
    return return_value_add_cent_rr$7 != 0 ? 0 : 0xffff;
  }
}

// rr_tp_byname
// file rr_types.h line 533
signed int rr_tp_byname(char *name)
{
  signed int i = 0;
  for( ; !(i >= 51); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(name, rrnames[(signed long int)i]);
    if(return_value_strcmp$1 == 0)
      return i + 1;

  }
  return -1;
}

// rrs2cent
// file dns_query.c line 229
static signed int rrs2cent(unsigned char *msg, unsigned long int msgsz, unsigned char **ptr, unsigned long int *lcnt, signed int recnum, unsigned int flags, signed long int queryts, struct anonymous$16 **centa, signed int *numopt, struct anonymous$17 *ep)
{
  signed int rc;
  signed int retval = 0;
  signed int i;
  unsigned short int type;
  unsigned short int class;
  unsigned int ttl;
  unsigned short int rdlength;
  i = 0;
  signed int return_value_isnormalencdomname$12;
  const char *return_value_getrrtpname$16;
  signed int return_value_isnormalencdomname$17;
  signed int return_value_isnormalencdomname$21;
  const char *return_value_getrrtpname$24;
  for( ; !(i >= recnum); i = i + 1)
  {
    unsigned char oname[256l];
    unsigned char *ttlp;
    unsigned int len;
    rc=decompress_name(msg, msgsz, ptr, lcnt, oname, &len);
    if(!(rc == 0))
      return rc;

    if(!(*lcnt >= 10ul))
      return 0xfffe;

    *lcnt = *lcnt - (unsigned long int)10;
    do
    {
      unsigned short int t_s;
      const unsigned char *t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post$1 = t_cp;
      t_cp = t_cp + 1l;
      t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$1 << 8);
      const unsigned char *tmp_post$2 = t_cp;
      t_cp = t_cp + 1l;
      t_s = t_s | (unsigned short int)*tmp_post$2;
      type = t_s;
      *ptr = (unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int rrs2cent$$1$$1$$1$$4$$t_s;
      const unsigned char *rrs2cent$$1$$1$$1$$4$$t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post$3 = rrs2cent$$1$$1$$1$$4$$t_cp;
      rrs2cent$$1$$1$$1$$4$$t_cp = rrs2cent$$1$$1$$1$$4$$t_cp + 1l;
      rrs2cent$$1$$1$$1$$4$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$3 << 8);
      const unsigned char *tmp_post$4 = rrs2cent$$1$$1$$1$$4$$t_cp;
      rrs2cent$$1$$1$$1$$4$$t_cp = rrs2cent$$1$$1$$1$$4$$t_cp + 1l;
      rrs2cent$$1$$1$$1$$4$$t_s = rrs2cent$$1$$1$$1$$4$$t_s | (unsigned short int)*tmp_post$4;
      class = rrs2cent$$1$$1$$1$$4$$t_s;
      *ptr = (unsigned char *)(void *)rrs2cent$$1$$1$$1$$4$$t_cp;
    }
    while((_Bool)0);
    ttlp = *ptr;
    do
    {
      unsigned int t_l;
      const unsigned char *rrs2cent$$1$$1$$1$$5$$t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post$5 = rrs2cent$$1$$1$$1$$5$$t_cp;
      rrs2cent$$1$$1$$1$$5$$t_cp = rrs2cent$$1$$1$$1$$5$$t_cp + 1l;
      t_l = (unsigned int)*tmp_post$5 << 24;
      const unsigned char *tmp_post$6 = rrs2cent$$1$$1$$1$$5$$t_cp;
      rrs2cent$$1$$1$$1$$5$$t_cp = rrs2cent$$1$$1$$1$$5$$t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post$6 << 16;
      const unsigned char *tmp_post$7 = rrs2cent$$1$$1$$1$$5$$t_cp;
      rrs2cent$$1$$1$$1$$5$$t_cp = rrs2cent$$1$$1$$1$$5$$t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post$7 << 8;
      const unsigned char *tmp_post$8 = rrs2cent$$1$$1$$1$$5$$t_cp;
      rrs2cent$$1$$1$$1$$5$$t_cp = rrs2cent$$1$$1$$1$$5$$t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post$8;
      ttl = t_l;
      *ptr = (unsigned char *)(void *)rrs2cent$$1$$1$$1$$5$$t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int rrs2cent$$1$$1$$1$$6$$t_s;
      const unsigned char *rrs2cent$$1$$1$$1$$6$$t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post$9 = rrs2cent$$1$$1$$1$$6$$t_cp;
      rrs2cent$$1$$1$$1$$6$$t_cp = rrs2cent$$1$$1$$1$$6$$t_cp + 1l;
      rrs2cent$$1$$1$$1$$6$$t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post$9 << 8);
      const unsigned char *tmp_post$10 = rrs2cent$$1$$1$$1$$6$$t_cp;
      rrs2cent$$1$$1$$1$$6$$t_cp = rrs2cent$$1$$1$$1$$6$$t_cp + 1l;
      rrs2cent$$1$$1$$1$$6$$t_s = rrs2cent$$1$$1$$1$$6$$t_s | (unsigned short int)*tmp_post$10;
      rdlength = rrs2cent$$1$$1$$1$$6$$t_s;
      *ptr = (unsigned char *)(void *)rrs2cent$$1$$1$$1$$6$$t_cp;
    }
    while((_Bool)0);
    if(!(*lcnt >= (unsigned long int)rdlength))
      return 0xfffe;

    if((signed int)type == 41)
    {
      signed int tmp_post$11 = *numopt;
      *numopt = *numopt + 1;
      if(tmp_post$11 == 0)
      {
        if(!((signed int)oname[0l] == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "rrs2cent: name in OPT record not empty!\n");

        }

        ep->udpsize = class;
        ep->rcode = (unsigned short int)((signed int)(unsigned short int)ttlp[(signed long int)0] << 4 | (signed int)((struct anonymous$29 *)msg)->rcode);
        ep->version = (unsigned short int)ttlp[(signed long int)1];
        ep->do_flg = (unsigned char)((signed int)ttlp[(signed long int)2] >> 7 & 1);
        if(!(debug_p == 0))
        {
          unsigned int Zflags = (unsigned int)((signed int)(unsigned short int)ttlp[(signed long int)2] << 8 | (signed int)ttlp[(signed long int)3]);
          if(!((32767u & Zflags) == 0u))
          {
            if(!(debug_p == 0))
              debug_msg(0, "rrs2cent: Z field contains unknown nonzero bits (%04x).\n", Zflags);

          }

        }

        if(!(rdlength == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "rrs2cent: RDATA field in OPT record not empty!\n");

        }

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "rrs2cent: ingnoring surplus OPT record.\n");

    }

    else
    {
      _Bool tmp_if_expr$25;
      if((signed int)type >= 52 || !((signed int)type >= 1))
        tmp_if_expr$25 = (_Bool)1;

      else
        tmp_if_expr$25 = (signed int)rrlkuptab[(signed long int)((signed int)type - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
      if((signed int)class == 1 && !tmp_if_expr$25)
      {
        unsigned long int blcnt = (unsigned long int)rdlength;
        unsigned char *bptr = *ptr;
        unsigned char *nptr;
        unsigned int slen;
        switch((signed int)type)
        {
          case 1:
          {
            if(!((signed int)rdlength == 4))
              goto invalid_length;

            goto default_case;
          }
          case 5:

          case 7:

          case 3:

          case 4:

          case 8:

          case 9:

          case 2:

          case 12:
          {
            unsigned char db[256l];
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, db, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, len, (void *)db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 14:

          case 17:
          {
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$2$$db[512l];
            nptr = rrs2cent$$1$$1$$1$$9$$1$$2$$db;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$2$$db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 15:

          case 18:

          case 21:

          case 36:
          {
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$3$$db[258l];
            if(!(blcnt >= 2ul))
              goto record_too_short;

            memcpy((void *)rrs2cent$$1$$1$$1$$9$$1$$3$$db, (const void *)bptr, (unsigned long int)2);
            blcnt = blcnt - (unsigned long int)2;
            bptr = bptr + (signed long int)2;
            nptr = rrs2cent$$1$$1$$1$$9$$1$$3$$db + (signed long int)2;
            slen = (unsigned int)2;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$3$$db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 6:
          {
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$4$$db[532l];
            nptr = rrs2cent$$1$$1$$1$$9$$1$$4$$db;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = slen + len;
            if(!(blcnt >= 20ul))
              goto record_too_short;

            memcpy((void *)nptr, (const void *)bptr, (unsigned long int)20);
            blcnt = blcnt - (unsigned long int)20;
            slen = slen + (unsigned int)20;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$4$$db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 28:
          {
            if(!((signed int)rdlength == 16))
              goto invalid_length;

            goto default_case;
          }
          case 26:
          {
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$5$$db[514l];
            if(!(blcnt >= 2ul))
              goto record_too_short;

            memcpy((void *)rrs2cent$$1$$1$$1$$9$$1$$5$$db, (const void *)bptr, (unsigned long int)2);
            blcnt = blcnt - (unsigned long int)2;
            bptr = bptr + (signed long int)2;
            nptr = rrs2cent$$1$$1$$1$$9$$1$$5$$db + (signed long int)2;
            slen = (unsigned int)2;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = slen + len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$5$$db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 33:
          {
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$6$$db[262l];
            if(!(blcnt >= 6ul))
              goto record_too_short;

            memcpy((void *)rrs2cent$$1$$1$$1$$9$$1$$6$$db, (const void *)bptr, (unsigned long int)6);
            blcnt = blcnt - (unsigned long int)6;
            bptr = bptr + (signed long int)6;
            nptr = rrs2cent$$1$$1$$1$$9$$1$$6$$db + (signed long int)6;
            slen = (unsigned int)6;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$6$$db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 30:
          {
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$7$$db[1040l];
            nptr = rrs2cent$$1$$1$$1$$9$$1$$7$$db;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = (unsigned int)((unsigned long int)len + blcnt);
            if((unsigned long int)slen >= 1041ul)
              goto buffer_overflow;

            memcpy((void *)nptr, (const void *)bptr, blcnt);
            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$7$$db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 35:
          {
            signed int j;
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$8$$db[1028l];
            nptr = rrs2cent$$1$$1$$1$$9$$1$$8$$db;
            len = (unsigned int)4;
            j = 0;
            for( ; !(j >= 3); j = j + 1)
            {
              if((unsigned long int)len >= blcnt)
                goto record_too_short;

              len = len + (unsigned int)bptr[(signed long int)len] + (unsigned int)1;
            }
            if(!(blcnt >= (unsigned long int)len))
              goto record_too_short;

            memcpy((void *)nptr, (const void *)bptr, (unsigned long int)len);
            blcnt = blcnt - (unsigned long int)len;
            bptr = bptr + (signed long int)len;
            nptr = nptr + (signed long int)len;
            slen = len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$8$$db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 45:
          {
            unsigned int gwtp;
            if(!(blcnt >= 3ul))
              goto record_too_short;

            gwtp = (unsigned int)bptr[(signed long int)1];
            blcnt = blcnt - (unsigned long int)3;
            bptr = bptr + (signed long int)3;
            switch(gwtp)
            {
              case (unsigned int)0:
                goto default_case;
              case (unsigned int)1:
              {
                if(!(blcnt >= 4ul))
                  goto record_too_short;

                goto default_case;
              }
              case (unsigned int)2:
              {
                if(!(blcnt >= 16ul))
                  goto record_too_short;

                goto default_case;
              }
              case (unsigned int)3:
              {
                return_value_isnormalencdomname$12=isnormalencdomname(bptr, (unsigned int)blcnt);
                if(!(return_value_isnormalencdomname$12 == 0))
                  goto default_case;

                unsigned char *rbuf;
                unsigned char nmbuf[256l];
                rc=decompress_name(msg, msgsz, &bptr, &blcnt, nmbuf, &len);
                if(!(rc == 0))
                  return rc == 0xfffe ? 1 : rc;

                slen = (unsigned int)((unsigned long int)((unsigned int)3 + len) + blcnt);
                void *return_value_malloc$13;
                return_value_malloc$13=malloc((unsigned long int)slen);
                rbuf = (unsigned char *)return_value_malloc$13;
                if(rbuf == ((unsigned char *)NULL))
                  return 0xffff;

                void *return_value_mempcpy$14;
                return_value_mempcpy$14=mempcpy((void *)rbuf, (const void *)*ptr, (unsigned long int)3);
                nptr = (unsigned char *)return_value_mempcpy$14;
                void *return_value_mempcpy$15;
                return_value_mempcpy$15=mempcpy((void *)nptr, (const void *)nmbuf, (unsigned long int)len);
                nptr = (unsigned char *)return_value_mempcpy$15;
                memcpy((void *)nptr, (const void *)bptr, blcnt);
                rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rbuf, flags, queryts);
                free((void *)rbuf);
                if(!(rc == 0))
                {
                  if(rc == 0xffff)
                    return rc;

                  retval = rc;
                }

                break;
              }
              default:
              {
                if(!(debug_p == 0))
                {
                  return_value_getrrtpname$16=getrrtpname((signed int)type);
                  debug_msg(0, "rrs2cent: %s record contains unsupported gateway type (%u).\n", return_value_getrrtpname$16, gwtp);
                }

                return 1;
              }
            }
            break;
          }
          case 46:
          {
            if(!(blcnt >= 18ul))
              goto record_too_short;

            blcnt = blcnt - (unsigned long int)18;
            bptr = bptr + (signed long int)18;
            return_value_isnormalencdomname$17=isnormalencdomname(bptr, (unsigned int)blcnt);
            if(!(return_value_isnormalencdomname$17 == 0))
              goto default_case;

            unsigned char *rrs2cent$$1$$1$$1$$9$$1$$10$$rbuf;
            unsigned char rrs2cent$$1$$1$$1$$9$$1$$10$$nmbuf[256l];
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, rrs2cent$$1$$1$$1$$9$$1$$10$$nmbuf, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = (unsigned int)((unsigned long int)((unsigned int)18 + len) + blcnt);
            void *return_value_malloc$18;
            return_value_malloc$18=malloc((unsigned long int)slen);
            rrs2cent$$1$$1$$1$$9$$1$$10$$rbuf = (unsigned char *)return_value_malloc$18;
            if(rrs2cent$$1$$1$$1$$9$$1$$10$$rbuf == ((unsigned char *)NULL))
              return 0xffff;

            void *return_value_mempcpy$19;
            return_value_mempcpy$19=mempcpy((void *)rrs2cent$$1$$1$$1$$9$$1$$10$$rbuf, (const void *)*ptr, (unsigned long int)18);
            nptr = (unsigned char *)return_value_mempcpy$19;
            void *return_value_mempcpy$20;
            return_value_mempcpy$20=mempcpy((void *)nptr, (const void *)rrs2cent$$1$$1$$1$$9$$1$$10$$nmbuf, (unsigned long int)len);
            nptr = (unsigned char *)return_value_mempcpy$20;
            memcpy((void *)nptr, (const void *)bptr, blcnt);
            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$10$$rbuf, flags, queryts);
            free((void *)rrs2cent$$1$$1$$1$$9$$1$$10$$rbuf);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 47:
          {
            return_value_isnormalencdomname$21=isnormalencdomname(bptr, (unsigned int)blcnt);
            if(return_value_isnormalencdomname$21 == 0)
            {
              unsigned char *rrs2cent$$1$$1$$1$$9$$1$$11$$rbuf;
              unsigned char rrs2cent$$1$$1$$1$$9$$1$$11$$nmbuf[256l];
              rc=decompress_name(msg, msgsz, &bptr, &blcnt, rrs2cent$$1$$1$$1$$9$$1$$11$$nmbuf, &len);
              if(!(rc == 0))
                return rc == 0xfffe ? 1 : rc;

              slen = (unsigned int)((unsigned long int)len + blcnt);
              void *return_value_malloc$22;
              return_value_malloc$22=malloc((unsigned long int)slen);
              rrs2cent$$1$$1$$1$$9$$1$$11$$rbuf = (unsigned char *)return_value_malloc$22;
              if(rrs2cent$$1$$1$$1$$9$$1$$11$$rbuf == ((unsigned char *)NULL))
                return 0xffff;

              void *return_value_mempcpy$23;
              return_value_mempcpy$23=mempcpy((void *)rrs2cent$$1$$1$$1$$9$$1$$11$$rbuf, (const void *)rrs2cent$$1$$1$$1$$9$$1$$11$$nmbuf, (unsigned long int)len);
              nptr = (unsigned char *)return_value_mempcpy$23;
              memcpy((void *)nptr, (const void *)bptr, blcnt);
              rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent$$1$$1$$1$$9$$1$$11$$rbuf, flags, queryts);
              free((void *)rrs2cent$$1$$1$$1$$9$$1$$11$$rbuf);
              if(!(rc == 0))
              {
                if(rc == 0xffff)
                  return rc;

                retval = rc;
              }

              break;
            }

          }
          default:
          {

          default_case:
            ;
            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, (unsigned int)rdlength, (void *)*ptr, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

          }
        }
      }

      else
        if(!(debug_p == 0))
        {
          return_value_getrrtpname$24=getrrtpname((signed int)type);
          debug_msg(0, "rrs2cent: ignoring record of type %s (%d), class %s (%d).\n", return_value_getrrtpname$24, type, (signed int)class == 1 ? "IN" : "[unknown]", class);
        }

    }
    *lcnt = *lcnt - (unsigned long int)rdlength;
    *ptr = *ptr + (signed long int)rdlength;
  }
  return retval;

trailing_junk:
  ;
  const char *return_value_getrrtpname$26;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname$26=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: %s record has trailing junk.\n", return_value_getrrtpname$26);
  }

  return 1;

record_too_short:
  ;
  const char *return_value_getrrtpname$27;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname$27=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: %s record too short.\n", return_value_getrrtpname$27);
  }

  return 1;

buffer_overflow:
  ;
  const char *return_value_getrrtpname$28;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname$28=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: buffer too small to process %s record.\n", return_value_getrrtpname$28);
  }

  return 1;

invalid_length:
  ;
  const char *return_value_getrrtpname$29;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname$29=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: %s record has length %u.\n", return_value_getrrtpname$29, rdlength);
  }

  return 1;
}

// run_as
// file helpers.h line 37
signed int run_as(const char *user)
{
  signed int return_value_initgroups$6;
  char *return_value_strerror$10;
  if(!(*user == 0))
  {
    struct passwd pwdbuf;
    struct passwd *pwd;
    unsigned long int buflen;
    signed int err;
    buflen = (unsigned long int)128;
    do
    {
      const signed long int err$array_size0 = (signed long int)buflen;
      char buf[err$array_size0];
      err=getpwnam_r(user, &pwdbuf, buf, buflen, &pwd);
      if(err == 0 && !(pwd == ((struct passwd *)NULL)))
      {
        signed int return_value_setgid$3;
        return_value_setgid$3=setgid(pwd->pw_gid);
        if(!(return_value_setgid$3 == 0))
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          char *return_value_strerror$2;
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          log_message(3, "Could not change group id to that of run_as user '%s': %s", user, return_value_strerror$2);
          return 0;
        }

        if(!(global.use_nss == 0))
        {
          return_value_initgroups$6=initgroups(user, pwd->pw_gid);
          if(!(return_value_initgroups$6 == 0))
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            char *return_value_strerror$5;
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            log_message(3, "Could not initialize the group access list of run_as user '%s': %s", user, return_value_strerror$5);
            return 0;
          }

        }

        signed int return_value_setuid$9;
        return_value_setuid$9=setuid(pwd->pw_uid);
        if(!(return_value_setuid$9 == 0))
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          char *return_value_strerror$8;
          return_value_strerror$8=strerror(*return_value___errno_location$7);
          log_message(3, "Could not change user id to that of run_as user '%s': %s", user, return_value_strerror$8);
          return 0;
        }

        break;
      }

      else
        if(!(err == 34))
        {
          if(!(err == 0))
          {
            return_value_strerror$10=strerror(err);
            log_message(3, "run_as user '%s' could not be found: %s", user, return_value_strerror$10);
          }

          else
            log_message(3, "run_as user '%s' could not be found.", user);
          return 0;
        }

        else
          if(buflen >= 16384ul)
          {
            log_message(3, "getpwnam_r() requires more than %u bytes of buffer space.", (unsigned int)buflen);
            return 0;
          }

      buflen = buflen * (unsigned long int)2;
    }
    while((_Bool)1);
  }

  return 1;
}

// same_inaddr2
// file helpers.h line 141
static inline signed int same_inaddr2(union anonymous$6 *a, struct anonymous$15 *b)
{
  signed int tmp_if_expr$5;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!(run_ipv4 == 0))
    tmp_if_expr$5 = (signed int)(a->ipv4.s_addr == b->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a->ipv6) == *((unsigned int *)&b->ipv6))
      tmp_if_expr$1 = ((unsigned int *)&a->ipv6)[(signed long int)1] == ((unsigned int *)&b->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ((unsigned int *)&a->ipv6)[(signed long int)2] == ((unsigned int *)&b->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = ((unsigned int *)&a->ipv6)[(signed long int)3] == ((unsigned int *)&b->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = b->ipv4.s_addr == (unsigned int)0x00000000 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = (signed int)tmp_if_expr$4;
  }
  return tmp_if_expr$5;
}

// scan_string
// file conf-parser.c line 186
static signed int scan_string(char **curp, char *outbuf, unsigned int outbufsz, char **errstr)
{
  char *cur = *curp;
  unsigned int i = (unsigned int)0;
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  if((signed int)*cur == 34)
  {
    cur = cur + 1l;
    for( ; (_Bool)1; cur = cur + 1l)
    {
      if(*cur == 0)
        goto noclosingquote;

      if((signed int)*cur == 34)
        break;

      if((signed int)*cur == 92)
      {
        cur = cur + 1l;
        if(*cur == 0)
          goto nofollowingchar;

        if(!(i >= outbufsz))
          outbuf[(signed long int)i]=translescapedchar(*cur);

      }

      else
        if(!(i >= outbufsz))
          outbuf[(signed long int)i] = *cur;

      i = i + 1u;
    }
    cur = cur + 1l;
  }

  else
    for( ; !(*cur == 0); cur = cur + 1l)
    {
      if((signed int)*cur == 92)
      {
        cur = cur + 1l;
        if(*cur == 0)
          goto nofollowingchar;

        if(!(i >= outbufsz))
          outbuf[(signed long int)i]=translescapedchar(*cur);

      }

      else
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        _Bool tmp_if_expr$2;
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*cur]) == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*cur == 44 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$3;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)*cur == 59 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$4;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)*cur == 123 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$5;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)*cur == 125 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$6;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*cur == 34 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$7;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)*cur == 35 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$10;
        if(tmp_if_expr$7)
          tmp_if_expr$10 = (_Bool)1;

        else
        {
          if((signed int)*cur == 47)
          {
            if((signed int)cur[1l] == 47)
              tmp_if_expr$8 = (_Bool)1;

            else
              tmp_if_expr$8 = (signed int)cur[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$9 = (_Bool)0;
          tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$10)
          break;

        else
          if(!(i >= outbufsz))
            outbuf[(signed long int)i] = *cur;

      }
      i = i + 1u;
    }
  if(!(i >= outbufsz))
    outbuf[(signed long int)i] = (char)0;

  *curp = cur;
  return (signed int)i;

noclosingquote:
  ;
  *errstr = "quoted string without closing quote";
  return -1;

nofollowingchar:
  ;
  *errstr = "may not use backslash to escape end-of-line";
  return -1;
}

// sched_server_test
// file servers.h line 38
void sched_server_test(union anonymous$6 *sa, signed int nadr, signed int up)
{
  signed int k;
  signed int signal_test;
  pthread_mutex_lock(&servers_lock);
  signal_test = 0;
  k = 0;
  const char *return_value_pdnsd_a2str$3;
  for( ; !(k >= nadr); k = k + 1)
  {
    union anonymous$6 *sak = &sa[(signed long int)k];
    signed int i;
    signed int n;
    unsigned int return_value_da_nel$1;
    return_value_da_nel$1=da_nel$link5((struct anonymous$3 *)servers);
    n = (signed int)return_value_da_nel$1;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous$7 *sp = &servers->elem[(signed long int)i];
      signed int j;
      signed int m;
      unsigned int return_value_da_nel$2;
      return_value_da_nel$2=da_nel$link5((struct anonymous$3 *)sp->atup_a);
      m = (signed int)return_value_da_nel$2;
      j = 0;
      for( ; !(j >= m); j = j + 1)
      {
        struct anonymous$20 *at = &sp->atup_a->elem[(signed long int)j];
        signed int return_value_equiv_inaddr2$4;
        return_value_equiv_inaddr2$4=equiv_inaddr2$link2(sak, &at->a);
        if(!(return_value_equiv_inaddr2$4 == 0))
        {
          if(up >= 0)
          {
            at->is_up = (char)up;
            at->i_ts=time((signed long int *)(void *)0);
            char _debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              return_value_pdnsd_a2str$3=pdnsd_a2str(sak, _debugsockabuf, 46);
              debug_msg(0, "Marked server %s %s.\n", return_value_pdnsd_a2str$3, up != 0 ? "up" : "down");
            }

          }

          else
            if(!(at->i_ts == 0l))
            {
              at->i_ts = (signed long int)0;
              signal_test = 1;
            }

        }

      }
    }
  }
  if(!(signal_test == 0))
    pthread_cond_signal(&server_test_cond);

  pthread_mutex_unlock(&servers_lock);
}

// scheme_ok
// file servers.c line 203
static signed int scheme_ok(struct anonymous$7 *serv)
{
  if(!(serv->scheme[0l] == 0))
  {
    if(schm[0l] == 0)
    {
      signed long int nschm;
      signed int sc;
      sc=open(global.scheme_file, 00);
      char *s;
      if(!(sc >= 0))
        return 0;

      nschm=read(sc, (void *)schm, sizeof(char [32l]) /*32ul*/  - (unsigned long int)1);
      close(sc);
      if(!(nschm >= 0l))
        return 0;

      schm[nschm] = (char)0;
      s=strchr(schm, 10);
      if(!(s == ((char *)NULL)))
        *s = (char)0;

    }

    signed int return_value_fnmatch$1;
    return_value_fnmatch$1=fnmatch(serv->scheme, schm, 0);
    if(!(return_value_fnmatch$1 == 0))
      return 0;

  }

  return 1;
}

// servstat_thread
// file servers.c line 314
void * servstat_thread(void *p)
{
  struct sigaction action;
  signed int keep_testing;
  pthread_mutex_lock(&servers_lock);
  signal_interrupt = 0;
  action.__sigaction_handler.sa_handler = sigint_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction$3;
  return_value_sigaction$3=sigaction(1, &action, (struct sigaction *)(void *)0);
  if(return_value_sigaction$3 == 0)
  {
    struct anonymous$41 smask;
    sigemptyset(&smask);
    sigaddset(&smask, 1);
    pthread_sigmask(1, &smask, (struct anonymous$41 *)(void *)0);
  }

  else
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_message(4, "Cannot install signal handler for server status thread: %s\n", return_value_strerror$2);
  }
  unsigned int return_value_da_nel$6;
  signed long int return_value_time$16;
  signed int return_value_needs_intermittent_testing$21;
  _Bool tmp_if_expr$22;
  signed int return_value_needs_intermittent_testing$26;
  do
  {

  __CPROVER_DUMP_L3:
    ;
    signed int i;
    signed int n;
    keep_testing = 0;
    retest_flag = (signed short int)0;
    schm[(signed long int)0] = (char)0;
    unsigned int return_value_da_nel$4;
    return_value_da_nel$4=da_nel$link5((struct anonymous$3 *)servers);
    n = (signed int)return_value_da_nel$4;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous$7 *sp = &servers->elem[(signed long int)i];
      signed int j;
      signed int m;
      if((signed int)sp->rootserver == 2)
      {
        struct anonymous$14 *adrs;
        signed int l;
        signed int one_up = 0;
        signed int return_value_scheme_ok$11;
        return_value_scheme_ok$11=scheme_ok(sp);
        if(return_value_scheme_ok$11 == 0)
        {
          signed long int servstat_thread$$1$$3$$1$$1$$1$$1$$1$$1$$now;
          servstat_thread$$1$$3$$1$$1$$1$$1$$1$$1$$now=time((signed long int *)(void *)0);
          unsigned int return_value_da_nel$5;
          return_value_da_nel$5=da_nel$link5((struct anonymous$3 *)sp->atup_a);
          m = (signed int)return_value_da_nel$5;
          j = 0;
          for( ; !(j >= m); j = j + 1)
            sp->atup_a->elem[(signed long int)j].i_ts = servstat_thread$$1$$3$$1$$1$$1$$1$$1$$1$$now;
        }

        else
        {
          _Bool tmp_if_expr$10;
          if((signed int)sp->uptest == 8)
            tmp_if_expr$10 = (_Bool)1;

          else
            tmp_if_expr$10 = (signed int)sp->uptest == 9 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$10)
          {
            if(sp->interval >= 1l)
            {
              return_value_da_nel$6=da_nel$link5((struct anonymous$3 *)sp->atup_a);
              one_up = (signed int)return_value_da_nel$6;
            }

            else
            {
              signed long int servstat_thread$$1$$3$$1$$1$$1$$1$$1$$2$$1$$now;
              servstat_thread$$1$$3$$1$$1$$1$$1$$1$$2$$1$$now=time((signed long int *)(void *)0);
              unsigned int return_value_da_nel$7;
              return_value_da_nel$7=da_nel$link5((struct anonymous$3 *)sp->atup_a);
              m = (signed int)return_value_da_nel$7;
              j = 0;
              for( ; !(j >= m); j = j + 1)
              {
                struct anonymous$20 *servstat_thread$$1$$3$$1$$1$$1$$1$$1$$2$$1$$1$$1$$at = &sp->atup_a->elem[(signed long int)j];
                _Bool tmp_if_expr$8;
                if(!(servstat_thread$$1$$3$$1$$1$$1$$1$$1$$2$$1$$1$$1$$at->is_up == 0))
                  tmp_if_expr$8 = (_Bool)1;

                else
                  tmp_if_expr$8 = servstat_thread$$1$$3$$1$$1$$1$$1$$1$$2$$1$$1$$1$$at->i_ts == (signed long int)0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$8)
                  one_up = 1;

                servstat_thread$$1$$3$$1$$1$$1$$1$$1$$2$$1$$1$$1$$at->i_ts = servstat_thread$$1$$3$$1$$1$$1$$1$$1$$2$$1$$now;
              }
            }
          }

          else
          {
            retest(i, -1);
            unsigned int return_value_da_nel$9;
            return_value_da_nel$9=da_nel$link5((struct anonymous$3 *)sp->atup_a);
            m = (signed int)return_value_da_nel$9;
            j = 0;
            for( ; !(j >= m); j = j + 1)
              if(!(sp->atup_a->elem[(signed long int)j].is_up == 0))
              {
                one_up = 1;
                break;
              }

          }
        }
        if(one_up == 0)
        {
          signed int return_value_needs_intermittent_testing$12;
          return_value_needs_intermittent_testing$12=needs_intermittent_testing(sp);
          if(!(return_value_needs_intermittent_testing$12 == 0))
            keep_testing = 1;

          goto __CPROVER_DUMP_L55;
        }

        if(!(debug_p == 0))
          debug_msg(0, "Attempting to discover root servers for server section #%d.\n", i);

        adrs=resolv_rootserver_addrs(sp->atup_a, (signed int)sp->port, sp->edns_query, sp->timeout);
        unsigned int return_value_da_nel$13;
        return_value_da_nel$13=da_nel$link5((struct anonymous$3 *)adrs);
        l = (signed int)return_value_da_nel$13;
        if(l >= 1)
        {
          struct timeval servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$now;
          struct timespec servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$timeout;
          struct anonymous$19 *ata;
          if(!(debug_p == 0))
            debug_msg(0, "Filling server section #%d with %d root server addresses.\n", i, l);

          gettimeofday(&servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$now, (struct timezone *)(void *)0);
          servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$timeout.tv_sec = servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$now.tv_sec + (signed long int)60;
          servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$timeout.tv_nsec = servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$now.tv_usec * (signed long int)1000;
          while(server_data_users >= 1)
          {
            signed int return_value_pthread_cond_timedwait$14;
            return_value_pthread_cond_timedwait$14=pthread_cond_timedwait(&server_data_cond, &servers_lock, &servstat_thread$$1$$3$$1$$1$$1$$1$$1$$6$$timeout);
            if(return_value_pthread_cond_timedwait$14 == 110)
            {
              if(!(debug_p == 0))
                debug_msg(0, "Timed out while waiting for exclusive access to server data to set root server addresses of server section #%d\n", i);

              free((void *)adrs);
              keep_testing = 1;
            }

          }
          struct anonymous$3 *return_value_da_resize$15;
          return_value_da_resize$15=da_resize((struct anonymous$3 *)(void *)0, (unsigned long int)((struct anonymous$19 *)0)->elem, sizeof(struct anonymous$20) /*32ul*/ , (unsigned long int)l, (void (*)(void *))(void *)0);
          ata = (struct anonymous$19 *)return_value_da_resize$15;
          if(ata == ((struct anonymous$19 *)NULL))
          {
            log_message(4, "Out of memory in servstat_thread() while discovering root servers.");
            free((void *)adrs);
            keep_testing = 1;
            goto __CPROVER_DUMP_L55;
          }

          j = 0;
          for( ; !(j >= l); j = j + 1)
          {
            struct anonymous$20 *at = &ata->elem[(signed long int)j];
            at->a = adrs->elem[(signed long int)j];
            at->is_up = sp->preset;
            signed long int tmp_if_expr$17;
            if(!(sp->interval >= 0l))
            {
              return_value_time$16=time((signed long int *)(void *)0);
              tmp_if_expr$17 = return_value_time$16;
            }

            else
              tmp_if_expr$17 = (signed long int)0;
            at->i_ts = tmp_if_expr$17;
          }
          free((void *)sp->atup_a);
          sp->atup_a = ata;
          free((void *)adrs);
          sp->rootserver = (char)1;
        }

        else
        {
          if(!(debug_p == 0))
            debug_msg(0, "Failed to discover root servers in servstat_thread() (server section #%d).\n", i);

          if(!(adrs == ((struct anonymous$14 *)NULL)))
            free((void *)adrs);

          unsigned int return_value_da_nel$18;
          return_value_da_nel$18=da_nel$link5((struct anonymous$3 *)sp->atup_a);
          if(!(return_value_da_nel$18 == 0u))
            keep_testing = 1;

          goto __CPROVER_DUMP_L55;
        }
      }

      signed int return_value_needs_testing$19;
      return_value_needs_testing$19=needs_testing$link1(sp);
      if(!(return_value_needs_testing$19 == 0))
        keep_testing = 1;

      unsigned int return_value_da_nel$20;
      return_value_da_nel$20=da_nel$link5((struct anonymous$3 *)sp->atup_a);
      m = (signed int)return_value_da_nel$20;
      j = 0;
      for( ; !(j >= m); j = j + 1)
        if(!(sp->atup_a->elem[(signed long int)j].i_ts == 0l))
          goto individual_tests;

      if(signal_interrupt == 0)
        retest(i, -1);

      goto __CPROVER_DUMP_L55;

    individual_tests:
      ;
      j = 0;
      for( ; signal_interrupt == 0 && !(j >= m); j = j + 1)
      {
        signed long int ts = sp->atup_a->elem[(signed long int)j].i_ts;
        signed long int now;
        _Bool tmp_if_expr$23;
        if(ts == 0l)
          tmp_if_expr$23 = (_Bool)1;

        else
        {
          return_value_needs_intermittent_testing$21=needs_intermittent_testing(sp);
          if(!(return_value_needs_intermittent_testing$21 == 0))
          {
            now=time((signed long int *)(void *)0);
            tmp_if_expr$22 = (now - ts > sp->interval ? (_Bool)1 : (ts > now ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$22 = (_Bool)0;
          tmp_if_expr$23 = tmp_if_expr$22 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$23)
          retest(i, j);

      }

    __CPROVER_DUMP_L55:
      ;
    }
    if(signal_interrupt == 0 && !(retest_flag == 0))
      goto __CPROVER_DUMP_L3;

    signal_interrupt = 0;
    if(keep_testing == 0)
      break;

    struct timeval servstat_thread$$1$$3$$1$$2$$now;
    struct timespec timeout;
    signed long int minwait;
    signed int servstat_thread$$1$$3$$1$$2$$i;
    signed int servstat_thread$$1$$3$$1$$2$$n;
    signed int retval;
    gettimeofday(&servstat_thread$$1$$3$$1$$2$$now, (struct timezone *)(void *)0);
    minwait = (signed long int)3600;
    unsigned int return_value_da_nel$24;
    return_value_da_nel$24=da_nel$link5((struct anonymous$3 *)servers);
    servstat_thread$$1$$3$$1$$2$$n = (signed int)return_value_da_nel$24;
    servstat_thread$$1$$3$$1$$2$$i = 0;
    for( ; !(servstat_thread$$1$$3$$1$$2$$i >= servstat_thread$$1$$3$$1$$2$$n); servstat_thread$$1$$3$$1$$2$$i = servstat_thread$$1$$3$$1$$2$$i + 1)
    {
      struct anonymous$7 *servstat_thread$$1$$3$$1$$2$$1$$1$$sp = &servers->elem[(signed long int)servstat_thread$$1$$3$$1$$2$$i];
      signed int servstat_thread$$1$$3$$1$$2$$1$$1$$j;
      signed int servstat_thread$$1$$3$$1$$2$$1$$1$$m;
      unsigned int return_value_da_nel$25;
      return_value_da_nel$25=da_nel$link5((struct anonymous$3 *)servstat_thread$$1$$3$$1$$2$$1$$1$$sp->atup_a);
      servstat_thread$$1$$3$$1$$2$$1$$1$$m = (signed int)return_value_da_nel$25;
      servstat_thread$$1$$3$$1$$2$$1$$1$$j = 0;
      for( ; !(servstat_thread$$1$$3$$1$$2$$1$$1$$j >= servstat_thread$$1$$3$$1$$2$$1$$1$$m); servstat_thread$$1$$3$$1$$2$$1$$1$$j = servstat_thread$$1$$3$$1$$2$$1$$1$$j + 1)
      {
        signed long int servstat_thread$$1$$3$$1$$2$$1$$1$$1$$1$$ts = servstat_thread$$1$$3$$1$$2$$1$$1$$sp->atup_a->elem[(signed long int)servstat_thread$$1$$3$$1$$2$$1$$1$$j].i_ts;
        if(servstat_thread$$1$$3$$1$$2$$1$$1$$1$$1$$ts == 0l)
        {
          if(minwait >= 1l)
            minwait = (signed long int)0;

        }

        else
        {
          return_value_needs_intermittent_testing$26=needs_intermittent_testing(servstat_thread$$1$$3$$1$$2$$1$$1$$sp);
          if(!(return_value_needs_intermittent_testing$26 == 0))
          {
            signed long int wait = (servstat_thread$$1$$3$$1$$2$$1$$1$$1$$1$$ts + servstat_thread$$1$$3$$1$$2$$1$$1$$sp->interval) - servstat_thread$$1$$3$$1$$2$$now.tv_sec;
            if(!(wait >= minwait))
              minwait = wait;

          }

        }
      }
    }
    timeout.tv_sec = servstat_thread$$1$$3$$1$$2$$now.tv_sec;
    if(minwait >= 1l)
      timeout.tv_sec = timeout.tv_sec + minwait;

    timeout.tv_nsec = servstat_thread$$1$$3$$1$$2$$now.tv_usec * (signed long int)1000 + (signed long int)500000000;
    if(timeout.tv_nsec >= 1000000000l)
    {
      timeout.tv_nsec = timeout.tv_nsec - (signed long int)1000000000;
      timeout.tv_sec = timeout.tv_sec + 1l;
    }

    retval=pthread_cond_timedwait(&server_test_cond, &servers_lock, &timeout);
    if(!(debug_p == 0))
      debug_msg(0, "Server status thread woke up (%s signal).\n", retval == 0 ? "test condition" : (retval == 110 ? "timer" : (retval == 4 ? "interrupt" : "error")));

  }
  while((_Bool)1);
  servstat_thrid = main_thrid;
  pthread_mutex_unlock(&servers_lock);
  if(!(debug_p == 0))
    debug_msg(0, "Server status thread exiting.\n");

  return (void *)0;
}

// set_all_flags_ttl
// file dns_query.c line 3210
static void set_all_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous$0 *cached)
{
  signed int i;
  signed int ilim;
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)cached->flags) == 0))
    tmp_if_expr$1 = 0;

  else
    tmp_if_expr$1 = cached->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
  ilim = tmp_if_expr$1;
  i = 0;
  for( ; !(i >= ilim); i = i + 1)
  {
    struct anonymous *rrset;
    struct anonymous *tmp_if_expr$2;
    if(!(i >= 8))
      tmp_if_expr$2 = cached->$anon0.rr.rrmu[(signed long int)i];

    else
      tmp_if_expr$2 = cached->$anon0.rr.rrext[(signed long int)(i - 8)];
    rrset = tmp_if_expr$2;
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      signed long int t;
      *flags = *flags | rrset->flags;
      signed long int tmp_if_expr$3;
      if(!(rrset->ttl >= 120l))
        tmp_if_expr$3 = (signed long int)120;

      else
        tmp_if_expr$3 = rrset->ttl;
      t = rrset->ts + tmp_if_expr$3;
      _Bool tmp_if_expr$4;
      if(*ttl == 0l)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = *ttl > t ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        *ttl = t;

    }

  }
}

// set_cent_flags
// file cache.h line 177
signed int set_cent_flags(const unsigned char *name, unsigned int flags)
{
  struct anonymous$0 *ret;
  lock_cache_rw();
  ret=dns_lookup(name, (struct anonymous$58 *)(void *)0);
  if(!(ret == ((struct anonymous$0 *)NULL)))
    ret->flags = ret->flags | (unsigned short int)flags;

  unlock_cache_rw();
  return (signed int)(ret != (struct anonymous$0 *)(void *)0);
}

// set_flags_ttl
// file dns_query.c line 3196
static signed int set_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous$0 *cached, signed int tp)
{
  struct anonymous *rrset;
  rrset=getrrset$link1(cached, tp);
  if(!(rrset == ((struct anonymous *)NULL)))
  {
    signed long int t;
    *flags = *flags | rrset->flags;
    signed long int tmp_if_expr$1;
    if(!(rrset->ttl >= 120l))
      tmp_if_expr$1 = (signed long int)120;

    else
      tmp_if_expr$1 = rrset->ttl;
    t = rrset->ts + tmp_if_expr$1;
    _Bool tmp_if_expr$2;
    if(*ttl == 0l)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = *ttl > t ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      *ttl = t;

    return 1;
  }

  return 0;
}

// sigint_handler
// file servers.c line 853
static void sigint_handler(signed int signum)
{
  signal_interrupt = 1;
}

// simple_dns_cached_resolve
// file dns_query.c line 3446
static signed int simple_dns_cached_resolve(struct anonymous$19 *atup_a, signed int port, char edns_query, signed long int timeout, const unsigned char *name, signed int thint, struct anonymous$0 **cachedp)
{
  struct anonymous$0 *cached = (struct anonymous$0 *)(void *)0;
  signed int rc;
  unsigned char _debugstrbuf[256l];
  const unsigned char *return_value_rhn2str$1;
  const char *return_value_get_tname$2;
  if(!(debug_p == 0))
  {
    return_value_rhn2str$1=rhn2str(name, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
    return_value_get_tname$2=get_tname(thint);
    debug_msg(0, "Starting simple cached resolve for: %s, query %s\n", return_value_rhn2str$1, return_value_get_tname$2);
  }

  signed long int return_value_time$3;
  return_value_time$3=time((signed long int *)(void *)0);
  rc=lookup_cache_status(name, thint, &cached, (unsigned short int *)(void *)0, return_value_time$3, (unsigned char *)(void *)0);
  if(rc == 0)
  {
    *cachedp = cached;
    return 0;
  }

  else
    if(rc == 3)
      return 3;

  if(!(rc == 0xfffb))
  {
    struct anonymous$4 *qserv;
    signed int j;
    signed int m;
    if(!(cached == ((struct anonymous$0 *)NULL)))
    {
      free_cent(cached);
      free((void *)cached);
      cached = (struct anonymous$0 *)(void *)0;
    }

    if(!(debug_p == 0))
      debug_msg(0, "Trying name servers.\n");

    qserv = (struct anonymous$4 *)(void *)0;
    unsigned int return_value_da_nel$4;
    return_value_da_nel$4=da_nel$link2((struct anonymous$3 *)atup_a);
    m = (signed int)return_value_da_nel$4;
    j = 0;
    for( ; !(j >= m); j = j + 1)
    {
      signed int return_value_add_qserv$5;
      return_value_add_qserv$5=add_qserv(&qserv, &atup_a->elem[(signed long int)j].a, port, timeout, (unsigned int)0, 0, (char)1, edns_query, (char)0, (char)0, (char)1, (const unsigned char *)(void *)0, (struct rejectlist_s *)(void *)0);
      if(return_value_add_qserv$5 == 0)
        return 2;

    }
    rc=p_recursive_query(qserv, name, thint, &cached, (signed int *)(void *)0, 0, (struct qstatnode_s *)(void *)0, (struct qhintnode_s *)(void *)0, (unsigned char *)(void *)0);
    del_qserv(qserv);
    if(rc == 0)
    {
      struct anonymous$0 *tc;
      add_cache(cached);
      tc=lookup_cache(name, (signed int *)(void *)0);
      if(!(tc == ((struct anonymous$0 *)NULL)))
      {
        free_cent(cached);
        free((void *)cached);
        cached = tc;
      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "simple_dns_cached_resolve: merging answer with cache failed, using local cent copy.\n");

    }

    else
      return rc;
  }

  else
    if(!(debug_p == 0))
      debug_msg(0, "Using cached record.\n");

  if(!((1 & (signed int)cached->flags) == 0))
  {
    free_cent(cached);
    free((void *)cached);
    return 3;
  }

  else
  {
    *cachedp = cached;
    return 0;
  }
}

// skiprhn
// file helpers.h line 88
static inline unsigned char * skiprhn(unsigned char *rhn)
{
  unsigned int lb;
  unsigned char *tmp_post$1;
  do
  {
    tmp_post$1 = rhn;
    rhn = rhn + 1l;
    lb = (unsigned int)*tmp_post$1;
    if(lb == 0u)
      break;

    rhn = rhn + (signed long int)lb;
  }
  while((_Bool)1);
  return rhn;
}

// skiprhn$link1
// file helpers.h line 88
static inline unsigned char * skiprhn$link1(unsigned char *rhn$link1)
{
  unsigned int lb$link1;
  unsigned char *tmp_post$1$link1;
  do
  {
    tmp_post$1$link1 = rhn$link1;
    rhn$link1 = rhn$link1 + 1l;
    lb$link1 = (unsigned int)*tmp_post$1$link1;
    if(lb$link1 == 0u)
      break;

    rhn$link1 = rhn$link1 + (signed long int)lb$link1;
  }
  while((_Bool)1);
  return rhn$link1;
}

// skiprhn$link2
// file helpers.h line 88
static inline unsigned char * skiprhn$link2(unsigned char *rhn$link2)
{
  unsigned int lb$link2;
  unsigned char *tmp_post$1$link2;
  do
  {
    tmp_post$1$link2 = rhn$link2;
    rhn$link2 = rhn$link2 + 1l;
    lb$link2 = (unsigned int)*tmp_post$1$link2;
    if(lb$link2 == 0u)
      break;

    rhn$link2 = rhn$link2 + (signed long int)lb$link2;
  }
  while((_Bool)1);
  return rhn$link2;
}

// skipsegs
// file helpers.h line 74
static inline const unsigned char * skipsegs(const unsigned char *nm, unsigned int k)
{
  unsigned int lb;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(k == 0u))
    {
      lb = (unsigned int)*nm;
      tmp_if_expr$1 = lb != 0u ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    nm = nm + (signed long int)(lb + (unsigned int)1);
    k = k - 1u;
  }
  while((_Bool)1);
  return nm;
}

// skipsegs$link1
// file helpers.h line 74
static inline const unsigned char * skipsegs$link1(const unsigned char *nm$link1, unsigned int k$link1)
{
  unsigned int lb$link1;
  _Bool tmp_if_expr$1$link1;
  do
  {
    if(!(k$link1 == 0u))
    {
      lb$link1 = (unsigned int)*nm$link1;
      tmp_if_expr$1$link1 = lb$link1 != 0u ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1$link1 = (_Bool)0;
    if(!tmp_if_expr$1$link1)
      break;

    nm$link1 = nm$link1 + (signed long int)(lb$link1 + (unsigned int)1);
    k$link1 = k$link1 - 1u;
  }
  while((_Bool)1);
  return nm$link1;
}

// skipsegs$link2
// file helpers.h line 74
static inline const unsigned char * skipsegs$link2(const unsigned char *nm$link2, unsigned int k$link2)
{
  unsigned int lb$link2;
  _Bool tmp_if_expr$1$link2;
  do
  {
    if(!(k$link2 == 0u))
    {
      lb$link2 = (unsigned int)*nm$link2;
      tmp_if_expr$1$link2 = lb$link2 != 0u ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1$link2 = (_Bool)0;
    if(!tmp_if_expr$1$link2)
      break;

    nm$link2 = nm$link2 + (signed long int)(lb$link2 + (unsigned int)1);
    k$link2 = k$link2 - 1u;
  }
  while((_Bool)1);
  return nm$link2;
}

// slist_add
// file conf-parser.c line 2074
static const char * slist_add(struct anonymous$8 **sla, const char *nm, unsigned int len, signed int tp)
{
  struct anonymous$9 *sl;
  signed int exact = 1;
  const char *err;
  unsigned long int sz;
  unsigned char rhn[256l];
  if(len >= 2u)
  {
    if((signed int)*nm == 46)
    {
      exact = 0;
      nm = nm + 1l;
      len = len - 1u;
    }

  }

  err=parsestr2rhn((unsigned char *)nm, len, rhn);
  if(!(err == ((const char *)NULL)))
    return err;

  else
  {
    unsigned int return_value_rhnlen$1;
    return_value_rhnlen$1=rhnlen(rhn);
    sz = (unsigned long int)return_value_rhnlen$1;
    struct anonymous$3 *return_value_da_grow1$2;
    return_value_da_grow1$2=da_grow1((struct anonymous$3 *)*sla, (unsigned long int)((struct anonymous$8 *)0)->elem, sizeof(struct anonymous$9) /*16ul*/ , free_slist_domain);
    *sla = (struct anonymous$8 *)return_value_da_grow1$2;
    if(*sla == ((struct anonymous$8 *)NULL))
      return "out of memory!";

    else
    {
      sl = &(*sla)->elem[(signed long int)((*sla)->nel - (unsigned long int)1)];
      sl->exact = (signed short int)exact;
      sl->rule = (signed short int)tp;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sz);
      sl->domain = (unsigned char *)return_value_malloc$3;
      if(sl->domain == ((unsigned char *)NULL))
        return "out of memory!";

      else
      {
        memcpy((void *)sl->domain, (const void *)rhn, sz);
        return (const char *)(void *)0;
      }
    }
  }
}

// soa_minimum
// file dns_query.c line 1106
static signed long int soa_minimum(struct rr_b_s *rrs)
{
  unsigned int minimum;
  unsigned char *p = (unsigned char *)rrs->data;
  unsigned char *return_value_skiprhn$1;
  return_value_skiprhn$1=skiprhn$link1(p);
  p=skiprhn$link1(return_value_skiprhn$1);
  p = p + (signed long int)((unsigned long int)4 * sizeof(unsigned int) /*4ul*/ );
  do
  {
    unsigned int t_l;
    const unsigned char *t_cp = (const unsigned char *)p;
    const unsigned char *tmp_post$2 = t_cp;
    t_cp = t_cp + 1l;
    t_l = (unsigned int)*tmp_post$2 << 24;
    const unsigned char *tmp_post$3 = t_cp;
    t_cp = t_cp + 1l;
    t_l = t_l | (unsigned int)*tmp_post$3 << 16;
    const unsigned char *tmp_post$4 = t_cp;
    t_cp = t_cp + 1l;
    t_l = t_l | (unsigned int)*tmp_post$4 << 8;
    const unsigned char *tmp_post$5 = t_cp;
    t_cp = t_cp + 1l;
    t_l = t_l | (unsigned int)*tmp_post$5;
    minimum = t_l;
    p = (unsigned char *)(void *)t_cp;
  }
  while((_Bool)0);
  return (signed long int)minimum;
}

// softlock_cache_r
// file cache.c line 371
static signed int softlock_cache_r(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int lk = 0;
    signed int tr = 0;
    do
    {
      signed int return_value_softlock_mutex$1;
      return_value_softlock_mutex$1=softlock_mutex(&lock_mutex);
      if(return_value_softlock_mutex$1 == 0)
        return 0;

      if(cache_w_lock == 0)
      {
        lk = 1;
        cache_r_lock = cache_r_lock + 1;
      }

      pthread_mutex_unlock(&lock_mutex);
      if(!(lk == 0))
        break;

      tr = tr + 1;
      if(tr >= 1000)
        return 0;

      usleep_r$link3((unsigned long int)1000);
    }
    while((_Bool)1);
    return 1;
  }
}

// softlock_cache_rw
// file cache.c line 408
static signed int softlock_cache_rw(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int lk = 0;
    signed int tr = 0;
    do
    {
      signed int return_value_softlock_mutex$1;
      return_value_softlock_mutex$1=softlock_mutex(&lock_mutex);
      if(return_value_softlock_mutex$1 == 0)
        return 0;

      if(cache_r_lock == 0 && cache_w_lock == 0)
      {
        lk = 1;
        cache_w_lock = 1;
      }

      pthread_mutex_unlock(&lock_mutex);
      if(!(lk == 0))
        break;

      tr = tr + 1;
      if(tr >= 1000)
        return 0;

      usleep_r$link3((unsigned long int)1000);
    }
    while((_Bool)1);
    return 1;
  }
}

// softlock_mutex
// file helpers.h line 39
signed int softlock_mutex(union anonymous$33 *mutex)
{
  unsigned int tr = (unsigned int)0;
  signed int return_value_pthread_mutex_trylock$1;
  do
  {
    return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(mutex);
    if(return_value_pthread_mutex_trylock$1 == 0)
      break;

    tr = tr + 1u;
    if(tr >= 1000u)
      return 0;

    usleep_r$link1((unsigned long int)10000);
  }
  while((_Bool)1);
  return 1;
}

// softunlock_cache_r
// file cache.c line 396
static signed int softunlock_cache_r(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int return_value_softlock_mutex$1;
    return_value_softlock_mutex$1=softlock_mutex(&lock_mutex);
    if(return_value_softlock_mutex$1 == 0)
      return 0;

    else
    {
      if(cache_r_lock >= 1)
        cache_r_lock = cache_r_lock - 1;

      pthread_mutex_unlock(&lock_mutex);
      return 1;
    }
  }
}

// softunlock_cache_rw
// file cache.c line 432
static signed int softunlock_cache_rw(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int return_value_softlock_mutex$1;
    return_value_softlock_mutex$1=softlock_mutex(&lock_mutex);
    if(return_value_softlock_mutex$1 == 0)
      return 0;

    else
    {
      cache_w_lock = 0;
      pthread_mutex_unlock(&lock_mutex);
      return 1;
    }
  }
}

// sort_rrl
// file cache.c line 1012
static void sort_rrl()
{
  _Bool tmp_if_expr$1;
  if(!(rrset_l == ((struct rr_lent_s *)NULL)))
  {
    if(!(rrset_l->next == ((struct rr_lent_s *)NULL)))
    {
      struct rr_lent_s *tmp[32l];
      struct rr_lent_s **fill = tmp;
      struct rr_lent_s **end = tmp + (signed long int)32;
      struct rr_lent_s **counter;
      struct rr_lent_s *rem = rrset_l;
      struct rr_lent_s *carry;
      do
      {
        carry = rem;
        rem = rem->next;
        carry->next = (struct rr_lent_s *)(void *)0;
        counter = tmp;
        do
        {
          if(!(counter == fill))
            tmp_if_expr$1 = *counter != (struct rr_lent_s *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          carry=listmerge(*counter, carry);
          *counter = (struct rr_lent_s *)(void *)0;
          counter = counter + 1l;
        }
        while((_Bool)1);
        if(counter == end)
        {
          log_message(3, "%s:%d: %s", (const void *)"cache.c", 1032, (const void *)"sort_rrl: tmp array overflowed");
          pdnsd_exit();
        }

        *counter = carry;
        if(counter == fill)
          fill = fill + 1l;

      }
      while(!(rem == ((struct rr_lent_s *)NULL)));
      carry = tmp[(signed long int)0];
      counter = tmp;
      do
      {
        counter = counter + 1l;
        if(counter == fill)
          break;

        carry=listmerge(*counter, carry);
      }
      while((_Bool)1);
      rrset_l = carry;
      struct rr_lent_s *p;
      struct rr_lent_s *q = (struct rr_lent_s *)(void *)0;
      p = rrset_l;
      for( ; !(p == ((struct rr_lent_s *)NULL)); p = p->next)
      {
        p->prev = q;
        q = p;
      }
      rrset_l_tail = q;
    }

  }

}

// start_dns_servers
// file dns_answer.c line 2109
void start_dns_servers(void)
{
  if(!(tcp_socket == -1))
  {
    unsigned long int tcps;
    signed int return_value_pthread_create$1;
    return_value_pthread_create$1=pthread_create(&tcps, &attr_detached, tcp_server_thread, (void *)0);
    if(!(return_value_pthread_create$1 == 0))
    {
      log_message(3, "Could not create TCP server thread. Exiting.");
      pdnsd_exit();
    }

    else
    {
      tcps_thrid = tcps;
      if((signed int)global.verbosity >= 2)
        log_message(6, "TCP server thread started.");

    }
  }

  if(!(udp_socket == -1))
  {
    unsigned long int udps;
    signed int return_value_pthread_create$2;
    return_value_pthread_create$2=pthread_create(&udps, &attr_detached, udp_server_thread, (void *)0);
    if(!(return_value_pthread_create$2 == 0))
    {
      log_message(3, "Could not create UDP server thread. Exiting.");
      pdnsd_exit();
    }

    else
    {
      udps_thrid = udps;
      if((signed int)global.verbosity >= 2)
        log_message(6, "UDP server thread started.");

    }
  }

}

// start_servstat_thread
// file servers.h line 37
signed int start_servstat_thread(void)
{
  unsigned long int stt;
  signed int rv;
  rv=pthread_create(&stt, &attr_detached, servstat_thread, (void *)0);
  char *return_value_strerror$1;
  if(!(rv == 0))
  {
    return_value_strerror$1=strerror(rv);
    log_message(4, "Failed to start server status thread: %s", return_value_strerror$1);
  }

  else
  {
    servstat_thrid = stt;
    if((signed int)global.verbosity >= 2)
      log_message(6, "Server status thread started.");

  }
  return rv;
}

// start_stat_sock
// file status.h line 57
signed int start_stat_sock(void)
{
  unsigned long int st;
  signed int rv;
  rv=pthread_create(&st, &attr_detached, status_thread, (void *)0);
  if(!(rv == 0))
    log_message(4, "Failed to start status thread. The status socket will be unuseable");

  else
  {
    statsock_thrid = st;
    if((signed int)global.verbosity >= 2)
      log_message(6, "Status thread started.");

  }
  return rv;
}

// status_thread
// file status.c line 172
static void * status_thread(void *p)
{
  if(global.strict_suid == 0)
  {
    signed int return_value_run_as$1;
    return_value_run_as$1=run_as(global.run_as);
    if(return_value_run_as$1 == 0)
      pdnsd_exit();

  }

  signed int return_value_listen$4;
  return_value_listen$4=listen(stat_sock, 5);
  if(return_value_listen$4 == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    log_message(4, "Error: could not listen on socket: %s.\nStatus readback will be impossible", return_value_strerror$3);
    goto exit_thread;
  }

  signed int return_value_report_cache_stat$9;
  signed int return_value_report_thread_stat$11;
  signed int return_value_report_conf_stat$13;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int return_value_read_allocstring$17;
  unsigned int return_value_da_nel$19;
  unsigned int return_value_da_nel$22;
  signed int return_value_strcmp$23;
  unsigned int return_value_da_nel$25;
  signed int return_value_strcmp$26;
  const unsigned short int **return_value___ctype_b_loc$27;
  const unsigned short int **return_value___ctype_b_loc$29;
  signed int return_value_read_long$37;
  signed int return_value_read_short$39;
  signed int return_value_read_short$41;
  signed int return_value_read_short$48;
  void *return_value_malloc$49;
  signed int return_value_read_domain$50;
  signed long int return_value_read$51;
  signed int return_value_read_domain$52;
  unsigned int return_value_rhnlen$53;
  signed int return_value_add_cent_rr$56;
  _Bool tmp_if_expr$80;
  char *tmp_if_expr$78;
  signed int return_value_fsprintf$79;
  signed int *return_value___errno_location$76;
  char *return_value_strerror$77;
  signed int *return_value___errno_location$85;
  do
  {
    struct sockaddr_un ra;
    unsigned int res = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
    signed int rs;
    rs=accept(stat_sock, (struct sockaddr *)&ra, &res);
    if(!(rs == -1))
    {
      unsigned short int cmd;
      if(!(debug_p == 0))
        debug_msg(0, "Status socket query pending.\n");

      signed int return_value_read_short$82;
      return_value_read_short$82=read_short(rs, &cmd);
      if(!(return_value_read_short$82 == 0))
      {
        if((0xff00 & (signed int)cmd) == 0x6800)
        {
          const char *errmsg;
          cmd = cmd & (unsigned short int)0xff;
          if(!((signed int)cmd == 1))
          {
            if((signed int)cmd == 2)
              goto __CPROVER_DUMP_L17;

            if((signed int)cmd == 3)
              goto __CPROVER_DUMP_L62;

            if((signed int)cmd == 4)
              goto __CPROVER_DUMP_L68;

            if((signed int)cmd == 5)
              goto __CPROVER_DUMP_L84;

            if((signed int)cmd == 6)
              goto __CPROVER_DUMP_L106;

            if((signed int)cmd == 7)
              goto __CPROVER_DUMP_L118;

            if((signed int)cmd == 8)
              goto __CPROVER_DUMP_L123;

            if((signed int)cmd == 9)
              goto __CPROVER_DUMP_L128;

            if((signed int)cmd == 10)
              goto __CPROVER_DUMP_L133;

            if((signed int)cmd == 11)
              goto __CPROVER_DUMP_L152;

          }

          else
          {
            struct utsname nm;
            if(!(debug_p == 0))
              debug_msg(0, "Received STATUS query.\n");

            signed int return_value_print_succ$5;
            return_value_print_succ$5=print_succ(rs);
            if(return_value_print_succ$5 == 0)
              goto __CPROVER_DUMP_L172;

            uname(&nm);
            signed int return_value_fsprintf$8;
            return_value_fsprintf$8=fsprintf(rs, "pdnsd-%s running on %s.\n", (const void *)"1.2.9a-par", (const void *)nm.nodename);
            _Bool tmp_if_expr$10;
            if(!(return_value_fsprintf$8 >= 0))
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              return_value_report_cache_stat$9=report_cache_stat(rs);
              tmp_if_expr$10 = return_value_report_cache_stat$9 < 0 ? (_Bool)1 : (_Bool)0;
            }
            _Bool tmp_if_expr$12;
            if(tmp_if_expr$10)
              tmp_if_expr$12 = (_Bool)1;

            else
            {
              return_value_report_thread_stat$11=report_thread_stat(rs);
              tmp_if_expr$12 = return_value_report_thread_stat$11 < 0 ? (_Bool)1 : (_Bool)0;
            }
            _Bool tmp_if_expr$14;
            if(tmp_if_expr$12)
              tmp_if_expr$14 = (_Bool)1;

            else
            {
              return_value_report_conf_stat$13=report_conf_stat(rs);
              tmp_if_expr$14 = return_value_report_conf_stat$13 < 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$14)
            {
              if(!(debug_p == 0))
              {
                return_value___errno_location$6=__errno_location();
                return_value_strerror$7=strerror(*return_value___errno_location$6);
                debug_msg(0, "Error writing to control socket: %s\nFailed to send status report.\n", return_value_strerror$7);
              }

            }

            goto __CPROVER_DUMP_L172;

          __CPROVER_DUMP_L17:
            ;
            char *label;
            char *dnsaddr;
            signed int indx;
            unsigned short int cmd2;
            if(!(debug_p == 0))
              debug_msg(0, "Received SERVER command.\n");

            signed int return_value_read_allocstring$15;
            return_value_read_allocstring$15=read_allocstring(rs, &label, (unsigned int *)(void *)0);
            if(!(return_value_read_allocstring$15 >= 1))
            {
              print_serr(rs, "Error reading server label.");
              goto __CPROVER_DUMP_L172;
            }

            signed int return_value_read_short$16;
            return_value_read_short$16=read_short(rs, &cmd2);
            if(return_value_read_short$16 == 0)
              print_serr(rs, "Missing up|down|retest.");

            else
            {
              return_value_read_allocstring$17=read_allocstring(rs, &dnsaddr, (unsigned int *)(void *)0);
              if(return_value_read_allocstring$17 == 0)
                print_serr(rs, "Error reading DNS addresses.");

              else
              {
                char *endptr;
                signed long int return_value_strtol$18;
                return_value_strtol$18=strtol(label, &endptr, 0);
                indx = (signed int)return_value_strtol$18;
                if(*endptr == 0)
                {
                  _Bool tmp_if_expr$20;
                  if(!(indx >= 0))
                    tmp_if_expr$20 = (_Bool)1;

                  else
                  {
                    return_value_da_nel$19=da_nel$link4((struct anonymous$3 *)servers);
                    tmp_if_expr$20 = (unsigned int)indx >= return_value_da_nel$19 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$20)
                  {
                    print_serr(rs, "Server index out of range.");
                    goto free_dnsaddr_label_break;
                  }

                }

                else
                {
                  signed int return_value_strcmp$21;
                  return_value_strcmp$21=strcmp(label, "all");
                  if(return_value_strcmp$21 == 0)
                    indx = -2;

                  else
                    indx = -1;
                }
                if((signed int)cmd2 == 1 || (signed int)cmd2 == 2 || (signed int)cmd2 == 3)
                {
                  if(dnsaddr == ((char *)NULL))
                  {
                    if(indx == -1)
                    {
                      signed int i = 0;
                      do
                      {
                        return_value_da_nel$22=da_nel$link4((struct anonymous$3 *)servers);
                        if((unsigned int)i >= return_value_da_nel$22)
                          break;

                        char *servlabel = servers->elem[(signed long int)i].label;
                        if(!(servlabel == ((char *)NULL)))
                        {
                          return_value_strcmp$23=strcmp(servlabel, label);
                          if(return_value_strcmp$23 == 0)
                            goto found_label;

                        }

                        i = i + 1;
                      }
                      while((_Bool)1);
                      print_serr(rs, "Bad server label.");
                      goto free_dnsaddr_label_break;
                    }


                  found_label:
                    ;
                    signed int return_value_mark_servers$24;
                    return_value_mark_servers$24=mark_servers(indx, indx == -1 ? label : (char *)(void *)0, (signed int)cmd2 == 3 ? -1 : (signed int)((signed int)cmd2 == 1));
                    if(return_value_mark_servers$24 == 0)
                      print_succ(rs);

                    else
                      print_serr(rs, "Could not start up or signal server status thread.");
                  }

                  else
                  {
                    if(indx == -2)
                    {
                      print_serr(rs, "Can't use label \"all\" to change server addresses.");
                      goto free_dnsaddr_label_break;
                    }

                    if(indx == -1)
                    {
                      signed int status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$i = 0;
                      do
                      {
                        return_value_da_nel$25=da_nel$link4((struct anonymous$3 *)servers);
                        if((unsigned int)status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$i >= return_value_da_nel$25)
                          break;

                        char *status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$1$$1$$servlabel = servers->elem[(signed long int)status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$i].label;
                        if(!(status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$1$$1$$servlabel == ((char *)NULL)))
                        {
                          return_value_strcmp$26=strcmp(status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$1$$1$$servlabel, label);
                          if(return_value_strcmp$26 == 0)
                          {
                            if(!(indx == -1))
                            {
                              print_serr(rs, "server label must be unique to change server addresses.");
                              goto free_dnsaddr_label_break;
                            }

                            indx = status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$i;
                          }

                        }

                        status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$i = status_thread$$1$$3$$1$$1$$2$$1$$1$$2$$6$$2$$2$$i + 1;
                      }
                      while((_Bool)1);
                      if(indx == -1)
                      {
                        print_serr(rs, "Bad server label.");
                        goto free_dnsaddr_label_break;
                      }

                    }

                    char *ipstr;
                    char *q = dnsaddr;
                    struct anonymous$54 *ar = (struct anonymous$54 *)(void *)0;
                    union anonymous$6 addr;
                    signed int err;

                  __CPROVER_DUMP_L45:
                    ;
                    while(!(*q == 0))
                    {
                      if(!((signed int)*q == 44))
                      {
                        return_value___ctype_b_loc$27=__ctype_b_loc();
                        if((8192 & (signed int)(*return_value___ctype_b_loc$27)[(signed long int)(signed int)*q]) == 0)
                          goto __CPROVER_DUMP_L47;

                      }

                      q = q + 1l;
                      goto __CPROVER_DUMP_L45;

                    __CPROVER_DUMP_L47:
                      ;
                      ipstr = q;
                      do
                      {
                        q = q + 1l;
                        if(*q == 0)
                          break;

                        _Bool tmp_if_expr$30;
                        if((signed int)*q == 44)
                          tmp_if_expr$30 = (_Bool)1;

                        else
                        {
                          return_value___ctype_b_loc$29=__ctype_b_loc();
                          tmp_if_expr$30 = ((signed int)(*return_value___ctype_b_loc$29)[(signed long int)(signed int)*q] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr$30)
                        {
                          char *tmp_post$28 = q;
                          q = q + 1l;
                          *tmp_post$28 = (char)0;
                          break;
                        }

                      }
                      while((_Bool)1);
                      signed int return_value_str2pdnsd_a$31;
                      return_value_str2pdnsd_a$31=str2pdnsd_a(ipstr, &addr);
                      if(return_value_str2pdnsd_a$31 == 0)
                      {
                        print_serr(rs, "Bad server ip");
                        goto free_ar;
                      }

                      struct anonymous$3 *return_value_da_grow1$32;
                      return_value_da_grow1$32=da_grow1((struct anonymous$3 *)ar, (unsigned long int)((struct anonymous$54 *)0)->elem, sizeof(union anonymous$6) /*16ul*/ , (void (*)(void *))(void *)0);
                      ar = (struct anonymous$54 *)return_value_da_grow1$32;
                      if(ar == ((struct anonymous$54 *)NULL))
                      {
                        print_serr(rs, "Out of memory.");
                        goto free_dnsaddr_label_break;
                      }

                      ar->elem[(signed long int)(ar->nel - (unsigned long int)1)] = addr;
                    }

                  change_servs:
                    ;
                    err=change_servers(indx, ar, (signed int)cmd2 == 3 ? -1 : (signed int)((signed int)cmd2 == 1));
                    if(err == 0)
                      print_succ(rs);

                    else
                      print_serr(rs, err == 110 ? "Timed out while trying to gain access to server data." : (err == 12 ? "Out of memory." : "Could not start up or signal server status thread."));

                  free_ar:
                    ;
                    free((void *)ar);
                  }
                }

                else
                  print_serr(rs, "Bad command.");

              free_dnsaddr_label_break:
                ;
                free((void *)dnsaddr);
              }
            }

          free_label_break:
            ;
            free((void *)label);
            goto __CPROVER_DUMP_L172;

          __CPROVER_DUMP_L62:
            ;
            unsigned short int status_thread$$1$$3$$1$$1$$2$$1$$1$$3$$cmd2;
            unsigned char name[256l];
            unsigned char buf[256l];
            if(!(debug_p == 0))
              debug_msg(0, "Received RECORD command.\n");

            signed int return_value_read_short$33;
            return_value_read_short$33=read_short(rs, &status_thread$$1$$3$$1$$1$$2$$1$$1$$3$$cmd2);
            if(!(return_value_read_short$33 == 0))
            {
              signed int return_value_read_domain$34;
              return_value_read_domain$34=read_domain(rs, (char *)buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
              if(return_value_read_domain$34 >= 1)
              {
                errmsg=parsestr2rhn(buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , name);
                if(!(errmsg == ((const char *)NULL)))
                  goto bad_domain_name;

                switch((signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$3$$cmd2)
                {
                  case 1:
                  {
                    del_cache(name);
                    print_succ(rs);
                    break;
                  }
                  case 2:
                  {
                    invalidate_record(name);
                    print_succ(rs);
                    break;
                  }
                  default:
                    print_serr(rs, "Bad command.");
                }
                goto __CPROVER_DUMP_L172;

              __CPROVER_DUMP_L68:
                ;
                unsigned int ttl;
                char *fn;
                unsigned short int servaliases;
                unsigned short int flags;
                unsigned char status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$buf[256l];
                unsigned char owner[256l];
                if(!(debug_p == 0))
                  debug_msg(0, "Received SOURCE command.\n");

                signed int return_value_read_allocstring$35;
                return_value_read_allocstring$35=read_allocstring(rs, &fn, (unsigned int *)(void *)0);
                if(!(return_value_read_allocstring$35 >= 1))
                {
                  print_serr(rs, "Bad filename name.");
                  goto __CPROVER_DUMP_L172;
                }

                signed int return_value_read_domain$36;
                return_value_read_domain$36=read_domain(rs, (char *)status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                _Bool tmp_if_expr$38;
                if(!(return_value_read_domain$36 >= 1))
                  tmp_if_expr$38 = (_Bool)1;

                else
                {
                  return_value_read_long$37=read_long(rs, &ttl);
                  tmp_if_expr$38 = !(return_value_read_long$37 != 0) ? (_Bool)1 : (_Bool)0;
                }
                _Bool tmp_if_expr$40;
                if(tmp_if_expr$38)
                  tmp_if_expr$40 = (_Bool)1;

                else
                {
                  return_value_read_short$39=read_short(rs, &servaliases);
                  tmp_if_expr$40 = !(return_value_read_short$39 != 0) ? (_Bool)1 : (_Bool)0;
                }
                _Bool tmp_if_expr$42;
                if(tmp_if_expr$40)
                  tmp_if_expr$42 = (_Bool)1;

                else
                {
                  return_value_read_short$41=read_short(rs, &flags);
                  tmp_if_expr$42 = !(return_value_read_short$41 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$42)
                  print_serr(rs, "Malformed or incomplete command.");

                else
                {
                  errmsg=parsestr2rhn(status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , owner);
                  if(!(errmsg == ((const char *)NULL)))
                    print_serr(rs, errmsg);

                  else
                    if(!((1 & (signed int)flags) == 0))
                      print_serr(rs, "Bad cache flags.");

                    else
                    {
                      char *status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$7$$errmsg;
                      signed int return_value_read_hosts$43;
                      return_value_read_hosts$43=read_hosts(fn, owner, (signed long int)ttl, (unsigned int)flags, (signed int)servaliases, &status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$7$$errmsg);
                      if(!(return_value_read_hosts$43 == 0))
                        print_succ(rs);

                      else
                      {
                        print_serr(rs, (_Bool)status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$7$$errmsg ? status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$7$$errmsg : "Out of memory.");
                        free((void *)status_thread$$1$$3$$1$$1$$2$$1$$1$$4$$7$$errmsg);
                      }
                    }
                }

              free_fn:
                ;
                free((void *)fn);
                goto __CPROVER_DUMP_L172;

              __CPROVER_DUMP_L84:
                ;
                unsigned int status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$ttl;
                unsigned int sz;
                unsigned short int tp;
                unsigned short int status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$flags;
                unsigned short int nadr = (unsigned short int)0;
                unsigned char status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$name[256l];
                unsigned char status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$buf[256l];
                unsigned char dbuf[258l];
                unsigned long int adrbufsz = (unsigned long int)0;
                unsigned char *adrbuf = (unsigned char *)(void *)0;
                if(!(debug_p == 0))
                  debug_msg(0, "Received ADD command.\n");

                signed int return_value_read_short$44;
                return_value_read_short$44=read_short(rs, &tp);
                if(!(return_value_read_short$44 == 0))
                {
                  signed int return_value_read_domain$45;
                  return_value_read_domain$45=read_domain(rs, (char *)status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                  if(return_value_read_domain$45 >= 1)
                  {
                    signed int return_value_read_long$46;
                    return_value_read_long$46=read_long(rs, &status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$ttl);
                    if(!(return_value_read_long$46 == 0))
                    {
                      signed int return_value_read_short$47;
                      return_value_read_short$47=read_short(rs, &status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$flags);
                      if(!(return_value_read_short$47 == 0))
                      {
                        errmsg=parsestr2rhn(status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$name);
                        if(!(errmsg == ((const char *)NULL)))
                          goto bad_domain_name;

                        if(!((1 & (signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$flags) == 0))
                          goto bad_flags;

                        if(!((signed int)tp == 1))
                        {
                          if((signed int)tp == 28)
                            goto __CPROVER_DUMP_L87;

                          if((signed int)tp == 2 || (signed int)tp == 5 || (signed int)tp == 12)
                            goto __CPROVER_DUMP_L92;

                          if((signed int)tp == 15)
                            goto __CPROVER_DUMP_L93;

                        }

                        else
                        {
                          sz = (unsigned int)sizeof(struct in_addr) /*4ul*/ ;
                          goto read_adress_list;

                        __CPROVER_DUMP_L87:
                          ;
                          sz = (unsigned int)sizeof(struct in6_addr) /*16ul*/ ;

                        read_adress_list:
                          ;
                          return_value_read_short$48=read_short(rs, &nadr);
                          if(return_value_read_short$48 == 0)
                            goto incomplete_command;

                          if(nadr == 0)
                            goto bad_arg;

                          adrbufsz = (unsigned long int)nadr * (unsigned long int)sz;
                          return_value_malloc$49=malloc(adrbufsz);
                          adrbuf = (unsigned char *)return_value_malloc$49;
                          if(adrbuf == ((unsigned char *)NULL))
                            goto out_of_memory;

                          unsigned long int nread = (unsigned long int)0;
                          while(!(nread >= adrbufsz))
                          {
                            signed long int m;
                            m=read(rs, (void *)(adrbuf + (signed long int)nread), adrbufsz - nread);
                            if(!(m >= 1l))
                            {
                              free((void *)adrbuf);
                              goto bad_arg;
                            }

                            nread = nread + (unsigned long int)m;
                          }
                          goto __CPROVER_DUMP_L95;

                        __CPROVER_DUMP_L92:
                          ;
                          return_value_read_domain$50=read_domain(rs, (char *)status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                          if(!(return_value_read_domain$50 >= 1))
                            goto incomplete_command;

                          errmsg=parsestr2rhn(status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , dbuf);
                          if(!(errmsg == ((const char *)NULL)))
                            goto bad_domain_name;

                          sz=rhnlen$link5(dbuf);
                          goto __CPROVER_DUMP_L95;

                        __CPROVER_DUMP_L93:
                          ;
                          return_value_read$51=read(rs, (void *)dbuf, (unsigned long int)2);
                          if(!(return_value_read$51 == 2l))
                            goto bad_arg;

                          return_value_read_domain$52=read_domain(rs, (char *)status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                          if(!(return_value_read_domain$52 >= 1))
                            goto incomplete_command;

                          errmsg=parsestr2rhn(status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , dbuf + (signed long int)2);
                          if(!(errmsg == ((const char *)NULL)))
                            goto bad_domain_name;

                          return_value_rhnlen$53=rhnlen$link5(dbuf + (signed long int)2);
                          sz = return_value_rhnlen$53 + (unsigned int)2;
                          goto __CPROVER_DUMP_L95;
                        }
                        goto bad_arg;

                      __CPROVER_DUMP_L95:
                        ;
                        struct anonymous$0 cent;
                        signed int return_value_init_cent$54;
                        return_value_init_cent$54=init_cent(&cent, status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$name, (signed long int)0, (signed long int)0, (unsigned int)status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$flags);
                        if(return_value_init_cent$54 == 0)
                        {
                          free((void *)adrbuf);
                          goto out_of_memory;
                        }

                        if(!(adrbuf == ((unsigned char *)NULL)))
                        {
                          unsigned char *adrp;
                          signed int status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$3$$2$$i;
                          adrp = adrbuf;
                          status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$3$$2$$i = 0;
                          for( ; !(status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$3$$2$$i >= (signed int)nadr); status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$3$$2$$i = status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$3$$2$$i + 1)
                          {
                            signed int return_value_add_cent_rr$55;
                            return_value_add_cent_rr$55=add_cent_rr(&cent, (signed int)tp, (signed long int)status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$ttl, (signed long int)0, (unsigned int)2, sz, (void *)adrp);
                            if(return_value_add_cent_rr$55 == 0)
                            {
                              free_cent(&cent);
                              free((void *)adrbuf);
                              goto out_of_memory;
                            }

                            adrp = adrp + (signed long int)sz;
                          }
                          free((void *)adrbuf);
                        }

                        else
                        {
                          return_value_add_cent_rr$56=add_cent_rr(&cent, (signed int)tp, (signed long int)status_thread$$1$$3$$1$$1$$2$$1$$1$$5$$ttl, (signed long int)0, (unsigned int)2, sz, (void *)dbuf);
                          if(return_value_add_cent_rr$56 == 0)
                          {
                            free_cent(&cent);
                            goto out_of_memory;
                          }

                        }
                        if((signed int)*cent.qname == 1)
                        {
                          if((signed int)cent.qname[1l] == 42)
                          {
                            signed int return_value_set_cent_flags$57;
                            return_value_set_cent_flags$57=set_cent_flags(&cent.qname[(signed long int)2], (unsigned int)16);
                            if(return_value_set_cent_flags$57 == 0)
                            {
                              print_serr(rs, "Before defining records for a name with a wildcard you must first define some records for the name with '*.' removed.");
                              goto cleanup_cent;
                            }

                          }

                        }

                        add_cache(&cent);
                        print_succ(rs);

                      cleanup_cent:
                        ;
                        free_cent(&cent);
                        goto __CPROVER_DUMP_L172;

                      __CPROVER_DUMP_L106:
                        ;
                        unsigned int status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$ttl;
                        unsigned short int status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp;
                        unsigned char status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$name[256l];
                        unsigned char status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$buf[256l];
                        if(!(debug_p == 0))
                          debug_msg(0, "Received NEG command.\n");

                        signed int return_value_read_domain$58;
                        return_value_read_domain$58=read_domain(rs, (char *)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                        if(return_value_read_domain$58 >= 1)
                        {
                          signed int return_value_read_short$59;
                          return_value_read_short$59=read_short(rs, &status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp);
                          if(!(return_value_read_short$59 == 0))
                          {
                            signed int return_value_read_long$60;
                            return_value_read_long$60=read_long(rs, &status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$ttl);
                            if(!(return_value_read_long$60 == 0))
                            {
                              errmsg=parsestr2rhn(status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$name);
                              if(!(errmsg == ((const char *)NULL)))
                              {
                                if(!(debug_p == 0))
                                  debug_msg(0, "NEG: received bad domain name.\n");

                                goto bad_domain_name;
                              }

                              if(!((signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp == 255))
                              {
                                _Bool tmp_if_expr$61;
                                if((signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp >= 52 || !((signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp >= 1))
                                  tmp_if_expr$61 = (_Bool)1;

                                else
                                  tmp_if_expr$61 = (signed int)rrlkuptab[(signed long int)((signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr$61)
                                {
                                  if(!(debug_p == 0))
                                    debug_msg(0, "NEG: received bad record type.\n");

                                  print_serr(rs, "Bad record type.");
                                  goto __CPROVER_DUMP_L172;
                                }

                              }

                              struct anonymous$0 status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$4$$cent;
                              if((signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp == 255)
                              {
                                signed int return_value_init_cent$62;
                                return_value_init_cent$62=init_cent(&status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$4$$cent, status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$name, (signed long int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$ttl, (signed long int)0, (unsigned int)(2 | 1));
                                if(return_value_init_cent$62 == 0)
                                  goto out_of_memory;

                              }

                              else
                              {
                                signed int return_value_init_cent$63;
                                return_value_init_cent$63=init_cent(&status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$4$$cent, status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$name, (signed long int)0, (signed long int)0, (unsigned int)0);
                                if(return_value_init_cent$63 == 0)
                                  goto out_of_memory;

                                signed int return_value_add_cent_rrset_by_type$64;
                                return_value_add_cent_rrset_by_type$64=add_cent_rrset_by_type(&status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$4$$cent, (signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$tp, (signed long int)status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$ttl, (signed long int)0, (unsigned int)(2 | 1));
                                if(return_value_add_cent_rrset_by_type$64 == 0)
                                {
                                  free_cent(&status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$4$$cent);
                                  goto out_of_memory;
                                }

                              }
                              add_cache(&status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$4$$cent);
                              free_cent(&status_thread$$1$$3$$1$$1$$2$$1$$1$$6$$4$$cent);
                              print_succ(rs);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L118:
                              ;
                              char *status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$fn;
                              char *status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$errmsg;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received CONFIG command.\n");

                              signed int return_value_read_allocstring$65;
                              return_value_read_allocstring$65=read_allocstring(rs, &status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$fn, (unsigned int *)(void *)0);
                              if(return_value_read_allocstring$65 == 0)
                              {
                                print_serr(rs, "Bad filename name.");
                                goto __CPROVER_DUMP_L172;
                              }

                              signed int return_value_reload_config_file$66;
                              return_value_reload_config_file$66=reload_config_file(status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$fn, &status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$errmsg);
                              if(!(return_value_reload_config_file$66 == 0))
                                print_succ(rs);

                              else
                              {
                                print_serr(rs, (_Bool)status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$errmsg ? status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$errmsg : "Out of memory.");
                                free((void *)status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$errmsg);
                              }
                              free((void *)status_thread$$1$$3$$1$$1$$2$$1$$1$$7$$fn);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L123:
                              ;
                              char *status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$fn;
                              char *status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$errmsg;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received INCLUDE command.\n");

                              signed int return_value_read_allocstring$67;
                              return_value_read_allocstring$67=read_allocstring(rs, &status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$fn, (unsigned int *)(void *)0);
                              if(!(return_value_read_allocstring$67 >= 1))
                              {
                                print_serr(rs, "Bad filename name.");
                                goto __CPROVER_DUMP_L172;
                              }

                              signed int return_value_read_config_file$68;
                              return_value_read_config_file$68=read_config_file(status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$fn, (struct anonymous$21 *)(void *)0, (struct anonymous$18 **)(void *)0, 0, &status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$errmsg);
                              if(!(return_value_read_config_file$68 == 0))
                                print_succ(rs);

                              else
                              {
                                print_serr(rs, (_Bool)status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$errmsg ? status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$errmsg : "Out of memory.");
                                free((void *)status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$errmsg);
                              }
                              free((void *)status_thread$$1$$3$$1$$1$$2$$1$$1$$8$$fn);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L128:
                              ;
                              char *str;
                              char *status_thread$$1$$3$$1$$1$$2$$1$$1$$9$$errmsg;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received EVAL command.\n");

                              signed int return_value_read_allocstring$69;
                              return_value_read_allocstring$69=read_allocstring(rs, &str, (unsigned int *)(void *)0);
                              if(return_value_read_allocstring$69 == 0)
                              {
                                print_serr(rs, "Bad input string.");
                                goto __CPROVER_DUMP_L172;
                              }

                              signed int return_value_confparse$70;
                              return_value_confparse$70=confparse((struct _IO_FILE *)(void *)0, str, (struct anonymous$21 *)(void *)0, (struct anonymous$18 **)(void *)0, 0, &status_thread$$1$$3$$1$$1$$2$$1$$1$$9$$errmsg);
                              if(!(return_value_confparse$70 == 0))
                                print_succ(rs);

                              else
                              {
                                print_serr(rs, (_Bool)status_thread$$1$$3$$1$$1$$2$$1$$1$$9$$errmsg ? status_thread$$1$$3$$1$$1$$2$$1$$1$$9$$errmsg : "Out of memory.");
                                free((void *)status_thread$$1$$3$$1$$1$$2$$1$$1$$9$$errmsg);
                              }
                              free((void *)str);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L133:
                              ;
                              struct anonymous$8 *sla = (struct anonymous$8 *)(void *)0;
                              char *names;
                              unsigned int len;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received EMPTY command.\n");

                              signed int return_value_read_allocstring$71;
                              return_value_read_allocstring$71=read_allocstring(rs, &names, &len);
                              if(return_value_read_allocstring$71 == 0)
                              {
                                print_serr(rs, "Bad arguments.");
                                goto __CPROVER_DUMP_L172;
                              }

                              if(!(names == ((char *)NULL)))
                              {
                                char *p = names;
                                char *last = names + (signed long int)len;
                                while(!(p >= last))
                                {
                                  signed int status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$tp;
                                  char *status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q;
                                  struct anonymous$9 *sl;
                                  unsigned int status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$sz;
                                  unsigned char rhn[256l];
                                  if((signed int)*p == 45)
                                  {
                                    status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$tp = 19;
                                    p = p + 1l;
                                  }

                                  else
                                  {
                                    status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$tp = 18;
                                    if((signed int)*p == 43)
                                      p = p + 1l;

                                  }
                                  if(!(p + 1l >= last))
                                  {
                                    if((signed int)*p == 46)
                                    {
                                      if(!(p[1l] == 0))
                                        p = p + 1l;

                                    }

                                  }

                                  status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q = p;
                                  for( ; !(status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q >= last); status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q = status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q + 1l)
                                    if(*status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q == 0)
                                      break;

                                  errmsg=parsestr2rhn((unsigned char *)p, (unsigned int)(status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q - p), rhn);
                                  if(!(errmsg == ((const char *)NULL)))
                                  {
                                    if(!(debug_p == 0))
                                      debug_msg(0, "EMPTY: received bad domain name: %s\n", p);

                                    print_serr(rs, errmsg);
                                    goto free_sla_names_break;
                                  }

                                  status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$sz=rhnlen$link5(rhn);
                                  struct anonymous$3 *return_value_da_grow1$72;
                                  return_value_da_grow1$72=da_grow1((struct anonymous$3 *)sla, (unsigned long int)((struct anonymous$8 *)0)->elem, sizeof(struct anonymous$9) /*16ul*/ , free_slist_domain);
                                  sla = (struct anonymous$8 *)return_value_da_grow1$72;
                                  if(sla == ((struct anonymous$8 *)NULL))
                                  {
                                    print_serr(rs, "Out of memory.");
                                    goto free_names_break;
                                  }

                                  sl = &sla->elem[(signed long int)(sla->nel - (unsigned long int)1)];
                                  void *return_value_malloc$73;
                                  return_value_malloc$73=malloc((unsigned long int)status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$sz);
                                  sl->domain = (unsigned char *)return_value_malloc$73;
                                  if(sl->domain == ((unsigned char *)NULL))
                                  {
                                    print_serr(rs, "Out of memory.");
                                    goto free_sla_names_break;
                                  }

                                  memcpy((void *)sl->domain, (const void *)rhn, (unsigned long int)status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$sz);
                                  sl->exact = (signed short int)0;
                                  sl->rule = (signed short int)status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$tp;
                                  p = status_thread$$1$$3$$1$$1$$2$$1$$1$$10$$3$$1$$q + (signed long int)1;
                                }
                              }

                              signed int return_value_empty_cache$74;
                              return_value_empty_cache$74=empty_cache(sla);
                              if(!(return_value_empty_cache$74 == 0))
                                print_succ(rs);

                              else
                                print_serr(rs, "Could not lock the cache.");

                            free_sla_names_break:
                              ;
                              free_slist_array(sla);

                            free_names_break:
                              ;
                              free((void *)names);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L152:
                              ;
                              signed int rv;
                              signed int exact = 0;
                              unsigned char *status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm = (unsigned char *)(void *)0;
                              char status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$buf[256l];
                              unsigned char status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$rhn[256l];
                              if(!(debug_p == 0))
                                debug_msg(0, "Received DUMP command.\n");

                              rv=read_domain(rs, status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$buf, (unsigned int)sizeof(char [256l]) /*256ul*/ );
                              if(rv == 0)
                              {
                                print_serr(rs, "Bad domain name.");
                                goto __CPROVER_DUMP_L172;
                              }

                              if(rv >= 1)
                              {
                                signed int status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$3$$sz;
                                exact = 1;
                                status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm = (unsigned char *)status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$buf;
                                status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$3$$sz = (signed int)sizeof(char [256l]) /*256ul*/ ;
                                if((signed int)status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$buf[0l] == 46)
                                {
                                  if(!(status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$buf[1l] == 0))
                                  {
                                    exact = 0;
                                    status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm = status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm + 1l;
                                    status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$3$$sz = status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$3$$sz - 1;
                                  }

                                }

                                errmsg=parsestr2rhn(status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm, (unsigned int)status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$3$$sz, status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$rhn);
                                if(!(errmsg == ((const char *)NULL)))
                                  goto bad_domain_name;

                                status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm = status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$rhn;
                              }

                              signed int return_value_print_succ$75;
                              return_value_print_succ$75=print_succ(rs);
                              if(return_value_print_succ$75 == 0)
                                goto __CPROVER_DUMP_L172;

                              rv=dump_cache(rs, status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm, exact);
                              _Bool tmp_if_expr$81;
                              if(!(rv >= 0))
                                tmp_if_expr$81 = (_Bool)1;

                              else
                              {
                                if(rv == 0)
                                {
                                  if(!(status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm == ((unsigned char *)NULL)))
                                    tmp_if_expr$78 = status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$buf;

                                  else
                                    tmp_if_expr$78 = "";
                                  return_value_fsprintf$79=fsprintf(rs, "Could not find %s%s in the cache.\n", exact != 0 ? "" : (status_thread$$1$$3$$1$$1$$2$$1$$1$$11$$nm != ((unsigned char *)NULL) ? "any entries matching " : "any entries"), tmp_if_expr$78);
                                  tmp_if_expr$80 = return_value_fsprintf$79 < 0 ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr$80 = (_Bool)0;
                                tmp_if_expr$81 = tmp_if_expr$80 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr$81)
                              {
                                if(!(debug_p == 0))
                                {
                                  return_value___errno_location$76=__errno_location();
                                  return_value_strerror$77=strerror(*return_value___errno_location$76);
                                  debug_msg(0, "Error writing to control socket: %s\n", return_value_strerror$77);
                                }

                              }

                              goto __CPROVER_DUMP_L172;
                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }


          incomplete_command:
            ;
            print_serr(rs, "Malformed or incomplete command.");
            goto __CPROVER_DUMP_L172;

          bad_arg:
            ;
            print_serr(rs, "Bad arg.");
            goto __CPROVER_DUMP_L172;

          bad_domain_name:
            ;
            print_serr(rs, errmsg);
            goto __CPROVER_DUMP_L172;

          bad_ttl:
            ;
            print_serr(rs, "Bad TTL.");
            goto __CPROVER_DUMP_L172;

          bad_flags:
            ;
            print_serr(rs, "Bad cache flags.");
            goto __CPROVER_DUMP_L172;

          out_of_memory:
            ;
            print_serr(rs, "Out of memory.");
            goto __CPROVER_DUMP_L172;
          }
          print_serr(rs, "Unknown command.");
        }

        else
        {
          if(!(debug_p == 0))
            debug_msg(0, "Incorrect magic number in status-socket command code: %02x\n", (signed int)cmd >> 8);

          print_serr(rs, "Command code contains incompatible version number.");
        }
      }

      else
      {
        if(!(debug_p == 0))
          debug_msg(0, "short status-socket query\n");

        print_serr(rs, "Command code missing or too short.");
      }

    __CPROVER_DUMP_L172:
      ;
      close(rs);
      usleep_r$link2((unsigned long int)100000);
    }

    else
    {
      return_value___errno_location$85=__errno_location();
      if(!(*return_value___errno_location$85 == 4))
      {
        signed int *return_value___errno_location$83;
        return_value___errno_location$83=__errno_location();
        char *return_value_strerror$84;
        return_value_strerror$84=strerror(*return_value___errno_location$83);
        log_message(4, "Failed to accept connection on status socket: %s. Status readback will be impossible", return_value_strerror$84);
        break;
      }

    }
  }
  while((_Bool)1);

exit_thread:
  ;
  stat_pipe = (signed short int)0;
  close(stat_sock);
  statsock_thrid = main_thrid;
  return (void *)0;
}

// statusif
// file netdev.c line 110
signed int statusif(char *name)
{
  struct anonymous$53 phone;
  signed int isdninfo;
  signed int rc = 0;
  isdninfo=open("/dev/isdninfo", 00);
  if(!(isdninfo >= 0))
  {
    isdn_errs = isdn_errs + 1ul;
    if(!(isdn_errs >= 3ul))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_message(4, "Could not open /dev/isdninfo for uptest: %s", return_value_strerror$2);
    }

    return 0;
  }

  else
  {
    strncp$link2(phone.name, name, sizeof(char [10l]) /*10ul*/ );
    signed int return_value_ioctl$3;
    return_value_ioctl$3=ioctl(isdninfo, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(73 << 0 + 8) | (unsigned int)(34 << 0) | (unsigned int)(0 << 0 + 8 + 8)), &phone);
    if(return_value_ioctl$3 == 0)
      rc = 1;

    close(isdninfo);
    return rc;
  }
}

// str2pdnsd_a
// file helpers.h line 156
signed int str2pdnsd_a(const char *addr, union anonymous$6 *a)
{
  if(!(run_ipv4 == 0))
  {
    signed int return_value_inet_aton$1;
    return_value_inet_aton$1=inet_aton(addr, &a->ipv4);
    return return_value_inet_aton$1;
  }

  else
  {
    struct in_addr a4;
    signed int return_value_inet_aton$2;
    return_value_inet_aton$2=inet_aton(addr, &a4);
    if(!(return_value_inet_aton$2 == 0))
    {
      a->ipv6 = global.ipv4_6_prefix;
      ((unsigned int *)&a->ipv6)[(signed long int)3] = a4.s_addr;
      return 1;
    }

    signed int return_value_inet_pton$3;
    return_value_inet_pton$3=inet_pton(10, addr, (void *)&a->ipv6);
    return (signed int)(return_value_inet_pton$3 > 0);
  }
}

// str2rhn
// file helpers.h line 53
signed int str2rhn(const unsigned char *str, unsigned char *rhn)
{
  unsigned int i;
  unsigned int j;
  _Bool tmp_if_expr$1;
  if((signed int)*str == 46)
  {
    if(!(str[1l] == 0))
      goto __CPROVER_DUMP_L1;

    rhn[(signed long int)0] = (unsigned char)0;
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    i = (unsigned int)0;
    do
    {
      unsigned int jlim = i + (unsigned int)63;
      if(jlim >= 255u)
        jlim = (unsigned int)(256 - 2);

      j = i;
      do
      {
        if(!(str[(signed long int)j] == 0))
          tmp_if_expr$1 = (signed int)str[(signed long int)j] != 46 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        if(j >= jlim)
          return 0;

        rhn[(signed long int)(j + (unsigned int)1)] = str[(signed long int)j];
        j = j + 1u;
      }
      while((_Bool)1);
      if(str[(signed long int)j] == 0)
        break;

      if(i >= j)
        return 0;

      rhn[(signed long int)i] = (unsigned char)(j - i);
      i = j + (unsigned int)1;
    }
    while((_Bool)1);
    rhn[(signed long int)i] = (unsigned char)0;
    if(i == 0u || !(i >= j))
      return 0;

    else
      return 1;
  }
}

// strncp
// file helpers.h line 234
static inline signed int strncp(char *dst, const char *src, unsigned long int dstsz)
{
  char *p;
  p=stpncpy(dst, src, dstsz);
  if(!(p >= dst + (signed long int)dstsz))
    return 1;

  else
  {
    *(p - (signed long int)1) = (char)0;
    return 0;
  }
}

// strncp$link1
// file helpers.h line 234
static inline signed int strncp$link1(char *dst$link1, const char *src$link1, unsigned long int dstsz$link1)
{
  char *p$link1;
  p$link1=stpncpy(dst$link1, src$link1, dstsz$link1);
  if(!(p$link1 >= dst$link1 + (signed long int)dstsz$link1))
    return 1;

  else
  {
    *(p$link1 - (signed long int)1) = (char)0;
    return 0;
  }
}

// strncp$link2
// file helpers.h line 234
static inline signed int strncp$link2(char *dst$link2, const char *src$link2, unsigned long int dstsz$link2)
{
  char *p$link2;
  p$link2=stpncpy(dst$link2, src$link2, dstsz$link2);
  if(!(p$link2 >= dst$link2 + (signed long int)dstsz$link2))
    return 1;

  else
  {
    *(p$link2 - (signed long int)1) = (char)0;
    return 0;
  }
}

// strtotime
// file conf-parser.c line 249
static signed long int strtotime(char *nptr, char **endptr, char **errstr)
{
  signed long int retval = (signed long int)0;
  signed long int t;
  char c;
  *errstr = (char *)(void *)0;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    c = *nptr;
    if((8 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)c]) == 0)
      break;

    const unsigned short int **return_value___ctype_b_loc$2;
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)c]) == 0)
    {
      *errstr = "no digits before suffix.";
      break;
    }

    t=strtol(nptr, &nptr, 10);
    const unsigned short int **return_value___ctype_b_loc$3;
    return_value___ctype_b_loc$3=__ctype_b_loc();
    c = *nptr;
    if(!((1024 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)c]) == 0))
    {
      if(!((signed int)c == 115))
      {
        if((signed int)c == 109)
          t = t * (signed long int)60;

        else
          if((signed int)c == 104)
            t = t * (signed long int)(60 * 60);

          else
            if((signed int)c == 100)
              t = t * (signed long int)(24 * 60 * 60);

            else
              if((signed int)c == 119)
                t = t * (signed long int)(7 * 24 * 60 * 60);

              else
              {
                *errstr = "allowed suffixes are w,d,h,m,s.";
                break;
              }
      }

      nptr = nptr + 1l;
    }

    retval = retval + t;
  }
  while((_Bool)1);
  if(!(endptr == ((char **)NULL)))
    *endptr = nptr;

  return retval;
}

// sva_add
// file dns_answer.c line 149
static signed int sva_add(struct _dynamic_list_head **sva, const unsigned char *rhn, unsigned short int tp, unsigned short int dlen, void *data)
{
  if(!(sva == ((struct _dynamic_list_head **)NULL)))
  {
    unsigned long int rlen;
    unsigned int return_value_rhnlen$1;
    return_value_rhnlen$1=rhnlen$link2(rhn);
    rlen = (unsigned long int)return_value_rhnlen$1;
    struct anonymous$71 *st;
    *sva=dlist_grow(*sva, sizeof(struct anonymous$71) /*4ul*/  + rlen + (unsigned long int)dlen);
    if(*sva == ((struct _dynamic_list_head *)NULL))
      return 0;

    void *return_value_dlist_last$2;
    return_value_dlist_last$2=dlist_last$link1(*sva);
    st = (struct anonymous$71 *)return_value_dlist_last$2;
    st->tp = tp;
    st->dlen = dlen;
    void *return_value_mempcpy$3;
    return_value_mempcpy$3=mempcpy((void *)st->nm, (const void *)rhn, rlen);
    memcpy(return_value_mempcpy$3, data, (unsigned long int)dlen);
  }

  return 1;
}

// switch_to_tcp
// file dns_query.c line 814
static inline void switch_to_tcp(struct anonymous$5 *st)
{
  st->qm = (signed short int)13;
  st->state = (signed short int)0;
  st->failed = (char)0;
}

// switch_to_udp
// file dns_query.c line 803
static inline void switch_to_udp(struct anonymous$5 *st)
{
  st->qm = (signed short int)12;
  st->myrid=get_rand16();
  st->msg->hdr.id=htons(st->myrid);
  st->state = (signed short int)4;
}

// tcp_answer_thread
// file dns_answer.c line 1811
static void * tcp_answer_thread(void *csock)
{
  signed int sock = *((signed int *)csock);
  unsigned int thrid;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  do
  {
    struct anonymous$66 __cancel_buf;
    void (*__cancel_routine)(void *) = tcp_answer_thread_cleanup;
    void *__cancel_arg = csock;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      if(global.strict_suid == 0)
      {
        signed int return_value_run_as$1;
        return_value_run_as$1=run_as(global.run_as);
        if(return_value_run_as$1 == 0)
          pdnsd_exit();

      }

      do
      {
        pthread_mutex_lock(&proc_lock);
        if(!(procs >= global.proc_limit))
          break;

        pthread_mutex_unlock(&proc_lock);
        usleep_r((unsigned long int)50000);
      }
      while((_Bool)1);
      procs = procs + 1;
      thrid_cnt = thrid_cnt + 1u;
      thrid = thrid_cnt;
      pthread_mutex_unlock(&proc_lock);
      if(!(debug_p == 0))
      {
        signed int tcp_answer_thread$$1$$1$$2$$3$$err;
        tcp_answer_thread$$1$$1$$2$$3$$err=pthread_setspecific(thrid_key, (const void *)&thrid);
        if(!(tcp_answer_thread$$1$$1$$2$$3$$err == 0))
        {
          da_misc_errs = da_misc_errs + 1ul;
          if(!(da_misc_errs >= 11ul))
          {
            return_value_strerror$2=strerror(tcp_answer_thread$$1$$1$$2$$3$$err);
            log_message(3, "pthread_setspecific failed: %s", return_value_strerror$2);
          }

        }

      }

      signed int rlen;
      signed int olen;
      unsigned long int nlen;
      unsigned char *buf;
      struct anonymous$28 *resp;
      struct pollfd pfd;
      pfd.fd = sock;
      pfd.events = (signed short int)0x001;
      signed int return_value_poll$3;
      return_value_poll$3=poll(&pfd, (unsigned long int)1, (signed int)(global.tcp_qtimeout * (signed long int)1000));
      if(!(return_value_poll$3 >= 1))
        pthread_exit((void *)0);

      signed long int err;
      unsigned short int rlen_net;
      err=read(sock, (void *)&rlen_net, sizeof(unsigned short int) /*2ul*/ );
      if(!((unsigned long int)err == sizeof(unsigned short int) /*2ul*/ ))
      {
        if(!(debug_p == 0))
        {
          char *tmp_if_expr$6;
          if(err == -1l)
          {
            return_value___errno_location$4=__errno_location();
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            tmp_if_expr$6 = return_value_strerror$5;
          }

          else
            tmp_if_expr$6 = "incomplete data";
          debug_msg(0, "Error while reading from TCP client: %s\n", tmp_if_expr$6);
        }

        pthread_exit((void *)0);
      }

      unsigned short int return_value_ntohs$7;
      return_value_ntohs$7=ntohs(rlen_net);
      rlen = (signed int)return_value_ntohs$7;
      if(rlen == 0)
      {
        log_message(3, "TCP zero size query received.\n");
        pthread_exit((void *)0);
      }

      void *return_value_malloc$8;
      return_value_malloc$8=malloc((unsigned long int)rlen);
      buf = (unsigned char *)return_value_malloc$8;
      if(buf == ((unsigned char *)NULL))
      {
        da_mem_errs = da_mem_errs + 1ul;
        if(!(da_mem_errs >= 11ul))
          log_message(3, "Out of memory in request handling.");

        pthread_exit((void *)0);
      }

      do
      {
        struct anonymous$66 tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_buf;
        void (*tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_routine)(void *) = free;
        void *tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_arg = (void *)buf;
        signed int tcp_answer_thread$$1$$1$$2$$4$$4$$__not_first_call;
        tcp_answer_thread$$1$$1$$2$$4$$4$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)tcp_answer_thread$$1$$1$$2$$4$$4$$__not_first_call == 0l))
        {
          tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_routine(tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_arg);
          __pthread_unwind_next(&tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_buf);
        }

        __pthread_register_cancel(&tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_buf);
        do
        {
          olen = 0;
          while(!(olen >= rlen))
          {
            signed int rv;
            pfd.fd = sock;
            pfd.events = (signed short int)0x001;
            signed int return_value_poll$9;
            return_value_poll$9=poll(&pfd, (unsigned long int)1, (signed int)(global.tcp_qtimeout * (signed long int)1000));
            if(!(return_value_poll$9 >= 1))
              pthread_exit((void *)0);

            signed long int return_value_read$10;
            return_value_read$10=read(sock, (void *)(buf + (signed long int)olen), (unsigned long int)(rlen - olen));
            rv = (signed int)return_value_read$10;
            if(!(rv >= 1))
            {
              if(!(debug_p == 0))
              {
                char *tmp_if_expr$13;
                if(rv == -1)
                {
                  return_value___errno_location$11=__errno_location();
                  return_value_strerror$12=strerror(*return_value___errno_location$11);
                  tmp_if_expr$13 = return_value_strerror$12;
                }

                else
                  tmp_if_expr$13 = "incomplete data";
                debug_msg(0, "Error while reading from TCP client: %s\n", tmp_if_expr$13);
              }

              if(olen >= 2)
              {
                struct anonymous$28 tcp_answer_thread$$1$$1$$2$$4$$4$$2$$1$$1$$2$$err;
                signed int tmp_if_expr$14;
                if(olen >= 3)
                  tmp_if_expr$14 = (signed int)((struct anonymous$29 *)buf)->opcode;

                else
                  tmp_if_expr$14 = 0;
                mk_error_reply(((struct anonymous$29 *)buf)->id, (unsigned short int)tmp_if_expr$14, (unsigned short int)1, &tcp_answer_thread$$1$$1$$2$$4$$4$$2$$1$$1$$2$$err.hdr);
                tcp_answer_thread$$1$$1$$2$$4$$4$$2$$1$$1$$2$$err.len=htons((unsigned short int)sizeof(struct anonymous$29) /*12ul*/ );
                write_all(sock, (const void *)&tcp_answer_thread$$1$$1$$2$$4$$4$$2$$1$$1$$2$$err, sizeof(struct anonymous$28) /*14ul*/ );
              }

              pthread_exit((void *)0);
            }

            olen = olen + rv;
          }
          nlen = (unsigned long int)rlen;
          resp=process_query(buf, &nlen, (unsigned int *)(void *)0, (signed int *)(void *)0);
          if(resp == ((struct anonymous$28 *)NULL))
            pthread_exit((void *)0);


        __CPROVER_DUMP_L30:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_buf);
        tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_routine(tcp_answer_thread$$1$$1$$2$$4$$4$$__cancel_arg);
      }
      while((_Bool)0);
      do
      {
        struct anonymous$66 tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_buf;
        void (*tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_routine)(void *) = free;
        void *tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_arg = (void *)resp;
        signed int tcp_answer_thread$$1$$1$$2$$4$$5$$__not_first_call;
        tcp_answer_thread$$1$$1$$2$$4$$5$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)tcp_answer_thread$$1$$1$$2$$4$$5$$__not_first_call == 0l))
        {
          tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_routine(tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_arg);
          __pthread_unwind_next(&tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_buf);
        }

        __pthread_register_cancel(&tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_buf);
        do
        {
          signed int tcp_answer_thread$$1$$1$$2$$4$$5$$2$$1$$err;
          unsigned long int rsize;
          resp->len=htons((unsigned short int)nlen);
          rsize = (unsigned long int)2 + nlen;
          signed long int return_value_write_all$18;
          return_value_write_all$18=write_all(sock, (const void *)resp, rsize);
          tcp_answer_thread$$1$$1$$2$$4$$5$$2$$1$$err = (signed int)return_value_write_all$18;
          if(!((unsigned long int)tcp_answer_thread$$1$$1$$2$$4$$5$$2$$1$$err == rsize))
          {
            if(!(debug_p == 0))
            {
              char *tmp_if_expr$17;
              if(tcp_answer_thread$$1$$1$$2$$4$$5$$2$$1$$err == -1)
              {
                return_value___errno_location$15=__errno_location();
                return_value_strerror$16=strerror(*return_value___errno_location$15);
                tmp_if_expr$17 = return_value_strerror$16;
              }

              else
                tmp_if_expr$17 = "unknown error";
              debug_msg(0, "Error while writing to TCP client: %s\n", tmp_if_expr$17);
            }

            pthread_exit((void *)0);
          }


        __CPROVER_DUMP_L39:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_buf);
        tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_routine(tcp_answer_thread$$1$$1$$2$$4$$5$$__cancel_arg);
      }
      while((_Bool)0);

    __CPROVER_DUMP_L41:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// tcp_answer_thread_cleanup
// file dns_answer.c line 1801
static void tcp_answer_thread_cleanup(void *csock)
{
  close(*((signed int *)csock));
  free(csock);
  decrease_procs();
}

// tcp_server_thread
// file dns_answer.c line 2033
void * tcp_server_thread(void *p)
{
  signed int sock;
  unsigned long int pt;
  signed int *csock;
  if(global.strict_suid == 0)
  {
    signed int return_value_run_as$1;
    return_value_run_as$1=run_as(global.run_as);
    if(return_value_run_as$1 == 0)
      pdnsd_exit();

  }

  sock = tcp_socket;
  signed int return_value_listen$4;
  return_value_listen$4=listen(sock, 5);
  char *return_value_strerror$9;
  if(!(return_value_listen$4 == 0))
  {
    da_tcp_errs = da_tcp_errs + 1ul;
    if(!(da_tcp_errs >= 11ul))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      log_message(3, "Could not listen on tcp socket: %s", return_value_strerror$3);
    }

  }

  else
    while((_Bool)1)
    {
      void *return_value_malloc$5;
      return_value_malloc$5=malloc(sizeof(signed int) /*4ul*/ );
      csock = (signed int *)return_value_malloc$5;
      if(csock == ((signed int *)NULL))
      {
        da_mem_errs = da_mem_errs + 1ul;
        if(!(da_mem_errs >= 11ul))
          log_message(3, "Out of memory in request handling.");

        break;
      }

      *csock=accept(sock, (void *)0, ((unsigned int *)NULL));
      if(*csock == -1)
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(!(*return_value___errno_location$8 == 4))
        {
          da_tcp_errs = da_tcp_errs + 1ul;
          if(!(da_tcp_errs >= 11ul))
          {
            signed int *return_value___errno_location$6;
            return_value___errno_location$6=__errno_location();
            char *return_value_strerror$7;
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            log_message(3, "tcp accept failed: %s", return_value_strerror$7);
          }

        }

      }

      else
      {
        pthread_mutex_lock(&proc_lock);
        if(!(qprocs >= global.proc_limit + global.procq_limit))
        {
          signed int err;
          qprocs = qprocs + 1;
          spawned = spawned + 1ul;
          pthread_mutex_unlock(&proc_lock);
          err=pthread_create(&pt, &attr_detached, tcp_answer_thread, (void *)csock);
          if(err == 0)
            continue;

          da_thrd_errs = da_thrd_errs + 1ul;
          if(!(da_thrd_errs >= 11ul))
          {
            return_value_strerror$9=strerror(err);
            log_message(4, "pthread_create failed: %s", return_value_strerror$9);
          }

          pthread_mutex_lock(&proc_lock);
          qprocs = qprocs - 1;
          spawned = spawned - 1ul;
        }

        dropped = dropped + 1ul;
        pthread_mutex_unlock(&proc_lock);
        close(*csock);
      }
      free((void *)csock);
      usleep_r((unsigned long int)50000);
    }

close_sock_return:
  ;
  tcp_socket = -1;
  close(sock);
  tcps_thrid = main_thrid;
  if(udp_socket == -1)
    pdnsd_exit();

  return (void *)0;
}

// test_onquery
// file servers.h line 40
void test_onquery(void)
{
  signed int i;
  signed int n;
  signed int signal_test;
  pthread_mutex_lock(&servers_lock);
  schm[(signed long int)0] = (char)0;
  signal_test = 0;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link5((struct anonymous$3 *)servers);
  n = (signed int)return_value_da_nel$1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous$7 *sp = &servers->elem[(signed long int)i];
    if(sp->interval == -1l)
    {
      if(!((signed int)sp->rootserver >= 2))
        retest(i, -1);

      else
      {
        signed int j;
        signed int m;
        unsigned int return_value_da_nel$2;
        return_value_da_nel$2=da_nel$link5((struct anonymous$3 *)sp->atup_a);
        m = (signed int)return_value_da_nel$2;
        j = 0;
        for( ; !(j >= m); j = j + 1)
          sp->atup_a->elem[(signed long int)j].i_ts = (signed long int)0;
        signal_test = 1;
      }
    }

  }
  char *return_value_strerror$3;
  if(!(signal_test == 0))
  {
    signed int rv;
    signed int return_value_pthread_equal$4;
    return_value_pthread_equal$4=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal$4 == 0))
      start_servstat_thread();

    else
    {
      retest_flag = (signed short int)1;
      rv=pthread_cond_signal(&server_test_cond);
      if(!(rv == 0))
      {
        if(!(debug_p == 0))
        {
          return_value_strerror$3=strerror(rv);
          debug_msg(0, "test_onquery(): couldn't signal server status thread: %s\n", return_value_strerror$3);
        }

      }

    }
  }

  pthread_mutex_unlock(&servers_lock);
}

// timedlock_cache_rw
// file cache.c line 285
static signed int timedlock_cache_rw(signed int tm)
{
  signed int retval = 0;
  struct timeval now;
  struct timespec timeout;
  if(use_cache_lock == 0)
    return 0;

  else
  {
    pthread_mutex_lock(&lock_mutex);
    gettimeofday(&now, (struct timezone *)(void *)0);
    timeout.tv_sec = now.tv_sec + (signed long int)tm;
    timeout.tv_nsec = now.tv_usec * (signed long int)1000;
    rw_pend = rw_pend + 1;
    while(!(cache_r_lock == 0) || !(cache_w_lock == 0))
    {
      signed int return_value_pthread_cond_timedwait$1;
      return_value_pthread_cond_timedwait$1=pthread_cond_timedwait(&rw_cond, &lock_mutex, &timeout);
      if(return_value_pthread_cond_timedwait$1 == 110)
        goto cleanup_return;

    }
    cache_w_lock = 1;
    retval = 1;

  cleanup_return:
    ;
    rw_pend = rw_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
    return retval;
  }
}

// translescapedchar
// file conf-parser.c line 149
static char translescapedchar(char c)
{
  switch((signed int)c)
  {
    case 102:
      return (char)12;
    case 110:
      return (char)10;
    case 114:
      return (char)13;
    case 116:
      return (char)9;
    case 118:
      return (char)11;
    default:
      return c;
  }
}

// udp_answer_thread
// file dns_answer.c line 1368
static void * udp_answer_thread(void *data)
{
  struct msghdr msg;
  struct iovec v;
  struct cmsghdr *cmsg;
  char ctrl[40l];
  unsigned long int rlen = ((struct anonymous$69 *)data)->len;
  unsigned int udpmaxrespsize = (unsigned int)512;
  struct anonymous$28 *resp;
  signed int rcode;
  unsigned int thrid;
  char *return_value_strerror$2;
  const char *return_value_get_ename$3;
  const char *return_value_inet_ntop$5;
  const char *return_value_inet_ntop$6;
  const char *return_value_inet_ntop$8;
  const char *return_value_inet_ntop$9;
  do
  {
    struct anonymous$66 __cancel_buf;
    void (*__cancel_routine)(void *) = udp_answer_thread_cleanup;
    void *__cancel_arg = data;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      if(global.strict_suid == 0)
      {
        signed int return_value_run_as$1;
        return_value_run_as$1=run_as(global.run_as);
        if(return_value_run_as$1 == 0)
          pdnsd_exit();

      }

      do
      {
        pthread_mutex_lock(&proc_lock);
        if(!(procs >= global.proc_limit))
          break;

        pthread_mutex_unlock(&proc_lock);
        usleep_r((unsigned long int)50000);
      }
      while((_Bool)1);
      procs = procs + 1;
      thrid_cnt = thrid_cnt + 1u;
      thrid = thrid_cnt;
      pthread_mutex_unlock(&proc_lock);
      if(!(debug_p == 0))
      {
        signed int err;
        err=pthread_setspecific(thrid_key, (const void *)&thrid);
        if(!(err == 0))
        {
          da_misc_errs = da_misc_errs + 1ul;
          if(!(da_misc_errs >= 11ul))
          {
            return_value_strerror$2=strerror(err);
            log_message(3, "pthread_setspecific failed: %s", return_value_strerror$2);
          }

        }

      }

      resp=process_query(((struct anonymous$69 *)data)->buf, &rlen, &udpmaxrespsize, &rcode);
      if(resp == ((struct anonymous$28 *)NULL))
        pthread_exit((void *)0);

      do
      {
        struct anonymous$66 udp_answer_thread$$1$$1$$2$$5$$__cancel_buf;
        void (*udp_answer_thread$$1$$1$$2$$5$$__cancel_routine)(void *) = free;
        void *udp_answer_thread$$1$$1$$2$$5$$__cancel_arg = (void *)resp;
        signed int udp_answer_thread$$1$$1$$2$$5$$__not_first_call;
        udp_answer_thread$$1$$1$$2$$5$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)udp_answer_thread$$1$$1$$2$$5$$__cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)udp_answer_thread$$1$$1$$2$$5$$__not_first_call == 0l))
        {
          udp_answer_thread$$1$$1$$2$$5$$__cancel_routine(udp_answer_thread$$1$$1$$2$$5$$__cancel_arg);
          __pthread_unwind_next(&udp_answer_thread$$1$$1$$2$$5$$__cancel_buf);
        }

        __pthread_register_cancel(&udp_answer_thread$$1$$1$$2$$5$$__cancel_buf);
        do
        {
          if(!((unsigned long int)udpmaxrespsize >= rlen))
          {
            rlen = (unsigned long int)udpmaxrespsize;
            resp->hdr.tc = (unsigned int)1;
          }

          if(!(debug_p == 0))
          {
            return_value_get_ename$3=get_ename(rcode);
            debug_msg(0, "Outbound msg len %li, tc=%u, rc=\"%s\"\n", (signed long int)rlen, resp->hdr.tc, return_value_get_ename$3);
          }

          v.iov_base = (void *)(char *)&resp->hdr;
          v.iov_len = rlen;
          msg.msg_iov = &v;
          msg.msg_iovlen = (unsigned long int)1;
          msg.msg_control = (void *)ctrl;
          msg.msg_controllen = sizeof(char [40l]) /*40ul*/ ;
          msg.msg_flags = 0;
          if(!(run_ipv4 == 0))
          {
            msg.msg_name = (void *)&((struct anonymous$69 *)data)->addr.sin4;
            msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
            ((struct anonymous$69 *)data)->pi.pi4.ipi_spec_dst = ((struct anonymous$69 *)data)->pi.pi4.ipi_addr;
            struct cmsghdr *tmp_if_expr$4;
            if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
              tmp_if_expr$4 = (struct cmsghdr *)(&msg)->msg_control;

            else
              tmp_if_expr$4 = (struct cmsghdr *)0;
            cmsg = tmp_if_expr$4;
            cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(struct in_pktinfo) /*12ul*/ ;
            cmsg->cmsg_level = 0;
            cmsg->cmsg_type = 8;
            memcpy((void *)cmsg->__cmsg_data, (const void *)&((struct anonymous$69 *)data)->pi.pi4, sizeof(struct in_pktinfo) /*12ul*/ );
            msg.msg_controllen = ((sizeof(struct in_pktinfo) /*12ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
            char buf[46l];
            if(!(debug_p == 0))
            {
              return_value_inet_ntop$5=inet_ntop(2, (const void *)&((struct anonymous$69 *)data)->addr.sin4.sin_addr, buf, (unsigned int)46);
              debug_msg(0, "Answering to: %s", return_value_inet_ntop$5);
            }

            if(!(debug_p == 0))
            {
              return_value_inet_ntop$6=inet_ntop(2, (const void *)&((struct anonymous$69 *)data)->pi.pi4.ipi_spec_dst, buf, (unsigned int)46);
              debug_msg(1, ", source address: %s\n", return_value_inet_ntop$6);
            }

          }

          else
          {
            msg.msg_name = (void *)&((struct anonymous$69 *)data)->addr.sin6;
            msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
            struct cmsghdr *tmp_if_expr$7;
            if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
              tmp_if_expr$7 = (struct cmsghdr *)(&msg)->msg_control;

            else
              tmp_if_expr$7 = (struct cmsghdr *)0;
            cmsg = tmp_if_expr$7;
            cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(struct in6_pktinfo) /*20ul*/ ;
            cmsg->cmsg_level = 41;
            cmsg->cmsg_type = 50;
            memcpy((void *)cmsg->__cmsg_data, (const void *)&((struct anonymous$69 *)data)->pi.pi6, sizeof(struct in6_pktinfo) /*20ul*/ );
            msg.msg_controllen = ((sizeof(struct in6_pktinfo) /*20ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
            char udp_answer_thread$$1$$1$$2$$5$$2$$4$$1$$buf[46l];
            if(!(debug_p == 0))
            {
              return_value_inet_ntop$8=inet_ntop(10, (const void *)&((struct anonymous$69 *)data)->addr.sin6.sin6_addr, udp_answer_thread$$1$$1$$2$$5$$2$$4$$1$$buf, (unsigned int)46);
              debug_msg(0, "Answering to: %s", return_value_inet_ntop$8);
            }

            if(!(debug_p == 0))
            {
              return_value_inet_ntop$9=inet_ntop(10, (const void *)&((struct anonymous$69 *)data)->pi.pi6.ipi6_addr, udp_answer_thread$$1$$1$$2$$5$$2$$4$$1$$buf, (unsigned int)46);
              debug_msg(1, ", source address: %s\n", return_value_inet_ntop$9);
            }

          }
          signed long int return_value_sendmsg$12;
          return_value_sendmsg$12=sendmsg(((struct anonymous$69 *)data)->sock, &msg, 0);
          if(!(return_value_sendmsg$12 >= 0l))
          {
            da_udp_errs = da_udp_errs + 1ul;
            if(!(da_udp_errs >= 11ul))
            {
              signed int *return_value___errno_location$10;
              return_value___errno_location$10=__errno_location();
              char *return_value_strerror$11;
              return_value_strerror$11=strerror(*return_value___errno_location$10);
              log_message(3, "Error in udp send: %s", return_value_strerror$11);
            }

          }

          else
          {
            signed int tmp;
            unsigned int sl = (unsigned int)sizeof(signed int) /*4ul*/ ;
            getsockopt(((struct anonymous$69 *)data)->sock, 1, 4, (void *)&tmp, &sl);
          }

        __CPROVER_DUMP_L28:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&udp_answer_thread$$1$$1$$2$$5$$__cancel_buf);
        udp_answer_thread$$1$$1$$2$$5$$__cancel_routine(udp_answer_thread$$1$$1$$2$$5$$__cancel_arg);
      }
      while((_Bool)0);

    __CPROVER_DUMP_L30:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// udp_answer_thread_cleanup
// file dns_answer.c line 1356
static void udp_answer_thread_cleanup(void *data)
{
  free(data);
  decrease_procs();
}

// udp_server_thread
// file dns_answer.c line 1623
void * udp_server_thread(void *dummy)
{
  signed int sock;
  signed long int qlen;
  unsigned long int pt;
  struct anonymous$69 *buf;
  struct msghdr msg;
  struct iovec v;
  struct cmsghdr *cmsg;
  char ctrl[512l];
  struct in_pktinfo sip;
  if(global.strict_suid == 0)
  {
    signed int return_value_run_as$1;
    return_value_run_as$1=run_as(global.run_as);
    if(return_value_run_as$1 == 0)
      pdnsd_exit();

  }

  sock = udp_socket;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  while((_Bool)1)
  {
    signed int udpbufsize = global.udpbufsize;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct anonymous$69) /*64ul*/  + (unsigned long int)udpbufsize);
    buf = (struct anonymous$69 *)return_value_calloc$2;
    if(buf == ((struct anonymous$69 *)NULL))
    {
      da_mem_errs = da_mem_errs + 1ul;
      if(!(da_mem_errs >= 11ul))
        log_message(3, "Out of memory in request handling.");

      break;
    }

    buf->sock = sock;
    v.iov_base = (void *)(char *)buf->buf;
    v.iov_len = (unsigned long int)udpbufsize;
    msg.msg_iov = &v;
    msg.msg_iovlen = (unsigned long int)1;
    msg.msg_control = (void *)ctrl;
    msg.msg_controllen = sizeof(char [512l]) /*512ul*/ ;
    if(!(run_ipv4 == 0))
    {
      msg.msg_name = (void *)&buf->addr.sin4;
      msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      qlen=recvmsg(sock, &msg, 0);
      if(qlen >= 0l)
      {
        struct cmsghdr *tmp_if_expr$3;
        if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
          tmp_if_expr$3 = (struct cmsghdr *)(&msg)->msg_control;

        else
          tmp_if_expr$3 = (struct cmsghdr *)0;
        cmsg = tmp_if_expr$3;
        while(!(cmsg == ((struct cmsghdr *)NULL)))
        {
          if(cmsg->cmsg_level == 0)
          {
            if(cmsg->cmsg_type == 8)
            {
              memcpy((void *)&buf->pi.pi4, (const void *)cmsg->__cmsg_data, sizeof(struct in_pktinfo) /*12ul*/ );
              break;
            }

          }

          cmsg=__cmsg_nxthdr(&msg, cmsg);
        }
        if(cmsg == ((struct cmsghdr *)NULL))
        {
          da_udp_errs = da_udp_errs + 1ul;
          if(!(da_udp_errs >= 11ul))
            log_message(3, "Could not discover udp destination address");

          goto free_buf_continue;
        }

      }

      else
      {
        return_value___errno_location$6=__errno_location();
        if(!(*return_value___errno_location$6 == 4))
        {
          da_udp_errs = da_udp_errs + 1ul;
          if(!(da_udp_errs >= 11ul))
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            char *return_value_strerror$5;
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            log_message(3, "error in UDP recv: %s", return_value_strerror$5);
          }

        }

      }
    }

    else
    {
      msg.msg_name = (void *)&buf->addr.sin6;
      msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
      qlen=recvmsg(sock, &msg, 0);
      if(qlen >= 0l)
      {
        struct cmsghdr *tmp_if_expr$7;
        if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
          tmp_if_expr$7 = (struct cmsghdr *)(&msg)->msg_control;

        else
          tmp_if_expr$7 = (struct cmsghdr *)0;
        cmsg = tmp_if_expr$7;
        while(!(cmsg == ((struct cmsghdr *)NULL)))
        {
          if(cmsg->cmsg_level == 41)
          {
            if(cmsg->cmsg_type == 50)
            {
              memcpy((void *)&buf->pi.pi6, (const void *)cmsg->__cmsg_data, sizeof(struct in6_pktinfo) /*20ul*/ );
              break;
            }

          }

          cmsg=__cmsg_nxthdr(&msg, cmsg);
        }
        if(cmsg == ((struct cmsghdr *)NULL))
        {
          struct cmsghdr *tmp_if_expr$8;
          if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
            tmp_if_expr$8 = (struct cmsghdr *)(&msg)->msg_control;

          else
            tmp_if_expr$8 = (struct cmsghdr *)0;
          cmsg = tmp_if_expr$8;
          while(!(cmsg == ((struct cmsghdr *)NULL)))
          {
            if(cmsg->cmsg_level == 0)
            {
              if(cmsg->cmsg_type == 8)
              {
                memcpy((void *)&sip, (const void *)cmsg->__cmsg_data, sizeof(struct in_pktinfo) /*12ul*/ );
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)3] = (&sip.ipi_addr)->s_addr;
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)2]=htonl((unsigned int)0xffff);
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)0] = (unsigned int)0;
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)1] = ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)0];
                buf->pi.pi6.ipi6_ifindex = (unsigned int)sip.ipi_ifindex;
                break;
              }

            }

            cmsg=__cmsg_nxthdr(&msg, cmsg);
          }
          if(cmsg == ((struct cmsghdr *)NULL))
          {
            da_udp_errs = da_udp_errs + 1ul;
            if(!(da_udp_errs >= 11ul))
              log_message(3, "Could not discover udp destination address");

            goto free_buf_continue;
          }

        }

      }

      else
      {
        return_value___errno_location$11=__errno_location();
        if(!(*return_value___errno_location$11 == 4))
        {
          da_udp_errs = da_udp_errs + 1ul;
          if(!(da_udp_errs >= 11ul))
          {
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            char *return_value_strerror$10;
            return_value_strerror$10=strerror(*return_value___errno_location$9);
            log_message(3, "error in UDP recv: %s", return_value_strerror$10);
          }

        }

      }
    }
    if(qlen >= 0l)
    {
      pthread_mutex_lock(&proc_lock);
      if(!(qprocs >= global.proc_limit + global.procq_limit))
      {
        signed int err;
        qprocs = qprocs + 1;
        spawned = spawned + 1ul;
        pthread_mutex_unlock(&proc_lock);
        buf->len = (unsigned long int)qlen;
        err=pthread_create(&pt, &attr_detached, udp_answer_thread, (void *)buf);
        if(err == 0)
          continue;

        da_thrd_errs = da_thrd_errs + 1ul;
        if(!(da_thrd_errs >= 11ul))
        {
          return_value_strerror$12=strerror(err);
          log_message(4, "pthread_create failed: %s", return_value_strerror$12);
        }

        pthread_mutex_lock(&proc_lock);
        qprocs = qprocs - 1;
        spawned = spawned - 1ul;
      }

      dropped = dropped + 1ul;
      pthread_mutex_unlock(&proc_lock);
    }


  free_buf_continue:
    ;
    free((void *)buf);
    usleep_r((unsigned long int)50000);
  }
  udp_socket = -1;
  close(sock);
  udps_thrid = main_thrid;
  if(tcp_socket == -1)
    pdnsd_exit();

  return (void *)0;
}

// unlock_cache_r
// file cache.c line 250
static void unlock_cache_r(void)
{
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    if(cache_r_lock >= 1)
      cache_r_lock = cache_r_lock - 1;

    if(cache_r_lock == 0)
      pthread_cond_signal(&rw_cond);

    pthread_mutex_unlock(&lock_mutex);
  }

}

// unlock_cache_rw
// file cache.c line 311
static void unlock_cache_rw(void)
{
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    cache_w_lock = 0;
    r_susp = 0;
    if(r_pend == 0 || !(r_pend / 2 + 2 >= rw_pend))
      pthread_cond_signal(&rw_cond);

    else
      pthread_cond_broadcast(&r_cond);
    pthread_mutex_unlock(&lock_mutex);
  }

}

// unlock_server_data
// file servers.h line 42
void unlock_server_data()
{
  pthread_mutex_lock(&servers_lock);
  if(!(server_data_users >= 1))
  {
    log_message(3, "%s:%d: %s", (const void *)"servers.c", 696, (const void *)"server_data_users non-positive before attempt to decrement it");
    pdnsd_exit();
  }

  server_data_users = server_data_users - 1;
  if(server_data_users == 0)
    pthread_cond_broadcast(&server_data_cond);

  pthread_mutex_unlock(&servers_lock);
}

// uptest
// file servers.c line 73
static signed int uptest(struct anonymous$7 *serv, signed int j)
{
  signed int ret = 0;
  signed int count_running_ping = 0;
  union anonymous$6 *s_addr;
  union anonymous$6 *tmp_if_expr$1;
  if(!(run_ipv4 == 0))
    tmp_if_expr$1 = (union anonymous$6 *)&(&serv->atup_a->elem[(signed long int)j].a)->ipv4;

  else
    tmp_if_expr$1 = (union anonymous$6 *)&(&serv->atup_a->elem[(signed long int)j].a)->ipv6;
  s_addr = tmp_if_expr$1;
  char uptest$$1$$1$$_debugsockabuf[46l];
  const char *return_value_const_name$2;
  const char *return_value_pdnsd_a2str$3;
  if(!(debug_p == 0))
  {
    return_value_const_name$2=const_name((signed int)serv->uptest);
    return_value_pdnsd_a2str$3=pdnsd_a2str(s_addr, uptest$$1$$1$$_debugsockabuf, 46);
    debug_msg(0, "performing uptest (type=%s) for %s\n", return_value_const_name$2, return_value_pdnsd_a2str$3);
  }

  server_data_users = server_data_users + 1;
  _Bool tmp_if_expr$6;
  if((signed int)serv->uptest == 8)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = (signed int)serv->uptest == 9 ? (_Bool)1 : (_Bool)0;
  unsigned long int return_value_pthread_self$4;
  signed int return_value_pthread_equal$5;
  if(tmp_if_expr$6)
  {
    return_value_pthread_self$4=pthread_self();
    return_value_pthread_equal$5=pthread_equal(return_value_pthread_self$4, servstat_thrid);
    if(!(return_value_pthread_equal$5 == 0))
    {
      count_running_ping = 1;
      server_status_ping = server_status_ping + 1;
    }

  }

  pthread_mutex_unlock(&servers_lock);
  signed int return_value_is_inaddr_any$7;
  signed int return_value_ping$9;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  unsigned int return_value_getuid$16;
  signed int return_value_setuid$17;
  signed int *return_value___errno_location$25;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  switch((signed int)serv->uptest)
  {
    case 5:
    {
      ret = (signed int)serv->atup_a->elem[(signed long int)j].is_up;
      break;
    }
    case 8:
    {
      return_value_is_inaddr_any$7=is_inaddr_any$link2(&serv->ping_a);
      union anonymous$6 *tmp_if_expr$8;
      if(!(return_value_is_inaddr_any$7 == 0))
        tmp_if_expr$8 = s_addr;

      else
        tmp_if_expr$8 = &serv->ping_a;
      return_value_ping$9=ping(tmp_if_expr$8, (signed int)serv->ping_timeout, 2);
      ret = (signed int)(return_value_ping$9 != -1);
      break;
    }
    case 6:

    case 16:

    case 17:
    {
      ret=if_up(serv->interface);
      if(!(ret == 0))
      {
        if((signed int)serv->uptest == 16)
          ret=dev_up(serv->interface, serv->device);

        else
          if((signed int)serv->uptest == 17)
            ret=dev_up("diald", serv->device);

      }

      break;
    }
    case 7:
    {
      signed int pid;
      pid=fork();
      if(pid == -1)
      {
        if(!(debug_p == 0))
        {
          return_value___errno_location$10=__errno_location();
          return_value_strerror$11=strerror(*return_value___errno_location$10);
          debug_msg(0, "Could not fork to perform exec uptest: %s\n", return_value_strerror$11);
        }

        break;
      }

      else
        if(pid == 0)
        {
          unsigned int return_value_getgid$14;
          return_value_getgid$14=getgid();
          signed int return_value_setgid$15;
          return_value_setgid$15=setgid(return_value_getgid$14);
          _Bool tmp_if_expr$18;
          if(return_value_setgid$15 == -1)
            tmp_if_expr$18 = (_Bool)1;

          else
          {
            return_value_getuid$16=getuid();
            return_value_setuid$17=setuid(return_value_getuid$16);
            tmp_if_expr$18 = return_value_setuid$17 == -1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$18)
          {
            signed int *return_value___errno_location$12;
            return_value___errno_location$12=__errno_location();
            char *return_value_strerror$13;
            return_value_strerror$13=strerror(*return_value___errno_location$12);
            log_message(3, "Could not reset uid or gid: %s", return_value_strerror$13);
            _exit(1);
          }

          signed int return_value_run_as$19;
          return_value_run_as$19=run_as(serv->uptest_usr);
          if(return_value_run_as$19 == 0)
            _exit(1);

          struct rlimit rl;
          signed int i;
          signed int return_value_getrlimit$22;
          return_value_getrlimit$22=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &rl);
          if(return_value_getrlimit$22 == -1)
          {
            signed int *return_value___errno_location$20;
            return_value___errno_location$20=__errno_location();
            char *return_value_strerror$21;
            return_value_strerror$21=strerror(*return_value___errno_location$20);
            log_message(3, "getrlimit() failed: %s", return_value_strerror$21);
            _exit(1);
          }

          i = 0;
          for( ; !((unsigned long int)i >= rl.rlim_max); i = i + 1)
          {
            signed int return_value_fcntl$26;
            return_value_fcntl$26=fcntl(i, 2, 1);
            if(return_value_fcntl$26 == -1)
            {
              return_value___errno_location$25=__errno_location();
              if(!(*return_value___errno_location$25 == 9))
              {
                signed int *return_value___errno_location$23;
                return_value___errno_location$23=__errno_location();
                char *return_value_strerror$24;
                return_value_strerror$24=strerror(*return_value___errno_location$23);
                log_message(3, "fcntl(F_SETFD) failed: %s", return_value_strerror$24);
                _exit(1);
              }

            }

          }
          execl("/bin/sh", "uptest_sh", (const void *)"-c", serv->uptest_cmd, (char *)(void *)0);
          _exit(1);
        }

        else
        {
          signed int status;
          signed int wpid;
          wpid=waitpid(pid, &status, 0);
          if(wpid == pid)
          {
            /* tag-#anon#lUN[lS32'__in'|S32'__i'] */
union anonymous$57
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
            ;
            if((0x7f & status) == 0)
            {
              signed int exitstatus = (((union anonymous$57){ .__in=status }).__i & 0xff00) >> 8;
              if(!(debug_p == 0))
                debug_msg(0, "uptest command \"%s\" exited with status %d\n", serv->uptest_cmd, exitstatus);

              ret = (signed int)(exitstatus == 0);
            }

            else
              if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
              {
                if(!(debug_p == 0))
                  debug_msg(0, "uptest command \"%s\" was terminated by signal %d\n", serv->uptest_cmd, ((union anonymous$57){ .__in=status }).__i & 0x7f);

              }

              else
                if(!(debug_p == 0))
                  debug_msg(0, "status of uptest command \"%s\" is of unknown type (0x%x)\n", serv->uptest_cmd, status);

          }

          else
            if(wpid == -1)
            {
              if(!(debug_p == 0))
              {
                return_value___errno_location$27=__errno_location();
                return_value_strerror$28=strerror(*return_value___errno_location$27);
                debug_msg(0, "Error while waiting for uptest command \"%s\" to terminate: waitpid for pid %d failed: %s\n", serv->uptest_cmd, pid, return_value_strerror$28);
              }

            }

            else
              if(!(debug_p == 0))
                debug_msg(0, "Error while waiting for uptest command \"%s\" to terminate: waitpid returned %d, expected pid %d\n", serv->uptest_cmd, wpid, pid);

        }
      break;
    }
    case 9:
    {
      signed long int tmp_if_expr$29;
      if(serv->timeout >= global.timeout)
        tmp_if_expr$29 = serv->timeout;

      else
        tmp_if_expr$29 = global.timeout;
      ret=query_uptest(s_addr, (signed int)serv->port, serv->query_test_name, tmp_if_expr$29, 2);
    }
  }
  pthread_mutex_lock(&servers_lock);
  if(!(count_running_ping == 0))
    server_status_ping = server_status_ping - 1;

  if(!(server_data_users >= 1))
  {
    log_message(3, "%s:%d: %s", (const void *)"servers.c", 194, (const void *)"server_data_users non-positive before attempt to decrement it");
    pdnsd_exit();
  }

  server_data_users = server_data_users - 1;
  if(server_data_users == 0)
    pthread_cond_broadcast(&server_data_cond);

  char _debugsockabuf[46l];
  const char *return_value_pdnsd_a2str$30;
  if(!(debug_p == 0))
  {
    return_value_pdnsd_a2str$30=pdnsd_a2str(s_addr, _debugsockabuf, 46);
    debug_msg(0, "result of uptest for %s: %s\n", return_value_pdnsd_a2str$30, ret != 0 ? "OK" : "failed");
  }

  return ret;
}

// use_server
// file dns_query.c line 2820
static signed int use_server(struct anonymous$7 *s, const unsigned char *name)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel$1;
  return_value_da_nel$1=da_nel$link2((struct anonymous$3 *)s->alist);
  n = (signed int)return_value_da_nel$1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous$9 *sl = &s->alist->elem[(signed long int)i];
    unsigned int nrem;
    unsigned int lrem;
    domain_match(name, sl->domain, &nrem, &lrem);
    if(lrem == 0u)
    {
      if(sl->exact == 0 || nrem == 0u)
        return (signed int)((signed int)sl->rule == 18);

    }

  }
  _Bool tmp_if_expr$3;
  if((signed int)s->policy == 20)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)s->policy == 21 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    unsigned int return_value_rhnsegcnt$2;
    return_value_rhnsegcnt$2=rhnsegcnt$link1(name);
    if(!(return_value_rhnsegcnt$2 >= 2u))
      return (signed int)((signed int)s->policy == 20);

    else
      return (signed int)((signed int)s->policy == 21);
  }

  return (signed int)((signed int)s->policy == 18);
}

// usleep_r
// file thread.h line 113
static inline signed int usleep_r(unsigned long int useconds)
{
  struct timespec ts = { .tv_sec=(signed long int)(useconds / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep$1;
  return_value_nanosleep$1=nanosleep(&ts, (struct timespec *)(void *)0);
  return return_value_nanosleep$1;
}

// usleep_r$link1
// file thread.h line 113
static inline signed int usleep_r$link1(unsigned long int useconds$link1)
{
  struct timespec ts$link1 = { .tv_sec=(signed long int)(useconds$link1 / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds$link1 % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep$1$link1;
  return_value_nanosleep$1$link1=nanosleep(&ts$link1, (struct timespec *)(void *)0);
  return return_value_nanosleep$1$link1;
}

// usleep_r$link2
// file thread.h line 113
static inline signed int usleep_r$link2(unsigned long int useconds$link2)
{
  struct timespec ts$link2 = { .tv_sec=(signed long int)(useconds$link2 / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds$link2 % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep$1$link2;
  return_value_nanosleep$1$link2=nanosleep(&ts$link2, (struct timespec *)(void *)0);
  return return_value_nanosleep$1$link2;
}

// usleep_r$link3
// file thread.h line 113
static inline signed int usleep_r$link3(unsigned long int useconds$link3)
{
  struct timespec ts$link3 = { .tv_sec=(signed long int)(useconds$link3 / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds$link3 % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep$1$link3;
  return_value_nanosleep$1$link3=nanosleep(&ts$link3, (struct timespec *)(void *)0);
  return return_value_nanosleep$1$link3;
}

// write_all
// file helpers.h line 182
static inline signed long int write_all(signed int fd, const void *data, unsigned long int n)
{
  signed long int written = (signed long int)0;
  while(!((unsigned long int)written >= n))
  {
    signed long int m;
    m=write(fd, (const void *)((const char *)data + written), n - (unsigned long int)written);
    if(!(m >= 0l))
      return m;

    written = written + m;
  }
  return written;
}

// write_all$link1
// file helpers.h line 182
static inline signed long int write_all$link1(signed int fd$link1, const void *data$link1, unsigned long int n$link1)
{
  signed long int written$link1 = (signed long int)0;
  while(!((unsigned long int)written$link1 >= n$link1))
  {
    signed long int m$link1;
    m$link1=write(fd$link1, (const void *)((const char *)data$link1 + written$link1), n$link1 - (unsigned long int)written$link1);
    if(!(m$link1 >= 0l))
      return m$link1;

    written$link1 = written$link1 + m$link1;
  }
  return written$link1;
}

// write_all$link2
// file helpers.h line 182
static inline signed long int write_all$link2(signed int fd$link2, const void *data$link2, unsigned long int n$link2)
{
  signed long int written$link2 = (signed long int)0;
  while(!((unsigned long int)written$link2 >= n$link2))
  {
    signed long int m$link2;
    m$link2=write(fd$link2, (const void *)((const char *)data$link2 + written$link2), n$link2 - (unsigned long int)written$link2);
    if(!(m$link2 >= 0l))
      return m$link2;

    written$link2 = written$link2 + m$link2;
  }
  return written$link2;
}

// write_disk_cache
// file cache.h line 165
void write_disk_cache(void)
{
  signed int j;
  signed int jlim;
  struct anonymous$0 *le;
  unsigned long int en = (unsigned long int)0;
  struct anonymous$59 pos;
  struct _IO_FILE *f;
  unsigned long int num_rrs_errs = (unsigned long int)0;
  signed long int num_rrs_errs$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(global.cache_dir);
  num_rrs_errs$array_size0 = (signed long int)(return_value_strlen$1 + sizeof(char [13l]) /*13ul*/ );
  char path[num_rrs_errs$array_size0];
  char *return_value_stpcpy$2;
  return_value_stpcpy$2=stpcpy(path, global.cache_dir);
  stpcpy(return_value_stpcpy$2, "/pdnsd.cache");
  if(!(debug_p == 0))
    debug_msg(0, "Writing cache to %s\n", (const void *)path);

  signed int return_value_softlock_cache_rw$3;
  return_value_softlock_cache_rw$3=softlock_cache_rw();
  signed int return_value_softunlock_cache_rw$4;
  signed int return_value_softlock_cache_r$5;
  unsigned long int return_value_fwrite$10;
  unsigned long int return_value_fwrite$15;
  unsigned long int return_value_fwrite$30;
  const unsigned short int *tmp_if_expr$32;
  signed int return_value_fclose$37;
  if(!(return_value_softlock_cache_rw$3 == 0))
  {
    purge_cache((signed long int)global.perm_cache * (signed long int)1024, 0);
    return_value_softunlock_cache_rw$4=softunlock_cache_rw();
    if(return_value_softunlock_cache_rw$4 == 0)
      goto lock_failed;

    return_value_softlock_cache_r$5=softlock_cache_r();
    if(return_value_softlock_cache_r$5 == 0)
      goto lock_failed;

    f=fopen(path, "w");
    if(f == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log_message(4, "Could not open disk cache file %s: %s", (const void *)path, return_value_strerror$7);
      goto softunlock_return;
    }

    return_value_fwrite$10=fwrite((const void *)cachverid, sizeof(const char [4l]) /*4ul*/ , (unsigned long int)1, f);
    if(!(return_value_fwrite$10 == 1ul))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(*return_value___errno_location$8);
      log_message(3, "Error while writing cache version identifier to disk cache: %s", return_value_strerror$9);
      goto fclose_unlock;
    }

    le=fetch_first(&pos);
    while(!(le == ((struct anonymous$0 *)NULL)))
    {
      if(!((1 & (signed int)le->flags) == 0))
      {
        if((2 & (signed int)le->flags) == 0)
          en = en + 1ul;

      }

      else
      {
        signed int tmp_if_expr$11;
        if(!((1 & (signed int)le->flags) == 0))
          tmp_if_expr$11 = 0;

        else
          tmp_if_expr$11 = le->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        jlim = tmp_if_expr$11;
        j = 0;
        for( ; !(j >= jlim); j = j + 1)
        {
          struct anonymous *write_disk_cache$$1$$7$$1$$2$$1$$1$$rrset;
          struct anonymous *tmp_if_expr$12;
          if(!(j >= 8))
            tmp_if_expr$12 = le->$anon0.rr.rrmu[(signed long int)j];

          else
            tmp_if_expr$12 = le->$anon0.rr.rrext[(signed long int)(j - 8)];
          write_disk_cache$$1$$7$$1$$2$$1$$1$$rrset = tmp_if_expr$12;
          if(!(write_disk_cache$$1$$7$$1$$2$$1$$1$$rrset == ((struct anonymous *)NULL)))
          {
            if((2 & (signed int)write_disk_cache$$1$$7$$1$$2$$1$$1$$rrset->flags) == 0)
            {
              en = en + 1ul;
              break;
            }

          }

        }
      }
      le=fetch_next(&pos);
    }
    return_value_fwrite$15=fwrite((const void *)&en, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, f);
    if(!(return_value_fwrite$15 == 1ul))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      char *return_value_strerror$14;
      return_value_strerror$14=strerror(*return_value___errno_location$13);
      log_message(3, "Error while writing entry count to disk cache: %s", return_value_strerror$14);
      goto fclose_unlock;
    }

    le=fetch_first(&pos);
    while(!(le == ((struct anonymous$0 *)NULL)))
    {
      if(!((1 & (signed int)le->flags) == 0))
      {
        if((2 & (signed int)le->flags) == 0)
          goto write_rrs;

      }

      else
      {
        signed int tmp_if_expr$16;
        if(!((1 & (signed int)le->flags) == 0))
          tmp_if_expr$16 = 0;

        else
          tmp_if_expr$16 = le->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        jlim = tmp_if_expr$16;
        j = 0;
        for( ; !(j >= jlim); j = j + 1)
        {
          struct anonymous *write_disk_cache$$1$$9$$1$$2$$1$$1$$rrset;
          struct anonymous *tmp_if_expr$17;
          if(!(j >= 8))
            tmp_if_expr$17 = le->$anon0.rr.rrmu[(signed long int)j];

          else
            tmp_if_expr$17 = le->$anon0.rr.rrext[(signed long int)(j - 8)];
          write_disk_cache$$1$$9$$1$$2$$1$$1$$rrset = tmp_if_expr$17;
          if(!(write_disk_cache$$1$$9$$1$$2$$1$$1$$rrset == ((struct anonymous *)NULL)))
          {
            if((2 & (signed int)write_disk_cache$$1$$9$$1$$2$$1$$1$$rrset->flags) == 0)
              goto write_rrs;

          }

        }
      }
      goto __CPROVER_DUMP_L48;

    write_rrs:
      ;
      struct anonymous$62 df;
      signed int num_rrs;
      const unsigned short int *iterlist;
      unsigned int return_value_rhnlen$18;
      return_value_rhnlen$18=rhnlen$link6(le->qname);
      df.qlen = (unsigned char)(return_value_rhnlen$18 - (unsigned int)1);
      df.num_rrs = (unsigned char)0;
      df.flags = le->flags;
      df.c_ns = le->c_ns;
      df.c_soa = le->c_soa;
      num_rrs = 0;
      signed int tmp_if_expr$19;
      if(!((1 & (signed int)le->flags) == 0))
        tmp_if_expr$19 = 0;

      else
        tmp_if_expr$19 = le->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      jlim = tmp_if_expr$19;
      j = 0;
      for( ; !(j >= jlim); j = j + 1)
      {
        struct anonymous *write_disk_cache$$1$$9$$1$$3$$1$$1$$rrset;
        struct anonymous *tmp_if_expr$20;
        if(!(j >= 8))
          tmp_if_expr$20 = le->$anon0.rr.rrmu[(signed long int)j];

        else
          tmp_if_expr$20 = le->$anon0.rr.rrext[(signed long int)(j - 8)];
        write_disk_cache$$1$$9$$1$$3$$1$$1$$rrset = tmp_if_expr$20;
        if(!(write_disk_cache$$1$$9$$1$$3$$1$$1$$rrset == ((struct anonymous *)NULL)))
        {
          num_rrs = num_rrs + 1;
          if((2 & (signed int)write_disk_cache$$1$$9$$1$$3$$1$$1$$rrset->flags) == 0)
            df.num_rrs = df.num_rrs + 1;

        }

      }
      if(!(num_rrs == (signed int)le->num_rrs))
      {
        num_rrs_errs = num_rrs_errs + 1ul;
        if(!(num_rrs_errs >= 11ul))
        {
          unsigned char buf[256l];
          const unsigned char *return_value_rhn2str$21;
          return_value_rhn2str$21=rhn2str(le->qname, buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
          log_message(4, "Counted %d rr record types for %s but cached counter=%d", num_rrs, return_value_rhn2str$21, le->num_rrs);
        }

      }

      unsigned long int return_value_fwrite$24;
      return_value_fwrite$24=fwrite((const void *)&df, sizeof(struct anonymous$62) /*6ul*/ , (unsigned long int)1, f);
      if(!(return_value_fwrite$24 == 1ul))
      {
        signed int *return_value___errno_location$22;
        return_value___errno_location$22=__errno_location();
        char *return_value_strerror$23;
        return_value_strerror$23=strerror(*return_value___errno_location$22);
        log_message(3, "Error while writing cache entry header to disk cache: %s", return_value_strerror$23);
        goto fclose_unlock;
      }

      if(!((1 & (signed int)le->flags) == 0))
      {
        struct anonymous$63 fttlts = { .ttl=le->$anon0.neg.ttl, .ts=le->$anon0.neg.ts };
        unsigned long int return_value_fwrite$27;
        return_value_fwrite$27=fwrite((const void *)&fttlts, sizeof(struct anonymous$63) /*16ul*/ , (unsigned long int)1, f);
        if(!(return_value_fwrite$27 == 1ul))
        {
          signed int *return_value___errno_location$25;
          return_value___errno_location$25=__errno_location();
          char *return_value_strerror$26;
          return_value_strerror$26=strerror(*return_value___errno_location$25);
          log_message(3, "Error while writing cache TTL and timestamp to disk cache: %s", return_value_strerror$26);
          goto fclose_unlock;
        }

      }

      if(!(df.qlen == 0))
      {
        return_value_fwrite$30=fwrite((const void *)le->qname, (unsigned long int)df.qlen, (unsigned long int)1, f);
        if(!(return_value_fwrite$30 == 1ul))
        {
          signed int *return_value___errno_location$28;
          return_value___errno_location$28=__errno_location();
          char *return_value_strerror$29;
          return_value_strerror$29=strerror(*return_value___errno_location$28);
          log_message(3, "Error while writing domain name to disk cache: %s", return_value_strerror$29);
          goto fclose_unlock;
        }

      }

      signed int tmp_if_expr$31;
      if(!((1 & (signed int)le->flags) == 0))
        tmp_if_expr$31 = 0;

      else
        tmp_if_expr$31 = le->$anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      jlim = tmp_if_expr$31;
      const unsigned short int *tmp_if_expr$33;
      if(!((1 & (signed int)le->flags) == 0))
        tmp_if_expr$33 = (const unsigned short int *)(void *)0;

      else
      {
        if(!(le->$anon0.rr.rrext == ((struct anonymous **)NULL)))
          tmp_if_expr$32 = rrcachiterlist;

        else
          tmp_if_expr$32 = rrmuiterlist;
        tmp_if_expr$33 = tmp_if_expr$32;
      }
      iterlist = tmp_if_expr$33;
      j = 0;
      for( ; !(j >= jlim); j = j + 1)
      {
        signed int tp = (signed int)iterlist[(signed long int)j];
        struct anonymous *rrset;
        rrset=getrrset_eff$link3(le, tp);
        if(!(rrset == ((struct anonymous *)NULL)))
        {
          if((2 & (signed int)rrset->flags) == 0)
          {
            signed int return_value_write_rrset$34;
            return_value_write_rrset$34=write_rrset(tp, rrset, f);
            if(return_value_write_rrset$34 == 0)
              goto fclose_unlock;

          }

        }

      }

    __CPROVER_DUMP_L48:
      ;
      le=fetch_next(&pos);
    }
    return_value_fclose$37=fclose(f);
    if(!(return_value_fclose$37 == 0))
    {
      signed int *return_value___errno_location$35;
      return_value___errno_location$35=__errno_location();
      char *return_value_strerror$36;
      return_value_strerror$36=strerror(*return_value___errno_location$35);
      log_message(3, "Could not close cache file %s after writing cache: %s", (const void *)path, return_value_strerror$36);
    }

    softunlock_cache_r();
    if(!(debug_p == 0))
      debug_msg(0, "Finished writing cache to disk.\n");

    goto __CPROVER_DUMP_L55;

  fclose_unlock:
    ;
    fclose(f);

  softunlock_return:
    ;
    softunlock_cache_r();
  }

  else
  {

  lock_failed:
    ;
    crash_msg("Lock failed; could not write disk cache.");
  }

__CPROVER_DUMP_L55:
  ;
}

// write_rrset
// file cache.c line 1554
static signed int write_rrset(signed int tp, struct anonymous *rrs, struct _IO_FILE *f)
{
  struct rr_b_s *rr;
  struct anonymous$61 sh;
  struct anonymous$60 rf;
  unsigned int num_rr;
  sh.tp = (unsigned char)tp;
  num_rr = (unsigned int)0;
  rr = rrs->rrs;
  for( ; !(rr == ((struct rr_b_s *)NULL)) && !(num_rr >= 255u); rr = rr->next)
    num_rr = num_rr + 1u;
  sh.num_rr = (unsigned char)num_rr;
  sh.flags = rrs->flags;
  sh.ttl = rrs->ttl;
  sh.ts = rrs->ts;
  unsigned long int return_value_fwrite$3;
  return_value_fwrite$3=fwrite((const void *)&sh, sizeof(struct anonymous$61) /*20ul*/ , (unsigned long int)1, f);
  if(!(return_value_fwrite$3 == 1ul))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_message(3, "Error while writing rr header to disk cache: %s", return_value_strerror$2);
    return 0;
  }

  rr = rrs->rrs;
  _Bool tmp_if_expr$8;
  unsigned long int return_value_fwrite$7;
  for( ; !(num_rr == 0u); num_rr = num_rr - 1u)
  {
    rf.rdlen = (unsigned short int)rr->rdlen;
    unsigned long int return_value_fwrite$6;
    return_value_fwrite$6=fwrite((const void *)&rf, sizeof(struct anonymous$60) /*2ul*/ , (unsigned long int)1, f);
    _Bool tmp_if_expr$9;
    if(!(return_value_fwrite$6 == 1ul))
      tmp_if_expr$9 = (_Bool)1;

    else
    {
      if(!(rf.rdlen == 0))
      {
        return_value_fwrite$7=fwrite((const void *)rr->data, (unsigned long int)rf.rdlen, (unsigned long int)1, f);
        tmp_if_expr$8 = return_value_fwrite$7 != (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$9)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_message(3, "Error while writing rr data to disk cache: %s", return_value_strerror$5);
      return 0;
    }

    rr = rr->next;
  }
  return 1;
}

// yield_lock_cache_rw
// file cache.c line 336
static void yield_lock_cache_rw()
{
  if(!(use_cache_lock == 0) && (!(r_pend == 0) || !(rw_pend == 0)))
  {
    pthread_mutex_lock(&lock_mutex);
    cache_w_lock = 0;
    r_susp = 0;
    if(r_pend == 0 || !(r_pend / 2 + 2 >= rw_pend))
      pthread_cond_signal(&rw_cond);

    else
      pthread_cond_broadcast(&r_cond);
    pthread_mutex_unlock(&lock_mutex);
    usleep_r$link3((unsigned long int)1000);
    pthread_mutex_lock(&lock_mutex);
    rw_pend = rw_pend + 1;
    while(!(cache_r_lock == 0) || !(cache_w_lock == 0))
      pthread_cond_wait(&rw_cond, &lock_mutex);
    cache_w_lock = 1;
    rw_pend = rw_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
  }

}

// zone_add
// file conf-parser.c line 2103
static const char * zone_add(struct anonymous$30 **za, const char *zone, unsigned int len)
{
  unsigned char *z;
  const char *err;
  unsigned long int sz;
  unsigned char rhn[256l];
  err=parsestr2rhn((unsigned char *)zone, len, rhn);
  void *return_value_malloc$3;
  if(!(err == ((const char *)NULL)))
    return err;

  else
  {
    unsigned int return_value_rhnlen$1;
    return_value_rhnlen$1=rhnlen(rhn);
    sz = (unsigned long int)return_value_rhnlen$1;
    struct anonymous$3 *return_value_da_grow1$2;
    return_value_da_grow1$2=da_grow1((struct anonymous$3 *)*za, (unsigned long int)((struct anonymous$30 *)0)->elem, sizeof(unsigned char *) /*8ul*/ , free_zone);
    *za = (struct anonymous$30 *)return_value_da_grow1$2;
    _Bool tmp_if_expr$4;
    if(*za == ((struct anonymous$30 *)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_malloc$3=malloc(sz);
      z = (unsigned char *)return_value_malloc$3;
      (*za)->elem[(signed long int)((*za)->nel - (unsigned long int)1)] = z;
      tmp_if_expr$4 = !((*za)->elem[(signed long int)((*za)->nel - (unsigned long int)1)] != ((unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      return "out of memory!";

    else
    {
      memcpy((void *)z, (const void *)rhn, sz);
      return (const char *)(void *)0;
    }
  }
}

