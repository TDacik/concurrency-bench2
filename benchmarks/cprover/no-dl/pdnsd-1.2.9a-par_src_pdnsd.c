// tag-#anon#ST[*{*{SYM#tag-dns_hash_ent_s#}_SYM#tag-dns_hash_ent_s#_}_*{SYM#tag-dns_hash_ent_s#}_SYM#tag-dns_hash_ent_s#__'pos'|U64'rhash']
// file hash.h line 49
struct anonymous_58;

// tag-#anon#ST[*{SYM#tag-llistnode_s#}_SYM#tag-llistnode_s#_'first'|*{SYM#tag-llistnode_s#}_SYM#tag-llistnode_s#_'last']
// file list.h line 123
struct anonymous_40;

// tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts']
// file cache.h line 64
struct anonymous_24;

// tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']
// file cache.h line 49
struct anonymous;

// tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']
// file conff.h line 62
struct anonymous_9;

// tag-#anon#ST[*{U8}_U8_'qname'|U64'cs'|U16'num_rrs'|U16'flags'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrext']#'rr']#'_anon0'|U8'c_ns'|U8'c_soa'|U48'_pad1']
// file cache.h line 58
struct anonymous_0;

// tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 126
struct anonymous_51;

// tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 111
struct anonymous_48;

// tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_49;

// tag-#anon#ST[*{cS8}_cS8_'name'|S32'val'|U32'_pad0']
// file consts.h line 60
struct anonymous_32;

// tag-#anon#ST[ARR10{S8}_S8_'name'|ARR32{S8}_S8_'phone'|U16'_pad0'|S32'outgoing']
// file /usr/include/linux/isdn.h line 102
struct anonymous_53;

// tag-#anon#ST[ARR16{U64}_U64_'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_41;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']#_'__cancel_jmp_buf'|ARR4{*{V}_V_}_*{V}_V__'__pad']
// file /usr/include/pthread.h line 523
struct anonymous_66;

// tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrext']
// file cache.h line 69
struct anonymous_2;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'_pad0']
// file /usr/include/pthread.h line 525
struct anonymous_65;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_55;

// tag-#anon#ST[S32'bucket'|U32'_pad0'|*{SYM#tag-dns_hash_ent_s#}_SYM#tag-dns_hash_ent_s#_'ent']
// file hash.h line 55
struct anonymous_59;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_44;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_47;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_46;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_43;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_45;

// tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']
// file conff.h line 55
struct anonymous_20;

// tag-#anon#ST[S64'perm_cache'|*{S8}_S8_'cache_dir'|*{S8}_S8_'pidfile'|S32'port'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'a'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'out_a'|SYM#tag-in6_addr#'ipv4_6_prefix'|U32'_pad0'|S64'max_ttl'|S64'min_ttl'|S64'neg_ttl'|S16'neg_rrs_pol'|S16'neg_domain_pol'|S16'verbosity'|ARR21{S8}_S8_'run_as'|S8'daemon'|S8'debug'|S8'stat_pipe'|S8'notcp'|S8'strict_suid'|S8'use_nss'|S8'paranoid'|S8'lndown_kluge'|S8'onquery'|S8'rnd_recs'|U24'_pad1'|S32'ctl_perms'|U32'_pad2'|*{S8}_S8_'scheme_file'|S32'proc_limit'|S32'procq_limit'|S64'tcp_qtimeout'|S64'timeout'|S32'par_queries'|S32'query_method'|S32'query_port_start'|S32'query_port_end'|S32'udpbufsize'|U32'_pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{*{U8}_U8_}_*{U8}_U8__'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{*{U8}_U8_}_*{U8}_U8__'elem']#_'deleg_only_zones']
// file conff.h line 120
struct anonymous_21;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 119
struct anonymous_50;

// tag-#anon#ST[S64'ttl'|S64'ts']
// file cache.c line 135
struct anonymous_63;

// tag-#anon#ST[S8'prefix'|S8'pidfile'|S8'verbosity'|S8'pdnsduser'|S8'daemon'|S8'debug'|S8'stat_pipe'|S8'notcp'|S8'query_method']
// file conff.h line 161
struct anonymous_31;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'a'|SYM#tag-in_addr#'a4fallback'|S64'timeout'|U16'flags'|S16'nocache'|S16'state'|S16'qm'|S8'auth_serv'|S8'lean_query'|S8'edns_query'|S8'needs_testing'|S8'trusted'|S8'aa'|S8'tc'|S8'failed'|*{cU8}_cU8_'nsdomain'|*{SYM#tag-rejectlist_s#}_SYM#tag-rejectlist_s#_'rejectlist'|S32'sock'|U16'transl'|U16'recvl'|S32'iolen'|U32'_pad0'|*{SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#}_SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#_'msg'|*{SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#}_SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#_'recvbuf'|U16'myrid'|U16'_pad1'|S32's_errno']
// file dns_query.c line 75
struct anonymous_5;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'addr'|SYM#tag-#anon#UN[SYM#tag-in_pktinfo#'pi4'|SYM#tag-in6_pktinfo#'pi6']#'pi'|S32'sock'|S32'proto'|U64'len'|ARR0{U8}_U8_'buf']
// file dns_answer.c line 104
struct anonymous_69;

// tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']
// file conff.h line 76
struct anonymous_13;

// tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']
// file ipvers.h line 248
struct anonymous_15;

// tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']
// file conff.h line 69
struct anonymous_11;

// tag-#anon#ST[U16'__unused'|U16'mtu']
// file /usr/include/linux/icmp.h line 78
struct anonymous_36;

// tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']
// file dns.h line 166
struct anonymous_29;

// tag-#anon#ST[U16'id'|U16'sequence']
// file /usr/include/linux/icmp.h line 73
struct anonymous_35;

// tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']
// file dns.h line 201
struct anonymous_28;

// tag-#anon#ST[U16'port'|S16'uptest'|U32'_pad0'|S64'timeout'|S64'interval'|S64'ping_timeout'|ARR32{S8}_S8_'scheme'|*{S8}_S8_'uptest_cmd'|ARR21{S8}_S8_'uptest_usr'|ARR16{S8}_S8_'interface'|ARR16{S8}_S8_'device'|U24'_pad1'|*{U8}_U8_'query_test_name'|*{S8}_S8_'label'|S8'purge_cache'|S8'nocache'|S8'lean_query'|S8'edns_query'|S8'is_proxy'|S8'rootserver'|S8'rand_servers'|S8'preset'|S8'rejectrecursively'|U8'_pad2'|S16'rejectpolicy'|S16'policy'|U16'_pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#}_SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#}_SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#_'elem']#_'alist'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}_SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}_SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#_'elem']#_'atup_a'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#_'elem']#_'reject_a4'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#_'elem']#_'reject_a6'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'ping_a']
// file conff.h line 83
struct anonymous_7;

// tag-#anon#ST[U16'qtype'|U16'qclass'|ARR0{U8}_U8_'query']
// file dns_answer.c line 128
struct anonymous_70;

// tag-#anon#ST[U16'rdlen']
// file cache.c line 104
struct anonymous_60;

// tag-#anon#ST[U16'tp'|U16'dlen'|ARR0{U8}_U8_'nm']
// file dns_answer.c line 139
struct anonymous_71;

// tag-#anon#ST[U16'udpsize'|U16'rcode'|U16'version'|U8'do_flg'|U8'_pad0']
// file dns.h line 216
struct anonymous_17;

// tag-#anon#ST[U32'index'|ARR0{U8}_U8_'s']
// file dns.h line 279
struct anonymous_64;

// tag-#anon#ST[U64'nel']
// file list.h line 32
struct anonymous_3;

// tag-#anon#ST[U64'nel'|ARR0{*{U8}_U8_}_*{U8}_U8__'elem']
// file conff.h line 118
struct anonymous_30;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#}_SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#_'elem']
// file conff.h line 67
struct anonymous_8;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'qname'|U64'cs'|U16'num_rrs'|U16'flags'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrext']#'rr']#'_anon0'|U8'c_ns'|U8'c_soa'|U48'_pad1']#}_SYM#tag-#anon#ST[*{U8}_U8_'qname'|U64'cs'|U16'num_rrs'|U16'flags'|U32'_pad0'|SYM#tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrext']#'rr']#'_anon0'|U8'c_ns'|U8'c_soa'|U48'_pad1']#_'elem']
// file dns_query.c line 174
struct anonymous_16;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}_SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#_'elem']
// file conff.h line 60
struct anonymous_19;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'a'|SYM#tag-in_addr#'a4fallback'|S64'timeout'|U16'flags'|S16'nocache'|S16'state'|S16'qm'|S8'auth_serv'|S8'lean_query'|S8'edns_query'|S8'needs_testing'|S8'trusted'|S8'aa'|S8'tc'|S8'failed'|*{cU8}_cU8_'nsdomain'|*{SYM#tag-rejectlist_s#}_SYM#tag-rejectlist_s#_'rejectlist'|S32'sock'|U16'transl'|U16'recvl'|S32'iolen'|U32'_pad0'|*{SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#}_SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#_'msg'|*{SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#}_SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#_'recvbuf'|U16'myrid'|U16'_pad1'|S32's_errno']#}_SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']#'a'|SYM#tag-in_addr#'a4fallback'|S64'timeout'|U16'flags'|S16'nocache'|S16'state'|S16'qm'|S8'auth_serv'|S8'lean_query'|S8'edns_query'|S8'needs_testing'|S8'trusted'|S8'aa'|S8'tc'|S8'failed'|*{cU8}_cU8_'nsdomain'|*{SYM#tag-rejectlist_s#}_SYM#tag-rejectlist_s#_'rejectlist'|S32'sock'|U16'transl'|U16'recvl'|S32'iolen'|U32'_pad0'|*{SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#}_SYM#tag-#anon#ST[U16'len'|SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#'hdr']#_'msg'|*{SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#}_SYM#tag-#anon#ST[U16'id'|BF{U32}_U32_'rd'|BF{U32}_U32_'tc'|BF{U32}_U32_'aa'|BF{U32}_U32_'opcode'|BF{U32}_U32_'qr'|BF{U32}_U32_'rcode'|BF{U32}_U32_'cd'|BF{U32}_U32_'ad'|BF{U32}_U32_'z'|BF{U32}_U32_'ra'|U16'qdcount'|U16'ancount'|U16'nscount'|U16'arcount']#_'recvbuf'|U16'myrid'|U16'_pad1'|S32's_errno']#_'elem']
// file dns_query.c line 118
struct anonymous_4;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#_'elem']
// file conff.h line 80
struct anonymous_12;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#_'elem']
// file conff.h line 53
struct anonymous_14;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#_'elem']
// file conff.h line 73
struct anonymous_10;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[U16'port'|S16'uptest'|U32'_pad0'|S64'timeout'|S64'interval'|S64'ping_timeout'|ARR32{S8}_S8_'scheme'|*{S8}_S8_'uptest_cmd'|ARR21{S8}_S8_'uptest_usr'|ARR16{S8}_S8_'interface'|ARR16{S8}_S8_'device'|U24'_pad1'|*{U8}_U8_'query_test_name'|*{S8}_S8_'label'|S8'purge_cache'|S8'nocache'|S8'lean_query'|S8'edns_query'|S8'is_proxy'|S8'rootserver'|S8'rand_servers'|S8'preset'|S8'rejectrecursively'|U8'_pad2'|S16'rejectpolicy'|S16'policy'|U16'_pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#}_SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#}_SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#_'elem']#_'alist'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}_SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}_SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#_'elem']#_'atup_a'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#_'elem']#_'reject_a4'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#_'elem']#_'reject_a6'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'ping_a']#}_SYM#tag-#anon#ST[U16'port'|S16'uptest'|U32'_pad0'|S64'timeout'|S64'interval'|S64'ping_timeout'|ARR32{S8}_S8_'scheme'|*{S8}_S8_'uptest_cmd'|ARR21{S8}_S8_'uptest_usr'|ARR16{S8}_S8_'interface'|ARR16{S8}_S8_'device'|U24'_pad1'|*{U8}_U8_'query_test_name'|*{S8}_S8_'label'|S8'purge_cache'|S8'nocache'|S8'lean_query'|S8'edns_query'|S8'is_proxy'|S8'rootserver'|S8'rand_servers'|S8'preset'|S8'rejectrecursively'|U8'_pad2'|S16'rejectpolicy'|S16'policy'|U16'_pad3'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#}_SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#}_SYM#tag-#anon#ST[*{U8}_U8_'domain'|S16'exact'|S16'rule'|U32'_pad0']#_'elem']#_'alist'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}_SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#}_SYM#tag-#anon#ST[S64'i_ts'|S8'is_up'|U24'_pad0'|SYM#tag-#anon#ST[SYM#tag-in6_addr#'ipv6'|SYM#tag-in_addr#'ipv4']#'a']#_'elem']#_'atup_a'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in_addr#'a'|SYM#tag-in_addr#'mask']#_'elem']#_'reject_a4'|*{SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#_'elem']#}_SYM#tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#}_SYM#tag-#anon#ST[SYM#tag-in6_addr#'a'|SYM#tag-in6_addr#'mask']#_'elem']#_'reject_a6'|SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#'ping_a']#_'elem']
// file conff.h line 115
struct anonymous_18;

// tag-#anon#ST[U64'nel'|ARR0{SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#}_SYM#tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']#_'elem']
// file conff.h line 52
struct anonymous_54;

// tag-#anon#ST[U8'qlen'|U8'num_rrs'|U16'flags'|U8'c_ns'|U8'c_soa']
// file cache.c line 122
struct anonymous_62;

// tag-#anon#ST[U8'tp'|U8'num_rr'|U16'flags'|S64'ttl'|S64'ts']
// file cache.c line 109
struct anonymous_61;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}_SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'_pad0'|SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#_|*{V}_V_)->V_'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_42;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name']
// file /usr/include/net/if.h line 130
union anonymous_25;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_27;

// tag-#anon#UN[ARR1{U32}_U32_'icmp6_un_data32'|ARR2{U16}_U16_'icmp6_un_data16'|ARR4{U8}_U8_'icmp6_un_data8']
// file /usr/include/netinet/icmp6.h line 43
union anonymous_37;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'_pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}_V_'si_addr'|S16'si_addr_lsb'|U48'_pad0'|SYM#tag-#anon#ST[*{V}_V_'_lower'|*{V}_V_'_upper']#'si_addr_bnd']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'_pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}_V_'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_52;

// tag-#anon#UN[SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts']#'neg'|SYM#tag-#anon#ST[ARR8{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrmu'|*{*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#_}_*{SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#}_SYM#tag-#anon#ST[*{SYM#tag-rr_lent_s#}_SYM#tag-rr_lent_s#_'lent'|S64'ttl'|S64'ts'|U16'flags'|U48'_pad0'|*{SYM#tag-rr_b_s#}_SYM#tag-rr_b_s#_'rrs']#__'rrext']#'rr']
// file cache.h line 63
union anonymous_1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_56;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'id'|U16'sequence']#'echo'|U32'gateway'|SYM#tag-#anon#ST[U16'__unused'|U16'mtu']#'frag']
// file /usr/include/linux/icmp.h line 72
union anonymous_34;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_33;

// tag-#anon#UN[SYM#tag-in_addr#'ipv4'|SYM#tag-in6_addr#'ipv6']
// file ipvers.h line 228
union anonymous_6;

// tag-#anon#UN[SYM#tag-in_pktinfo#'pi4'|SYM#tag-in6_pktinfo#'pi6']
// file dns_answer.c line 90
union anonymous_67;

// tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'|U8'ip6_un2_vfc']
// file /usr/include/netinet/ip6.h line 26
union anonymous_38;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'|SYM#tag-sockaddr#'ifru_dstaddr'|SYM#tag-sockaddr#'ifru_broadaddr'|SYM#tag-sockaddr#'ifru_netmask'|SYM#tag-sockaddr#'ifru_hwaddr'|S16'ifru_flags'|S32'ifru_ivalue'|S32'ifru_mtu'|SYM#tag-ifmap#'ifru_map'|ARR16{S8}_S8_'ifru_slave'|ARR16{S8}_S8_'ifru_newname'|*{S8}_S8_'ifru_data']
// file /usr/include/net/if.h line 135
union anonymous_26;

// tag-#anon#UN[SYM#tag-sockaddr_in#'sin4'|SYM#tag-sockaddr_in6#'sin6']
// file dns_answer.c line 105
union anonymous_68;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_39;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_23;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 742
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_dynamic_list_head
// file list.h line 78
struct _dynamic_list_head;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 246
struct cmsghdr;

// tag-dns_hash_ent_s
// file hash.h line 29
struct dns_hash_ent_s;

// tag-icmp6_filter
// file /usr/include/netinet/icmp6.h line 33
struct icmp6_filter;

// tag-icmp6_hdr
// file /usr/include/netinet/icmp6.h line 38
struct icmp6_hdr;

// tag-icmp_filter
// file /usr/include/linux/icmp.h line 92
struct icmp_filter;

// tag-icmphdr
// file /usr/include/linux/icmp.h line 68
struct icmphdr;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in6_pktinfo
// file /usr/include/netinet/in.h line 535
struct in6_pktinfo;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-in_pktinfo
// file /usr/include/x86_64-linux-gnu/bits/in.h line 147
struct in_pktinfo;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip6_hbh
// file /usr/include/netinet/ip6.h line 57
struct ip6_hbh;

// tag-ip6_hdr
// file /usr/include/netinet/ip6.h line 24
struct ip6_hdr;

// tag-ip6_hdrctl
// file /usr/include/netinet/ip6.h line 28
struct ip6_hdrctl;

// tag-iphdr
// file /usr/include/netinet/ip.h line 44
struct iphdr;

// tag-llistnode_s
// file list.h line 118
struct llistnode_s;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 228
struct msghdr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-qhintnode_s
// file dns_query.h line 33
struct qhintnode_s;

// tag-qstatnode_s
// file dns_query.c line 2030
struct qstatnode_s;

// tag-rejectlist_s
// file dns_query.c line 61
struct rejectlist_s;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rr_b_s
// file cache.h line 39
struct rr_b_s;

// tag-rr_infos
// file rr_types.h line 455
struct rr_infos;

// tag-rr_lent_s
// file cache.h line 34
struct rr_lent_s;

// tag-rre_s
// file dns_answer.c line 481
struct rre_s;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

#ifndef NULL
#define NULL ((void*)0)
#endif

// SET_PDNSD_A2
// file ipvers.h line 260
static inline void SET_PDNSD_A2(struct anonymous_15 *a2, union anonymous_6 *a);
// SET_PDNSD_A2_link1
// file ipvers.h line 260
static inline void SET_PDNSD_A2_link1(struct anonymous_15 *a2_link1, union anonymous_6 *a_link1);
// __cmsg_nxthdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 276
extern struct cmsghdr * __cmsg_nxthdr(struct msghdr *, struct cmsghdr *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 680
extern void __pthread_register_cancel(struct anonymous_66 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 692
extern void __pthread_unregister_cancel(struct anonymous_66 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 733
extern void __pthread_unwind_next(struct anonymous_66 *);
// __sigsetjmp
// file /usr/include/pthread.h line 743
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _exit
// file /usr/include/unistd.h line 606
extern void _exit(signed int);
// a2ptrstr
// file dns.c line 306
signed int a2ptrstr(union anonymous_6 *a, signed int tp, unsigned char *buf);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_additional_a
// file dns_answer.c line 715
static signed int add_additional_a(struct anonymous_28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, signed long int queryts, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva);
// add_additional_rr
// file dns_answer.c line 662
static signed int add_additional_rr(struct anonymous_28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, unsigned int dlen, void *data, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva);
// add_additional_rrs
// file dns_answer.c line 689
static signed int add_additional_rrs(struct anonymous_28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, struct rr_b_s *rrb, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva);
// add_ar
// file dns_answer.c line 495
static signed int add_ar(struct _dynamic_list_head **ar, unsigned short int tp, unsigned short int tsz, void *tnm, unsigned char *nm, unsigned int ttl);
// add_cache
// file cache.h line 173
void add_cache(struct anonymous_0 *cent);
// add_cent_rr
// file cache.h line 201
signed int add_cent_rr(struct anonymous_0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data);
// add_cent_rr_int
// file cache.c line 668
static signed int add_cent_rr_int(struct anonymous_0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data, struct rr_b_s **rtail);
// add_cent_rrset_by_index
// file cache.c line 605
static signed int add_cent_rrset_by_index(struct anonymous_0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags);
// add_cent_rrset_by_type
// file cache.h line 200
signed int add_cent_rrset_by_type(struct anonymous_0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags);
// add_dns_hash
// file hash.h line 69
signed int add_dns_hash(struct anonymous_0 *data, struct anonymous_58 *loc);
// add_host
// file dns.c line 340
static signed int add_host(unsigned char *pn, unsigned char *rns, union anonymous_6 *a, signed int tp, signed int a_sz, signed long int ttl, unsigned int flags, signed int reverse);
// add_opt_pseudo_rr
// file dns_answer.c line 423
signed int add_opt_pseudo_rr(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned short int udpsize, unsigned short int rcode, unsigned short int ednsver, unsigned short int Zflags);
// add_qserv
// file dns_query.c line 1958
static signed int add_qserv(struct anonymous_4 **q, struct anonymous_15 *a, signed int port, signed long int timeout, unsigned int flags, signed int nocache, char lean_query, char edns_query, char auth_s, char needs_testing, char trusted, const unsigned char *nsdomain, struct rejectlist_s *rejectlist);
// add_rejectlist
// file dns_query.c line 2853
static struct rejectlist_s * add_rejectlist(struct rejectlist_s *rl, struct anonymous_7 *sp);
// add_reverse_cache
// file cache.h line 174
signed int add_reverse_cache(struct anonymous_0 *cent);
// add_rr
// file dns_answer.c line 213
static signed int add_rr(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned short int type, unsigned int ttl, unsigned int dlen, void *data, char section, unsigned int *udp, struct _dynamic_list_head **cb);
// add_rrset
// file dns_answer.c line 554
static signed int add_rrset(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int tp, signed long int queryts, struct anonymous_0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar);
// add_to_response
// file dns_answer.c line 605
static signed int add_to_response(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int qtype, signed long int queryts, struct anonymous_0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar);
// addr_add
// file conf-parser.c line 1871
static const char * addr_add(struct anonymous_19 **ata, const char *ipstr);
// adjust_dom_ttl
// file cache.c line 1840
static inline void adjust_dom_ttl(struct anonymous_0 *cent);
// adjust_ttl
// file cache.c line 1817
static inline void adjust_ttl(struct anonymous *rrset);
// alloc_nel
// file list.c line 57
static inline unsigned long int alloc_nel(unsigned long int n);
// ans_ttl
// file dns_answer.c line 170
static inline signed long int ans_ttl(struct anonymous *rrset, signed long int queryts);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// auth_ok
// file dns_query.c line 2554
static signed int auth_ok(struct anonymous_4 *q, const unsigned char *name, signed int thint, struct anonymous_0 *ent, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, struct anonymous_5 *qse, struct _dynamic_list_head *ns, struct anonymous_4 **serv);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bind_socket
// file dns_query.c line 682
static signed int bind_socket(signed int s);
// binsearch_keyword
// file consts.h line 65
signed int binsearch_keyword(const char *name, signed int len, const struct anonymous_32 *dic, signed int range);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// change_servers
// file servers.h line 45
signed int change_servers(signed int i, struct anonymous_54 *ar, signed int up);
// chdir
// file /usr/include/unistd.h line 500
extern signed int chdir(const char *);
// check_ipv6
// file main.c line 202
static signed int check_ipv6();
// check_localaddrs
// file conf-parser.c line 1976
static void check_localaddrs(struct anonymous_7 *serv);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// compose_answer
// file dns_answer.c line 752
static struct anonymous_28 * compose_answer(struct anonymous_40 *ql, struct anonymous_29 *hdr, unsigned long int *rlen, struct anonymous_17 *ednsinfo, unsigned int *udp, signed int *rcodep);
// compress_name
// file dns.c line 248
unsigned int compress_name(unsigned char *in, unsigned char *out, unsigned int offs, struct _dynamic_list_head **cb);
// confparse
// file conf-parser.c line 488
signed int confparse(struct _IO_FILE *in, char *prestr, struct anonymous_21 *global, struct anonymous_18 **servers, signed int includedepth, char **errstr);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// const_name
// file consts.h line 67
const char * const_name(signed int c);
// copy_cent
// file cache.c line 1098
struct anonymous_0 * copy_cent(struct anonymous_0 *cent);
// copy_rr
// file cache.c line 1059
static inline struct rr_b_s * copy_rr(struct rr_b_s *rr);
// copy_rrset
// file cache.c line 1072
static struct anonymous * copy_rrset(struct anonymous *rrset);
// cr_check_add
// file cache.c line 1759
static signed int cr_check_add(struct anonymous_0 *cent, signed int idx, signed long int ttl, signed long int ts, unsigned int flags);
// crash_msg
// file error.c line 52
void crash_msg(char *msg);
// create_rr
// file cache.c line 588
static struct rr_b_s * create_rr(unsigned int dlen, void *data);
// da_grow1
// file list.h line 54
struct anonymous_3 * da_grow1(struct anonymous_3 *a, unsigned long int headsz, unsigned long int elemsz, void (*cleanuproutine)(void *));
// da_grow1::cleanuproutine_object
//
void cleanuproutine_object(void *);
// da_nel
// file list.h line 59
static inline unsigned int da_nel(struct anonymous_3 *a);
// da_nel_link1
// file list.h line 59
static inline unsigned int da_nel_link1(struct anonymous_3 *a_link1);
// da_nel_link2
// file list.h line 59
static inline unsigned int da_nel_link2(struct anonymous_3 *a_link2);
// da_nel_link3
// file list.h line 59
static inline unsigned int da_nel_link3(struct anonymous_3 *a_link3);
// da_nel_link4
// file list.h line 59
static inline unsigned int da_nel_link4(struct anonymous_3 *a_link4);
// da_nel_link5
// file list.h line 59
static inline unsigned int da_nel_link5(struct anonymous_3 *a_link5);
// da_nel_link6
// file list.h line 59
static inline unsigned int da_nel_link6(struct anonymous_3 *a_link6);
// da_resize
// file list.h line 55
struct anonymous_3 * da_resize(struct anonymous_3 *a, unsigned long int headsz, unsigned long int elemsz, unsigned long int n, void (*cleanuproutine)(void *));
// da_resize::cleanuproutine_object
//
void cleanuproutine_object(void *);
// debug_msg
// file error.h line 74
void debug_msg(signed int c, const char *fmt, ...);
// decode_query
// file dns_answer.c line 1003
static signed int decode_query(unsigned char *data, unsigned long int rlen, unsigned char **ptrrem, unsigned long int *lenrem, struct anonymous_40 *qp);
// decode_query_additional
// file dns_answer.c line 1058
static signed int decode_query_additional(unsigned char *data, unsigned long int rlen, unsigned char *ptr, unsigned long int sz, signed int numrr, signed int *numopt, struct anonymous_17 *ep);
// decompress_name
// file dns.c line 44
signed int decompress_name(unsigned char *msg, unsigned long int msgsz, unsigned char **src, unsigned long int *sz, unsigned char *tgt, unsigned int *len);
// decrease_procs
// file dns_answer.c line 1347
static inline void decrease_procs();
// del_cache
// file cache.h line 175
void del_cache(const unsigned char *name);
// del_cache_ent
// file cache.c line 2075
static void del_cache_ent(struct anonymous_0 *cent, struct anonymous_58 *loc);
// del_cent
// file cache.c line 2061
void del_cent(struct anonymous_0 *cent);
// del_cent_rrset_by_index
// file cache.c line 776
static signed int del_cent_rrset_by_index(struct anonymous_0 *cent, signed int i);
// del_dns_hash
// file hash.h line 71
struct anonymous_0 * del_dns_hash(const unsigned char *key);
// del_dns_hash_ent
// file hash.h line 70
struct anonymous_0 * del_dns_hash_ent(struct anonymous_58 *loc);
// del_qserv
// file dns_query.c line 2025
static inline void del_qserv(struct anonymous_4 *q);
// del_rrset
// file cache.h line 202
signed int del_rrset(struct anonymous *rrs);
// destroy_cache
// file cache.h line 163
void destroy_cache(void);
// dev_up
// file netdev.c line 135
signed int dev_up(char *ifname, char *devname);
// dlist_first
// file list.h line 87
static inline void * dlist_first(struct _dynamic_list_head *a);
// dlist_first_link1
// file list.h line 87
static inline void * dlist_first_link1(struct _dynamic_list_head *a_link1);
// dlist_first_link2
// file list.h line 87
static inline void * dlist_first_link2(struct _dynamic_list_head *a_link2);
// dlist_grow
// file list.h line 112
struct _dynamic_list_head * dlist_grow(struct _dynamic_list_head *a, unsigned long int len);
// dlist_last
// file list.h line 107
static inline void * dlist_last(struct _dynamic_list_head *a);
// dlist_last_link1
// file list.h line 107
static inline void * dlist_last_link1(struct _dynamic_list_head *a_link1);
// dlist_last_link2
// file list.h line 107
static inline void * dlist_last_link2(struct _dynamic_list_head *a_link2);
// dlist_next
// file list.h line 98
static inline void * dlist_next(void *ref);
// dlist_next_link1
// file list.h line 98
static inline void * dlist_next_link1(void *ref_link1);
// dlist_next_link2
// file list.h line 98
static inline void * dlist_next_link2(void *ref_link2);
// dns_hash
// file hash.c line 57
static unsigned int dns_hash(const unsigned char *str, unsigned long int *rhash);
// dns_lookup
// file hash.h line 68
struct anonymous_0 * dns_lookup(const unsigned char *key, struct anonymous_58 *loc);
// dns_rootserver_resolv
// file dns_query.c line 2978
struct anonymous_14 * dns_rootserver_resolv(struct anonymous_19 *atup_a, signed int port, char edns_query, signed long int timeout);
// dnsflags2str
// file dns.c line 544
char * dnsflags2str(struct anonymous_29 *hdr, char *buf);
// domain_match
// file dns.c line 204
unsigned int domain_match(const unsigned char *ms, const unsigned char *md, unsigned int *os, unsigned int *od);
// dump_cache
// file cache.h line 168
signed int dump_cache(signed int fd, const unsigned char *name, signed int exact);
// dump_cent
// file cache.c line 2395
static signed int dump_cent(signed int fd, struct anonymous_0 *cent);
// dup2
// file /usr/include/unistd.h line 537
extern signed int dup2(signed int, signed int);
// empty_cache
// file cache.h line 162
signed int empty_cache(struct anonymous_8 *sla);
// equiv_inaddr2
// file helpers.h line 149
static inline signed int equiv_inaddr2(union anonymous_6 *a, struct anonymous_15 *b);
// equiv_inaddr2_link1
// file helpers.h line 149
static inline signed int equiv_inaddr2_link1(union anonymous_6 *a_link1, struct anonymous_15 *b_link1);
// equiv_inaddr2_link2
// file helpers.h line 149
static inline signed int equiv_inaddr2_link2(union anonymous_6 *a_link2, struct anonymous_15 *b_link2);
// escapestr
// file helpers.c line 583
signed int escapestr(const char *in, signed int ilen, char *str, signed int size);
// exclusive_lock_server_data
// file servers.h line 43
signed int exclusive_lock_server_data(signed int tm);
// exclusive_unlock_server_data
// file servers.h line 44
void exclusive_unlock_server_data(signed int retest);
// execl
// file /usr/include/unistd.h line 576
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fetch_first
// file hash.h line 76
struct anonymous_0 * fetch_first(struct anonymous_59 *pos);
// fetch_next
// file hash.h line 77
struct anonymous_0 * fetch_next(struct anonymous_59 *pos);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// final_init
// file main.c line 179
signed int final_init();
// flags2str
// file cache.h line 119
char * flags2str(unsigned int flags, char *buf, signed int nflags, const char *flgnames);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// follow_cname_chain
// file dns_answer.c line 188
static inline signed int follow_cname_chain(struct anonymous_0 *c, unsigned char *name);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 759
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_cent
// file cache.h line 203
void free_cent(struct anonymous_0 *cent);
// free_cent0
// file cache.h line 204
void free_cent0(void *ptr);
// free_dns_hash
// file hash.h line 74
void free_dns_hash();
// free_dns_hash_bucket
// file hash.h line 72
void free_dns_hash_bucket(signed int i);
// free_dns_hash_selected
// file hash.h line 73
void free_dns_hash_selected(signed int i, struct anonymous_8 *sla);
// free_rejectlist
// file dns_query.c line 2892
static inline void free_rejectlist(struct rejectlist_s *rl);
// free_server_data
// file conff.c line 390
static void free_server_data(struct anonymous_18 *sa);
// free_servparm
// file conff.h line 187
void free_servparm(struct anonymous_7 *serv);
// free_slist_array
// file conff.c line 368
void free_slist_array(struct anonymous_8 *sla);
// free_slist_domain
// file conff.h line 185
void free_slist_domain(void *ptr);
// free_zone
// file conff.h line 184
void free_zone(void *ptr);
// free_zones
// file conff.c line 354
static void free_zones(struct anonymous_30 *za);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fsprintf
// file helpers.h line 170
signed int fsprintf(signed int fd, const char *format, ...);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_cname
// file dns.c line 492
const char * get_cname(signed int id);
// get_ename
// file dns.c line 532
const char * get_ename(signed int id);
// get_rand16
// file helpers.h line 168
unsigned short int get_rand16(void);
// get_rrlent_ts
// file cache.c line 880
static inline signed long int get_rrlent_ts(struct rr_lent_s *le);
// get_tname
// file dns.c line 501
const char * get_tname(signed int id);
// getgid
// file /usr/include/unistd.h line 684
extern unsigned int getgid(void);
// getline
// file /usr/include/stdio.h line 678
extern signed long int getline(char ** restrict , unsigned long int *, struct _IO_FILE *);
// getlocalowner
// file cache.h line 178
unsigned char * getlocalowner(unsigned char *name, signed int tp);
// getnextp
// file conf-parser.c line 84
static char * getnextp(char **buf, unsigned long int *n, struct _IO_FILE *in, char *p, unsigned int *linenr, char **errstr);
// getpwnam_r
// file /usr/include/pwd.h line 151
extern signed int getpwnam_r(const char *, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// getrrset
// file cache.h line 221
static inline struct anonymous * getrrset(struct anonymous_0 *cent, signed int type);
// getrrset_link1
// file cache.h line 221
static inline struct anonymous * getrrset_link1(struct anonymous_0 *cent_link1, signed int type_link1);
// getrrset_link2
// file cache.h line 221
static inline struct anonymous * getrrset_link2(struct anonymous_0 *cent_link2, signed int type_link2);
// getrrset_eff
// file cache.h line 251
static inline struct anonymous * getrrset_eff(struct anonymous_0 *cent, signed int type);
// getrrset_eff_link1
// file cache.h line 251
static inline struct anonymous * getrrset_eff_link1(struct anonymous_0 *cent_link1, signed int type_link1);
// getrrset_eff_link2
// file cache.h line 251
static inline struct anonymous * getrrset_eff_link2(struct anonymous_0 *cent_link2, signed int type_link2);
// getrrset_eff_link3
// file cache.h line 251
static inline struct anonymous * getrrset_eff_link3(struct anonymous_0 *cent_link3, signed int type_link3);
// getrrtpname
// file dns.c line 480
const char * getrrtpname(signed int tp);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 678
extern unsigned int getuid(void);
// have_rr
// file cache.h line 274
static inline signed int have_rr(struct anonymous_0 *cent, signed int type);
// have_rr_link1
// file cache.h line 274
static inline signed int have_rr_link1(struct anonymous_0 *cent_link1, signed int type_link1);
// have_rr_link2
// file cache.h line 274
static inline signed int have_rr_link2(struct anonymous_0 *cent_link2, signed int type_link2);
// hexdump
// file helpers.c line 546
void hexdump(const void *data, signed int dlen, char *buf, signed int buflen);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// icmp4_errcmp
// file icmp.c line 136
static signed int icmp4_errcmp(char *packet, signed int plen, struct in_addr *to, char *errmsg, signed int elen, signed int errtype);
// icmp6_errcmp
// file icmp.c line 330
static signed int icmp6_errcmp(char *packet, signed int plen, struct in6_addr *to, char *errmsg, signed int elen, signed int errtype);
// if_up
// file netdev.c line 186
signed int if_up(char *devname);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init_cache_lock
// file cache.h line 157
static inline void init_cache_lock();
// init_cent
// file cache.h line 199
signed int init_cent(struct anonymous_0 *cent, const unsigned char *qname, signed long int ttl, signed long int ts, unsigned int flags);
// init_crandom
// file helpers.c line 447
void init_crandom();
// init_log_lock
// file error.h line 45
static inline void init_log_lock(void);
// init_ping_socket
// file icmp.c line 114
void init_ping_socket(void);
// init_rng
// file helpers.c line 458
signed int init_rng(void);
// init_stat_sock
// file status.h line 56
void init_stat_sock(void);
// init_tcp_socket
// file dns_answer.c line 1967
signed int init_tcp_socket(void);
// init_udp_socket
// file dns_answer.c line 1536
signed int init_udp_socket(void);
// initgroups
// file /usr/include/grp.h line 198
extern signed int initgroups(const char *, unsigned int);
// insert_rrl
// file cache.c line 889
static signed int insert_rrl(struct anonymous *rrs, struct anonymous_0 *cent, signed int idx);
// invalidate_record
// file cache.h line 176
void invalidate_record(const unsigned char *name);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_inaddr2_any
// file helpers.h line 123
static inline signed int is_inaddr2_any(struct anonymous_15 *a);
// is_inaddr_any
// file helpers.h line 115
static inline signed int is_inaddr_any(union anonymous_6 *a);
// is_inaddr_any_link1
// file helpers.h line 115
static inline signed int is_inaddr_any_link1(union anonymous_6 *a_link1);
// is_inaddr_any_link2
// file helpers.h line 115
static inline signed int is_inaddr_any_link2(union anonymous_6 *a_link2);
// is_interrupted_servstat_thread
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread();
// is_interrupted_servstat_thread_link1
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread_link1();
// is_local_addr
// file netdev.h line 30
signed int is_local_addr(union anonymous_6 *a);
// isnormalencdomname
// file helpers.h line 112
signed int isnormalencdomname(const unsigned char *rhn, unsigned int maxlen);
// keyncmp
// file consts.c line 98
static inline signed int keyncmp(const char *key1, signed int len, const char *key2);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// listmerge
// file cache.c line 972
static struct rr_lent_s * listmerge(struct rr_lent_s *p, struct rr_lent_s *q);
// llist_first
// file list.h line 145
static inline void * llist_first(struct anonymous_40 *a);
// llist_free
// file list.h line 168
void llist_free(struct anonymous_40 *a);
// llist_grow
// file list.h line 167
signed int llist_grow(struct anonymous_40 *a, unsigned long int len);
// llist_init
// file list.h line 130
static inline void llist_init(struct anonymous_40 *a);
// llist_isempty
// file list.h line 138
static inline signed int llist_isempty(struct anonymous_40 *a);
// llist_last
// file list.h line 161
static inline void * llist_last(struct anonymous_40 *a);
// llist_next
// file list.h line 153
static inline void * llist_next(void *ref);
// loc2str
// file rr_types.c line 80
const char * loc2str(const void *binary, char *ascii, unsigned long int asclen);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// lock_cache_r
// file cache.c line 235
static void lock_cache_r(void);
// lock_cache_rw
// file cache.c line 269
static void lock_cache_rw(void);
// lock_server_data
// file servers.h line 41
void lock_server_data();
// log_message
// file error.h line 50
void log_message(signed int prior, const char *s, ...);
// lookup_cache
// file cache.h line 179
struct anonymous_0 * lookup_cache(const unsigned char *name, signed int *wild);
// lookup_cache_local_rrset
// file cache.h line 180
struct anonymous * lookup_cache_local_rrset(const unsigned char *name, signed int type);
// lookup_cache_status
// file dns_query.c line 3235
static signed int lookup_cache_status(const unsigned char *name, signed int thint, struct anonymous_0 **cachedp, unsigned short int *flagsp, signed long int queryts, unsigned char *c_soa);
// lookup_cent_array
// file dns_query.c line 1094
static struct anonymous_0 * lookup_cent_array(struct anonymous_16 *ca, const unsigned char *nm);
// lookup_const
// file consts.h line 66
signed int lookup_const(const char *name, signed int len);
// lookup_ns
// file dns_query.c line 2904
static struct anonymous_14 * lookup_ns(const unsigned char *domain);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mark_servers
// file servers.h line 39
signed int mark_servers(signed int i, char *label, signed int up);
// memcmp
// file /usr/include/string.h line 65
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// mempcpy
// file /usr/include/string.h line 386
extern void * mempcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mk_dns_hash
// file hash.h line 61
static inline void mk_dns_hash();
// mk_error_reply
// file dns_answer.c line 1133
static void mk_error_reply(unsigned short int id, unsigned short int opcode, unsigned short int rescode, struct anonymous_29 *rep);
// mk_flag_val
// file cache.h line 187
static inline unsigned int mk_flag_val(struct anonymous_7 *server);
// mk_netmask4
// file conf-parser.c line 1903
static inline unsigned int mk_netmask4(signed int len);
// mk_netmask6
// file conf-parser.c line 1915
static inline void mk_netmask6(struct in6_addr *m, signed int len);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// needs_intermittent_testing
// file servers.h line 56
static inline signed int needs_intermittent_testing(struct anonymous_7 *sp);
// needs_testing
// file servers.h line 49
static inline signed int needs_testing(struct anonymous_7 *sp);
// needs_testing_link1
// file servers.h line 49
static inline signed int needs_testing_link1(struct anonymous_7 *sp_link1);
// negate_cent
// file cache.h line 205
void negate_cent(struct anonymous_0 *cent, signed long int ttl, signed long int ts);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// p_cancel_query
// file dns_query.c line 1926
static void p_cancel_query(struct anonymous_5 *st);
// p_dns_cached_resolve
// file dns_query.c line 3340
static signed int p_dns_cached_resolve(struct anonymous_4 *q, const unsigned char *name, signed int thint, struct anonymous_0 **cachedp, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa);
// p_dns_resolve
// file dns_query.c line 3066
static signed int p_dns_resolve(const unsigned char *name, signed int thint, struct anonymous_0 **cachedp, signed int hops, struct qhintnode_s *qhlist, unsigned char *c_soa);
// p_exec_query
// file dns_query.c line 1137
static signed int p_exec_query(struct anonymous_0 **entp, const unsigned char *name, signed int thint, struct anonymous_5 *st, struct _dynamic_list_head **ns, unsigned char *c_soa);
// p_query_sm
// file dns_query.c line 847
static signed int p_query_sm(struct anonymous_5 *st);
// p_recursive_query
// file dns_query.c line 2070
static signed int p_recursive_query(struct anonymous_4 *q, const unsigned char *name, signed int thint, struct anonymous_0 **entp, signed int *nocache, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, unsigned char *c_soa);
// parse_ip
// file conf-parser.c line 1841
static const char * parse_ip(const char *ipstr, union anonymous_6 *a);
// parsestr2rhn
// file helpers.h line 54
const char * parsestr2rhn(const unsigned char *str, unsigned int len, unsigned char *rhn);
// pdnsd_a2str
// file helpers.h line 157
const char * pdnsd_a2str(union anonymous_6 *a, char *buf, signed int maxlen);
// pdnsd_exit
// file pdnsd_assert.h line 38
void pdnsd_exit(void);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// ping
// file icmp.c line 514
signed int ping(union anonymous_6 *addr, signed int timeout, signed int rep);
// ping4
// file icmp.c line 160
static signed int ping4(struct in_addr addr, signed int timeout, signed int rep);
// ping6
// file icmp.c line 371
static signed int ping6(struct in6_addr a, signed int timeout, signed int rep);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// precsize_ntoa
// file rr_types.c line 60
static const char * precsize_ntoa(unsigned char prec, char *retbuf);
// print_serr
// file status.c line 61
static signed int print_serr(signed int rs, const char *msg);
// print_succ
// file status.c line 77
static signed int print_succ(signed int rs);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_query
// file dns_answer.c line 1156
static struct anonymous_28 * process_query(unsigned char *data, unsigned long int *rlenp, unsigned int *udp, signed int *rcodep);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 299
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous_56 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 977
extern signed int pthread_cond_signal(union anonymous_56 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_timedwait(union anonymous_56 *, union anonymous_33 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous_56 *, union anonymous_33 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 278
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 242
extern void pthread_exit(void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1119
extern void * pthread_getspecific(unsigned int);
// pthread_key_create
// file /usr/include/pthread.h line 1111
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_33 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 758
extern signed int pthread_mutex_trylock(union anonymous_33 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_33 *);
// pthread_self
// file /usr/include/pthread.h line 275
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1122
extern signed int pthread_setspecific(unsigned int, const void *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_41 *, struct anonymous_41 *);
// purge_all_rrsets
// file cache.c line 1207
static signed int purge_all_rrsets(struct anonymous_0 *cent, signed int test, signed int *numrrsrem);
// purge_cache
// file cache.c line 1314
static void purge_cache(signed long int sz, signed int lazy);
// purge_cent
// file cache.c line 1257
static signed int purge_cent(struct anonymous_0 *cent, signed int delete, signed int test);
// purge_rrset
// file cache.c line 1188
static signed int purge_rrset(struct anonymous_0 *cent, signed int idx, signed int test);
// query_stat_same_inaddr2
// file dns_query.c line 2013
static inline signed int query_stat_same_inaddr2(struct anonymous_5 *qs, struct anonymous_15 *b);
// query_uptest
// file dns_query.c line 3513
signed int query_uptest(union anonymous_6 *addr, signed int port, const unsigned char *name, signed long int timeout, signed int rep);
// r_dns_cached_resolve
// file dns_query.h line 36
signed int r_dns_cached_resolve(unsigned char *name, signed int thint, struct anonymous_0 **cachedp, signed int hops, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// randrr
// file dns_answer.c line 519
static inline struct rr_b_s * randrr(struct rr_b_s *rrb);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// read_allocstring
// file status.c line 122
static signed int read_allocstring(signed int fh, char **res, unsigned int *len);
// read_config_file
// file conff.h line 182
signed int read_config_file(const char *nm, struct anonymous_21 *global, struct anonymous_18 **servers, signed int includedepth, char **errstr);
// read_disk_cache
// file cache.h line 164
void read_disk_cache(void);
// read_domain
// file status.c line 148
static signed int read_domain(signed int fh, char *buf, unsigned int buflen);
// read_hosts
// file dns.h line 291
signed int read_hosts(const char *fn, unsigned char *rns, signed long int ttl, unsigned int flags, signed int aliases, char **errstr);
// read_long
// file status.c line 104
static signed int read_long(signed int fh, unsigned int *res);
// read_resolv_conf
// file conf-parser.c line 2009
static signed int read_resolv_conf(const char *fn, struct anonymous_19 **ata, char **errstr);
// read_short
// file status.c line 91
static signed int read_short(signed int fh, unsigned short int *res);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realloc_or_cleanup
// file dns_query.c line 784
static inline void * realloc_or_cleanup(void *ptr, unsigned long int size);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int,  struct sockaddr *, unsigned int *);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// reject_add
// file conf-parser.c line 1926
static const char * reject_add(struct anonymous_7 *serv, const char *ipstr);
// reload_config_file
// file conff.c line 222
signed int reload_config_file(const char *nm, char **errstr);
// remove_opt_pseudo_rr
// file dns_answer.c line 462
unsigned long int remove_opt_pseudo_rr(struct anonymous_28 *ans, unsigned long int sz);
// remove_rrl
// file cache.c line 953
static void remove_rrl(struct rr_lent_s *le);
// report_cache_stat
// file cache.h line 167
signed int report_cache_stat(signed int f);
// report_conf_stat
// file conff.c line 399
signed int report_conf_stat(signed int f);
// report_error
// file conf-parser.c line 54
static char * report_error(const char *conftype, unsigned int linenr, const char *msg);
// report_errorf
// file conf-parser.c line 70
static char * report_errorf(const char *conftype, unsigned int linenr, const char *frm, ...);
// report_server_stat
// file conff.c line 501
static signed int report_server_stat(signed int f, signed int i);
// report_thread_stat
// file dns_answer.c line 2141
signed int report_thread_stat(signed int f);
// resolv_rootserver_addrs
// file servers.c line 289
static struct anonymous_14 * resolv_rootserver_addrs(struct anonymous_19 *a, signed int port, char edns_query, signed long int timeout);
// retest
// file servers.c line 230
static void retest(signed int i, signed int j);
// rhn2str
// file helpers.h line 52
const unsigned char * rhn2str(const unsigned char *rhn, unsigned char *str, unsigned int size);
// rhncpy
// file helpers.h line 111
unsigned int rhncpy(unsigned char *dst, const unsigned char *src);
// rhnicmp
// file helpers.h line 214
static inline signed int rhnicmp(const unsigned char *a, const unsigned char *b);
// rhnicmp_link1
// file helpers.h line 214
static inline signed int rhnicmp_link1(const unsigned char *a_link1, const unsigned char *b_link1);
// rhnicmp_link2
// file helpers.h line 214
static inline signed int rhnicmp_link2(const unsigned char *a_link2, const unsigned char *b_link2);
// rhnlen
// file helpers.h line 62
static inline unsigned int rhnlen(const unsigned char *rhn);
// rhnlen_link1
// file helpers.h line 62
static inline unsigned int rhnlen_link1(const unsigned char *rhn_link1);
// rhnlen_link2
// file helpers.h line 62
static inline unsigned int rhnlen_link2(const unsigned char *rhn_link2);
// rhnlen_link3
// file helpers.h line 62
static inline unsigned int rhnlen_link3(const unsigned char *rhn_link3);
// rhnlen_link4
// file helpers.h line 62
static inline unsigned int rhnlen_link4(const unsigned char *rhn_link4);
// rhnlen_link5
// file helpers.h line 62
static inline unsigned int rhnlen_link5(const unsigned char *rhn_link5);
// rhnlen_link6
// file helpers.h line 62
static inline unsigned int rhnlen_link6(const unsigned char *rhn_link6);
// rhnsegcnt
// file helpers.h line 100
static inline unsigned int rhnsegcnt(const unsigned char *rhn);
// rhnsegcnt_link1
// file helpers.h line 100
static inline unsigned int rhnsegcnt_link1(const unsigned char *rhn_link1);
// rhnsegcnt_link2
// file helpers.h line 100
static inline unsigned int rhnsegcnt_link2(const unsigned char *rhn_link2);
// rr_to_cache
// file dns_query.c line 183
static signed int rr_to_cache(struct anonymous_16 **centa, unsigned char *oname, signed int tp, signed long int ttl, unsigned int dlen, void *data, unsigned int flags, signed long int queryts);
// rr_tp_byname
// file rr_types.h line 533
signed int rr_tp_byname(char *name);
// rrs2cent
// file dns_query.c line 229
static signed int rrs2cent(unsigned char *msg, unsigned long int msgsz, unsigned char **ptr, unsigned long int *lcnt, signed int recnum, unsigned int flags, signed long int queryts, struct anonymous_16 **centa, signed int *numopt, struct anonymous_17 *ep);
// run_as
// file helpers.h line 37
signed int run_as(const char *user);
// same_inaddr2
// file helpers.h line 141
static inline signed int same_inaddr2(union anonymous_6 *a, struct anonymous_15 *b);
// scan_string
// file conf-parser.c line 186
static signed int scan_string(char **curp, char *outbuf, unsigned int outbufsz, char **errstr);
// sched_server_test
// file servers.h line 38
void sched_server_test(union anonymous_6 *sa, signed int nadr, signed int up);
// scheme_ok
// file servers.c line 203
static signed int scheme_ok(struct anonymous_7 *serv);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// servstat_thread
// file servers.c line 314
void * servstat_thread(void *p);
// set_all_flags_ttl
// file dns_query.c line 3210
static void set_all_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous_0 *cached);
// set_cent_flags
// file cache.h line 177
signed int set_cent_flags(const unsigned char *name, unsigned int flags);
// set_flags_ttl
// file dns_query.c line 3196
static signed int set_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous_0 *cached, signed int tp);
// setgid
// file /usr/include/unistd.h line 720
extern signed int setgid(unsigned int);
// setsid
// file /usr/include/unistd.h line 670
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 703
extern signed int setuid(unsigned int);
// sigaction
// file /usr/include/signal.h line 257
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 219
extern signed int sigaddset(struct anonymous_41 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 213
extern signed int sigemptyset(struct anonymous_41 *);
// sigint_handler
// file servers.c line 853
static void sigint_handler(signed int signum);
// sigwait
// file /usr/include/signal.h line 268
extern signed int sigwait(const struct anonymous_41 *, signed int *);
// simple_dns_cached_resolve
// file dns_query.c line 3446
static signed int simple_dns_cached_resolve(struct anonymous_19 *atup_a, signed int port, char edns_query, signed long int timeout, const unsigned char *name, signed int thint, struct anonymous_0 **cachedp);
// skiprhn
// file helpers.h line 88
static inline unsigned char * skiprhn(unsigned char *rhn);
// skiprhn_link1
// file helpers.h line 88
static inline unsigned char * skiprhn_link1(unsigned char *rhn_link1);
// skiprhn_link2
// file helpers.h line 88
static inline unsigned char * skiprhn_link2(unsigned char *rhn_link2);
// skipsegs
// file helpers.h line 74
static inline const unsigned char * skipsegs(const unsigned char *nm, unsigned int k);
// skipsegs_link1
// file helpers.h line 74
static inline const unsigned char * skipsegs_link1(const unsigned char *nm_link1, unsigned int k_link1);
// skipsegs_link2
// file helpers.h line 74
static inline const unsigned char * skipsegs_link2(const unsigned char *nm_link2, unsigned int k_link2);
// slist_add
// file conf-parser.c line 2074
static const char * slist_add(struct anonymous_8 **sla, const char *nm, unsigned int len, signed int tp);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// soa_minimum
// file dns_query.c line 1106
static signed long int soa_minimum(struct rr_b_s *rrs);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// softlock_cache_r
// file cache.c line 371
static signed int softlock_cache_r(void);
// softlock_cache_rw
// file cache.c line 408
static signed int softlock_cache_rw(void);
// softlock_mutex
// file helpers.h line 39
signed int softlock_mutex(union anonymous_33 *mutex);
// softunlock_cache_r
// file cache.c line 396
static signed int softunlock_cache_r(void);
// softunlock_cache_rw
// file cache.c line 432
static signed int softunlock_cache_rw(void);
// sort_rrl
// file cache.c line 1012
static void sort_rrl();
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// start_dns_servers
// file dns_answer.c line 2109
void start_dns_servers(void);
// start_servstat_thread
// file servers.h line 37
signed int start_servstat_thread(void);
// start_stat_sock
// file status.h line 57
signed int start_stat_sock(void);
// status_thread
// file status.c line 172
static void * status_thread(void *p);
// statusif
// file netdev.c line 110
signed int statusif(char *name);
// stpcpy
// file /usr/include/string.h line 564
extern char * stpcpy(char *, const char *);
// stpncpy
// file /usr/include/string.h line 572
extern char * stpncpy(char *, const char *, unsigned long int);
// str2pdnsd_a
// file helpers.h line 156
signed int str2pdnsd_a(const char *addr, union anonymous_6 *a);
// str2rhn
// file helpers.h line 53
signed int str2rhn(const unsigned char *str, unsigned char *rhn);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncp
// file helpers.h line 234
static inline signed int strncp(char *dst, const char *src, unsigned long int dstsz);
// strncp_link1
// file helpers.h line 234
static inline signed int strncp_link1(char *dst_link1, const char *src_link1, unsigned long int dstsz_link1);
// strncp_link2
// file helpers.h line 234
static inline signed int strncp_link2(char *dst_link2, const char *src_link2, unsigned long int dstsz_link2);
// strndup
// file /usr/include/string.h line 179
extern char * strndup(const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtotime
// file conf-parser.c line 249
static signed long int strtotime(char *nptr, char **endptr, char **errstr);
// sva_add
// file dns_answer.c line 149
static signed int sva_add(struct _dynamic_list_head **sva, const unsigned char *rhn, unsigned short int tp, unsigned short int dlen, void *data);
// switch_to_tcp
// file dns_query.c line 814
static inline void switch_to_tcp(struct anonymous_5 *st);
// switch_to_udp
// file dns_query.c line 803
static inline void switch_to_udp(struct anonymous_5 *st);
// tcp_answer_thread
// file dns_answer.c line 1811
static void * tcp_answer_thread(void *csock);
// tcp_answer_thread::1::1::2::4::4::__cancel_routine_object
//
void __cancel_routine_object(void *);
// tcp_answer_thread::1::1::2::4::5::__cancel_routine_object
//
void __cancel_routine_object(void *);
// tcp_answer_thread::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// tcp_answer_thread_cleanup
// file dns_answer.c line 1801
static void tcp_answer_thread_cleanup(void *csock);
// tcp_server_thread
// file dns_answer.c line 2033
void * tcp_server_thread(void *p);
// test_onquery
// file servers.h line 40
void test_onquery(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timedlock_cache_rw
// file cache.c line 285
static signed int timedlock_cache_rw(signed int tm);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// translescapedchar
// file conf-parser.c line 149
static char translescapedchar(char c);
// udp_answer_thread
// file dns_answer.c line 1368
static void * udp_answer_thread(void *data);
// udp_answer_thread::1::1::2::5::__cancel_routine_object
//
void __cancel_routine_object(void *);
// udp_answer_thread::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// udp_answer_thread_cleanup
// file dns_answer.c line 1356
static void udp_answer_thread_cleanup(void *data);
// udp_server_thread
// file dns_answer.c line 1623
void * udp_server_thread(void *dummy);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// unlock_cache_r
// file cache.c line 250
static void unlock_cache_r(void);
// unlock_cache_rw
// file cache.c line 311
static void unlock_cache_rw(void);
// unlock_server_data
// file servers.h line 42
void unlock_server_data();
// uptest
// file servers.c line 73
static signed int uptest(struct anonymous_7 *serv, signed int j);
// use_server
// file dns_query.c line 2820
static signed int use_server(struct anonymous_7 *s, const unsigned char *name);
// usleep_r
// file thread.h line 113
static inline signed int usleep_r(unsigned long int useconds);
// usleep_r_link1
// file thread.h line 113
static inline signed int usleep_r_link1(unsigned long int useconds_link1);
// usleep_r_link2
// file thread.h line 113
static inline signed int usleep_r_link2(unsigned long int useconds_link2);
// usleep_r_link3
// file thread.h line 113
static inline signed int usleep_r_link3(unsigned long int useconds_link3);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// write_all
// file helpers.h line 182
static inline signed long int write_all(signed int fd, const void *data, unsigned long int n);
// write_all_link1
// file helpers.h line 182
static inline signed long int write_all_link1(signed int fd_link1, const void *data_link1, unsigned long int n_link1);
// write_all_link2
// file helpers.h line 182
static inline signed long int write_all_link2(signed int fd_link2, const void *data_link2, unsigned long int n_link2);
// write_disk_cache
// file cache.h line 165
void write_disk_cache(void);
// write_rrset
// file cache.c line 1554
static signed int write_rrset(signed int tp, struct anonymous *rrs, struct _IO_FILE *f);
// yield_lock_cache_rw
// file cache.c line 336
static void yield_lock_cache_rw();
// zone_add
// file conf-parser.c line 2103
static const char * zone_add(struct anonymous_30 **za, const char *zone, unsigned int len);

struct anonymous_58
{
  // pos
  struct dns_hash_ent_s **pos;
  // rhash
  unsigned long int rhash;
};

struct anonymous_40
{
  // first
  struct llistnode_s *first;
  // last
  struct llistnode_s *last;
};

struct anonymous_24
{
  // lent
  struct rr_lent_s *lent;
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
};

struct anonymous
{
  // lent
  struct rr_lent_s *lent;
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
  // flags
  unsigned short int flags;
  // rrs
  struct rr_b_s *rrs;
};

struct anonymous_9
{
  // domain
  unsigned char *domain;
  // exact
  signed short int exact;
  // rule
  signed short int rule;
};

struct anonymous_2
{
  // rrmu
  struct anonymous *rrmu[8l];
  // rrext
  struct anonymous **rrext;
};

union anonymous_1
{
  // neg
  struct anonymous_24 neg;
  // rr
  struct anonymous_2 rr;
};

struct anonymous_0
{
  // qname
  unsigned char *qname;
  // cs
  unsigned long int cs;
  // num_rrs
  unsigned short int num_rrs;
  // flags
  unsigned short int flags;
  // _anon0
  union anonymous_1 _anon0;
  // c_ns
  unsigned char c_ns;
  // c_soa
  unsigned char c_soa;
};

struct anonymous_51
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_48
{
  // _lower
  void *_lower;
  // _upper
  void *_upper;
};

struct anonymous_49
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
  // si_addr_bnd
  struct anonymous_48 si_addr_bnd;
};

struct anonymous_32
{
  // name
  const char *name;
  // val
  signed int val;
};

struct anonymous_53
{
  // name
  char name[10l];
  // phone
  char phone[32l];
  // outgoing
  signed int outgoing;
};

struct anonymous_41
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_65
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_66
{
  // __cancel_jmp_buf
  struct anonymous_65 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_55
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_59
{
  // bucket
  signed int bucket;
  // ent
  struct dns_hash_ent_s *ent;
};

struct anonymous_44
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_47
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_46
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_45
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_50
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_52
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_44 _kill;
  // _timer
  struct anonymous_45 _timer;
  // _rt
  struct anonymous_46 _rt;
  // _sigchld
  struct anonymous_47 _sigchld;
  // _sigfault
  struct anonymous_49 _sigfault;
  // _sigpoll
  struct anonymous_50 _sigpoll;
  // _sigsys
  struct anonymous_51 _sigsys;
};

struct anonymous_43
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_52 _sifields;
};

union anonymous_27
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_27 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct anonymous_15
{
  // ipv6
  struct in6_addr ipv6;
  // ipv4
  struct in_addr ipv4;
};

struct anonymous_20
{
  // i_ts
  signed long int i_ts;
  // is_up
  char is_up;
  // a
  struct anonymous_15 a;
};

union anonymous_6
{
  // ipv4
  struct in_addr ipv4;
  // ipv6
  struct in6_addr ipv6;
};

struct anonymous_21
{
  // perm_cache
  signed long int perm_cache;
  // cache_dir
  char *cache_dir;
  // pidfile
  char *pidfile;
  // port
  signed int port;
  // a
  union anonymous_6 a;
  // out_a
  union anonymous_6 out_a;
  // ipv4_6_prefix
  struct in6_addr ipv4_6_prefix;
  // max_ttl
  signed long int max_ttl;
  // min_ttl
  signed long int min_ttl;
  // neg_ttl
  signed long int neg_ttl;
  // neg_rrs_pol
  signed short int neg_rrs_pol;
  // neg_domain_pol
  signed short int neg_domain_pol;
  // verbosity
  signed short int verbosity;
  // run_as
  char run_as[21l];
  // daemon
  char daemon;
  // debug
  char debug;
  // stat_pipe
  char stat_pipe;
  // notcp
  char notcp;
  // strict_suid
  char strict_suid;
  // use_nss
  char use_nss;
  // paranoid
  char paranoid;
  // lndown_kluge
  char lndown_kluge;
  // onquery
  char onquery;
  // rnd_recs
  char rnd_recs;
  // ctl_perms
  signed int ctl_perms;
  // scheme_file
  char *scheme_file;
  // proc_limit
  signed int proc_limit;
  // procq_limit
  signed int procq_limit;
  // tcp_qtimeout
  signed long int tcp_qtimeout;
  // timeout
  signed long int timeout;
  // par_queries
  signed int par_queries;
  // query_method
  signed int query_method;
  // query_port_start
  signed int query_port_start;
  // query_port_end
  signed int query_port_end;
  // udpbufsize
  signed int udpbufsize;
  // deleg_only_zones
  struct anonymous_30 *deleg_only_zones;
};

struct anonymous_63
{
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
} __attribute__ ((__packed__));

struct anonymous_31
{
  // prefix
  char prefix;
  // pidfile
  char pidfile;
  // verbosity
  char verbosity;
  // pdnsduser
  char pdnsduser;
  // daemon
  char daemon;
  // debug
  char debug;
  // stat_pipe
  char stat_pipe;
  // notcp
  char notcp;
  // query_method
  char query_method;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

union anonymous_68
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

struct anonymous_5
{
  // a
  union anonymous_68 a;
  // a4fallback
  struct in_addr a4fallback;
  // timeout
  signed long int timeout;
  // flags
  unsigned short int flags;
  // nocache
  signed short int nocache;
  // state
  signed short int state;
  // qm
  signed short int qm;
  // auth_serv
  char auth_serv;
  // lean_query
  char lean_query;
  // edns_query
  char edns_query;
  // needs_testing
  char needs_testing;
  // trusted
  char trusted;
  // aa
  char aa;
  // tc
  char tc;
  // failed
  char failed;
  // nsdomain
  const unsigned char *nsdomain;
  // rejectlist
  struct rejectlist_s *rejectlist;
  // sock
  signed int sock;
  // transl
  unsigned short int transl;
  // recvl
  unsigned short int recvl;
  // iolen
  signed int iolen;
  // msg
  struct anonymous_28 *msg;
  // recvbuf
  struct anonymous_29 *recvbuf;
  // myrid
  unsigned short int myrid;
  // s_errno
  signed int s_errno;
};

struct in_pktinfo
{
  // ipi_ifindex
  signed int ipi_ifindex;
  // ipi_spec_dst
  struct in_addr ipi_spec_dst;
  // ipi_addr
  struct in_addr ipi_addr;
};

struct in6_pktinfo
{
  // ipi6_addr
  struct in6_addr ipi6_addr;
  // ipi6_ifindex
  unsigned int ipi6_ifindex;
};

union anonymous_67
{
  // pi4
  struct in_pktinfo pi4;
  // pi6
  struct in6_pktinfo pi6;
};

struct anonymous_69
{
  // addr
  union anonymous_68 addr;
  // pi
  union anonymous_67 pi;
  // sock
  signed int sock;
  // proto
  signed int proto;
  // len
  unsigned long int len;
  // buf
  unsigned char buf[0l];
};

struct anonymous_13
{
  // a
  struct in6_addr a;
  // mask
  struct in6_addr mask;
};

struct anonymous_11
{
  // a
  struct in_addr a;
  // mask
  struct in_addr mask;
};

struct anonymous_36
{
  // __unused
  unsigned short int __unused;
  // mtu
  unsigned short int mtu;
};

struct anonymous_29
{
  // id
  unsigned short int id;
  // rd
  unsigned int rd : 1;
  // tc
  unsigned int tc : 1;
  // aa
  unsigned int aa : 1;
  // opcode
  unsigned int opcode : 4;
  // qr
  unsigned int qr : 1;
  // rcode
  unsigned int rcode : 4;
  // cd
  unsigned int cd : 1;
  // ad
  unsigned int ad : 1;
  // z
  unsigned int z : 1;
  // ra
  unsigned int ra : 1;
  // qdcount
  unsigned short int qdcount;
  // ancount
  unsigned short int ancount;
  // nscount
  unsigned short int nscount;
  // arcount
  unsigned short int arcount;
} __attribute__ ((__packed__));

struct anonymous_35
{
  // id
  unsigned short int id;
  // sequence
  unsigned short int sequence;
};

struct anonymous_28
{
  // len
  unsigned short int len;
  // hdr
  struct anonymous_29 hdr;
} __attribute__ ((__packed__));

struct anonymous_7
{
  // port
  unsigned short int port;
  // uptest
  signed short int uptest;
  // timeout
  signed long int timeout;
  // interval
  signed long int interval;
  // ping_timeout
  signed long int ping_timeout;
  // scheme
  char scheme[32l];
  // uptest_cmd
  char *uptest_cmd;
  // uptest_usr
  char uptest_usr[21l];
  // interface
  char interface[16l];
  // device
  char device[16l];
  // query_test_name
  unsigned char *query_test_name;
  // label
  char *label;
  // purge_cache
  char purge_cache;
  // nocache
  char nocache;
  // lean_query
  char lean_query;
  // edns_query
  char edns_query;
  // is_proxy
  char is_proxy;
  // rootserver
  char rootserver;
  // rand_servers
  char rand_servers;
  // preset
  char preset;
  // rejectrecursively
  char rejectrecursively;
  // rejectpolicy
  signed short int rejectpolicy;
  // policy
  signed short int policy;
  // alist
  struct anonymous_8 *alist;
  // atup_a
  struct anonymous_19 *atup_a;
  // reject_a4
  struct anonymous_10 *reject_a4;
  // reject_a6
  struct anonymous_12 *reject_a6;
  // ping_a
  union anonymous_6 ping_a;
};

struct anonymous_70
{
  // qtype
  unsigned short int qtype;
  // qclass
  unsigned short int qclass;
  // query
  unsigned char query[0l];
};

struct anonymous_60
{
  // rdlen
  unsigned short int rdlen;
};

struct anonymous_71
{
  // tp
  unsigned short int tp;
  // dlen
  unsigned short int dlen;
  // nm
  unsigned char nm[0l];
};

struct anonymous_17
{
  // udpsize
  unsigned short int udpsize;
  // rcode
  unsigned short int rcode;
  // version
  unsigned short int version;
  // do_flg
  unsigned char do_flg;
};

struct anonymous_64
{
  // index
  unsigned int index;
  // s
  unsigned char s[0l];
};

struct anonymous_3
{
  // nel
  unsigned long int nel;
};

struct anonymous_30
{
  // nel
  unsigned long int nel;
  // elem
  unsigned char *elem[0l];
};

struct anonymous_8
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_9 elem[0l];
};

struct anonymous_16
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_0 elem[0l];
};

struct anonymous_19
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_20 elem[0l];
};

struct anonymous_4
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_5 elem[0l];
};

struct anonymous_12
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_13 elem[0l];
};

struct anonymous_14
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_15 elem[0l];
};

struct anonymous_10
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_11 elem[0l];
};

struct anonymous_18
{
  // nel
  unsigned long int nel;
  // elem
  struct anonymous_7 elem[0l];
};

struct anonymous_54
{
  // nel
  unsigned long int nel;
  // elem
  union anonymous_6 elem[0l];
};

struct anonymous_62
{
  // qlen
  unsigned char qlen;
  // num_rrs
  unsigned char num_rrs;
  // flags
  unsigned short int flags;
  // c_ns
  unsigned char c_ns;
  // c_soa
  unsigned char c_soa;
} __attribute__ ((__packed__));

struct anonymous_61
{
  // tp
  unsigned char tp;
  // num_rr
  unsigned char num_rr;
  // flags
  unsigned short int flags;
  // ttl
  signed long int ttl;
  // ts
  signed long int ts;
} __attribute__ ((__packed__));

union anonymous_42
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_43 *, void *);
};

union anonymous_25
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_37
{
  // icmp6_un_data32
  unsigned int icmp6_un_data32[1l];
  // icmp6_un_data16
  unsigned short int icmp6_un_data16[2l];
  // icmp6_un_data8
  unsigned char icmp6_un_data8[4l];
};

union anonymous_56
{
  // __data
  struct anonymous_55 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_34
{
  // echo
  struct anonymous_35 echo;
  // gateway
  unsigned int gateway;
  // frag
  struct anonymous_36 frag;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_33
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ip6_hdrctl
{
  // ip6_un1_flow
  unsigned int ip6_un1_flow;
  // ip6_un1_plen
  unsigned short int ip6_un1_plen;
  // ip6_un1_nxt
  unsigned char ip6_un1_nxt;
  // ip6_un1_hlim
  unsigned char ip6_un1_hlim;
};

union anonymous_38
{
  // ip6_un1
  struct ip6_hdrctl ip6_un1;
  // ip6_un2_vfc
  unsigned char ip6_un2_vfc;
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_26
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

union anonymous_39
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_23
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _dynamic_list_head
{
  // last
  unsigned long int last;
  // lastsz
  unsigned long int lastsz;
  // data
  char data[0l];
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct dns_hash_ent_s
{
  // next
  struct dns_hash_ent_s *next;
  // rhash
  unsigned long int rhash;
  // data
  struct anonymous_0 *data;
};

struct icmp6_filter
{
  // icmp6_filt
  unsigned int icmp6_filt[8l];
};

struct icmp6_hdr
{
  // icmp6_type
  unsigned char icmp6_type;
  // icmp6_code
  unsigned char icmp6_code;
  // icmp6_cksum
  unsigned short int icmp6_cksum;
  // icmp6_dataun
  union anonymous_37 icmp6_dataun;
};

struct icmp_filter
{
  // data
  unsigned int data;
};

struct icmphdr
{
  // type
  unsigned char type;
  // code
  unsigned char code;
  // checksum
  unsigned short int checksum;
  // un
  union anonymous_34 un;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_25 ifr_ifrn;
  // ifr_ifru
  union anonymous_26 ifr_ifru;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip6_hbh
{
  // ip6h_nxt
  unsigned char ip6h_nxt;
  // ip6h_len
  unsigned char ip6h_len;
};

struct ip6_hdr
{
  // ip6_ctlun
  union anonymous_38 ip6_ctlun;
  // ip6_src
  struct in6_addr ip6_src;
  // ip6_dst
  struct in6_addr ip6_dst;
};

struct iphdr
{
  // ihl
  unsigned int ihl : 4;
  // version
  unsigned int version : 4;
  // tos
  unsigned char tos;
  // tot_len
  unsigned short int tot_len;
  // id
  unsigned short int id;
  // frag_off
  unsigned short int frag_off;
  // ttl
  unsigned char ttl;
  // protocol
  unsigned char protocol;
  // check
  unsigned short int check;
  // saddr
  unsigned int saddr;
  // daddr
  unsigned int daddr;
};

struct llistnode_s
{
  // next
  struct llistnode_s *next;
  // data
  char *data[0l];
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct qhintnode_s
{
  // nm
  const unsigned char *nm;
  // tp
  signed int tp;
  // next
  struct qhintnode_s *next;
};

struct qstatnode_s
{
  // qa
  struct anonymous_4 *qa;
  // next
  struct qstatnode_s *next;
};

struct rejectlist_s
{
  // next
  struct rejectlist_s *next;
  // policy
  signed short int policy;
  // inherit
  signed short int inherit;
  // na4
  signed int na4;
  // na6
  signed int na6;
  // rdata
  struct anonymous_13 rdata[0l];
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct rr_b_s
{
  // next
  struct rr_b_s *next;
  // rdlen
  unsigned int rdlen;
  // data
  struct in6_addr data[0l];
};

struct rr_infos
{
  // class
  unsigned short int class;
  // excludes
  unsigned short int excludes;
};

struct rr_lent_s
{
  // next
  struct rr_lent_s *next;
  // prev
  struct rr_lent_s *prev;
  // rrset
  struct anonymous *rrset;
  // cent
  struct anonymous_0 *cent;
  // idx
  signed int idx;
};

struct rre_s
{
  // tp
  unsigned short int tp;
  // tsz
  unsigned short int tsz;
  // ttl
  unsigned int ttl;
  // tnm
  unsigned char tnm[0l];
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_42 __sigaction_handler;
  // sa_mask
  struct anonymous_41 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};


// ar_offs
// file dns_answer.c line 545
static const signed int ar_offs[6l] = { 0, 0, 0, 0, 2, 6 };
// ar_recs
// file dns_answer.c line 539
static const signed int ar_recs[6l] = { 2, 3, 4, 7, 15, 33 };
// attr_detached
// file thread.c line 41
union pthread_attr_t attr_detached;
// c_names
// file dns.c line 489
static const char * const c_names[4l] = { "IN", "CS", "CH", "HS" };
// cache_r_lock
// file cache.c line 165
static volatile signed int cache_r_lock = 0;
// cache_size
// file cache.c line 161
static volatile signed long int cache_size = (volatile signed long int)0;
// cache_w_lock
// file cache.c line 164
static volatile signed int cache_w_lock = 0;
// cachverid
// file cache.c line 46
static const char cachverid[4l] = { (const char)112, (const char)100, (const char)49, (const char)51 };
// cflgnames
// file cache.c line 2698
const char cflgnames[21l] = { (const char)78, (const char)69, (const char)71, (const char)76, (const char)79, (const char)67, (const char)65, (const char)85, (const char)84, (const char)78, (const char)79, (const char)67, (const char)65, (const char)68, (const char)68, (const char)78, (const char)79, (const char)80, (const char)82, (const char)84, (const char)83 };
// cmdline
// file main.c line 61
struct anonymous_31 cmdline = { .prefix=(char)0, .pidfile=0, .verbosity=0, .pdnsduser=0,
    .daemon=0, .debug=0, .stat_pipe=0, .notcp=0,
    .query_method=0 };
// cmdlineipv
// file main.c line 59
signed short int cmdlineipv = (signed short int)0;
// conf_file
// file main.c line 70
char *conf_file = "/etc/pdnsd.conf";
// const_dic
// file consts.c line 31
static const struct anonymous_32 const_dic[29l] = { { .name="auth", .val=22 }, { .name="default", .val=3 }, { .name="dev", .val=16 }, { .name="diald", .val=17 }, { .name="discover", .val=4 }, { .name="domain", .val=23 }, { .name="excluded", .val=19 }, { .name="exec", .val=7 }, { .name="fail", .val=24 }, { .name="false", .val=2 }, { .name="fqdn_only", .val=21 }, { .name="if", .val=6 }, { .name="included", .val=18 }, { .name="negate", .val=25 }, { .name="no", .val=2 }, { .name="none", .val=5 }, { .name="off", .val=2 }, { .name="on", .val=1 }, { .name="onquery", .val=10 }, { .name="ontimeout", .val=11 }, { .name="ping", .val=8 }, { .name="query", .val=9 }, { .name="simple_only", .val=20 }, { .name="tcp_only", .val=13 }, { .name="tcp_udp", .val=14 }, { .name="true", .val=1 }, { .name="udp_only", .val=12 }, { .name="udp_tcp", .val=15 }, { .name="yes", .val=1 } };
// const_names
// file consts.c line 64
static const char * const const_names[26l] = { "error", "on", "off", "default", "discover", "none", "if", "exec", "ping", "query", "onquery", "ontimeout", "udp_only", "tcp_only", "tcp_udp", "udp_tcp", "dev", "diald", "included", "excluded", "simple_only", "fqdn_only", "auth", "domain", "fail", "negate" };
// da_mem_errs
// file dns_answer.c line 75
static volatile unsigned long int da_mem_errs = (volatile unsigned long int)0;
// da_misc_errs
// file dns_answer.c line 78
static volatile unsigned long int da_misc_errs = (volatile unsigned long int)0;
// da_tcp_errs
// file dns_answer.c line 73
static volatile unsigned long int da_tcp_errs = (volatile unsigned long int)0;
// da_thrd_errs
// file dns_answer.c line 76
static volatile unsigned long int da_thrd_errs = (volatile unsigned long int)0;
// da_udp_errs
// file dns_answer.c line 74
static volatile unsigned long int da_udp_errs = (volatile unsigned long int)0;
// dbg_file
// file main.c line 65
struct _IO_FILE *dbg_file = (struct _IO_FILE *)(void *)0;
// debug_p
// file main.c line 52
signed short int debug_p = (signed short int)0;
// dflgnames
// file cache.c line 2699
const char dflgnames[15l] = { (const char)78, (const char)69, (const char)71, (const char)76, (const char)79, (const char)67, (const char)65, (const char)85, (const char)84, (const char)78, (const char)79, (const char)67, (const char)87, (const char)76, (const char)68 };
// dropped
// file dns_answer.c line 82
static volatile unsigned long int dropped = (volatile unsigned long int)0;
// e_names
// file dns.c line 512
static const char * const e_names[17l] = { "no error", "query format error", "server failed", "non-existent domain", "not supported", "query refused", "name exists when it should not", "RR set exists when it should not", "RR set that should exist does not", "server not authoritative for zone", "name not contained in zone", "11", "12", "13", "14", "15", "bad OPT version" };
// ent_num
// file cache.c line 162
static volatile signed long int ent_num = (volatile signed long int)0;
// global
// file conff.c line 40
struct anonymous_21 global = { .perm_cache=(signed long int)2048, .cache_dir=(char *)(void *)0, .pidfile=(char *)(void *)0,
    .port=53, .a={ .ipv4={ .s_addr=(unsigned int)0x00000000 } },
    .out_a={ .ipv4={ .s_addr=(unsigned int)0x00000000 } },
    .ipv4_6_prefix={ .__in6_u={ .__u6_addr8={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 } } },
    .max_ttl=(signed long int)604800,
    .min_ttl=(signed long int)120, .neg_ttl=(signed long int)900,
    .neg_rrs_pol=(signed short int)3, .neg_domain_pol=(signed short int)22,
    .verbosity=(signed short int)0,
    .run_as={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .daemon=(char)0,
    .debug=(char)0, .stat_pipe=(char)0, .notcp=(char)0,
    .strict_suid=(char)1, .use_nss=(char)1,
    .paranoid=(char)0, .lndown_kluge=(char)0,
    .onquery=(char)0, .rnd_recs=(char)1,
    .ctl_perms=0600, .scheme_file=(char *)(void *)0, .proc_limit=40,
    .procq_limit=60, .tcp_qtimeout=(signed long int)30, .timeout=(signed long int)0,
    .par_queries=2, .query_method=12,
    .query_port_start=1024, .query_port_end=65535,
    .udpbufsize=1024, .deleg_only_zones=(struct anonymous_30 *)(void *)0 };
// global_options
// file conf-keywords.h line 127
static const struct anonymous_32 global_options[39l] = { { .name="cache_dir", .val=8 }, { .name="ctl_perms", .val=30 }, { .name="daemon", .val=22 }, { .name="debug", .val=29 }, { .name="delegation_only", .val=42 }, { .name="ignore_cd", .val=20 }, { .name="interface", .val=10 }, { .name="ipv4_6_prefix", .val=28 }, { .name="linkdown_kluge", .val=13 }, { .name="max_ttl", .val=14 }, { .name="min_ttl", .val=15 }, { .name="neg_domain_pol", .val=38 }, { .name="neg_rrs_pol", .val=37 }, { .name="neg_ttl", .val=36 }, { .name="outgoing_ip", .val=11 }, { .name="outside_interface", .val=11 }, { .name="par_queries", .val=34 }, { .name="paranoid", .val=19 }, { .name="perm_cache", .val=7 }, { .name="pid_file", .val=24 }, { .name="proc_limit", .val=31 }, { .name="procq_limit", .val=32 }, { .name="query_method", .val=26 }, { .name="query_port_end", .val=40 }, { .name="query_port_start", .val=39 }, { .name="randomize_recs", .val=35 }, { .name="run_as", .val=16 }, { .name="run_ipv4", .val=27 }, { .name="scheme_file", .val=12 }, { .name="server_ip", .val=10 }, { .name="server_port", .val=9 }, { .name="status_ctl", .val=21 }, { .name="strict_setuid", .val=17 }, { .name="tcp_qtimeout", .val=33 }, { .name="tcp_server", .val=23 }, { .name="timeout", .val=47 }, { .name="udpbufsize", .val=41 }, { .name="use_nss", .val=18 }, { .name="verbosity", .val=25 } };
// hash_buckets
// file hash.c line 50
struct dns_hash_ent_s *hash_buckets[1024l];
// help_message
// file main.c line 93
static const char help_message[1711l] = { '\n', '\n', 'U', 's', 'a', 'g', 'e', ':', ' ', 'p', 'd', 'n', 's', 'd', ' ', '[', '-', 'h', ']', ' ', '[', '-', 'V', ']', ' ', '[', '-', 's', ']', ' ', '[', '-', 'd', ']', ' ', '[', '-', 'g', ']', ' ', '[', '-', 't', ']', ' ', '[', '-', 'p', ' ', 'f', 'i', 'l', 'e', ']', ' ', '[', '-', 'v', 'n', ']', ' ', '[', '-', 'm', 'x', 'x', ']', ' ', '[', '-', 'c', ' ', 'f', 'i', 'l', 'e', ']', ' ', '[', '-', '4', ']', ' ', '[', '-', '6', ']', ' ', '[', '-', 'i', ' ', 'p', 'r', 'e', 'f', 'i', 'x', ']', ' ', '[', '-', 'a', ']', '\n', '\n', 'O', 'p', 't', 'i', 'o', 'n', 's', ':', '\n', '-', 'h', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'h', 'e', 'l', 'p', '\t', '\t', 'p', 'r', 'i', 'n', 't', ' ', 't', 'h', 'i', 's', ' ', 'h', 'e', 'l', 'p', ' ', 'p', 'a', 'g', 'e', ' ', 'a', 'n', 'd', ' ', 'e', 'x', 'i', 't', '.', '\n', '-', 'V', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'v', 'e', 'r', 's', 'i', 'o', 'n', '\t', 'p', 'r', 'i', 'n', 't', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'a', 'n', 'd', ' ', 'l', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'n', 'd', ' ', 'e', 'x', 'i', 't', '.', '\n', '-', '-', 'p', 'd', 'n', 's', 'd', '-', 'u', 's', 'e', 'r', '\t', 'p', 'r', 'i', 'n', 't', ' ', 't', 'h', 'e', ' ', 'u', 's', 'e', 'r', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'w', 'i', 'l', 'l', ' ', 'r', 'u', 'n', ' ', 'a', 's', ' ', 'a', 'n', 'd', ' ', 'e', 'x', 'i', 't', '.', '\n', '-', 's', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 's', 't', 'a', 't', 'u', 's', '\t', 'E', 'n', 'a', 'b', 'l', 'e', ' ', 's', 't', 'a', 't', 'u', 's', ' ', 'c', 'o', 'n', 't', 'r', 'o', 'l', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '.', '\n', '-', 'd', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'd', 'a', 'e', 'm', 'o', 'n', '\t', 'S', 't', 'a', 'r', 't', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'i', 'n', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'm', 'o', 'd', 'e', ' ', '(', 'a', 's', ' ', 'b', 'a', 'c', 'k', 'g', 'r', 'o', 'u', 'n', 'd', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', '.', ')', '\n', '-', 'g', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'd', 'e', 'b', 'u', 'g', '\t', '\t', 'P', 'r', 'i', 'n', 't', ' ', 's', 'o', 'm', 'e', ' ', 'd', 'e', 'b', 'u', 'g', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', 's', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's', 'o', 'l', 'e', ' ', 'o', 'r', ' ', 't', 'o', ' ', 't', 'h', 'e', '\n', '\t', '\t', 'f', 'i', 'l', 'e', ' ', 'p', 'd', 'n', 's', 'd', '.', 'd', 'e', 'b', 'u', 'g', ' ', 'i', 'n', ' ', 'y', 'o', 'u', 'r', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', '(', 'i', 'n', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'm', 'o', 'd', 'e', ')', '.', '\n', '-', 't', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 't', 'c', 'p', '\t', '\t', 'E', 'n', 'a', 'b', 'l', 'e', 's', ' ', 't', 'h', 'e', ' ', 'T', 'C', 'P', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 't', 'h', 'r', 'e', 'a', 'd', '.', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'w', 'i', 'l', 'l', ' ', 't', 'h', 'e', 'n', ' ', 's', 'e', 'r', 'v', 'e', '\n', '\t', '\t', 'T', 'C', 'P', ' ', 'a', 'n', 'd', ' ', 'U', 'D', 'P', ' ', 'q', 'u', 'e', 'r', 'i', 'e', 's', '.', '\n', '-', 'p', '\t', '\t', 'W', 'r', 'i', 't', 'e', 's', ' ', 't', 'h', 'e', ' ', 'p', 'i', 'd', ' ', 't', 'h', 'e', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'r', 'u', 'n', 's', ' ', 'a', 's', ' ', 't', 'o', ' ', 'a', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', '.', '\n', '\t', '\t', 'W', 'o', 'r', 'k', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'i', 'n', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'm', 'o', 'd', 'e', '.', '\n', '-', 'v', 'n', '\t', '\t', 's', 'e', 't', 's', ' ', 't', 'h', 'e', ' ', 'v', 'e', 'r', 'b', 'o', 's', 'i', 't', 'y', ' ', 'o', 'f', ' ', 'p', 'd', 'n', 's', 'd', '.', ' ', 'n', ' ', 'i', 's', ' ', 'a', ' ', 'n', 'u', 'm', 'e', 'r', 'i', 'c', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f', 'r', 'o', 'm', ' ', '0', '\n', '\t', '\t', '(', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ')', ' ', 't', 'o', ' ', '9', ' ', '(', 'm', 'a', 'n', 'y', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'd', 'e', 'b', 'u', 'g', 'g', 'i', 'n', 'g', ')', '.', '\n', '\t', '\t', 'U', 's', 'e', ' ', 'l', 'i', 'k', 'e', ' ', '-', 'v', '2', '\n', '-', 'm', 'x', 'x', '\t', '\t', 's', 'e', 't', 's', ' ', 't', 'h', 'e', ' ', 'q', 'u', 'e', 'r', 'y', ' ', 'm', 'e', 't', 'h', 'o', 'd', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'u', 's', 'e', 's', '.', ' ', 'P', 'o', 's', 's', 'i', 'b', 'l', 'e', ' ', 'v', 'a', 'l', 'u', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'x', 'x', ' ', 'a', 'r', 'e', ':', '\n', '\t', '\t', 'u', 'o', ' ', '(', 'U', 'D', 'P', ' ', 'o', 'n', 'l', 'y', ')', ',', ' ', 't', 'o', ' ', '(', 'T', 'C', 'P', ' ', 'o', 'n', 'l', 'y', ')', ',', ' ', 't', 'u', ' ', '(', 'T', 'C', 'P', ' ', 'o', 'r', ',', ' ', 'i', 'f', ' ', 't', 'h', 'e', ' ', 's', 'e', 'r', 'v', 'e', 'r', '\n', '\t', '\t', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 't', 'h', 'i', 's', ',', ' ', 'U', 'D', 'P', ')', ' ', 'a', 'n', 'd', ' ', 'u', 't', ' ', '(', 'U', 'D', 'P', ' ', 'a', 'n', 'd', ',', ' ', 'i', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'p', 'l', 'y', ' ', 'w', 'a', 's', '\n', '\t', '\t', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', 'd', ',', ' ', 'T', 'C', 'P', ')', '.', ' ', 'U', 's', 'e', ' ', 'l', 'i', 'k', 'e', ' ', '-', 'm', 'u', 'o', '.', ' ', 'P', 'r', 'e', 's', 'e', 't', ':', ' ', '-', 'm', 'u', 'o', '\n', '-', 'c', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'c', 'o', 'n', 'f', 'i', 'g', '-', 'f', 'i', 'l', 'e', '\t', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 's', ' ', 't', 'h', 'e', ' ', 'f', 'i', 'l', 'e', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'i', 's', ' ', 'r', 'e', 'a', 'd', ' ', 'f', 'r', 'o', 'm', '.', '\n', '\t', '\t', 'D', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'i', 's', ' ', '/', 'e', 't', 'c', '/', 'p', 'd', 'n', 's', 'd', '.', 'c', 'o', 'n', 'f', '\n', '-', '4', '\t', '\t', 's', 'w', 'i', 't', 'c', 'h', 'e', 's', ' ', 't', 'o', ' ', 'I', 'P', 'v', '4', ' ', 'm', 'o', 'd', 'e', '.', '\n', '\t', '\t', 'O', 'n', ' ', 'b', 'y', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', '.', '\n', '-', '6', '\t', '\t', 's', 'w', 'i', 't', 'c', 'h', 'e', 's', ' ', 't', 'o', ' ', 'I', 'P', 'v', '6', ' ', 'm', 'o', 'd', 'e', '.', '\n', '\t', '\t', 'O', 'f', 'f', ' ', 'b', 'y', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', '.', '\n', '-', 'i', '\t', '\t', '-', '-', 'o', 'r', '-', '-', '\n', '-', '-', 'i', 'p', 'v', '4', '_', '6', '_', 'p', 'r', 'e', 'f', 'i', 'x', '\t', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 's', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'e', 'f', 'i', 'x', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'u', 's', 'e', 's', ' ', 't', 'o', ' ', 'm', 'a', 'p', ' ', 'I', 'P', 'v', '4', ' ', 't', 'o', ' ', 'I', 'P', 'v', '6', '\n', '\t', '\t', 'a', 'd', 'd', 'r', 'e', 's', 's', 'e', 's', '.', ' ', 'M', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd', ' ', 'I', 'P', 'v', '6', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', '.', '\n', '\t', '\t', 'D', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'i', 's', ' ', ':', ':', 'f', 'f', 'f', 'f', ':', '0', '.', '0', '.', '0', '.', '0', '\n', '-', 'a', '\t', '\t', 'W', 'i', 't', 'h', ' ', 't', 'h', 'i', 's', ' ', 'o', 'p', 't', 'i', 'o', 'n', ',', ' ', 'p', 'd', 'n', 's', 'd', ' ', 'w', 'i', 'l', 'l', ' ', 't', 'r', 'y', ' ', 't', 'o', ' ', 'd', 'e', 't', 'e', 'c', 't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', 'a', 'l', 'l', 'y', ' ', 'i', 'f', '\n', '\t', '\t', 't', 'h', 'e', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 's', ' ', 'I', 'P', 'v', '6', ',', ' ', 'a', 'n', 'd', ' ', 'r', 'e', 'v', 'e', 'r', 't', ' ', 't', 'o', ' ', 'I', 'P', 'v', '4', ' ', 'o', 't', 'h', 'e', 'r', 'w', 'i', 's', 'e', '.', '\n', '\n', '\n', '"', 'n', 'o', '"', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 'p', 'r', 'e', 'p', 'e', 'n', 'd', 'e', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', '-', '-', 's', 't', 'a', 't', 'u', 's', ',', ' ', '-', '-', 'd', 'a', 'e', 'm', 'o', 'n', ',', ' ', '-', '-', 'd', 'e', 'b', 'u', 'g', ' ', 'a', 'n', 'd', ' ', '-', '-', 't', 'c', 'p', '\n', 'o', 'p', 't', 'i', 'o', 'n', 's', ' ', '(', 'e', '.', 'g', '.', ' ', '-', '-', 'n', 'o', 't', 'c', 'p', ')', ' ', 't', 'o', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'e', ' ', 't', 'h', 'e', 'i', 'r', ' ', 'e', 'f', 'f', 'e', 'c', 't', '.', '\n', 0 };
// icmp_errs
// file icmp.c line 69
static volatile unsigned long int icmp_errs = (volatile unsigned long int)0;
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// include_options
// file conf-keywords.h line 229
static const struct anonymous_32 include_options[1l] = { { .name="file", .val=81 } };
// info_message
// file main.c line 74
static const char info_message[778l] = { 'p', 'd', 'n', 's', 'd', ' ', '-', ' ', 'd', 'n', 's', ' ', 'p', 'r', 'o', 'x', 'y', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ',', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', '1', '.', '2', '.', '9', 'a', '-', 'p', 'a', 'r', '\n', '\n', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '(', 'C', ')', ' ', '2', '0', '0', '0', ',', ' ', '2', '0', '0', '1', ' ', 'T', 'h', 'o', 'm', 'a', 's', ' ', 'M', 'o', 'e', 's', 't', 'l', '\n', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '(', 'C', ')', ' ', '2', '0', '0', '2', ',', ' ', '2', '0', '0', '3', ',', ' ', '2', '0', '0', '4', ',', ' ', '2', '0', '0', '5', ',', ' ', '2', '0', '0', '6', ',', ' ', '2', '0', '0', '7', ',', ' ', '2', '0', '0', '8', ',', ' ', '2', '0', '1', '0', ' ', 'P', 'a', 'u', 'l', ' ', 'A', '.', ' ', 'R', 'o', 'm', 'b', 'o', 'u', 't', 's', '\n', '\n', 'p', 'd', 'n', 's', 'd', ' ', 'i', 's', ' ', 'f', 'r', 'e', 'e', ' ', 's', 'o', 'f', 't', 'w', 'a', 'r', 'e', ';', ' ', 'y', 'o', 'u', ' ', 'c', 'a', 'n', ' ', 'r', 'e', 'd', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 'i', 't', ' ', 'a', 'n', 'd', '/', 'o', 'r', ' ', 'm', 'o', 'd', 'i', 'f', 'y', '\n', 'i', 't', ' ', 'u', 'n', 'd', 'e', 'r', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'a', 's', ' ', 'p', 'u', 'b', 'l', 'i', 's', 'h', 'e', 'd', ' ', 'b', 'y', '\n', 't', 'h', 'e', ' ', 'F', 'r', 'e', 'e', ' ', 'S', 'o', 'f', 't', 'w', 'a', 'r', 'e', ' ', 'F', 'o', 'u', 'n', 'd', 'a', 't', 'i', 'o', 'n', ';', ' ', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', '3', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ',', ' ', 'o', 'r', '\n', '(', 'a', 't', ' ', 'y', 'o', 'u', 'r', ' ', 'o', 'p', 't', 'i', 'o', 'n', ')', ' ', 'a', 'n', 'y', ' ', 'l', 'a', 't', 'e', 'r', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', '.', '\n', '\n', 'p', 'd', 'n', 's', 'd', ' ', 'i', 's', ' ', 'd', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'h', 'o', 'p', 'e', ' ', 't', 'h', 'a', 't', ' ', 'i', 't', ' ', 'w', 'i', 'l', 'l', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'f', 'u', 'l', ',', '\n', 'b', 'u', 't', ' ', 'W', 'I', 'T', 'H', 'O', 'U', 'T', ' ', 'A', 'N', 'Y', ' ', 'W', 'A', 'R', 'R', 'A', 'N', 'T', 'Y', ';', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'e', 'v', 'e', 'n', ' ', 't', 'h', 'e', ' ', 'i', 'm', 'p', 'l', 'i', 'e', 'd', ' ', 'w', 'a', 'r', 'r', 'a', 'n', 't', 'y', ' ', 'o', 'f', '\n', 'M', 'E', 'R', 'C', 'H', 'A', 'N', 'T', 'A', 'B', 'I', 'L', 'I', 'T', 'Y', ' ', 'o', 'r', ' ', 'F', 'I', 'T', 'N', 'E', 'S', 'S', ' ', 'F', 'O', 'R', ' ', 'A', ' ', 'P', 'A', 'R', 'T', 'I', 'C', 'U', 'L', 'A', 'R', ' ', 'P', 'U', 'R', 'P', 'O', 'S', 'E', '.', ' ', ' ', 'S', 'e', 'e', ' ', 't', 'h', 'e', '\n', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', ' ', 'f', 'o', 'r', ' ', 'm', 'o', 'r', 'e', ' ', 'd', 'e', 't', 'a', 'i', 'l', 's', '.', '\n', '\n', 'Y', 'o', 'u', ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'h', 'a', 'v', 'e', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', ' ', 'a', ' ', 'c', 'o', 'p', 'y', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'G', 'N', 'U', ' ', 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'L', 'i', 'c', 'e', 'n', 's', 'e', '\n', 'a', 'l', 'o', 'n', 'g', ' ', 'w', 'i', 't', 'h', ' ', 'p', 'd', 's', 'n', 'd', ';', ' ', 's', 'e', 'e', ' ', 't', 'h', 'e', ' ', 'f', 'i', 'l', 'e', ' ', 'C', 'O', 'P', 'Y', 'I', 'N', 'G', '.', ' ', ' ', 'I', 'f', ' ', 'n', 'o', 't', ',', ' ', 's', 'e', 'e', '\n', '<', 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'g', 'n', 'u', '.', 'o', 'r', 'g', '/', 'l', 'i', 'c', 'e', 'n', 's', 'e', 's', '/', '>', '.', '\n', 0 };
// init_uid
// file main.c line 63
unsigned int init_uid;
// insert_sort
// file cache.c line 199
static signed short int insert_sort = (signed short int)1;
// isdn_errs
// file netdev.c line 96
static volatile unsigned long int isdn_errs = (volatile unsigned long int)0;
// lock_mutex
// file cache.c line 167
union anonymous_33 lock_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// loglock
// file error.c line 36
union anonymous_33 loglock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// main_thrid
// file main.c line 62
unsigned long int main_thrid;
// neg_options
// file conf-keywords.h line 234
static const struct anonymous_32 neg_options[3l] = { { .name="name", .val=77 }, { .name="ttl", .val=79 }, { .name="types", .val=80 } };
// ping6_isocket
// file icmp.c line 76
volatile signed int ping6_isocket = -1;
// ping_isocket
// file icmp.c line 74
volatile signed int ping_isocket = -1;
// poll_errs
// file dns_query.c line 159
static volatile unsigned long int poll_errs = (volatile unsigned long int)0;
// poweroften
// file rr_types.c line 53
static const unsigned int poweroften[8l] = { (const unsigned int)1, (const unsigned int)10, (const unsigned int)100, (const unsigned int)1000, (const unsigned int)10000, (const unsigned int)100000, (const unsigned int)1000000, (const unsigned int)10000000 };
// proc_lock
// file dns_answer.c line 84
static union anonymous_33 proc_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// procs
// file dns_answer.c line 80
static volatile signed int procs = 0;
// qprocs
// file dns_answer.c line 81
static volatile signed int qprocs = 0;
// qt_names
// file dns.c line 490
static const char * const qt_names[5l] = { "IXFR", "AXFR", "MAILB", "MAILA", "*" };
// r_cond
// file cache.c line 178
union anonymous_56 r_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// r_pend
// file cache.c line 181
static volatile signed int r_pend = 0;
// r_susp
// file cache.c line 183
static volatile signed int r_susp = 0;
// retest_flag
// file servers.c line 64
static signed short int retest_flag = (signed short int)0;
// rr_info
// file rr_types.h line 482
struct rr_infos rr_info[47l] = { { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)1, .excludes=(unsigned short int)(2 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)8, .excludes=(unsigned short int)(1 | 2) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)8, .excludes=(unsigned short int)(1 | 2) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)2, .excludes=(unsigned short int)(1 | 8) },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 },
    { .class=(unsigned short int)4, .excludes=(unsigned short int)0 } };
// rr_options
// file conf-keywords.h line 202
static const struct anonymous_32 rr_options[13l] = { { .name="a", .val=70 }, { .name="authrec", .val=83 }, { .name="cname", .val=74 }, { .name="mx", .val=72 }, { .name="name", .val=77 }, { .name="ns", .val=78 }, { .name="owner", .val=78 }, { .name="ptr", .val=71 }, { .name="reverse", .val=84 }, { .name="soa", .val=73 }, { .name="spf", .val=76 }, { .name="ttl", .val=79 }, { .name="txt", .val=75 } };
// rrcachiterlist
// file rr_types.h line 184
const unsigned short int rrcachiterlist[47l] = { (const unsigned short int)1, (const unsigned short int)2, (const unsigned short int)3, (const unsigned short int)4, (const unsigned short int)5, (const unsigned short int)6, (const unsigned short int)7, (const unsigned short int)8, (const unsigned short int)9, (const unsigned short int)10, (const unsigned short int)11, (const unsigned short int)12, (const unsigned short int)13, (const unsigned short int)14, (const unsigned short int)15, (const unsigned short int)16, (const unsigned short int)17, (const unsigned short int)18, (const unsigned short int)19, (const unsigned short int)20, (const unsigned short int)21, (const unsigned short int)22, (const unsigned short int)23, (const unsigned short int)24, (const unsigned short int)25, (const unsigned short int)26, (const unsigned short int)27, (const unsigned short int)28, (const unsigned short int)29, (const unsigned short int)30, (const unsigned short int)31, (const unsigned short int)32, (const unsigned short int)33, (const unsigned short int)34, (const unsigned short int)35, (const unsigned short int)36, (const unsigned short int)37, (const unsigned short int)42, (const unsigned short int)43, (const unsigned short int)44, (const unsigned short int)45, (const unsigned short int)46, (const unsigned short int)47, (const unsigned short int)48, (const unsigned short int)49, (const unsigned short int)50, (const unsigned short int)51 };
// rrlkuptab
// file rr_types.h line 111
const unsigned short int rrlkuptab[51l] = { (const unsigned short int)0, (const unsigned short int)1, (const unsigned short int)8, (const unsigned short int)9, (const unsigned short int)2, (const unsigned short int)3, (const unsigned short int)10, (const unsigned short int)11, (const unsigned short int)12, (const unsigned short int)13, (const unsigned short int)14, (const unsigned short int)4, (const unsigned short int)15, (const unsigned short int)16, (const unsigned short int)5, (const unsigned short int)6, (const unsigned short int)17, (const unsigned short int)18, (const unsigned short int)19, (const unsigned short int)20, (const unsigned short int)21, (const unsigned short int)22, (const unsigned short int)23, (const unsigned short int)24, (const unsigned short int)25, (const unsigned short int)26, (const unsigned short int)27, (const unsigned short int)7, (const unsigned short int)28, (const unsigned short int)29, (const unsigned short int)30, (const unsigned short int)31, (const unsigned short int)32, (const unsigned short int)33, (const unsigned short int)34, (const unsigned short int)35, (const unsigned short int)36, (const unsigned short int)47, (const unsigned short int)48, (const unsigned short int)49, (const unsigned short int)50, (const unsigned short int)37, (const unsigned short int)38, (const unsigned short int)39, (const unsigned short int)40, (const unsigned short int)41, (const unsigned short int)42, (const unsigned short int)43, (const unsigned short int)44, (const unsigned short int)45, (const unsigned short int)46 };
// rrmuiterlist
// file rr_types.h line 169
const unsigned short int rrmuiterlist[8l] = { (const unsigned short int)1, (const unsigned short int)2, (const unsigned short int)5, (const unsigned short int)6, (const unsigned short int)12, (const unsigned short int)15, (const unsigned short int)16, (const unsigned short int)28 };
// rrnames
// file rr_types.h line 399
const char * const rrnames[51l] = { "A", "NS", "MD", "MF", "CNAME", "SOA", "MB", "MG", "MR", "NULL", "WKS", "PTR", "HINFO", "MINFO", "MX", "TXT", "RP", "AFSDB", "X25", "ISDN", "RT", "NSAP", "NSAP_PTR", "SIG", "KEY", "PX", "GPOS", "AAAA", "LOC", "NXT", "EID", "NIMLOC", "SRV", "ATMA", "NAPTR", "KX", "CERT", "A6", "DNAME", "SINK", "OPT", "APL", "DS", "SSHFP", "IPSECKEY", "RRSIG", "NSEC", "DNSKEY", "DHCID", "NSEC3", "NSEC3PARAM" };
// rrset_l
// file cache.c line 154
static struct rr_lent_s *rrset_l = (struct rr_lent_s *)(void *)0;
// rrset_l_tail
// file cache.c line 155
static struct rr_lent_s *rrset_l_tail = (struct rr_lent_s *)(void *)0;
// run_ipv4
// file main.c line 58
signed short int run_ipv4 = (signed short int)1;
// rw_cond
// file cache.c line 177
union anonymous_56 rw_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// rw_pend
// file cache.c line 182
static volatile signed int rw_pend = 0;
// schm
// file servers.c line 66
static char schm[32l];
// section_headers
// file conf-keywords.h line 117
static const struct anonymous_32 section_headers[6l] = { { .name="global", .val=1 }, { .name="include", .val=6 }, { .name="neg", .val=4 }, { .name="rr", .val=3 }, { .name="server", .val=2 }, { .name="source", .val=5 } };
// serv_presets
// file conff.c line 81
struct anonymous_7 serv_presets = { .port=(unsigned short int)53, .uptest=(signed short int)5, .timeout=(signed long int)120,
    .interval=(signed long int)900, .ping_timeout=(signed long int)600,
    .scheme={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .uptest_cmd=(char *)(void *)0,
    .uptest_usr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .interface={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .device={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .query_test_name=(unsigned char *)(void *)0,
    .label=(char *)(void *)0,
    .purge_cache=(char)0, .nocache=(char)0,
    .lean_query=(char)1, .edns_query=(char)0,
    .is_proxy=(char)0, .rootserver=(char)0,
    .rand_servers=(char)0, .preset=(char)1,
    .rejectrecursively=(char)0, .rejectpolicy=(signed short int)24,
    .policy=(signed short int)18, .alist=(struct anonymous_8 *)(void *)0,
    .atup_a=(struct anonymous_19 *)(void *)0,
    .reject_a4=(struct anonymous_10 *)(void *)0,
    .reject_a6=(struct anonymous_12 *)(void *)0,
    .ping_a={ .ipv4={ .s_addr=(unsigned int)0x00000000 } } };
// server_data_cond
// file servers.c line 57
static union anonymous_56 server_data_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// server_data_users
// file servers.c line 59
static signed int server_data_users = 0;
// server_options
// file conf-keywords.h line 170
static const struct anonymous_32 server_options[28l] = { { .name="caching", .val=56 }, { .name="device", .val=54 }, { .name="edns_query", .val=58 }, { .name="exclude", .val=64 }, { .name="file", .val=81 }, { .name="include", .val=63 }, { .name="interface", .val=53 }, { .name="interval", .val=52 }, { .name="ip", .val=43 }, { .name="label", .val=69 }, { .name="lean_query", .val=57 }, { .name="ping_ip", .val=49 }, { .name="ping_timeout", .val=48 }, { .name="policy", .val=65 }, { .name="port", .val=44 }, { .name="preset", .val=59 }, { .name="proxy_only", .val=60 }, { .name="purge_cache", .val=55 }, { .name="query_test_name", .val=51 }, { .name="randomize_servers", .val=62 }, { .name="reject", .val=66 }, { .name="reject_policy", .val=67 }, { .name="reject_recursively", .val=68 },
    { .name="root_server", .val=61 }, { .name="scheme", .val=45 }, { .name="timeout", .val=47 }, { .name="uptest", .val=46 }, { .name="uptest_cmd", .val=50 } };
// server_status_ping
// file servers.c line 59
static signed int server_status_ping = 0;
// server_test_cond
// file servers.c line 58
static union anonymous_56 server_test_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// servers
// file conff.c line 114
struct anonymous_18 *servers = (struct anonymous_18 *)(void *)0;
// servers_lock
// file servers.c line 56
static union anonymous_33 servers_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// servstat_thrid
// file main.c line 62
unsigned long int servstat_thrid;
// signal_interrupt
// file servers.c line 61
volatile signed int signal_interrupt = 0;
// sigs_msk
// file main.c line 69
struct anonymous_41 sigs_msk;
// sock_path
// file status.c line 56
char *sock_path = (char *)(void *)0;
// socketopen_errs
// file netdev.c line 86
static volatile unsigned long int socketopen_errs = (volatile unsigned long int)0;
// source_options
// file conf-keywords.h line 219
static const struct anonymous_32 source_options[6l] = { { .name="authrec", .val=83 }, { .name="file", .val=81 }, { .name="ns", .val=78 }, { .name="owner", .val=78 }, { .name="serve_aliases", .val=82 }, { .name="ttl", .val=79 } };
// spawned
// file dns_answer.c line 82
static volatile unsigned long int spawned = (volatile unsigned long int)0;
// stat_pipe
// file main.c line 54
signed short int stat_pipe = (signed short int)0;
// stat_sock
// file status.c line 57
signed int stat_sock;
// statsock_thrid
// file main.c line 62
unsigned long int statsock_thrid;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tcp_socket
// file main.c line 67
volatile signed int tcp_socket = -1;
// tcps_thrid
// file main.c line 62
unsigned long int tcps_thrid;
// thrid_cnt
// file dns_answer.c line 83
static volatile unsigned int thrid_cnt = (volatile unsigned int)0;
// thrid_key
// file thread.c line 43
unsigned int thrid_key;
// udp_socket
// file main.c line 68
volatile signed int udp_socket = -1;
// udps_thrid
// file main.c line 62
unsigned long int udps_thrid;
// use_cache_lock
// file cache.c line 193
volatile signed short int use_cache_lock = (volatile signed short int)0;
// use_log_lock
// file error.c line 37
volatile signed short int use_log_lock = (volatile signed short int)0;

// SET_PDNSD_A2
// file ipvers.h line 260
static inline void SET_PDNSD_A2(struct anonymous_15 *a2, union anonymous_6 *a)
{
  if(!(run_ipv4 == 0))
    a2->ipv4 = a->ipv4;

  else
  {
    a2->ipv6 = a->ipv6;
    a2->ipv4.s_addr = (unsigned int)0x00000000;
  }
}

// SET_PDNSD_A2_link1
// file ipvers.h line 260
static inline void SET_PDNSD_A2_link1(struct anonymous_15 *a2_link1, union anonymous_6 *a_link1)
{
  if(!(run_ipv4 == 0))
    a2_link1->ipv4 = a_link1->ipv4;

  else
  {
    a2_link1->ipv6 = a_link1->ipv6;
    a2_link1->ipv4.s_addr = (unsigned int)0x00000000;
  }
}

// a2ptrstr
// file dns.c line 306
signed int a2ptrstr(union anonymous_6 *a, signed int tp, unsigned char *buf)
{
  if(tp == 1)
  {
    unsigned char *p = (unsigned char *)&a->ipv4.s_addr;
    signed int n;
    n=snprintf((char *)buf, (unsigned long int)256, "%u.%u.%u.%u.in-addr.arpa.", p[(signed long int)3], p[(signed long int)2], p[(signed long int)1], p[(signed long int)0]);
    if(n >= 256 || !(n >= 0))
      return 0;

  }

  else
    if(tp == 28)
    {
      unsigned char *a2ptrstr__1__2__p = (unsigned char *)&a->ipv6;
      signed int i;
      signed int offs = 0;
      i = 15;
      for( ; i >= 0; i = i - 1)
      {
        unsigned char bt = a2ptrstr__1__2__p[(signed long int)i];
        signed int a2ptrstr__1__2__1__1__n;
        a2ptrstr__1__2__1__1__n=snprintf((char *)(buf + (signed long int)offs), (unsigned long int)(256 - offs), "%x.%x.", (signed int)bt & 0xf, (signed int)bt >> 4 & 0xf);
        if(!(a2ptrstr__1__2__1__1__n >= 0))
          return 0;

        offs = offs + a2ptrstr__1__2__1__1__n;
        if(offs >= 256)
          return 0;

      }
      signed int return_value_strncp_1;
      return_value_strncp_1=strncp_link1((char *)(buf + (signed long int)offs), "ip6.arpa.", (unsigned long int)(256 - offs));
      if(return_value_strncp_1 == 0)
        return 0;

    }

    else
      return 0;
  return 1;
}

// add_additional_a
// file dns_answer.c line 715
static signed int add_additional_a(struct anonymous_28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, signed long int queryts, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva)
{
  struct anonymous_0 *ae;
  signed int retval = 1;
  ae=lookup_cache(rhn, (signed int *)(void *)0);
  signed long int return_value_ans_ttl_2;
  signed int return_value_add_additional_rrs_3;
  signed long int return_value_ans_ttl_5;
  signed int return_value_add_additional_rrs_6;
  if(!(ae == ((struct anonymous_0 *)NULL)))
  {
    struct anonymous *rrset;
    struct rr_b_s *rr;
    struct anonymous *tmp_if_expr_1;
    if((1 & (signed int)ae->flags) == 0)
      tmp_if_expr_1 = ae->_anon0.rr.rrmu[(signed long int)0];

    else
      tmp_if_expr_1 = (struct anonymous *)(void *)0;
    rrset = tmp_if_expr_1;
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      rr = rrset->rrs;
      if(!(rr == ((struct rr_b_s *)NULL)))
      {
        return_value_ans_ttl_2=ans_ttl(rrset, queryts);
        return_value_add_additional_rrs_3=add_additional_rrs(ans, rlen, allocsz, rhn, (unsigned int)1, return_value_ans_ttl_2, rr, 3, udp, cb, sva);
        if(return_value_add_additional_rrs_3 == 0)
          retval = 0;

      }

    }

    if(!(retval == 0))
    {
      struct anonymous *tmp_if_expr_4;
      if((1 & (signed int)ae->flags) == 0)
        tmp_if_expr_4 = ae->_anon0.rr.rrmu[(signed long int)7];

      else
        tmp_if_expr_4 = (struct anonymous *)(void *)0;
      rrset = tmp_if_expr_4;
      if(!(rrset == ((struct anonymous *)NULL)))
      {
        rr = rrset->rrs;
        if(!(rr == ((struct rr_b_s *)NULL)))
        {
          return_value_ans_ttl_5=ans_ttl(rrset, queryts);
          return_value_add_additional_rrs_6=add_additional_rrs(ans, rlen, allocsz, rhn, (unsigned int)28, return_value_ans_ttl_5, rr, 3, udp, cb, sva);
          if(return_value_add_additional_rrs_6 == 0)
            retval = 0;

        }

      }

    }

    free_cent(ae);
    free((void *)ae);
  }

  return retval;
}

// add_additional_rr
// file dns_answer.c line 662
static signed int add_additional_rr(struct anonymous_28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, unsigned int dlen, void *data, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva)
{
  struct anonymous_71 *st;
  void *return_value_dlist_first_1;
  return_value_dlist_first_1=dlist_first_link1(*sva);
  st = (struct anonymous_71 *)return_value_dlist_first_1;
  signed int return_value_rhnicmp_5;
  unsigned char *return_value_skiprhn_3;
  signed int return_value_memcmp_4;
  void *return_value_dlist_next_2;
  for( ; !(st == ((struct anonymous_71 *)NULL)); st = (struct anonymous_71 *)return_value_dlist_next_2)
  {
    if((unsigned int)st->tp == tp)
    {
      return_value_rhnicmp_5=rhnicmp(st->nm, rhn);
      if(!(return_value_rhnicmp_5 == 0))
      {
        if((unsigned int)st->dlen == dlen)
        {
          return_value_skiprhn_3=skiprhn(st->nm);
          return_value_memcmp_4=memcmp((const void *)return_value_skiprhn_3, data, (unsigned long int)dlen);
          if(return_value_memcmp_4 == 0)
            return 1;

        }

      }

    }

    return_value_dlist_next_2=dlist_next_link1((void *)st);
  }
  signed int return_value_add_rr_6;
  return_value_add_rr_6=add_rr(ans, rlen, allocsz, rhn, (unsigned short int)tp, (unsigned int)ttl, dlen, data, (char)sect, udp, cb);
  if(return_value_add_rr_6 == 0)
    return 0;

  else
  {
    signed int return_value_sva_add_7;
    return_value_sva_add_7=sva_add(sva, rhn, (unsigned short int)tp, (unsigned short int)dlen, data);
    if(return_value_sva_add_7 == 0)
      return 0;

    else
      return 1;
  }
}

// add_additional_rrs
// file dns_answer.c line 689
static signed int add_additional_rrs(struct anonymous_28 **ans, unsigned long int *rlen, unsigned long int *allocsz, unsigned char *rhn, unsigned int tp, signed long int ttl, struct rr_b_s *rrb, signed int sect, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva)
{
  struct rr_b_s *rr;
  struct rr_b_s *first = (struct rr_b_s *)(void *)0;
  signed short int rnd_recs = (signed short int)global.rnd_recs;
  rr = rrb;
  if(!(rnd_recs == 0))
  {
    first=randrr(rrb);
    rr = first;
  }

  while(!(rr == ((struct rr_b_s *)NULL)))
  {
    signed int return_value_add_additional_rr_1;
    return_value_add_additional_rr_1=add_additional_rr(ans, rlen, allocsz, rhn, tp, ttl, rr->rdlen, (void *)rr->data, sect, udp, cb, sva);
    if(return_value_add_additional_rr_1 == 0)
      return 0;

    rr = rr->next;
    if(!(rnd_recs == 0))
    {
      if(rr == ((struct rr_b_s *)NULL))
        rr = rrb;

      if(rr == first)
        break;

    }

  }
  return 1;
}

// add_ar
// file dns_answer.c line 495
static signed int add_ar(struct _dynamic_list_head **ar, unsigned short int tp, unsigned short int tsz, void *tnm, unsigned char *nm, unsigned int ttl)
{
  struct rre_s *re;
  unsigned char *p;
  unsigned long int nmsz = (unsigned long int)0;
  unsigned long int size = sizeof(struct rre_s) /*8ul*/  + (unsigned long int)tsz;
  if((signed int)tp == 2 || (signed int)tp == 6)
  {
    unsigned int return_value_rhnlen_1;
    return_value_rhnlen_1=rhnlen_link2(nm);
    nmsz = (unsigned long int)return_value_rhnlen_1;
    size = size + nmsz;
  }

  *ar=dlist_grow(*ar, size);
  if(*ar == ((struct _dynamic_list_head *)NULL))
    return 0;

  else
  {
    void *return_value_dlist_last_2;
    return_value_dlist_last_2=dlist_last_link1(*ar);
    re = (struct rre_s *)return_value_dlist_last_2;
    re->tp = tp;
    re->tsz = tsz;
    re->ttl = ttl;
    void *return_value_mempcpy_3;
    return_value_mempcpy_3=mempcpy((void *)re->tnm, tnm, (unsigned long int)tsz);
    p = (unsigned char *)return_value_mempcpy_3;
    if((signed int)tp == 2 || (signed int)tp == 6)
      memcpy((void *)p, (const void *)nm, nmsz);

    return 1;
  }
}

// add_cache
// file cache.h line 173
void add_cache(struct anonymous_0 *cent)
{
  struct anonymous_0 *ce;
  struct anonymous_58 loc;
  signed int i;
  signed int ilim;
  lock_cache_rw();
  do
  {

  retry:
    ;
    ce=dns_lookup(cent->qname, &loc);
    if(ce == ((struct anonymous_0 *)NULL))
    {
      if((signed int)cent->num_rrs == 0)
      {
        if((1 & (signed int)cent->flags) == 0)
          goto purge_cache_return;

      }

      ce=copy_cent(cent);
      if(ce == ((struct anonymous_0 *)NULL))
        goto warn_unlock_cache_return;

      if((1 & (signed int)ce->flags) == 0)
      {
        signed int tmp_if_expr_1;
        if(!((1 & (signed int)ce->flags) == 0))
          tmp_if_expr_1 = 0;

        else
          tmp_if_expr_1 = ce->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        ilim = tmp_if_expr_1;
        i = 0;
        for( ; !(i >= ilim); i = i + 1)
        {
          struct anonymous *rrset;
          struct anonymous *tmp_if_expr_2;
          if(!(i >= 8))
            tmp_if_expr_2 = ce->_anon0.rr.rrmu[(signed long int)i];

          else
            tmp_if_expr_2 = ce->_anon0.rr.rrext[(signed long int)(i - 8)];
          rrset = tmp_if_expr_2;
          if(!(rrset == ((struct anonymous *)NULL)))
          {
            adjust_ttl(rrset);
            signed int return_value_insert_rrl_3;
            return_value_insert_rrl_3=insert_rrl(rrset, ce, i);
            if(return_value_insert_rrl_3 == 0)
              goto free_cent_unlock_cache_return;

          }

        }
      }

      else
      {
        adjust_dom_ttl(ce);
        signed int return_value_insert_rrl_4;
        return_value_insert_rrl_4=insert_rrl((struct anonymous *)(void *)0, ce, -1);
        if(return_value_insert_rrl_4 == 0)
          goto free_cent_unlock_cache_return;

      }
      signed int return_value_add_dns_hash_5;
      return_value_add_dns_hash_5=add_dns_hash(ce, &loc);
      if(return_value_add_dns_hash_5 == 0)
        goto free_cent_unlock_cache_return;

      ent_num = ent_num + 1l;
      goto __CPROVER_DUMP_L64;
    }

    if((1 & (signed int)cent->flags) == 0)
      break;

    signed int tmp_if_expr_6;
    if(!((1 & (signed int)ce->flags) == 0))
      tmp_if_expr_6 = 0;

    else
      tmp_if_expr_6 = ce->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
    ilim = tmp_if_expr_6;
    i = 0;
    for( ; !(i >= ilim); i = i + 1)
    {
      struct anonymous *add_cache__1__2__1__1__1__cerrs;
      struct anonymous *tmp_if_expr_7;
      if(!(i >= 8))
        tmp_if_expr_7 = ce->_anon0.rr.rrmu[(signed long int)i];

      else
        tmp_if_expr_7 = ce->_anon0.rr.rrext[(signed long int)(i - 8)];
      add_cache__1__2__1__1__1__cerrs = tmp_if_expr_7;
      if(!(add_cache__1__2__1__1__1__cerrs == ((struct anonymous *)NULL)))
      {
        if(!((2 & (signed int)add_cache__1__2__1__1__1__cerrs->flags) == 0))
          goto unlock_cache_return;

      }

    }
    del_cache_ent(ce, &loc);
  }
  while((_Bool)1);
  purge_cent(ce, 0, 0);
  cache_size = cache_size - (volatile signed long int)ce->cs;
  signed int tmp_if_expr_8;
  if(!((1 & (signed int)cent->flags) == 0))
    tmp_if_expr_8 = 0;

  else
    tmp_if_expr_8 = cent->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
  ilim = tmp_if_expr_8;
  i = 0;
  struct anonymous *tmp_if_expr_11;
  struct anonymous *tmp_if_expr_10;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_25;
  _Bool tmp_if_expr_21;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_24;
  signed long int tmp_if_expr_22;
  signed long int return_value_time_23;
  for( ; !(i >= ilim); i = i + 1)
  {
    struct anonymous *centrrs;
    struct anonymous *tmp_if_expr_9;
    if(!(i >= 8))
      tmp_if_expr_9 = cent->_anon0.rr.rrmu[(signed long int)i];

    else
      tmp_if_expr_9 = cent->_anon0.rr.rrext[(signed long int)(i - 8)];
    centrrs = tmp_if_expr_9;
    if(!(centrrs == ((struct anonymous *)NULL)))
    {
      struct anonymous *cerrs;
      struct anonymous *tmp_if_expr_12;
      if(!((1 & (signed int)ce->flags) == 0))
        tmp_if_expr_12 = (struct anonymous *)(void *)0;

      else
      {
        if(!(i >= 8))
          tmp_if_expr_11 = ce->_anon0.rr.rrmu[(signed long int)i];

        else
        {
          if(!(ce->_anon0.rr.rrext == ((struct anonymous **)NULL)))
            tmp_if_expr_10 = ce->_anon0.rr.rrext[(signed long int)(i - 8)];

          else
            tmp_if_expr_10 = (struct anonymous *)(void *)0;
          tmp_if_expr_11 = tmp_if_expr_10;
        }
        tmp_if_expr_12 = tmp_if_expr_11;
      }
      cerrs = tmp_if_expr_12;
      _Bool tmp_if_expr_26;
      if(!(cerrs == ((struct anonymous *)NULL)))
      {
        if((2 & (signed int)centrrs->flags) == 0)
          tmp_if_expr_18 = ((signed int)cerrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_18 = (_Bool)0;
        if(tmp_if_expr_18)
          tmp_if_expr_25 = (_Bool)1;

        else
        {
          if(!((16 & (signed int)centrrs->flags) == 0))
          {
            if((16 & (signed int)cerrs->flags) == 0)
              tmp_if_expr_20 = (_Bool)1;

            else
            {
              if((64 & (signed int)centrrs->flags) == 0)
                tmp_if_expr_19 = ((signed int)cerrs->flags & 64) != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_19 = (_Bool)0;
              tmp_if_expr_20 = tmp_if_expr_19 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_21 = tmp_if_expr_20 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_21 = (_Bool)0;
          if(tmp_if_expr_21)
          {
            if(!(cerrs->ttl >= 120l))
              tmp_if_expr_22 = (signed long int)120;

            else
              tmp_if_expr_22 = cerrs->ttl;
            return_value_time_23=time((signed long int *)(void *)0);
            tmp_if_expr_24 = !(cerrs->ts + tmp_if_expr_22 < return_value_time_23) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_24 = (_Bool)0;
          tmp_if_expr_25 = tmp_if_expr_24 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr_26 = tmp_if_expr_25 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_26 = (_Bool)0;
      if(!tmp_if_expr_26)
      {
        struct rr_b_s *rr;
        struct rr_b_s *rtail;
        del_cent_rrset_by_index(ce, i);
        signed int return_value_cr_check_add_13;
        return_value_cr_check_add_13=cr_check_add(ce, i, centrrs->ttl, centrrs->ts, (unsigned int)centrrs->flags);
        if(return_value_cr_check_add_13 == 0)
          goto __CPROVER_DUMP_L55;

        signed int return_value_add_cent_rrset_by_index_14;
        return_value_add_cent_rrset_by_index_14=add_cent_rrset_by_index(ce, (unsigned int)i, centrrs->ttl, centrrs->ts, (unsigned int)centrrs->flags);
        if(return_value_add_cent_rrset_by_index_14 == 0)
          goto addsize_unlock_cache_return;

        rtail = (struct rr_b_s *)(void *)0;
        rr = centrrs->rrs;
        for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
        {
          signed int return_value_add_cent_rr_int_15;
          return_value_add_cent_rr_int_15=add_cent_rr_int(ce, (unsigned int)i, centrrs->ttl, centrrs->ts, (unsigned int)centrrs->flags, rr->rdlen, (void *)rr->data, &rtail);
          if(return_value_add_cent_rr_int_15 == 0)
            goto cleanup_cent_unlock_cache_return;

        }
        struct anonymous *tmp_if_expr_16;
        if(!(i >= 8))
          tmp_if_expr_16 = ce->_anon0.rr.rrmu[(signed long int)i];

        else
          tmp_if_expr_16 = ce->_anon0.rr.rrext[(signed long int)(i - 8)];
        cerrs = tmp_if_expr_16;
        adjust_ttl(cerrs);
        signed int return_value_insert_rrl_17;
        return_value_insert_rrl_17=insert_rrl(cerrs, ce, i);
        if(return_value_insert_rrl_17 == 0)
          goto cleanup_cent_unlock_cache_return;

      }

    }


  __CPROVER_DUMP_L55:
    ;
  }
  ce->flags = ce->flags | (unsigned short int)((signed int)cent->flags & (4 | 16));
  if(!((signed int)cent->c_ns == 0xff))
  {
    _Bool tmp_if_expr_27;
    if((signed int)ce->c_ns == 0xff)
      tmp_if_expr_27 = (_Bool)1;

    else
      tmp_if_expr_27 = (signed int)ce->c_ns < (signed int)cent->c_ns ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_27)
      ce->c_ns = cent->c_ns;

  }

  if(!((signed int)cent->c_soa == 0xff))
  {
    _Bool tmp_if_expr_28;
    if((signed int)ce->c_soa == 0xff)
      tmp_if_expr_28 = (_Bool)1;

    else
      tmp_if_expr_28 = (signed int)ce->c_soa < (signed int)cent->c_soa ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_28)
      ce->c_soa = cent->c_soa;

  }


__CPROVER_DUMP_L64:
  ;
  cache_size = cache_size + (volatile signed long int)ce->cs;

purge_cache_return:
  ;
  purge_cache((signed long int)global.perm_cache * (signed long int)1024 + (signed long int)10240, 1);
  goto unlock_cache_return;

cleanup_cent_unlock_cache_return:
  ;
  del_cent_rrset_by_index(ce, i);

addsize_unlock_cache_return:
  ;
  cache_size = cache_size + (volatile signed long int)ce->cs;
  goto warn_unlock_cache_return;

free_cent_unlock_cache_return:
  ;
  free_cent(ce);
  free((void *)ce);

warn_unlock_cache_return:
  ;
  log_message(4, "Out of cache memory.");

unlock_cache_return:
  ;
  unlock_cache_rw();
}

// add_cent_rr
// file cache.h line 201
signed int add_cent_rr(struct anonymous_0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data)
{
  signed int tpi;
  unsigned int idx;
  struct anonymous *rrset;
  struct rr_b_s *rtail;
  struct rr_b_s *rrb;
  struct anonymous *tmp_if_expr_2;
  struct anonymous *tmp_if_expr_1;
  signed int return_value_memcmp_4;
  if(!((2 & (signed int)cent->flags) == 0))
  {
    if(!((2u & flags) == 0u))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    tpi = type - 1;
    if(!(tpi >= 0) || tpi >= 51)
    {
      log_message(3, "%s:%d: %s", (const void *)"cache.c", 730, (const void *)"add_cent_rr: rr type value out of range");
      pdnsd_exit();
    }

    idx = (unsigned int)rrlkuptab[(signed long int)tpi];
    if(idx >= 47u)
    {
      log_message(3, "%s:%d: %s", (const void *)"cache.c", 732, (const void *)"add_cent_rr: illegal rr type value for caching");
      pdnsd_exit();
    }

    struct anonymous *tmp_if_expr_3;
    if(!((1 & (signed int)cent->flags) == 0))
      tmp_if_expr_3 = (struct anonymous *)(void *)0;

    else
    {
      if(!(idx >= 8u))
        tmp_if_expr_2 = cent->_anon0.rr.rrmu[(signed long int)idx];

      else
      {
        if(!(cent->_anon0.rr.rrext == ((struct anonymous **)NULL)))
          tmp_if_expr_1 = cent->_anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];

        else
          tmp_if_expr_1 = (struct anonymous *)(void *)0;
        tmp_if_expr_2 = tmp_if_expr_1;
      }
      tmp_if_expr_3 = tmp_if_expr_2;
    }
    rrset = tmp_if_expr_3;
    rtail = (struct rr_b_s *)(void *)0;
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      if(!(ttl >= rrset->ttl))
        rrset->ttl = ttl;

      rrb = rrset->rrs;
      while(!(rrb == ((struct rr_b_s *)NULL)))
      {
        if(rrb->rdlen == dlen)
        {
          return_value_memcmp_4=memcmp((const void *)rrb->data, data, (unsigned long int)dlen);
          if(return_value_memcmp_4 == 0)
            return 1;

        }

        rtail = rrb;
        rrb = rrb->next;
      }
    }

    signed int return_value_add_cent_rr_int_5;
    return_value_add_cent_rr_int_5=add_cent_rr_int(cent, idx, ttl, ts, flags, dlen, data, &rtail);
    return return_value_add_cent_rr_int_5;
  }
}

// add_cent_rr_int
// file cache.c line 668
static signed int add_cent_rr_int(struct anonymous_0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags, unsigned int dlen, void *data, struct rr_b_s **rtail)
{
  struct rr_b_s *rr;
  struct anonymous *rrset;
  rr=create_rr(dlen, data);
  struct anonymous *tmp_if_expr_2;
  struct anonymous *tmp_if_expr_1;
  char *return_value_flags2str_8;
  if(rr == ((struct rr_b_s *)NULL))
    return 0;

  else
  {
    _Bool tmp_if_expr_6;
    if(!(rtail == ((struct rr_b_s **)NULL)))
      tmp_if_expr_6 = *rtail != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if(!tmp_if_expr_6)
    {
      struct anonymous *tmp_if_expr_3;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr_3 = (struct anonymous *)(void *)0;

      else
      {
        if(!(idx >= 8u))
          tmp_if_expr_2 = cent->_anon0.rr.rrmu[(signed long int)idx];

        else
        {
          if(!(cent->_anon0.rr.rrext == ((struct anonymous **)NULL)))
            tmp_if_expr_1 = cent->_anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];

          else
            tmp_if_expr_1 = (struct anonymous *)(void *)0;
          tmp_if_expr_2 = tmp_if_expr_1;
        }
        tmp_if_expr_3 = tmp_if_expr_2;
      }
      rrset = tmp_if_expr_3;
      if(rrset == ((struct anonymous *)NULL))
      {
        signed int return_value_add_cent_rrset_by_index_4;
        return_value_add_cent_rrset_by_index_4=add_cent_rrset_by_index(cent, idx, ttl, ts, flags);
        if(return_value_add_cent_rrset_by_index_4 == 0)
          goto cleanup_return;

        struct anonymous *tmp_if_expr_5;
        if(!(idx >= 8u))
          tmp_if_expr_5 = cent->_anon0.rr.rrmu[(signed long int)idx];

        else
          tmp_if_expr_5 = cent->_anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];
        rrset = tmp_if_expr_5;
      }

      rr->next = rrset->rrs;
      rrset->rrs = rr;
    }

    else
    {
      rr->next = (*rtail)->next;
      (*rtail)->next = rr;
    }
    if(!(rtail == ((struct rr_b_s **)NULL)))
      *rtail = rr;

    cent->cs = cent->cs + sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rr->rdlen;
    if(!(debug_p == 0))
    {
      struct anonymous *tmp_if_expr_7;
      if(!(idx >= 8u))
        tmp_if_expr_7 = cent->_anon0.rr.rrmu[(signed long int)idx];

      else
        tmp_if_expr_7 = cent->_anon0.rr.rrext[(signed long int)(idx - (unsigned int)8)];
      rrset = tmp_if_expr_7;
      if(!((1 & (signed int)rrset->flags) == 0))
      {
        char cflagstr[28l];
        if(!(debug_p == 0))
        {
          return_value_flags2str_8=flags2str((unsigned int)rrset->flags, cflagstr, 7, cflgnames);
          debug_msg(0, "Tried to add rr to a rrset with CF_NEGATIVE set! flags=%s\n", return_value_flags2str_8);
        }

      }

    }

    return 1;

  cleanup_return:
    ;
    free((void *)rr);
    return 0;
  }
}

// add_cent_rrset_by_index
// file cache.c line 605
static signed int add_cent_rrset_by_index(struct anonymous_0 *cent, unsigned int idx, signed long int ttl, signed long int ts, unsigned int flags)
{
  struct anonymous **rrext;
  struct anonymous **rrsetpa;
  struct anonymous *rrset;
  if(!((1 & (signed int)cent->flags) == 0))
  {
    signed int i;
    if(!(cent->_anon0.neg.lent == ((struct rr_lent_s *)NULL)))
      remove_rrl(cent->_anon0.neg.lent);

    cent->flags = cent->flags & (unsigned short int)~1;
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      cent->_anon0.rr.rrmu[(signed long int)i] = (struct anonymous *)(void *)0;
    cent->_anon0.rr.rrext = (struct anonymous **)(void *)0;
  }

  if(!(idx >= 8u))
    rrsetpa = &cent->_anon0.rr.rrmu[(signed long int)idx];

  else
  {
    idx = idx - (unsigned int)8;
    if(idx >= 39u)
    {
      log_message(3, "%s:%d: %s", (const void *)"cache.c", 625, (const void *)"add_cent_rrset_by_index: rr-set index out of range");
      pdnsd_exit();
    }

    rrext = cent->_anon0.rr.rrext;
    if(rrext == ((struct anonymous **)NULL))
    {
      signed int add_cent_rrset_by_index__1__2__2__i;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39);
      rrext = (struct anonymous **)return_value_malloc_1;
      cent->_anon0.rr.rrext = rrext;
      if(rrext == ((struct anonymous **)NULL))
        return 0;

      add_cent_rrset_by_index__1__2__2__i = 0;
      for( ; !(add_cent_rrset_by_index__1__2__2__i >= 39); add_cent_rrset_by_index__1__2__2__i = add_cent_rrset_by_index__1__2__2__i + 1)
        rrext[(signed long int)add_cent_rrset_by_index__1__2__2__i] = (struct anonymous *)(void *)0;
      cent->cs = cent->cs + sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39;
    }

    rrsetpa = &rrext[(signed long int)idx];
  }
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct anonymous) /*40ul*/ );
  rrset = (struct anonymous *)return_value_malloc_2;
  *rrsetpa = rrset;
  if(rrset == ((struct anonymous *)NULL))
    return 0;

  else
  {
    rrset->lent = (struct rr_lent_s *)(void *)0;
    rrset->ttl = ttl;
    rrset->ts = ts;
    rrset->flags = (unsigned short int)flags;
    rrset->rrs = (struct rr_b_s *)(void *)0;
    cent->cs = cent->cs + sizeof(struct anonymous) /*40ul*/ ;
    cent->num_rrs = cent->num_rrs + 1;
    return 1;
  }
}

// add_cent_rrset_by_type
// file cache.h line 200
signed int add_cent_rrset_by_type(struct anonymous_0 *cent, signed int type, signed long int ttl, signed long int ts, unsigned int flags)
{
  signed int tpi = type - 1;
  if(!(tpi >= 0) || tpi >= 51)
  {
    log_message(3, "%s:%d: %s", (const void *)"cache.c", 659, (const void *)"add_cent_rrset_by_type: rr type value out of range");
    pdnsd_exit();
  }

  signed int return_value_add_cent_rrset_by_index_1;
  return_value_add_cent_rrset_by_index_1=add_cent_rrset_by_index(cent, (unsigned int)rrlkuptab[(signed long int)tpi], ttl, ts, flags);
  return return_value_add_cent_rrset_by_index_1;
}

// add_dns_hash
// file hash.h line 69
signed int add_dns_hash(struct anonymous_0 *data, struct anonymous_58 *loc)
{
  struct dns_hash_ent_s *he;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct dns_hash_ent_s) /*24ul*/ );
  he = (struct dns_hash_ent_s *)return_value_malloc_1;
  if(he == ((struct dns_hash_ent_s *)NULL))
    return 0;

  else
  {
    he->next = *loc->pos;
    he->rhash = loc->rhash;
    he->data = data;
    *loc->pos = he;
    return 1;
  }
}

// add_host
// file dns.c line 340
static signed int add_host(unsigned char *pn, unsigned char *rns, union anonymous_6 *a, signed int tp, signed int a_sz, signed long int ttl, unsigned int flags, signed int reverse)
{
  struct anonymous_0 ce;
  signed int return_value_init_cent_1;
  return_value_init_cent_1=init_cent(&ce, pn, (signed long int)0, (signed long int)0, flags);
  unsigned int return_value_rhnlen_3;
  signed int return_value_add_cent_rr_4;
  if(return_value_init_cent_1 == 0)
    return 0;

  else
  {
    signed int return_value_add_cent_rr_2;
    return_value_add_cent_rr_2=add_cent_rr(&ce, tp, ttl, (signed long int)0, (unsigned int)2, (unsigned int)a_sz, (void *)a);
    if(!(return_value_add_cent_rr_2 == 0))
    {
      return_value_rhnlen_3=rhnlen_link1(rns);
      return_value_add_cent_rr_4=add_cent_rr(&ce, 2, ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen_3, (void *)rns);
      if(return_value_add_cent_rr_4 == 0)
        goto free_cent_return0;

      add_cache(&ce);
      free_cent(&ce);
      if(!(reverse == 0))
      {
        unsigned char b2[256l];
        unsigned char rhn[256l];
        signed int return_value_a2ptrstr_5;
        return_value_a2ptrstr_5=a2ptrstr(a, tp, b2);
        if(return_value_a2ptrstr_5 == 0)
          return -1;

        signed int return_value_str2rhn_6;
        return_value_str2rhn_6=str2rhn(b2, rhn);
        if(return_value_str2rhn_6 == 0)
          return -1;

        signed int return_value_init_cent_7;
        return_value_init_cent_7=init_cent(&ce, rhn, (signed long int)0, (signed long int)0, flags);
        if(return_value_init_cent_7 == 0)
          return 0;

        unsigned int return_value_rhnlen_8;
        return_value_rhnlen_8=rhnlen_link1(pn);
        signed int return_value_add_cent_rr_9;
        return_value_add_cent_rr_9=add_cent_rr(&ce, 12, ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen_8, (void *)pn);
        if(return_value_add_cent_rr_9 == 0)
          goto free_cent_return0;

        unsigned int return_value_rhnlen_10;
        return_value_rhnlen_10=rhnlen_link1(rns);
        signed int return_value_add_cent_rr_11;
        return_value_add_cent_rr_11=add_cent_rr(&ce, 2, ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen_10, (void *)rns);
        if(return_value_add_cent_rr_11 == 0)
          goto free_cent_return0;

        add_cache(&ce);
        free_cent(&ce);
      }

      return 1;
    }

    else
    {

    free_cent_return0:
      ;
      free_cent(&ce);
      return 0;
    }
  }
}

// add_opt_pseudo_rr
// file dns_answer.c line 423
signed int add_opt_pseudo_rr(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned short int udpsize, unsigned short int rcode, unsigned short int ednsver, unsigned short int Zflags)
{
  unsigned char *ptr;
  unsigned long int newsz = (unsigned long int)2 + *sz + (unsigned long int)(1 + 10);
  if(!(*allocsz >= newsz))
  {
    unsigned long int newallocsz = newsz + (unsigned long int)0x7f & ~((unsigned long int)0x7f);
    struct anonymous_28 *newans;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)*ans, newallocsz);
    newans = (struct anonymous_28 *)return_value_realloc_1;
    if(newans == ((struct anonymous_28 *)NULL))
      return 0;

    *ans = newans;
    *allocsz = newallocsz;
  }

  ptr = (unsigned char *)&(*ans)->hdr + (signed long int)*sz;
  unsigned char *tmp_post_2 = ptr;
  ptr = ptr + 1l;
  *tmp_post_2 = (unsigned char)0;
  do
  {
    unsigned short int t_s = (unsigned short int)41;
    unsigned char *t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post_3 = t_cp;
    t_cp = t_cp + 1l;
    *tmp_post_3 = (unsigned char)((signed int)t_s >> 8);
    unsigned char *tmp_post_4 = t_cp;
    t_cp = t_cp + 1l;
    *tmp_post_4 = (unsigned char)t_s;
    ptr = (unsigned char *)(void *)t_cp;
  }
  while((_Bool)0);
  do
  {
    unsigned short int add_opt_pseudo_rr__1__3__t_s = (unsigned short int)udpsize;
    unsigned char *add_opt_pseudo_rr__1__3__t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post_5 = add_opt_pseudo_rr__1__3__t_cp;
    add_opt_pseudo_rr__1__3__t_cp = add_opt_pseudo_rr__1__3__t_cp + 1l;
    *tmp_post_5 = (unsigned char)((signed int)add_opt_pseudo_rr__1__3__t_s >> 8);
    unsigned char *tmp_post_6 = add_opt_pseudo_rr__1__3__t_cp;
    add_opt_pseudo_rr__1__3__t_cp = add_opt_pseudo_rr__1__3__t_cp + 1l;
    *tmp_post_6 = (unsigned char)add_opt_pseudo_rr__1__3__t_s;
    ptr = (unsigned char *)(void *)add_opt_pseudo_rr__1__3__t_cp;
  }
  while((_Bool)0);
  unsigned char *tmp_post_7 = ptr;
  ptr = ptr + 1l;
  *tmp_post_7 = (unsigned char)((signed int)rcode >> 4);
  unsigned char *tmp_post_8 = ptr;
  ptr = ptr + 1l;
  *tmp_post_8 = (unsigned char)ednsver;
  do
  {
    unsigned short int add_opt_pseudo_rr__1__4__t_s = (unsigned short int)Zflags;
    unsigned char *add_opt_pseudo_rr__1__4__t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post_9 = add_opt_pseudo_rr__1__4__t_cp;
    add_opt_pseudo_rr__1__4__t_cp = add_opt_pseudo_rr__1__4__t_cp + 1l;
    *tmp_post_9 = (unsigned char)((signed int)add_opt_pseudo_rr__1__4__t_s >> 8);
    unsigned char *tmp_post_10 = add_opt_pseudo_rr__1__4__t_cp;
    add_opt_pseudo_rr__1__4__t_cp = add_opt_pseudo_rr__1__4__t_cp + 1l;
    *tmp_post_10 = (unsigned char)add_opt_pseudo_rr__1__4__t_s;
    ptr = (unsigned char *)(void *)add_opt_pseudo_rr__1__4__t_cp;
  }
  while((_Bool)0);
  do
  {
    unsigned short int add_opt_pseudo_rr__1__5__t_s = (unsigned short int)0;
    unsigned char *add_opt_pseudo_rr__1__5__t_cp = (unsigned char *)ptr;
    unsigned char *tmp_post_11 = add_opt_pseudo_rr__1__5__t_cp;
    add_opt_pseudo_rr__1__5__t_cp = add_opt_pseudo_rr__1__5__t_cp + 1l;
    *tmp_post_11 = (unsigned char)((signed int)add_opt_pseudo_rr__1__5__t_s >> 8);
    unsigned char *tmp_post_12 = add_opt_pseudo_rr__1__5__t_cp;
    add_opt_pseudo_rr__1__5__t_cp = add_opt_pseudo_rr__1__5__t_cp + 1l;
    *tmp_post_12 = (unsigned char)add_opt_pseudo_rr__1__5__t_s;
    ptr = (unsigned char *)(void *)add_opt_pseudo_rr__1__5__t_cp;
  }
  while((_Bool)0);
  *sz = *sz + (unsigned long int)(1 + 10);
  unsigned short int return_value_ntohs_13;
  return_value_ntohs_13=ntohs((*ans)->hdr.arcount);
  (*ans)->hdr.arcount=htons((unsigned short int)((signed int)return_value_ntohs_13 + 1));
  return 1;
}

// add_qserv
// file dns_query.c line 1958
static signed int add_qserv(struct anonymous_4 **q, struct anonymous_15 *a, signed int port, signed long int timeout, unsigned int flags, signed int nocache, char lean_query, char edns_query, char auth_s, char needs_testing, char trusted, const unsigned char *nsdomain, struct rejectlist_s *rejectlist)
{
  struct anonymous_5 *qs;
  struct anonymous_3 *return_value_da_grow1_1;
  return_value_da_grow1_1=da_grow1((struct anonymous_3 *)*q, (unsigned long int)((struct anonymous_4 *)0)->elem, sizeof(struct anonymous_5) /*112ul*/ , (void (*)(void *))(void *)0);
  *q = (struct anonymous_4 *)return_value_da_grow1_1;
  if(*q == ((struct anonymous_4 *)NULL))
  {
    if(!(debug_p == 0))
      debug_msg(0, "Out of memory in add_qserv()\n");

    return 0;
  }

  else
  {
    qs = &(*q)->elem[(signed long int)((*q)->nel - (unsigned long int)1)];
    if(!(run_ipv4 == 0))
    {
      memset((void *)&qs->a.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      qs->a.sin4.sin_family = (unsigned short int)2;
      qs->a.sin4.sin_port=htons((unsigned short int)port);
      qs->a.sin4.sin_addr = a->ipv4;
    }

    else
    {
      memset((void *)&qs->a.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
      qs->a.sin6.sin6_family = (unsigned short int)10;
      qs->a.sin6.sin6_port=htons((unsigned short int)port);
      qs->a.sin6.sin6_flowinfo = (unsigned int)0;
      qs->a.sin6.sin6_addr = a->ipv6;
      qs->a4fallback = a->ipv4;
    }
    qs->timeout = timeout;
    qs->flags = (unsigned short int)flags;
    qs->nocache = (signed short int)nocache;
    qs->auth_serv = auth_s;
    qs->lean_query = lean_query;
    qs->edns_query = edns_query;
    qs->needs_testing = needs_testing;
    qs->trusted = trusted;
    qs->aa = (char)0;
    qs->tc = (char)0;
    qs->failed = (char)0;
    qs->nsdomain = nsdomain;
    qs->rejectlist = rejectlist;
    qs->state = (signed short int)0;
    qs->qm = (signed short int)global.query_method;
    qs->s_errno = 0;
    return 1;
  }
}

// add_rejectlist
// file dns_query.c line 2853
static struct rejectlist_s * add_rejectlist(struct rejectlist_s *rl, struct anonymous_7 *sp)
{
  signed int i;
  signed int na4;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link2((struct anonymous_3 *)sp->reject_a4);
  na4 = (signed int)return_value_da_nel_1;
  struct anonymous_11 *a4p;
  signed int na6;
  unsigned int return_value_da_nel_2;
  return_value_da_nel_2=da_nel_link2((struct anonymous_3 *)sp->reject_a6);
  na6 = (signed int)return_value_da_nel_2;
  struct anonymous_13 *a6p;
  struct rejectlist_s *rlist;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(struct rejectlist_s) /*24ul*/  + (unsigned long int)na4 * sizeof(struct anonymous_11) /*8ul*/  + (unsigned long int)na6 * sizeof(struct anonymous_13) /*32ul*/ );
  rlist = (struct rejectlist_s *)return_value_malloc_3;
  if(!(rlist == ((struct rejectlist_s *)NULL)))
  {
    rlist->na6 = na6;
    a6p = (struct anonymous_13 *)rlist->rdata;
    i = 0;
    for( ; !(i >= na6); i = i + 1)
    {
      struct anonymous_13 *tmp_post_4 = a6p;
      a6p = a6p + 1l;
      *tmp_post_4 = sp->reject_a6->elem[(signed long int)i];
    }
    rlist->na4 = na4;
    a4p = (struct anonymous_11 *)a6p;
    i = 0;
    for( ; !(i >= na4); i = i + 1)
    {
      struct anonymous_11 *tmp_post_5 = a4p;
      a4p = a4p + 1l;
      *tmp_post_5 = sp->reject_a4->elem[(signed long int)i];
    }
    rlist->policy = sp->rejectpolicy;
    rlist->inherit = (signed short int)sp->rejectrecursively;
    rlist->next = rl;
  }

  return rlist;
}

// add_reverse_cache
// file cache.h line 174
signed int add_reverse_cache(struct anonymous_0 *cent)
{
  signed int tp = 1;
  struct anonymous *rrset;
  struct anonymous *tmp_if_expr_1;
  if((1 & (signed int)cent->flags) == 0)
    tmp_if_expr_1 = cent->_anon0.rr.rrmu[(signed long int)0];

  else
    tmp_if_expr_1 = (struct anonymous *)(void *)0;
  rrset = tmp_if_expr_1;
  signed int return_value_str2rhn_3;
  while((_Bool)1)
  {
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      struct rr_b_s *rr = rrset->rrs;
      for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
      {
        struct anonymous_0 ce;
        unsigned char buf[256l];
        unsigned char rhn[256l];
        signed int return_value_a2ptrstr_2;
        return_value_a2ptrstr_2=a2ptrstr((union anonymous_6 *)rr->data, tp, buf);
        _Bool tmp_if_expr_4;
        if(return_value_a2ptrstr_2 == 0)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_str2rhn_3=str2rhn(buf, rhn);
          tmp_if_expr_4 = !(return_value_str2rhn_3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          return 0;

        signed int return_value_init_cent_5;
        return_value_init_cent_5=init_cent(&ce, rhn, (signed long int)0, (signed long int)0, (unsigned int)cent->flags);
        if(return_value_init_cent_5 == 0)
          return 0;

        unsigned int return_value_rhnlen_6;
        return_value_rhnlen_6=rhnlen_link6(cent->qname);
        signed int return_value_add_cent_rr_7;
        return_value_add_cent_rr_7=add_cent_rr(&ce, 12, rrset->ttl, rrset->ts, (unsigned int)rrset->flags, return_value_rhnlen_6, (void *)cent->qname);
        if(return_value_add_cent_rr_7 == 0)
        {
          free_cent(&ce);
          return 0;
        }

        ce._anon0.rr.rrmu[(signed long int)1] = cent->_anon0.rr.rrmu[(signed long int)1];
        ce._anon0.rr.rrmu[(signed long int)3] = cent->_anon0.rr.rrmu[(signed long int)3];
        add_cache(&ce);
        ce._anon0.rr.rrmu[(signed long int)1] = (struct anonymous *)(void *)0;
        ce._anon0.rr.rrmu[(signed long int)3] = (struct anonymous *)(void *)0;
        free_cent(&ce);
      }
    }

    if(tp == 28)
      break;

    tp = 28;
    struct anonymous *tmp_if_expr_8;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr_8 = cent->_anon0.rr.rrmu[(signed long int)7];

    else
      tmp_if_expr_8 = (struct anonymous *)(void *)0;
    rrset = tmp_if_expr_8;
  }
  return 1;
}

// add_rr
// file dns_answer.c line 213
static signed int add_rr(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned short int type, unsigned int ttl, unsigned int dlen, void *data, char section, unsigned int *udp, struct _dynamic_list_head **cb)
{
  unsigned long int osz = *sz;
  unsigned int ilen;
  unsigned int blen;
  unsigned int rdlen;
  unsigned char *rrht;
  unsigned int nlen;
  unsigned char nbuf[256l];
  nlen=compress_name(rrn, nbuf, (unsigned int)*sz, cb);
  unsigned int return_value_rhnlen_2;
  unsigned int return_value_rhnlen_3;
  unsigned short int return_value_ntohs_14;
  unsigned short int return_value_ntohs_15;
  unsigned short int return_value_ntohs_16;
  if(nlen == 0u)
    return 0;

  else
  {
    unsigned long int newsz = (unsigned long int)2 + *sz + (unsigned long int)nlen + (unsigned long int)10 + (unsigned long int)dlen;
    if(!(*allocsz >= newsz))
    {
      unsigned long int newallocsz = newsz + (unsigned long int)0x7f & ~((unsigned long int)0x7f);
      struct anonymous_28 *newans;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)*ans, newallocsz);
      newans = (struct anonymous_28 *)return_value_realloc_1;
      if(newans == ((struct anonymous_28 *)NULL))
        return 0;

      *ans = newans;
      *allocsz = newallocsz;
    }

    memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)nbuf, (unsigned long int)nlen);
    *sz = *sz + (unsigned long int)nlen;
    rrht = (unsigned char *)&(*ans)->hdr + (signed long int)*sz;
    *sz = *sz + (unsigned long int)10;
    switch((signed int)type)
    {
      case 5:

      case 7:

      case 3:

      case 4:

      case 8:

      case 9:

      case 2:

      case 12:
      {
        rdlen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(rdlen == 0u)
          return 0;

        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 263, (const void *)"T_CNAME/T_MB/...: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)rdlen;
        break;
      }
      case 14:

      case 17:
      {
        rdlen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(rdlen == 0u)
          return 0;

        *sz = *sz + (unsigned long int)rdlen;
        ilen=rhnlen_link2((unsigned char *)data);
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 277, (const void *)"T_MINFO/T_RP: got longer");
          pdnsd_exit();
        }

        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = rdlen + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 281, (const void *)"T_MINFO/T_RP: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 15:

      case 18:

      case 21:

      case 36:
      {
        if(!(dlen >= 3u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 295, (const void *)"T_MX/T_AFSDB/...: rr botch");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)2);
        *sz = *sz + (unsigned long int)2;
        blen=compress_name((unsigned char *)data + (signed long int)2, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = (unsigned int)2 + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 301, (const void *)"T_MX/T_AFSDB/...: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 6:
      {
        rdlen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(rdlen == 0u)
          return 0;

        *sz = *sz + (unsigned long int)rdlen;
        ilen=rhnlen_link2((unsigned char *)data);
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 309, (const void *)"T_SOA: got longer");
          pdnsd_exit();
        }

        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = rdlen + blen;
        *sz = *sz + (unsigned long int)blen;
        return_value_rhnlen_2=rhnlen_link2((unsigned char *)data + (signed long int)ilen);
        ilen = ilen + return_value_rhnlen_2;
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 315, (const void *)"T_SOA: got longer");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)((unsigned char *)data + (signed long int)ilen), (unsigned long int)20);
        rdlen = rdlen + (unsigned int)20;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 318, (const void *)"T_SOA: rr botch");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)20;
        break;
      }
      case 26:
      {
        if(!(dlen >= 3u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 323, (const void *)"T_PX: rr botch");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)2);
        *sz = *sz + (unsigned long int)2;
        ilen = (unsigned int)2;
        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = (unsigned int)2 + blen;
        *sz = *sz + (unsigned long int)blen;
        return_value_rhnlen_3=rhnlen_link2((unsigned char *)data + (signed long int)ilen);
        ilen = ilen + return_value_rhnlen_3;
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 332, (const void *)"T_PX: got longer");
          pdnsd_exit();
        }

        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = rdlen + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 336, (const void *)"T_PX: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 33:
      {
        if(!(dlen >= 7u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 342, (const void *)"T_SRV: rr botch");
          pdnsd_exit();
        }

        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)6);
        *sz = *sz + (unsigned long int)6;
        blen=compress_name((unsigned char *)data + (signed long int)6, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = (unsigned int)6 + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 348, (const void *)"T_SRV: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      case 30:
      {
        blen=compress_name((unsigned char *)data, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = blen;
        *sz = *sz + (unsigned long int)blen;
        ilen=rhnlen_link2((unsigned char *)data);
        if(!(ilen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 359, (const void *)"T_NXT: got longer");
          pdnsd_exit();
        }

        if(!(dlen >= ilen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 360, (const void *)"T_NXT: rr botch");
          pdnsd_exit();
        }

        if(!(ilen >= dlen))
        {
          unsigned int wlen = dlen - ilen;
          memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)((unsigned char *)data + (signed long int)ilen), (unsigned long int)wlen);
          *sz = *sz + (unsigned long int)wlen;
          rdlen = rdlen + wlen;
        }

        break;
      }
      case 35:
      {
        if(!(dlen >= 5u))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 371, (const void *)"T_NAPTR: rr botch");
          pdnsd_exit();
        }

        ilen = (unsigned int)4;
        signed int j = 0;
        for( ; !(j >= 3); j = j + 1)
        {
          ilen = ilen + (unsigned int)((unsigned char *)data)[(signed long int)ilen] + (unsigned int)1;
          if(ilen >= dlen)
          {
            log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 377, (const void *)"T_NAPTR: rr botch 2");
            pdnsd_exit();
          }

        }
        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)ilen);
        *sz = *sz + (unsigned long int)ilen;
        blen=compress_name((unsigned char *)data + (signed long int)ilen, (unsigned char *)&(*ans)->hdr + (signed long int)*sz, (unsigned int)*sz, cb);
        if(blen == 0u)
          return 0;

        rdlen = ilen + blen;
        if(!(dlen >= rdlen))
        {
          log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 386, (const void *)"T_NAPTR: got longer");
          pdnsd_exit();
        }

        *sz = *sz + (unsigned long int)blen;
        break;
      }
      default:
      {
        memcpy((void *)((unsigned char *)&(*ans)->hdr + (signed long int)*sz), (const void *)(unsigned char *)data, (unsigned long int)dlen);
        rdlen = dlen;
        *sz = *sz + (unsigned long int)dlen;
      }
    }
    _Bool tmp_if_expr_17;
    if(!(udp == ((unsigned int *)NULL)))
      tmp_if_expr_17 = *sz > (unsigned long int)*udp ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_17 = (_Bool)0;
    if((signed int)section == 3 && tmp_if_expr_17)
      *sz = osz;

    else
    {
      do
      {
        unsigned short int t_s = (unsigned short int)type;
        unsigned char *t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post_4 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post_4 = (unsigned char)((signed int)t_s >> 8);
        unsigned char *tmp_post_5 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post_5 = (unsigned char)t_s;
        rrht = (unsigned char *)(void *)t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned short int add_rr__1__3__2__t_s = (unsigned short int)1;
        unsigned char *add_rr__1__3__2__t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post_6 = add_rr__1__3__2__t_cp;
        add_rr__1__3__2__t_cp = add_rr__1__3__2__t_cp + 1l;
        *tmp_post_6 = (unsigned char)((signed int)add_rr__1__3__2__t_s >> 8);
        unsigned char *tmp_post_7 = add_rr__1__3__2__t_cp;
        add_rr__1__3__2__t_cp = add_rr__1__3__2__t_cp + 1l;
        *tmp_post_7 = (unsigned char)add_rr__1__3__2__t_s;
        rrht = (unsigned char *)(void *)add_rr__1__3__2__t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned int t_l = (unsigned int)ttl;
        unsigned char *add_rr__1__3__3__t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post_8 = add_rr__1__3__3__t_cp;
        add_rr__1__3__3__t_cp = add_rr__1__3__3__t_cp + 1l;
        *tmp_post_8 = (unsigned char)(t_l >> 24);
        unsigned char *tmp_post_9 = add_rr__1__3__3__t_cp;
        add_rr__1__3__3__t_cp = add_rr__1__3__3__t_cp + 1l;
        *tmp_post_9 = (unsigned char)(t_l >> 16);
        unsigned char *tmp_post_10 = add_rr__1__3__3__t_cp;
        add_rr__1__3__3__t_cp = add_rr__1__3__3__t_cp + 1l;
        *tmp_post_10 = (unsigned char)(t_l >> 8);
        unsigned char *tmp_post_11 = add_rr__1__3__3__t_cp;
        add_rr__1__3__3__t_cp = add_rr__1__3__3__t_cp + 1l;
        *tmp_post_11 = (unsigned char)t_l;
        rrht = (unsigned char *)(void *)add_rr__1__3__3__t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned short int add_rr__1__3__4__t_s = (unsigned short int)rdlen;
        unsigned char *add_rr__1__3__4__t_cp = (unsigned char *)rrht;
        unsigned char *tmp_post_12 = add_rr__1__3__4__t_cp;
        add_rr__1__3__4__t_cp = add_rr__1__3__4__t_cp + 1l;
        *tmp_post_12 = (unsigned char)((signed int)add_rr__1__3__4__t_s >> 8);
        unsigned char *tmp_post_13 = add_rr__1__3__4__t_cp;
        add_rr__1__3__4__t_cp = add_rr__1__3__4__t_cp + 1l;
        *tmp_post_13 = (unsigned char)add_rr__1__3__4__t_s;
        rrht = (unsigned char *)(void *)add_rr__1__3__4__t_cp;
      }
      while((_Bool)0);
      switch((signed int)section)
      {
        case 1:
        {
          return_value_ntohs_14=ntohs((*ans)->hdr.ancount);
          (*ans)->hdr.ancount=htons((unsigned short int)((signed int)return_value_ntohs_14 + 1));
          break;
        }
        case 2:
        {
          return_value_ntohs_15=ntohs((*ans)->hdr.nscount);
          (*ans)->hdr.nscount=htons((unsigned short int)((signed int)return_value_ntohs_15 + 1));
          break;
        }
        case 3:
        {
          return_value_ntohs_16=ntohs((*ans)->hdr.arcount);
          (*ans)->hdr.arcount=htons((unsigned short int)((signed int)return_value_ntohs_16 + 1));
        }
      }
    }
    return 1;
  }
}

// add_rrset
// file dns_answer.c line 554
static signed int add_rrset(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int tp, signed long int queryts, struct anonymous_0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar)
{
  struct anonymous *crrset;
  crrset=getrrset(cached, (signed int)tp);
  if(!(crrset == ((struct anonymous *)NULL)))
  {
    if(!(crrset->rrs == ((struct rr_b_s *)NULL)))
    {
      struct rr_b_s *b;
      struct rr_b_s *first = (struct rr_b_s *)(void *)0;
      signed int i;
      signed short int rnd_recs = (signed short int)global.rnd_recs;
      b = crrset->rrs;
      if(!(rnd_recs == 0))
      {
        first=randrr(crrset->rrs);
        b = first;
      }

      while(!(b == ((struct rr_b_s *)NULL)))
      {
        signed long int return_value_ans_ttl_1;
        return_value_ans_ttl_1=ans_ttl(crrset, queryts);
        signed int return_value_add_rr_2;
        return_value_add_rr_2=add_rr(ans, sz, allocsz, rrn, (unsigned short int)tp, (unsigned int)return_value_ans_ttl_1, b->rdlen, (void *)b->data, (char)1, udp, cb);
        if(return_value_add_rr_2 == 0)
          return 0;

        if(tp == 1u || tp == 2u || tp == 28u)
        {
          signed int return_value_sva_add_3;
          return_value_sva_add_3=sva_add(sva, rrn, (unsigned short int)tp, (unsigned short int)b->rdlen, (void *)b->data);
          if(return_value_sva_add_3 == 0)
            return 0;

        }

        i = 0;
        for( ; !(i >= 6); i = i + 1)
          if((unsigned int)ar_recs[(signed long int)i] == tp)
          {
            signed int return_value_add_ar_4;
            return_value_add_ar_4=add_ar(ar, (unsigned short int)0, (unsigned short int)(b->rdlen - (unsigned int)ar_offs[(signed long int)i]), (void *)((unsigned char *)b->data + (signed long int)ar_offs[(signed long int)i]), (unsigned char *)"", (unsigned int)0);
            if(return_value_add_ar_4 == 0)
              return 0;

            break;
          }

        b = b->next;
        if(!(rnd_recs == 0))
        {
          if(b == ((struct rr_b_s *)NULL))
            b = crrset->rrs;

          if(b == first)
            break;

        }

      }
    }

  }

  return 1;
}

// add_to_response
// file dns_answer.c line 605
static signed int add_to_response(struct anonymous_28 **ans, unsigned long int *sz, unsigned long int *allocsz, unsigned char *rrn, unsigned int qtype, signed long int queryts, struct anonymous_0 *cached, unsigned int *udp, struct _dynamic_list_head **cb, struct _dynamic_list_head **sva, struct _dynamic_list_head **ar)
{
  signed int return_value_have_rr_2;
  signed int return_value_add_rrset_1;
  if(!(qtype == 5u) && !(qtype == 255u))
  {
    _Bool tmp_if_expr_3;
    if(qtype >= 1u && !(qtype >= 52u))
    {
      return_value_have_rr_2=have_rr(cached, (signed int)qtype);
      tmp_if_expr_3 = return_value_have_rr_2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
    {
      return_value_add_rrset_1=add_rrset(ans, sz, allocsz, rrn, (unsigned int)5, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset_1 == 0)
        return 0;

    }

  }

  const unsigned short int *tmp_if_expr_10;
  if(qtype == 251u || qtype == 252u)
    return 0;

  else
    if(qtype == 253u)
    {
      signed int return_value_add_rrset_4;
      return_value_add_rrset_4=add_rrset(ans, sz, allocsz, rrn, (unsigned int)7, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset_4 == 0)
        return 0;

      signed int return_value_add_rrset_5;
      return_value_add_rrset_5=add_rrset(ans, sz, allocsz, rrn, (unsigned int)8, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset_5 == 0)
        return 0;

      signed int return_value_add_rrset_6;
      return_value_add_rrset_6=add_rrset(ans, sz, allocsz, rrn, (unsigned int)9, queryts, cached, udp, cb, sva, ar);
      if(return_value_add_rrset_6 == 0)
        return 0;

    }

    else
      if(qtype == 254u)
      {
        signed int return_value_add_rrset_7;
        return_value_add_rrset_7=add_rrset(ans, sz, allocsz, rrn, (unsigned int)3, queryts, cached, udp, cb, sva, ar);
        if(return_value_add_rrset_7 == 0)
          return 0;

        signed int return_value_add_rrset_8;
        return_value_add_rrset_8=add_rrset(ans, sz, allocsz, rrn, (unsigned int)4, queryts, cached, udp, cb, sva, ar);
        if(return_value_add_rrset_8 == 0)
          return 0;

      }

      else
        if(qtype == 255u)
        {
          signed int i;
          signed int n;
          signed int tmp_if_expr_9;
          if(!((1 & (signed int)cached->flags) == 0))
            tmp_if_expr_9 = 0;

          else
            tmp_if_expr_9 = cached->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
          n = tmp_if_expr_9;
          const unsigned short int *iterlist;
          const unsigned short int *tmp_if_expr_11;
          if(!((1 & (signed int)cached->flags) == 0))
            tmp_if_expr_11 = (const unsigned short int *)(void *)0;

          else
          {
            if(!(cached->_anon0.rr.rrext == ((struct anonymous **)NULL)))
              tmp_if_expr_10 = rrcachiterlist;

            else
              tmp_if_expr_10 = rrmuiterlist;
            tmp_if_expr_11 = tmp_if_expr_10;
          }
          iterlist = tmp_if_expr_11;
          i = 0;
          for( ; !(i >= n); i = i + 1)
          {
            signed int return_value_add_rrset_12;
            return_value_add_rrset_12=add_rrset(ans, sz, allocsz, rrn, (unsigned int)iterlist[(signed long int)i], queryts, cached, udp, cb, sva, ar);
            if(return_value_add_rrset_12 == 0)
              return 0;

          }
        }

        else
          if(qtype >= 1u && !(qtype >= 52u))
          {
            signed int return_value_add_rrset_13;
            return_value_add_rrset_13=add_rrset(ans, sz, allocsz, rrn, qtype, queryts, cached, udp, cb, sva, ar);
            if(return_value_add_rrset_13 == 0)
              return 0;

          }

          else
            return 0;
  return 1;
}

// addr_add
// file conf-parser.c line 1871
static const char * addr_add(struct anonymous_19 **ata, const char *ipstr)
{
  struct anonymous_20 *at;
  union anonymous_6 addr;
  if(cmdlineipv == 0)
    cmdlineipv = (signed short int)-2;

  signed int return_value_str2pdnsd_a_2;
  return_value_str2pdnsd_a_2=str2pdnsd_a(ipstr, &addr);
  signed int return_value_inet_pton_1;
  if(return_value_str2pdnsd_a_2 == 0)
  {
    if(!(run_ipv4 == 0))
    {
      return_value_inet_pton_1=inet_pton(10, ipstr, (void *)&addr.ipv6);
      if(return_value_inet_pton_1 >= 1)
      {
        fprintf(stderr, "IPv6 address \"%s\" in config file ignored while running in IPv4 mode.\n", ipstr);
        return (const char *)(void *)0;
      }

    }

    return "bad IP address";
  }

  struct anonymous_3 *return_value_da_grow1_3;
  return_value_da_grow1_3=da_grow1((struct anonymous_3 *)*ata, (unsigned long int)((struct anonymous_19 *)0)->elem, sizeof(struct anonymous_20) /*32ul*/ , (void (*)(void *))(void *)0);
  *ata = (struct anonymous_19 *)return_value_da_grow1_3;
  if(*ata == ((struct anonymous_19 *)NULL))
    return "out of memory!";

  else
  {
    at = &(*ata)->elem[(signed long int)((*ata)->nel - (unsigned long int)1)];
    SET_PDNSD_A2(&at->a, &addr);
    at->is_up = (char)0;
    at->i_ts = (signed long int)0;
    return (const char *)(void *)0;
  }
}

// adjust_dom_ttl
// file cache.c line 1840
static inline void adjust_dom_ttl(struct anonymous_0 *cent)
{
  if(!((8 & (signed int)cent->flags) == 0))
  {
    cent->flags = cent->flags & (unsigned short int)~8;
    cent->_anon0.neg.ttl = (signed long int)0;
  }

  else
  {
    signed long int min_ttl = global.min_ttl;
    signed long int neg_ttl = global.neg_ttl;
    if(!(neg_ttl >= min_ttl))
      min_ttl = neg_ttl;

    if(!(cent->_anon0.neg.ttl >= min_ttl))
      cent->_anon0.neg.ttl = min_ttl;

    else
    {
      signed long int max_ttl = global.max_ttl;
      if(!(max_ttl >= cent->_anon0.neg.ttl))
        cent->_anon0.neg.ttl = max_ttl;

    }
  }
}

// adjust_ttl
// file cache.c line 1817
static inline void adjust_ttl(struct anonymous *rrset)
{
  if(!((8 & (signed int)rrset->flags) == 0))
  {
    rrset->flags = rrset->flags & (unsigned short int)~8;
    rrset->ttl = (signed long int)0;
  }

  else
  {
    signed long int min_ttl = global.min_ttl;
    signed long int neg_ttl = global.neg_ttl;
    if(!((1 & (signed int)rrset->flags) == 0))
    {
      if(!(neg_ttl >= min_ttl))
        min_ttl = neg_ttl;

    }

    if(!(rrset->ttl >= min_ttl))
      rrset->ttl = min_ttl;

    else
    {
      signed long int max_ttl = global.max_ttl;
      if(!(max_ttl >= rrset->ttl))
        rrset->ttl = max_ttl;

    }
  }
}

// alloc_nel
// file list.c line 57
static inline unsigned long int alloc_nel(unsigned long int n)
{
  return n == (unsigned long int)0 ? (unsigned long int)8 : n + (unsigned long int)7 & (unsigned long int)~7;
}

// ans_ttl
// file dns_answer.c line 170
static inline signed long int ans_ttl(struct anonymous *rrset, signed long int queryts)
{
  signed long int ttl = rrset->ttl;
  if((2 & (signed int)rrset->flags) == 0)
  {
    signed long int tpassed = queryts - rrset->ts;
    if(!(tpassed >= 0l))
      tpassed = (signed long int)0;

    ttl = ttl - tpassed;
    if(!(ttl >= 0l))
      ttl = (signed long int)0;

  }

  return ttl;
}

// auth_ok
// file dns_query.c line 2554
static signed int auth_ok(struct anonymous_4 *q, const unsigned char *name, signed int thint, struct anonymous_0 *ent, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, struct anonymous_5 *qse, struct _dynamic_list_head *ns, struct anonymous_4 **serv)
{
  signed int retval = 0;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  signed int return_value_have_rr_2;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  const char *return_value_pdnsd_a2str_13;
  const unsigned char *return_value_rhn2str_14;
  const unsigned char *return_value_rhn2str_15;
  const unsigned char *return_value_rhn2str_17;
  const unsigned char *return_value_rhn2str_18;
  const unsigned char *return_value_rhn2str_19;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_22;
  const unsigned char *return_value_rhn2str_26;
  signed int return_value_equiv_inaddr2_44;
  const char *return_value_pdnsd_a2str_42;
  const char *return_value_pdnsd_a2str_49;
  if((signed int)qse->failed >= 2)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(!(qse->auth_serv == 0))
      tmp_if_expr_1 = !(((signed int)ent->flags & 1) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    _Bool tmp_if_expr_8;
    if(tmp_if_expr_1)
    {
      if(thint >= 251 && !(thint >= 256))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        if(thint >= 1 && !(thint >= 52))
        {
          return_value_have_rr_2=have_rr_link1(ent, thint);
          if(return_value_have_rr_2 == 0)
          {
            if((1 & (signed int)ent->flags) == 0)
              tmp_if_expr_3 = ent->_anon0.rr.rrmu[(signed long int)2] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
            if(tmp_if_expr_3)
              tmp_if_expr_4 = ent->_anon0.rr.rrmu[(signed long int)2]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            tmp_if_expr_5 = !tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_5 = (_Bool)0;
          tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(!tmp_if_expr_8)
      return 1;

    else
    {
      if(!(qse->aa == 0))
      {
        unsigned char *nsdomain;
        if(qse->nsdomain == ((const unsigned char *)NULL))
          return 1;

        void *return_value_dlist_first_9;
        return_value_dlist_first_9=dlist_first_link2(ns);
        nsdomain = (unsigned char *)return_value_dlist_first_9;
        if(nsdomain == ((unsigned char *)NULL))
          return 1;

        do
        {
          unsigned int rem;
          unsigned int crem;
          domain_match(nsdomain, qse->nsdomain, &rem, &crem);
          if(!(crem == 0u) || !(rem >= 1u))
            return 1;

          domain_match(nsdomain, name, &rem, (unsigned int *)(void *)0);
          if(!(rem == 0u))
            return 1;

          do
          {
            void *return_value_dlist_next_10;
            return_value_dlist_next_10=dlist_next_link2((void *)nsdomain);
            nsdomain = (unsigned char *)return_value_dlist_next_10;
            if(nsdomain == ((unsigned char *)NULL))
              goto done_checkauth;

          }
          while((signed int)*nsdomain == 0xff);
        }
        while((_Bool)1);

      done_checkauth:
        ;
        if(!(debug_p == 0))
        {
          unsigned char dbuf[256l];
          unsigned char sdbuf[256l];
          void *return_value_dlist_first_11;
          return_value_dlist_first_11=dlist_first_link2(ns);
          nsdomain = (unsigned char *)return_value_dlist_first_11;
          char _debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous_6 *tmp_if_expr_12;
            if(!(run_ipv4 == 0))
              tmp_if_expr_12 = (union anonymous_6 *)&qse->a.sin4.sin_addr;

            else
              tmp_if_expr_12 = (union anonymous_6 *)&qse->a.sin6.sin6_addr;
            return_value_pdnsd_a2str_13=pdnsd_a2str(tmp_if_expr_12, _debugsockabuf, 46);
            return_value_rhn2str_14=rhn2str(qse->nsdomain, dbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            return_value_rhn2str_15=rhn2str(nsdomain, sdbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            debug_msg(0, "The name server %s which is responsible for the %s domain, raised the aa flag, but appears to delegate to the sub-domain %s\n", return_value_pdnsd_a2str_13, return_value_rhn2str_14, return_value_rhn2str_15);
          }

        }

      }

      if(hops >= 1)
      {
        unsigned char *nsdomp;
        unsigned char *auth_ok__1__2__nsdomain = (unsigned char *)(void *)0;
        struct anonymous *localrrset = (struct anonymous *)(void *)0;
        struct rr_b_s *localrr = (struct rr_b_s *)(void *)0;
        void *return_value_dlist_first_16;
        return_value_dlist_first_16=dlist_first_link2(ns);
        nsdomp = (unsigned char *)return_value_dlist_first_16;
        do
        {
          unsigned char *nsname = (unsigned char *)(void *)0;
          struct anonymous_15 serva;
          if(!(localrr == ((struct rr_b_s *)NULL)))
          {
            nsname = (unsigned char *)localrr->data;
            localrr = localrr->next;
          }

          else
          {
            if(!(localrrset == ((struct anonymous *)NULL)))
            {
              del_rrset(localrrset);
              localrrset = (struct anonymous *)(void *)0;
            }

            if(nsdomp == ((unsigned char *)NULL))
              break;

            else
              if(!((signed int)*nsdomp == 0xff))
              {
                auth_ok__1__2__nsdomain = nsdomp;
                if(!(global.paranoid == 0))
                {
                  unsigned int auth_ok__1__2__1__1__2__2__1__rem;
                  domain_match(auth_ok__1__2__nsdomain, name, &auth_ok__1__2__1__1__2__2__1__rem, (unsigned int *)(void *)0);
                  if(!(auth_ok__1__2__1__1__2__2__1__rem == 0u))
                  {
                    unsigned char nmbuf[256l];
                    unsigned char auth_ok__1__2__1__1__2__2__1__1__dbuf[256l];
                    unsigned char nsbuf[256l];
                    if(!(debug_p == 0))
                    {
                      return_value_rhn2str_17=rhn2str(nsname, nsbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                      return_value_rhn2str_18=rhn2str(auth_ok__1__2__nsdomain, auth_ok__1__2__1__1__2__2__1__1__dbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                      return_value_rhn2str_19=rhn2str(name, nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                      debug_msg(0, "The name server %s is responsible for the %s domain, which does not match %s\n", return_value_rhn2str_17, return_value_rhn2str_18, return_value_rhn2str_19);
                    }

                    do
                    {
                      void *return_value_dlist_next_21;
                      return_value_dlist_next_21=dlist_next_link2((void *)nsdomp);
                      nsdomp = (unsigned char *)return_value_dlist_next_21;
                      if(!(nsdomp == ((unsigned char *)NULL)))
                        tmp_if_expr_20 = (signed int)*nsdomp == 0xff ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_20 = (_Bool)0;
                    }
                    while(tmp_if_expr_20);
                    continue;
                  }

                }

                localrrset=lookup_cache_local_rrset(auth_ok__1__2__nsdomain, 2);
                if(!(localrrset == ((struct anonymous *)NULL)))
                {
                  do
                  {
                    void *return_value_dlist_next_23;
                    return_value_dlist_next_23=dlist_next_link2((void *)nsdomp);
                    nsdomp = (unsigned char *)return_value_dlist_next_23;
                    if(!(nsdomp == ((unsigned char *)NULL)))
                      tmp_if_expr_22 = (signed int)*nsdomp == 0xff ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_22 = (_Bool)0;
                  }
                  while(tmp_if_expr_22);
                  localrr = localrrset->rrs;
                  if(localrr == ((struct rr_b_s *)NULL))
                    continue;

                  nsname = (unsigned char *)localrr->data;
                  localrr = localrr->next;
                }

                else
                {
                  nsname=skiprhn_link1(nsdomp);
                  void *return_value_dlist_next_24;
                  return_value_dlist_next_24=dlist_next_link2((void *)nsdomp);
                  nsdomp = (unsigned char *)return_value_dlist_next_24;
                }
              }

              else
              {
                nsname = nsdomp + (signed long int)1;
                void *return_value_dlist_next_25;
                return_value_dlist_next_25=dlist_next_link2((void *)nsdomp);
                nsdomp = (unsigned char *)return_value_dlist_next_25;
              }
          }
          if(run_ipv4 == 0)
            serva.ipv6 = in6addr_any;

          serva.ipv4.s_addr = (unsigned int)0x00000000;
          const unsigned char *nm = name;
          signed int tp = thint;
          struct qhintnode_s *auth_ok__1__2__1__1__3__ql = qhlist;
          do
          {
            signed int return_value_rhnicmp_27;
            return_value_rhnicmp_27=rhnicmp_link1(nm, nsname);
            if(!(return_value_rhnicmp_27 == 0))
            {
              if(tp == 1)
              {
                unsigned char _debugstrbuf[256l];
                if(!(debug_p == 0))
                {
                  return_value_rhn2str_26=rhn2str(nsname, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                  debug_msg(0, "Not looking up address for name server \"%s\": risk of infinite recursion.\n", return_value_rhn2str_26);
                }

                goto skip_server;
              }

            }

            if(auth_ok__1__2__1__1__3__ql == ((struct qhintnode_s *)NULL))
              break;

            nm = auth_ok__1__2__1__1__3__ql->nm;
            tp = auth_ok__1__2__1__1__3__ql->tp;
            auth_ok__1__2__1__1__3__ql = auth_ok__1__2__1__1__3__ql->next;
          }
          while((_Bool)1);
          struct qhintnode_s qhn = { .nm=name, .tp=thint, .next=qhlist };
          struct anonymous_0 *servent;
          signed long int return_value_time_33;
          return_value_time_33=time((signed long int *)(void *)0);
          signed int return_value_r_dns_cached_resolve_34;
          return_value_r_dns_cached_resolve_34=r_dns_cached_resolve(nsname, 1, &servent, hops - 1, &qhn, return_value_time_33, (unsigned char *)(void *)0);
          if(return_value_r_dns_cached_resolve_34 == 0)
          {
            if(!(run_ipv4 == 0))
            {
              struct anonymous *rrset;
              struct anonymous *tmp_if_expr_28;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr_28 = servent->_anon0.rr.rrmu[(signed long int)0];

              else
                tmp_if_expr_28 = (struct anonymous *)(void *)0;
              rrset = tmp_if_expr_28;
              if(!(rrset == ((struct anonymous *)NULL)))
              {
                if(!(rrset->rrs == ((struct rr_b_s *)NULL)))
                  serva.ipv4 = *((struct in_addr *)rrset->rrs->data);

              }

            }

            else
            {
              struct anonymous *auth_ok__1__2__1__1__3__2__1__2__rrset;
              struct anonymous *tmp_if_expr_31;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr_31 = servent->_anon0.rr.rrmu[(signed long int)7];

              else
                tmp_if_expr_31 = (struct anonymous *)(void *)0;
              auth_ok__1__2__1__1__3__2__1__2__rrset = tmp_if_expr_31;
              _Bool tmp_if_expr_32;
              if(!(auth_ok__1__2__1__1__3__2__1__2__rrset == ((struct anonymous *)NULL)))
                tmp_if_expr_32 = auth_ok__1__2__1__1__3__2__1__2__rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_32 = (_Bool)0;
              if(tmp_if_expr_32)
              {
                serva.ipv6 = *((struct in6_addr *)auth_ok__1__2__1__1__3__2__1__2__rrset->rrs->data);
                struct anonymous *tmp_if_expr_29;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr_29 = servent->_anon0.rr.rrmu[(signed long int)0];

                else
                  tmp_if_expr_29 = (struct anonymous *)(void *)0;
                auth_ok__1__2__1__1__3__2__1__2__rrset = tmp_if_expr_29;
                if(!(auth_ok__1__2__1__1__3__2__1__2__rrset == ((struct anonymous *)NULL)))
                {
                  if(!(auth_ok__1__2__1__1__3__2__1__2__rrset->rrs == ((struct rr_b_s *)NULL)))
                    serva.ipv4 = *((struct in_addr *)auth_ok__1__2__1__1__3__2__1__2__rrset->rrs->data);

                }

              }

              else
              {
                struct anonymous *tmp_if_expr_30;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr_30 = servent->_anon0.rr.rrmu[(signed long int)0];

                else
                  tmp_if_expr_30 = (struct anonymous *)(void *)0;
                auth_ok__1__2__1__1__3__2__1__2__rrset = tmp_if_expr_30;
                if(!(auth_ok__1__2__1__1__3__2__1__2__rrset == ((struct anonymous *)NULL)))
                {
                  if(!(auth_ok__1__2__1__1__3__2__1__2__rrset->rrs == ((struct rr_b_s *)NULL)))
                  {
                    struct in_addr *ina = (struct in_addr *)auth_ok__1__2__1__1__3__2__1__2__rrset->rrs->data;
                    ((unsigned int *)&serva.ipv6)[(signed long int)3] = ina->s_addr;
                    ((unsigned int *)&serva.ipv6)[(signed long int)2]=htonl((unsigned int)0xffff);
                    ((unsigned int *)&serva.ipv6)[(signed long int)0] = (unsigned int)0;
                    ((unsigned int *)&serva.ipv6)[(signed long int)1] = ((unsigned int *)&serva.ipv6)[(signed long int)0];
                  }

                }

              }
            }
            free_cent(servent);
            free((void *)servent);
          }

          signed int return_value_is_inaddr2_any_35;
          return_value_is_inaddr2_any_35=is_inaddr2_any(&serva);
          if(return_value_is_inaddr2_any_35 == 0)
          {
            union anonymous_6 *tmp_if_expr_36;
            if(!(run_ipv4 == 0))
              tmp_if_expr_36 = (union anonymous_6 *)&(&serva)->ipv4;

            else
              tmp_if_expr_36 = (union anonymous_6 *)&(&serva)->ipv6;
            signed int return_value_is_local_addr_37;
            return_value_is_local_addr_37=is_local_addr(tmp_if_expr_36);
            if(return_value_is_local_addr_37 == 0)
            {
              signed int i;
              signed int n;
              unsigned int return_value_da_nel_38;
              return_value_da_nel_38=da_nel_link2((struct anonymous_3 *)*serv);
              n = (signed int)return_value_da_nel_38;
              i = 0;
              for( ; !(i >= n); i = i + 1)
              {
                struct anonymous_5 *qs = &(*serv)->elem[(signed long int)i];
                signed int return_value_query_stat_same_inaddr2_39;
                return_value_query_stat_same_inaddr2_39=query_stat_same_inaddr2(qs, &serva);
                if(!(return_value_query_stat_same_inaddr2_39 == 0))
                  goto skip_server;

              }
              struct anonymous_4 *qa = q;
              struct qstatnode_s *ql = qslist;
              do
              {
                signed int auth_ok__1__2__1__1__5__1__1__i;
                signed int auth_ok__1__2__1__1__5__1__1__n;
                unsigned int return_value_da_nel_40;
                return_value_da_nel_40=da_nel_link2((struct anonymous_3 *)qa);
                auth_ok__1__2__1__1__5__1__1__n = (signed int)return_value_da_nel_40;
                auth_ok__1__2__1__1__5__1__1__i = 0;
                for( ; !(auth_ok__1__2__1__1__5__1__1__i >= auth_ok__1__2__1__1__5__1__1__n); auth_ok__1__2__1__1__5__1__1__i = auth_ok__1__2__1__1__5__1__1__i + 1)
                {
                  struct anonymous_5 *auth_ok__1__2__1__1__5__1__1__1__1__qs = &qa->elem[(signed long int)auth_ok__1__2__1__1__5__1__1__i];
                  if((signed int)auth_ok__1__2__1__1__5__1__1__1__1__qs->state == 8)
                  {
                    union anonymous_6 *tmp_if_expr_43;
                    if(!(run_ipv4 == 0))
                      tmp_if_expr_43 = (union anonymous_6 *)&auth_ok__1__2__1__1__5__1__1__1__1__qs->a.sin4.sin_addr;

                    else
                      tmp_if_expr_43 = (union anonymous_6 *)&auth_ok__1__2__1__1__5__1__1__1__1__qs->a.sin6.sin6_addr;
                    return_value_equiv_inaddr2_44=equiv_inaddr2_link1(tmp_if_expr_43, &serva);
                    if(!(return_value_equiv_inaddr2_44 == 0))
                    {
                      char auth_ok__1__2__1__1__5__1__1__1__1__1__1___debugsockabuf[46l];
                      if(!(debug_p == 0))
                      {
                        union anonymous_6 *tmp_if_expr_41;
                        if(!(run_ipv4 == 0))
                          tmp_if_expr_41 = (union anonymous_6 *)&(&serva)->ipv4;

                        else
                          tmp_if_expr_41 = (union anonymous_6 *)&(&serva)->ipv6;
                        return_value_pdnsd_a2str_42=pdnsd_a2str(tmp_if_expr_41, auth_ok__1__2__1__1__5__1__1__1__1__1__1___debugsockabuf, 46);
                        debug_msg(0, "Not trying name server %s, already queried.\n", return_value_pdnsd_a2str_42);
                      }

                      goto skip_server;
                    }

                  }

                }
                if(ql == ((struct qstatnode_s *)NULL))
                  break;

                qa = ql->qa;
                ql = ql->next;
              }
              while((_Bool)1);
              _Bool tmp_if_expr_45;
              if(!(qse->rejectlist == ((struct rejectlist_s *)NULL)))
                tmp_if_expr_45 = qse->rejectlist->inherit != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_45 = (_Bool)0;
              struct rejectlist_s *tmp_if_expr_46;
              if(tmp_if_expr_45)
                tmp_if_expr_46 = qse->rejectlist;

              else
                tmp_if_expr_46 = (struct rejectlist_s *)(void *)0;
              signed int return_value_add_qserv_47;
              return_value_add_qserv_47=add_qserv(serv, &serva, 53, qse->timeout, (unsigned int)((signed int)qse->flags & ~(2 | 4 | 16 | 64)), 0, qse->lean_query, qse->edns_query, (char)2, (char)0, (char)!(global.paranoid != 0), auth_ok__1__2__nsdomain, tmp_if_expr_46);
              if(return_value_add_qserv_47 == 0)
                return -1;

              retval = 1;
            }

          }


        skip_server:
          ;
        }
        while((_Bool)1);
        if(retval == 0)
        {
          char auth_ok__1__2__2__1___debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous_6 *tmp_if_expr_48;
            if(!(run_ipv4 == 0))
              tmp_if_expr_48 = (union anonymous_6 *)&qse->a.sin4.sin_addr;

            else
              tmp_if_expr_48 = (union anonymous_6 *)&qse->a.sin6.sin6_addr;
            return_value_pdnsd_a2str_49=pdnsd_a2str(tmp_if_expr_48, auth_ok__1__2__2__1___debugsockabuf, 46);
            debug_msg(0, "No remaining authoritative name servers to try in authority section from %s.\n", return_value_pdnsd_a2str_49);
          }

        }

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "Maximum hops count reached; not trying any more name servers.\n");

      return retval;
    }
  }
}

// bind_socket
// file dns_query.c line 682
static signed int bind_socket(signed int s)
{
  signed int query_port_start = global.query_port_start;
  signed int query_port_end = global.query_port_end;
  signed int *return_value___errno_location_4;
  if(query_port_start >= 0)
  {
    /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'sin4'|lSYM#tag-sockaddr_in6#'sin6'] */
union anonymous_22
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

/* */
    ;
    union anonymous_22 sin;
    unsigned int sinl;
    signed int prt;
    signed int pstart;
    signed int range = (query_port_end - query_port_start) + 1;
    signed int m = 0xffff;
    unsigned int try1;
    unsigned int try2;
    unsigned int maxtry2;
    if(range >= 65537 || !(range >= 1))
    {
      log_message(4, "Illegal port range in %s line %d, dropping query!\n", (const void *)"dns_query.c", 704);
      return 0;
    }

    if(!(range >= 32769))
    {
      m = 1;
      for( ; !(m >= range); m = m << 1)
        ;
      m = m - 1;
    }

    try2 = (unsigned int)0;
    maxtry2 = (unsigned int)(range * 2);
    do
    {
      try1 = (unsigned int)0;
      do
      {
        unsigned short int return_value_get_rand16_1;
        return_value_get_rand16_1=get_rand16();
        prt = (signed int)return_value_get_rand16_1 & m;
        if(!(prt >= range))
          break;

        try1 = try1 + 1u;
        if(try1 >= 65536u)
        {
          log_message(4, "Cannot get random number < range after %d tries in %s line %d, bad random number generator?\n", try1, (const void *)"dns_query.c", 723);
          return 0;
        }

      }
      while((_Bool)1);
      prt = prt + query_port_start;
      pstart = prt;
      while((_Bool)1)
      {
        if(!(run_ipv4 == 0))
        {
          memset((void *)&sin.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
          sin.sin4.sin_family = (unsigned short int)2;
          sin.sin4.sin_port=htons((unsigned short int)prt);
          sin.sin4.sin_addr = global.out_a.ipv4;
          sinl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        }

        else
        {
          memset((void *)&sin.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
          sin.sin6.sin6_family = (unsigned short int)10;
          sin.sin6.sin6_port=htons((unsigned short int)prt);
          sin.sin6.sin6_flowinfo = (unsigned int)0;
          sin.sin6.sin6_addr = global.out_a.ipv6;
          sinl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
        }
        signed int return_value_bind_6;
        return_value_bind_6=bind(s, (struct sockaddr *)&sin, sinl);
        if(return_value_bind_6 == -1)
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          if(!(*return_value___errno_location_5 == 98))
          {
            return_value___errno_location_4=__errno_location();
            if(!(*return_value___errno_location_4 == 99))
            {
              signed int *return_value___errno_location_2;
              return_value___errno_location_2=__errno_location();
              char *return_value_strerror_3;
              return_value_strerror_3=strerror(*return_value___errno_location_2);
              log_message(4, "Could not bind to socket: %s\n", return_value_strerror_3);
              return 0;
            }

          }

        }

        else
          goto done;
        try2 = try2 + 1u;
        if(try2 >= maxtry2)
        {
          prt = prt + 1;
          if(!(query_port_end >= prt))
            prt = query_port_start;

          if(prt == pstart)
          {
            log_message(4, "Out of ports in the range %d-%d, dropping query!\n", query_port_start, query_port_end);
            return 0;
          }

        }

        else
          break;
      }
    }
    while((_Bool)1);
  }


done:
  ;
  return 1;
}

// binsearch_keyword
// file consts.h line 65
signed int binsearch_keyword(const char *name, signed int len, const struct anonymous_32 *dic, signed int range)
{
  signed int i = 0;
  signed int j = range;
  while(!(i >= j))
  {
    signed int k = (i + j) / 2;
    signed int cmp;
    cmp=keyncmp(name, len, (dic + (signed long int)k)->name);
    if(!(cmp >= 0))
      j = k;

    else
      if(cmp >= 1)
        i = k + 1;

      else
        return (dic + (signed long int)k)->val;
  }
  return 0;
}

// change_servers
// file servers.h line 45
signed int change_servers(signed int i, struct anonymous_54 *ar, signed int up)
{
  signed int retval = 0;
  signed int j;
  signed int change;
  signed int signal_test;
  signed int n;
  struct anonymous_7 *sp;
  pthread_mutex_lock(&servers_lock);
  signal_test = 0;
  change = 0;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link5((struct anonymous_3 *)ar);
  n = (signed int)return_value_da_nel_1;
  sp = &servers->elem[(signed long int)i];
  unsigned int return_value_da_nel_3;
  return_value_da_nel_3=da_nel_link5((struct anonymous_3 *)sp->atup_a);
  _Bool tmp_if_expr_4;
  if(!((unsigned int)n == return_value_da_nel_3))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)sp->rootserver > 1 ? (_Bool)1 : (_Bool)0;
  signed int return_value_same_inaddr2_2;
  if(tmp_if_expr_4)
    change = 1;

  else
  {
    signed int change_servers__1__1__j = 0;
    for( ; !(change_servers__1__1__j >= n); change_servers__1__1__j = change_servers__1__1__j + 1)
    {
      return_value_same_inaddr2_2=same_inaddr2(&ar->elem[(signed long int)change_servers__1__1__j], &sp->atup_a->elem[(signed long int)change_servers__1__1__j].a);
      if(return_value_same_inaddr2_2 == 0)
      {
        change = 1;
        break;
      }

    }
  }
  signed int return_value_pthread_equal_6;
  char *return_value_strerror_5;
  if(!(change == 0))
  {
    struct timeval now;
    struct timespec timeout;
    struct anonymous_19 *ata;
    if(server_status_ping >= 1)
    {
      return_value_pthread_equal_6=pthread_equal(servstat_thrid, main_thrid);
      if(return_value_pthread_equal_6 == 0)
      {
        signed int err;
        if(!(debug_p == 0))
          debug_msg(0, "Sending server status thread an interrupt signal.\n");

        err=pthread_kill(servstat_thrid, 1);
        if(!(err == 0))
        {
          if(!(debug_p == 0))
          {
            return_value_strerror_5=strerror(err);
            debug_msg(0, "pthread_kill failed: %s\n", return_value_strerror_5);
          }

        }

      }

    }

    if(!(debug_p == 0))
      debug_msg(0, "Changing IPs of server section #%d\n", i);

    gettimeofday(&now, (struct timezone *)(void *)0);
    timeout.tv_sec = now.tv_sec + (signed long int)60;
    timeout.tv_nsec = now.tv_usec * (signed long int)1000;
    while(server_data_users >= 1)
    {
      signed int return_value_pthread_cond_timedwait_7;
      return_value_pthread_cond_timedwait_7=pthread_cond_timedwait(&server_data_cond, &servers_lock, &timeout);
      if(return_value_pthread_cond_timedwait_7 == 110)
      {
        retval = 110;
        goto unlock_mutex;
      }

    }
    struct anonymous_3 *return_value_da_resize_8;
    return_value_da_resize_8=da_resize((struct anonymous_3 *)(void *)0, (unsigned long int)((struct anonymous_19 *)0)->elem, sizeof(struct anonymous_20) /*32ul*/ , (unsigned long int)n, (void (*)(void *))(void *)0);
    ata = (struct anonymous_19 *)return_value_da_resize_8;
    if(ata == ((struct anonymous_19 *)NULL))
    {
      log_message(4, "Out of memory in change_servers().");
      retval = 12;
      goto unlock_mutex;
    }

    free((void *)sp->atup_a);
    sp->atup_a = ata;
    if((signed int)sp->rootserver >= 2)
      sp->rootserver = (char)1;

  }

  j = 0;
  for( ; !(j >= n); j = j + 1)
  {
    struct anonymous_20 *at = &sp->atup_a->elem[(signed long int)j];
    if(!(change == 0))
    {
      SET_PDNSD_A2_link1(&at->a, &ar->elem[(signed long int)j]);
      at->is_up = sp->preset;
    }

    if(up >= 0)
    {
      at->is_up = (char)up;
      at->i_ts=time((signed long int *)(void *)0);
    }

    else
    {
      _Bool tmp_if_expr_9;
      if(!(change == 0))
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = at->i_ts != 0l ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_9)
      {
        at->i_ts = (signed long int)0;
        signal_test = 1;
      }

    }
  }
  if(!(signal_test == 0))
  {
    signed int return_value_pthread_equal_10;
    return_value_pthread_equal_10=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal_10 == 0))
      retval=start_servstat_thread();

    else
    {
      retest_flag = (signed short int)1;
      retval=pthread_cond_signal(&server_test_cond);
    }
  }


unlock_mutex:
  ;
  pthread_mutex_unlock(&servers_lock);
  return retval;
}

// check_ipv6
// file main.c line 202
static signed int check_ipv6()
{
  signed int fd;
  fd=socket(10, 1, 0);
  signed int *return_value___errno_location_2;
  signed int *return_value___errno_location_4;
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    _Bool tmp_if_expr_3;
    if(*return_value___errno_location_1 == 93)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 97 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_5;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___errno_location_4=__errno_location();
      tmp_if_expr_5 = *return_value___errno_location_4 == 22 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return 0;

    return -1;
  }

  close(fd);
  return 1;
}

// check_localaddrs
// file conf-parser.c line 1976
static void check_localaddrs(struct anonymous_7 *serv)
{
  struct anonymous_3 *return_value_da_resize_10;
  if((signed int)serv->port == global.port)
  {
    struct anonymous_19 *ata = serv->atup_a;
    signed int i;
    signed int j = 0;
    signed int n;
    unsigned int return_value_da_nel_1;
    return_value_da_nel_1=da_nel((struct anonymous_3 *)ata);
    n = (signed int)return_value_da_nel_1;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous_20 *at = &ata->elem[(signed long int)i];
      signed int return_value_is_inaddr_any_9;
      return_value_is_inaddr_any_9=is_inaddr_any(&global.a);
      if(!(return_value_is_inaddr_any_9 == 0))
      {
        union anonymous_6 *tmp_if_expr_4;
        if(!(run_ipv4 == 0))
          tmp_if_expr_4 = (union anonymous_6 *)&(&at->a)->ipv4;

        else
          tmp_if_expr_4 = (union anonymous_6 *)&(&at->a)->ipv6;
        signed int return_value_is_local_addr_5;
        return_value_is_local_addr_5=is_local_addr(tmp_if_expr_4);
        if(!(return_value_is_local_addr_5 == 0))
        {
          char buf[46l];
          union anonymous_6 *tmp_if_expr_2;
          if(!(run_ipv4 == 0))
            tmp_if_expr_2 = (union anonymous_6 *)&(&at->a)->ipv4;

          else
            tmp_if_expr_2 = (union anonymous_6 *)&(&at->a)->ipv6;
          const char *return_value_pdnsd_a2str_3;
          return_value_pdnsd_a2str_3=pdnsd_a2str(tmp_if_expr_2, buf, 46);
          fprintf(stderr, "Local name-server address \"%s\" ignored in config file.\n", return_value_pdnsd_a2str_3);
          goto __CPROVER_DUMP_L13;
        }

      }

      else
      {
        signed int return_value_equiv_inaddr2_8;
        return_value_equiv_inaddr2_8=equiv_inaddr2(&global.a, &at->a);
        if(!(return_value_equiv_inaddr2_8 == 0))
        {
          char check_localaddrs__1__1__1__1__2__1__buf[46l];
          union anonymous_6 *tmp_if_expr_6;
          if(!(run_ipv4 == 0))
            tmp_if_expr_6 = (union anonymous_6 *)&(&at->a)->ipv4;

          else
            tmp_if_expr_6 = (union anonymous_6 *)&(&at->a)->ipv6;
          const char *return_value_pdnsd_a2str_7;
          return_value_pdnsd_a2str_7=pdnsd_a2str(tmp_if_expr_6, check_localaddrs__1__1__1__1__2__1__buf, 46);
          fprintf(stderr, "Ignoring name-server address \"%s\" in config file (identical to server_ip address).\n", return_value_pdnsd_a2str_7);
          goto __CPROVER_DUMP_L13;
        }

      }
      if(!(j >= i))
        ata->elem[(signed long int)j] = *at;

      j = j + 1;

    __CPROVER_DUMP_L13:
      ;
    }
    if(!(j >= n))
    {
      return_value_da_resize_10=da_resize((struct anonymous_3 *)ata, (unsigned long int)((struct anonymous_19 *)0)->elem, sizeof(struct anonymous_20) /*32ul*/ , (unsigned long int)j, (void (*)(void *))(void *)0);
      serv->atup_a = (struct anonymous_19 *)return_value_da_resize_10;
    }

  }

}

// compose_answer
// file dns_answer.c line 752
static struct anonymous_28 * compose_answer(struct anonymous_40 *ql, struct anonymous_29 *hdr, unsigned long int *rlen, struct anonymous_17 *ednsinfo, unsigned int *udp, signed int *rcodep)
{
  unsigned short int rcode = (unsigned short int)0;
  unsigned short int aa = (unsigned short int)1;
  struct _dynamic_list_head *cb = (struct _dynamic_list_head *)(void *)0;
  struct _dynamic_list_head *sva = (struct _dynamic_list_head *)(void *)0;
  struct _dynamic_list_head *ar = (struct _dynamic_list_head *)(void *)0;
  signed long int queryts;
  queryts=time((signed long int *)(void *)0);
  struct anonymous_70 *qe;
  struct anonymous_28 *ans;
  unsigned long int allocsz = (unsigned long int)256;
  struct anonymous_0 *cached;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(allocsz);
  ans = (struct anonymous_28 *)return_value_malloc_1;
  void *return_value_llist_next_3;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_18;
  void *return_value_llist_next_12;
  const unsigned char *return_value_skipsegs_25;
  _Bool tmp_if_expr_60;
  _Bool tmp_if_expr_62;
  signed int return_value_have_rr_61;
  signed int return_value_follow_cname_chain_64;
  signed int return_value_have_rr_29;
  _Bool tmp_if_expr_34;
  _Bool tmp_if_expr_31;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_33;
  _Bool tmp_if_expr_38;
  _Bool tmp_if_expr_35;
  _Bool tmp_if_expr_36;
  _Bool tmp_if_expr_37;
  _Bool tmp_if_expr_42;
  _Bool tmp_if_expr_39;
  _Bool tmp_if_expr_40;
  _Bool tmp_if_expr_41;
  _Bool tmp_if_expr_47;
  _Bool tmp_if_expr_44;
  _Bool tmp_if_expr_45;
  _Bool tmp_if_expr_46;
  _Bool tmp_if_expr_51;
  _Bool tmp_if_expr_48;
  _Bool tmp_if_expr_49;
  _Bool tmp_if_expr_50;
  const unsigned char *return_value_skipsegs_54;
  void *return_value_llist_next_21;
  void *return_value_dlist_next_67;
  void *return_value_dlist_next_72;
  if(!(ans == ((struct anonymous_28 *)NULL)))
  {
    ans->hdr.id = hdr->id;
    ans->hdr.qr = (unsigned int)1;
    ans->hdr.opcode = (unsigned int)0;
    ans->hdr.aa = (unsigned int)0;
    ans->hdr.tc = (unsigned int)0;
    ans->hdr.rd = (unsigned int)hdr->rd;
    ans->hdr.ra = (unsigned int)1;
    ans->hdr.z = (unsigned int)0;
    ans->hdr.ad = (unsigned int)0;
    ans->hdr.cd = (unsigned int)0;
    ans->hdr.rcode = (unsigned int)rcode;
    ans->hdr.qdcount = (unsigned short int)0;
    ans->hdr.ancount = (unsigned short int)0;
    ans->hdr.nscount = (unsigned short int)0;
    ans->hdr.arcount = (unsigned short int)0;
    *rlen = sizeof(struct anonymous_29) /*12ul*/ ;
    void *return_value_llist_first_2;
    return_value_llist_first_2=llist_first(ql);
    qe = (struct anonymous_70 *)return_value_llist_first_2;
    for( ; !(qe == ((struct anonymous_70 *)NULL)); qe = (struct anonymous_70 *)return_value_llist_next_3)
    {
      unsigned int qclen;
      unsigned long int newsz;
      unsigned int return_value_rhnlen_4;
      return_value_rhnlen_4=rhnlen_link2(qe->query);
      newsz = (unsigned long int)2 + *rlen + (unsigned long int)return_value_rhnlen_4 + (unsigned long int)4;
      if(!(allocsz >= newsz))
      {
        unsigned long int newallocsz = newsz + (unsigned long int)0x7f & ~((unsigned long int)0x7f);
        struct anonymous_28 *newans;
        void *return_value_realloc_5;
        return_value_realloc_5=realloc((void *)ans, newallocsz);
        newans = (struct anonymous_28 *)return_value_realloc_5;
        if(newans == ((struct anonymous_28 *)NULL))
          goto error_ans;

        ans = newans;
        allocsz = newallocsz;
      }

      unsigned char *p = (unsigned char *)&ans->hdr + (signed long int)*rlen;
      qclen=compress_name(qe->query, p, (unsigned int)*rlen, &cb);
      if(qclen == 0u)
        goto error_ans;

      p = p + (signed long int)qclen;
      do
      {
        unsigned short int t_s = (unsigned short int)qe->qtype;
        unsigned char *t_cp = (unsigned char *)p;
        unsigned char *tmp_post_6 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post_6 = (unsigned char)((signed int)t_s >> 8);
        unsigned char *tmp_post_7 = t_cp;
        t_cp = t_cp + 1l;
        *tmp_post_7 = (unsigned char)t_s;
        p = (unsigned char *)(void *)t_cp;
      }
      while((_Bool)0);
      do
      {
        unsigned short int compose_answer__1__1__1__2__2__t_s = (unsigned short int)qe->qclass;
        unsigned char *compose_answer__1__1__1__2__2__t_cp = (unsigned char *)p;
        unsigned char *tmp_post_8 = compose_answer__1__1__1__2__2__t_cp;
        compose_answer__1__1__1__2__2__t_cp = compose_answer__1__1__1__2__2__t_cp + 1l;
        *tmp_post_8 = (unsigned char)((signed int)compose_answer__1__1__1__2__2__t_s >> 8);
        unsigned char *tmp_post_9 = compose_answer__1__1__1__2__2__t_cp;
        compose_answer__1__1__1__2__2__t_cp = compose_answer__1__1__1__2__2__t_cp + 1l;
        *tmp_post_9 = (unsigned char)compose_answer__1__1__1__2__2__t_s;
        p = (unsigned char *)(void *)compose_answer__1__1__1__2__2__t_cp;
      }
      while((_Bool)0);
      *rlen = *rlen + (unsigned long int)(qclen + (unsigned int)4);
      unsigned short int return_value_ntohs_10;
      return_value_ntohs_10=ntohs(ans->hdr.qdcount);
      ans->hdr.qdcount=htons((unsigned short int)((signed int)return_value_ntohs_10 + 1));
      return_value_llist_next_3=llist_next((void *)qe);
    }
    void *return_value_llist_first_11;
    return_value_llist_first_11=llist_first(ql);
    qe = (struct anonymous_70 *)return_value_llist_first_11;
    for( ; !(qe == ((struct anonymous_70 *)NULL)); qe = (struct anonymous_70 *)return_value_llist_next_12)
    {
      _Bool tmp_if_expr_13;
      if(!((signed int)qe->qtype >= 1))
        tmp_if_expr_13 = (_Bool)1;

      else
        tmp_if_expr_13 = (signed int)qe->qtype > 51 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_14;
      if(tmp_if_expr_13)
        tmp_if_expr_14 = (_Bool)1;

      else
        tmp_if_expr_14 = (signed int)rrlkuptab[(signed long int)((signed int)qe->qtype - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_17;
      if(tmp_if_expr_14)
      {
        if(!((signed int)qe->qtype == 253))
          tmp_if_expr_15 = (signed int)qe->qtype != 254 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_15 = (_Bool)0;
        if(tmp_if_expr_15)
          tmp_if_expr_16 = (signed int)qe->qtype != 255 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_16 = (_Bool)0;
        tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_17 = (_Bool)0;
      _Bool tmp_if_expr_19;
      if(tmp_if_expr_17)
        tmp_if_expr_19 = (_Bool)1;

      else
      {
        if(!((signed int)qe->qclass == 1))
          tmp_if_expr_18 = (signed int)qe->qclass != 255 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_18 = (_Bool)0;
        tmp_if_expr_19 = tmp_if_expr_18 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_19)
      {
        if(!(debug_p == 0))
          debug_msg(0, "Unsupported QTYPE or QCLASS.\n");

        rcode = (unsigned short int)4;
        ans->hdr.rcode = (unsigned int)rcode;
        goto cleanup_return;
      }

      return_value_llist_next_12=llist_next((void *)qe);
    }
    void *return_value_llist_first_20;
    return_value_llist_first_20=llist_first(ql);
    qe = (struct anonymous_70 *)return_value_llist_first_20;
    for( ; !(qe == ((struct anonymous_70 *)NULL)); qe = (struct anonymous_70 *)return_value_llist_next_21)
    {
      signed int hops;
      unsigned char qname[256l];
      rhncpy(qname, qe->query);
      hops = 20;
      do
      {
        signed int rc;
        unsigned char c_soa = (unsigned char)0xff;
        rc=r_dns_cached_resolve(qname, (signed int)qe->qtype, &cached, 20, (struct qhintnode_s *)(void *)0, queryts, &c_soa);
        if(!(rc == 0))
        {
          rcode = (unsigned short int)rc;
          ans->hdr.rcode = (unsigned int)rcode;
          if(rc == 3)
          {
            if(!((signed int)c_soa == 0xff))
            {
              unsigned int scnt;
              scnt=rhnsegcnt(qname);
              if(!((unsigned int)c_soa >= scnt))
              {
                return_value_skipsegs_25=skipsegs(qname, scnt - (unsigned int)c_soa);
                cached=lookup_cache(return_value_skipsegs_25, (signed int *)(void *)0);
                if(!(cached == ((struct anonymous_0 *)NULL)))
                {
                  struct anonymous *rrset;
                  struct anonymous *tmp_if_expr_22;
                  if((1 & (signed int)cached->flags) == 0)
                    tmp_if_expr_22 = cached->_anon0.rr.rrmu[(signed long int)3];

                  else
                    tmp_if_expr_22 = (struct anonymous *)(void *)0;
                  rrset = tmp_if_expr_22;
                  if(!(rrset == ((struct anonymous *)NULL)))
                  {
                    if((1 & (signed int)rrset->flags) == 0)
                    {
                      struct rr_b_s *rr = rrset->rrs;
                      for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
                      {
                        signed long int return_value_ans_ttl_23;
                        return_value_ans_ttl_23=ans_ttl(rrset, queryts);
                        signed int return_value_add_rr_24;
                        return_value_add_rr_24=add_rr(&ans, rlen, &allocsz, cached->qname, (unsigned short int)6, (unsigned int)return_value_ans_ttl_23, rr->rdlen, (void *)rr->data, (char)2, udp, &cb);
                        if(return_value_add_rr_24 == 0)
                          goto error_cached;

                      }
                    }

                  }

                  free_cent(cached);
                  free((void *)cached);
                }

              }

            }

            if(!(ednsinfo == ((struct anonymous_17 *)NULL)))
            {
              signed int return_value_add_opt_pseudo_rr_26;
              return_value_add_opt_pseudo_rr_26=add_opt_pseudo_rr(&ans, rlen, &allocsz, (unsigned short int)global.udpbufsize, rcode, (unsigned short int)0, (unsigned short int)0);
              if(return_value_add_opt_pseudo_rr_26 == 0)
                goto error_ans;

            }

          }

          goto cleanup_return;
        }

        if((2 & (signed int)cached->flags) == 0)
          aa = (unsigned short int)0;

        signed int return_value_add_to_response_27;
        return_value_add_to_response_27=add_to_response(&ans, rlen, &allocsz, qname, (unsigned int)qe->qtype, queryts, cached, udp, &cb, &sva, &ar);
        if(return_value_add_to_response_27 == 0)
          goto error_cached;

        _Bool tmp_if_expr_58;
        if(!(hdr->rd == 0u))
          tmp_if_expr_58 = (signed int)qe->qtype != 5 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_58 = (_Bool)0;
        _Bool tmp_if_expr_59;
        if(tmp_if_expr_58)
          tmp_if_expr_59 = (signed int)qe->qtype != 255 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_59 = (_Bool)0;
        _Bool tmp_if_expr_63;
        if(tmp_if_expr_59)
        {
          if((signed int)qe->qtype >= 1)
            tmp_if_expr_60 = (signed int)qe->qtype <= 51 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_60 = (_Bool)0;
          if(tmp_if_expr_60)
          {
            return_value_have_rr_61=have_rr(cached, (signed int)qe->qtype);
            tmp_if_expr_62 = return_value_have_rr_61 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_62 = (_Bool)0;
          tmp_if_expr_63 = !tmp_if_expr_62 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_63 = (_Bool)0;
        _Bool tmp_if_expr_65;
        if(tmp_if_expr_63)
        {
          return_value_follow_cname_chain_64=follow_cname_chain(cached, qname);
          tmp_if_expr_65 = return_value_follow_cname_chain_64 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_65 = (_Bool)0;
        if(!tmp_if_expr_65)
        {
          struct anonymous *compose_answer__1__3__1__1__2__rrset;
          signed int rretp = 2;
          _Bool tmp_if_expr_28;
          if((signed int)qe->qtype >= 1)
            tmp_if_expr_28 = (signed int)qe->qtype <= 51 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_28 = (_Bool)0;
          _Bool tmp_if_expr_30;
          if(tmp_if_expr_28)
          {
            return_value_have_rr_29=have_rr(cached, (signed int)qe->qtype);
            tmp_if_expr_30 = !(return_value_have_rr_29 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_30 = (_Bool)0;
          _Bool tmp_if_expr_43;
          if(tmp_if_expr_30)
            tmp_if_expr_43 = (_Bool)1;

          else
          {
            if((signed int)qe->qtype == 253)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr_31 = cached->_anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_31 = (_Bool)0;
              if(tmp_if_expr_31)
                tmp_if_expr_32 = cached->_anon0.rr.rrext[(signed long int)2] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_32 = (_Bool)0;
              if(tmp_if_expr_32)
                tmp_if_expr_33 = cached->_anon0.rr.rrext[(signed long int)2]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_33 = (_Bool)0;
              tmp_if_expr_34 = !tmp_if_expr_33 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_34 = (_Bool)0;
            if(tmp_if_expr_34)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr_35 = cached->_anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_35 = (_Bool)0;
              if(tmp_if_expr_35)
                tmp_if_expr_36 = cached->_anon0.rr.rrext[(signed long int)3] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_36 = (_Bool)0;
              if(tmp_if_expr_36)
                tmp_if_expr_37 = cached->_anon0.rr.rrext[(signed long int)3]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_37 = (_Bool)0;
              tmp_if_expr_38 = !tmp_if_expr_37 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_38 = (_Bool)0;
            if(tmp_if_expr_38)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr_39 = cached->_anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_39 = (_Bool)0;
              if(tmp_if_expr_39)
                tmp_if_expr_40 = cached->_anon0.rr.rrext[(signed long int)4] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_40 = (_Bool)0;
              if(tmp_if_expr_40)
                tmp_if_expr_41 = cached->_anon0.rr.rrext[(signed long int)4]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_41 = (_Bool)0;
              tmp_if_expr_42 = !tmp_if_expr_41 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_42 = (_Bool)0;
            tmp_if_expr_43 = tmp_if_expr_42 ? (_Bool)1 : (_Bool)0;
          }
          _Bool tmp_if_expr_52;
          if(tmp_if_expr_43)
            tmp_if_expr_52 = (_Bool)1;

          else
          {
            if((signed int)qe->qtype == 254)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr_44 = cached->_anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_44 = (_Bool)0;
              if(tmp_if_expr_44)
                tmp_if_expr_45 = cached->_anon0.rr.rrext[(signed long int)0] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_45 = (_Bool)0;
              if(tmp_if_expr_45)
                tmp_if_expr_46 = cached->_anon0.rr.rrext[(signed long int)0]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_46 = (_Bool)0;
              tmp_if_expr_47 = !tmp_if_expr_46 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_47 = (_Bool)0;
            if(tmp_if_expr_47)
            {
              if((1 & (signed int)cached->flags) == 0)
                tmp_if_expr_48 = cached->_anon0.rr.rrext != ((struct anonymous **)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_48 = (_Bool)0;
              if(tmp_if_expr_48)
                tmp_if_expr_49 = cached->_anon0.rr.rrext[(signed long int)1] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_49 = (_Bool)0;
              if(tmp_if_expr_49)
                tmp_if_expr_50 = cached->_anon0.rr.rrext[(signed long int)1]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_50 = (_Bool)0;
              tmp_if_expr_51 = !tmp_if_expr_50 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_51 = (_Bool)0;
            tmp_if_expr_52 = tmp_if_expr_51 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_52)
            rretp = 6;

          compose_answer__1__3__1__1__2__rrset=getrrset(cached, rretp);
          if(!(compose_answer__1__3__1__1__2__rrset == ((struct anonymous *)NULL)))
          {
            if(!((1 & (signed int)compose_answer__1__3__1__1__2__rrset->flags) == 0))
              compose_answer__1__3__1__1__2__rrset = (struct anonymous *)(void *)0;

          }

          if(compose_answer__1__3__1__1__2__rrset == ((struct anonymous *)NULL))
          {
            struct anonymous_0 *prev = cached;
            unsigned int compose_answer__1__3__1__1__2__2__scnt;
            compose_answer__1__3__1__1__2__2__scnt=rhnsegcnt(prev->qname);
            unsigned int tcnt;
            signed int tmp_if_expr_53;
            if(rretp == 2)
              tmp_if_expr_53 = (signed int)prev->c_ns;

            else
              tmp_if_expr_53 = (signed int)prev->c_soa;
            tcnt = (unsigned int)tmp_if_expr_53;
            const unsigned char *tmp_if_expr_55;
            if(!(tcnt == 255u) && !(tcnt >= compose_answer__1__3__1__1__2__2__scnt))
            {
              return_value_skipsegs_54=skipsegs(prev->qname, compose_answer__1__3__1__1__2__2__scnt - tcnt);
              tmp_if_expr_55 = return_value_skipsegs_54;
            }

            else
              tmp_if_expr_55 = prev->qname;
            cached=lookup_cache(tmp_if_expr_55, (signed int *)(void *)0);
            if(!(cached == ((struct anonymous_0 *)NULL)))
            {
              compose_answer__1__3__1__1__2__rrset=getrrset(cached, rretp);
              if(!(compose_answer__1__3__1__1__2__rrset == ((struct anonymous *)NULL)))
              {
                if(!((1 & (signed int)compose_answer__1__3__1__1__2__rrset->flags) == 0))
                  compose_answer__1__3__1__1__2__rrset = (struct anonymous *)(void *)0;

              }

            }

            if(compose_answer__1__3__1__1__2__rrset == ((struct anonymous *)NULL))
            {
              if(!((2 & (signed int)prev->flags) == 0))
              {
                unsigned char *nm;
                nm=getlocalowner(prev->qname, rretp);
                if(!(nm == ((unsigned char *)NULL)))
                {
                  if(!(cached == ((struct anonymous_0 *)NULL)))
                  {
                    free_cent(cached);
                    free((void *)cached);
                  }

                  cached=lookup_cache(nm, (signed int *)(void *)0);
                  if(!(cached == ((struct anonymous_0 *)NULL)))
                    compose_answer__1__3__1__1__2__rrset=getrrset(cached, rretp);

                }

              }

            }

            free_cent(prev);
            free((void *)prev);
          }

          if(!(compose_answer__1__3__1__1__2__rrset == ((struct anonymous *)NULL)))
          {
            struct rr_b_s *compose_answer__1__3__1__1__2__3__rr = compose_answer__1__3__1__1__2__rrset->rrs;
            for( ; !(compose_answer__1__3__1__1__2__3__rr == ((struct rr_b_s *)NULL)); compose_answer__1__3__1__1__2__3__rr = compose_answer__1__3__1__1__2__3__rr->next)
            {
              signed long int return_value_ans_ttl_56;
              return_value_ans_ttl_56=ans_ttl(compose_answer__1__3__1__1__2__rrset, queryts);
              signed int return_value_add_ar_57;
              return_value_add_ar_57=add_ar(&ar, (unsigned short int)rretp, (unsigned short int)compose_answer__1__3__1__1__2__3__rr->rdlen, (void *)compose_answer__1__3__1__1__2__3__rr->data, cached->qname, (unsigned int)return_value_ans_ttl_56);
              if(return_value_add_ar_57 == 0)
                goto error_cached;

            }
          }

          hops = 0;
        }

        if(!(cached == ((struct anonymous_0 *)NULL)))
        {
          free_cent(cached);
          free((void *)cached);
        }

        hops = hops - 1;
      }
      while(hops >= 0);
      return_value_llist_next_21=llist_next((void *)qe);
    }
    struct rre_s *rre;
    void *return_value_dlist_first_66;
    return_value_dlist_first_66=dlist_first_link1(ar);
    rre = (struct rre_s *)return_value_dlist_first_66;
    for( ; !(rre == ((struct rre_s *)NULL)); rre = (struct rre_s *)return_value_dlist_next_67)
    {
      _Bool tmp_if_expr_69;
      if((signed int)rre->tp == 2)
        tmp_if_expr_69 = (_Bool)1;

      else
        tmp_if_expr_69 = (signed int)rre->tp == 6 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_69)
      {
        unsigned char *compose_answer__1__4__1__1__1__nm = rre->tnm + (signed long int)rre->tsz;
        signed int return_value_add_additional_rr_68;
        return_value_add_additional_rr_68=add_additional_rr(&ans, rlen, &allocsz, compose_answer__1__4__1__1__1__nm, (unsigned int)rre->tp, (signed long int)rre->ttl, (unsigned int)rre->tsz, (void *)rre->tnm, 2, udp, &cb, &sva);
        if(return_value_add_additional_rr_68 == 0)
          goto error_ans;

      }

      return_value_dlist_next_67=dlist_next_link1((void *)rre);
    }
    _Bool tmp_if_expr_75;
    if(!(udp == ((unsigned int *)NULL)))
      tmp_if_expr_75 = *rlen + (unsigned long int)(1 + 10) > (unsigned long int)*udp ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_75 = (_Bool)0;
    if(!tmp_if_expr_75)
    {
      if(!(ednsinfo == ((struct anonymous_17 *)NULL)))
      {
        signed int return_value_add_opt_pseudo_rr_70;
        return_value_add_opt_pseudo_rr_70=add_opt_pseudo_rr(&ans, rlen, &allocsz, (unsigned short int)global.udpbufsize, rcode, (unsigned short int)0, (unsigned short int)0);
        if(return_value_add_opt_pseudo_rr_70 == 0)
          goto error_ans;

      }

      void *return_value_dlist_first_71;
      return_value_dlist_first_71=dlist_first_link1(ar);
      rre = (struct rre_s *)return_value_dlist_first_71;
      for( ; !(rre == ((struct rre_s *)NULL)); rre = (struct rre_s *)return_value_dlist_next_72)
      {
        _Bool tmp_if_expr_74;
        if((signed int)rre->tp == 2)
          tmp_if_expr_74 = (_Bool)1;

        else
          tmp_if_expr_74 = (signed int)rre->tp == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_74)
        {
          signed int return_value_add_additional_a_73;
          return_value_add_additional_a_73=add_additional_a(&ans, rlen, &allocsz, rre->tnm, queryts, udp, &cb, &sva);
          if(return_value_add_additional_a_73 == 0)
            goto error_ans;

        }

        return_value_dlist_next_72=dlist_next_link1((void *)rre);
      }
    }

    if(!(aa == 0))
      ans->hdr.aa = (unsigned int)1;

    goto cleanup_return;

  error_cached:
    ;
    free_cent(cached);
    free((void *)cached);

  error_ans:
    ;
    free((void *)ans);
    ans = (struct anonymous_28 *)(void *)0;

  cleanup_return:
    ;
    free((void *)ar);
    free((void *)sva);
    free((void *)cb);
  }


return_ans:
  ;
  if(!(rcodep == ((signed int *)NULL)))
    *rcodep = (signed int)rcode;

  return ans;
}

// compress_name
// file dns.c line 248
unsigned int compress_name(unsigned char *in, unsigned char *out, unsigned int offs, struct _dynamic_list_head **cb)
{
  struct anonymous_64 *ci;
  unsigned int longest = (unsigned int)0;
  unsigned int lrem = (unsigned int)0;
  unsigned int coffs = (unsigned int)0;
  unsigned int rl = (unsigned int)0;
  unsigned int ilen;
  ilen=rhnlen_link1(in);
  unsigned short int add = (unsigned short int)1;
  if(ilen >= 257u)
  {
    log_message(3, "%s:%d: %s", (const void *)"dns.c", 256, (const void *)"compress_name: name too long");
    pdnsd_exit();
  }

  void *return_value_dlist_first_1;
  return_value_dlist_first_1=dlist_first(*cb);
  ci = (struct anonymous_64 *)return_value_dlist_first_1;
  void *return_value_dlist_next_2;
  for( ; !(ci == ((struct anonymous_64 *)NULL)); ci = (struct anonymous_64 *)return_value_dlist_next_2)
  {
    unsigned int rv;
    unsigned int rem;
    unsigned int to;
    rv=domain_match(in, ci->s, &rem, &to);
    if(!(longest >= rv))
    {
      unsigned int newoffs = ci->index + to;
      if(!(newoffs >= 16384u))
      {
        longest = rv;
        lrem = rem;
        coffs = newoffs;
      }

    }

    return_value_dlist_next_2=dlist_next((void *)ci);
  }
  if(longest >= 1u)
  {
    if(!(ilen >= 2u + lrem))
    {
      log_message(3, "%s:%d: %s", (const void *)"dns.c", 279, (const void *)"compress_name: length increased");
      pdnsd_exit();
    }

    memcpy((void *)out, (const void *)in, (unsigned long int)lrem);
    out[(signed long int)lrem] = (unsigned char)((unsigned int)0xc0 | (coffs & (unsigned int)0x3f00) >> 8);
    out[(signed long int)(lrem + (unsigned int)1)] = (unsigned char)(coffs & (unsigned int)0xff);
    rl = lrem + (unsigned int)2;
    add = (unsigned short int)(lrem != (unsigned int)0);
  }

  else
  {
    memcpy((void *)out, (const void *)in, (unsigned long int)ilen);
    rl = ilen;
  }
  if(!(add == 0))
  {
    *cb=dlist_grow(*cb, sizeof(struct anonymous_64) /*4ul*/  + (unsigned long int)ilen);
    if(*cb == ((struct _dynamic_list_head *)NULL))
      return (unsigned int)0;

    void *return_value_dlist_last_3;
    return_value_dlist_last_3=dlist_last(*cb);
    ci = (struct anonymous_64 *)return_value_dlist_last_3;
    ci->index = offs;
    memcpy((void *)ci->s, (const void *)in, (unsigned long int)ilen);
  }

  return rl;
}

// confparse
// file conf-parser.c line 488
signed int confparse(struct _IO_FILE *in, char *prestr, struct anonymous_21 *global, struct anonymous_18 **servers, signed int includedepth, char **errstr)
{
  char *linebuf = (char *)(void *)0;
  char *p;
  char *ps;
  char *getnextperr = (char *)(void *)0;
  char *scanstrerr = (char *)(void *)0;
  const char *conftype;
  unsigned long int buflen = (unsigned long int)256;
  unsigned int linenr = (unsigned int)0;
  signed int retval = 0;
  signed int sechdr;
  signed int option;
  signed int len;
  char strbuf[1024l];
  *errstr = (char *)(void *)0;
  if(!(in == ((struct _IO_FILE *)NULL)))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(buflen);
    linebuf = (char *)return_value_malloc_1;
    if(linebuf == ((char *)NULL))
      return 0;

    if(!(global == ((struct anonymous_21 *)NULL)))
      conftype = "config file";

    else
      conftype = "include file";
  }

  else
    conftype = "config string";
  p = prestr;
  _Bool tmp_if_expr_4;
  const unsigned short int **return_value___ctype_b_loc_2;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_5;
  _Bool tmp_if_expr_8;
  const unsigned short int **return_value___ctype_b_loc_6;
  _Bool tmp_if_expr_7;
  union anonymous_6 *ipaddrp;
  _Bool tmp_if_expr_11;
  const unsigned short int **return_value___ctype_b_loc_9;
  _Bool tmp_if_expr_10;
  const unsigned short int **return_value___ctype_b_loc_12;
  signed int return_value_ioctl_18;
  _Bool tmp_if_expr_23;
  const unsigned short int **return_value___ctype_b_loc_21;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_29;
  const unsigned short int **return_value___ctype_b_loc_27;
  _Bool tmp_if_expr_28;
  _Bool tmp_if_expr_33;
  const unsigned short int **return_value___ctype_b_loc_31;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_37;
  const unsigned short int **return_value___ctype_b_loc_35;
  _Bool tmp_if_expr_36;
  _Bool tmp_if_expr_41;
  const unsigned short int **return_value___ctype_b_loc_39;
  _Bool tmp_if_expr_40;
  _Bool tmp_if_expr_45;
  const unsigned short int **return_value___ctype_b_loc_43;
  _Bool tmp_if_expr_44;
  _Bool tmp_if_expr_49;
  const unsigned short int **return_value___ctype_b_loc_47;
  _Bool tmp_if_expr_48;
  _Bool tmp_if_expr_53;
  const unsigned short int **return_value___ctype_b_loc_51;
  _Bool tmp_if_expr_52;
  _Bool tmp_if_expr_59;
  const unsigned short int **return_value___ctype_b_loc_57;
  _Bool tmp_if_expr_58;
  _Bool tmp_if_expr_63;
  const unsigned short int **return_value___ctype_b_loc_61;
  _Bool tmp_if_expr_62;
  _Bool tmp_if_expr_68;
  const unsigned short int **return_value___ctype_b_loc_66;
  _Bool tmp_if_expr_67;
  _Bool tmp_if_expr_82;
  const unsigned short int **return_value___ctype_b_loc_80;
  _Bool tmp_if_expr_81;
  _Bool tmp_if_expr_87;
  const unsigned short int **return_value___ctype_b_loc_85;
  _Bool tmp_if_expr_86;
  _Bool tmp_if_expr_91;
  const unsigned short int **return_value___ctype_b_loc_89;
  _Bool tmp_if_expr_90;
  _Bool tmp_if_expr_95;
  const unsigned short int **return_value___ctype_b_loc_93;
  _Bool tmp_if_expr_94;
  const unsigned short int **return_value___ctype_b_loc_97;
  const unsigned short int **return_value___ctype_b_loc_103;
  _Bool tmp_if_expr_106;
  const unsigned short int **return_value___ctype_b_loc_104;
  _Bool tmp_if_expr_105;
  _Bool tmp_if_expr_112;
  const unsigned short int **return_value___ctype_b_loc_110;
  _Bool tmp_if_expr_111;
  const unsigned short int **return_value___ctype_b_loc_119;
  _Bool tmp_if_expr_118;
  const unsigned short int **return_value___ctype_b_loc_116;
  _Bool tmp_if_expr_117;
  const unsigned short int **return_value___ctype_b_loc_125;
  _Bool tmp_if_expr_123;
  const unsigned short int **return_value___ctype_b_loc_121;
  _Bool tmp_if_expr_122;
  const unsigned short int **return_value___ctype_b_loc_124;
  _Bool tmp_if_expr_128;
  const unsigned short int **return_value___ctype_b_loc_126;
  _Bool tmp_if_expr_127;
  _Bool tmp_if_expr_132;
  const unsigned short int **return_value___ctype_b_loc_130;
  _Bool tmp_if_expr_131;
  _Bool tmp_if_expr_136;
  const unsigned short int **return_value___ctype_b_loc_134;
  _Bool tmp_if_expr_135;
  _Bool tmp_if_expr_140;
  const unsigned short int **return_value___ctype_b_loc_138;
  _Bool tmp_if_expr_139;
  _Bool tmp_if_expr_144;
  const unsigned short int **return_value___ctype_b_loc_142;
  _Bool tmp_if_expr_143;
  _Bool tmp_if_expr_148;
  const unsigned short int **return_value___ctype_b_loc_146;
  _Bool tmp_if_expr_147;
  _Bool tmp_if_expr_152;
  const unsigned short int **return_value___ctype_b_loc_150;
  _Bool tmp_if_expr_151;
  _Bool tmp_if_expr_156;
  const unsigned short int **return_value___ctype_b_loc_154;
  _Bool tmp_if_expr_155;
  _Bool tmp_if_expr_160;
  const unsigned short int **return_value___ctype_b_loc_158;
  _Bool tmp_if_expr_159;
  _Bool tmp_if_expr_164;
  const unsigned short int **return_value___ctype_b_loc_162;
  _Bool tmp_if_expr_163;
  _Bool tmp_if_expr_168;
  const unsigned short int **return_value___ctype_b_loc_166;
  _Bool tmp_if_expr_167;
  const char *return_value_const_name_170;
  struct anonymous_0 confparse__1__2__1__5__5__c_cent;
  signed long int confparse__1__2__1__5__5__c_ttl;
  unsigned int c_flags;
  unsigned char reverse;
  const unsigned short int **return_value___ctype_b_loc_175;
  _Bool tmp_if_expr_178;
  const unsigned short int **return_value___ctype_b_loc_176;
  _Bool tmp_if_expr_177;
  signed int tp;
  const char *tpname;
  _Bool tmp_if_expr_183;
  const unsigned short int **return_value___ctype_b_loc_181;
  _Bool tmp_if_expr_182;
  _Bool tmp_if_expr_187;
  const unsigned short int **return_value___ctype_b_loc_185;
  _Bool tmp_if_expr_186;
  signed int return_value_inet_pton_189;
  const unsigned short int **return_value___ctype_b_loc_234;
  _Bool tmp_if_expr_237;
  const unsigned short int **return_value___ctype_b_loc_235;
  _Bool tmp_if_expr_236;
  _Bool tmp_if_expr_242;
  const unsigned short int **return_value___ctype_b_loc_240;
  _Bool tmp_if_expr_241;
  _Bool tmp_if_expr_246;
  const unsigned short int **return_value___ctype_b_loc_244;
  _Bool tmp_if_expr_245;
  const unsigned short int **return_value___ctype_b_loc_248;
  _Bool tmp_if_expr_251;
  const unsigned short int **return_value___ctype_b_loc_249;
  _Bool tmp_if_expr_250;
  const unsigned short int **return_value___ctype_b_loc_255;
  _Bool tmp_if_expr_258;
  const unsigned short int **return_value___ctype_b_loc_256;
  _Bool tmp_if_expr_257;
  const unsigned short int **return_value___ctype_b_loc_272;
  _Bool tmp_if_expr_262;
  const unsigned short int **return_value___ctype_b_loc_260;
  _Bool tmp_if_expr_261;
  signed int return_value_add_cent_rrset_by_type_266;
  _Bool tmp_if_expr_271;
  const unsigned short int **return_value___ctype_b_loc_269;
  _Bool tmp_if_expr_270;
  do
  {
    p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
    if(p == ((char *)NULL))
      break;

    const unsigned short int **return_value___ctype_b_loc_273;
    return_value___ctype_b_loc_273=__ctype_b_loc();
    if(!((1024 & (signed int)(*return_value___ctype_b_loc_273)[(signed long int)(signed int)*p]) == 0))
    {
      ps = p;
      do
      {
        p = p + 1l;
        if(!(*p == 0))
        {
          return_value___ctype_b_loc_2=__ctype_b_loc();
          if(!((8 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0))
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
      }
      while(tmp_if_expr_4);
      len = (signed int)(p - ps);
      sechdr=binsearch_keyword(ps, len, section_headers, (signed int)(sizeof(const struct anonymous_32 [6l]) /*96ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
      if(sechdr == 0)
      {
        *errstr=report_errorf(conftype, linenr, "invalid section header: %.*s", (signed int)len, ps);
        goto free_linebuf_return;
      }

      p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
      if(p == ((char *)NULL))
        goto unexpected_eof;

      if(!((signed int)*p == 123))
        goto expected_bropen;

      p = p + 1l;
      p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
      if(p == ((char *)NULL))
        goto unexpected_eof;

      switch(sechdr)
      {
        case 1:
        {
          if(global == ((struct anonymous_21 *)NULL))
          {
            *errstr=report_error(conftype, linenr, in != ((struct _IO_FILE *)NULL) ? "global section not allowed in include file" : "global section not allowed in eval string");
            goto free_linebuf_return;
          }

          do
          {
            return_value___ctype_b_loc_5=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_6=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr_7 = (_Bool)1;

                else
                  tmp_if_expr_7 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_8 = (_Bool)0;
            }
            while(tmp_if_expr_8);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, global_options, (signed int)(sizeof(const struct anonymous_32 [39l]) /*624ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for global section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!(option == 7))
            {
              if(option == 8)
                goto __CPROVER_DUMP_L37;

              if(option == 9)
                goto __CPROVER_DUMP_L42;

              if(option == 11)
                goto __CPROVER_DUMP_L45;

              if(option == 10)
                goto __CPROVER_DUMP_L46;

              if(option == 12)
                goto __CPROVER_DUMP_L60;

              if(option == 13)
                goto __CPROVER_DUMP_L65;

              if(option == 14)
                goto __CPROVER_DUMP_L75;

              if(option == 15)
                goto __CPROVER_DUMP_L79;

              if(option == 16)
                goto __CPROVER_DUMP_L83;

              if(option == 17)
                goto __CPROVER_DUMP_L88;

              if(option == 18)
                goto __CPROVER_DUMP_L98;

              if(option == 19)
                goto __CPROVER_DUMP_L108;

              if(option == 20)
                goto __CPROVER_DUMP_L118;

              if(option == 21)
                goto __CPROVER_DUMP_L128;

              if(option == 22)
                goto __CPROVER_DUMP_L137;

              if(option == 23)
                goto __CPROVER_DUMP_L146;

              if(option == 24)
                goto __CPROVER_DUMP_L155;

              if(option == 25)
                goto __CPROVER_DUMP_L160;

              if(option == 26)
                goto __CPROVER_DUMP_L164;

              if(option == 27)
                goto __CPROVER_DUMP_L173;

              if(option == 28)
                goto __CPROVER_DUMP_L183;

              if(option == 29)
                goto __CPROVER_DUMP_L188;

              if(option == 30)
                goto __CPROVER_DUMP_L197;

              if(option == 31)
                goto __CPROVER_DUMP_L200;

              if(option == 32)
                goto __CPROVER_DUMP_L203;

              if(option == 33)
                goto __CPROVER_DUMP_L206;

              if(option == 47)
                goto __CPROVER_DUMP_L210;

              if(option == 34)
                goto __CPROVER_DUMP_L214;

              if(option == 35)
                goto __CPROVER_DUMP_L219;

              if(option == 36)
                goto __CPROVER_DUMP_L229;

              if(option == 37)
                goto __CPROVER_DUMP_L233;

              if(option == 38)
                goto __CPROVER_DUMP_L241;

              if(option == 39)
                goto __CPROVER_DUMP_L249;

              if(option == 40)
                goto __CPROVER_DUMP_L263;

              if(option == 41)
                goto __CPROVER_DUMP_L267;

              if(option == 42)
                goto __CPROVER_DUMP_L271;

              goto __CPROVER_DUMP_L279;
            }

            const unsigned short int **return_value___ctype_b_loc_13;
            return_value___ctype_b_loc_13=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_13)[(signed long int)(signed int)*p]) == 0))
            {
              signed int confparse__1__2__1__5__2__5__1__cnst;
              ps = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_9=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_10 = (_Bool)1;

                  else
                    tmp_if_expr_10 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_11 = (_Bool)0;
              }
              while(tmp_if_expr_11);
              len = (signed int)(p - ps);
              confparse__1__2__1__5__2__5__1__cnst=lookup_const(ps, len);
              if(confparse__1__2__1__5__2__5__1__cnst == 2)
                global->perm_cache = (signed long int)0;

              else
                goto bad_perm_cache_option;
            }

            else
            {
              return_value___ctype_b_loc_12=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc_12)[(signed long int)(signed int)*p]) == 0))
                global->perm_cache=strtol(p, &p, 0);

              else
              {

              bad_perm_cache_option:
                ;
                *errstr=report_error(conftype, linenr, "bad qualifier in perm_cache= option.");
                goto free_linebuf_return;
              }
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L37:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(!(global->cache_dir == ((char *)NULL)))
              free((void *)global->cache_dir);

            global->cache_dir=strndup(strbuf, (unsigned long int)len);
            if(global->cache_dir == ((char *)NULL))
              goto out_of_memory;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L42:
            ;
            const unsigned short int **return_value___ctype_b_loc_15;
            return_value___ctype_b_loc_15=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_15)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_14;
              return_value_strtol_14=strtol(p, &p, 0);
              global->port = (signed int)return_value_strtol_14;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for server_port option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L45:
            ;
            ipaddrp = &global->out_a;
            goto scan_ip_or_interface;

          __CPROVER_DUMP_L46:
            ;
            ipaddrp = &global->a;

          scan_ip_or_interface:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            const char *confparse__1__2__1__5__2__5__8__err;
            confparse__1__2__1__5__2__5__8__err=parse_ip(strbuf, ipaddrp);
            if(!(confparse__1__2__1__5__2__5__8__err == ((const char *)NULL)))
            {
              signed int return_value_strcmp_20;
              return_value_strcmp_20=strcmp(confparse__1__2__1__5__2__5__8__err, "bad IP address");
              if(return_value_strcmp_20 == 0 && !(len >= 16))
              {
                signed int fd;
                struct ifreq req;
                memcpy((void *)req.ifr_ifrn.ifrn_name, (const void *)strbuf, (unsigned long int)len);
                req.ifr_ifrn.ifrn_name[(signed long int)len] = (char)0;
                req.ifr_ifru.ifru_addr.sa_family = (unsigned short int)(run_ipv4 != 0 ? 2 : 10);
                fd=socket(run_ipv4 != 0 ? 2 : 10, 2, 0);
                _Bool tmp_if_expr_19;
                if(!(fd == -1))
                {
                  return_value_ioctl_18=ioctl(fd, (unsigned long int)0x8915, &req);
                  tmp_if_expr_19 = return_value_ioctl_18 != -1 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_19 = (_Bool)0;
                if(tmp_if_expr_19)
                {
                  if(!(run_ipv4 == 0))
                    ipaddrp->ipv4 = ((struct sockaddr_in *)&req.ifr_ifru.ifru_addr)->sin_addr;

                  else
                    ipaddrp->ipv6 = ((struct sockaddr_in6 *)&req.ifr_ifru.ifru_addr)->sin6_addr;
                  close(fd);
                }

                else
                {
                  signed int *return_value___errno_location_16;
                  return_value___errno_location_16=__errno_location();
                  char *return_value_strerror_17;
                  return_value_strerror_17=strerror(*return_value___errno_location_16);
                  *errstr=report_errorf(conftype, linenr, "Failed to get IP address of %s: %s", (const void *)req.ifr_ifrn.ifrn_name, return_value_strerror_17);
                  if(!(fd == -1))
                    close(fd);

                  goto free_linebuf_return;
                }
              }

              else
              {
                *errstr=report_errorf(conftype, linenr, "%s for the %s= option.", confparse__1__2__1__5__2__5__8__err, option == 10 ? "server_ip" : "outgoing_ip");
                goto free_linebuf_return;
              }
            }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L60:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(!(global->scheme_file == ((char *)NULL)))
              free((void *)global->scheme_file);

            global->scheme_file=strndup(strbuf, (unsigned long int)len);
            if(global->scheme_file == ((char *)NULL))
              goto out_of_memory;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L65:
            ;
            const unsigned short int **return_value___ctype_b_loc_24;
            return_value___ctype_b_loc_24=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_24)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__11__1___str;
              unsigned long int confparse__1__2__1__5__2__5__11__1___len;
              signed int confparse__1__2__1__5__2__5__11__1___cnst;
              confparse__1__2__1__5__2__5__11__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_21=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_21)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_22 = (_Bool)1;

                  else
                    tmp_if_expr_22 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_23 = tmp_if_expr_22 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_23 = (_Bool)0;
              }
              while(tmp_if_expr_23);
              confparse__1__2__1__5__2__5__11__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__11__1___str);
              confparse__1__2__1__5__2__5__11__1___cnst=lookup_const(confparse__1__2__1__5__2__5__11__1___str, (signed int)confparse__1__2__1__5__2__5__11__1___len);
              if(confparse__1__2__1__5__2__5__11__1___cnst == 1 || confparse__1__2__1__5__2__5__11__1___cnst == 2)
                global->lndown_kluge = (char)(confparse__1__2__1__5__2__5__11__1___cnst == 1);

              else
                goto ASSIGN_ON_OFF_656;
            }

            else
            {

            ASSIGN_ON_OFF_656:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in linkdown_kluge= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L75:
            ;
            const unsigned short int **return_value___ctype_b_loc_25;
            return_value___ctype_b_loc_25=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_25)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__12__1___err;
              global->max_ttl=strtotime(p, &p, &confparse__1__2__1__5__2__5__12__1___err);
              if(!(confparse__1__2__1__5__2__5__12__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"max_ttl option", confparse__1__2__1__5__2__5__12__1___err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for max_ttl option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L79:
            ;
            const unsigned short int **return_value___ctype_b_loc_26;
            return_value___ctype_b_loc_26=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_26)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__13__1___err;
              global->min_ttl=strtotime(p, &p, &confparse__1__2__1__5__2__5__13__1___err);
              if(!(confparse__1__2__1__5__2__5__13__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"min_ttl option", confparse__1__2__1__5__2__5__13__1___err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for min_ttl option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L83:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(!((unsigned long int)len >= sizeof(char [21l]) /*21ul*/ ))
            {
              memcpy((void *)global->run_as, (const void *)strbuf, (unsigned long int)len);
              global->run_as[(signed long int)len] = (char)0;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "run_as: string too long");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L88:
            ;
            const unsigned short int **return_value___ctype_b_loc_30;
            return_value___ctype_b_loc_30=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_30)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__16__1___str;
              unsigned long int confparse__1__2__1__5__2__5__16__1___len;
              signed int confparse__1__2__1__5__2__5__16__1___cnst;
              confparse__1__2__1__5__2__5__16__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_27=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_27)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_28 = (_Bool)1;

                  else
                    tmp_if_expr_28 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_29 = tmp_if_expr_28 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_29 = (_Bool)0;
              }
              while(tmp_if_expr_29);
              confparse__1__2__1__5__2__5__16__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__16__1___str);
              confparse__1__2__1__5__2__5__16__1___cnst=lookup_const(confparse__1__2__1__5__2__5__16__1___str, (signed int)confparse__1__2__1__5__2__5__16__1___len);
              if(confparse__1__2__1__5__2__5__16__1___cnst == 1 || confparse__1__2__1__5__2__5__16__1___cnst == 2)
                global->strict_suid = (char)(confparse__1__2__1__5__2__5__16__1___cnst == 1);

              else
                goto ASSIGN_ON_OFF_673;
            }

            else
            {

            ASSIGN_ON_OFF_673:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in strict_setuid= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L98:
            ;
            const unsigned short int **return_value___ctype_b_loc_34;
            return_value___ctype_b_loc_34=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_34)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__17__1___str;
              unsigned long int confparse__1__2__1__5__2__5__17__1___len;
              signed int confparse__1__2__1__5__2__5__17__1___cnst;
              confparse__1__2__1__5__2__5__17__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_31=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_31)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_32 = (_Bool)1;

                  else
                    tmp_if_expr_32 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_33 = tmp_if_expr_32 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_33 = (_Bool)0;
              }
              while(tmp_if_expr_33);
              confparse__1__2__1__5__2__5__17__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__17__1___str);
              confparse__1__2__1__5__2__5__17__1___cnst=lookup_const(confparse__1__2__1__5__2__5__17__1___str, (signed int)confparse__1__2__1__5__2__5__17__1___len);
              if(confparse__1__2__1__5__2__5__17__1___cnst == 1 || confparse__1__2__1__5__2__5__17__1___cnst == 2)
                global->use_nss = (char)(confparse__1__2__1__5__2__5__17__1___cnst == 1);

              else
                goto ASSIGN_ON_OFF_677;
            }

            else
            {

            ASSIGN_ON_OFF_677:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in use_nss= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L108:
            ;
            const unsigned short int **return_value___ctype_b_loc_38;
            return_value___ctype_b_loc_38=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_38)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__18__1___str;
              unsigned long int confparse__1__2__1__5__2__5__18__1___len;
              signed int confparse__1__2__1__5__2__5__18__1___cnst;
              confparse__1__2__1__5__2__5__18__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_35=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_35)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_36 = (_Bool)1;

                  else
                    tmp_if_expr_36 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_37 = tmp_if_expr_36 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_37 = (_Bool)0;
              }
              while(tmp_if_expr_37);
              confparse__1__2__1__5__2__5__18__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__18__1___str);
              confparse__1__2__1__5__2__5__18__1___cnst=lookup_const(confparse__1__2__1__5__2__5__18__1___str, (signed int)confparse__1__2__1__5__2__5__18__1___len);
              if(confparse__1__2__1__5__2__5__18__1___cnst == 1 || confparse__1__2__1__5__2__5__18__1___cnst == 2)
                global->paranoid = (char)(confparse__1__2__1__5__2__5__18__1___cnst == 1);

              else
                goto ASSIGN_ON_OFF_681;
            }

            else
            {

            ASSIGN_ON_OFF_681:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in paranoid= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L118:
            ;
            signed int ignore_cd;
            const unsigned short int **return_value___ctype_b_loc_42;
            return_value___ctype_b_loc_42=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_42)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__19__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__19__1__1___len;
              signed int confparse__1__2__1__5__2__5__19__1__1___cnst;
              confparse__1__2__1__5__2__5__19__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_39=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_39)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_40 = (_Bool)1;

                  else
                    tmp_if_expr_40 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_41 = tmp_if_expr_40 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_41 = (_Bool)0;
              }
              while(tmp_if_expr_41);
              confparse__1__2__1__5__2__5__19__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__19__1__1___str);
              confparse__1__2__1__5__2__5__19__1__1___cnst=lookup_const(confparse__1__2__1__5__2__5__19__1__1___str, (signed int)confparse__1__2__1__5__2__5__19__1__1___len);
              if(confparse__1__2__1__5__2__5__19__1__1___cnst == 1 || confparse__1__2__1__5__2__5__19__1__1___cnst == 2)
                ignore_cd = (signed int)(confparse__1__2__1__5__2__5__19__1__1___cnst == 1);

              else
                goto ASSIGN_ON_OFF_686;
            }

            else
            {

            ASSIGN_ON_OFF_686:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in ignore_cd= option.");
              goto free_linebuf_return;
            }
            fprintf(stderr, "Warning: ignore_cd option in configuration file is obsolete and currently has no effect.\n");
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L128:
            ;
            signed int confparse__1__2__1__5__2__5__20__cnst;
            const unsigned short int **return_value___ctype_b_loc_46;
            return_value___ctype_b_loc_46=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_46)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__20__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__20__1__1___len;
              confparse__1__2__1__5__2__5__20__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_43=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_43)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_44 = (_Bool)1;

                  else
                    tmp_if_expr_44 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_45 = tmp_if_expr_44 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_45 = (_Bool)0;
              }
              while(tmp_if_expr_45);
              confparse__1__2__1__5__2__5__20__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__20__1__1___str);
              confparse__1__2__1__5__2__5__20__cnst=lookup_const(confparse__1__2__1__5__2__5__20__1__1___str, (signed int)confparse__1__2__1__5__2__5__20__1__1___len);
              if(!(confparse__1__2__1__5__2__5__20__cnst == 1) && !(confparse__1__2__1__5__2__5__20__cnst == 2))
                goto ASSIGN_CONST_693;

            }

            else
            {

            ASSIGN_CONST_693:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in status_pipe= option.");
              goto free_linebuf_return;
            }
            if(cmdline.stat_pipe == 0)
              global->stat_pipe = (char)(confparse__1__2__1__5__2__5__20__cnst == 1);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L137:
            ;
            signed int confparse__1__2__1__5__2__5__21__cnst;
            const unsigned short int **return_value___ctype_b_loc_50;
            return_value___ctype_b_loc_50=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_50)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__21__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__21__1__1___len;
              confparse__1__2__1__5__2__5__21__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_47=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_47)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_48 = (_Bool)1;

                  else
                    tmp_if_expr_48 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_49 = tmp_if_expr_48 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_49 = (_Bool)0;
              }
              while(tmp_if_expr_49);
              confparse__1__2__1__5__2__5__21__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__21__1__1___str);
              confparse__1__2__1__5__2__5__21__cnst=lookup_const(confparse__1__2__1__5__2__5__21__1__1___str, (signed int)confparse__1__2__1__5__2__5__21__1__1___len);
              if(!(confparse__1__2__1__5__2__5__21__cnst == 1) && !(confparse__1__2__1__5__2__5__21__cnst == 2))
                goto ASSIGN_CONST_700;

            }

            else
            {

            ASSIGN_CONST_700:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in daemon= option.");
              goto free_linebuf_return;
            }
            if(cmdline.daemon == 0)
              global->daemon = (char)(confparse__1__2__1__5__2__5__21__cnst == 1);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L146:
            ;
            signed int confparse__1__2__1__5__2__5__22__cnst;
            const unsigned short int **return_value___ctype_b_loc_54;
            return_value___ctype_b_loc_54=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_54)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__22__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__22__1__1___len;
              confparse__1__2__1__5__2__5__22__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_51=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_51)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_52 = (_Bool)1;

                  else
                    tmp_if_expr_52 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_53 = tmp_if_expr_52 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_53 = (_Bool)0;
              }
              while(tmp_if_expr_53);
              confparse__1__2__1__5__2__5__22__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__22__1__1___str);
              confparse__1__2__1__5__2__5__22__cnst=lookup_const(confparse__1__2__1__5__2__5__22__1__1___str, (signed int)confparse__1__2__1__5__2__5__22__1__1___len);
              if(!(confparse__1__2__1__5__2__5__22__cnst == 1) && !(confparse__1__2__1__5__2__5__22__cnst == 2))
                goto ASSIGN_CONST_707;

            }

            else
            {

            ASSIGN_CONST_707:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in tcp_server= option.");
              goto free_linebuf_return;
            }
            if(cmdline.notcp == 0)
              global->notcp = (char)(confparse__1__2__1__5__2__5__22__cnst == 2);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L155:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(cmdline.pidfile == 0)
            {
              if(!(global->pidfile == ((char *)NULL)))
                free((void *)global->pidfile);

              global->pidfile=strndup(strbuf, (unsigned long int)len);
              if(global->pidfile == ((char *)NULL))
                goto out_of_memory;

            }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L160:
            ;
            signed int confparse__1__2__1__5__2__5__25__val;
            const unsigned short int **return_value___ctype_b_loc_56;
            return_value___ctype_b_loc_56=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_56)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_55;
              return_value_strtol_55=strtol(p, &p, 0);
              confparse__1__2__1__5__2__5__25__val = (signed int)return_value_strtol_55;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for verbosity option");
              goto free_linebuf_return;
            }
            if(cmdline.verbosity == 0)
              global->verbosity = (signed short int)confparse__1__2__1__5__2__5__25__val;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L164:
            ;
            signed int confparse__1__2__1__5__2__5__26__cnst;
            const unsigned short int **return_value___ctype_b_loc_60;
            return_value___ctype_b_loc_60=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_60)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__26__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__26__1__1___len;
              confparse__1__2__1__5__2__5__26__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_57=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_57)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_58 = (_Bool)1;

                  else
                    tmp_if_expr_58 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_59 = tmp_if_expr_58 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_59 = (_Bool)0;
              }
              while(tmp_if_expr_59);
              confparse__1__2__1__5__2__5__26__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__26__1__1___str);
              confparse__1__2__1__5__2__5__26__cnst=lookup_const(confparse__1__2__1__5__2__5__26__1__1___str, (signed int)confparse__1__2__1__5__2__5__26__1__1___len);
              if(!(confparse__1__2__1__5__2__5__26__cnst == 12) && !(confparse__1__2__1__5__2__5__26__cnst == 13) && !(confparse__1__2__1__5__2__5__26__cnst == 14) && !(confparse__1__2__1__5__2__5__26__cnst == 15))
                goto ASSIGN_CONST_734;

            }

            else
            {

            ASSIGN_CONST_734:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in query_method= option.");
              goto free_linebuf_return;
            }
            if(cmdline.query_method == 0)
              global->query_method = confparse__1__2__1__5__2__5__26__cnst;

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L173:
            ;
            signed int confparse__1__2__1__5__2__5__27__cnst;
            const unsigned short int **return_value___ctype_b_loc_64;
            return_value___ctype_b_loc_64=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_64)[(signed long int)(signed int)*p]) == 0))
            {
              char *_str;
              unsigned long int _len;
              _str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_61=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_61)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_62 = (_Bool)1;

                  else
                    tmp_if_expr_62 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_63 = tmp_if_expr_62 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_63 = (_Bool)0;
              }
              while(tmp_if_expr_63);
              _len = (unsigned long int)(p - _str);
              confparse__1__2__1__5__2__5__27__cnst=lookup_const(_str, (signed int)_len);
              if(!(confparse__1__2__1__5__2__5__27__cnst == 1) && !(confparse__1__2__1__5__2__5__27__cnst == 2))
                goto ASSIGN_CONST_766;

            }

            else
            {

            ASSIGN_CONST_766:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in run_ipv4= option.");
              goto free_linebuf_return;
            }
            if(cmdlineipv == 0)
            {
              run_ipv4 = (signed short int)(confparse__1__2__1__5__2__5__27__cnst == 1);
              cmdlineipv = (signed short int)-1;
            }

            else
              if(!((signed int)run_ipv4 == (signed int)(confparse__1__2__1__5__2__5__27__cnst == 1)) && !((signed int)cmdlineipv >= 0))
              {
                *errstr=report_error(conftype, linenr, (signed int)cmdlineipv == -1 ? "IPv4/IPv6 conflict: you are trying to set run_ipv4 to a value that conflicts with a previous run_ipv4 setting." : "You must set the run_ipv4 option before specifying IP addresses.");
                goto free_linebuf_return;
              }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L183:
            ;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
              goto string_err;

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                goto string_too_long;

            if(cmdline.prefix == 0)
            {
              signed int return_value_inet_pton_65;
              return_value_inet_pton_65=inet_pton(10, strbuf, (void *)&global->ipv4_6_prefix);
              if(!(return_value_inet_pton_65 >= 1))
              {
                *errstr=report_error(conftype, linenr, "ipv4_6_prefix: argument not a valid IPv6 address.");
                goto free_linebuf_return;
              }

            }

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L188:
            ;
            signed int cnst;
            const unsigned short int **return_value___ctype_b_loc_69;
            return_value___ctype_b_loc_69=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_69)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__30__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__30__1__1___len;
              confparse__1__2__1__5__2__5__30__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_66=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_66)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_67 = (_Bool)1;

                  else
                    tmp_if_expr_67 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_68 = tmp_if_expr_67 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_68 = (_Bool)0;
              }
              while(tmp_if_expr_68);
              confparse__1__2__1__5__2__5__30__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__30__1__1___str);
              cnst=lookup_const(confparse__1__2__1__5__2__5__30__1__1___str, (signed int)confparse__1__2__1__5__2__5__30__1__1___len);
              if(!(cnst == 1) && !(cnst == 2))
                goto ASSIGN_CONST_809;

            }

            else
            {

            ASSIGN_CONST_809:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in debug= option.");
              goto free_linebuf_return;
            }
            if(cmdline.debug == 0)
              global->debug = (char)(cnst == 1);

            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L197:
            ;
            const unsigned short int **return_value___ctype_b_loc_71;
            return_value___ctype_b_loc_71=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_71)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_70;
              return_value_strtol_70=strtol(p, &p, 0);
              global->ctl_perms = (signed int)return_value_strtol_70;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for ctl_perms option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L200:
            ;
            const unsigned short int **return_value___ctype_b_loc_73;
            return_value___ctype_b_loc_73=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_73)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_72;
              return_value_strtol_72=strtol(p, &p, 0);
              global->proc_limit = (signed int)return_value_strtol_72;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for proc_limit option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L203:
            ;
            const unsigned short int **return_value___ctype_b_loc_75;
            return_value___ctype_b_loc_75=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_75)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_74;
              return_value_strtol_74=strtol(p, &p, 0);
              global->procq_limit = (signed int)return_value_strtol_74;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for procq_limit option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L206:
            ;
            const unsigned short int **return_value___ctype_b_loc_76;
            return_value___ctype_b_loc_76=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_76)[(signed long int)(signed int)*p]) == 0))
            {
              char *_err;
              global->tcp_qtimeout=strtotime(p, &p, &_err);
              if(!(_err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"tcp_qtimeout option", _err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for tcp_qtimeout option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L210:
            ;
            const unsigned short int **return_value___ctype_b_loc_77;
            return_value___ctype_b_loc_77=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_77)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__35__1___err;
              global->timeout=strtotime(p, &p, &confparse__1__2__1__5__2__5__35__1___err);
              if(!(confparse__1__2__1__5__2__5__35__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"global timeout option", confparse__1__2__1__5__2__5__35__1___err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for global timeout option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L214:
            ;
            signed int val;
            const unsigned short int **return_value___ctype_b_loc_79;
            return_value___ctype_b_loc_79=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_79)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_78;
              return_value_strtol_78=strtol(p, &p, 0);
              val = (signed int)return_value_strtol_78;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for par_queries option");
              goto free_linebuf_return;
            }
            if(!(val >= 1))
            {
              *errstr=report_error(conftype, linenr, "bad value for par_queries.");
              goto free_linebuf_return;
            }

            else
              global->par_queries = val;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L219:
            ;
            const unsigned short int **return_value___ctype_b_loc_83;
            return_value___ctype_b_loc_83=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_83)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__37__1___str;
              unsigned long int confparse__1__2__1__5__2__5__37__1___len;
              signed int _cnst;
              confparse__1__2__1__5__2__5__37__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_80=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_80)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_81 = (_Bool)1;

                  else
                    tmp_if_expr_81 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_82 = tmp_if_expr_81 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_82 = (_Bool)0;
              }
              while(tmp_if_expr_82);
              confparse__1__2__1__5__2__5__37__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__37__1___str);
              _cnst=lookup_const(confparse__1__2__1__5__2__5__37__1___str, (signed int)confparse__1__2__1__5__2__5__37__1___len);
              if(_cnst == 1 || _cnst == 2)
                global->rnd_recs = (char)(_cnst == 1);

              else
                goto ASSIGN_ON_OFF_853;
            }

            else
            {

            ASSIGN_ON_OFF_853:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in randomize_recs= option.");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L229:
            ;
            const unsigned short int **return_value___ctype_b_loc_84;
            return_value___ctype_b_loc_84=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_84)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__38__1___err;
              global->neg_ttl=strtotime(p, &p, &confparse__1__2__1__5__2__5__38__1___err);
              if(!(confparse__1__2__1__5__2__5__38__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"neg_ttl option", confparse__1__2__1__5__2__5__38__1___err);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for neg_ttl option");
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L233:
            ;
            signed int confparse__1__2__1__5__2__5__39__cnst;
            const unsigned short int **return_value___ctype_b_loc_88;
            return_value___ctype_b_loc_88=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_88)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__39__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__39__1__1___len;
              confparse__1__2__1__5__2__5__39__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_85=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_85)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_86 = (_Bool)1;

                  else
                    tmp_if_expr_86 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_87 = tmp_if_expr_86 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_87 = (_Bool)0;
              }
              while(tmp_if_expr_87);
              confparse__1__2__1__5__2__5__39__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__39__1__1___str);
              confparse__1__2__1__5__2__5__39__cnst=lookup_const(confparse__1__2__1__5__2__5__39__1__1___str, (signed int)confparse__1__2__1__5__2__5__39__1__1___len);
              if(!(confparse__1__2__1__5__2__5__39__cnst == 1) && !(confparse__1__2__1__5__2__5__39__cnst == 2) && !(confparse__1__2__1__5__2__5__39__cnst == 3) && !(confparse__1__2__1__5__2__5__39__cnst == 22))
                goto ASSIGN_CONST_863;

            }

            else
            {

            ASSIGN_CONST_863:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in neg_rrs_pol= option.");
              goto free_linebuf_return;
            }
            global->neg_rrs_pol = (signed short int)confparse__1__2__1__5__2__5__39__cnst;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L241:
            ;
            signed int confparse__1__2__1__5__2__5__40__cnst;
            const unsigned short int **return_value___ctype_b_loc_92;
            return_value___ctype_b_loc_92=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_92)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__2__5__40__1__1___str;
              unsigned long int confparse__1__2__1__5__2__5__40__1__1___len;
              confparse__1__2__1__5__2__5__40__1__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_89=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_89)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_90 = (_Bool)1;

                  else
                    tmp_if_expr_90 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_91 = tmp_if_expr_90 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_91 = (_Bool)0;
              }
              while(tmp_if_expr_91);
              confparse__1__2__1__5__2__5__40__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__2__5__40__1__1___str);
              confparse__1__2__1__5__2__5__40__cnst=lookup_const(confparse__1__2__1__5__2__5__40__1__1___str, (signed int)confparse__1__2__1__5__2__5__40__1__1___len);
              if(!(confparse__1__2__1__5__2__5__40__cnst == 1) && !(confparse__1__2__1__5__2__5__40__cnst == 2) && !(confparse__1__2__1__5__2__5__40__cnst == 22))
                goto ASSIGN_CONST_870;

            }

            else
            {

            ASSIGN_CONST_870:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in neg_domain_pol= option.");
              goto free_linebuf_return;
            }
            global->neg_domain_pol = (signed short int)confparse__1__2__1__5__2__5__40__cnst;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L249:
            ;
            signed int confparse__1__2__1__5__2__5__41__val;
            const unsigned short int **return_value___ctype_b_loc_98;
            return_value___ctype_b_loc_98=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_98)[(signed long int)(signed int)*p]) == 0))
            {
              signed int confparse__1__2__1__5__2__5__41__1__cnst;
              ps = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_93=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_93)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_94 = (_Bool)1;

                  else
                    tmp_if_expr_94 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_95 = tmp_if_expr_94 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_95 = (_Bool)0;
              }
              while(tmp_if_expr_95);
              len = (signed int)(p - ps);
              confparse__1__2__1__5__2__5__41__1__cnst=lookup_const(ps, len);
              if(confparse__1__2__1__5__2__5__41__1__cnst == 5)
                confparse__1__2__1__5__2__5__41__val = -1;

              else
                goto bad_port_start_option;
            }

            else
            {
              return_value___ctype_b_loc_97=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc_97)[(signed long int)(signed int)*p]) == 0))
              {
                signed long int return_value_strtol_96;
                return_value_strtol_96=strtol(p, &p, 0);
                confparse__1__2__1__5__2__5__41__val = (signed int)return_value_strtol_96;
                if(confparse__1__2__1__5__2__5__41__val >= 65536)
                {
                  *errstr=report_error(conftype, linenr, "value for query_port_start out of range.");
                  goto free_linebuf_return;
                }

                else
                  if(!(confparse__1__2__1__5__2__5__41__val >= 1024))
                    fprintf(stderr, "Warning: query_port_start=%i but source ports <1204 can only be used as root.\n", confparse__1__2__1__5__2__5__41__val);

              }

              else
              {

              bad_port_start_option:
                ;
                *errstr=report_error(conftype, linenr, "bad qualifier in query_port_start= option.");
                goto free_linebuf_return;
              }
            }
            global->query_port_start = confparse__1__2__1__5__2__5__41__val;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L263:
            ;
            signed int confparse__1__2__1__5__2__5__42__val;
            const unsigned short int **return_value___ctype_b_loc_100;
            return_value___ctype_b_loc_100=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_100)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_99;
              return_value_strtol_99=strtol(p, &p, 0);
              confparse__1__2__1__5__2__5__42__val = (signed int)return_value_strtol_99;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for query_port_end option");
              goto free_linebuf_return;
            }
            if(confparse__1__2__1__5__2__5__42__val >= 65536)
            {
              *errstr=report_error(conftype, linenr, "value for query_port_end out of range.");
              goto free_linebuf_return;
            }

            global->query_port_end = confparse__1__2__1__5__2__5__42__val;
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L267:
            ;
            signed int confparse__1__2__1__5__2__5__43__val;
            const unsigned short int **return_value___ctype_b_loc_102;
            return_value___ctype_b_loc_102=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_102)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_101;
              return_value_strtol_101=strtol(p, &p, 0);
              confparse__1__2__1__5__2__5__43__val = (signed int)return_value_strtol_101;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for udpbufsize");
              goto free_linebuf_return;
            }
            if(confparse__1__2__1__5__2__5__43__val >= 65508 || !(confparse__1__2__1__5__2__5__43__val >= 512))
            {
              *errstr=report_error(conftype, linenr, "value for udpbufsize out of range.");
              goto free_linebuf_return;
            }

            global->udpbufsize = confparse__1__2__1__5__2__5__43__val;
            goto __CPROVER_DUMP_L280;
            do
            {

            __CPROVER_DUMP_L271:
              ;
              const char *confparse__1__2__1__5__2__5__44__1__1___err;
              len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
              if(len == -1)
                goto string_err;

              else
                if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  goto string_too_long;

              confparse__1__2__1__5__2__5__44__1__1___err=zone_add(&global->deleg_only_zones, strbuf, (unsigned int)len);
              if(!(confparse__1__2__1__5__2__5__44__1__1___err == ((const char *)NULL)))
              {
                *errstr=report_error(conftype, linenr, confparse__1__2__1__5__2__5__44__1__1___err);
                goto free_linebuf_return;
              }

              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
                goto unexpected_eof;

              if(!((signed int)*p == 44))
                break;

              p = p + 1l;
              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
                goto unexpected_eof;

            }
            while((_Bool)1);
            goto __CPROVER_DUMP_L280;

          __CPROVER_DUMP_L279:
            ;
            goto internal_parse_error;

          __CPROVER_DUMP_L280:
            ;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          if(!((signed int)*p == 125))
            goto expected_closing_brace;

          if(!(global->query_port_end >= global->query_port_start))
          {
            *errstr=report_error(conftype, linenr, "query_port_end may not be smaller than query_port_start.");
            goto free_linebuf_return;
          }

          break;
        }
        case 2:
        {
          struct anonymous_7 server;
          if(servers == ((struct anonymous_18 **)NULL))
          {
            *errstr=report_error(conftype, linenr, in != ((struct _IO_FILE *)NULL) ? "server section not allowed in include file" : "server section not allowed in eval string");
            goto free_linebuf_return;
          }

          server = serv_presets;
          do
          {
            return_value___ctype_b_loc_103=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc_103)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_104=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc_104)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr_105 = (_Bool)1;

                else
                  tmp_if_expr_105 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_106 = tmp_if_expr_105 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_106 = (_Bool)0;
            }
            while(tmp_if_expr_106);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, server_options, (signed int)(sizeof(const struct anonymous_32 [28l]) /*448ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for server section: %.*s", (signed int)len, ps);
              free_servparm(&server);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 61))
            {
              free_servparm(&server);
              goto expected_equals;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

            switch(option)
            {
              case 43:
              {
                do
                {
                  const char *confparse__1__2__1__5__4__2__6__1__1__1___err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse__1__2__1__5__4__2__6__1__1__1___err=addr_add(&server.atup_a, strbuf);
                  if(!(confparse__1__2__1__5__4__2__6__1__1__1___err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse__1__2__1__5__4__2__6__1__1__1___err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 81:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                char *errmsg;
                signed int return_value_read_resolv_conf_107;
                return_value_read_resolv_conf_107=read_resolv_conf(strbuf, &server.atup_a, &errmsg);
                if(return_value_read_resolv_conf_107 == 0)
                {
                  if(!(errmsg == ((char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, errmsg);
                    free((void *)errmsg);
                  }

                  else
                    *errstr = (char *)(void *)0;
                  free_servparm(&server);
                  goto free_linebuf_return;
                }

                break;
              }
              case 44:
              {
                const unsigned short int **return_value___ctype_b_loc_109;
                return_value___ctype_b_loc_109=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_109)[(signed long int)(signed int)*p]) == 0))
                {
                  signed long int return_value_strtol_108;
                  return_value_strtol_108=strtol(p, &p, 0);
                  server.port = (unsigned short int)return_value_strtol_108;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected unsigned integer value for port option");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 45:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!((unsigned long int)len >= sizeof(char [32l]) /*32ul*/ ))
                {
                  memcpy((void *)server.scheme, (const void *)strbuf, (unsigned long int)len);
                  server.scheme[(signed long int)len] = (char)0;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "scheme: string too long");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 46:
              {
                signed int confparse__1__2__1__5__4__2__6__7__cnst;
                const unsigned short int **return_value___ctype_b_loc_113;
                return_value___ctype_b_loc_113=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_113)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__7__1__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__7__1__1___len;
                  confparse__1__2__1__5__4__2__6__7__1__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_110=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_110)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_111 = (_Bool)1;

                      else
                        tmp_if_expr_111 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_112 = tmp_if_expr_111 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_112 = (_Bool)0;
                  }
                  while(tmp_if_expr_112);
                  confparse__1__2__1__5__4__2__6__7__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__7__1__1___str);
                  confparse__1__2__1__5__4__2__6__7__cnst=lookup_const(confparse__1__2__1__5__4__2__6__7__1__1___str, (signed int)confparse__1__2__1__5__4__2__6__7__1__1___len);
                  if(!(confparse__1__2__1__5__4__2__6__7__cnst == 5) && !(confparse__1__2__1__5__4__2__6__7__cnst == 6) && !(confparse__1__2__1__5__4__2__6__7__cnst == 7) && !(confparse__1__2__1__5__4__2__6__7__cnst == 8) && !(confparse__1__2__1__5__4__2__6__7__cnst == 9) && !(confparse__1__2__1__5__4__2__6__7__cnst == 16) && !(confparse__1__2__1__5__4__2__6__7__cnst == 17))
                    goto ASSIGN_CONST_1001;

                }

                else
                {

                ASSIGN_CONST_1001:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in uptest= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.uptest = (signed short int)confparse__1__2__1__5__4__2__6__7__cnst;
                break;
              }
              case 47:
              {
                const unsigned short int **return_value___ctype_b_loc_114;
                return_value___ctype_b_loc_114=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_114)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__8__1___err;
                  server.timeout=strtotime(p, &p, &confparse__1__2__1__5__4__2__6__8__1___err);
                  if(!(confparse__1__2__1__5__4__2__6__8__1___err == ((char *)NULL)))
                  {
                    *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"timeout option", confparse__1__2__1__5__4__2__6__8__1___err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected a time specification for timeout option");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 48:
              {
                const unsigned short int **return_value___ctype_b_loc_115;
                return_value___ctype_b_loc_115=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_115)[(signed long int)(signed int)*p]) == 0))
                  server.ping_timeout=strtol(p, &p, 0);

                else
                {
                  *errstr=report_error(conftype, linenr, "expected unsigned integer value for ping_timeout option");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 49:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                const char *err;
                err=parse_ip(strbuf, &server.ping_a);
                if(!(err == ((const char *)NULL)))
                {
                  *errstr=report_errorf(conftype, linenr, "%s for the ping_ip= option.", err);
                  free_servparm(&server);
                  goto free_linebuf_return;
                }

                break;
              }
              case 50:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!(server.uptest_cmd == ((char *)NULL)))
                  free((void *)server.uptest_cmd);

                server.uptest_cmd=strndup(strbuf, (unsigned long int)len);
                if(server.uptest_cmd == ((char *)NULL))
                {
                  free_servparm(&server);
                  goto out_of_memory;
                }

                p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                if(p == ((char *)NULL))
                {
                  free_servparm(&server);
                  goto unexpected_eof;
                }

                if((signed int)*p == 44)
                {
                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  if(!((unsigned long int)len >= sizeof(char [21l]) /*21ul*/ ))
                  {
                    memcpy((void *)server.uptest_usr, (const void *)strbuf, (unsigned long int)len);
                    server.uptest_usr[(signed long int)len] = (char)0;
                  }

                  else
                  {
                    *errstr=report_error(conftype, linenr, "second argument of uptest_cmd: string too long");
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }
                }

                break;
              }
              case 51:
              {
                return_value___ctype_b_loc_119=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_119)[(signed long int)(signed int)*p]) == 0))
                {
                  signed int confparse__1__2__1__5__4__2__6__16__cnst;
                  ps = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_116=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_116)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_117 = (_Bool)1;

                      else
                        tmp_if_expr_117 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_118 = tmp_if_expr_117 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_118 = (_Bool)0;
                  }
                  while(tmp_if_expr_118);
                  len = (signed int)(p - ps);
                  if(!((signed int)*p == 46))
                  {
                    if(!((signed int)*p == 45))
                    {
                      confparse__1__2__1__5__4__2__6__16__cnst=lookup_const(ps, len);
                      if(confparse__1__2__1__5__4__2__6__16__cnst == 5)
                      {
                        if(!(server.query_test_name == ((unsigned char *)NULL)))
                          free((void *)server.query_test_name);

                        server.query_test_name = (unsigned char *)(void *)0;
                        break;
                      }

                    }

                  }

                  p = ps;
                }

                unsigned char tname[256l];
                unsigned char *copy;
                unsigned int confparse__1__2__1__5__4__2__6__17__sz;
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                const char *confparse__1__2__1__5__4__2__6__17__2___err;
                confparse__1__2__1__5__4__2__6__17__2___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, tname);
                if(!(confparse__1__2__1__5__4__2__6__17__2___err == ((const char *)NULL)))
                {
                  *errstr=report_error(conftype, linenr, confparse__1__2__1__5__4__2__6__17__2___err);
                  free_servparm(&server);
                  goto free_linebuf_return;
                }

                confparse__1__2__1__5__4__2__6__17__sz=rhnlen(tname);
                void *return_value_malloc_120;
                return_value_malloc_120=malloc((unsigned long int)confparse__1__2__1__5__4__2__6__17__sz);
                copy = (unsigned char *)return_value_malloc_120;
                if(copy == ((unsigned char *)NULL))
                {
                  free_servparm(&server);
                  goto out_of_memory;
                }

                memcpy((void *)copy, (const void *)tname, (unsigned long int)confparse__1__2__1__5__4__2__6__17__sz);
                if(!(server.query_test_name == ((unsigned char *)NULL)))
                  free((void *)server.query_test_name);

                server.query_test_name = copy;
                break;
              }
              case 52:
              {
                return_value___ctype_b_loc_125=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_125)[(signed long int)(signed int)*p]) == 0))
                {
                  signed int confparse__1__2__1__5__4__2__6__18__cnst;
                  ps = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_121=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_121)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_122 = (_Bool)1;

                      else
                        tmp_if_expr_122 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_123 = tmp_if_expr_122 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_123 = (_Bool)0;
                  }
                  while(tmp_if_expr_123);
                  len = (signed int)(p - ps);
                  confparse__1__2__1__5__4__2__6__18__cnst=lookup_const(ps, len);
                  if(confparse__1__2__1__5__4__2__6__18__cnst == 10)
                    server.interval = (signed long int)-1;

                  else
                    if(confparse__1__2__1__5__4__2__6__18__cnst == 11)
                      server.interval = (signed long int)-2;

                    else
                      goto bad_interval_option;
                }

                else
                {
                  return_value___ctype_b_loc_124=__ctype_b_loc();
                  if(!((2048 & (signed int)(*return_value___ctype_b_loc_124)[(signed long int)(signed int)*p]) == 0))
                  {
                    char *confparse__1__2__1__5__4__2__6__19__err;
                    server.interval=strtotime(p, &p, &confparse__1__2__1__5__4__2__6__19__err);
                    if(!(confparse__1__2__1__5__4__2__6__19__err == ((char *)NULL)))
                    {
                      *errstr=report_errorf(conftype, linenr, "bad time specification in interval= option: %s", confparse__1__2__1__5__4__2__6__19__err);
                      free_servparm(&server);
                      goto free_linebuf_return;
                    }

                  }

                  else
                  {

                  bad_interval_option:
                    ;
                    *errstr=report_error(conftype, linenr, "bad qualifier in interval= option.");
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }
                }
                break;
              }
              case 53:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!((unsigned long int)len >= sizeof(char [16l]) /*16ul*/ ))
                {
                  memcpy((void *)server.interface, (const void *)strbuf, (unsigned long int)len);
                  server.interface[(signed long int)len] = (char)0;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "interface: string too long");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 54:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!((unsigned long int)len >= sizeof(char [16l]) /*16ul*/ ))
                {
                  memcpy((void *)server.device, (const void *)strbuf, (unsigned long int)len);
                  server.device[(signed long int)len] = (char)0;
                }

                else
                {
                  *errstr=report_error(conftype, linenr, "device: string too long");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 55:
              {
                const unsigned short int **return_value___ctype_b_loc_129;
                return_value___ctype_b_loc_129=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_129)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__25__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__25__1___len;
                  signed int confparse__1__2__1__5__4__2__6__25__1___cnst;
                  confparse__1__2__1__5__4__2__6__25__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_126=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_126)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_127 = (_Bool)1;

                      else
                        tmp_if_expr_127 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_128 = tmp_if_expr_127 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_128 = (_Bool)0;
                  }
                  while(tmp_if_expr_128);
                  confparse__1__2__1__5__4__2__6__25__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__25__1___str);
                  confparse__1__2__1__5__4__2__6__25__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__25__1___str, (signed int)confparse__1__2__1__5__4__2__6__25__1___len);
                  if(confparse__1__2__1__5__4__2__6__25__1___cnst == 1 || confparse__1__2__1__5__4__2__6__25__1___cnst == 2)
                    server.purge_cache = (char)(confparse__1__2__1__5__4__2__6__25__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1111;
                }

                else
                {

                ASSIGN_ON_OFF_1111:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in purge_cache= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 56:
              {
                const unsigned short int **return_value___ctype_b_loc_133;
                return_value___ctype_b_loc_133=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_133)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__26__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__26__1___len;
                  signed int confparse__1__2__1__5__4__2__6__26__1___cnst;
                  confparse__1__2__1__5__4__2__6__26__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_130=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_130)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_131 = (_Bool)1;

                      else
                        tmp_if_expr_131 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_132 = tmp_if_expr_131 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_132 = (_Bool)0;
                  }
                  while(tmp_if_expr_132);
                  confparse__1__2__1__5__4__2__6__26__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__26__1___str);
                  confparse__1__2__1__5__4__2__6__26__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__26__1___str, (signed int)confparse__1__2__1__5__4__2__6__26__1___len);
                  if(confparse__1__2__1__5__4__2__6__26__1___cnst == 1 || confparse__1__2__1__5__4__2__6__26__1___cnst == 2)
                    server.nocache = (char)(confparse__1__2__1__5__4__2__6__26__1___cnst == 2);

                  else
                    goto ASSIGN_ON_OFF_1115;
                }

                else
                {

                ASSIGN_ON_OFF_1115:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in caching= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 57:
              {
                const unsigned short int **return_value___ctype_b_loc_137;
                return_value___ctype_b_loc_137=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_137)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__27__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__27__1___len;
                  signed int confparse__1__2__1__5__4__2__6__27__1___cnst;
                  confparse__1__2__1__5__4__2__6__27__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_134=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_134)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_135 = (_Bool)1;

                      else
                        tmp_if_expr_135 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_136 = tmp_if_expr_135 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_136 = (_Bool)0;
                  }
                  while(tmp_if_expr_136);
                  confparse__1__2__1__5__4__2__6__27__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__27__1___str);
                  confparse__1__2__1__5__4__2__6__27__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__27__1___str, (signed int)confparse__1__2__1__5__4__2__6__27__1___len);
                  if(confparse__1__2__1__5__4__2__6__27__1___cnst == 1 || confparse__1__2__1__5__4__2__6__27__1___cnst == 2)
                    server.lean_query = (char)(confparse__1__2__1__5__4__2__6__27__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1119;
                }

                else
                {

                ASSIGN_ON_OFF_1119:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in lean_query= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 58:
              {
                const unsigned short int **return_value___ctype_b_loc_141;
                return_value___ctype_b_loc_141=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_141)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__28__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__28__1___len;
                  signed int confparse__1__2__1__5__4__2__6__28__1___cnst;
                  confparse__1__2__1__5__4__2__6__28__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_138=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_138)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_139 = (_Bool)1;

                      else
                        tmp_if_expr_139 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_140 = tmp_if_expr_139 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_140 = (_Bool)0;
                  }
                  while(tmp_if_expr_140);
                  confparse__1__2__1__5__4__2__6__28__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__28__1___str);
                  confparse__1__2__1__5__4__2__6__28__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__28__1___str, (signed int)confparse__1__2__1__5__4__2__6__28__1___len);
                  if(confparse__1__2__1__5__4__2__6__28__1___cnst == 1 || confparse__1__2__1__5__4__2__6__28__1___cnst == 2)
                    server.edns_query = (char)(confparse__1__2__1__5__4__2__6__28__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1123;
                }

                else
                {

                ASSIGN_ON_OFF_1123:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in edns_query= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 59:
              {
                const unsigned short int **return_value___ctype_b_loc_145;
                return_value___ctype_b_loc_145=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_145)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__29__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__29__1___len;
                  signed int confparse__1__2__1__5__4__2__6__29__1___cnst;
                  confparse__1__2__1__5__4__2__6__29__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_142=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_142)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_143 = (_Bool)1;

                      else
                        tmp_if_expr_143 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_144 = tmp_if_expr_143 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_144 = (_Bool)0;
                  }
                  while(tmp_if_expr_144);
                  confparse__1__2__1__5__4__2__6__29__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__29__1___str);
                  confparse__1__2__1__5__4__2__6__29__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__29__1___str, (signed int)confparse__1__2__1__5__4__2__6__29__1___len);
                  if(confparse__1__2__1__5__4__2__6__29__1___cnst == 1 || confparse__1__2__1__5__4__2__6__29__1___cnst == 2)
                    server.preset = (char)(confparse__1__2__1__5__4__2__6__29__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1127;
                }

                else
                {

                ASSIGN_ON_OFF_1127:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in preset= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 60:
              {
                const unsigned short int **return_value___ctype_b_loc_149;
                return_value___ctype_b_loc_149=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_149)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__30__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__30__1___len;
                  signed int confparse__1__2__1__5__4__2__6__30__1___cnst;
                  confparse__1__2__1__5__4__2__6__30__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_146=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_146)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_147 = (_Bool)1;

                      else
                        tmp_if_expr_147 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_148 = tmp_if_expr_147 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_148 = (_Bool)0;
                  }
                  while(tmp_if_expr_148);
                  confparse__1__2__1__5__4__2__6__30__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__30__1___str);
                  confparse__1__2__1__5__4__2__6__30__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__30__1___str, (signed int)confparse__1__2__1__5__4__2__6__30__1___len);
                  if(confparse__1__2__1__5__4__2__6__30__1___cnst == 1 || confparse__1__2__1__5__4__2__6__30__1___cnst == 2)
                    server.is_proxy = (char)(confparse__1__2__1__5__4__2__6__30__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1131;
                }

                else
                {

                ASSIGN_ON_OFF_1131:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in proxy_only= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 61:
              {
                signed int confparse__1__2__1__5__4__2__6__31__cnst;
                const unsigned short int **return_value___ctype_b_loc_153;
                return_value___ctype_b_loc_153=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_153)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__31__1__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__31__1__1___len;
                  confparse__1__2__1__5__4__2__6__31__1__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_150=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_150)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_151 = (_Bool)1;

                      else
                        tmp_if_expr_151 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_152 = tmp_if_expr_151 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_152 = (_Bool)0;
                  }
                  while(tmp_if_expr_152);
                  confparse__1__2__1__5__4__2__6__31__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__31__1__1___str);
                  confparse__1__2__1__5__4__2__6__31__cnst=lookup_const(confparse__1__2__1__5__4__2__6__31__1__1___str, (signed int)confparse__1__2__1__5__4__2__6__31__1__1___len);
                  if(!(confparse__1__2__1__5__4__2__6__31__cnst == 1) && !(confparse__1__2__1__5__4__2__6__31__cnst == 2) && !(confparse__1__2__1__5__4__2__6__31__cnst == 4))
                    goto ASSIGN_CONST_1136;

                }

                else
                {

                ASSIGN_CONST_1136:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in root_server= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.rootserver = (char)(confparse__1__2__1__5__4__2__6__31__cnst == 4 ? 2 : (signed int)(confparse__1__2__1__5__4__2__6__31__cnst == 1));
                break;
              }
              case 62:
              {
                const unsigned short int **return_value___ctype_b_loc_157;
                return_value___ctype_b_loc_157=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_157)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__32__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__32__1___len;
                  signed int confparse__1__2__1__5__4__2__6__32__1___cnst;
                  confparse__1__2__1__5__4__2__6__32__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_154=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_154)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_155 = (_Bool)1;

                      else
                        tmp_if_expr_155 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_156 = tmp_if_expr_155 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_156 = (_Bool)0;
                  }
                  while(tmp_if_expr_156);
                  confparse__1__2__1__5__4__2__6__32__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__32__1___str);
                  confparse__1__2__1__5__4__2__6__32__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__32__1___str, (signed int)confparse__1__2__1__5__4__2__6__32__1___len);
                  if(confparse__1__2__1__5__4__2__6__32__1___cnst == 1 || confparse__1__2__1__5__4__2__6__32__1___cnst == 2)
                    server.rand_servers = (char)(confparse__1__2__1__5__4__2__6__32__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1142;
                }

                else
                {

                ASSIGN_ON_OFF_1142:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in randomize_servers= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 65:
              {
                signed int confparse__1__2__1__5__4__2__6__33__cnst;
                const unsigned short int **return_value___ctype_b_loc_161;
                return_value___ctype_b_loc_161=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_161)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__33__1__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__33__1__1___len;
                  confparse__1__2__1__5__4__2__6__33__1__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_158=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_158)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_159 = (_Bool)1;

                      else
                        tmp_if_expr_159 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_160 = tmp_if_expr_159 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_160 = (_Bool)0;
                  }
                  while(tmp_if_expr_160);
                  confparse__1__2__1__5__4__2__6__33__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__33__1__1___str);
                  confparse__1__2__1__5__4__2__6__33__cnst=lookup_const(confparse__1__2__1__5__4__2__6__33__1__1___str, (signed int)confparse__1__2__1__5__4__2__6__33__1__1___len);
                  if(!(confparse__1__2__1__5__4__2__6__33__cnst == 18) && !(confparse__1__2__1__5__4__2__6__33__cnst == 19) && !(confparse__1__2__1__5__4__2__6__33__cnst == 20) && !(confparse__1__2__1__5__4__2__6__33__cnst == 21))
                    goto ASSIGN_CONST_1147;

                }

                else
                {

                ASSIGN_CONST_1147:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in policy= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.policy = (signed short int)confparse__1__2__1__5__4__2__6__33__cnst;
                break;
              }
              case 63:
              {
                do
                {
                  const char *confparse__1__2__1__5__4__2__6__34__1__1___err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse__1__2__1__5__4__2__6__34__1__1___err=slist_add(&server.alist, strbuf, (unsigned int)len, 18);
                  if(!(confparse__1__2__1__5__4__2__6__34__1__1___err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse__1__2__1__5__4__2__6__34__1__1___err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 64:
              {
                do
                {
                  const char *confparse__1__2__1__5__4__2__6__35__1__1___err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse__1__2__1__5__4__2__6__35__1__1___err=slist_add(&server.alist, strbuf, (unsigned int)len, 19);
                  if(!(confparse__1__2__1__5__4__2__6__35__1__1___err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse__1__2__1__5__4__2__6__35__1__1___err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 66:
              {
                do
                {
                  const char *confparse__1__2__1__5__4__2__6__36__1__1___err;
                  len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                  if(len == -1)
                  {
                    free_servparm(&server);
                    goto string_err;
                  }

                  else
                    if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    {
                      free_servparm(&server);
                      goto string_too_long;
                    }

                  confparse__1__2__1__5__4__2__6__36__1__1___err=reject_add(&server, strbuf);
                  if(!(confparse__1__2__1__5__4__2__6__36__1__1___err == ((const char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse__1__2__1__5__4__2__6__36__1__1___err);
                    free_servparm(&server);
                    goto free_linebuf_return;
                  }

                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                  if(!((signed int)*p == 44))
                    break;

                  p = p + 1l;
                  p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                  if(p == ((char *)NULL))
                  {
                    free_servparm(&server);
                    goto unexpected_eof;
                  }

                }
                while((_Bool)1);
                break;
              }
              case 67:
              {
                signed int confparse__1__2__1__5__4__2__6__37__cnst;
                const unsigned short int **return_value___ctype_b_loc_165;
                return_value___ctype_b_loc_165=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_165)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__37__1__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__37__1__1___len;
                  confparse__1__2__1__5__4__2__6__37__1__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_162=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_162)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_163 = (_Bool)1;

                      else
                        tmp_if_expr_163 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_164 = tmp_if_expr_163 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_164 = (_Bool)0;
                  }
                  while(tmp_if_expr_164);
                  confparse__1__2__1__5__4__2__6__37__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__37__1__1___str);
                  confparse__1__2__1__5__4__2__6__37__cnst=lookup_const(confparse__1__2__1__5__4__2__6__37__1__1___str, (signed int)confparse__1__2__1__5__4__2__6__37__1__1___len);
                  if(!(confparse__1__2__1__5__4__2__6__37__cnst == 24) && !(confparse__1__2__1__5__4__2__6__37__cnst == 25))
                    goto ASSIGN_CONST_1166;

                }

                else
                {

                ASSIGN_CONST_1166:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in reject_policy= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                server.rejectpolicy = (signed short int)confparse__1__2__1__5__4__2__6__37__cnst;
                break;
              }
              case 68:
              {
                const unsigned short int **return_value___ctype_b_loc_169;
                return_value___ctype_b_loc_169=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_169)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__4__2__6__38__1___str;
                  unsigned long int confparse__1__2__1__5__4__2__6__38__1___len;
                  signed int confparse__1__2__1__5__4__2__6__38__1___cnst;
                  confparse__1__2__1__5__4__2__6__38__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_166=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_166)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_167 = (_Bool)1;

                      else
                        tmp_if_expr_167 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_168 = tmp_if_expr_167 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_168 = (_Bool)0;
                  }
                  while(tmp_if_expr_168);
                  confparse__1__2__1__5__4__2__6__38__1___len = (unsigned long int)(p - confparse__1__2__1__5__4__2__6__38__1___str);
                  confparse__1__2__1__5__4__2__6__38__1___cnst=lookup_const(confparse__1__2__1__5__4__2__6__38__1___str, (signed int)confparse__1__2__1__5__4__2__6__38__1___len);
                  if(confparse__1__2__1__5__4__2__6__38__1___cnst == 1 || confparse__1__2__1__5__4__2__6__38__1___cnst == 2)
                    server.rejectrecursively = (char)(confparse__1__2__1__5__4__2__6__38__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1172;
                }

                else
                {

                ASSIGN_ON_OFF_1172:
                  ;
                  *errstr=report_error(conftype, linenr, "bad qualifier in reject_recursively= option.");
                  free_servparm(&server);
                  goto free_linebuf_return;
                }
                break;
              }
              case 69:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                {
                  free_servparm(&server);
                  goto string_err;
                }

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  {
                    free_servparm(&server);
                    goto string_too_long;
                  }

                if(!(server.label == ((char *)NULL)))
                  free((void *)server.label);

                server.label=strndup(strbuf, (unsigned long int)len);
                if(server.label == ((char *)NULL))
                {
                  free_servparm(&server);
                  goto out_of_memory;
                }

                break;
              }
              default:
              {
                free_servparm(&server);
                goto internal_parse_error;
              }
            }
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 59))
            {
              free_servparm(&server);
              goto expected_semicolon;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_servparm(&server);
              goto unexpected_eof;
            }

          }
          while((_Bool)1);
          if(!((signed int)*p == 125))
          {
            free_servparm(&server);
            goto expected_closing_brace;
          }

          if((signed int)server.uptest == 7)
          {
            if(server.uptest_cmd == ((char *)NULL))
            {
              *errstr=report_error(conftype, linenr, "you must specify uptest_cmd if you specify uptest=exec!");
              free_servparm(&server);
              goto free_linebuf_return;
            }

          }

          if(!(server.is_proxy == 0) && !(server.rootserver == 0))
          {
            *errstr=report_error(conftype, linenr, "A server may not be specified as both a proxy and a root-server.");
            free_servparm(&server);
            goto free_linebuf_return;
          }

          if(!(server.rootserver == 0) && ((signed int)server.policy == 20 || (signed int)server.policy == 21))
          {
            return_value_const_name_170=const_name((signed int)server.policy);
            fprintf(stderr, "Warning: using policy=%s with a root-server usually makes no sense.", return_value_const_name_170);
          }

          unsigned int return_value_da_nel_172;
          return_value_da_nel_172=da_nel((struct anonymous_3 *)server.atup_a);
          if(!(return_value_da_nel_172 == 0u))
          {
            check_localaddrs(&server);
            unsigned int return_value_da_nel_171;
            return_value_da_nel_171=da_nel((struct anonymous_3 *)server.atup_a);
            if(return_value_da_nel_171 == 0u)
            {
              *errstr=report_error(conftype, linenr, "Server section contains only local IP addresses.\nBind pdnsd to a different local IP address or specify different port numbers in global section and server section if you want pdnsd to query servers on the same machine.");
              free_servparm(&server);
              goto free_linebuf_return;
            }

          }

          signed int j;
          signed int confparse__1__2__1__5__4__7__n;
          unsigned int return_value_da_nel_173;
          return_value_da_nel_173=da_nel((struct anonymous_3 *)server.atup_a);
          confparse__1__2__1__5__4__7__n = (signed int)return_value_da_nel_173;
          j = 0;
          for( ; !(j >= confparse__1__2__1__5__4__7__n); j = j + 1)
          {
            struct anonymous_20 *at = &server.atup_a->elem[(signed long int)j];
            at->is_up = server.preset;
            if(!(server.interval >= 0l))
              at->i_ts=time((signed long int *)(void *)0);

          }
          if(server.interval == -1l)
            global->onquery = (char)1;

          struct anonymous_3 *return_value_da_grow1_174;
          return_value_da_grow1_174=da_grow1((struct anonymous_3 *)*servers, (unsigned long int)((struct anonymous_18 *)0)->elem, sizeof(struct anonymous_7) /*208ul*/ , (void (*)(void *))free_servparm);
          *servers = (struct anonymous_18 *)return_value_da_grow1_174;
          if(*servers == ((struct anonymous_18 *)NULL))
          {
            free_servparm(&server);
            goto out_of_memory;
          }

          (*servers)->elem[(signed long int)((*servers)->nel - (unsigned long int)1)] = server;
          break;
        }
        case 3:
        {
          confparse__1__2__1__5__5__c_cent = (struct anonymous_0){ .qname=((unsigned char *)NULL), .cs=0ul, .num_rrs=0,
    .flags=0, ._anon0={ .rr={ .rrmu={ ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL), ((struct anonymous *)NULL) }, .rrext=((struct anonymous **)NULL) } }, .c_ns=0,
    .c_soa=0 };
          confparse__1__2__1__5__5__c_ttl = (signed long int)86400;
          c_flags = (unsigned int)2;
          reverse = (unsigned char)0;
          do
          {
            return_value___ctype_b_loc_175=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc_175)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_176=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc_176)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr_177 = (_Bool)1;

                else
                  tmp_if_expr_177 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_178 = tmp_if_expr_177 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_178 = (_Bool)0;
            }
            while(tmp_if_expr_178);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, rr_options, (signed int)(sizeof(const struct anonymous_32 [13l]) /*208ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for rr section: %.*s", (signed int)len, ps);
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 61))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto expected_equals;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!(option == 77))
            {
              if(option == 79)
                goto __CPROVER_DUMP_L553;

              if(option == 83)
                goto __CPROVER_DUMP_L557;

              if(option == 84)
                goto __CPROVER_DUMP_L566;

              if(option == 70)
                goto __CPROVER_DUMP_L576;

              if(option == 78)
                goto __CPROVER_DUMP_L583;

              if(option == 74)
                goto __CPROVER_DUMP_L584;

              if(option == 71)
                goto __CPROVER_DUMP_L585;

              if(option == 72)
                goto __CPROVER_DUMP_L590;

              if(option == 73)
                goto __CPROVER_DUMP_L600;

              if(option == 76)
                goto __CPROVER_DUMP_L644;

              if(option == 75)
                goto __CPROVER_DUMP_L645;

              goto __CPROVER_DUMP_L656;
            }

            unsigned char c_name[256l];
            if(!(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, "You may specify only one name in a rr section.");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto string_too_long;
              }

            const char *confparse__1__2__1__5__5__1__6__1__3___err;
            confparse__1__2__1__5__5__1__6__1__3___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, c_name);
            if(!(confparse__1__2__1__5__5__1__6__1__3___err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse__1__2__1__5__5__1__6__1__3___err);
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            signed int return_value_init_cent_179;
            return_value_init_cent_179=init_cent(&confparse__1__2__1__5__5__c_cent, c_name, (signed long int)0, (signed long int)0, c_flags);
            if(return_value_init_cent_179 == 0)
              goto out_of_memory;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L553:
            ;
            const unsigned short int **return_value___ctype_b_loc_180;
            return_value___ctype_b_loc_180=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_180)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__5__1__6__2__1___err;
              confparse__1__2__1__5__5__c_ttl=strtotime(p, &p, &confparse__1__2__1__5__5__1__6__2__1___err);
              if(!(confparse__1__2__1__5__5__1__6__2__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"ttl option", confparse__1__2__1__5__5__1__6__2__1___err);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for ttl option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L557:
            ;
            signed int confparse__1__2__1__5__5__1__6__3__cnst;
            if(!(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, "The authrec= option has no effect unless it precedes name= in a rr section.");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            const unsigned short int **return_value___ctype_b_loc_184;
            return_value___ctype_b_loc_184=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_184)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__5__1__6__3__2__1___str;
              unsigned long int confparse__1__2__1__5__5__1__6__3__2__1___len;
              confparse__1__2__1__5__5__1__6__3__2__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_181=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_181)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_182 = (_Bool)1;

                  else
                    tmp_if_expr_182 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_183 = tmp_if_expr_182 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_183 = (_Bool)0;
              }
              while(tmp_if_expr_183);
              confparse__1__2__1__5__5__1__6__3__2__1___len = (unsigned long int)(p - confparse__1__2__1__5__5__1__6__3__2__1___str);
              confparse__1__2__1__5__5__1__6__3__cnst=lookup_const(confparse__1__2__1__5__5__1__6__3__2__1___str, (signed int)confparse__1__2__1__5__5__1__6__3__2__1___len);
              if(!(confparse__1__2__1__5__5__1__6__3__cnst == 1) && !(confparse__1__2__1__5__5__1__6__3__cnst == 2))
                goto ASSIGN_CONST_1282;

            }

            else
            {

            ASSIGN_CONST_1282:
              ;
              *errstr=report_error(conftype, linenr, "Bad qualifier in authrec= option.");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            c_flags = (unsigned int)(confparse__1__2__1__5__5__1__6__3__cnst == 1 ? 2 : 0);
            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L566:
            ;
            const unsigned short int **return_value___ctype_b_loc_188;
            return_value___ctype_b_loc_188=__ctype_b_loc();
            if(!((1024 & (signed int)(*return_value___ctype_b_loc_188)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__5__1__6__4__1___str;
              unsigned long int confparse__1__2__1__5__5__1__6__4__1___len;
              signed int confparse__1__2__1__5__5__1__6__4__1___cnst;
              confparse__1__2__1__5__5__1__6__4__1___str = p;
              do
              {
                p = p + 1l;
                if(!(*p == 0))
                {
                  return_value___ctype_b_loc_185=__ctype_b_loc();
                  if(!((8 & (signed int)(*return_value___ctype_b_loc_185)[(signed long int)(signed int)*p]) == 0))
                    tmp_if_expr_186 = (_Bool)1;

                  else
                    tmp_if_expr_186 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_187 = tmp_if_expr_186 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_187 = (_Bool)0;
              }
              while(tmp_if_expr_187);
              confparse__1__2__1__5__5__1__6__4__1___len = (unsigned long int)(p - confparse__1__2__1__5__5__1__6__4__1___str);
              confparse__1__2__1__5__5__1__6__4__1___cnst=lookup_const(confparse__1__2__1__5__5__1__6__4__1___str, (signed int)confparse__1__2__1__5__5__1__6__4__1___len);
              if(confparse__1__2__1__5__5__1__6__4__1___cnst == 1 || confparse__1__2__1__5__5__1__6__4__1___cnst == 2)
                reverse = (unsigned char)(confparse__1__2__1__5__5__1__6__4__1___cnst == 1);

              else
                goto ASSIGN_ON_OFF_1288;
            }

            else
            {

            ASSIGN_ON_OFF_1288:
              ;
              *errstr=report_error(conftype, linenr, "bad qualifier in reverse= option.");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L576:
            ;
            unsigned int sz;
            union anonymous_6 c_a;
            if(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto string_too_long;
              }

            signed int return_value_inet_aton_190;
            return_value_inet_aton_190=inet_aton(strbuf, &c_a.ipv4);
            if(!(return_value_inet_aton_190 == 0))
            {
              tp = 1;
              sz = (unsigned int)sizeof(struct in_addr) /*4ul*/ ;
            }

            else
            {
              return_value_inet_pton_189=inet_pton(10, strbuf, (void *)&c_a.ipv6);
              if(return_value_inet_pton_189 >= 1)
              {
                tp = 28;
                sz = (unsigned int)sizeof(struct in6_addr) /*16ul*/ ;
              }

              else
              {
                *errstr=report_error(conftype, linenr, "bad IP address in a= option.");
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }
            }
            signed int return_value_add_cent_rr_191;
            return_value_add_cent_rr_191=add_cent_rr(&confparse__1__2__1__5__5__c_cent, tp, confparse__1__2__1__5__5__c_ttl, (signed long int)0, (unsigned int)2, sz, (void *)&c_a);
            if(return_value_add_cent_rr_191 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L583:
            ;
            tp = 2;
            goto scan_name;

          __CPROVER_DUMP_L584:
            ;
            tp = 5;
            goto scan_name;

          __CPROVER_DUMP_L585:
            ;
            tp = 12;

          scan_name:
            ;
            unsigned char confparse__1__2__1__5__5__1__6__6__c_name[256l];
            if(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto string_too_long;
              }

            const char *confparse__1__2__1__5__5__1__6__6__2___err;
            confparse__1__2__1__5__5__1__6__6__2___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, confparse__1__2__1__5__5__1__6__6__c_name);
            if(!(confparse__1__2__1__5__5__1__6__6__2___err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse__1__2__1__5__5__1__6__6__2___err);
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            unsigned int return_value_rhnlen_192;
            return_value_rhnlen_192=rhnlen(confparse__1__2__1__5__5__1__6__6__c_name);
            signed int return_value_add_cent_rr_193;
            return_value_add_cent_rr_193=add_cent_rr(&confparse__1__2__1__5__5__c_cent, tp, confparse__1__2__1__5__5__c_ttl, (signed long int)0, (unsigned int)2, return_value_rhnlen_192, (void *)confparse__1__2__1__5__5__1__6__6__c_name);
            if(return_value_add_cent_rr_193 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L590:
            ;
            unsigned char *cp;
            unsigned int pref;
            unsigned char c_mx[258l];
            if(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            cp = c_mx + (signed long int)2;
            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto string_too_long;
              }

            const char *confparse__1__2__1__5__5__1__6__7__2___err;
            confparse__1__2__1__5__5__1__6__7__2___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, cp);
            if(!(confparse__1__2__1__5__5__1__6__7__2___err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse__1__2__1__5__5__1__6__7__2___err);
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing second argument (preference level) of mx= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc_195;
            return_value___ctype_b_loc_195=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_195)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_194;
              return_value_strtol_194=strtol(p, &p, 0);
              pref = (unsigned int)return_value_strtol_194;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for second argument of mx= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            cp = c_mx;
            do
            {
              unsigned short int t_s = (unsigned short int)pref;
              unsigned char *t_cp = (unsigned char *)cp;
              unsigned char *tmp_post_196 = t_cp;
              t_cp = t_cp + 1l;
              *tmp_post_196 = (unsigned char)((signed int)t_s >> 8);
              unsigned char *tmp_post_197 = t_cp;
              t_cp = t_cp + 1l;
              *tmp_post_197 = (unsigned char)t_s;
              cp = (unsigned char *)(void *)t_cp;
            }
            while((_Bool)0);
            unsigned int return_value_rhnlen_198;
            return_value_rhnlen_198=rhnlen(cp);
            signed int return_value_add_cent_rr_199;
            return_value_add_cent_rr_199=add_cent_rr(&confparse__1__2__1__5__5__c_cent, 15, confparse__1__2__1__5__5__c_ttl, (signed long int)0, (unsigned int)2, (unsigned int)2 + return_value_rhnlen_198, (void *)c_mx);
            if(return_value_add_cent_rr_199 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L600:
            ;
            unsigned int blen;
            unsigned int rlen;
            unsigned char *bp;
            unsigned int confparse__1__2__1__5__5__1__6__8__val;
            unsigned char buf[532l];
            if(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto string_too_long;
              }

            const char *confparse__1__2__1__5__5__1__6__8__2___err;
            confparse__1__2__1__5__5__1__6__8__2___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, buf);
            if(!(confparse__1__2__1__5__5__1__6__8__2___err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse__1__2__1__5__5__1__6__8__2___err);
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            rlen=rhnlen(buf);
            blen = rlen;
            bp = buf + (signed long int)rlen;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 2nd argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
            if(len == -1)
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto string_err;
            }

            else
              if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
              {
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto string_too_long;
              }

            const char *confparse__1__2__1__5__5__1__6__8__5___err;
            confparse__1__2__1__5__5__1__6__8__5___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, bp);
            if(!(confparse__1__2__1__5__5__1__6__8__5___err == ((const char *)NULL)))
            {
              *errstr=report_error(conftype, linenr, confparse__1__2__1__5__5__1__6__8__5___err);
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            rlen=rhnlen(bp);
            blen = blen + rlen;
            bp = bp + (signed long int)rlen;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 3rd argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc_201;
            return_value___ctype_b_loc_201=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_201)[(signed long int)(signed int)*p]) == 0))
            {
              signed long int return_value_strtol_200;
              return_value_strtol_200=strtol(p, &p, 0);
              confparse__1__2__1__5__5__1__6__8__val = (unsigned int)return_value_strtol_200;
            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected unsigned integer value for 3rd argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int t_l = (unsigned int)confparse__1__2__1__5__5__1__6__8__val;
              unsigned char *confparse__1__2__1__5__5__1__6__8__8__t_cp = (unsigned char *)bp;
              unsigned char *tmp_post_202 = confparse__1__2__1__5__5__1__6__8__8__t_cp;
              confparse__1__2__1__5__5__1__6__8__8__t_cp = confparse__1__2__1__5__5__1__6__8__8__t_cp + 1l;
              *tmp_post_202 = (unsigned char)(t_l >> 24);
              unsigned char *tmp_post_203 = confparse__1__2__1__5__5__1__6__8__8__t_cp;
              confparse__1__2__1__5__5__1__6__8__8__t_cp = confparse__1__2__1__5__5__1__6__8__8__t_cp + 1l;
              *tmp_post_203 = (unsigned char)(t_l >> 16);
              unsigned char *tmp_post_204 = confparse__1__2__1__5__5__1__6__8__8__t_cp;
              confparse__1__2__1__5__5__1__6__8__8__t_cp = confparse__1__2__1__5__5__1__6__8__8__t_cp + 1l;
              *tmp_post_204 = (unsigned char)(t_l >> 8);
              unsigned char *tmp_post_205 = confparse__1__2__1__5__5__1__6__8__8__t_cp;
              confparse__1__2__1__5__5__1__6__8__8__t_cp = confparse__1__2__1__5__5__1__6__8__8__t_cp + 1l;
              *tmp_post_205 = (unsigned char)t_l;
              bp = (unsigned char *)(void *)confparse__1__2__1__5__5__1__6__8__8__t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 4th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc_207;
            return_value___ctype_b_loc_207=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_207)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__5__1__6__8__10__1___err;
              signed long int return_value_strtotime_206;
              return_value_strtotime_206=strtotime(p, &p, &confparse__1__2__1__5__5__1__6__8__10__1___err);
              confparse__1__2__1__5__5__1__6__8__val = (unsigned int)return_value_strtotime_206;
              if(!(confparse__1__2__1__5__5__1__6__8__10__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"4th argument of soa= option", confparse__1__2__1__5__5__1__6__8__10__1___err);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 4th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse__1__2__1__5__5__1__6__8__11__t_l = (unsigned int)confparse__1__2__1__5__5__1__6__8__val;
              unsigned char *confparse__1__2__1__5__5__1__6__8__11__t_cp = (unsigned char *)bp;
              unsigned char *tmp_post_208 = confparse__1__2__1__5__5__1__6__8__11__t_cp;
              confparse__1__2__1__5__5__1__6__8__11__t_cp = confparse__1__2__1__5__5__1__6__8__11__t_cp + 1l;
              *tmp_post_208 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__11__t_l >> 24);
              unsigned char *tmp_post_209 = confparse__1__2__1__5__5__1__6__8__11__t_cp;
              confparse__1__2__1__5__5__1__6__8__11__t_cp = confparse__1__2__1__5__5__1__6__8__11__t_cp + 1l;
              *tmp_post_209 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__11__t_l >> 16);
              unsigned char *tmp_post_210 = confparse__1__2__1__5__5__1__6__8__11__t_cp;
              confparse__1__2__1__5__5__1__6__8__11__t_cp = confparse__1__2__1__5__5__1__6__8__11__t_cp + 1l;
              *tmp_post_210 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__11__t_l >> 8);
              unsigned char *tmp_post_211 = confparse__1__2__1__5__5__1__6__8__11__t_cp;
              confparse__1__2__1__5__5__1__6__8__11__t_cp = confparse__1__2__1__5__5__1__6__8__11__t_cp + 1l;
              *tmp_post_211 = (unsigned char)confparse__1__2__1__5__5__1__6__8__11__t_l;
              bp = (unsigned char *)(void *)confparse__1__2__1__5__5__1__6__8__11__t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 5th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc_213;
            return_value___ctype_b_loc_213=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_213)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__5__1__6__8__13__1___err;
              signed long int return_value_strtotime_212;
              return_value_strtotime_212=strtotime(p, &p, &confparse__1__2__1__5__5__1__6__8__13__1___err);
              confparse__1__2__1__5__5__1__6__8__val = (unsigned int)return_value_strtotime_212;
              if(!(confparse__1__2__1__5__5__1__6__8__13__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"5th argument of soa= option", confparse__1__2__1__5__5__1__6__8__13__1___err);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 5th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse__1__2__1__5__5__1__6__8__14__t_l = (unsigned int)confparse__1__2__1__5__5__1__6__8__val;
              unsigned char *confparse__1__2__1__5__5__1__6__8__14__t_cp = (unsigned char *)bp;
              unsigned char *tmp_post_214 = confparse__1__2__1__5__5__1__6__8__14__t_cp;
              confparse__1__2__1__5__5__1__6__8__14__t_cp = confparse__1__2__1__5__5__1__6__8__14__t_cp + 1l;
              *tmp_post_214 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__14__t_l >> 24);
              unsigned char *tmp_post_215 = confparse__1__2__1__5__5__1__6__8__14__t_cp;
              confparse__1__2__1__5__5__1__6__8__14__t_cp = confparse__1__2__1__5__5__1__6__8__14__t_cp + 1l;
              *tmp_post_215 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__14__t_l >> 16);
              unsigned char *tmp_post_216 = confparse__1__2__1__5__5__1__6__8__14__t_cp;
              confparse__1__2__1__5__5__1__6__8__14__t_cp = confparse__1__2__1__5__5__1__6__8__14__t_cp + 1l;
              *tmp_post_216 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__14__t_l >> 8);
              unsigned char *tmp_post_217 = confparse__1__2__1__5__5__1__6__8__14__t_cp;
              confparse__1__2__1__5__5__1__6__8__14__t_cp = confparse__1__2__1__5__5__1__6__8__14__t_cp + 1l;
              *tmp_post_217 = (unsigned char)confparse__1__2__1__5__5__1__6__8__14__t_l;
              bp = (unsigned char *)(void *)confparse__1__2__1__5__5__1__6__8__14__t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 6th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc_219;
            return_value___ctype_b_loc_219=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_219)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__5__1__6__8__16__1___err;
              signed long int return_value_strtotime_218;
              return_value_strtotime_218=strtotime(p, &p, &confparse__1__2__1__5__5__1__6__8__16__1___err);
              confparse__1__2__1__5__5__1__6__8__val = (unsigned int)return_value_strtotime_218;
              if(!(confparse__1__2__1__5__5__1__6__8__16__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"6th argument of soa= option", confparse__1__2__1__5__5__1__6__8__16__1___err);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 6th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse__1__2__1__5__5__1__6__8__17__t_l = (unsigned int)confparse__1__2__1__5__5__1__6__8__val;
              unsigned char *confparse__1__2__1__5__5__1__6__8__17__t_cp = (unsigned char *)bp;
              unsigned char *tmp_post_220 = confparse__1__2__1__5__5__1__6__8__17__t_cp;
              confparse__1__2__1__5__5__1__6__8__17__t_cp = confparse__1__2__1__5__5__1__6__8__17__t_cp + 1l;
              *tmp_post_220 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__17__t_l >> 24);
              unsigned char *tmp_post_221 = confparse__1__2__1__5__5__1__6__8__17__t_cp;
              confparse__1__2__1__5__5__1__6__8__17__t_cp = confparse__1__2__1__5__5__1__6__8__17__t_cp + 1l;
              *tmp_post_221 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__17__t_l >> 16);
              unsigned char *tmp_post_222 = confparse__1__2__1__5__5__1__6__8__17__t_cp;
              confparse__1__2__1__5__5__1__6__8__17__t_cp = confparse__1__2__1__5__5__1__6__8__17__t_cp + 1l;
              *tmp_post_222 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__17__t_l >> 8);
              unsigned char *tmp_post_223 = confparse__1__2__1__5__5__1__6__8__17__t_cp;
              confparse__1__2__1__5__5__1__6__8__17__t_cp = confparse__1__2__1__5__5__1__6__8__17__t_cp + 1l;
              *tmp_post_223 = (unsigned char)confparse__1__2__1__5__5__1__6__8__17__t_l;
              bp = (unsigned char *)(void *)confparse__1__2__1__5__5__1__6__8__17__t_cp;
            }
            while((_Bool)0);
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 44))
            {
              *errstr=report_error(conftype, linenr, "missing 7th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            const unsigned short int **return_value___ctype_b_loc_225;
            return_value___ctype_b_loc_225=__ctype_b_loc();
            if(!((2048 & (signed int)(*return_value___ctype_b_loc_225)[(signed long int)(signed int)*p]) == 0))
            {
              char *confparse__1__2__1__5__5__1__6__8__19__1___err;
              signed long int return_value_strtotime_224;
              return_value_strtotime_224=strtotime(p, &p, &confparse__1__2__1__5__5__1__6__8__19__1___err);
              confparse__1__2__1__5__5__1__6__8__val = (unsigned int)return_value_strtotime_224;
              if(!(confparse__1__2__1__5__5__1__6__8__19__1___err == ((char *)NULL)))
              {
                *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"7th argument of soa= option", confparse__1__2__1__5__5__1__6__8__19__1___err);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

            }

            else
            {
              *errstr=report_error(conftype, linenr, "expected a time specification for 7th argument of soa= option");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }
            do
            {
              unsigned int confparse__1__2__1__5__5__1__6__8__20__t_l = (unsigned int)confparse__1__2__1__5__5__1__6__8__val;
              unsigned char *confparse__1__2__1__5__5__1__6__8__20__t_cp = (unsigned char *)bp;
              unsigned char *tmp_post_226 = confparse__1__2__1__5__5__1__6__8__20__t_cp;
              confparse__1__2__1__5__5__1__6__8__20__t_cp = confparse__1__2__1__5__5__1__6__8__20__t_cp + 1l;
              *tmp_post_226 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__20__t_l >> 24);
              unsigned char *tmp_post_227 = confparse__1__2__1__5__5__1__6__8__20__t_cp;
              confparse__1__2__1__5__5__1__6__8__20__t_cp = confparse__1__2__1__5__5__1__6__8__20__t_cp + 1l;
              *tmp_post_227 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__20__t_l >> 16);
              unsigned char *tmp_post_228 = confparse__1__2__1__5__5__1__6__8__20__t_cp;
              confparse__1__2__1__5__5__1__6__8__20__t_cp = confparse__1__2__1__5__5__1__6__8__20__t_cp + 1l;
              *tmp_post_228 = (unsigned char)(confparse__1__2__1__5__5__1__6__8__20__t_l >> 8);
              unsigned char *tmp_post_229 = confparse__1__2__1__5__5__1__6__8__20__t_cp;
              confparse__1__2__1__5__5__1__6__8__20__t_cp = confparse__1__2__1__5__5__1__6__8__20__t_cp + 1l;
              *tmp_post_229 = (unsigned char)confparse__1__2__1__5__5__1__6__8__20__t_l;
              bp = (unsigned char *)(void *)confparse__1__2__1__5__5__1__6__8__20__t_cp;
            }
            while((_Bool)0);
            blen = blen + (unsigned int)20;
            signed int return_value_add_cent_rr_230;
            return_value_add_cent_rr_230=add_cent_rr(&confparse__1__2__1__5__5__c_cent, 6, confparse__1__2__1__5__5__c_ttl, (signed long int)0, (unsigned int)2, blen, (void *)buf);
            if(return_value_add_cent_rr_230 == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L644:
            ;
            *errstr=report_error(conftype, linenr, "Missing support for caching SPF records in rr section");
            free_cent(&confparse__1__2__1__5__5__c_cent);
            goto free_linebuf_return;

          __CPROVER_DUMP_L645:
            ;
            tp = 16;
            tpname = "txt";
            unsigned char *rbuf;
            unsigned int confparse__1__2__1__5__5__1__6__10__sz;
            unsigned int allocsz;
            signed int rv;
            if(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL))
              goto no_name_spec;

            rbuf = (unsigned char *)(void *)0;
            allocsz = (unsigned int)0;
            confparse__1__2__1__5__5__1__6__10__sz = allocsz;
            do
            {
              unsigned char *newbuf;
              unsigned char *confparse__1__2__1__5__5__1__6__10__1__1__cp;
              unsigned int newsz = confparse__1__2__1__5__5__1__6__10__sz + (unsigned int)256;
              signed int n;
              if(!(allocsz >= newsz))
              {
                allocsz = allocsz + (unsigned int)512;
                void *return_value_realloc_231;
                return_value_realloc_231=realloc((void *)rbuf, (unsigned long int)allocsz);
                newbuf = (unsigned char *)return_value_realloc_231;
                if(newbuf == ((unsigned char *)NULL))
                {
                  free((void *)rbuf);
                  free_cent(&confparse__1__2__1__5__5__c_cent);
                  goto out_of_memory;
                }

                rbuf = newbuf;
              }

              confparse__1__2__1__5__5__1__6__10__1__1__cp = rbuf + (signed long int)confparse__1__2__1__5__5__1__6__10__sz;
              n=scan_string(&p, (char *)(confparse__1__2__1__5__5__1__6__10__1__1__cp + (signed long int)1), (unsigned int)255, &scanstrerr);
              if(n == -1)
              {
                *errstr=report_errorf(conftype, linenr, "%s in %s= option", scanstrerr, tpname);
                free((void *)rbuf);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

              if(n >= 256)
              {
                *errstr=report_errorf(conftype, linenr, "string longer than 255 bytes in %s= option", tpname);
                free((void *)rbuf);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

              *confparse__1__2__1__5__5__1__6__10__1__1__cp = (unsigned char)n;
              confparse__1__2__1__5__5__1__6__10__sz = confparse__1__2__1__5__5__1__6__10__sz + (unsigned int)(n + 1);
              if(confparse__1__2__1__5__5__1__6__10__sz >= 65536u)
              {
                *errstr=report_errorf(conftype, linenr, "data exceeds maximum size (65535 bytes) in %s= option", tpname);
                free((void *)rbuf);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
              {
                free((void *)rbuf);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto unexpected_eof;
              }

              if(!((signed int)*p == 44))
                break;

              p = p + 1l;
              p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
              if(p == ((char *)NULL))
              {
                free((void *)rbuf);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto unexpected_eof;
              }

            }
            while((_Bool)1);
            rv=add_cent_rr(&confparse__1__2__1__5__5__c_cent, tp, confparse__1__2__1__5__5__c_ttl, (signed long int)0, (unsigned int)2, confparse__1__2__1__5__5__1__6__10__sz, (void *)rbuf);
            free((void *)rbuf);
            if(rv == 0)
              goto add_rr_failed;

            goto __CPROVER_DUMP_L657;

          __CPROVER_DUMP_L656:
            ;
            free_cent(&confparse__1__2__1__5__5__c_cent);
            goto internal_parse_error;

          __CPROVER_DUMP_L657:
            ;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

            if(!((signed int)*p == 59))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto expected_semicolon;
            }

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
            {
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto unexpected_eof;
            }

          }
          while((_Bool)1);
          if(!((signed int)*p == 125))
          {
            free_cent(&confparse__1__2__1__5__5__c_cent);
            goto expected_closing_brace;
          }

          if(confparse__1__2__1__5__5__c_cent.qname == ((unsigned char *)NULL))
            goto no_name_spec;

          if((signed int)*confparse__1__2__1__5__5__c_cent.qname == 1)
          {
            if((signed int)confparse__1__2__1__5__5__c_cent.qname[1l] == 42)
            {
              signed int return_value_set_cent_flags_232;
              return_value_set_cent_flags_232=set_cent_flags(&confparse__1__2__1__5__5__c_cent.qname[(signed long int)2], (unsigned int)16);
              if(return_value_set_cent_flags_232 == 0)
              {
                unsigned char confparse__1__2__1__5__5__3__1__buf[256l];
                rhn2str(confparse__1__2__1__5__5__c_cent.qname, confparse__1__2__1__5__5__3__1__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                *errstr=report_errorf(conftype, linenr, "You must define some records for '%s' before you can define records for the wildcard name '%s'", &confparse__1__2__1__5__5__3__1__buf[(signed long int)2], (const void *)confparse__1__2__1__5__5__3__1__buf);
                free_cent(&confparse__1__2__1__5__5__c_cent);
                goto free_linebuf_return;
              }

            }

          }

          add_cache(&confparse__1__2__1__5__5__c_cent);
          if(!(reverse == 0))
          {
            signed int return_value_add_reverse_cache_233;
            return_value_add_reverse_cache_233=add_reverse_cache(&confparse__1__2__1__5__5__c_cent);
            if(return_value_add_reverse_cache_233 == 0)
            {
              *errstr=report_error(conftype, linenr, "Can't convert IP address in a= option into form suitable for reverse resolving.");
              free_cent(&confparse__1__2__1__5__5__c_cent);
              goto free_linebuf_return;
            }

          }

          free_cent(&confparse__1__2__1__5__5__c_cent);
          break;

        add_rr_failed:
          ;
          free_cent(&confparse__1__2__1__5__5__c_cent);
          goto out_of_memory;
        }
        case 5:
        {
          unsigned char c_owner[256l];
          signed long int c_ttl;
          unsigned int confparse__1__2__1__5__6__c_flags;
          unsigned char c_aliases;
          c_owner[(signed long int)0] = (unsigned char)0;
          c_ttl = (signed long int)86400;
          confparse__1__2__1__5__6__c_flags = (unsigned int)2;
          c_aliases = (unsigned char)0;
          do
          {
            return_value___ctype_b_loc_234=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc_234)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_235=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc_235)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr_236 = (_Bool)1;

                else
                  tmp_if_expr_236 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_237 = tmp_if_expr_236 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_237 = (_Bool)0;
            }
            while(tmp_if_expr_237);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, source_options, (signed int)(sizeof(const struct anonymous_32 [6l]) /*96ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for source section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            switch(option)
            {
              case 78:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                  goto string_err;

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    goto string_too_long;

                const char *confparse__1__2__1__5__6__1__5__2___err;
                confparse__1__2__1__5__6__1__5__2___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, c_owner);
                if(!(confparse__1__2__1__5__6__1__5__2___err == ((const char *)NULL)))
                {
                  *errstr=report_error(conftype, linenr, confparse__1__2__1__5__6__1__5__2___err);
                  goto free_linebuf_return;
                }

                break;
              }
              case 79:
              {
                const unsigned short int **return_value___ctype_b_loc_238;
                return_value___ctype_b_loc_238=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_238)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__6__1__5__3__1___err;
                  c_ttl=strtotime(p, &p, &confparse__1__2__1__5__6__1__5__3__1___err);
                  if(!(confparse__1__2__1__5__6__1__5__3__1___err == ((char *)NULL)))
                  {
                    *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"ttl option", confparse__1__2__1__5__6__1__5__3__1___err);
                    goto free_linebuf_return;
                  }

                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected a time specification for ttl option");
                  goto free_linebuf_return;
                }
                break;
              }
              case 81:
              {
                if(c_owner[0l] == 0)
                {
                  *errstr=report_error(conftype, linenr, "you must specify owner before file= in source records.");
                  goto free_linebuf_return;
                }

                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                  goto string_err;

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    goto string_too_long;

                char *confparse__1__2__1__5__6__1__5__6__errmsg;
                signed int return_value_read_hosts_239;
                return_value_read_hosts_239=read_hosts(strbuf, c_owner, c_ttl, confparse__1__2__1__5__6__c_flags, (signed int)c_aliases, &confparse__1__2__1__5__6__1__5__6__errmsg);
                if(return_value_read_hosts_239 == 0)
                {
                  if(!(confparse__1__2__1__5__6__1__5__6__errmsg == ((char *)NULL)))
                  {
                    *errstr=report_error(conftype, linenr, confparse__1__2__1__5__6__1__5__6__errmsg);
                    free((void *)confparse__1__2__1__5__6__1__5__6__errmsg);
                  }

                  else
                    *errstr = (char *)(void *)0;
                  goto free_linebuf_return;
                }

                break;
              }
              case 82:
              {
                const unsigned short int **return_value___ctype_b_loc_243;
                return_value___ctype_b_loc_243=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_243)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__6__1__5__7__1___str;
                  unsigned long int confparse__1__2__1__5__6__1__5__7__1___len;
                  signed int confparse__1__2__1__5__6__1__5__7__1___cnst;
                  confparse__1__2__1__5__6__1__5__7__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_240=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_240)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_241 = (_Bool)1;

                      else
                        tmp_if_expr_241 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_242 = tmp_if_expr_241 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_242 = (_Bool)0;
                  }
                  while(tmp_if_expr_242);
                  confparse__1__2__1__5__6__1__5__7__1___len = (unsigned long int)(p - confparse__1__2__1__5__6__1__5__7__1___str);
                  confparse__1__2__1__5__6__1__5__7__1___cnst=lookup_const(confparse__1__2__1__5__6__1__5__7__1___str, (signed int)confparse__1__2__1__5__6__1__5__7__1___len);
                  if(confparse__1__2__1__5__6__1__5__7__1___cnst == 1 || confparse__1__2__1__5__6__1__5__7__1___cnst == 2)
                    c_aliases = (unsigned char)(confparse__1__2__1__5__6__1__5__7__1___cnst == 1);

                  else
                    goto ASSIGN_ON_OFF_1564;
                }

                else
                {

                ASSIGN_ON_OFF_1564:
                  ;
                  *errstr=report_error(conftype, linenr, "Bad qualifier in serve_aliases= option.");
                  goto free_linebuf_return;
                }
                break;
              }
              case 83:
              {
                signed int confparse__1__2__1__5__6__1__5__8__cnst;
                const unsigned short int **return_value___ctype_b_loc_247;
                return_value___ctype_b_loc_247=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_247)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__6__1__5__8__1__1___str;
                  unsigned long int confparse__1__2__1__5__6__1__5__8__1__1___len;
                  confparse__1__2__1__5__6__1__5__8__1__1___str = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_244=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_244)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_245 = (_Bool)1;

                      else
                        tmp_if_expr_245 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_246 = tmp_if_expr_245 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_246 = (_Bool)0;
                  }
                  while(tmp_if_expr_246);
                  confparse__1__2__1__5__6__1__5__8__1__1___len = (unsigned long int)(p - confparse__1__2__1__5__6__1__5__8__1__1___str);
                  confparse__1__2__1__5__6__1__5__8__cnst=lookup_const(confparse__1__2__1__5__6__1__5__8__1__1___str, (signed int)confparse__1__2__1__5__6__1__5__8__1__1___len);
                  if(!(confparse__1__2__1__5__6__1__5__8__cnst == 1) && !(confparse__1__2__1__5__6__1__5__8__cnst == 2))
                    goto ASSIGN_CONST_1569;

                }

                else
                {

                ASSIGN_CONST_1569:
                  ;
                  *errstr=report_error(conftype, linenr, "Bad qualifier in authrec= option.");
                  goto free_linebuf_return;
                }
                confparse__1__2__1__5__6__c_flags = (unsigned int)(confparse__1__2__1__5__6__1__5__8__cnst == 1 ? 2 : 0);
                break;
              }
              default:
                goto internal_parse_error;
            }
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          break;
        }
        case 6:
        {
          do
          {
            return_value___ctype_b_loc_248=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc_248)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_249=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc_249)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr_250 = (_Bool)1;

                else
                  tmp_if_expr_250 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_251 = tmp_if_expr_250 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_251 = (_Bool)0;
            }
            while(tmp_if_expr_251);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, include_options, (signed int)(sizeof(const struct anonymous_32 [1l]) /*16ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for include section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(option == 81)
            {
              if(includedepth >= 100)
              {
                *errstr=report_errorf(conftype, linenr, "maximum include depth (%d) exceeded.", 100);
                goto free_linebuf_return;
              }

              len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
              if(len == -1)
                goto string_err;

              else
                if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                  goto string_too_long;

              char *confparse__1__2__1__5__7__1__5__3__errmsg;
              signed int return_value_read_config_file_254;
              return_value_read_config_file_254=read_config_file(strbuf, (struct anonymous_21 *)(void *)0, (struct anonymous_18 **)(void *)0, includedepth + 1, &confparse__1__2__1__5__7__1__5__3__errmsg);
              if(return_value_read_config_file_254 == 0)
              {
                if(!(confparse__1__2__1__5__7__1__5__3__errmsg == ((char *)NULL)))
                {
                  if(!(linenr == 0u))
                  {
                    signed int return_value_asprintf_252;
                    return_value_asprintf_252=asprintf(errstr, "In file %s included at line %u:\n%s", (const void *)strbuf, linenr, confparse__1__2__1__5__7__1__5__3__errmsg);
                    if(!(return_value_asprintf_252 >= 0))
                      *errstr = (char *)(void *)0;

                  }

                  else
                  {
                    signed int return_value_asprintf_253;
                    return_value_asprintf_253=asprintf(errstr, "In file %s:\n%s", (const void *)strbuf, confparse__1__2__1__5__7__1__5__3__errmsg);
                    if(!(return_value_asprintf_253 >= 0))
                      *errstr = (char *)(void *)0;

                  }
                  free((void *)confparse__1__2__1__5__7__1__5__3__errmsg);
                }

                else
                  *errstr = (char *)(void *)0;
                goto free_linebuf_return;
              }

              goto __CPROVER_DUMP_L737;
            }

            goto internal_parse_error;

          __CPROVER_DUMP_L737:
            ;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          break;
        }
        case 4:
        {
          unsigned char confparse__1__2__1__5__8__c_name[256l];
          signed long int confparse__1__2__1__5__8__c_ttl;
          unsigned char htp;
          unsigned char hdtp;
          htp = (unsigned char)0;
          hdtp = (unsigned char)0;
          confparse__1__2__1__5__8__c_name[(signed long int)0] = (unsigned char)0;
          confparse__1__2__1__5__8__c_ttl = (signed long int)86400;
          do
          {
            return_value___ctype_b_loc_255=__ctype_b_loc();
            if((1024 & (signed int)(*return_value___ctype_b_loc_255)[(signed long int)(signed int)*p]) == 0)
              break;

            ps = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_256=__ctype_b_loc();
                if(!((8 & (signed int)(*return_value___ctype_b_loc_256)[(signed long int)(signed int)*p]) == 0))
                  tmp_if_expr_257 = (_Bool)1;

                else
                  tmp_if_expr_257 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_258 = tmp_if_expr_257 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_258 = (_Bool)0;
            }
            while(tmp_if_expr_258);
            len = (signed int)(p - ps);
            option=binsearch_keyword(ps, len, neg_options, (signed int)(sizeof(const struct anonymous_32 [3l]) /*48ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
            if(option == 0)
            {
              *errstr=report_errorf(conftype, linenr, "invalid option for neg section: %.*s", (signed int)len, ps);
              goto free_linebuf_return;
            }

            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 61))
              goto expected_equals;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            switch(option)
            {
              case 77:
              {
                len=scan_string(&p, strbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , &scanstrerr);
                if(len == -1)
                  goto string_err;

                else
                  if((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ )
                    goto string_too_long;

                const char *confparse__1__2__1__5__8__1__5__2___err;
                confparse__1__2__1__5__8__1__5__2___err=parsestr2rhn((unsigned char *)strbuf, (unsigned int)len, confparse__1__2__1__5__8__c_name);
                if(!(confparse__1__2__1__5__8__1__5__2___err == ((const char *)NULL)))
                {
                  *errstr=report_error(conftype, linenr, confparse__1__2__1__5__8__1__5__2___err);
                  goto free_linebuf_return;
                }

                break;
              }
              case 79:
              {
                const unsigned short int **return_value___ctype_b_loc_259;
                return_value___ctype_b_loc_259=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc_259)[(signed long int)(signed int)*p]) == 0))
                {
                  char *confparse__1__2__1__5__8__1__5__3__1___err;
                  confparse__1__2__1__5__8__c_ttl=strtotime(p, &p, &confparse__1__2__1__5__8__1__5__3__1___err);
                  if(!(confparse__1__2__1__5__8__1__5__3__1___err == ((char *)NULL)))
                  {
                    *errstr=report_errorf(conftype, linenr, "invalid time specification for %s: %s", (const void *)"ttl option", confparse__1__2__1__5__8__1__5__3__1___err);
                    goto free_linebuf_return;
                  }

                }

                else
                {
                  *errstr=report_error(conftype, linenr, "expected a time specification for ttl option");
                  goto free_linebuf_return;
                }
                break;
              }
              case 80:
              {
                if(confparse__1__2__1__5__8__c_name[0l] == 0)
                {
                  *errstr=report_error(conftype, linenr, "you must specify a name before the types= option.");
                  goto free_linebuf_return;
                }

                return_value___ctype_b_loc_272=__ctype_b_loc();
                if(!((1024 & (signed int)(*return_value___ctype_b_loc_272)[(signed long int)(signed int)*p]) == 0))
                {
                  signed int confparse__1__2__1__5__8__1__5__5__cnst;
                  struct anonymous_0 c_cent;
                  ps = p;
                  do
                  {
                    p = p + 1l;
                    if(!(*p == 0))
                    {
                      return_value___ctype_b_loc_260=__ctype_b_loc();
                      if(!((8 & (signed int)(*return_value___ctype_b_loc_260)[(signed long int)(signed int)*p]) == 0))
                        tmp_if_expr_261 = (_Bool)1;

                      else
                        tmp_if_expr_261 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_262 = tmp_if_expr_261 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_262 = (_Bool)0;
                  }
                  while(tmp_if_expr_262);
                  len = (signed int)(p - ps);
                  confparse__1__2__1__5__8__1__5__5__cnst=lookup_const(ps, len);
                  if(confparse__1__2__1__5__8__1__5__5__cnst == 23)
                  {
                    if(!(htp == 0))
                    {
                      *errstr=report_error(conftype, linenr, "You may not specify types=domain together with other types!");
                      goto free_linebuf_return;
                    }

                    hdtp = (unsigned char)1;
                    signed int return_value_init_cent_263;
                    return_value_init_cent_263=init_cent(&c_cent, confparse__1__2__1__5__8__c_name, confparse__1__2__1__5__8__c_ttl, (signed long int)0, (unsigned int)(2 | 1));
                    if(return_value_init_cent_263 == 0)
                      goto out_of_memory;

                  }

                  else
                    if(confparse__1__2__1__5__8__1__5__5__cnst == 0)
                    {
                      if(!(hdtp == 0))
                      {
                        *errstr=report_error(conftype, linenr, "You may not specify types=domain together with other types!");
                        goto free_linebuf_return;
                      }

                      htp = (unsigned char)1;
                      signed int return_value_init_cent_264;
                      return_value_init_cent_264=init_cent(&c_cent, confparse__1__2__1__5__8__c_name, (signed long int)0, (signed long int)0, (unsigned int)0);
                      if(return_value_init_cent_264 == 0)
                        goto out_of_memory;

                      do
                      {
                        const signed long int c_cent_array_size0 = (signed long int)(len + 1);
                        char confparse__1__2__1__5__8__1__5__5__3__2__1__1__buf[c_cent_array_size0];
                        memcpy((void *)confparse__1__2__1__5__8__1__5__5__3__2__1__1__buf, (const void *)ps, (unsigned long int)len);
                        confparse__1__2__1__5__8__1__5__5__3__2__1__1__buf[(signed long int)len] = (char)0;
                        confparse__1__2__1__5__8__1__5__5__cnst=rr_tp_byname(confparse__1__2__1__5__8__1__5__5__3__2__1__1__buf);
                        if(confparse__1__2__1__5__8__1__5__5__cnst == -1)
                        {
                          *errstr=report_errorf(conftype, linenr, "unrecognized rr type '%.*s' used as argument for types= option.", (signed int)len, ps);
                          free_cent(&c_cent);
                          goto free_linebuf_return;
                        }

                        _Bool tmp_if_expr_265;
                        if(confparse__1__2__1__5__8__1__5__5__cnst >= 52 || !(confparse__1__2__1__5__8__1__5__5__cnst >= 1))
                          tmp_if_expr_265 = (_Bool)1;

                        else
                          tmp_if_expr_265 = (signed int)rrlkuptab[(signed long int)(confparse__1__2__1__5__8__1__5__5__cnst - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
                        if(tmp_if_expr_265)
                        {
                          *errstr=report_errorf(conftype, linenr, "illegal rr type '%.*s' used as argument for types= option.", (signed int)len, ps);
                          free_cent(&c_cent);
                          goto free_linebuf_return;
                        }

                        struct anonymous *return_value_getrrset_eff_267;
                        return_value_getrrset_eff_267=getrrset_eff(&c_cent, confparse__1__2__1__5__8__1__5__5__cnst);
                        if(return_value_getrrset_eff_267 == ((struct anonymous *)NULL))
                        {
                          return_value_add_cent_rrset_by_type_266=add_cent_rrset_by_type(&c_cent, confparse__1__2__1__5__8__1__5__5__cnst, confparse__1__2__1__5__8__c_ttl, (signed long int)0, (unsigned int)(2 | 1));
                          if(return_value_add_cent_rrset_by_type_266 == 0)
                          {
                            free_cent(&c_cent);
                            goto out_of_memory;
                          }

                        }

                        p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                        if(p == ((char *)NULL))
                        {
                          free_cent(&c_cent);
                          goto unexpected_eof;
                        }

                        if(!((signed int)*p == 44))
                          break;

                        p = p + 1l;
                        p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
                        if(p == ((char *)NULL))
                        {
                          free_cent(&c_cent);
                          goto unexpected_eof;
                        }

                        const unsigned short int **return_value___ctype_b_loc_268;
                        return_value___ctype_b_loc_268=__ctype_b_loc();
                        if((1024 & (signed int)(*return_value___ctype_b_loc_268)[(signed long int)(signed int)*p]) == 0)
                        {
                          free_cent(&c_cent);
                          goto bad_types_option;
                        }

                        ps = p;
                        do
                        {
                          p = p + 1l;
                          if(!(*p == 0))
                          {
                            return_value___ctype_b_loc_269=__ctype_b_loc();
                            if(!((8 & (signed int)(*return_value___ctype_b_loc_269)[(signed long int)(signed int)*p]) == 0))
                              tmp_if_expr_270 = (_Bool)1;

                            else
                              tmp_if_expr_270 = (signed int)*p == 95 ? (_Bool)1 : (_Bool)0;
                            tmp_if_expr_271 = tmp_if_expr_270 ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr_271 = (_Bool)0;
                        }
                        while(tmp_if_expr_271);
                        len = (signed int)(p - ps);
                      }
                      while((_Bool)1);
                    }

                    else
                      goto bad_types_option;
                  add_cache(&c_cent);
                  free_cent(&c_cent);
                }

                else
                {

                bad_types_option:
                  ;
                  *errstr=report_error(conftype, linenr, "Bad argument for types= option.");
                  goto free_linebuf_return;
                }
                break;
              }
              default:
                goto internal_parse_error;
            }
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

            if(!((signed int)*p == 59))
              goto expected_semicolon;

            p = p + 1l;
            p=getnextp(&linebuf, &buflen, in, p, &linenr, &getnextperr);
            if(p == ((char *)NULL))
              goto unexpected_eof;

          }
          while((_Bool)1);
          break;
        }
        default:
          goto internal_parse_error;
      }
      if(!((signed int)*p == 125))
        goto expected_closing_brace;

      p = p + 1l;
    }

    else
    {
      *errstr=report_error(conftype, linenr, "expected section header");
      goto free_linebuf_return;
    }
  }
  while((_Bool)1);
  _Bool tmp_if_expr_275;
  signed int return_value_feof_274;
  if(in == ((struct _IO_FILE *)NULL))
    tmp_if_expr_275 = (_Bool)1;

  else
  {
    return_value_feof_274=feof(in);
    tmp_if_expr_275 = return_value_feof_274 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_275)
  {
    if(!(getnextperr == ((char *)NULL)))
    {
      *errstr=report_error(conftype, linenr, getnextperr);
      goto free_linebuf_return;
    }

    retval = 1;
  }

  else
    goto input_error;
  goto free_linebuf_return;

expected_bropen:
  ;
  *errstr=report_error(conftype, linenr, "expected opening brace after section name");
  goto free_linebuf_return;

expected_closing_brace:
  ;
  *errstr=report_error(conftype, linenr, "expected beginning of new option or closing brace");
  goto free_linebuf_return;

expected_equals:
  ;
  *errstr=report_error(conftype, linenr, "expected equals sign after option name");
  goto free_linebuf_return;

expected_semicolon:
  ;
  *errstr=report_error(conftype, linenr, "too many arguments to option or missing semicolon");
  goto free_linebuf_return;

string_err:
  ;
  *errstr=report_error(conftype, linenr, scanstrerr);
  goto free_linebuf_return;

string_too_long:
  ;
  *errstr=report_error(conftype, linenr, "string length exceeds buffer size");
  goto free_linebuf_return;

no_name_spec:
  ;
  *errstr=report_error(conftype, linenr, "you must specify a name before a,ptr,cname,mx,ns(owner) and soa records.");
  goto free_linebuf_return;

internal_parse_error:
  ;
  signed int return_value_asprintf_276;
  return_value_asprintf_276=asprintf(errstr, "Internal inconsistency detected while parsing line %u of %s.\nPlease consider reporting this error to one of the maintainers.\n", linenr, conftype);
  if(!(return_value_asprintf_276 >= 0))
    *errstr = (char *)(void *)0;

  goto free_linebuf_return;

out_of_memory:
  ;
  *errstr = (char *)(void *)0;
  goto free_linebuf_return;

unexpected_eof:
  ;
  _Bool tmp_if_expr_281;
  signed int return_value_feof_280;
  if(in == ((struct _IO_FILE *)NULL))
    tmp_if_expr_281 = (_Bool)1;

  else
  {
    return_value_feof_280=feof(in);
    tmp_if_expr_281 = return_value_feof_280 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_281)
    *errstr=report_error(conftype, linenr, getnextperr != ((char *)NULL) ? getnextperr : (in != ((struct _IO_FILE *)NULL) ? "unexpected end of file" : "unexpected end of input string"));

  else
  {

  input_error:
    ;
    signed int *return_value___errno_location_277;
    return_value___errno_location_277=__errno_location();
    char *return_value_strerror_278;
    return_value_strerror_278=strerror(*return_value___errno_location_277);
    signed int return_value_asprintf_279;
    return_value_asprintf_279=asprintf(errstr, "Error while reading config file: %s", return_value_strerror_278);
    if(!(return_value_asprintf_279 >= 0))
      *errstr = (char *)(void *)0;

  }

free_linebuf_return:
  ;
  free((void *)linebuf);
  return retval;
}

// const_name
// file consts.h line 67
const char * const_name(signed int c)
{
  const char *tmp_if_expr_1;
  if(c >= 0 && !((unsigned long int)c >= 26ul))
    tmp_if_expr_1 = const_names[(signed long int)c];

  else
    tmp_if_expr_1 = "ILLEGAL!";
  return tmp_if_expr_1;
}

// copy_cent
// file cache.c line 1098
struct anonymous_0 * copy_cent(struct anonymous_0 *cent)
{
  struct anonymous_0 *copy;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_0) /*104ul*/ );
  copy = (struct anonymous_0 *)return_value_malloc_1;
  if(copy == ((struct anonymous_0 *)NULL))
    return (struct anonymous_0 *)(void *)0;

  else
  {
    unsigned long int namesz;
    unsigned int return_value_rhnlen_2;
    return_value_rhnlen_2=rhnlen_link6(cent->qname);
    namesz = (unsigned long int)return_value_rhnlen_2;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(namesz);
    copy->qname = (unsigned char *)return_value_malloc_3;
    if(!(copy->qname == ((unsigned char *)NULL)))
    {
      memcpy((void *)copy->qname, (const void *)cent->qname, namesz);
      copy->cs = cent->cs;
      copy->num_rrs = cent->num_rrs;
      copy->flags = cent->flags;
      copy->c_ns = cent->c_ns;
      copy->c_soa = cent->c_soa;
      if(!((1 & (signed int)cent->flags) == 0))
      {
        copy->_anon0.neg.lent = (struct rr_lent_s *)(void *)0;
        copy->_anon0.neg.ttl = cent->_anon0.neg.ttl;
        copy->_anon0.neg.ts = cent->_anon0.neg.ts;
      }

      else
      {
        signed int i;
        signed int ilim;
        i = 0;
        for( ; !(i >= 8); i = i + 1)
          copy->_anon0.rr.rrmu[(signed long int)i] = (struct anonymous *)(void *)0;
        copy->_anon0.rr.rrext = (struct anonymous **)(void *)0;
        ilim = 8;
        if(!(cent->_anon0.rr.rrext == ((struct anonymous **)NULL)))
        {
          struct anonymous **rrextc;
          ilim = 47;
          void *return_value_malloc_4;
          return_value_malloc_4=malloc(sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39);
          rrextc = (struct anonymous **)return_value_malloc_4;
          copy->_anon0.rr.rrext = rrextc;
          if(rrextc == ((struct anonymous **)NULL))
            goto free_cent_return_null;

          i = 0;
          for( ; !(i >= 39); i = i + 1)
            rrextc[(signed long int)i] = (struct anonymous *)(void *)0;
        }

        i = 0;
        for( ; !(i >= ilim); i = i + 1)
        {
          struct anonymous *rrset;
          struct anonymous *tmp_if_expr_5;
          if(!(i >= 8))
            tmp_if_expr_5 = cent->_anon0.rr.rrmu[(signed long int)i];

          else
            tmp_if_expr_5 = cent->_anon0.rr.rrext[(signed long int)(i - 8)];
          rrset = tmp_if_expr_5;
          if(!(rrset == ((struct anonymous *)NULL)))
          {
            struct anonymous *rrsc;
            void *return_value_malloc_6;
            return_value_malloc_6=malloc(sizeof(struct anonymous) /*40ul*/ );
            rrsc = (struct anonymous *)return_value_malloc_6;
            struct rr_b_s *rr;
            struct rr_b_s **rrp;
            struct anonymous **tmp_if_expr_7;
            if(!(i >= 8))
              tmp_if_expr_7 = &copy->_anon0.rr.rrmu[(signed long int)i];

            else
              tmp_if_expr_7 = &copy->_anon0.rr.rrext[(signed long int)(i - 8)];
            *tmp_if_expr_7 = rrsc;
            if(rrsc == ((struct anonymous *)NULL))
              goto free_cent_return_null;

            *rrsc = *rrset;
            rrsc->lent = (struct rr_lent_s *)(void *)0;
            rrp = &rrsc->rrs;
            rr = rrset->rrs;
            while(!(rr == ((struct rr_b_s *)NULL)))
            {
              struct rr_b_s *rrc;
              rrc=copy_rr(rr);
              *rrp = rrc;
              if(rrc == ((struct rr_b_s *)NULL))
                goto free_cent_return_null;

              rrp = &rrc->next;
              rr = rr->next;
            }
          }

        }
      }
      return copy;

    free_cent_return_null:
      ;
      free_cent(copy);
    }


  free_return_null:
    ;
    free((void *)copy);
    return (struct anonymous_0 *)(void *)0;
  }
}

// copy_rr
// file cache.c line 1059
static inline struct rr_b_s * copy_rr(struct rr_b_s *rr)
{
  struct rr_b_s *rrn;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rr->rdlen);
  rrn = (struct rr_b_s *)return_value_malloc_1;
  if(rrn == ((struct rr_b_s *)NULL))
    return (struct rr_b_s *)(void *)0;

  else
  {
    memcpy((void *)rrn, (const void *)rr, sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rr->rdlen);
    rrn->next = (struct rr_b_s *)(void *)0;
    return rrn;
  }
}

// copy_rrset
// file cache.c line 1072
static struct anonymous * copy_rrset(struct anonymous *rrset)
{
  struct anonymous *rrsc;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous) /*40ul*/ );
  rrsc = (struct anonymous *)return_value_malloc_1;
  struct rr_b_s *rr;
  struct rr_b_s **rrp;
  if(!(rrsc == ((struct anonymous *)NULL)))
  {
    *rrsc = *rrset;
    rrsc->lent = (struct rr_lent_s *)(void *)0;
    rrp = &rrsc->rrs;
    rr = rrset->rrs;
    while(!(rr == ((struct rr_b_s *)NULL)))
    {
      struct rr_b_s *rrc;
      rrc=copy_rr(rr);
      *rrp = rrc;
      if(rrc == ((struct rr_b_s *)NULL))
        goto cleanup_return;

      rrp = &rrc->next;
      rr = rr->next;
    }
  }

  return rrsc;

cleanup_return:
  ;
  del_rrset(rrsc);
  return (struct anonymous *)(void *)0;
}

// cr_check_add
// file cache.c line 1759
static signed int cr_check_add(struct anonymous_0 *cent, signed int idx, signed long int ttl, signed long int ts, unsigned int flags)
{
  signed long int nttl;
  struct rr_infos *rri;
  if(!((1u & flags) == 0u))
    return 1;

  else
  {
    nttl = (signed long int)0;
    rri = &rr_info[(signed long int)idx];
    if((2u & flags) == 0u)
    {
      signed int i;
      signed int cr_check_add__1__1__ilim;
      signed int ncf;
      if(!((2 & (signed int)cent->flags) == 0))
        return 0;

      ncf = 0;
      signed int tmp_if_expr_1;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr_1 = 0;

      else
        tmp_if_expr_1 = cent->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      cr_check_add__1__1__ilim = tmp_if_expr_1;
      i = 0;
      for( ; !(i >= cr_check_add__1__1__ilim); i = i + 1)
      {
        struct anonymous *cr_check_add__1__1__1__1__rrs;
        struct anonymous *tmp_if_expr_2;
        if(!(i >= 8))
          tmp_if_expr_2 = cent->_anon0.rr.rrmu[(signed long int)i];

        else
          tmp_if_expr_2 = cent->_anon0.rr.rrext[(signed long int)(i - 8)];
        cr_check_add__1__1__1__1__rrs = tmp_if_expr_2;
        if(!(cr_check_add__1__1__1__1__rrs == ((struct anonymous *)NULL)))
        {
          if((1 & (signed int)cr_check_add__1__1__1__1__rrs->flags) == 0)
          {
            _Bool tmp_if_expr_4;
            if(!(((signed int)rri->class & (signed int)rr_info[(signed long int)i].excludes) == 0))
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = ((signed int)rri->excludes & (signed int)rr_info[(signed long int)i].class) != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              signed long int rttl;
              if(!((2 & (signed int)cr_check_add__1__1__1__1__rrs->flags) == 0))
                return 0;

              ncf = ncf + 1;
              signed long int return_value_time_3;
              return_value_time_3=time((signed long int *)(void *)0);
              rttl = (cr_check_add__1__1__1__1__rrs->ttl + cr_check_add__1__1__1__1__rrs->ts) - return_value_time_3;
              if(rttl >= 1l)
                nttl = nttl + rttl;

            }

          }

        }

      }
      if(ncf == 0)
        return 1;

      nttl = nttl / (signed long int)ncf;
    }

    if(!((2u & flags) == 0u) || !(nttl >= ttl))
    {
      signed int cr_check_add__1__2__i;
      signed int ilim;
      signed int tmp_if_expr_5;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr_5 = 0;

      else
        tmp_if_expr_5 = cent->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      ilim = tmp_if_expr_5;
      cr_check_add__1__2__i = 0;
      for( ; !(cr_check_add__1__2__i >= ilim); cr_check_add__1__2__i = cr_check_add__1__2__i + 1)
      {
        struct anonymous *rrs;
        struct anonymous *tmp_if_expr_6;
        if(!(cr_check_add__1__2__i >= 8))
          tmp_if_expr_6 = cent->_anon0.rr.rrmu[(signed long int)cr_check_add__1__2__i];

        else
          tmp_if_expr_6 = cent->_anon0.rr.rrext[(signed long int)(cr_check_add__1__2__i - 8)];
        rrs = tmp_if_expr_6;
        if(!(rrs == ((struct anonymous *)NULL)))
        {
          if((1 & (signed int)rrs->flags) == 0)
          {
            _Bool tmp_if_expr_7;
            if(!(((signed int)rri->class & (signed int)rr_info[(signed long int)cr_check_add__1__2__i].excludes) == 0))
              tmp_if_expr_7 = (_Bool)1;

            else
              tmp_if_expr_7 = ((signed int)rri->excludes & (signed int)rr_info[(signed long int)cr_check_add__1__2__i].class) != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_7)
              del_cent_rrset_by_index(cent, cr_check_add__1__2__i);

          }

        }

      }
      return 1;
    }

    return 0;
  }
}

// crash_msg
// file error.c line 52
void crash_msg(char *msg)
{
  log_message(3, "%s", msg);
  log_message(3, "pdnsd probably crashed due to a bug. Please consider sending a bug");
  log_message(3, "report to p.a.rombouts@home.nl or tmoestl@gmx.net");
}

// create_rr
// file cache.c line 588
static struct rr_b_s * create_rr(unsigned int dlen, void *data)
{
  struct rr_b_s *rrb;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)dlen);
  rrb = (struct rr_b_s *)return_value_malloc_1;
  if(rrb == ((struct rr_b_s *)NULL))
    return (struct rr_b_s *)(void *)0;

  else
  {
    rrb->next = (struct rr_b_s *)(void *)0;
    rrb->rdlen = dlen;
    memcpy((void *)rrb->data, data, (unsigned long int)dlen);
    return rrb;
  }
}

// da_grow1
// file list.h line 54
struct anonymous_3 * da_grow1(struct anonymous_3 *a, unsigned long int headsz, unsigned long int elemsz, void (*cleanuproutine)(void *))
{
  unsigned long int k;
  unsigned long int tmp_if_expr_1;
  if(!(a == ((struct anonymous_3 *)NULL)))
    tmp_if_expr_1 = a->nel;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  k = tmp_if_expr_1;
  if(a == ((struct anonymous_3 *)NULL) || (7ul & k) == 0ul && !(k == 0ul))
  {
    struct anonymous_3 *tmp;
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)a, headsz + elemsz * (k + (unsigned long int)8));
    tmp = (struct anonymous_3 *)return_value_realloc_2;
    if(tmp == ((struct anonymous_3 *)NULL) && !(a == ((struct anonymous_3 *)NULL)))
    {
      if(!(cleanuproutine == ((void (*)(void *))NULL)))
      {
        unsigned long int i = (unsigned long int)0;
        if(!(i >= k))
        {
          cleanuproutine((void *)((char *)a + (signed long int)headsz + (signed long int)(elemsz * i)));
          i = i + 1ul;
        }

      }

      free((void *)a);
    }

    a = tmp;
  }

  if(!(a == ((struct anonymous_3 *)NULL)))
    a->nel = k + (unsigned long int)1;

  return a;
}

// da_nel
// file list.h line 59
static inline unsigned int da_nel(struct anonymous_3 *a)
{
  if(a == ((struct anonymous_3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a->nel;
}

// da_nel_link1
// file list.h line 59
static inline unsigned int da_nel_link1(struct anonymous_3 *a_link1)
{
  if(a_link1 == ((struct anonymous_3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a_link1->nel;
}

// da_nel_link2
// file list.h line 59
static inline unsigned int da_nel_link2(struct anonymous_3 *a_link2)
{
  if(a_link2 == ((struct anonymous_3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a_link2->nel;
}

// da_nel_link3
// file list.h line 59
static inline unsigned int da_nel_link3(struct anonymous_3 *a_link3)
{
  if(a_link3 == ((struct anonymous_3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a_link3->nel;
}

// da_nel_link4
// file list.h line 59
static inline unsigned int da_nel_link4(struct anonymous_3 *a_link4)
{
  if(a_link4 == ((struct anonymous_3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a_link4->nel;
}

// da_nel_link5
// file list.h line 59
static inline unsigned int da_nel_link5(struct anonymous_3 *a_link5)
{
  if(a_link5 == ((struct anonymous_3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a_link5->nel;
}

// da_nel_link6
// file list.h line 59
static inline unsigned int da_nel_link6(struct anonymous_3 *a_link6)
{
  if(a_link6 == ((struct anonymous_3 *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)a_link6->nel;
}

// da_resize
// file list.h line 55
struct anonymous_3 * da_resize(struct anonymous_3 *a, unsigned long int headsz, unsigned long int elemsz, unsigned long int n, void (*cleanuproutine)(void *))
{
  unsigned long int ael;
  unsigned long int tmp_if_expr_2;
  unsigned long int return_value_alloc_nel_1;
  if(!(a == ((struct anonymous_3 *)NULL)))
  {
    return_value_alloc_nel_1=alloc_nel(a->nel);
    tmp_if_expr_2 = return_value_alloc_nel_1;
  }

  else
    tmp_if_expr_2 = (unsigned long int)0;
  ael = tmp_if_expr_2;
  unsigned long int new_ael;
  new_ael=alloc_nel(n);
  if(!(new_ael == ael))
  {
    struct anonymous_3 *tmp;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)a, headsz + elemsz * new_ael);
    tmp = (struct anonymous_3 *)return_value_realloc_3;
    if(tmp == ((struct anonymous_3 *)NULL) && !(a == ((struct anonymous_3 *)NULL)))
    {
      if(!(cleanuproutine == ((void (*)(void *))NULL)))
      {
        unsigned long int i;
        unsigned long int k = a->nel;
        i = (unsigned long int)0;
        if(!(i >= k))
        {
          cleanuproutine((void *)((char *)a + (signed long int)headsz + (signed long int)(elemsz * i)));
          i = i + 1ul;
        }

      }

      free((void *)a);
    }

    a = tmp;
  }

  if(!(a == ((struct anonymous_3 *)NULL)))
    a->nel = n;

  return a;
}

// debug_msg
// file error.h line 74
void debug_msg(signed int c, const char *fmt, ...)
{
  void **va;
  unsigned long int return_value_strftime_2;
  if(c == 0)
  {
    char ts[(signed long int)sizeof(char [15l]) /*15l*/ ];
    signed long int tt;
    tt=time((signed long int *)(void *)0);
    struct tm tm;
    unsigned int *id;
    struct tm *return_value_localtime_r_3;
    return_value_localtime_r_3=localtime_r(&tt, &tm);
    if(!(return_value_localtime_r_3 == ((struct tm *)NULL)))
    {
      return_value_strftime_2=strftime(ts, sizeof(char [15l]) /*15ul*/ , "%m/%d %T", &tm);
      if(return_value_strftime_2 >= 1ul)
      {
        void *return_value_pthread_getspecific_1;
        return_value_pthread_getspecific_1=pthread_getspecific(thrid_key);
        id = (unsigned int *)return_value_pthread_getspecific_1;
        if(!(id == ((unsigned int *)NULL)))
          fprintf(dbg_file, "%u %s| ", *id, (const void *)ts);

        else
          fprintf(dbg_file, "- %s| ", (const void *)ts);
      }

    }

  }

  va = (void **)&fmt;
  vfprintf(dbg_file, fmt, va);
  va = ((void **)NULL);
  fflush(dbg_file);
}

// decode_query
// file dns_answer.c line 1003
static signed int decode_query(unsigned char *data, unsigned long int rlen, unsigned char **ptrrem, unsigned long int *lenrem, struct anonymous_40 *qp)
{
  signed int i;
  signed int res = 0;
  struct anonymous_29 *hdr = (struct anonymous_29 *)data;
  unsigned char *ptr = (unsigned char *)(hdr + (signed long int)1);
  unsigned long int sz = rlen - sizeof(struct anonymous_29) /*12ul*/ ;
  unsigned short int qdcount;
  qdcount=ntohs(hdr->qdcount);
  llist_init(qp);
  i = 0;
  for( ; !(i >= (signed int)qdcount); i = i + 1)
  {
    struct anonymous_70 *qe;
    unsigned int qlen;
    unsigned char qbuf[256l];
    res=decompress_name(data, rlen, &ptr, &sz, qbuf, &qlen);
    if(res == 0xfffe)
      break;

    if(!(res == 0))
    {
      llist_free(qp);
      break;
    }

    if(!(sz >= 4ul))
    {
      if(!(debug_p == 0))
        debug_msg(0, "decode_query: query truncated in qtype or qclass.\n");

      res = 0xfffe;
      break;
    }

    signed int return_value_llist_grow_1;
    return_value_llist_grow_1=llist_grow(qp, sizeof(struct anonymous_70) /*4ul*/  + (unsigned long int)qlen);
    if(return_value_llist_grow_1 == 0)
    {
      res = 2;
      break;
    }

    void *return_value_llist_last_2;
    return_value_llist_last_2=llist_last(qp);
    qe = (struct anonymous_70 *)return_value_llist_last_2;
    do
    {
      unsigned short int t_s;
      const unsigned char *t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post_3 = t_cp;
      t_cp = t_cp + 1l;
      t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_3 << 8);
      const unsigned char *tmp_post_4 = t_cp;
      t_cp = t_cp + 1l;
      t_s = t_s | (unsigned short int)*tmp_post_4;
      qe->qtype = t_s;
      ptr = (unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int decode_query__1__1__1__5__t_s;
      const unsigned char *decode_query__1__1__1__5__t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post_5 = decode_query__1__1__1__5__t_cp;
      decode_query__1__1__1__5__t_cp = decode_query__1__1__1__5__t_cp + 1l;
      decode_query__1__1__1__5__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_5 << 8);
      const unsigned char *tmp_post_6 = decode_query__1__1__1__5__t_cp;
      decode_query__1__1__1__5__t_cp = decode_query__1__1__1__5__t_cp + 1l;
      decode_query__1__1__1__5__t_s = decode_query__1__1__1__5__t_s | (unsigned short int)*tmp_post_6;
      qe->qclass = decode_query__1__1__1__5__t_s;
      ptr = (unsigned char *)(void *)decode_query__1__1__1__5__t_cp;
    }
    while((_Bool)0);
    sz = sz - (unsigned long int)4;
    memcpy((void *)qe->query, (const void *)qbuf, (unsigned long int)qlen);
  }
  if(!(ptrrem == ((unsigned char **)NULL)))
    *ptrrem = ptr;

  if(!(lenrem == ((unsigned long int *)NULL)))
    *lenrem = sz;

  return res;
}

// decode_query_additional
// file dns_answer.c line 1058
static signed int decode_query_additional(unsigned char *data, unsigned long int rlen, unsigned char *ptr, unsigned long int sz, signed int numrr, signed int *numopt, struct anonymous_17 *ep)
{
  signed int i;
  signed int res;
  i = 0;
  const char *return_value_getrrtpname_8;
  for( ; !(i >= numrr); i = i + 1)
  {
    unsigned char nmbuf[256l];
    unsigned short int type;
    unsigned short int class;
    unsigned char *ttlp;
    unsigned short int rdlen;
    res=decompress_name(data, rlen, &ptr, &sz, nmbuf, (unsigned int *)(void *)0);
    if(!(res == 0))
      return res;

    if(!(sz >= 10ul))
    {
      if(!(debug_p == 0))
        debug_msg(0, "decode_query_additional: additional section truncated in RR header.\n");

      return 0xfffe;
    }

    sz = sz - (unsigned long int)10;
    do
    {
      unsigned short int t_s;
      const unsigned char *t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post_1 = t_cp;
      t_cp = t_cp + 1l;
      t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_1 << 8);
      const unsigned char *tmp_post_2 = t_cp;
      t_cp = t_cp + 1l;
      t_s = t_s | (unsigned short int)*tmp_post_2;
      type = t_s;
      ptr = (unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int decode_query_additional__1__1__1__3__t_s;
      const unsigned char *decode_query_additional__1__1__1__3__t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post_3 = decode_query_additional__1__1__1__3__t_cp;
      decode_query_additional__1__1__1__3__t_cp = decode_query_additional__1__1__1__3__t_cp + 1l;
      decode_query_additional__1__1__1__3__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_3 << 8);
      const unsigned char *tmp_post_4 = decode_query_additional__1__1__1__3__t_cp;
      decode_query_additional__1__1__1__3__t_cp = decode_query_additional__1__1__1__3__t_cp + 1l;
      decode_query_additional__1__1__1__3__t_s = decode_query_additional__1__1__1__3__t_s | (unsigned short int)*tmp_post_4;
      class = decode_query_additional__1__1__1__3__t_s;
      ptr = (unsigned char *)(void *)decode_query_additional__1__1__1__3__t_cp;
    }
    while((_Bool)0);
    ttlp = ptr;
    ptr = ptr + (signed long int)4;
    do
    {
      unsigned short int decode_query_additional__1__1__1__4__t_s;
      const unsigned char *decode_query_additional__1__1__1__4__t_cp = (const unsigned char *)ptr;
      const unsigned char *tmp_post_5 = decode_query_additional__1__1__1__4__t_cp;
      decode_query_additional__1__1__1__4__t_cp = decode_query_additional__1__1__1__4__t_cp + 1l;
      decode_query_additional__1__1__1__4__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_5 << 8);
      const unsigned char *tmp_post_6 = decode_query_additional__1__1__1__4__t_cp;
      decode_query_additional__1__1__1__4__t_cp = decode_query_additional__1__1__1__4__t_cp + 1l;
      decode_query_additional__1__1__1__4__t_s = decode_query_additional__1__1__1__4__t_s | (unsigned short int)*tmp_post_6;
      rdlen = decode_query_additional__1__1__1__4__t_s;
      ptr = (unsigned char *)(void *)decode_query_additional__1__1__1__4__t_cp;
    }
    while((_Bool)0);
    if(!(sz >= (unsigned long int)rdlen))
    {
      if(!(debug_p == 0))
        debug_msg(0, "decode_query_additional: additional section truncated in RDATA field.\n");

      return 0xfffe;
    }

    if((signed int)type == 41)
    {
      signed int tmp_post_7 = *numopt;
      *numopt = *numopt + 1;
      if(tmp_post_7 == 0)
      {
        if(!((signed int)nmbuf[0l] == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "decode_query_additional: name in OPT record not empty!\n");

        }

        ep->udpsize = class;
        ep->rcode = (unsigned short int)((signed int)(unsigned short int)ttlp[(signed long int)0] << 4 | (signed int)((struct anonymous_29 *)data)->rcode);
        ep->version = (unsigned short int)ttlp[(signed long int)1];
        ep->do_flg = (unsigned char)((signed int)ttlp[(signed long int)2] >> 7 & 1);
        if(!(debug_p == 0))
        {
          unsigned int Zflags = (unsigned int)((signed int)(unsigned short int)ttlp[(signed long int)2] << 8 | (signed int)ttlp[(signed long int)3]);
          if(!((32767u & Zflags) == 0u))
          {
            if(!(debug_p == 0))
              debug_msg(0, "decode_query_additional: Z field contains unknown nonzero bits (%04x).\n", Zflags);

          }

          if(!(rdlen == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "decode_query_additional: RDATA field in OPT record not empty!\n");

          }

        }

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "decode_query_additional: ingnoring surplus OPT record.\n");

    }

    else
      if(!(debug_p == 0))
      {
        return_value_getrrtpname_8=getrrtpname((signed int)type);
        debug_msg(0, "decode_query_additional: ignoring record of type %s (%d).\n", return_value_getrrtpname_8, type);
      }

    sz = sz - (unsigned long int)rdlen;
    ptr = ptr + (signed long int)rdlen;
  }
  return 0;
}

// decompress_name
// file dns.c line 44
signed int decompress_name(unsigned char *msg, unsigned long int msgsz, unsigned char **src, unsigned long int *sz, unsigned char *tgt, unsigned int *len)
{
  unsigned int lb;
  unsigned int offs;
  unsigned int hops = (unsigned int)0;
  unsigned int tpos = (unsigned int)0;
  unsigned char *lptr = *src;
  unsigned long int oldsz = *sz;
  unsigned long int newsz = oldsz;
  if(!(newsz == 0ul))
  {
    if((unsigned long int)(lptr - msg) >= msgsz)
      goto name_outside_msg;

    do
    {
      newsz = newsz - 1ul;
      unsigned char *tmp_post_1 = lptr;
      lptr = lptr + 1l;
      lb = (unsigned int)*tmp_post_1;
      if(lb >= 64u)
      {
        if(!(lb >= 192u))
          goto unsupported_lbl_bits;

        if(newsz == 0ul)
          goto name_outside_data;

        if((unsigned long int)(lptr - msg) >= msgsz)
          goto name_outside_msg;

        newsz = newsz - 1ul;
        offs = (lb & (unsigned int)0x3f) << 8 | (unsigned int)*lptr;
        if((unsigned long int)offs >= msgsz)
          goto offset_outside_msg;

        lptr = msg + (signed long int)offs;
        goto jumped;
      }

      unsigned int tmp_post_2 = tpos;
      tpos = tpos + 1u;
      tgt[(signed long int)tmp_post_2] = (unsigned char)lb;
      if(lb == 0u)
        break;

      if((unsigned long int)lb >= newsz)
        goto name_outside_data;

      if((unsigned long int)((lptr + (signed long int)lb) - msg) >= msgsz)
        goto name_outside_msg;

      if(lb + tpos >= 256u)
        goto name_buf_full;

      newsz = newsz - (unsigned long int)lb;
      do
      {
        unsigned int tmp_post_3 = tpos;
        tpos = tpos + 1u;
        unsigned char *tmp_post_4 = lptr;
        lptr = lptr + 1l;
        tgt[(signed long int)tmp_post_3] = *tmp_post_4;
        lb = lb - 1u;
      }
      while(!(lb == 0u));
    }
    while((_Bool)1);
    goto return_OK;

  jumped:
    ;
    hops = hops + 1u;
    do
    {
      unsigned char *tmp_post_5 = lptr;
      lptr = lptr + 1l;
      lb = (unsigned int)*tmp_post_5;
      while(lb >= 64u)
      {
        if(!(lb >= 192u))
          goto unsupported_lbl_bits;

        if((unsigned long int)(lptr - msg) >= msgsz)
          goto name_outside_msg;

        hops = hops + 1u;
        if(hops >= 256u)
          goto too_many_hops;

        offs = (lb & (unsigned int)0x3f) << 8 | (unsigned int)*lptr;
        if((unsigned long int)offs >= msgsz)
          goto offset_outside_msg;

        lptr = msg + (signed long int)offs;
        unsigned char *tmp_post_6 = lptr;
        lptr = lptr + 1l;
        lb = (unsigned int)*tmp_post_6;
      }
      unsigned int tmp_post_7 = tpos;
      tpos = tpos + 1u;
      tgt[(signed long int)tmp_post_7] = (unsigned char)lb;
      if(lb == 0u)
        break;

      if((unsigned long int)((lptr + (signed long int)lb) - msg) >= msgsz)
        goto name_outside_msg;

      if(lb + tpos >= 256u)
        goto name_buf_full;

      do
      {
        unsigned int tmp_post_8 = tpos;
        tpos = tpos + 1u;
        unsigned char *tmp_post_9 = lptr;
        lptr = lptr + 1l;
        tgt[(signed long int)tmp_post_8] = *tmp_post_9;
        lb = lb - 1u;
      }
      while(!(lb == 0u));
    }
    while((_Bool)1);

  return_OK:
    ;
    *src = *src + (signed long int)(oldsz - newsz);
    *sz = newsz;
    if(!(len == ((unsigned int *)NULL)))
      *len = tpos;

    return 0;
  }

  else
  {

  name_outside_data:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: compressed name extends outside data field.\n");

    return 0xfffe;

  name_outside_msg:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: compressed name extends outside message.\n");

    return 1;

  unsupported_lbl_bits:
    ;
    if(!(debug_p == 0))
      debug_msg(0, lb == (unsigned int)0x41 ? "decompress_name: Bit-string labels not supported.\n" : "decompress_name: unsupported label type.\n");

    return 1;

  offset_outside_msg:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: offset points outside message.\n");

    return 1;

  name_buf_full:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: decompressed name larger than %u bytes.\n", 256);

    return 1;

  too_many_hops:
    ;
    if(!(debug_p == 0))
      debug_msg(0, "decompress_name: too many offsets in compressed name.\n");

    return 1;
  }
}

// decrease_procs
// file dns_answer.c line 1347
static inline void decrease_procs()
{
  pthread_mutex_lock(&proc_lock);
  procs = procs - 1;
  qprocs = qprocs - 1;
  pthread_mutex_unlock(&proc_lock);
}

// del_cache
// file cache.h line 175
void del_cache(const unsigned char *name)
{
  struct anonymous_0 *cent;
  lock_cache_rw();
  cent=del_dns_hash(name);
  if(!(cent == ((struct anonymous_0 *)NULL)))
    del_cent(cent);

  unlock_cache_rw();
}

// del_cache_ent
// file cache.c line 2075
static void del_cache_ent(struct anonymous_0 *cent, struct anonymous_58 *loc)
{
  struct anonymous_0 *data;
  if(!(loc == ((struct anonymous_58 *)NULL)))
    data=del_dns_hash_ent(loc);

  else
    data=del_dns_hash(cent->qname);
  if(data == ((struct anonymous_0 *)NULL))
    log_message(4, "Cache entry not found by del_dns_hash() in %s, line %d", (const void *)"cache.c", 2085);

  else
    if(!(data == cent))
      log_message(4, "pointer returned by del_dns_hash() does not match cache entry in %s, line %d", (const void *)"cache.c", 2088);

  del_cent(cent);
}

// del_cent
// file cache.c line 2061
void del_cent(struct anonymous_0 *cent)
{
  cache_size = cache_size - (volatile signed long int)cent->cs;
  free_cent(cent);
  free((void *)cent);
  ent_num = ent_num - 1l;
}

// del_cent_rrset_by_index
// file cache.c line 776
static signed int del_cent_rrset_by_index(struct anonymous_0 *cent, signed int i)
{
  signed int rv = 0;
  struct anonymous **rrspa;
  struct anonymous **tmp_if_expr_3;
  struct anonymous **tmp_if_expr_2;
  struct anonymous **tmp_if_expr_1;
  if(!((1 & (signed int)cent->flags) == 0))
    tmp_if_expr_3 = (struct anonymous **)(void *)0;

  else
  {
    if(!(i >= 8))
      tmp_if_expr_2 = &cent->_anon0.rr.rrmu[(signed long int)i];

    else
    {
      if(!(cent->_anon0.rr.rrext == ((struct anonymous **)NULL)))
        tmp_if_expr_1 = &cent->_anon0.rr.rrext[(signed long int)(i - 8)];

      else
        tmp_if_expr_1 = (struct anonymous **)(void *)0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }
    tmp_if_expr_3 = tmp_if_expr_2;
  }
  rrspa = tmp_if_expr_3;
  if(!(rrspa == ((struct anonymous **)NULL)))
  {
    struct anonymous *rrs = *rrspa;
    if(!(rrs == ((struct anonymous *)NULL)))
    {
      rv=del_rrset(rrs);
      *rrspa = (struct anonymous *)(void *)0;
      cent->num_rrs = cent->num_rrs - 1;
      cent->cs = cent->cs - (unsigned long int)rv;
      cent->flags = cent->flags & (unsigned short int)~4;
    }

  }

  return rv;
}

// del_dns_hash
// file hash.h line 71
struct anonymous_0 * del_dns_hash(const unsigned char *key)
{
  unsigned int idx;
  unsigned long int rh;
  struct dns_hash_ent_s **hep;
  struct dns_hash_ent_s *he;
  struct anonymous_0 *data;
  idx=dns_hash(key, &rh);
  hep = &hash_buckets[(signed long int)idx];
  signed int return_value_rhnicmp_1;
  do
  {
    he = *hep;
    if(he == ((struct dns_hash_ent_s *)NULL))
      break;

    if(!(rh >= he->rhash))
      break;

    if(he->rhash == rh)
    {
      return_value_rhnicmp_1=rhnicmp_link2(key, he->data->qname);
      if(!(return_value_rhnicmp_1 == 0))
      {
        *hep = he->next;
        data = he->data;
        free((void *)he);
        return data;
      }

    }

    hep = &he->next;
  }
  while((_Bool)1);
  return (struct anonymous_0 *)(void *)0;
}

// del_dns_hash_ent
// file hash.h line 70
struct anonymous_0 * del_dns_hash_ent(struct anonymous_58 *loc)
{
  struct dns_hash_ent_s *he = *loc->pos;
  struct anonymous_0 *data;
  *loc->pos = he->next;
  data = he->data;
  free((void *)he);
  return data;
}

// del_qserv
// file dns_query.c line 2025
static inline void del_qserv(struct anonymous_4 *q)
{
  free((void *)q);
}

// del_rrset
// file cache.h line 202
signed int del_rrset(struct anonymous *rrs)
{
  signed int rv = (signed int)sizeof(struct anonymous) /*40ul*/ ;
  struct rr_b_s *rrb;
  struct rr_b_s *rrn;
  if(!(rrs->lent == ((struct rr_lent_s *)NULL)))
    remove_rrl(rrs->lent);

  rrb = rrs->rrs;
  for( ; !(rrb == ((struct rr_b_s *)NULL)); rrb = rrn)
  {
    rv = rv + (signed int)(sizeof(struct rr_b_s) /*16ul*/  + (unsigned long int)rrb->rdlen);
    rrn = rrb->next;
    free((void *)rrb);
  }
  free((void *)rrs);
  return rv;
}

// destroy_cache
// file cache.h line 163
void destroy_cache(void)
{
  signed int return_value_softlock_cache_rw_1;
  return_value_softlock_cache_rw_1=softlock_cache_rw();
  if(return_value_softlock_cache_rw_1 == 0)
    log_message(3, "Lock failed; could not destroy cache on exit.");

  else
  {
    free_dns_hash();
    if(!(cache_size == 0l) || !(ent_num == 0l))
    {
      if(!(debug_p == 0))
        debug_msg(0, "After destroying cache, %ld entries (%ld bytes) remaining.\n", ent_num, cache_size);

    }

  }
}

// dev_up
// file netdev.c line 135
signed int dev_up(char *ifname, char *devname)
{
  struct _IO_FILE *fd;
  signed int pidi;
  signed int pidd;
  signed int rv;
  signed long int rv_array_size0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(ifname);
  rv_array_size0 = (signed long int)(sizeof(char [14l]) /*14ul*/  + return_value_strlen_1);
  char path[rv_array_size0];
  char *return_value_stpcpy_2;
  return_value_stpcpy_2=stpcpy(path, "/var/run/");
  char *return_value_stpcpy_3;
  return_value_stpcpy_3=stpcpy(return_value_stpcpy_2, ifname);
  stpcpy(return_value_stpcpy_3, ".pid");
  fd=fopen(path, "r");
  _Bool tmp_if_expr_9;
  signed int *return_value___errno_location_8;
  if(fd == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    signed int return_value_fscanf_4;
    return_value_fscanf_4=fscanf(fd, "%d", &pidi);
    if(!(return_value_fscanf_4 == 1))
    {
      fclose(fd);
      return 0;
    }

    else
    {
      fclose(fd);
      signed long int path_array_size0;
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(devname);
      path_array_size0 = (signed long int)(sizeof(char [16l]) /*16ul*/  + return_value_strlen_5);
      char dev_up__1__2__path[path_array_size0];
      char *return_value_stpcpy_6;
      return_value_stpcpy_6=stpcpy(dev_up__1__2__path, "/var/lock/LCK..");
      stpcpy(return_value_stpcpy_6, devname);
      fd=fopen(dev_up__1__2__path, "r");
      if(fd == ((struct _IO_FILE *)NULL))
        return 0;

      else
      {
        signed int return_value_fscanf_7;
        return_value_fscanf_7=fscanf(fd, "%d", &pidd);
        if(!(return_value_fscanf_7 == 1))
        {
          fclose(fd);
          return 0;
        }

        else
        {
          fclose(fd);
          if(!(pidi == pidd))
            return 0;

          else
          {
            rv=kill(pidi, 0);
            _Bool tmp_if_expr_10;
            if(rv == 0)
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              if(rv == -1)
              {
                return_value___errno_location_8=__errno_location();
                tmp_if_expr_9 = *return_value___errno_location_8 != 3 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_9 = (_Bool)0;
              tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
            }
            return (signed int)tmp_if_expr_10;
          }
        }
      }
    }
  }
}

// dlist_first
// file list.h line 87
static inline void * dlist_first(struct _dynamic_list_head *a)
{
  char *tmp_if_expr_1;
  if(!(a == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr_1 = &a->data[(signed long int)sizeof(unsigned long int) /*8ul*/ ];

  else
    tmp_if_expr_1 = (char *)(void *)0;
  return (void *)tmp_if_expr_1;
}

// dlist_first_link1
// file list.h line 87
static inline void * dlist_first_link1(struct _dynamic_list_head *a_link1)
{
  char *tmp_if_expr_1_link1;
  if(!(a_link1 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr_1_link1 = &a_link1->data[(signed long int)sizeof(unsigned long int) /*8ul*/ ];

  else
    tmp_if_expr_1_link1 = (char *)(void *)0;
  return (void *)tmp_if_expr_1_link1;
}

// dlist_first_link2
// file list.h line 87
static inline void * dlist_first_link2(struct _dynamic_list_head *a_link2)
{
  char *tmp_if_expr_1_link2;
  if(!(a_link2 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr_1_link2 = &a_link2->data[(signed long int)sizeof(unsigned long int) /*8ul*/ ];

  else
    tmp_if_expr_1_link2 = (char *)(void *)0;
  return (void *)tmp_if_expr_1_link2;
}

// dlist_grow
// file list.h line 112
struct _dynamic_list_head * dlist_grow(struct _dynamic_list_head *a, unsigned long int len)
{
  unsigned long int sz = (unsigned long int)0;
  unsigned long int allocsz = (unsigned long int)0;
  unsigned long int szincr;
  unsigned long int newsz;
  if(!(a == ((struct _dynamic_list_head *)NULL)))
  {
    sz = a->last + a->lastsz;
    allocsz = sz + (unsigned long int)0x3ff & ~((unsigned long int)0x3ff);
    *((unsigned long int *)&a->data[(signed long int)a->last]) = a->lastsz;
  }

  szincr = len + sizeof(unsigned long int) /*8ul*/  + (sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1) & ~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1);
  newsz = sz + szincr;
  if(!(allocsz >= newsz))
  {
    struct _dynamic_list_head *tmp;
    allocsz = newsz + (unsigned long int)0x3ff & ~((unsigned long int)0x3ff);
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)a, sizeof(struct _dynamic_list_head) /*16ul*/  + allocsz);
    tmp = (struct _dynamic_list_head *)return_value_realloc_1;
    if(tmp == ((struct _dynamic_list_head *)NULL))
      free((void *)a);

    a = tmp;
  }

  if(!(a == ((struct _dynamic_list_head *)NULL)))
  {
    a->last = sz;
    a->lastsz = szincr;
    *((unsigned long int *)&a->data[(signed long int)sz]) = (unsigned long int)0;
  }

  return a;
}

// dlist_last
// file list.h line 107
static inline void * dlist_last(struct _dynamic_list_head *a)
{
  char *tmp_if_expr_1;
  if(!(a == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr_1 = &a->data[(signed long int)(a->last + sizeof(unsigned long int) /*8ul*/ )];

  else
    tmp_if_expr_1 = (char *)(void *)0;
  return (void *)tmp_if_expr_1;
}

// dlist_last_link1
// file list.h line 107
static inline void * dlist_last_link1(struct _dynamic_list_head *a_link1)
{
  char *tmp_if_expr_1_link1;
  if(!(a_link1 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr_1_link1 = &a_link1->data[(signed long int)(a_link1->last + sizeof(unsigned long int) /*8ul*/ )];

  else
    tmp_if_expr_1_link1 = (char *)(void *)0;
  return (void *)tmp_if_expr_1_link1;
}

// dlist_last_link2
// file list.h line 107
static inline void * dlist_last_link2(struct _dynamic_list_head *a_link2)
{
  char *tmp_if_expr_1_link2;
  if(!(a_link2 == ((struct _dynamic_list_head *)NULL)))
    tmp_if_expr_1_link2 = &a_link2->data[(signed long int)(a_link2->last + sizeof(unsigned long int) /*8ul*/ )];

  else
    tmp_if_expr_1_link2 = (char *)(void *)0;
  return (void *)tmp_if_expr_1_link2;
}

// dlist_next
// file list.h line 98
static inline void * dlist_next(void *ref)
{
  unsigned long int incr = *((unsigned long int *)ref - (signed long int)1);
  return (void *)(incr != 0ul ? (char *)ref + (signed long int)incr : (char *)(void *)0);
}

// dlist_next_link1
// file list.h line 98
static inline void * dlist_next_link1(void *ref_link1)
{
  unsigned long int incr_link1 = *((unsigned long int *)ref_link1 - (signed long int)1);
  return (void *)(incr_link1 != 0ul ? (char *)ref_link1 + (signed long int)incr_link1 : (char *)(void *)0);
}

// dlist_next_link2
// file list.h line 98
static inline void * dlist_next_link2(void *ref_link2)
{
  unsigned long int incr_link2 = *((unsigned long int *)ref_link2 - (signed long int)1);
  return (void *)(incr_link2 != 0ul ? (char *)ref_link2 + (signed long int)incr_link2 : (char *)(void *)0);
}

// dns_hash
// file hash.c line 57
static unsigned int dns_hash(const unsigned char *str, unsigned long int *rhash)
{
  unsigned int s;
  unsigned int i;
  unsigned int lb;
  unsigned int c;
  unsigned long int r;
  s = (unsigned int)0;
  r = (unsigned long int)0;
  i = (unsigned int)0;
  do
  {
    lb = (unsigned int)str[(signed long int)i];
    if(lb == 0u)
      break;

    s = s + (lb << i % (unsigned int)(10 - 5));
    r = r + ((unsigned long int)lb << (unsigned long int)i % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/  - (unsigned long int)7));
    i = i + 1u;
    do
    {
      signed int return_value_toupper_1;
      return_value_toupper_1=toupper((signed int)str[(signed long int)i]);
      c = (unsigned int)return_value_toupper_1;
      s = s + (c << i % (unsigned int)(10 - 5));
      r = r + ((unsigned long int)c << (unsigned long int)i % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/  - (unsigned long int)7));
      i = i + 1u;
      lb = lb - 1u;
    }
    while(!(lb == 0u));
  }
  while((_Bool)1);
  s = (s & (unsigned int)((1 << 10) - 1)) + ((s & (unsigned int)~((1 << 10) - 1)) >> 10);
  s = (s & (unsigned int)((1 << 10) - 1)) + ((s & (unsigned int)~((1 << 10) - 1)) >> 10);
  s = s & (unsigned int)((1 << 10) - 1);
  if(!(rhash == ((unsigned long int *)NULL)))
    *rhash = r;

  return s;
}

// dns_lookup
// file hash.h line 68
struct anonymous_0 * dns_lookup(const unsigned char *key, struct anonymous_58 *loc)
{
  struct anonymous_0 *retval = (struct anonymous_0 *)(void *)0;
  unsigned int idx;
  unsigned long int rh;
  struct dns_hash_ent_s **hep;
  struct dns_hash_ent_s *he;
  idx=dns_hash(key, &rh);
  hep = &hash_buckets[(signed long int)idx];
  signed int return_value_rhnicmp_1;
  do
  {
    he = *hep;
    if(he == ((struct dns_hash_ent_s *)NULL))
      break;

    if(!(rh >= he->rhash))
      break;

    if(he->rhash == rh)
    {
      return_value_rhnicmp_1=rhnicmp_link2(key, he->data->qname);
      if(!(return_value_rhnicmp_1 == 0))
      {
        retval = he->data;
        break;
      }

    }

    hep = &he->next;
  }
  while((_Bool)1);
  if(!(loc == ((struct anonymous_58 *)NULL)))
  {
    loc->pos = hep;
    loc->rhash = rh;
  }

  return retval;
}

// dns_rootserver_resolv
// file dns_query.c line 2978
struct anonymous_14 * dns_rootserver_resolv(struct anonymous_19 *atup_a, signed int port, char edns_query, signed long int timeout)
{
  struct anonymous_14 *res = (struct anonymous_14 *)(void *)0;
  struct anonymous_0 *cent;
  signed int rc;
  static const unsigned char rdomain[1l] = { (const unsigned char)0 };
  rc=simple_dns_cached_resolve(atup_a, port, edns_query, timeout, rdomain, 2, &cent);
  const unsigned char *return_value_rhn2str_7;
  const char *return_value_get_ename_8;
  const unsigned char *return_value_rhn2str_9;
  unsigned int return_value_da_nel_12;
  const char *return_value_get_ename_14;
  if(rc == 0)
  {
    struct anonymous *dns_rootserver_resolv__1__1__rrset;
    struct anonymous *tmp_if_expr_1;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr_1 = cent->_anon0.rr.rrmu[(signed long int)1];

    else
      tmp_if_expr_1 = (struct anonymous *)(void *)0;
    dns_rootserver_resolv__1__1__rrset = tmp_if_expr_1;
    if(!(dns_rootserver_resolv__1__1__rrset == ((struct anonymous *)NULL)))
    {
      struct rr_b_s *rr;
      unsigned int nfail = (unsigned int)0;
      rr = dns_rootserver_resolv__1__1__rrset->rrs;
      for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
      {
        struct anonymous_15 serva;
        struct anonymous_0 *servent;
        if(run_ipv4 == 0)
          serva.ipv6 = in6addr_any;

        serva.ipv4.s_addr = (unsigned int)0x00000000;
        rc=simple_dns_cached_resolve(atup_a, port, edns_query, timeout, (const unsigned char *)rr->data, 1, &servent);
        if(rc == 0)
        {
          if(!(run_ipv4 == 0))
          {
            struct anonymous *rrset;
            struct anonymous *tmp_if_expr_2;
            if((1 & (signed int)servent->flags) == 0)
              tmp_if_expr_2 = servent->_anon0.rr.rrmu[(signed long int)0];

            else
              tmp_if_expr_2 = (struct anonymous *)(void *)0;
            rrset = tmp_if_expr_2;
            if(!(rrset == ((struct anonymous *)NULL)))
            {
              if(!(rrset->rrs == ((struct rr_b_s *)NULL)))
                serva.ipv4 = *((struct in_addr *)rrset->rrs->data);

            }

          }

          else
          {
            struct anonymous *dns_rootserver_resolv__1__1__1__1__1__1__2__rrset;
            struct anonymous *tmp_if_expr_5;
            if((1 & (signed int)servent->flags) == 0)
              tmp_if_expr_5 = servent->_anon0.rr.rrmu[(signed long int)7];

            else
              tmp_if_expr_5 = (struct anonymous *)(void *)0;
            dns_rootserver_resolv__1__1__1__1__1__1__2__rrset = tmp_if_expr_5;
            _Bool tmp_if_expr_6;
            if(!(dns_rootserver_resolv__1__1__1__1__1__1__2__rrset == ((struct anonymous *)NULL)))
              tmp_if_expr_6 = dns_rootserver_resolv__1__1__1__1__1__1__2__rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_6 = (_Bool)0;
            if(tmp_if_expr_6)
            {
              serva.ipv6 = *((struct in6_addr *)dns_rootserver_resolv__1__1__1__1__1__1__2__rrset->rrs->data);
              struct anonymous *tmp_if_expr_3;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr_3 = servent->_anon0.rr.rrmu[(signed long int)0];

              else
                tmp_if_expr_3 = (struct anonymous *)(void *)0;
              dns_rootserver_resolv__1__1__1__1__1__1__2__rrset = tmp_if_expr_3;
              if(!(dns_rootserver_resolv__1__1__1__1__1__1__2__rrset == ((struct anonymous *)NULL)))
              {
                if(!(dns_rootserver_resolv__1__1__1__1__1__1__2__rrset->rrs == ((struct rr_b_s *)NULL)))
                  serva.ipv4 = *((struct in_addr *)dns_rootserver_resolv__1__1__1__1__1__1__2__rrset->rrs->data);

              }

            }

            else
            {
              struct anonymous *tmp_if_expr_4;
              if((1 & (signed int)servent->flags) == 0)
                tmp_if_expr_4 = servent->_anon0.rr.rrmu[(signed long int)0];

              else
                tmp_if_expr_4 = (struct anonymous *)(void *)0;
              dns_rootserver_resolv__1__1__1__1__1__1__2__rrset = tmp_if_expr_4;
              if(!(dns_rootserver_resolv__1__1__1__1__1__1__2__rrset == ((struct anonymous *)NULL)))
              {
                if(!(dns_rootserver_resolv__1__1__1__1__1__1__2__rrset->rrs == ((struct rr_b_s *)NULL)))
                {
                  struct in_addr *ina = (struct in_addr *)dns_rootserver_resolv__1__1__1__1__1__1__2__rrset->rrs->data;
                  ((unsigned int *)&serva.ipv6)[(signed long int)3] = ina->s_addr;
                  ((unsigned int *)&serva.ipv6)[(signed long int)2]=htonl((unsigned int)0xffff);
                  ((unsigned int *)&serva.ipv6)[(signed long int)0] = (unsigned int)0;
                  ((unsigned int *)&serva.ipv6)[(signed long int)1] = ((unsigned int *)&serva.ipv6)[(signed long int)0];
                }

              }

            }
          }
          free_cent(servent);
          free((void *)servent);
        }

        else
        {
          unsigned char _debugstrbuf[256l];
          if(!(debug_p == 0))
          {
            return_value_rhn2str_7=rhn2str((const unsigned char *)rr->data, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            return_value_get_ename_8=get_ename(rc);
            debug_msg(0, "Simple query for %s type A failed (rc: %s)\n", return_value_rhn2str_7, return_value_get_ename_8);
          }

        }
        signed int return_value_is_inaddr2_any_10;
        return_value_is_inaddr2_any_10=is_inaddr2_any(&serva);
        if(!(return_value_is_inaddr2_any_10 == 0))
        {
          unsigned char dns_rootserver_resolv__1__1__1__1__1__3__1___debugstrbuf[256l];
          if(!(debug_p == 0))
          {
            return_value_rhn2str_9=rhn2str((const unsigned char *)rr->data, dns_rootserver_resolv__1__1__1__1__1__3__1___debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
            debug_msg(0, "Failed to obtain address of root server %s in dns_rootserver_resolv()\n", return_value_rhn2str_9);
          }

          nfail = nfail + 1u;
        }

        else
        {
          struct anonymous_3 *return_value_da_grow1_11;
          return_value_da_grow1_11=da_grow1((struct anonymous_3 *)res, (unsigned long int)((struct anonymous_14 *)0)->elem, sizeof(struct anonymous_15) /*20ul*/ , (void (*)(void *))(void *)0);
          res = (struct anonymous_14 *)return_value_da_grow1_11;
          if(res == ((struct anonymous_14 *)NULL))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Out of memory in dns_rootserver_resolv()\n");

            goto free_cent_return;
          }

          res->elem[(signed long int)(res->nel - (unsigned long int)1)] = serva;
        }
      }
      unsigned int return_value_da_nel_13;
      return_value_da_nel_13=da_nel_link2((struct anonymous_3 *)res);
      if(!(return_value_da_nel_13 >= nfail))
      {
        if(!(debug_p == 0))
        {
          return_value_da_nel_12=da_nel_link2((struct anonymous_3 *)res);
          debug_msg(0, "Too many root-server resolve failures (%u succeeded, %u failed), rejecting the result.\n", return_value_da_nel_12, nfail);
        }

        free((void *)res);
        res = (struct anonymous_14 *)(void *)0;
      }

    }


  free_cent_return:
    ;
    free_cent(cent);
    free((void *)cent);
  }

  else
    if(!(debug_p == 0))
    {
      return_value_get_ename_14=get_ename(rc);
      debug_msg(0, "Simple query for root domain type NS failed (rc: %s)\n", return_value_get_ename_14);
    }

  return res;
}

// dnsflags2str
// file dns.c line 544
char * dnsflags2str(struct anonymous_29 *hdr, char *buf)
{
  char *p = buf;
  void *return_value_mempcpy_1;
  if(!(hdr->aa == 0u))
  {
    return_value_mempcpy_1=mempcpy((void *)p, (const void *)" AA", (unsigned long int)3);
    p = (char *)return_value_mempcpy_1;
  }

  void *return_value_mempcpy_2;
  if(!(hdr->tc == 0u))
  {
    return_value_mempcpy_2=mempcpy((void *)p, (const void *)" TC", (unsigned long int)3);
    p = (char *)return_value_mempcpy_2;
  }

  void *return_value_mempcpy_3;
  if(!(hdr->rd == 0u))
  {
    return_value_mempcpy_3=mempcpy((void *)p, (const void *)" RD", (unsigned long int)3);
    p = (char *)return_value_mempcpy_3;
  }

  void *return_value_mempcpy_4;
  if(!(hdr->ra == 0u))
  {
    return_value_mempcpy_4=mempcpy((void *)p, (const void *)" RA", (unsigned long int)3);
    p = (char *)return_value_mempcpy_4;
  }

  void *return_value_mempcpy_5;
  if(!(hdr->z == 0u))
  {
    return_value_mempcpy_5=mempcpy((void *)p, (const void *)" Z", (unsigned long int)2);
    p = (char *)return_value_mempcpy_5;
  }

  void *return_value_mempcpy_6;
  if(!(hdr->ad == 0u))
  {
    return_value_mempcpy_6=mempcpy((void *)p, (const void *)" AD", (unsigned long int)3);
    p = (char *)return_value_mempcpy_6;
  }

  void *return_value_mempcpy_7;
  if(!(hdr->cd == 0u))
  {
    return_value_mempcpy_7=mempcpy((void *)p, (const void *)" CD", (unsigned long int)3);
    p = (char *)return_value_mempcpy_7;
  }

  *p = (char)0;
  return buf;
}

// domain_match
// file dns.c line 204
unsigned int domain_match(const unsigned char *ms, const unsigned char *md, unsigned int *os, unsigned int *od)
{
  unsigned int i;
  unsigned int j;
  unsigned int k;
  unsigned int n;
  unsigned int ns = (unsigned int)0;
  unsigned int nd = (unsigned int)0;
  unsigned int offs;
  unsigned int offd;
  unsigned char lb;
  unsigned char ls[128l];
  unsigned char ld[128l];
  i = (unsigned int)0;
  do
  {
    lb = ms[(signed long int)i];
    if(lb == 0)
      break;

    if(ns >= 128u)
    {
      log_message(3, "%s:%d: %s", (const void *)"dns.c", 212, (const void *)"domain_match: too many name segments");
      pdnsd_exit();
    }

    unsigned int tmp_post_1 = ns;
    ns = ns + 1u;
    ls[(signed long int)tmp_post_1] = lb;
    i = i + (unsigned int)lb + (unsigned int)1;
  }
  while((_Bool)1);
  j = (unsigned int)0;
  do
  {
    lb = md[(signed long int)j];
    if(lb == 0)
      break;

    if(nd >= 128u)
    {
      log_message(3, "%s:%d: %s", (const void *)"dns.c", 219, (const void *)"domain_match: too many name segments");
      pdnsd_exit();
    }

    unsigned int tmp_post_2 = nd;
    nd = nd + 1u;
    ld[(signed long int)tmp_post_2] = lb;
    j = j + (unsigned int)lb + (unsigned int)1;
  }
  while((_Bool)1);
  n = ns;
  if(!(nd >= n))
    n = nd;

  k = (unsigned int)1;
  signed int return_value_tolower_3;
  signed int return_value_tolower_4;
  do
  {
    offs = i;
    offd = j;
    if(!(n >= k))
      break;

    lb = ls[(signed long int)(ns - k)];
    if(!(lb == ld[(signed long int)(nd + -k)]))
      break;

    for( ; !(lb == 0); lb = lb - 1)
    {
      i = i - 1u;
      return_value_tolower_3=tolower((signed int)ms[(signed long int)i]);
      j = j - 1u;
      return_value_tolower_4=tolower((signed int)md[(signed long int)j]);
      if(!(return_value_tolower_3 == return_value_tolower_4))
        goto mismatch;

    }
    i = i - 1u;
    j = j - 1u;
    k = k + 1u;
  }
  while((_Bool)1);

mismatch:
  ;
  if(!(os == ((unsigned int *)NULL)))
    *os = offs;

  if(!(od == ((unsigned int *)NULL)))
    *od = offd;

  return k - (unsigned int)1;
}

// dump_cache
// file cache.h line 168
signed int dump_cache(signed int fd, const unsigned char *name, signed int exact)
{
  signed int rv = 0;
  lock_cache_r();
  if(!(name == ((const unsigned char *)NULL)) && !(exact == 0))
  {
    struct anonymous_0 *cent;
    cent=dns_lookup(name, (struct anonymous_58 *)(void *)0);
    if(!(cent == ((struct anonymous_0 *)NULL)))
      rv=dump_cent(fd, cent);

  }

  else
  {
    struct anonymous_0 *dump_cache__1__2__cent;
    struct anonymous_59 pos;
    dump_cache__1__2__cent=fetch_first(&pos);
    while(!(dump_cache__1__2__cent == ((struct anonymous_0 *)NULL)))
    {
      unsigned int nrem;
      _Bool tmp_if_expr_1;
      if(name == ((const unsigned char *)NULL))
        tmp_if_expr_1 = (_Bool)1;

      else
      {
        domain_match(name, dump_cache__1__2__cent->qname, &nrem, (unsigned int *)(void *)0);
        tmp_if_expr_1 = nrem == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_1)
      {
        rv=dump_cent(fd, dump_cache__1__2__cent);
        if(!(rv >= 0))
          break;

      }

      dump_cache__1__2__cent=fetch_next(&pos);
    }
  }
  unlock_cache_r();
  return rv;
}

// dump_cent
// file cache.c line 2395
static signed int dump_cent(signed int fd, struct anonymous_0 *cent)
{
  signed long int now;
  char tstr[(signed long int)sizeof(char [20l]) /*20l*/ ];
  char dbuf[1024l];
  signed int dump_cent__1__1___retval;
  const unsigned char *return_value_rhn2str_1;
  return_value_rhn2str_1=rhn2str(cent->qname, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
  dump_cent__1__1___retval=fsprintf(fd, "%s\n", return_value_rhn2str_1);
  struct tm *return_value_localtime_r_2;
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strftime_5;
  const unsigned short int *tmp_if_expr_8;
  struct tm *return_value_localtime_r_10;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_strftime_13;
  const char *return_value_loc2str_70;
  const char *return_value_inet_ntop_71;
  const char *return_value_inet_ntop_72;
  if(!(dump_cent__1__1___retval >= 0))
    return dump_cent__1__1___retval;

  else
  {
    now=time((signed long int *)(void *)0);
    if(!((1 & (signed int)cent->flags) == 0))
    {
      struct tm tstm;
      _Bool tmp_if_expr_3;
      if(!(cent->_anon0.neg.ts == 0l))
      {
        return_value_localtime_r_2=localtime_r(&cent->_anon0.neg.ts, &tstm);
        tmp_if_expr_3 = return_value_localtime_r_2 != ((struct tm *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      _Bool tmp_if_expr_6;
      if(tmp_if_expr_3)
      {
        if(now >= cent->_anon0.neg.ts)
          tmp_if_expr_4 = now - cent->_anon0.neg.ts < (signed long int)((365 * 24 * 60 * 60) / 2) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        return_value_strftime_5=strftime(tstr, sizeof(char [20l]) /*20ul*/ , tmp_if_expr_4 ? "    %m/%d %T" : "%Y/%m/%d %T", &tstm);
        tmp_if_expr_6 = return_value_strftime_5 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      if(!tmp_if_expr_6)
        strcpy(tstr, "                  ");

      signed int dump_cent__1__2__2___retval;
      dump_cent__1__2__2___retval=fsprintf(fd, "%s    (domain negated)\n", (const void *)tstr);
      if(!(dump_cent__1__2__2___retval >= 0))
        return dump_cent__1__2__2___retval;

    }

    else
    {
      signed int i;
      signed int dump_cent__1__3__n;
      signed int tmp_if_expr_7;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr_7 = 0;

      else
        tmp_if_expr_7 = cent->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      dump_cent__1__3__n = tmp_if_expr_7;
      const unsigned short int *iterlist;
      const unsigned short int *tmp_if_expr_9;
      if(!((1 & (signed int)cent->flags) == 0))
        tmp_if_expr_9 = (const unsigned short int *)(void *)0;

      else
      {
        if(!(cent->_anon0.rr.rrext == ((struct anonymous **)NULL)))
          tmp_if_expr_8 = rrcachiterlist;

        else
          tmp_if_expr_8 = rrmuiterlist;
        tmp_if_expr_9 = tmp_if_expr_8;
      }
      iterlist = tmp_if_expr_9;
      i = 0;
      for( ; !(i >= dump_cent__1__3__n); i = i + 1)
      {
        signed int tp = (signed int)iterlist[(signed long int)i];
        struct anonymous *rrset;
        rrset=getrrset_eff_link3(cent, tp);
        if(!(rrset == ((struct anonymous *)NULL)))
        {
          struct tm dump_cent__1__3__1__1__1__1__tstm;
          _Bool tmp_if_expr_11;
          if(!(rrset->ts == 0l))
          {
            return_value_localtime_r_10=localtime_r(&rrset->ts, &dump_cent__1__3__1__1__1__1__tstm);
            tmp_if_expr_11 = return_value_localtime_r_10 != ((struct tm *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_11 = (_Bool)0;
          _Bool tmp_if_expr_14;
          if(tmp_if_expr_11)
          {
            if(now >= rrset->ts)
              tmp_if_expr_12 = now - rrset->ts < (signed long int)((365 * 24 * 60 * 60) / 2) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_12 = (_Bool)0;
            return_value_strftime_13=strftime(tstr, sizeof(char [20l]) /*20ul*/ , tmp_if_expr_12 ? "    %m/%d %T" : "%Y/%m/%d %T", &dump_cent__1__3__1__1__1__1__tstm);
            tmp_if_expr_14 = return_value_strftime_13 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_14 = (_Bool)0;
          if(!tmp_if_expr_14)
            strcpy(tstr, "                  ");

          if(!((1 & (signed int)rrset->flags) == 0))
          {
            signed int dump_cent__1__3__1__1__1__2__1___retval;
            dump_cent__1__3__1__1__1__2__1___retval=fsprintf(fd, "%s    %-7s (negated)\n", (const void *)tstr, rrnames[(signed long int)(tp - 1)]);
            if(!(dump_cent__1__3__1__1__1__2__1___retval >= 0))
              return dump_cent__1__3__1__1__1__2__1___retval;

          }

          else
          {
            struct rr_b_s *rr = rrset->rrs;
            for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
            {
              switch(tp)
              {
                case 5:

                case 7:

                case 3:

                case 4:

                case 8:

                case 9:

                case 2:

                case 12:
                {
                  rhn2str((unsigned char *)rr->data, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  break;
                }
                case 14:

                case 17:
                {
                  unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__1__p = (unsigned char *)rr->data;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__1__n;
                  rhn2str(dump_cent__1__3__1__1__1__3__1__1__1__1__p, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  unsigned long int return_value_strlen_15;
                  return_value_strlen_15=strlen(dbuf);
                  dump_cent__1__3__1__1__1__3__1__1__1__1__n = (signed int)return_value_strlen_15;
                  signed int tmp_post_16 = dump_cent__1__3__1__1__1__3__1__1__1__1__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__1__n = dump_cent__1__3__1__1__1__3__1__1__1__1__n + 1;
                  dbuf[(signed long int)tmp_post_16] = (char)32;
                  if((unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__1__n >= sizeof(char [1024l]) /*1024ul*/ )
                    goto hex_dump;

                  unsigned char *return_value_skiprhn_17;
                  return_value_skiprhn_17=skiprhn_link2(dump_cent__1__3__1__1__1__3__1__1__1__1__p);
                  rhn2str(return_value_skiprhn_17, (unsigned char *)dbuf + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__1__n, (unsigned int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__1__n));
                  break;
                }
                case 15:

                case 18:

                case 21:

                case 36:
                {
                  unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__2__p = (unsigned char *)rr->data;
                  unsigned int dump_cent__1__3__1__1__1__3__1__1__1__2__pref;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__2__n;
                  do
                  {
                    unsigned short int dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_s;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__2__p;
                    const unsigned char *tmp_post_18 = dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_18 << 8);
                    const unsigned char *tmp_post_19 = dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_s = dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_s | (unsigned short int)*tmp_post_19;
                    dump_cent__1__3__1__1__1__3__1__1__1__2__pref = (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_s;
                    dump_cent__1__3__1__1__1__3__1__1__1__2__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__2__1__t_cp;
                  }
                  while((_Bool)0);
                  dump_cent__1__3__1__1__1__3__1__1__1__2__n=sprintf(dbuf, "%u ", dump_cent__1__3__1__1__1__3__1__1__1__2__pref);
                  if(!(dump_cent__1__3__1__1__1__3__1__1__1__2__n >= 0))
                    goto hex_dump;

                  rhn2str(dump_cent__1__3__1__1__1__3__1__1__1__2__p, (unsigned char *)dbuf + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__2__n, (unsigned int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__2__n));
                  break;
                }
                case 6:
                {
                  unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__3__p = (unsigned char *)rr->data;
                  char *dump_cent__1__3__1__1__1__3__1__1__1__3__q;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__3__n;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__3__rem;
                  unsigned int serial;
                  unsigned int refresh;
                  unsigned int retry;
                  unsigned int expire;
                  unsigned int minimum;
                  rhn2str(dump_cent__1__3__1__1__1__3__1__1__1__3__p, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  unsigned long int return_value_strlen_20;
                  return_value_strlen_20=strlen(dbuf);
                  dump_cent__1__3__1__1__1__3__1__1__1__3__n = (signed int)return_value_strlen_20;
                  signed int tmp_post_21 = dump_cent__1__3__1__1__1__3__1__1__1__3__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__3__n = dump_cent__1__3__1__1__1__3__1__1__1__3__n + 1;
                  dbuf[(signed long int)tmp_post_21] = (char)32;
                  if((unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__3__n >= sizeof(char [1024l]) /*1024ul*/ )
                    goto hex_dump;

                  dump_cent__1__3__1__1__1__3__1__1__1__3__q = dbuf + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__3__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__3__rem = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__3__n);
                  dump_cent__1__3__1__1__1__3__1__1__1__3__p=skiprhn_link2(dump_cent__1__3__1__1__1__3__1__1__1__3__p);
                  rhn2str(dump_cent__1__3__1__1__1__3__1__1__1__3__p, (unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__3__q, (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__3__rem);
                  unsigned long int return_value_strlen_22;
                  return_value_strlen_22=strlen(dump_cent__1__3__1__1__1__3__1__1__1__3__q);
                  dump_cent__1__3__1__1__1__3__1__1__1__3__n = (signed int)return_value_strlen_22;
                  signed int tmp_post_23 = dump_cent__1__3__1__1__1__3__1__1__1__3__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__3__n = dump_cent__1__3__1__1__1__3__1__1__1__3__n + 1;
                  dump_cent__1__3__1__1__1__3__1__1__1__3__q[(signed long int)tmp_post_23] = (char)32;
                  if(dump_cent__1__3__1__1__1__3__1__1__1__3__n >= dump_cent__1__3__1__1__1__3__1__1__1__3__rem)
                    goto hex_dump;

                  dump_cent__1__3__1__1__1__3__1__1__1__3__q = dump_cent__1__3__1__1__1__3__1__1__1__3__q + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__3__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__3__rem = dump_cent__1__3__1__1__1__3__1__1__1__3__rem - dump_cent__1__3__1__1__1__3__1__1__1__3__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__3__p=skiprhn_link2(dump_cent__1__3__1__1__1__3__1__1__1__3__p);
                  do
                  {
                    unsigned int t_l;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__3__p;
                    const unsigned char *tmp_post_24 = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp + 1l;
                    t_l = (unsigned int)*tmp_post_24 << 24;
                    const unsigned char *tmp_post_25 = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp + 1l;
                    t_l = t_l | (unsigned int)*tmp_post_25 << 16;
                    const unsigned char *tmp_post_26 = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp + 1l;
                    t_l = t_l | (unsigned int)*tmp_post_26 << 8;
                    const unsigned char *tmp_post_27 = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp + 1l;
                    t_l = t_l | (unsigned int)*tmp_post_27;
                    serial = t_l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__3__1__t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__3__p;
                    const unsigned char *tmp_post_28 = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l = (unsigned int)*tmp_post_28 << 24;
                    const unsigned char *tmp_post_29 = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l | (unsigned int)*tmp_post_29 << 16;
                    const unsigned char *tmp_post_30 = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l | (unsigned int)*tmp_post_30 << 8;
                    const unsigned char *tmp_post_31 = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l | (unsigned int)*tmp_post_31;
                    refresh = dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__3__2__t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__3__p;
                    const unsigned char *tmp_post_32 = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l = (unsigned int)*tmp_post_32 << 24;
                    const unsigned char *tmp_post_33 = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l | (unsigned int)*tmp_post_33 << 16;
                    const unsigned char *tmp_post_34 = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l | (unsigned int)*tmp_post_34 << 8;
                    const unsigned char *tmp_post_35 = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l | (unsigned int)*tmp_post_35;
                    retry = dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__3__3__t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__3__p;
                    const unsigned char *tmp_post_36 = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l = (unsigned int)*tmp_post_36 << 24;
                    const unsigned char *tmp_post_37 = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l | (unsigned int)*tmp_post_37 << 16;
                    const unsigned char *tmp_post_38 = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l | (unsigned int)*tmp_post_38 << 8;
                    const unsigned char *tmp_post_39 = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l | (unsigned int)*tmp_post_39;
                    expire = dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__3__4__t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned int dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__3__p;
                    const unsigned char *tmp_post_40 = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l = (unsigned int)*tmp_post_40 << 24;
                    const unsigned char *tmp_post_41 = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l | (unsigned int)*tmp_post_41 << 16;
                    const unsigned char *tmp_post_42 = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l | (unsigned int)*tmp_post_42 << 8;
                    const unsigned char *tmp_post_43 = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l | (unsigned int)*tmp_post_43;
                    minimum = dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_l;
                    dump_cent__1__3__1__1__1__3__1__1__1__3__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__3__5__t_cp;
                  }
                  while((_Bool)0);
                  dump_cent__1__3__1__1__1__3__1__1__1__3__n=snprintf(dump_cent__1__3__1__1__1__3__1__1__1__3__q, (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__3__rem, "%lu %lu %lu %lu %lu", (unsigned long int)serial, (unsigned long int)refresh, (unsigned long int)retry, (unsigned long int)expire, (unsigned long int)minimum);
                  if(dump_cent__1__3__1__1__1__3__1__1__1__3__n >= dump_cent__1__3__1__1__1__3__1__1__1__3__rem || !(dump_cent__1__3__1__1__1__3__1__1__1__3__n >= 0))
                    goto hex_dump;

                  break;
                }
                case 13:

                case 16:
                {
                  unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__4__p = (unsigned char *)rr->data;
                  char *q = dbuf;
                  signed int j = 0;
                  signed int n;
                  signed int rem = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
                  while(!((unsigned int)j >= rr->rdlen))
                  {
                    unsigned int lb;
                    if(!(rem >= 3))
                      goto hex_dump;

                    if(!(j == 0))
                    {
                      char *tmp_post_44 = q;
                      q = q + 1l;
                      *tmp_post_44 = (char)32;
                      rem = rem - 1;
                    }

                    char *tmp_post_45 = q;
                    q = q + 1l;
                    *tmp_post_45 = (char)34;
                    rem = rem - 1;
                    unsigned char *tmp_post_46 = dump_cent__1__3__1__1__1__3__1__1__1__4__p;
                    dump_cent__1__3__1__1__1__3__1__1__1__4__p = dump_cent__1__3__1__1__1__3__1__1__1__4__p + 1l;
                    lb = (unsigned int)*tmp_post_46;
                    j = j + (signed int)(lb + (unsigned int)1);
                    if(!(rr->rdlen >= (unsigned int)j))
                      goto hex_dump;

                    n=escapestr((char *)dump_cent__1__3__1__1__1__3__1__1__1__4__p, (signed int)lb, q, rem);
                    if(1 + n >= rem || !(n >= 0))
                      goto hex_dump;

                    q = q + (signed long int)n;
                    char *tmp_post_47 = q;
                    q = q + 1l;
                    *tmp_post_47 = (char)34;
                    rem = rem - (n + 1);
                    dump_cent__1__3__1__1__1__3__1__1__1__4__p = dump_cent__1__3__1__1__1__3__1__1__1__4__p + (signed long int)lb;
                  }
                  *q = (char)0;
                  break;
                }
                case 26:
                {
                  unsigned char *p = (unsigned char *)rr->data;
                  char *dump_cent__1__3__1__1__1__3__1__1__1__5__q;
                  unsigned int pref;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__5__n;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__5__rem;
                  do
                  {
                    unsigned short int t_s;
                    const unsigned char *t_cp = (const unsigned char *)p;
                    const unsigned char *tmp_post_48 = t_cp;
                    t_cp = t_cp + 1l;
                    t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_48 << 8);
                    const unsigned char *tmp_post_49 = t_cp;
                    t_cp = t_cp + 1l;
                    t_s = t_s | (unsigned short int)*tmp_post_49;
                    pref = (unsigned int)t_s;
                    p = (unsigned char *)(void *)t_cp;
                  }
                  while((_Bool)0);
                  dump_cent__1__3__1__1__1__3__1__1__1__5__n=sprintf(dbuf, "%u ", pref);
                  if(!(dump_cent__1__3__1__1__1__3__1__1__1__5__n >= 0))
                    goto hex_dump;

                  dump_cent__1__3__1__1__1__3__1__1__1__5__q = dbuf + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__5__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__5__rem = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__5__n);
                  rhn2str(p, (unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__5__q, (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__5__rem);
                  unsigned long int return_value_strlen_50;
                  return_value_strlen_50=strlen(dump_cent__1__3__1__1__1__3__1__1__1__5__q);
                  dump_cent__1__3__1__1__1__3__1__1__1__5__n = (signed int)return_value_strlen_50;
                  signed int tmp_post_51 = dump_cent__1__3__1__1__1__3__1__1__1__5__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__5__n = dump_cent__1__3__1__1__1__3__1__1__1__5__n + 1;
                  dump_cent__1__3__1__1__1__3__1__1__1__5__q[(signed long int)tmp_post_51] = (char)32;
                  if(dump_cent__1__3__1__1__1__3__1__1__1__5__n >= dump_cent__1__3__1__1__1__3__1__1__1__5__rem)
                    goto hex_dump;

                  unsigned char *return_value_skiprhn_52;
                  return_value_skiprhn_52=skiprhn_link2(p);
                  rhn2str(return_value_skiprhn_52, (unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__5__q + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__5__n, (unsigned int)(dump_cent__1__3__1__1__1__3__1__1__1__5__rem - dump_cent__1__3__1__1__1__3__1__1__1__5__n));
                  break;
                }
                case 33:
                {
                  unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__6__p = (unsigned char *)rr->data;
                  unsigned int priority;
                  unsigned int weight;
                  unsigned int port;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__6__n;
                  do
                  {
                    unsigned short int dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_s;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__6__p;
                    const unsigned char *tmp_post_53 = dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_53 << 8);
                    const unsigned char *tmp_post_54 = dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_s = dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_s | (unsigned short int)*tmp_post_54;
                    priority = (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_s;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__6__1__t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned short int dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_s;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__6__p;
                    const unsigned char *tmp_post_55 = dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_55 << 8);
                    const unsigned char *tmp_post_56 = dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_s = dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_s | (unsigned short int)*tmp_post_56;
                    weight = (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_s;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__6__2__t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned short int dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_s;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__6__p;
                    const unsigned char *tmp_post_57 = dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_57 << 8);
                    const unsigned char *tmp_post_58 = dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_s = dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_s | (unsigned short int)*tmp_post_58;
                    port = (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_s;
                    dump_cent__1__3__1__1__1__3__1__1__1__6__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__6__3__t_cp;
                  }
                  while((_Bool)0);
                  dump_cent__1__3__1__1__1__3__1__1__1__6__n=sprintf(dbuf, "%u %u %u ", priority, weight, port);
                  if(!(dump_cent__1__3__1__1__1__3__1__1__1__6__n >= 0))
                    goto hex_dump;

                  rhn2str(dump_cent__1__3__1__1__1__3__1__1__1__6__p, (unsigned char *)dbuf + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__6__n, (unsigned int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__6__n));
                  break;
                }
                case 30:
                {
                  unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__7__p = (unsigned char *)rr->data;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__7__n;
                  signed int rlen;
                  rhn2str(dump_cent__1__3__1__1__1__3__1__1__1__7__p, (unsigned char *)dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  unsigned long int return_value_strlen_59;
                  return_value_strlen_59=strlen(dbuf);
                  dump_cent__1__3__1__1__1__3__1__1__1__7__n = (signed int)return_value_strlen_59;
                  signed int tmp_post_60 = dump_cent__1__3__1__1__1__3__1__1__1__7__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__7__n = dump_cent__1__3__1__1__1__3__1__1__1__7__n + 1;
                  dbuf[(signed long int)tmp_post_60] = (char)32;
                  if((unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__7__n >= sizeof(char [1024l]) /*1024ul*/ )
                    goto hex_dump;

                  unsigned int return_value_rhnlen_61;
                  return_value_rhnlen_61=rhnlen_link6(dump_cent__1__3__1__1__1__3__1__1__1__7__p);
                  rlen = (signed int)return_value_rhnlen_61;
                  hexdump((const void *)(dump_cent__1__3__1__1__1__3__1__1__1__7__p + (signed long int)rlen), (signed int)(rr->rdlen - (unsigned int)rlen), dbuf + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__7__n, (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__7__n));
                  break;
                }
                case 35:
                {
                  unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__8__p = (unsigned char *)rr->data;
                  char *dump_cent__1__3__1__1__1__3__1__1__1__8__q;
                  unsigned int order;
                  unsigned int dump_cent__1__3__1__1__1__3__1__1__1__8__pref;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__8__n;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__8__rem;
                  signed int dump_cent__1__3__1__1__1__3__1__1__1__8__j;
                  do
                  {
                    unsigned short int dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_s;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__8__p;
                    const unsigned char *tmp_post_62 = dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_62 << 8);
                    const unsigned char *tmp_post_63 = dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_s = dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_s | (unsigned short int)*tmp_post_63;
                    order = (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_s;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__8__1__t_cp;
                  }
                  while((_Bool)0);
                  do
                  {
                    unsigned short int dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_s;
                    const unsigned char *dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp = (const unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__8__p;
                    const unsigned char *tmp_post_64 = dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_64 << 8);
                    const unsigned char *tmp_post_65 = dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp = dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_s = dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_s | (unsigned short int)*tmp_post_65;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__pref = (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_s;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__p = (unsigned char *)(void *)dump_cent__1__3__1__1__1__3__1__1__1__8__2__t_cp;
                  }
                  while((_Bool)0);
                  dump_cent__1__3__1__1__1__3__1__1__1__8__n=sprintf(dbuf, "%u %u ", order, dump_cent__1__3__1__1__1__3__1__1__1__8__pref);
                  if(!(dump_cent__1__3__1__1__1__3__1__1__1__8__n >= 0))
                    goto hex_dump;

                  dump_cent__1__3__1__1__1__3__1__1__1__8__q = dbuf + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__8__n;
                  dump_cent__1__3__1__1__1__3__1__1__1__8__rem = (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)dump_cent__1__3__1__1__1__3__1__1__1__8__n);
                  dump_cent__1__3__1__1__1__3__1__1__1__8__j = 0;
                  for( ; !(dump_cent__1__3__1__1__1__3__1__1__1__8__j >= 3); dump_cent__1__3__1__1__1__3__1__1__1__8__j = dump_cent__1__3__1__1__1__3__1__1__1__8__j + 1)
                  {
                    unsigned int dump_cent__1__3__1__1__1__3__1__1__1__8__3__1__lb;
                    if(!(dump_cent__1__3__1__1__1__3__1__1__1__8__rem >= 2))
                      goto hex_dump;

                    char *tmp_post_66 = dump_cent__1__3__1__1__1__3__1__1__1__8__q;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__q = dump_cent__1__3__1__1__1__3__1__1__1__8__q + 1l;
                    *tmp_post_66 = (char)34;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__rem = dump_cent__1__3__1__1__1__3__1__1__1__8__rem - 1;
                    unsigned char *tmp_post_67 = dump_cent__1__3__1__1__1__3__1__1__1__8__p;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__p = dump_cent__1__3__1__1__1__3__1__1__1__8__p + 1l;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__3__1__lb = (unsigned int)*tmp_post_67;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__n=escapestr((char *)dump_cent__1__3__1__1__1__3__1__1__1__8__p, (signed int)dump_cent__1__3__1__1__1__3__1__1__1__8__3__1__lb, dump_cent__1__3__1__1__1__3__1__1__1__8__q, dump_cent__1__3__1__1__1__3__1__1__1__8__rem);
                    if(2 + dump_cent__1__3__1__1__1__3__1__1__1__8__n >= dump_cent__1__3__1__1__1__3__1__1__1__8__rem || !(dump_cent__1__3__1__1__1__3__1__1__1__8__n >= 0))
                      goto hex_dump;

                    dump_cent__1__3__1__1__1__3__1__1__1__8__q = dump_cent__1__3__1__1__1__3__1__1__1__8__q + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__8__n;
                    char *tmp_post_68 = dump_cent__1__3__1__1__1__3__1__1__1__8__q;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__q = dump_cent__1__3__1__1__1__3__1__1__1__8__q + 1l;
                    *tmp_post_68 = (char)34;
                    char *tmp_post_69 = dump_cent__1__3__1__1__1__3__1__1__1__8__q;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__q = dump_cent__1__3__1__1__1__3__1__1__1__8__q + 1l;
                    *tmp_post_69 = (char)32;
                    dump_cent__1__3__1__1__1__3__1__1__1__8__rem = dump_cent__1__3__1__1__1__3__1__1__1__8__rem - (dump_cent__1__3__1__1__1__3__1__1__1__8__n + 2);
                    dump_cent__1__3__1__1__1__3__1__1__1__8__p = dump_cent__1__3__1__1__1__3__1__1__1__8__p + (signed long int)dump_cent__1__3__1__1__1__3__1__1__1__8__3__1__lb;
                  }
                  rhn2str(dump_cent__1__3__1__1__1__3__1__1__1__8__p, (unsigned char *)dump_cent__1__3__1__1__1__3__1__1__1__8__q, (unsigned int)dump_cent__1__3__1__1__1__3__1__1__1__8__rem);
                  break;
                }
                case 29:
                {
                  if(!(rr->rdlen == 16u))
                    goto hex_dump;

                  return_value_loc2str_70=loc2str((const void *)rr->data, dbuf, sizeof(char [1024l]) /*1024ul*/ );
                  if(return_value_loc2str_70 == ((const char *)NULL))
                    goto hex_dump;

                  break;
                }
                case 1:
                {
                  return_value_inet_ntop_71=inet_ntop(2, (const void *)rr->data, dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  if(return_value_inet_ntop_71 == ((const char *)NULL))
                    goto hex_dump;

                  break;
                }
                case 28:
                {
                  return_value_inet_ntop_72=inet_ntop(10, (const void *)rr->data, dbuf, (unsigned int)sizeof(char [1024l]) /*1024ul*/ );
                  if(!(return_value_inet_ntop_72 == ((const char *)NULL)))
                    break;

                }
                default:
                {

                hex_dump:
                  ;
                  hexdump((const void *)rr->data, (signed int)rr->rdlen, dbuf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
                }
              }
              signed int _retval;
              _retval=fsprintf(fd, "%s    %-7s %s\n", (const void *)tstr, rrnames[(signed long int)(tp - 1)], (const void *)dbuf);
              if(!(_retval >= 0))
                return _retval;

            }
          }
        }

      }
    }
    signed int dump_cent__1__4___retval;
    dump_cent__1__4___retval=fsprintf(fd, "\n");
    if(!(dump_cent__1__4___retval >= 0))
      return dump_cent__1__4___retval;

    else
      return 1;
  }
}

// empty_cache
// file cache.h line 162
signed int empty_cache(struct anonymous_8 *sla)
{
  signed int i;
  signed int return_value_timedlock_cache_rw_1;
  return_value_timedlock_cache_rw_1=timedlock_cache_rw(60);
  if(return_value_timedlock_cache_rw_1 == 0)
    return 0;

  else
  {
    i = 0;
    while((_Bool)1)
    {
      if(!(sla == ((struct anonymous_8 *)NULL)))
        free_dns_hash_selected(i, sla);

      else
        free_dns_hash_bucket(i);
      i = i + 1;
      if(i >= 1024)
        break;

      yield_lock_cache_rw();
    }
    unlock_cache_rw();
    return 1;
  }
}

// equiv_inaddr2
// file helpers.h line 149
static inline signed int equiv_inaddr2(union anonymous_6 *a, struct anonymous_15 *b)
{
  signed int tmp_if_expr_10;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_5;
  unsigned int return_value_htonl_4;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(!(run_ipv4 == 0))
    tmp_if_expr_10 = (signed int)(a->ipv4.s_addr == b->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a->ipv6) == *((unsigned int *)&b->ipv6))
      tmp_if_expr_1 = ((unsigned int *)&a->ipv6)[(signed long int)1] == ((unsigned int *)&b->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = ((unsigned int *)&a->ipv6)[(signed long int)2] == ((unsigned int *)&b->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = ((unsigned int *)&a->ipv6)[(signed long int)3] == ((unsigned int *)&b->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      if(!(b->ipv4.s_addr == 0u))
      {
        if(((unsigned int *)&a->ipv6)[3l] == b->ipv4.s_addr)
        {
          return_value_htonl_4=htonl((unsigned int)0xffff);
          tmp_if_expr_5 = ((unsigned int *)&a->ipv6)[(signed long int)2] == return_value_htonl_4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = ((unsigned int *)&a->ipv6)[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
          tmp_if_expr_7 = ((unsigned int *)&a->ipv6)[(signed long int)0] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_10 = (signed int)tmp_if_expr_9;
  }
  return tmp_if_expr_10;
}

// equiv_inaddr2_link1
// file helpers.h line 149
static inline signed int equiv_inaddr2_link1(union anonymous_6 *a_link1, struct anonymous_15 *b_link1)
{
  signed int tmp_if_expr_10_link1;
  _Bool tmp_if_expr_1_link1;
  _Bool tmp_if_expr_2_link1;
  _Bool tmp_if_expr_3_link1;
  _Bool tmp_if_expr_9_link1;
  _Bool tmp_if_expr_8_link1;
  _Bool tmp_if_expr_5_link1;
  unsigned int return_value_htonl_4_link1;
  _Bool tmp_if_expr_6_link1;
  _Bool tmp_if_expr_7_link1;
  if(!(run_ipv4 == 0))
    tmp_if_expr_10_link1 = (signed int)(a_link1->ipv4.s_addr == b_link1->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a_link1->ipv6) == *((unsigned int *)&b_link1->ipv6))
      tmp_if_expr_1_link1 = ((unsigned int *)&a_link1->ipv6)[(signed long int)1] == ((unsigned int *)&b_link1->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1_link1 = (_Bool)0;
    if(tmp_if_expr_1_link1)
      tmp_if_expr_2_link1 = ((unsigned int *)&a_link1->ipv6)[(signed long int)2] == ((unsigned int *)&b_link1->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link1 = (_Bool)0;
    if(tmp_if_expr_2_link1)
      tmp_if_expr_3_link1 = ((unsigned int *)&a_link1->ipv6)[(signed long int)3] == ((unsigned int *)&b_link1->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link1 = (_Bool)0;
    if(tmp_if_expr_3_link1)
      tmp_if_expr_9_link1 = (_Bool)1;

    else
    {
      if(!(b_link1->ipv4.s_addr == 0u))
      {
        if(((unsigned int *)&a_link1->ipv6)[3l] == b_link1->ipv4.s_addr)
        {
          return_value_htonl_4_link1=htonl((unsigned int)0xffff);
          tmp_if_expr_5_link1 = ((unsigned int *)&a_link1->ipv6)[(signed long int)2] == return_value_htonl_4_link1 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5_link1 = (_Bool)0;
        if(tmp_if_expr_5_link1)
          tmp_if_expr_6_link1 = ((unsigned int *)&a_link1->ipv6)[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6_link1 = (_Bool)0;
        if(tmp_if_expr_6_link1)
          tmp_if_expr_7_link1 = ((unsigned int *)&a_link1->ipv6)[(signed long int)0] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7_link1 = (_Bool)0;
        tmp_if_expr_8_link1 = tmp_if_expr_7_link1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8_link1 = (_Bool)0;
      tmp_if_expr_9_link1 = tmp_if_expr_8_link1 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_10_link1 = (signed int)tmp_if_expr_9_link1;
  }
  return tmp_if_expr_10_link1;
}

// equiv_inaddr2_link2
// file helpers.h line 149
static inline signed int equiv_inaddr2_link2(union anonymous_6 *a_link2, struct anonymous_15 *b_link2)
{
  signed int tmp_if_expr_10_link2;
  _Bool tmp_if_expr_1_link2;
  _Bool tmp_if_expr_2_link2;
  _Bool tmp_if_expr_3_link2;
  _Bool tmp_if_expr_9_link2;
  _Bool tmp_if_expr_8_link2;
  _Bool tmp_if_expr_5_link2;
  unsigned int return_value_htonl_4_link2;
  _Bool tmp_if_expr_6_link2;
  _Bool tmp_if_expr_7_link2;
  if(!(run_ipv4 == 0))
    tmp_if_expr_10_link2 = (signed int)(a_link2->ipv4.s_addr == b_link2->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a_link2->ipv6) == *((unsigned int *)&b_link2->ipv6))
      tmp_if_expr_1_link2 = ((unsigned int *)&a_link2->ipv6)[(signed long int)1] == ((unsigned int *)&b_link2->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1_link2 = (_Bool)0;
    if(tmp_if_expr_1_link2)
      tmp_if_expr_2_link2 = ((unsigned int *)&a_link2->ipv6)[(signed long int)2] == ((unsigned int *)&b_link2->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link2 = (_Bool)0;
    if(tmp_if_expr_2_link2)
      tmp_if_expr_3_link2 = ((unsigned int *)&a_link2->ipv6)[(signed long int)3] == ((unsigned int *)&b_link2->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link2 = (_Bool)0;
    if(tmp_if_expr_3_link2)
      tmp_if_expr_9_link2 = (_Bool)1;

    else
    {
      if(!(b_link2->ipv4.s_addr == 0u))
      {
        if(((unsigned int *)&a_link2->ipv6)[3l] == b_link2->ipv4.s_addr)
        {
          return_value_htonl_4_link2=htonl((unsigned int)0xffff);
          tmp_if_expr_5_link2 = ((unsigned int *)&a_link2->ipv6)[(signed long int)2] == return_value_htonl_4_link2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5_link2 = (_Bool)0;
        if(tmp_if_expr_5_link2)
          tmp_if_expr_6_link2 = ((unsigned int *)&a_link2->ipv6)[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6_link2 = (_Bool)0;
        if(tmp_if_expr_6_link2)
          tmp_if_expr_7_link2 = ((unsigned int *)&a_link2->ipv6)[(signed long int)0] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7_link2 = (_Bool)0;
        tmp_if_expr_8_link2 = tmp_if_expr_7_link2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8_link2 = (_Bool)0;
      tmp_if_expr_9_link2 = tmp_if_expr_8_link2 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_10_link2 = (signed int)tmp_if_expr_9_link2;
  }
  return tmp_if_expr_10_link2;
}

// escapestr
// file helpers.c line 583
signed int escapestr(const char *in, signed int ilen, char *str, signed int size)
{
  signed int i;
  signed int j = 0;
  i = 0;
  for( ; !(i >= ilen); i = i + 1)
  {
    unsigned char c;
    if(1 + j >= size)
      return -1;

    c = (unsigned char)in[(signed long int)i];
    const unsigned short int **return_value___ctype_b_loc_3;
    return_value___ctype_b_loc_3=__ctype_b_loc();
    if((16384 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)c]) == 0)
    {
      signed int rem = size - j;
      signed int n;
      n=snprintf(&str[(signed long int)j], (unsigned long int)rem, "\\%03o", c);
      if(n >= rem || !(n >= 0))
        return -1;

      j = j + n;
    }

    else
    {
      if((signed int)c == 34 || (signed int)c == 92)
      {
        signed int tmp_post_1 = j;
        j = j + 1;
        str[(signed long int)tmp_post_1] = (char)92;
        if(1 + j >= size)
          return -1;

      }

      signed int tmp_post_2 = j;
      j = j + 1;
      str[(signed long int)tmp_post_2] = (char)c;
    }
  }
  str[(signed long int)j] = (char)0;
  return j;
}

// exclusive_lock_server_data
// file servers.h line 43
signed int exclusive_lock_server_data(signed int tm)
{
  struct timeval now;
  struct timespec timeout;
  pthread_mutex_lock(&servers_lock);
  signed int return_value_pthread_equal_2;
  char *return_value_strerror_1;
  if(server_status_ping >= 1)
  {
    return_value_pthread_equal_2=pthread_equal(servstat_thrid, main_thrid);
    if(return_value_pthread_equal_2 == 0)
    {
      signed int err;
      if(!(debug_p == 0))
        debug_msg(0, "Sending server status thread an interrupt signal.\n");

      err=pthread_kill(servstat_thrid, 1);
      if(!(err == 0))
      {
        if(!(debug_p == 0))
        {
          return_value_strerror_1=strerror(err);
          debug_msg(0, "pthread_kill failed: %s\n", return_value_strerror_1);
        }

      }

    }

  }

  gettimeofday(&now, (struct timezone *)(void *)0);
  timeout.tv_sec = now.tv_sec + (signed long int)tm;
  timeout.tv_nsec = now.tv_usec * (signed long int)1000;
  while(server_data_users >= 1)
  {
    signed int return_value_pthread_cond_timedwait_3;
    return_value_pthread_cond_timedwait_3=pthread_cond_timedwait(&server_data_cond, &servers_lock, &timeout);
    if(return_value_pthread_cond_timedwait_3 == 110)
    {
      pthread_mutex_unlock(&servers_lock);
      return 0;
    }

  }
  return 1;
}

// exclusive_unlock_server_data
// file servers.h line 44
void exclusive_unlock_server_data(signed int retest)
{
  if(!(retest == 0))
  {
    signed int return_value_pthread_equal_1;
    return_value_pthread_equal_1=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal_1 == 0))
      start_servstat_thread();

    else
      pthread_cond_signal(&server_test_cond);
  }

  pthread_mutex_unlock(&servers_lock);
}

// fetch_first
// file hash.h line 76
struct anonymous_0 * fetch_first(struct anonymous_59 *pos)
{
  signed int i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    struct dns_hash_ent_s *he = hash_buckets[(signed long int)i];
    if(!(he == ((struct dns_hash_ent_s *)NULL)))
    {
      pos->bucket = i;
      pos->ent = he->next;
      return he->data;
    }

  }
  return (struct anonymous_0 *)(void *)0;
}

// fetch_next
// file hash.h line 77
struct anonymous_0 * fetch_next(struct anonymous_59 *pos)
{
  struct dns_hash_ent_s *he = pos->ent;
  signed int i;
  if(!(he == ((struct dns_hash_ent_s *)NULL)))
  {
    pos->ent = he->next;
    return he->data;
  }

  else
  {
    i = pos->bucket + 1;
    for( ; !(i >= 1024); i = i + 1)
    {
      he = hash_buckets[(signed long int)i];
      if(!(he == ((struct dns_hash_ent_s *)NULL)))
      {
        pos->bucket = i;
        pos->ent = he->next;
        return he->data;
      }

    }
    return (struct anonymous_0 *)(void *)0;
  }
}

// final_init
// file main.c line 179
signed int final_init()
{
  if(global.notcp == 0)
    tcp_socket=init_tcp_socket();

  udp_socket=init_udp_socket();
  if(tcp_socket == -1 && udp_socket == -1)
  {
    log_message(3, "tcp and udp initialization failed. Exiting.");
    return 0;
  }

  else
  {
    if(!(global.strict_suid == 0))
    {
      signed int return_value_run_as_1;
      return_value_run_as_1=run_as(global.run_as);
      if(return_value_run_as_1 == 0)
        return 0;

    }

    return 1;
  }
}

// flags2str
// file cache.h line 119
char * flags2str(unsigned int flags, char *buf, signed int nflags, const char *flgnames)
{
  char *p = buf;
  signed int i;
  signed int nflgchars = 3 * nflags;
  i = 0;
  for( ; !(i >= nflgchars); i = i + 3)
  {
    if(!((1u & flags) == 0u))
    {
      if(!(buf >= p))
      {
        char *tmp_post_1 = p;
        p = p + 1l;
        *tmp_post_1 = (char)124;
      }

      void *return_value_mempcpy_2;
      return_value_mempcpy_2=mempcpy((void *)p, (const void *)&flgnames[(signed long int)i], (unsigned long int)3);
      p = (char *)return_value_mempcpy_2;
    }

    flags = flags >> 1;
  }
  if(p == buf)
  {
    char *tmp_post_3 = p;
    p = p + 1l;
    *tmp_post_3 = (char)48;
  }

  *p = (char)0;
  return buf;
}

// follow_cname_chain
// file dns_answer.c line 188
static inline signed int follow_cname_chain(struct anonymous_0 *c, unsigned char *name)
{
  struct anonymous *rrset;
  struct anonymous *tmp_if_expr_1;
  if((1 & (signed int)c->flags) == 0)
    tmp_if_expr_1 = c->_anon0.rr.rrmu[(signed long int)2];

  else
    tmp_if_expr_1 = (struct anonymous *)(void *)0;
  rrset = tmp_if_expr_1;
  struct rr_b_s *rr;
  _Bool tmp_if_expr_2;
  if(rrset == ((struct anonymous *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    rr = rrset->rrs;
    tmp_if_expr_2 = !(rr != ((struct rr_b_s *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return 0;

  else
  {
    if(rr->rdlen >= 257u)
    {
      log_message(3, "%s:%d: %s", (const void *)"dns_answer.c", 194, (const void *)"follow_cname_chain: record too long");
      pdnsd_exit();
    }

    memcpy((void *)name, (const void *)rr->data, (unsigned long int)rr->rdlen);
    return 1;
  }
}

// free_cent
// file cache.h line 203
void free_cent(struct anonymous_0 *cent)
{
  free((void *)cent->qname);
  if(!((1 & (signed int)cent->flags) == 0))
  {
    if(!(cent->_anon0.neg.lent == ((struct rr_lent_s *)NULL)))
      remove_rrl(cent->_anon0.neg.lent);

  }

  else
  {
    signed int i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      struct anonymous *free_cent__1__3__1__1__rrs = cent->_anon0.rr.rrmu[(signed long int)i];
      if(!(free_cent__1__3__1__1__rrs == ((struct anonymous *)NULL)))
        del_rrset(free_cent__1__3__1__1__rrs);

    }
    struct anonymous **rrext = cent->_anon0.rr.rrext;
    if(!(rrext == ((struct anonymous **)NULL)))
    {
      i = 0;
      for( ; !(i >= 39); i = i + 1)
      {
        struct anonymous *rrs = rrext[(signed long int)i];
        if(!(rrs == ((struct anonymous *)NULL)))
          del_rrset(rrs);

      }
      free((void *)rrext);
    }

  }
}

// free_cent0
// file cache.h line 204
void free_cent0(void *ptr)
{
  free_cent((struct anonymous_0 *)ptr);
}

// free_dns_hash
// file hash.h line 74
void free_dns_hash()
{
  signed int i;
  struct dns_hash_ent_s *he;
  struct dns_hash_ent_s *hen;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    he = hash_buckets[(signed long int)i];
    hash_buckets[(signed long int)i] = (struct dns_hash_ent_s *)(void *)0;
    for( ; !(he == ((struct dns_hash_ent_s *)NULL)); he = hen)
    {
      hen = he->next;
      del_cent(he->data);
      free((void *)he);
    }
  }
}

// free_dns_hash_bucket
// file hash.h line 72
void free_dns_hash_bucket(signed int i)
{
  struct dns_hash_ent_s *he;
  struct dns_hash_ent_s *hen;
  he = hash_buckets[(signed long int)i];
  hash_buckets[(signed long int)i] = (struct dns_hash_ent_s *)(void *)0;
  for( ; !(he == ((struct dns_hash_ent_s *)NULL)); he = hen)
  {
    hen = he->next;
    del_cent(he->data);
    free((void *)he);
  }
}

// free_dns_hash_selected
// file hash.h line 73
void free_dns_hash_selected(signed int i, struct anonymous_8 *sla)
{
  struct dns_hash_ent_s **hep;
  struct dns_hash_ent_s *he;
  struct dns_hash_ent_s *hen;
  signed int j;
  signed int m;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link6((struct anonymous_3 *)sla);
  m = (signed int)return_value_da_nel_1;
  hep = &hash_buckets[(signed long int)i];
  he = *hep;
  while(!(he == ((struct dns_hash_ent_s *)NULL)))
  {
    unsigned char *name = he->data->qname;
    j = 0;
    for( ; !(j >= m); j = j + 1)
    {
      struct anonymous_9 *sl = &sla->elem[(signed long int)j];
      unsigned int nrem;
      unsigned int lrem;
      domain_match(name, sl->domain, &nrem, &lrem);
      if(lrem == 0u)
      {
        if(sl->exact == 0 || nrem == 0u)
        {
          if((signed int)sl->rule == 18)
            goto delete_entry;

          else
            break;
        }

      }

    }
    hep = &he->next;
    he = *hep;
    continue;

  delete_entry:
    ;
    hen = he->next;
    *hep = hen;
    del_cent(he->data);
    free((void *)he);
    he = hen;
  }
}

// free_rejectlist
// file dns_query.c line 2892
static inline void free_rejectlist(struct rejectlist_s *rl)
{
  while(!(rl == ((struct rejectlist_s *)NULL)))
  {
    struct rejectlist_s *next = rl->next;
    free((void *)rl);
    rl = next;
  }
}

// free_server_data
// file conff.c line 390
static void free_server_data(struct anonymous_18 *sa)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link1((struct anonymous_3 *)sa);
  n = (signed int)return_value_da_nel_1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
    free_servparm(&sa->elem[(signed long int)i]);
  free((void *)sa);
}

// free_servparm
// file conff.h line 187
void free_servparm(struct anonymous_7 *serv)
{
  free((void *)serv->uptest_cmd);
  free((void *)serv->query_test_name);
  free((void *)serv->label);
  free((void *)serv->atup_a);
  free_slist_array(serv->alist);
  free((void *)serv->reject_a4);
  free((void *)serv->reject_a6);
}

// free_slist_array
// file conff.c line 368
void free_slist_array(struct anonymous_8 *sla)
{
  signed int j;
  signed int m;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link1((struct anonymous_3 *)sla);
  m = (signed int)return_value_da_nel_1;
  j = 0;
  for( ; !(j >= m); j = j + 1)
    free((void *)sla->elem[(signed long int)j].domain);
  free((void *)sla);
}

// free_slist_domain
// file conff.h line 185
void free_slist_domain(void *ptr)
{
  free((void *)((struct anonymous_9 *)ptr)->domain);
}

// free_zone
// file conff.h line 184
void free_zone(void *ptr)
{
  free((void *)*((unsigned char **)ptr));
}

// free_zones
// file conff.c line 354
static void free_zones(struct anonymous_30 *za)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link1((struct anonymous_3 *)za);
  n = (signed int)return_value_da_nel_1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
    free((void *)za->elem[(signed long int)i]);
  free((void *)za);
}

// fsprintf
// file helpers.h line 170
signed int fsprintf(signed int fd, const char *format, ...)
{
  signed int n;
  void **va;
  char buf[256l];
  va = (void **)&format;
  n=vsnprintf(buf, sizeof(char [256l]) /*256ul*/ , format, va);
  va = ((void **)NULL);
  signed long int return_value_write_all_1;
  if(!(n >= (signed int)sizeof(char [256l]) /*256*/ ))
  {
    if(n >= 1)
    {
      return_value_write_all_1=write_all_link1(fd, (const void *)buf, (unsigned long int)n);
      n = (signed int)return_value_write_all_1;
    }

    return n;
  }

  unsigned int bufsize = (unsigned int)(n + 1);
  const signed long int bufsize_array_size0 = (signed long int)bufsize;
  char fsprintf__1__2__buf[bufsize_array_size0];
  va = (void **)&format;
  n=vsnprintf(fsprintf__1__2__buf, (unsigned long int)bufsize, format, va);
  va = ((void **)NULL);
  signed long int return_value_write_all_2;
  if(n >= 1)
  {
    return_value_write_all_2=write_all_link1(fd, (const void *)fsprintf__1__2__buf, (unsigned long int)n);
    n = (signed int)return_value_write_all_2;
  }

  return n;
}

// get_cname
// file dns.c line 492
const char * get_cname(signed int id)
{
  if(id >= 1 && !(id >= 5))
    return c_names[(signed long int)(id - 1)];

  else
    if(id == 255)
      return "*";

    else
      return "[unknown]";
}

// get_ename
// file dns.c line 532
const char * get_ename(signed int id)
{
  if(id >= 0 && !(id >= 17))
    return e_names[(signed long int)id];

  else
    return "[unknown]";
}

// get_rand16
// file helpers.h line 168
unsigned short int get_rand16(void)
{
  signed long int return_value_random_1;
  return_value_random_1=random();
  return (unsigned short int)(return_value_random_1 & (signed long int)0xffff);
}

// get_rrlent_ts
// file cache.c line 880
static inline signed long int get_rrlent_ts(struct rr_lent_s *le)
{
  signed long int tmp_if_expr_1;
  if(!(le->rrset == ((struct anonymous *)NULL)))
    tmp_if_expr_1 = le->rrset->ts;

  else
    tmp_if_expr_1 = le->cent->_anon0.neg.ts;
  return tmp_if_expr_1;
}

// get_tname
// file dns.c line 501
const char * get_tname(signed int id)
{
  if(id >= 1 && !(id >= 52))
    return rrnames[(signed long int)(id - 1)];

  else
    if(id >= 251 && !(id >= 256))
      return qt_names[(signed long int)(id - 251)];

  return "[unknown]";
}

// getlocalowner
// file cache.h line 178
unsigned char * getlocalowner(unsigned char *name, signed int tp)
{
  unsigned char *ret = (unsigned char *)(void *)0;
  struct anonymous_0 *ce;
  unsigned int lb;
  lock_cache_r();
  lb = (unsigned int)*name;
  if(!(lb == 0u))
    do
    {
      name = name + (signed long int)(lb + (unsigned int)1);
      lb = (unsigned int)*name;
      if(lb == 0u)
        break;

      ce=dns_lookup(name, (struct anonymous_58 *)(void *)0);
      if(!(ce == ((struct anonymous_0 *)NULL)))
      {
        if((2 & (signed int)ce->flags) == 0)
          break;

        signed int return_value_have_rr_1;
        return_value_have_rr_1=have_rr_link2(ce, tp);
        if(!(return_value_have_rr_1 == 0))
        {
          ret = name;
          break;
        }

      }

    }
    while((_Bool)1);

  unlock_cache_r();
  return ret;
}

// getnextp
// file conf-parser.c line 84
static char * getnextp(char **buf, unsigned long int *n, struct _IO_FILE *in, char *p, unsigned int *linenr, char **errstr)
{
  if(!(p == ((char *)NULL)))
  {

  tryagain:
    ;
    if(!(*p == 0))
      goto __CPROVER_DUMP_L6;

  }

  signed long int return_value_getline_1;
  do
  {

  nextline:
    ;
    _Bool tmp_if_expr_2;
    if(in == ((struct _IO_FILE *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_getline_1=getline(buf, n, in);
      tmp_if_expr_2 = return_value_getline_1 < (signed long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
    {
      *errstr = (char *)(void *)0;
      return (char *)(void *)0;
    }

    *linenr = *linenr + 1u;
    p = *buf;
  }
  while(*p == 0);

__CPROVER_DUMP_L6:
  ;
  const unsigned short int **return_value___ctype_b_loc_3;
  return_value___ctype_b_loc_3=__ctype_b_loc();
  if(!((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*p]) == 0))
  {
    p = p + 1l;
    goto tryagain;
  }

  if((signed int)*p == 35)
  {

  skip_rest_of_line:
    ;
    if(!(*linenr == 0u))
      goto nextline;

    else
    {
      p=strchr(p, 10);
      if(!(p == ((char *)NULL)))
      {
        p = p + 1l;
        goto tryagain;
      }

      else
        goto nextline;
    }
  }

  signed long int return_value_getline_5;
  if((signed int)*p == 47)
  {
    if((signed int)p[1l] == 47)
      goto skip_rest_of_line;

    if((signed int)p[1l] == 42)
    {
      signed int lev = 1;
      p = p + (signed long int)2;

    __CPROVER_DUMP_L12:
      ;
      while((_Bool)1)
      {
        if(!(*p == 0))
        {
          _Bool tmp_if_expr_4;
          if((signed int)*p == 47)
            tmp_if_expr_4 = (signed int)p[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            lev = lev + 1;
            p = p + (signed long int)2;
            goto __CPROVER_DUMP_L17;
          }

          else
            if((signed int)*p == 42)
            {
              if((signed int)p[1l] == 47)
              {
                p = p + (signed long int)2;
                lev = lev - 1;
                if(lev == 0)
                  goto tryagain;

                goto __CPROVER_DUMP_L17;
              }

            }

          p = p + 1l;

        __CPROVER_DUMP_L17:
          ;
          goto __CPROVER_DUMP_L12;
        }

        _Bool tmp_if_expr_6;
        if(in == ((struct _IO_FILE *)NULL))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_getline_5=getline(buf, n, in);
          tmp_if_expr_6 = return_value_getline_5 < (signed long int)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
        {
          *errstr = "comment without closing */";
          return (char *)(void *)0;
        }

        *linenr = *linenr + 1u;
        p = *buf;
      }
    }

  }

  return p;
}

// getrrset
// file cache.h line 221
static inline struct anonymous * getrrset(struct anonymous_0 *cent, signed int type)
{
  if((1 & (signed int)cent->flags) == 0)
  {
    signed int tpi = type - 1;
    if(tpi >= 0 && !(tpi >= 51))
    {
      unsigned int idx = (unsigned int)rrlkuptab[(signed long int)tpi];
      if(!(idx >= 8u))
        return cent->_anon0.rr.rrmu[(signed long int)idx];

      else
      {
        idx = idx - (unsigned int)8;
        if(!(idx >= 39u))
        {
          struct anonymous **rrext = cent->_anon0.rr.rrext;
          if(!(rrext == ((struct anonymous **)NULL)))
            return rrext[(signed long int)idx];

        }

      }
    }

  }

  return (struct anonymous *)(void *)0;
}

// getrrset_link1
// file cache.h line 221
static inline struct anonymous * getrrset_link1(struct anonymous_0 *cent_link1, signed int type_link1)
{
  if((1 & (signed int)cent_link1->flags) == 0)
  {
    signed int tpi_link1 = type_link1 - 1;
    if(tpi_link1 >= 0 && !(tpi_link1 >= 51))
    {
      unsigned int idx_link1 = (unsigned int)rrlkuptab[(signed long int)tpi_link1];
      if(!(idx_link1 >= 8u))
        return cent_link1->_anon0.rr.rrmu[(signed long int)idx_link1];

      else
      {
        idx_link1 = idx_link1 - (unsigned int)8;
        if(!(idx_link1 >= 39u))
        {
          struct anonymous **rrext_link1 = cent_link1->_anon0.rr.rrext;
          if(!(rrext_link1 == ((struct anonymous **)NULL)))
            return rrext_link1[(signed long int)idx_link1];

        }

      }
    }

  }

  return (struct anonymous *)(void *)0;
}

// getrrset_link2
// file cache.h line 221
static inline struct anonymous * getrrset_link2(struct anonymous_0 *cent_link2, signed int type_link2)
{
  if((1 & (signed int)cent_link2->flags) == 0)
  {
    signed int tpi_link2 = type_link2 - 1;
    if(tpi_link2 >= 0 && !(tpi_link2 >= 51))
    {
      unsigned int idx_link2 = (unsigned int)rrlkuptab[(signed long int)tpi_link2];
      if(!(idx_link2 >= 8u))
        return cent_link2->_anon0.rr.rrmu[(signed long int)idx_link2];

      else
      {
        idx_link2 = idx_link2 - (unsigned int)8;
        if(!(idx_link2 >= 39u))
        {
          struct anonymous **rrext_link2 = cent_link2->_anon0.rr.rrext;
          if(!(rrext_link2 == ((struct anonymous **)NULL)))
            return rrext_link2[(signed long int)idx_link2];

        }

      }
    }

  }

  return (struct anonymous *)(void *)0;
}

// getrrset_eff
// file cache.h line 251
static inline struct anonymous * getrrset_eff(struct anonymous_0 *cent, signed int type)
{
  unsigned int idx = (unsigned int)rrlkuptab[(signed long int)(type - 1)];
  if(!(idx >= 8u))
    return cent->_anon0.rr.rrmu[(signed long int)idx];

  else
  {
    idx = idx - (unsigned int)8;
    if(!(idx >= 39u))
    {
      struct anonymous **rrext = cent->_anon0.rr.rrext;
      if(!(rrext == ((struct anonymous **)NULL)))
        return rrext[(signed long int)idx];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrset_eff_link1
// file cache.h line 251
static inline struct anonymous * getrrset_eff_link1(struct anonymous_0 *cent_link1, signed int type_link1)
{
  unsigned int idx_link1 = (unsigned int)rrlkuptab[(signed long int)(type_link1 - 1)];
  if(!(idx_link1 >= 8u))
    return cent_link1->_anon0.rr.rrmu[(signed long int)idx_link1];

  else
  {
    idx_link1 = idx_link1 - (unsigned int)8;
    if(!(idx_link1 >= 39u))
    {
      struct anonymous **rrext_link1 = cent_link1->_anon0.rr.rrext;
      if(!(rrext_link1 == ((struct anonymous **)NULL)))
        return rrext_link1[(signed long int)idx_link1];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrset_eff_link2
// file cache.h line 251
static inline struct anonymous * getrrset_eff_link2(struct anonymous_0 *cent_link2, signed int type_link2)
{
  unsigned int idx_link2 = (unsigned int)rrlkuptab[(signed long int)(type_link2 - 1)];
  if(!(idx_link2 >= 8u))
    return cent_link2->_anon0.rr.rrmu[(signed long int)idx_link2];

  else
  {
    idx_link2 = idx_link2 - (unsigned int)8;
    if(!(idx_link2 >= 39u))
    {
      struct anonymous **rrext_link2 = cent_link2->_anon0.rr.rrext;
      if(!(rrext_link2 == ((struct anonymous **)NULL)))
        return rrext_link2[(signed long int)idx_link2];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrset_eff_link3
// file cache.h line 251
static inline struct anonymous * getrrset_eff_link3(struct anonymous_0 *cent_link3, signed int type_link3)
{
  unsigned int idx_link3 = (unsigned int)rrlkuptab[(signed long int)(type_link3 - 1)];
  if(!(idx_link3 >= 8u))
    return cent_link3->_anon0.rr.rrmu[(signed long int)idx_link3];

  else
  {
    idx_link3 = idx_link3 - (unsigned int)8;
    if(!(idx_link3 >= 39u))
    {
      struct anonymous **rrext_link3 = cent_link3->_anon0.rr.rrext;
      if(!(rrext_link3 == ((struct anonymous **)NULL)))
        return rrext_link3[(signed long int)idx_link3];

    }

  }
  return (struct anonymous *)(void *)0;
}

// getrrtpname
// file dns.c line 480
const char * getrrtpname(signed int tp)
{
  const char *tmp_if_expr_1;
  if(tp >= 1 && !(tp >= 52))
    tmp_if_expr_1 = rrnames[(signed long int)(tp - 1)];

  else
    tmp_if_expr_1 = "[unknown]";
  return tmp_if_expr_1;
}

// have_rr
// file cache.h line 274
static inline signed int have_rr(struct anonymous_0 *cent, signed int type)
{
  struct anonymous *rrset;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)cent->flags) == 0)
  {
    rrset=getrrset_eff_link1(cent, type);
    tmp_if_expr_1 = rrset != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// have_rr_link1
// file cache.h line 274
static inline signed int have_rr_link1(struct anonymous_0 *cent_link1, signed int type_link1)
{
  struct anonymous *rrset_link1;
  _Bool tmp_if_expr_1_link1;
  if((1 & (signed int)cent_link1->flags) == 0)
  {
    rrset_link1=getrrset_eff_link2(cent_link1, type_link1);
    tmp_if_expr_1_link1 = rrset_link1 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1_link1 = (_Bool)0;
  _Bool tmp_if_expr_2_link1;
  if(tmp_if_expr_1_link1)
    tmp_if_expr_2_link1 = rrset_link1->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2_link1 = (_Bool)0;
  return (signed int)tmp_if_expr_2_link1;
}

// have_rr_link2
// file cache.h line 274
static inline signed int have_rr_link2(struct anonymous_0 *cent_link2, signed int type_link2)
{
  struct anonymous *rrset_link2;
  _Bool tmp_if_expr_1_link2;
  if((1 & (signed int)cent_link2->flags) == 0)
  {
    rrset_link2=getrrset_eff_link3(cent_link2, type_link2);
    tmp_if_expr_1_link2 = rrset_link2 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1_link2 = (_Bool)0;
  _Bool tmp_if_expr_2_link2;
  if(tmp_if_expr_1_link2)
    tmp_if_expr_2_link2 = rrset_link2->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2_link2 = (_Bool)0;
  return (signed int)tmp_if_expr_2_link2;
}

// hexdump
// file helpers.c line 546
void hexdump(const void *data, signed int dlen, char *buf, signed int buflen)
{
  const unsigned char *p = (const unsigned char *)data;
  signed int i;
  signed int j = 0;
  i = 0;
  for( ; !(i >= dlen); i = i + 1)
  {
    signed int rem = buflen - j;
    signed int n;
    n=snprintf(buf + (signed long int)j, (unsigned long int)rem, i == 0 ? "%02x" : " %02x", p[(signed long int)i]);
    if(n >= rem || !(n >= 0))
      goto truncated;

    j = j + n;
  }
  goto done;

truncated:
  ;
  if(j >= 6)
  {
    j = j - 3;
    if(4 + j >= buflen)
      j = j - 3;

    signed int tmp_post_1 = j;
    j = j + 1;
    buf[(signed long int)tmp_post_1] = (char)32;
    signed int tmp_post_2 = j;
    j = j + 1;
    buf[(signed long int)tmp_post_2] = (char)46;
    signed int tmp_post_3 = j;
    j = j + 1;
    buf[(signed long int)tmp_post_3] = (char)46;
    signed int tmp_post_4 = j;
    j = j + 1;
    buf[(signed long int)tmp_post_4] = (char)46;
  }

  else
  {
    signed int ndots = buflen - 1;
    if(ndots >= 4)
      ndots = 3;

    j = 0;
    while(!(j >= ndots))
    {
      signed int tmp_post_5 = j;
      j = j + 1;
      buf[(signed long int)tmp_post_5] = (char)46;
    }
  }

done:
  ;
  buf[(signed long int)j] = (char)0;
}

// icmp4_errcmp
// file icmp.c line 136
static signed int icmp4_errcmp(char *packet, signed int plen, struct in_addr *to, char *errmsg, signed int elen, signed int errtype)
{
  struct iphdr iph;
  struct icmphdr icmph;
  struct iphdr eiph;
  char *data;
  signed int return_value_memcmp_1;
  signed int return_value_memcmp_3;
  if(!((unsigned long int)elen >= sizeof(struct iphdr) /*20ul*/ ))
    return 0;

  else
  {
    memcpy((void *)&iph, (const void *)errmsg, sizeof(struct iphdr) /*20ul*/ );
    if(!((signed int)iph.protocol == 1) || !((unsigned long int)elen >= sizeof(struct iphdr) /*20ul*/  + (unsigned long int)(4 * (signed int)iph.ihl + 8)))
      return 0;

    else
    {
      memcpy((void *)&icmph, (const void *)(errmsg + (signed long int)((signed int)iph.ihl * 4)), (unsigned long int)8);
      memcpy((void *)&eiph, (const void *)(errmsg + (signed long int)((signed int)iph.ihl * 4) + (signed long int)8), sizeof(struct iphdr) /*20ul*/ );
      if(!(elen >= 4 * (signed int)eiph.ihl + 4 * (signed int)iph.ihl + 8))
        return 0;

      else
      {
        data = errmsg + (signed long int)((signed int)iph.ihl * 4) + (signed long int)8 + (signed long int)((signed int)eiph.ihl * 4);
        _Bool tmp_if_expr_2;
        if((signed int)icmph.type == errtype)
        {
          return_value_memcmp_1=memcmp((const void *)&to->s_addr, (const void *)&eiph.daddr, sizeof(unsigned int) /*4ul*/ );
          tmp_if_expr_2 = return_value_memcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_2 = (_Bool)0;
        _Bool tmp_if_expr_4;
        if(tmp_if_expr_2)
        {
          return_value_memcmp_3=memcmp((const void *)data, (const void *)packet, (unsigned long int)(plen < 8 ? plen : 8));
          tmp_if_expr_4 = return_value_memcmp_3 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        return (signed int)tmp_if_expr_4;
      }
    }
  }
}

// icmp6_errcmp
// file icmp.c line 330
static signed int icmp6_errcmp(char *packet, signed int plen, struct in6_addr *to, char *errmsg, signed int elen, signed int errtype)
{
  struct icmp6_hdr icmph;
  struct ip6_hdr eiph;
  struct ip6_hbh hbh;
  char *data;
  signed int rlen;
  signed int nxt;
  signed int return_value_memcmp_4;
  if(!((unsigned long int)elen >= sizeof(struct icmp6_hdr) * 6 /*48ul*/ ))
    return 0;

  else
  {
    memcpy((void *)&icmph, (const void *)errmsg, sizeof(struct icmp6_hdr) /*8ul*/ );
    memcpy((void *)&eiph, (const void *)(errmsg + (signed long int)sizeof(struct icmp6_hdr) /*8ul*/ ), sizeof(struct ip6_hdr) /*40ul*/ );
    _Bool tmp_if_expr_1;
    if(*((unsigned int *)&eiph.ip6_dst) == *((unsigned int *)to))
      tmp_if_expr_1 = ((unsigned int *)&eiph.ip6_dst)[(signed long int)1] == ((unsigned int *)to)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    _Bool tmp_if_expr_2;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = ((unsigned int *)&eiph.ip6_dst)[(signed long int)2] == ((unsigned int *)to)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = ((unsigned int *)&eiph.ip6_dst)[(signed long int)3] == ((unsigned int *)to)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      return 0;

    else
    {
      rlen = (signed int)(((unsigned long int)elen - sizeof(struct icmp6_hdr) /*8ul*/ ) - sizeof(struct ip6_hdr) /*40ul*/ );
      data = errmsg + (signed long int)sizeof(struct icmp6_hdr) /*8ul*/  + (signed long int)sizeof(struct ip6_hdr) /*40ul*/ ;
      nxt = (signed int)eiph.ip6_ctlun.ip6_un1.ip6_un1_nxt;
      for( ; !(nxt == 58); data = data + (signed long int)hbh.ip6h_len)
      {
        if(!(nxt == 0) && !(nxt == 43) && !(nxt == 60))
          return 0;

        if(!((unsigned long int)rlen >= sizeof(struct ip6_hbh) /*2ul*/ ))
          return 0;

        memcpy((void *)&hbh, (const void *)data, sizeof(struct ip6_hbh) /*2ul*/ );
        if(!(rlen >= (signed int)hbh.ip6h_len))
          return 0;

        rlen = rlen - (signed int)hbh.ip6h_len;
        nxt = (signed int)hbh.ip6h_nxt;
      }
      if(!((unsigned long int)rlen >= sizeof(struct icmp6_hdr) /*8ul*/ ))
        return 0;

      else
      {
        memset((void *)((char *)data + (signed long int)2ul), 0, sizeof(unsigned short int) /*2ul*/ );
        _Bool tmp_if_expr_5;
        if((signed int)icmph.icmp6_type == errtype)
        {
          return_value_memcmp_4=memcmp((const void *)data, (const void *)packet, (unsigned long int)(plen < rlen ? plen : rlen));
          tmp_if_expr_5 = return_value_memcmp_4 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5 = (_Bool)0;
        return (signed int)tmp_if_expr_5;
      }
    }
  }
}

// if_up
// file netdev.c line 186
signed int if_up(char *devname)
{
  signed int sock;
  struct ifreq ifr;
  unsigned int devnamelen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(devname);
  devnamelen = (unsigned int)return_value_strlen_1;
  signed int return_value_strncmp_3;
  if(devnamelen >= 5u && !(devnamelen >= 7u))
  {
    return_value_strncmp_3=strncmp(devname, "ippp", (unsigned long int)4);
    if(return_value_strncmp_3 == 0)
    {
      signed int return_value_statusif_2;
      return_value_statusif_2=statusif(devname);
      return return_value_statusif_2;
    }

  }

  sock=socket(2, 2, 17);
  if(sock == -1)
  {
    socketopen_errs = socketopen_errs + 1ul;
    if(!(socketopen_errs >= 11ul))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_message(4, "Could not open socket in if_up(): %s", return_value_strerror_5);
    }

    return 0;
  }

  else
  {
    strncp_link2(ifr.ifr_ifrn.ifrn_name, devname, (unsigned long int)16);
    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(sock, (unsigned long int)0x8913, &ifr);
    if(return_value_ioctl_6 == -1)
    {
      close(sock);
      return 0;
    }

    else
    {
      close(sock);
      return (signed int)(((signed int)ifr.ifr_ifru.ifru_flags & 1) != 0 && ((signed int)ifr.ifr_ifru.ifru_flags & 64) != 0);
    }
  }
}

// init_cache_lock
// file cache.h line 157
static inline void init_cache_lock()
{
  use_cache_lock = (volatile signed short int)1;
}

// init_cent
// file cache.h line 199
signed int init_cent(struct anonymous_0 *cent, const unsigned char *qname, signed long int ttl, signed long int ts, unsigned int flags)
{
  signed int i;
  unsigned long int namesz;
  unsigned int return_value_rhnlen_1;
  return_value_rhnlen_1=rhnlen_link6(qname);
  namesz = (unsigned long int)return_value_rhnlen_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(namesz);
  cent->qname = (unsigned char *)return_value_malloc_2;
  if(cent->qname == ((unsigned char *)NULL))
    return 0;

  else
  {
    memcpy((void *)cent->qname, (const void *)qname, namesz);
    cent->cs = sizeof(struct anonymous_0) /*104ul*/  + namesz;
    cent->num_rrs = (unsigned short int)0;
    cent->flags = (unsigned short int)flags;
    if(!((1u & flags) == 0u))
    {
      cent->_anon0.neg.lent = (struct rr_lent_s *)(void *)0;
      cent->_anon0.neg.ttl = ttl;
      cent->_anon0.neg.ts = ts;
    }

    else
    {
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        cent->_anon0.rr.rrmu[(signed long int)i] = (struct anonymous *)(void *)0;
      cent->_anon0.rr.rrext = (struct anonymous **)(void *)0;
    }
    cent->c_ns = (unsigned char)0xff;
    cent->c_soa = (unsigned char)0xff;
    return 1;
  }
}

// init_crandom
// file helpers.c line 447
void init_crandom()
{
  struct timeval tv;
  struct timezone tz;
  gettimeofday(&tv, &tz);
  srandom((unsigned int)(tv.tv_sec ^ tv.tv_usec));
}

// init_log_lock
// file error.h line 45
static inline void init_log_lock(void)
{
  use_log_lock = (volatile signed short int)1;
}

// init_ping_socket
// file icmp.c line 114
void init_ping_socket(void)
{
  ping_isocket=socket(2, 3, 1);
  if(ping_isocket == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_message(4, "icmp ping: socket() failed: %s", return_value_strerror_2);
  }

  if(run_ipv4 == 0)
  {
    ping6_isocket=socket(10, 3, 58);
    if(ping6_isocket == -1)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      log_message(4, "icmpv6 ping: socket() failed: %s", return_value_strerror_4);
    }

  }

}

// init_rng
// file helpers.c line 458
signed int init_rng(void)
{
  init_crandom();
  return 1;
}

// init_stat_sock
// file status.h line 56
void init_stat_sock(void)
{
  struct sockaddr_un *sa;
  unsigned int sa_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(global.cache_dir);
  sa_len = (unsigned int)(2ul + (sizeof(char [14l]) /*14ul*/  - (unsigned long int)1) + return_value_strlen_1);
  void *return_value___builtin_alloca_2;
  return_value___builtin_alloca_2=__builtin_alloca((unsigned long int)(sa_len + (unsigned int)1));
  sa = (struct sockaddr_un *)return_value___builtin_alloca_2;
  char *return_value_stpcpy_3;
  return_value_stpcpy_3=stpcpy(sa->sun_path, global.cache_dir);
  stpcpy(return_value_stpcpy_3, "/pdnsd.status");
  signed int return_value_unlink_7;
  return_value_unlink_7=unlink(sa->sun_path);
  signed int *return_value___errno_location_6;
  if(!(return_value_unlink_7 == 0))
  {
    return_value___errno_location_6=__errno_location();
    if(!(*return_value___errno_location_6 == 2))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_message(4, "Failed to unlink %s: %s.\nStatus readback will be disabled", (const void *)sa->sun_path, return_value_strerror_5);
      stat_pipe = (signed short int)0;
      goto __CPROVER_DUMP_L6;
    }

  }

  stat_sock=socket(1, 1, 0);
  if(stat_sock == -1)
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    log_message(4, "Failed to open socket: %s. Status readback will be impossible", return_value_strerror_9);
    stat_pipe = (signed short int)0;
    goto __CPROVER_DUMP_L6;
  }

  sa->sun_family = (unsigned short int)1;
  unsigned int old_mask;
  old_mask=umask((unsigned int)((0400 | 0200 | 0100 | (0400 | 0200 | 0100) >> 3 | ((0400 | 0200 | 0100) >> 3) >> 3) & ~global.ctl_perms));
  signed int return_value_bind_12;
  return_value_bind_12=bind(stat_sock, (struct sockaddr *)sa, sa_len);
  if(return_value_bind_12 == -1)
  {
    signed int *return_value___errno_location_10;
    return_value___errno_location_10=__errno_location();
    char *return_value_strerror_11;
    return_value_strerror_11=strerror(*return_value___errno_location_10);
    log_message(4, "Error: could not bind socket: %s.\nStatus readback will be impossible", return_value_strerror_11);
    close(stat_sock);
    stat_pipe = (signed short int)0;
  }

  umask(old_mask);
  if(!(stat_pipe == 0))
    sock_path=strdup(sa->sun_path);


__CPROVER_DUMP_L6:
  ;
}

// init_tcp_socket
// file dns_answer.c line 1967
signed int init_tcp_socket(void)
{
  signed int sock;
  /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'sin4'|lSYM#tag-sockaddr_in6#'sin6'] */
union anonymous_22
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

/* */
  ;
  union anonymous_22 sin;
  unsigned int sinl;
  if(!(run_ipv4 == 0))
  {
    sock=socket(2, 1, 6);
    if(sock == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_message(3, "Could not open tcp socket: %s", return_value_strerror_2);
      return -1;
    }

    memset((void *)&sin.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    sin.sin4.sin_family = (unsigned short int)2;
    sin.sin4.sin_port=htons((unsigned short int)global.port);
    sin.sin4.sin_addr = global.a.ipv4;
    sinl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  }

  else
  {
    sock=socket(10, 1, 6);
    if(sock == -1)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      log_message(3, "Could not open tcp socket: %s", return_value_strerror_4);
      return -1;
    }

    memset((void *)&sin.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
    sin.sin6.sin6_family = (unsigned short int)10;
    sin.sin6.sin6_port=htons((unsigned short int)global.port);
    sin.sin6.sin6_flowinfo = (unsigned int)0;
    sin.sin6.sin6_addr = global.a.ipv6;
    sinl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
  }
  signed int so = 1;
  signed int return_value_setsockopt_7;
  return_value_setsockopt_7=setsockopt(sock, 1, 2, (const void *)&so, (unsigned int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  if(!(return_value_setsockopt_7 == 0))
  {
    return_value___errno_location_5=__errno_location();
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    log_message(4, "Could not set options on tcp socket: %s", return_value_strerror_6);
  }

  signed int return_value_bind_10;
  return_value_bind_10=bind(sock, (struct sockaddr *)&sin, sinl);
  if(!(return_value_bind_10 == 0))
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    log_message(3, "Could not bind tcp socket: %s", return_value_strerror_9);
    close(sock);
    return -1;
  }

  return sock;
}

// init_udp_socket
// file dns_answer.c line 1536
signed int init_udp_socket(void)
{
  signed int sock;
  signed int so = 1;
  /* tag-#anon#lUN[lSYM#tag-sockaddr_in#'sin4'|lSYM#tag-sockaddr_in6#'sin6'] */
union anonymous_22
{
  // sin4
  struct sockaddr_in sin4;
  // sin6
  struct sockaddr_in6 sin6;
};

/* */
  ;
  union anonymous_22 sin;
  unsigned int sinl;
  if(!(run_ipv4 == 0))
  {
    sock=socket(2, 2, 17);
    if(sock == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_message(3, "Could not open udp socket: %s", return_value_strerror_2);
      return -1;
    }

    memset((void *)&sin.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    sin.sin4.sin_family = (unsigned short int)2;
    sin.sin4.sin_port=htons((unsigned short int)global.port);
    sin.sin4.sin_addr = global.a.ipv4;
    sinl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  }

  else
  {
    sock=socket(10, 2, 17);
    if(sock == -1)
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      log_message(3, "Could not open udp socket: %s", return_value_strerror_4);
      return -1;
    }

    memset((void *)&sin.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
    sin.sin6.sin6_family = (unsigned short int)10;
    sin.sin6.sin6_port=htons((unsigned short int)global.port);
    sin.sin6.sin6_flowinfo = (unsigned int)0;
    sin.sin6.sin6_addr = global.a.ipv6;
    sinl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
  }
  signed int return_value_setsockopt_7;
  return_value_setsockopt_7=setsockopt(sock, 0, 8, (const void *)&so, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_7 == 0))
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    char *return_value_strerror_6;
    return_value_strerror_6=strerror(*return_value___errno_location_5);
    log_message(3, "Could not set options on udp socket: %s", return_value_strerror_6);
    close(sock);
    return -1;
  }

  if(run_ipv4 == 0)
  {
    signed int return_value_setsockopt_10;
    return_value_setsockopt_10=setsockopt(sock, 41, 49, (const void *)&so, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_10 == 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      char *return_value_strerror_9;
      return_value_strerror_9=strerror(*return_value___errno_location_8);
      log_message(3, "Could not set options on udp socket: %s", return_value_strerror_9);
      close(sock);
      return -1;
    }

  }

  signed int return_value_bind_13;
  return_value_bind_13=bind(sock, (struct sockaddr *)&sin, sinl);
  if(!(return_value_bind_13 == 0))
  {
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    log_message(3, "Could not bind to udp socket: %s", return_value_strerror_12);
    close(sock);
    return -1;
  }

  return sock;
}

// insert_rrl
// file cache.c line 889
static signed int insert_rrl(struct anonymous *rrs, struct anonymous_0 *cent, signed int idx)
{
  signed long int ts;
  struct rr_lent_s *le;
  struct rr_lent_s *ne;
  _Bool tmp_if_expr_1;
  if(!(rrs == ((struct anonymous *)NULL)))
    tmp_if_expr_1 = ((signed int)rrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = ((signed int)cent->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return 1;

  else
  {
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(sizeof(struct rr_lent_s) /*40ul*/ );
    ne = (struct rr_lent_s *)return_value_malloc_3;
    if(ne == ((struct rr_lent_s *)NULL))
      return 0;

    else
    {
      ne->rrset = rrs;
      ne->cent = cent;
      ne->idx = idx;
      ne->next = (struct rr_lent_s *)(void *)0;
      ne->prev = (struct rr_lent_s *)(void *)0;
      if(!(insert_sort == 0))
      {
        ts=get_rrlent_ts(ne);
        le = rrset_l_tail;
        while(!(le == ((struct rr_lent_s *)NULL)))
        {
          signed long int return_value_get_rrlent_ts_4;
          return_value_get_rrlent_ts_4=get_rrlent_ts(le);
          if(ts >= return_value_get_rrlent_ts_4)
            goto found;

          le = le->prev;
        }
        ne->next = rrset_l;
        if(!(rrset_l == ((struct rr_lent_s *)NULL)))
          rrset_l->prev = ne;

        else
          rrset_l_tail = ne;
        rrset_l = ne;
        goto finish;

      found:
        ;
        ne->next = le->next;
        ne->prev = le;
        if(!(le->next == ((struct rr_lent_s *)NULL)))
          le->next->prev = ne;

        else
          rrset_l_tail = ne;
        le->next = ne;
      }

      else
      {
        ne->prev = rrset_l_tail;
        if(!(rrset_l_tail == ((struct rr_lent_s *)NULL)))
          rrset_l_tail->next = ne;

        else
          rrset_l = ne;
        rrset_l_tail = ne;
      }

    finish:
      ;
      if(!(rrs == ((struct anonymous *)NULL)))
        rrs->lent = ne;

      else
        cent->_anon0.neg.lent = ne;
      return 1;
    }
  }
}

// invalidate_record
// file cache.h line 176
void invalidate_record(const unsigned char *name)
{
  struct anonymous_0 *ce;
  signed int i;
  signed int ilim;
  lock_cache_rw();
  ce=dns_lookup(name, (struct anonymous_58 *)(void *)0);
  if(!(ce == ((struct anonymous_0 *)NULL)))
  {
    if((1 & (signed int)ce->flags) == 0)
    {
      signed int tmp_if_expr_1;
      if(!((1 & (signed int)ce->flags) == 0))
        tmp_if_expr_1 = 0;

      else
        tmp_if_expr_1 = ce->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      ilim = tmp_if_expr_1;
      i = 0;
      for( ; !(i >= ilim); i = i + 1)
      {
        struct anonymous *rrs;
        struct anonymous *tmp_if_expr_2;
        if(!(i >= 8))
          tmp_if_expr_2 = ce->_anon0.rr.rrmu[(signed long int)i];

        else
          tmp_if_expr_2 = ce->_anon0.rr.rrext[(signed long int)(i - 8)];
        rrs = tmp_if_expr_2;
        if(!(rrs == ((struct anonymous *)NULL)))
        {
          rrs->ts = (signed long int)0;
          rrs->flags = rrs->flags & (unsigned short int)~4;
        }

      }
    }

    else
      ce->_anon0.neg.ts = (signed long int)0;
    ce->flags = ce->flags & (unsigned short int)~4;
  }

  unlock_cache_rw();
}

// is_inaddr2_any
// file helpers.h line 123
static inline signed int is_inaddr2_any(struct anonymous_15 *a)
{
  signed int tmp_if_expr_5;
  _Bool tmp_statement_expression_1;
  if(!(run_ipv4 == 0))
    tmp_if_expr_5 = (signed int)(a->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a = (struct in6_addr *)&a->ipv6;
    _Bool tmp_if_expr_2;
    if(__a->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr_2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_statement_expression_1 = tmp_if_expr_4;
    tmp_if_expr_5 = (signed int)tmp_statement_expression_1;
  }
  return tmp_if_expr_5;
}

// is_inaddr_any
// file helpers.h line 115
static inline signed int is_inaddr_any(union anonymous_6 *a)
{
  signed int tmp_if_expr_5;
  _Bool tmp_statement_expression_1;
  if(!(run_ipv4 == 0))
    tmp_if_expr_5 = (signed int)(a->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a = (struct in6_addr *)&a->ipv6;
    _Bool tmp_if_expr_2;
    if(__a->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr_2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_statement_expression_1 = tmp_if_expr_4;
    tmp_if_expr_5 = (signed int)tmp_statement_expression_1;
  }
  return tmp_if_expr_5;
}

// is_inaddr_any_link1
// file helpers.h line 115
static inline signed int is_inaddr_any_link1(union anonymous_6 *a_link1)
{
  signed int tmp_if_expr_5_link1;
  _Bool tmp_statement_expression_1_link1;
  if(!(run_ipv4 == 0))
    tmp_if_expr_5_link1 = (signed int)(a_link1->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a_link1 = (struct in6_addr *)&a_link1->ipv6;
    _Bool tmp_if_expr_2_link1;
    if(__a_link1->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr_2_link1 = __a_link1->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link1 = (_Bool)0;
    _Bool tmp_if_expr_3_link1;
    if(tmp_if_expr_2_link1)
      tmp_if_expr_3_link1 = __a_link1->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link1 = (_Bool)0;
    _Bool tmp_if_expr_4_link1;
    if(tmp_if_expr_3_link1)
      tmp_if_expr_4_link1 = __a_link1->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4_link1 = (_Bool)0;
    tmp_statement_expression_1_link1 = tmp_if_expr_4_link1;
    tmp_if_expr_5_link1 = (signed int)tmp_statement_expression_1_link1;
  }
  return tmp_if_expr_5_link1;
}

// is_inaddr_any_link2
// file helpers.h line 115
static inline signed int is_inaddr_any_link2(union anonymous_6 *a_link2)
{
  signed int tmp_if_expr_5_link2;
  _Bool tmp_statement_expression_1_link2;
  if(!(run_ipv4 == 0))
    tmp_if_expr_5_link2 = (signed int)(a_link2->ipv4.s_addr == (unsigned int)0x00000000);

  else
  {
    struct in6_addr *__a_link2 = (struct in6_addr *)&a_link2->ipv6;
    _Bool tmp_if_expr_2_link2;
    if(__a_link2->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr_2_link2 = __a_link2->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link2 = (_Bool)0;
    _Bool tmp_if_expr_3_link2;
    if(tmp_if_expr_2_link2)
      tmp_if_expr_3_link2 = __a_link2->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link2 = (_Bool)0;
    _Bool tmp_if_expr_4_link2;
    if(tmp_if_expr_3_link2)
      tmp_if_expr_4_link2 = __a_link2->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4_link2 = (_Bool)0;
    tmp_statement_expression_1_link2 = tmp_if_expr_4_link2;
    tmp_if_expr_5_link2 = (signed int)tmp_statement_expression_1_link2;
  }
  return tmp_if_expr_5_link2;
}

// is_interrupted_servstat_thread
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread()
{
  _Bool tmp_if_expr_3;
  unsigned long int return_value_pthread_self_1;
  signed int return_value_pthread_equal_2;
  if(!(signal_interrupt == 0))
  {
    return_value_pthread_self_1=pthread_self();
    return_value_pthread_equal_2=pthread_equal(return_value_pthread_self_1, servstat_thrid);
    tmp_if_expr_3 = return_value_pthread_equal_2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return (signed int)tmp_if_expr_3;
}

// is_interrupted_servstat_thread_link1
// file servers.h line 63
static inline signed int is_interrupted_servstat_thread_link1()
{
  _Bool tmp_if_expr_3_link1;
  unsigned long int return_value_pthread_self_1_link1;
  signed int return_value_pthread_equal_2_link1;
  if(!(signal_interrupt == 0))
  {
    return_value_pthread_self_1_link1=pthread_self();
    return_value_pthread_equal_2_link1=pthread_equal(return_value_pthread_self_1_link1, servstat_thrid);
    tmp_if_expr_3_link1 = return_value_pthread_equal_2_link1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3_link1 = (_Bool)0;
  return (signed int)tmp_if_expr_3_link1;
}

// is_local_addr
// file netdev.h line 30
signed int is_local_addr(union anonymous_6 *a)
{
  signed int res = 0;
  if(!(run_ipv4 == 0))
  {
    signed int i;
    signed int sock;
    struct ifreq ifr;
    sock=socket(2, 2, 17);
    if(sock == -1)
    {
      socketopen_errs = socketopen_errs + 1ul;
      if(!(socketopen_errs >= 11ul))
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        log_message(4, "Could not open socket in is_local_addr(): %s", return_value_strerror_2);
      }

      return 0;
    }

    i = 1;
    for( ; !(i >= 255); i = i + 1)
    {
      ifr.ifr_ifru.ifru_ivalue = i;
      signed int return_value_ioctl_3;
      return_value_ioctl_3=ioctl(sock, (unsigned long int)0x8910, &ifr);
      if(!(return_value_ioctl_3 == -1))
      {
        signed int return_value_ioctl_4;
        return_value_ioctl_4=ioctl(sock, (unsigned long int)0x8915, &ifr);
        if(!(return_value_ioctl_4 == -1))
        {
          if(((struct sockaddr_in *)&ifr.ifr_ifru.ifru_addr)->sin_addr.s_addr == a->ipv4.s_addr)
          {
            res = 1;
            break;
          }

        }

      }

    }
    close(sock);
  }

  else
  {
    char buf[40l];
    struct _IO_FILE *f;
    struct in6_addr b;
    f=fopen("/proc/net/if_inet6", "r");
    if(f == ((struct _IO_FILE *)NULL))
      return 0;

    do
    {
      signed int is_local_addr__1__2__1__1__i;
      signed int ch;
      char *p = buf;
      is_local_addr__1__2__1__1__i = 0;
      for( ; !(is_local_addr__1__2__1__1__i >= 32); is_local_addr__1__2__1__1__i = is_local_addr__1__2__1__1__i + 1)
      {
        if(is_local_addr__1__2__1__1__i % 4 == 0 && !(is_local_addr__1__2__1__1__i == 0))
        {
          char *tmp_post_5 = p;
          p = p + 1l;
          *tmp_post_5 = (char)58;
        }

        ch=fgetc(f);
        if(ch == -1)
          goto fclose_return;

        if(ch == 10)
          goto nextline;

        char *tmp_post_6 = p;
        p = p + 1l;
        *tmp_post_6 = (char)ch;
      }
      *p = (char)0;
      signed int return_value_inet_pton_7;
      return_value_inet_pton_7=inet_pton(10, buf, (void *)&b);
      if(return_value_inet_pton_7 >= 1)
      {
        if(*((unsigned int *)&b) == *((unsigned int *)&a->ipv6))
        {
          if(((unsigned int *)&b)[1l] == ((unsigned int *)&a->ipv6)[1l])
          {
            if(((unsigned int *)&b)[2l] == ((unsigned int *)&a->ipv6)[2l])
            {
              if(((unsigned int *)&b)[3l] == ((unsigned int *)&a->ipv6)[3l])
              {
                res = 1;
                break;
              }

            }

          }

        }

      }

      do
      {
        ch=fgetc(f);
        if(ch == -1)
          goto fclose_return;

      }
      while(!(ch == 10));

    nextline:
      ;
    }
    while((_Bool)1);

  fclose_return:
    ;
    fclose(f);
  }
  return res;
}

// isnormalencdomname
// file helpers.h line 112
signed int isnormalencdomname(const unsigned char *rhn, unsigned int maxlen)
{
  unsigned int i;
  unsigned int lb;
  if(maxlen >= 257u)
    maxlen = (unsigned int)256;

  i = (unsigned int)0;
  for( ; (_Bool)1; i = i + lb)
  {
    if(i >= maxlen)
      return 0;

    unsigned int tmp_post_1 = i;
    i = i + 1u;
    lb = (unsigned int)rhn[(signed long int)tmp_post_1];
    if(lb == 0u)
      break;

    if(lb >= 64u)
      return 0;

  }
  return 1;
}

// keyncmp
// file consts.c line 98
static inline signed int keyncmp(const char *key1, signed int len, const char *key2)
{
  signed int cmp;
  cmp=strncmp(key1, key2, (unsigned long int)len);
  if(!(cmp == 0))
    return cmp;

  else
    return -((signed int)(unsigned char)key2[(signed long int)len]);
}

// listmerge
// file cache.c line 972
static struct rr_lent_s * listmerge(struct rr_lent_s *p, struct rr_lent_s *q)
{
  if(p == ((struct rr_lent_s *)NULL))
    return q;

  else
    if(q == ((struct rr_lent_s *)NULL))
      return p;

    else
    {
      struct rr_lent_s *l = (struct rr_lent_s *)(void *)0;
      struct rr_lent_s **s = &l;
      do
      {
        signed long int return_value_get_rrlent_ts_1;
        return_value_get_rrlent_ts_1=get_rrlent_ts(p);
        signed long int return_value_get_rrlent_ts_2;
        return_value_get_rrlent_ts_2=get_rrlent_ts(q);
        if(return_value_get_rrlent_ts_2 >= return_value_get_rrlent_ts_1)
        {
          *s = p;
          s = &p->next;
          p = *s;
          if(p == ((struct rr_lent_s *)NULL))
          {
            *s = q;
            break;
          }

        }

        else
        {
          *s = q;
          s = &q->next;
          q = *s;
          if(q == ((struct rr_lent_s *)NULL))
          {
            *s = p;
            break;
          }

        }
      }
      while((_Bool)1);
      return l;
    }
}

// llist_first
// file list.h line 145
static inline void * llist_first(struct anonymous_40 *a)
{
  struct llistnode_s *p = a->first;
  char **tmp_if_expr_1;
  if(!(p == ((struct llistnode_s *)NULL)))
    tmp_if_expr_1 = p->data;

  else
    tmp_if_expr_1 = (char **)(void *)0;
  return (void *)tmp_if_expr_1;
}

// llist_free
// file list.h line 168
void llist_free(struct anonymous_40 *a)
{
  struct llistnode_s *p = a->first;
  while(!(p == ((struct llistnode_s *)NULL)))
  {
    struct llistnode_s *next = p->next;
    free((void *)p);
    p = next;
  }
  a->first = (struct llistnode_s *)(void *)0;
  a->last = (struct llistnode_s *)(void *)0;
}

// llist_grow
// file list.h line 167
signed int llist_grow(struct anonymous_40 *a, unsigned long int len)
{
  struct llistnode_s *new;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct llistnode_s) /*8ul*/  + len);
  new = (struct llistnode_s *)return_value_malloc_1;
  if(new == ((struct llistnode_s *)NULL))
  {
    llist_free(a);
    return 0;
  }

  else
  {
    new->next = (struct llistnode_s *)(void *)0;
    if(a->first == ((struct llistnode_s *)NULL))
      a->first = new;

    else
      a->last->next = new;
    a->last = new;
    return 1;
  }
}

// llist_init
// file list.h line 130
static inline void llist_init(struct anonymous_40 *a)
{
  a->first = (struct llistnode_s *)(void *)0;
  a->last = (struct llistnode_s *)(void *)0;
}

// llist_isempty
// file list.h line 138
static inline signed int llist_isempty(struct anonymous_40 *a)
{
  return (signed int)(a->first == (struct llistnode_s *)(void *)0);
}

// llist_last
// file list.h line 161
static inline void * llist_last(struct anonymous_40 *a)
{
  struct llistnode_s *p = a->last;
  char **tmp_if_expr_1;
  if(!(p == ((struct llistnode_s *)NULL)))
    tmp_if_expr_1 = p->data;

  else
    tmp_if_expr_1 = (char **)(void *)0;
  return (void *)tmp_if_expr_1;
}

// llist_next
// file list.h line 153
static inline void * llist_next(void *ref)
{
  struct llistnode_s *next = *((struct llistnode_s **)ref - (signed long int)1);
  char **tmp_if_expr_1;
  if(!(next == ((struct llistnode_s *)NULL)))
    tmp_if_expr_1 = next->data;

  else
    tmp_if_expr_1 = (char **)(void *)0;
  return (void *)tmp_if_expr_1;
}

// loc2str
// file rr_types.c line 80
const char * loc2str(const void *binary, char *ascii, unsigned long int asclen)
{
  const unsigned char *cp = (const unsigned char *)binary;
  signed int latdeg;
  signed int latmin;
  signed int latsec;
  signed int latsecfrac;
  signed int longdeg;
  signed int longmin;
  signed int longsec;
  signed int longsecfrac;
  char northsouth;
  char eastwest;
  const char *altsign;
  signed int altmeters;
  signed int altfrac;
  const unsigned int referencealt = (const unsigned int)(100000 * 100);
  signed int latval;
  signed int longval;
  signed int altval;
  unsigned int templ;
  unsigned char sizeval;
  unsigned char hpval;
  unsigned char vpval;
  unsigned char versionval;
  char sizestr[(signed long int)sizeof(char [9l]) /*9l*/ ];
  char hpstr[(signed long int)sizeof(char [9l]) /*9l*/ ];
  char vpstr[(signed long int)sizeof(char [9l]) /*9l*/ ];
  const unsigned char *tmp_post_1 = cp;
  cp = cp + 1l;
  versionval = *tmp_post_1;
  const char *return_value_precsize_ntoa_18;
  const char *return_value_precsize_ntoa_20;
  if(!(versionval == 0))
    return (const char *)(void *)0;

  else
  {
    const unsigned char *tmp_post_2 = cp;
    cp = cp + 1l;
    sizeval = *tmp_post_2;
    const unsigned char *tmp_post_3 = cp;
    cp = cp + 1l;
    hpval = *tmp_post_3;
    const unsigned char *tmp_post_4 = cp;
    cp = cp + 1l;
    vpval = *tmp_post_4;
    do
    {
      unsigned int t_l;
      const unsigned char *t_cp = (const unsigned char *)cp;
      const unsigned char *tmp_post_5 = t_cp;
      t_cp = t_cp + 1l;
      t_l = (unsigned int)*tmp_post_5 << 24;
      const unsigned char *tmp_post_6 = t_cp;
      t_cp = t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post_6 << 16;
      const unsigned char *tmp_post_7 = t_cp;
      t_cp = t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post_7 << 8;
      const unsigned char *tmp_post_8 = t_cp;
      t_cp = t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post_8;
      templ = t_l;
      cp = (const unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    latval = (signed int)(templ - ((unsigned int)1 << 31));
    do
    {
      unsigned int loc2str__1__3__t_l;
      const unsigned char *loc2str__1__3__t_cp = (const unsigned char *)cp;
      const unsigned char *tmp_post_9 = loc2str__1__3__t_cp;
      loc2str__1__3__t_cp = loc2str__1__3__t_cp + 1l;
      loc2str__1__3__t_l = (unsigned int)*tmp_post_9 << 24;
      const unsigned char *tmp_post_10 = loc2str__1__3__t_cp;
      loc2str__1__3__t_cp = loc2str__1__3__t_cp + 1l;
      loc2str__1__3__t_l = loc2str__1__3__t_l | (unsigned int)*tmp_post_10 << 16;
      const unsigned char *tmp_post_11 = loc2str__1__3__t_cp;
      loc2str__1__3__t_cp = loc2str__1__3__t_cp + 1l;
      loc2str__1__3__t_l = loc2str__1__3__t_l | (unsigned int)*tmp_post_11 << 8;
      const unsigned char *tmp_post_12 = loc2str__1__3__t_cp;
      loc2str__1__3__t_cp = loc2str__1__3__t_cp + 1l;
      loc2str__1__3__t_l = loc2str__1__3__t_l | (unsigned int)*tmp_post_12;
      templ = loc2str__1__3__t_l;
      cp = (const unsigned char *)(void *)loc2str__1__3__t_cp;
    }
    while((_Bool)0);
    longval = (signed int)(templ - ((unsigned int)1 << 31));
    do
    {
      unsigned int loc2str__1__4__t_l;
      const unsigned char *loc2str__1__4__t_cp = (const unsigned char *)cp;
      const unsigned char *tmp_post_13 = loc2str__1__4__t_cp;
      loc2str__1__4__t_cp = loc2str__1__4__t_cp + 1l;
      loc2str__1__4__t_l = (unsigned int)*tmp_post_13 << 24;
      const unsigned char *tmp_post_14 = loc2str__1__4__t_cp;
      loc2str__1__4__t_cp = loc2str__1__4__t_cp + 1l;
      loc2str__1__4__t_l = loc2str__1__4__t_l | (unsigned int)*tmp_post_14 << 16;
      const unsigned char *tmp_post_15 = loc2str__1__4__t_cp;
      loc2str__1__4__t_cp = loc2str__1__4__t_cp + 1l;
      loc2str__1__4__t_l = loc2str__1__4__t_l | (unsigned int)*tmp_post_15 << 8;
      const unsigned char *tmp_post_16 = loc2str__1__4__t_cp;
      loc2str__1__4__t_cp = loc2str__1__4__t_cp + 1l;
      loc2str__1__4__t_l = loc2str__1__4__t_l | (unsigned int)*tmp_post_16;
      templ = loc2str__1__4__t_l;
      cp = (const unsigned char *)(void *)loc2str__1__4__t_cp;
    }
    while((_Bool)0);
    if(!(templ >= referencealt))
    {
      altval = (signed int)(referencealt - templ);
      altsign = "-";
    }

    else
    {
      altval = (signed int)(templ - referencealt);
      altsign = "";
    }
    if(!(latval >= 0))
    {
      northsouth = (char)83;
      latval = -latval;
    }

    else
      northsouth = (char)78;
    latsecfrac = latval % 1000;
    latval = latval / 1000;
    latsec = latval % 60;
    latval = latval / 60;
    latmin = latval % 60;
    latval = latval / 60;
    latdeg = latval;
    if(!(longval >= 0))
    {
      eastwest = (char)87;
      longval = -longval;
    }

    else
      eastwest = (char)69;
    longsecfrac = longval % 1000;
    longval = longval / 1000;
    longsec = longval % 60;
    longval = longval / 60;
    longmin = longval % 60;
    longval = longval / 60;
    longdeg = longval;
    altfrac = altval % 100;
    altmeters = altval / 100;
    const char *return_value_precsize_ntoa_17;
    return_value_precsize_ntoa_17=precsize_ntoa(sizeval, sizestr);
    _Bool tmp_if_expr_19;
    if(return_value_precsize_ntoa_17 == ((const char *)NULL))
      tmp_if_expr_19 = (_Bool)1;

    else
    {
      return_value_precsize_ntoa_18=precsize_ntoa(hpval, hpstr);
      tmp_if_expr_19 = !(return_value_precsize_ntoa_18 != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_21;
    if(tmp_if_expr_19)
      tmp_if_expr_21 = (_Bool)1;

    else
    {
      return_value_precsize_ntoa_20=precsize_ntoa(vpval, vpstr);
      tmp_if_expr_21 = !(return_value_precsize_ntoa_20 != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_21)
      return (const char *)(void *)0;

    else
    {
      signed int n;
      n=snprintf(ascii, asclen, "%d %.2d %.2d.%.3d %c %d %.2d %.2d.%.3d %c %s%d.%.2dm %sm %sm %sm", latdeg, latmin, latsec, latsecfrac, northsouth, longdeg, longmin, longsec, longsecfrac, eastwest, altsign, altmeters, altfrac, (const void *)sizestr, (const void *)hpstr, (const void *)vpstr);
      if((unsigned long int)n >= asclen || !(n >= 0))
        return (const char *)(void *)0;

      else
        return ascii;
    }
  }
}

// lock_cache_r
// file cache.c line 235
static void lock_cache_r(void)
{
  volatile signed int tmp_if_expr_1;
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    r_pend = r_pend + 1;
    do
    {
      if(!(r_pend / 2 + 2 >= rw_pend))
      {
        r_susp = 1;
        tmp_if_expr_1 = r_susp;
      }

      else
        tmp_if_expr_1 = r_susp;
      if(tmp_if_expr_1 == 0)
      {
        if(cache_w_lock == 0)
          break;

      }

      pthread_cond_wait(&r_cond, &lock_mutex);
    }
    while((_Bool)1);
    cache_r_lock = cache_r_lock + 1;
    r_pend = r_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
  }

}

// lock_cache_rw
// file cache.c line 269
static void lock_cache_rw(void)
{
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    rw_pend = rw_pend + 1;
    while(!(cache_r_lock == 0) || !(cache_w_lock == 0))
      pthread_cond_wait(&rw_cond, &lock_mutex);
    cache_w_lock = 1;
    rw_pend = rw_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
  }

}

// lock_server_data
// file servers.h line 41
void lock_server_data()
{
  pthread_mutex_lock(&servers_lock);
  server_data_users = server_data_users + 1;
  pthread_mutex_unlock(&servers_lock);
}

// log_message
// file error.h line 50
void log_message(signed int prior, const char *s, ...)
{
  signed int gotlock = 0;
  void **va;
  struct _IO_FILE *f;
  unsigned long int return_value_strftime_2;
  if(!(use_log_lock == 0))
  {
    gotlock=softlock_mutex(&loglock);
    if(!(gotlock == 0) || !(prior >= 6))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(global.daemon == 0))
    {
      openlog("pdnsd", 0x01, 3 << 3);
      va = (void **)&s;
      vsyslog(prior, s, va);
      va = ((void **)NULL);
      closelog();
    }

    else
    {
      f = stderr;
      goto printtofile;
    }
    if(!(debug_p == 0))
    {
      f = dbg_file;

    printtofile:
      ;
      char ts[(signed long int)sizeof(char [19l]) /*19l*/ ];
      signed long int tt;
      tt=time((signed long int *)(void *)0);
      struct tm tm;
      struct tm *return_value_localtime_r_1;
      return_value_localtime_r_1=localtime_r(&tt, &tm);
      _Bool tmp_if_expr_3;
      if(return_value_localtime_r_1 == ((struct tm *)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strftime_2=strftime(ts, sizeof(char [19l]) /*19ul*/ , "* %m/%d %T| ", &tm);
        tmp_if_expr_3 = return_value_strftime_2 <= (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        ts[(signed long int)0] = (char)0;

      fprintf(f, "%spdnsd: %s: ", (const void *)ts, prior <= 2 ? "critical" : (prior == 3 ? "error" : (prior == 4 ? "warning" : "info")));
      va = (void **)&s;
      vfprintf(f, s, va);
      va = ((void **)NULL);
      const char *p;
      p=strchr(s, 0);
      _Bool tmp_if_expr_4;
      if(p == ((const char *)NULL) || p == s)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)*(p - (signed long int)1) != 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        fputc(10, f);

    }

    if(!(gotlock == 0))
      pthread_mutex_unlock(&loglock);

  }
}

// lookup_cache
// file cache.h line 179
struct anonymous_0 * lookup_cache(const unsigned char *name, signed int *wild)
{
  signed int purge = 0;
  struct anonymous_0 *ret;
  lock_cache_r();
  ret=dns_lookup(name, (struct anonymous_58 *)(void *)0);
  if(!(wild == ((signed int *)NULL)))
  {
    *wild = 0;
    if(ret == ((struct anonymous_0 *)NULL))
    {
      const unsigned char *lookup_cache__1__1__1__nm = name;
      unsigned int lb = (unsigned int)*lookup_cache__1__1__1__nm;
      if(!(lb == 0u))
        do
        {
          lookup_cache__1__1__1__nm = lookup_cache__1__1__1__nm + (signed long int)(lb + (unsigned int)1);
          lb = (unsigned int)*lookup_cache__1__1__1__nm;
          if(lb == 0u)
            break;

          ret=dns_lookup(lookup_cache__1__1__1__nm, (struct anonymous_58 *)(void *)0);
          if(!(ret == ((struct anonymous_0 *)NULL)))
          {
            if(!((1 & (signed int)ret->flags) == 0))
              *wild = 2;

            else
              if(!((16 & (signed int)ret->flags) == 0))
              {
                unsigned char buf[256l];
                buf[(signed long int)0] = (unsigned char)1;
                buf[(signed long int)1] = (unsigned char)42;
                rhncpy(&buf[(signed long int)2], lookup_cache__1__1__1__nm);
                ret=dns_lookup(buf, (struct anonymous_58 *)(void *)0);
                if(!(ret == ((struct anonymous_0 *)NULL)))
                  *wild = 1;

              }

              else
                if(!((2 & (signed int)ret->flags) == 0))
                  *wild = 3;

                else
                  ret = (struct anonymous_0 *)(void *)0;
            break;
          }

        }
        while((_Bool)1);

    }

  }

  if(!(ret == ((struct anonymous_0 *)NULL)))
  {
    purge=purge_cent(ret, 1, 1);
    if(purge == 0)
      ret=copy_cent(ret);

  }

  unlock_cache_r();
  if(!(purge == 0))
  {
    lock_cache_rw();
    ret=dns_lookup(name, (struct anonymous_58 *)(void *)0);
    if(!(wild == ((signed int *)NULL)))
    {
      *wild = 0;
      if(ret == ((struct anonymous_0 *)NULL))
      {
        const unsigned char *nm = name;
        unsigned int lookup_cache__1__3__1__1__lb = (unsigned int)*nm;
        if(!(lookup_cache__1__3__1__1__lb == 0u))
          do
          {
            nm = nm + (signed long int)(lookup_cache__1__3__1__1__lb + (unsigned int)1);
            lookup_cache__1__3__1__1__lb = (unsigned int)*nm;
            if(lookup_cache__1__3__1__1__lb == 0u)
              break;

            ret=dns_lookup(nm, (struct anonymous_58 *)(void *)0);
            if(!(ret == ((struct anonymous_0 *)NULL)))
            {
              if(!((1 & (signed int)ret->flags) == 0))
                *wild = 2;

              else
                if(!((16 & (signed int)ret->flags) == 0))
                {
                  unsigned char lookup_cache__1__3__1__1__1__1__1__1__buf[256l];
                  lookup_cache__1__3__1__1__1__1__1__1__buf[(signed long int)0] = (unsigned char)1;
                  lookup_cache__1__3__1__1__1__1__1__1__buf[(signed long int)1] = (unsigned char)42;
                  rhncpy(&lookup_cache__1__3__1__1__1__1__1__1__buf[(signed long int)2], nm);
                  ret=dns_lookup(lookup_cache__1__3__1__1__1__1__1__1__buf, (struct anonymous_58 *)(void *)0);
                  if(!(ret == ((struct anonymous_0 *)NULL)))
                    *wild = 1;

                }

                else
                  if(!((2 & (signed int)ret->flags) == 0))
                    *wild = 3;

                  else
                    ret = (struct anonymous_0 *)(void *)0;
              break;
            }

          }
          while((_Bool)1);

      }

    }

    if(!(ret == ((struct anonymous_0 *)NULL)))
    {
      signed int return_value_purge_cent_1;
      return_value_purge_cent_1=purge_cent(ret, 1, 0);
      if(!(return_value_purge_cent_1 >= 0))
        ret = (struct anonymous_0 *)(void *)0;

      else
        ret=copy_cent(ret);
    }

    unlock_cache_rw();
  }

  return ret;
}

// lookup_cache_local_rrset
// file cache.h line 180
struct anonymous * lookup_cache_local_rrset(const unsigned char *name, signed int type)
{
  struct anonymous *ret = (struct anonymous *)(void *)0;
  struct anonymous_0 *cent;
  lock_cache_r();
  cent=dns_lookup(name, (struct anonymous_58 *)(void *)0);
  if(!(cent == ((struct anonymous_0 *)NULL)))
  {
    struct anonymous *rrset;
    rrset=getrrset_link2(cent, type);
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      if(!((2 & (signed int)rrset->flags) == 0))
        ret=copy_rrset(rrset);

    }

  }

  unlock_cache_r();
  return ret;
}

// lookup_cache_status
// file dns_query.c line 3235
static signed int lookup_cache_status(const unsigned char *name, signed int thint, struct anonymous_0 **cachedp, unsigned short int *flagsp, signed long int queryts, unsigned char *c_soa)
{
  struct anonymous_0 *cached;
  signed int rc = 0xfffa;
  signed int wild = 0;
  unsigned short int flags = (unsigned short int)0;
  cached=lookup_cache(name, &wild);
  const unsigned char *return_value_rhn2str_1;
  char *return_value_flags2str_2;
  unsigned int return_value_rhnsegcnt_3;
  unsigned int return_value_rhnsegcnt_4;
  const unsigned char *return_value_rhn2str_7;
  signed int return_value_set_flags_ttl_11;
  struct anonymous *tmp_if_expr_12;
  struct anonymous *return_value_getrrset_9;
  char *return_value_flags2str_14;
  char *return_value_flags2str_15;
  if(!(cached == ((struct anonymous_0 *)NULL)))
  {
    signed short int neg = (signed short int)0;
    signed short int timed = (signed short int)0;
    signed short int need_req = (signed short int)0;
    signed long int ttl = (signed long int)0;
    if(!((2 & (signed int)cached->flags) == 0))
    {
      char dflagstr[20l];
      unsigned char _debugstrbuf[256l];
      if(!(debug_p == 0))
      {
        return_value_rhn2str_1=rhn2str(cached->qname, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
        return_value_flags2str_2=flags2str((unsigned int)cached->flags, dflagstr, 5, dflgnames);
        debug_msg(0, "Entry found in cache for '%s' with dflags=%s.\n", return_value_rhn2str_1, return_value_flags2str_2);
      }

      if(wild == 3 || !((1 & (signed int)cached->flags) == 0))
      {
        if(!(c_soa == ((unsigned char *)NULL)))
        {
          if(!((signed int)cached->c_soa == 0xff))
            *c_soa = cached->c_soa;

          else
          {
            _Bool tmp_if_expr_5;
            if((1 & (signed int)cached->flags) == 0)
              tmp_if_expr_5 = cached->_anon0.rr.rrmu[(signed long int)3] != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5 = (_Bool)0;
            _Bool tmp_if_expr_6;
            if(tmp_if_expr_5)
              tmp_if_expr_6 = cached->_anon0.rr.rrmu[(signed long int)3]->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_6 = (_Bool)0;
            if(tmp_if_expr_6)
            {
              return_value_rhnsegcnt_3=rhnsegcnt_link1(cached->qname);
              *c_soa = (unsigned char)return_value_rhnsegcnt_3;
            }

            else
            {
              unsigned char *owner;
              owner=getlocalowner(cached->qname, 6);
              if(!(owner == ((unsigned char *)NULL)))
              {
                return_value_rhnsegcnt_4=rhnsegcnt_link1(owner);
                *c_soa = (unsigned char)return_value_rhnsegcnt_4;
              }

            }
          }
        }

        free_cent(cached);
        free((void *)cached);
        rc = 3;
        goto return_rc;
      }

      rc = 0;
    }

    else
    {
      unsigned char lookup_cache_status__1__1__2___debugstrbuf[256l];
      if(!(debug_p == 0))
      {
        return_value_rhn2str_7=rhn2str(cached->qname, lookup_cache_status__1__1__2___debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
        debug_msg(0, "Record found in cache for %s\n", return_value_rhn2str_7);
      }

      if(!((1 & (signed int)cached->flags) == 0))
      {
        signed long int tmp_if_expr_8;
        if(!(cached->_anon0.neg.ttl >= 120l))
          tmp_if_expr_8 = (signed long int)120;

        else
          tmp_if_expr_8 = cached->_anon0.neg.ttl;
        ttl = cached->_anon0.neg.ts + tmp_if_expr_8;
        if(ttl >= queryts)
          neg = (signed short int)1;

        else
          timed = (signed short int)1;
      }

      else
      {
        if(thint == 255)
          set_all_flags_ttl(&flags, &ttl, cached);

        else
        {
          return_value_set_flags_ttl_11=set_flags_ttl(&flags, &ttl, cached, 5);
          _Bool tmp_if_expr_13;
          if(return_value_set_flags_ttl_11 == 0)
            tmp_if_expr_13 = (_Bool)1;

          else
          {
            if((1 & (signed int)cached->flags) == 0)
              tmp_if_expr_12 = cached->_anon0.rr.rrmu[(signed long int)2];

            else
              tmp_if_expr_12 = (struct anonymous *)(void *)0;
            tmp_if_expr_13 = ((signed int)tmp_if_expr_12->flags & 1) != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_13)
          {
            flags = (unsigned short int)0;
            ttl = (signed long int)0;
            if(thint >= 1 && !(thint >= 52))
            {
              signed int return_value_set_flags_ttl_10;
              return_value_set_flags_ttl_10=set_flags_ttl(&flags, &ttl, cached, thint);
              if(!(return_value_set_flags_ttl_10 == 0))
              {
                return_value_getrrset_9=getrrset_link1(cached, thint);
                neg = (signed short int)(((signed int)return_value_getrrset_9->flags & 1) != 0 ? (ttl >= queryts ? (_Bool)1 : (_Bool)0) : (_Bool)0);
              }

            }

            else
              if(thint == 253)
              {
                set_flags_ttl(&flags, &ttl, cached, 7);
                set_flags_ttl(&flags, &ttl, cached, 8);
                set_flags_ttl(&flags, &ttl, cached, 9);
              }

              else
                if(thint == 254)
                {
                  set_flags_ttl(&flags, &ttl, cached, 3);
                  set_flags_ttl(&flags, &ttl, cached, 4);
                }

          }

        }
        if((2 & (signed int)flags) == 0)
        {
          if(thint == 255)
          {
            if((4 & (signed int)cached->flags) == 0)
              need_req = (signed short int)1;

          }

          else
            if(thint >= 251 && !(thint >= 256))
            {
              if(!((16 & (signed int)flags) == 0) || (4 & (signed int)flags) == 0)
                need_req = (signed short int)1;

            }

          if(!(ttl >= queryts))
            timed = (signed short int)1;

        }

      }
      char lookup_cache_status__1__1__5__dflagstr[20l];
      char cflagstr[28l];
      if(!(debug_p == 0))
      {
        return_value_flags2str_14=flags2str((unsigned int)cached->flags, lookup_cache_status__1__1__5__dflagstr, 5, dflgnames);
        return_value_flags2str_15=flags2str((unsigned int)flags, cflagstr, 7, cflgnames);
        debug_msg(0, "Requery decision: dflags=%s, cflags=%s, req=%i, neg=%i, timed=%i, %s=%li\n", return_value_flags2str_14, return_value_flags2str_15, need_req, neg, timed, ttl != 0l ? "ttl" : "timestamp", (signed long int)(ttl != 0l ? ttl - queryts : ttl));
      }

      rc = !(neg != 0) && (need_req != 0 || timed != 0) ? 0xfffc : 0xfffb;
    }

  return_rc_cent:
    ;
    *cachedp = cached;
  }


return_rc:
  ;
  if(!(flagsp == ((unsigned short int *)NULL)))
    *flagsp = flags;

  return rc;
}

// lookup_cent_array
// file dns_query.c line 1094
static struct anonymous_0 * lookup_cent_array(struct anonymous_16 *ca, const unsigned char *nm)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link2((struct anonymous_3 *)ca);
  n = (signed int)return_value_da_nel_1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous_0 *ce = &ca->elem[(signed long int)i];
    signed int return_value_rhnicmp_2;
    return_value_rhnicmp_2=rhnicmp_link1(ce->qname, nm);
    if(!(return_value_rhnicmp_2 == 0))
      return ce;

  }
  return (struct anonymous_0 *)(void *)0;
}

// lookup_const
// file consts.h line 66
signed int lookup_const(const char *name, signed int len)
{
  signed int return_value_binsearch_keyword_1;
  return_value_binsearch_keyword_1=binsearch_keyword(name, len, const_dic, (signed int)(sizeof(const struct anonymous_32 [29l]) /*464ul*/  / sizeof(struct anonymous_32) /*16ul*/ ));
  return return_value_binsearch_keyword_1;
}

// lookup_ns
// file dns_query.c line 2904
static struct anonymous_14 * lookup_ns(const unsigned char *domain)
{
  struct anonymous_14 *res = (struct anonymous_14 *)(void *)0;
  struct anonymous_0 *cent;
  cent=lookup_cache(domain, (signed int *)(void *)0);
  signed long int return_value_time_19;
  signed long int return_value_time_5;
  signed long int return_value_time_13;
  if(!(cent == ((struct anonymous_0 *)NULL)))
  {
    struct anonymous *lookup_ns__1__1__rrset;
    struct anonymous *tmp_if_expr_1;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr_1 = cent->_anon0.rr.rrmu[(signed long int)1];

    else
      tmp_if_expr_1 = (struct anonymous *)(void *)0;
    lookup_ns__1__1__rrset = tmp_if_expr_1;
    if(!(lookup_ns__1__1__rrset == ((struct anonymous *)NULL)))
    {
      if(!((64 & (signed int)lookup_ns__1__1__rrset->flags) == 0))
      {
        signed long int tmp_if_expr_18;
        if(!(lookup_ns__1__1__rrset->ttl >= 120l))
          tmp_if_expr_18 = (signed long int)120;

        else
          tmp_if_expr_18 = lookup_ns__1__1__rrset->ttl;
        return_value_time_19=time((signed long int *)(void *)0);
        if(lookup_ns__1__1__rrset->ts + tmp_if_expr_18 >= return_value_time_19)
        {
          struct rr_b_s *rr = lookup_ns__1__1__rrset->rrs;
          for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
          {
            struct anonymous_15 *serva;
            struct anonymous_0 *servent;
            struct anonymous_3 *return_value_da_grow1_2;
            return_value_da_grow1_2=da_grow1((struct anonymous_3 *)res, (unsigned long int)((struct anonymous_14 *)0)->elem, sizeof(struct anonymous_15) /*20ul*/ , (void (*)(void *))(void *)0);
            res = (struct anonymous_14 *)return_value_da_grow1_2;
            if(res == ((struct anonymous_14 *)NULL))
            {
              if(!(debug_p == 0))
                debug_msg(0, "Out of memory in lookup_ns()\n");

              break;
            }

            serva = &res->elem[(signed long int)(res->nel - (unsigned long int)1)];
            if(run_ipv4 == 0)
              serva->ipv6 = in6addr_any;

            serva->ipv4.s_addr = (unsigned int)0x00000000;
            servent=lookup_cache((unsigned char *)rr->data, (signed int *)(void *)0);
            if(!(servent == ((struct anonymous_0 *)NULL)))
            {
              if(!(run_ipv4 == 0))
              {
                struct anonymous *rrset;
                struct anonymous *tmp_if_expr_3;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr_3 = servent->_anon0.rr.rrmu[(signed long int)0];

                else
                  tmp_if_expr_3 = (struct anonymous *)(void *)0;
                rrset = tmp_if_expr_3;
                if(!(rrset == ((struct anonymous *)NULL)))
                {
                  signed long int tmp_if_expr_4;
                  if(!(rrset->ttl >= 120l))
                    tmp_if_expr_4 = (signed long int)120;

                  else
                    tmp_if_expr_4 = rrset->ttl;
                  return_value_time_5=time((signed long int *)(void *)0);
                  if(rrset->ts + tmp_if_expr_4 >= return_value_time_5)
                  {
                    if(!(rrset->rrs == ((struct rr_b_s *)NULL)))
                      serva->ipv4 = *((struct in_addr *)rrset->rrs->data);

                  }

                }

              }

              else
              {
                struct anonymous *lookup_ns__1__1__1__1__1__2__2__rrset;
                struct anonymous *tmp_if_expr_15;
                if((1 & (signed int)servent->flags) == 0)
                  tmp_if_expr_15 = servent->_anon0.rr.rrmu[(signed long int)7];

                else
                  tmp_if_expr_15 = (struct anonymous *)(void *)0;
                lookup_ns__1__1__1__1__1__2__2__rrset = tmp_if_expr_15;
                _Bool tmp_if_expr_16;
                if(!(lookup_ns__1__1__1__1__1__2__2__rrset == ((struct anonymous *)NULL)))
                  tmp_if_expr_16 = !(((signed int)lookup_ns__1__1__1__1__1__2__2__rrset->flags & 1) != 0) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_16 = (_Bool)0;
                if(tmp_if_expr_16)
                {
                  signed long int tmp_if_expr_10;
                  if(!(lookup_ns__1__1__1__1__1__2__2__rrset->ttl >= 120l))
                    tmp_if_expr_10 = (signed long int)120;

                  else
                    tmp_if_expr_10 = lookup_ns__1__1__1__1__1__2__2__rrset->ttl;
                  signed long int return_value_time_11;
                  return_value_time_11=time((signed long int *)(void *)0);
                  if(lookup_ns__1__1__1__1__1__2__2__rrset->ts + tmp_if_expr_10 >= return_value_time_11)
                  {
                    if(!(lookup_ns__1__1__1__1__1__2__2__rrset->rrs == ((struct rr_b_s *)NULL)))
                    {
                      serva->ipv6 = *((struct in6_addr *)lookup_ns__1__1__1__1__1__2__2__rrset->rrs->data);
                      struct anonymous *tmp_if_expr_9;
                      if((1 & (signed int)servent->flags) == 0)
                        tmp_if_expr_9 = servent->_anon0.rr.rrmu[(signed long int)0];

                      else
                        tmp_if_expr_9 = (struct anonymous *)(void *)0;
                      lookup_ns__1__1__1__1__1__2__2__rrset = tmp_if_expr_9;
                      if(!(lookup_ns__1__1__1__1__1__2__2__rrset == ((struct anonymous *)NULL)))
                      {
                        if((1 & (signed int)lookup_ns__1__1__1__1__1__2__2__rrset->flags) == 0)
                        {
                          signed long int tmp_if_expr_6;
                          if(!(lookup_ns__1__1__1__1__1__2__2__rrset->ttl >= 120l))
                            tmp_if_expr_6 = (signed long int)120;

                          else
                            tmp_if_expr_6 = lookup_ns__1__1__1__1__1__2__2__rrset->ttl;
                          signed long int return_value_time_7;
                          return_value_time_7=time((signed long int *)(void *)0);
                          _Bool tmp_if_expr_8;
                          if(lookup_ns__1__1__1__1__1__2__2__rrset->ts + tmp_if_expr_6 >= return_value_time_7)
                            tmp_if_expr_8 = lookup_ns__1__1__1__1__1__2__2__rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr_8 = (_Bool)0;
                          if(tmp_if_expr_8)
                            serva->ipv4 = *((struct in_addr *)lookup_ns__1__1__1__1__1__2__2__rrset->rrs->data);

                          else
                            serva->ipv6 = in6addr_any;
                        }

                      }

                    }

                  }

                }

                else
                {
                  struct anonymous *tmp_if_expr_14;
                  if((1 & (signed int)servent->flags) == 0)
                    tmp_if_expr_14 = servent->_anon0.rr.rrmu[(signed long int)0];

                  else
                    tmp_if_expr_14 = (struct anonymous *)(void *)0;
                  lookup_ns__1__1__1__1__1__2__2__rrset = tmp_if_expr_14;
                  if(!(lookup_ns__1__1__1__1__1__2__2__rrset == ((struct anonymous *)NULL)))
                  {
                    signed long int tmp_if_expr_12;
                    if(!(lookup_ns__1__1__1__1__1__2__2__rrset->ttl >= 120l))
                      tmp_if_expr_12 = (signed long int)120;

                    else
                      tmp_if_expr_12 = lookup_ns__1__1__1__1__1__2__2__rrset->ttl;
                    return_value_time_13=time((signed long int *)(void *)0);
                    if(lookup_ns__1__1__1__1__1__2__2__rrset->ts + tmp_if_expr_12 >= return_value_time_13)
                    {
                      if(!(lookup_ns__1__1__1__1__1__2__2__rrset->rrs == ((struct rr_b_s *)NULL)))
                      {
                        struct in_addr *ina = (struct in_addr *)lookup_ns__1__1__1__1__1__2__2__rrset->rrs->data;
                        ((unsigned int *)&serva->ipv6)[(signed long int)3] = ina->s_addr;
                        ((unsigned int *)&serva->ipv6)[(signed long int)2]=htonl((unsigned int)0xffff);
                        ((unsigned int *)&serva->ipv6)[(signed long int)0] = (unsigned int)0;
                        ((unsigned int *)&serva->ipv6)[(signed long int)1] = ((unsigned int *)&serva->ipv6)[(signed long int)0];
                      }

                    }

                  }

                }
              }
              free_cent(servent);
              free((void *)servent);
            }

            signed int return_value_is_inaddr2_any_17;
            return_value_is_inaddr2_any_17=is_inaddr2_any(serva);
            if(!(return_value_is_inaddr2_any_17 == 0))
            {
              free((void *)res);
              res = (struct anonymous_14 *)(void *)0;
              break;
            }

          }
        }

      }

    }

    free_cent(cent);
    free((void *)cent);
  }

  return res;
}

// main
// file main.c line 220
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int sig;
  signed int pfd = -1;
  main_thrid=pthread_self();
  servstat_thrid = main_thrid;
  statsock_thrid = main_thrid;
  tcps_thrid = main_thrid;
  udps_thrid = main_thrid;
  init_uid=getuid();
  signed int main__1__1__err;
  main__1__1__err=inet_pton(10, "::ffff:0.0.0.0", (void *)&global.ipv4_6_prefix);
  if(!(main__1__1__err >= 1))
  {
    fprintf(stderr, "Error: inet_pton() wont accept default prefix %s in %s, line %d\n", (const void *)"::ffff:0.0.0.0", (const void *)"main.c", 235);
    if(!(main__1__1__err == 0))
      perror("inet_pton");

    exit(1);
  }

  i = 1;
  signed int return_value_strcmp_48;
  signed int return_value_strcmp_44;
  signed int return_value_strcmp_45;
  signed int return_value_strcmp_41;
  signed int return_value_strcmp_42;
  signed int return_value_strcmp_40;
  signed int return_value_strcmp_39;
  signed int return_value_strcmp_38;
  signed int return_value_strcmp_35;
  signed int return_value_strcmp_36;
  signed int return_value_strcmp_32;
  signed int return_value_strcmp_33;
  signed int return_value_strcmp_31;
  signed int return_value_strcmp_28;
  signed int return_value_strcmp_29;
  signed int return_value_strcmp_27;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_25;
  signed int return_value_strcmp_23;
  signed int return_value_strcmp_22;
  signed int return_value_strncmp_21;
  const unsigned short int **return_value___ctype_b_loc_5;
  signed int return_value_strncmp_20;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strncmp_13;
  for( ; !(i >= argc); i = i + 1)
  {
    char *arg = argv[(signed long int)i];
    signed int return_value_strcmp_47;
    return_value_strcmp_47=strcmp(arg, "-h");
    _Bool tmp_if_expr_49;
    if(return_value_strcmp_47 == 0)
      tmp_if_expr_49 = (_Bool)1;

    else
    {
      return_value_strcmp_48=strcmp(arg, "--help");
      tmp_if_expr_49 = return_value_strcmp_48 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_49)
    {
      fputs(info_message, stdout);
      fputs(help_message, stdout);
      exit(1);
    }

    else
    {
      return_value_strcmp_44=strcmp(arg, "-V");
      _Bool tmp_if_expr_46;
      if(return_value_strcmp_44 == 0)
        tmp_if_expr_46 = (_Bool)1;

      else
      {
        return_value_strcmp_45=strcmp(arg, "--version");
        tmp_if_expr_46 = return_value_strcmp_45 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_46)
      {
        fputs(info_message, stdout);
        exit(1);
      }

      else
      {
        return_value_strcmp_41=strcmp(arg, "-c");
        _Bool tmp_if_expr_43;
        if(return_value_strcmp_41 == 0)
          tmp_if_expr_43 = (_Bool)1;

        else
        {
          return_value_strcmp_42=strcmp(arg, "--config-file");
          tmp_if_expr_43 = return_value_strcmp_42 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_43)
        {
          i = i + 1;
          if(!(i >= argc))
            conf_file = argv[(signed long int)i];

          else
          {
            fprintf(stderr, "Error: file name expected after %s option.\n", arg);
            exit(1);
          }
        }

        else
        {
          return_value_strcmp_40=strcmp(arg, "-4");
          if(return_value_strcmp_40 == 0)
          {
            run_ipv4 = (signed short int)1;
            cmdlineipv = (signed short int)1;
          }

          else
          {
            return_value_strcmp_39=strcmp(arg, "-6");
            if(return_value_strcmp_39 == 0)
            {
              run_ipv4 = (signed short int)0;
              cmdlineipv = (signed short int)1;
            }

            else
            {
              return_value_strcmp_38=strcmp(arg, "-a");
              if(return_value_strcmp_38 == 0)
              {
                signed int rv;
                rv=check_ipv6();
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location_1;
                  return_value___errno_location_1=__errno_location();
                  char *return_value_strerror_2;
                  return_value_strerror_2=strerror(*return_value___errno_location_1);
                  fprintf(stderr, "Error: -a: can't check availability of IPv6: %s\nTry using -4 or -6 option instead.\n", return_value_strerror_2);
                  exit(1);
                }

                run_ipv4 = (signed short int)!(rv != 0);
                if(!(run_ipv4 == 0))
                  fprintf(stderr, "Switching to IPv4 mode.\n");

                cmdlineipv = (signed short int)1;
              }

              else
              {
                return_value_strcmp_35=strcmp(arg, "-i");
                _Bool tmp_if_expr_37;
                if(return_value_strcmp_35 == 0)
                  tmp_if_expr_37 = (_Bool)1;

                else
                {
                  return_value_strcmp_36=strcmp(arg, "--ipv4_6_prefix");
                  tmp_if_expr_37 = return_value_strcmp_36 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_37)
                {
                  i = i + 1;
                  if(!(i >= argc))
                  {
                    signed int return_value_inet_pton_3;
                    return_value_inet_pton_3=inet_pton(10, argv[(signed long int)i], (void *)&global.ipv4_6_prefix);
                    if(!(return_value_inet_pton_3 >= 1))
                    {
                      fprintf(stderr, "Error: %s: argument not a valid IPv6 address.\n", arg);
                      exit(1);
                    }

                    cmdline.prefix = (char)1;
                  }

                  else
                  {
                    fprintf(stderr, "Error: IPv6 address expected after %s option.\n", arg);
                    exit(1);
                  }
                }

                else
                {
                  return_value_strcmp_32=strcmp(arg, "-s");
                  _Bool tmp_if_expr_34;
                  if(return_value_strcmp_32 == 0)
                    tmp_if_expr_34 = (_Bool)1;

                  else
                  {
                    return_value_strcmp_33=strcmp(arg, "--status");
                    tmp_if_expr_34 = return_value_strcmp_33 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_34)
                  {
                    global.stat_pipe = (char)1;
                    cmdline.stat_pipe = (char)1;
                  }

                  else
                  {
                    return_value_strcmp_31=strcmp(arg, "--nostatus");
                    if(return_value_strcmp_31 == 0)
                    {
                      global.stat_pipe = (char)0;
                      cmdline.stat_pipe = (char)1;
                    }

                    else
                    {
                      return_value_strcmp_28=strcmp(arg, "-d");
                      _Bool tmp_if_expr_30;
                      if(return_value_strcmp_28 == 0)
                        tmp_if_expr_30 = (_Bool)1;

                      else
                      {
                        return_value_strcmp_29=strcmp(arg, "--daemon");
                        tmp_if_expr_30 = return_value_strcmp_29 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_30)
                      {
                        global.daemon = (char)1;
                        cmdline.daemon = (char)1;
                      }

                      else
                      {
                        return_value_strcmp_27=strcmp(arg, "--nodaemon");
                        if(return_value_strcmp_27 == 0)
                        {
                          global.daemon = (char)0;
                          cmdline.daemon = (char)1;
                        }

                        else
                        {
                          return_value_strcmp_24=strcmp(arg, "-t");
                          _Bool tmp_if_expr_26;
                          if(return_value_strcmp_24 == 0)
                            tmp_if_expr_26 = (_Bool)1;

                          else
                          {
                            return_value_strcmp_25=strcmp(arg, "--tcp");
                            tmp_if_expr_26 = return_value_strcmp_25 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr_26)
                          {
                            global.notcp = (char)0;
                            cmdline.notcp = (char)1;
                          }

                          else
                          {
                            return_value_strcmp_23=strcmp(arg, "--notcp");
                            if(return_value_strcmp_23 == 0)
                            {
                              global.notcp = (char)1;
                              cmdline.notcp = (char)1;
                            }

                            else
                            {
                              return_value_strcmp_22=strcmp(arg, "-p");
                              if(return_value_strcmp_22 == 0)
                              {
                                i = i + 1;
                                if(!(i >= argc))
                                {
                                  global.pidfile = argv[(signed long int)i];
                                  cmdline.pidfile = (char)1;
                                }

                                else
                                {
                                  fprintf(stderr, "Error: file name expected after -p option.\n");
                                  exit(1);
                                }
                              }

                              else
                              {
                                return_value_strncmp_21=strncmp(arg, "-v", (unsigned long int)2);
                                if(return_value_strncmp_21 == 0)
                                {
                                  unsigned long int return_value_strlen_4;
                                  return_value_strlen_4=strlen(arg);
                                  _Bool tmp_if_expr_6;
                                  if(!(return_value_strlen_4 == 3ul))
                                    tmp_if_expr_6 = (_Bool)1;

                                  else
                                  {
                                    return_value___ctype_b_loc_5=__ctype_b_loc();
                                    tmp_if_expr_6 = !(((signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)arg[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
                                  }
                                  if(tmp_if_expr_6)
                                  {
                                    fprintf(stderr, "Error: one digit expected after -v option (like -v2).\n");
                                    exit(1);
                                  }

                                  global.verbosity = (signed short int)((signed int)arg[(signed long int)2] - 48);
                                  cmdline.verbosity = (char)1;
                                }

                                else
                                {
                                  return_value_strncmp_20=strncmp(arg, "-m", (unsigned long int)2);
                                  if(return_value_strncmp_20 == 0)
                                  {
                                    unsigned long int return_value_strlen_7;
                                    return_value_strlen_7=strlen(arg);
                                    if(!(return_value_strlen_7 == 4ul))
                                    {
                                      fprintf(stderr, "Error: uo, to or tu expected after the  -m option (like -muo).\n");
                                      exit(1);
                                    }

                                    signed int return_value_strcmp_11;
                                    return_value_strcmp_11=strcmp(&arg[(signed long int)2], "uo");
                                    if(return_value_strcmp_11 == 0)
                                      global.query_method = 12;

                                    else
                                    {
                                      return_value_strcmp_10=strcmp(&arg[(signed long int)2], "to");
                                      if(return_value_strcmp_10 == 0)
                                        global.query_method = 13;

                                      else
                                      {
                                        return_value_strcmp_9=strcmp(&arg[(signed long int)2], "tu");
                                        if(return_value_strcmp_9 == 0)
                                          global.query_method = 14;

                                        else
                                        {
                                          return_value_strcmp_8=strcmp(&arg[(signed long int)2], "ut");
                                          if(return_value_strcmp_8 == 0)
                                            global.query_method = 15;

                                          else
                                          {
                                            fprintf(stderr, "Error: uo, to, tu or ut expected after the  -m option (like -muo).\n");
                                            exit(1);
                                          }
                                        }
                                      }
                                    }
                                    cmdline.query_method = (char)1;
                                  }

                                  else
                                  {
                                    return_value_strcmp_17=strcmp(arg, "-g");
                                    _Bool tmp_if_expr_19;
                                    if(return_value_strcmp_17 == 0)
                                      tmp_if_expr_19 = (_Bool)1;

                                    else
                                    {
                                      return_value_strcmp_18=strcmp(arg, "--debug");
                                      tmp_if_expr_19 = return_value_strcmp_18 == 0 ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr_19)
                                    {
                                      global.debug = (char)1;
                                      cmdline.debug = (char)1;
                                    }

                                    else
                                    {
                                      return_value_strcmp_16=strcmp(arg, "--nodebug");
                                      if(return_value_strcmp_16 == 0)
                                      {
                                        global.debug = (char)0;
                                        cmdline.debug = (char)1;
                                      }

                                      else
                                      {
                                        return_value_strcmp_15=strcmp(arg, "--pdnsd-user");
                                        if(return_value_strcmp_15 == 0)
                                          cmdline.pdnsduser = (char)1;

                                        else
                                        {
                                          char *equ;
                                          equ=strchr(arg, 61);
                                          if(!(equ == ((char *)NULL)))
                                          {
                                            signed int plen = (signed int)(equ - arg);
                                            char *valstr = equ + (signed long int)1;
                                            signed int return_value_strncmp_14;
                                            return_value_strncmp_14=strncmp(arg, "--config-file", sizeof(char [14l]) /*14ul*/  - (unsigned long int)1);
                                            if(return_value_strncmp_14 == 0 && (unsigned long int)plen == 13ul)
                                              conf_file = valstr;

                                            else
                                            {
                                              return_value_strncmp_13=strncmp(arg, "--ipv4_6_prefix", sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
                                              if(return_value_strncmp_13 == 0 && (unsigned long int)plen == 15ul)
                                              {
                                                signed int return_value_inet_pton_12;
                                                return_value_inet_pton_12=inet_pton(10, valstr, (void *)&global.ipv4_6_prefix);
                                                if(!(return_value_inet_pton_12 >= 1))
                                                {
                                                  fprintf(stderr, "Error: --ipv4_6_prefix: argument not a valid IPv6 address.\n");
                                                  exit(1);
                                                }

                                                cmdline.prefix = (char)1;
                                              }

                                              else
                                              {
                                                fprintf(stderr, "Error: unknown option: %.*s\n", plen, arg);
                                                exit(1);
                                              }
                                            }
                                          }

                                          else
                                          {
                                            fprintf(stderr, "Error: unknown option: %s\n", arg);
                                            exit(1);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  mk_dns_hash();
  char *errmsg;
  signed int return_value_read_config_file_50;
  return_value_read_config_file_50=read_config_file(conf_file, &global, &servers, 0, &errmsg);
  if(return_value_read_config_file_50 == 0)
  {
    fputs((_Bool)errmsg ? errmsg : "Out of memory.", stderr);
    fputc(10, stderr);
    exit(3);
  }

  if(!(cmdline.pdnsduser == 0))
  {
    if(!(global.run_as[0l] == 0))
      printf("%s\n", (const void *)global.run_as);

    else
    {
      unsigned int uid;
      uid=getuid();
      struct passwd *pws;
      pws=getpwuid(uid);
      if(!(pws == ((struct passwd *)NULL)))
        printf("%s\n", pws->pw_name);

      else
        printf("%i\n", uid);
    }
    exit(0);
  }

  if(global.cache_dir == ((char *)NULL))
    global.cache_dir = "/var/cache/pdnsd";

  if(global.scheme_file == ((char *)NULL))
    global.scheme_file = "/var/lib/pcmcia/scheme";

  stat_pipe = (signed short int)global.stat_pipe;
  unsigned int return_value_da_nel_51;
  if(global.run_as[0l] == 0 || global.strict_suid == 0)
  {
    i = 0;
    do
    {
      return_value_da_nel_51=da_nel_link3((struct anonymous_3 *)servers);
      if((unsigned int)i >= return_value_da_nel_51)
        break;

      struct anonymous_7 *sp = &servers->elem[(signed long int)i];
      if((signed int)sp->uptest == 7)
      {
        if((signed int)sp->uptest_usr[0l] == 0)
        {
          unsigned int main__1__5__1__1__1__uid;
          main__1__5__1__1__1__uid=getuid();
          struct passwd *main__1__5__1__1__1__pws;
          main__1__5__1__1__1__pws=getpwuid(main__1__5__1__1__1__uid);
          fprintf(stderr, "Warning: uptest command \"%s\" will implicitly be executed as user ", sp->uptest_cmd);
          if(!(main__1__5__1__1__1__pws == ((struct passwd *)NULL)))
            fprintf(stderr, "%s\n", main__1__5__1__1__1__pws->pw_name);

          else
            fprintf(stderr, "%i\n", main__1__5__1__1__1__uid);
        }

      }

      i = i + 1;
    }
    while((_Bool)1);
  }

  signed int *return_value___errno_location_54;
  if(!(global.pidfile == ((char *)NULL)) && !(global.daemon == 0))
  {
    signed int return_value_unlink_55;
    return_value_unlink_55=unlink(global.pidfile);
    if(!(return_value_unlink_55 == 0))
    {
      return_value___errno_location_54=__errno_location();
      if(!(*return_value___errno_location_54 == 2))
      {
        signed int *return_value___errno_location_52;
        return_value___errno_location_52=__errno_location();
        char *return_value_strerror_53;
        return_value_strerror_53=strerror(*return_value___errno_location_52);
        log_message(3, "Error: could not unlink pid file %s: %s", global.pidfile, return_value_strerror_53);
        exit(1);
      }

    }

    pfd=open(global.pidfile, 01 | 0100 | 0200 | 0400000, 0600);
    if(pfd == -1)
    {
      signed int *return_value___errno_location_56;
      return_value___errno_location_56=__errno_location();
      char *return_value_strerror_57;
      return_value_strerror_57=strerror(*return_value___errno_location_56);
      log_message(3, "Error: could not open pid file %s: %s", global.pidfile, return_value_strerror_57);
      exit(1);
    }

  }

  i = 0;
  unsigned int return_value_da_nel_58;
  do
  {
    return_value_da_nel_58=da_nel_link3((struct anonymous_3 *)servers);
    if((unsigned int)i >= return_value_da_nel_58)
      break;

    if((signed int)servers->elem[(signed long int)i].uptest == 8)
    {
      init_ping_socket();
      break;
    }

    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_init_rng_59;
  return_value_init_rng_59=init_rng();
  if(return_value_init_rng_59 == 0)
    exit(1);

  signed int return_value_final_init_60;
  return_value_final_init_60=final_init();
  if(return_value_final_init_60 == 0)
    exit(1);

  struct sigaction action;
  action.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction_63;
  return_value_sigaction_63=sigaction(13, &action, (struct sigaction *)(void *)0);
  signed int *return_value___errno_location_61;
  char *return_value_strerror_62;
  if(!(return_value_sigaction_63 == 0))
  {
    return_value___errno_location_61=__errno_location();
    return_value_strerror_62=strerror(*return_value___errno_location_61);
    log_message(3, "Could not call sigaction to ignore SIGPIPE: %s", return_value_strerror_62);
  }

  umask((unsigned int)0077);
  signed int *return_value___errno_location_77;
  char *return_value_strerror_78;
  signed int *return_value___errno_location_86;
  char *return_value_strerror_87;
  if(!(global.daemon == 0))
  {
    signed int pid;
    signed int fd;
    pid=fork();
    if(pid == -1)
    {
      signed int *return_value___errno_location_64;
      return_value___errno_location_64=__errno_location();
      char *return_value_strerror_65;
      return_value_strerror_65=strerror(*return_value___errno_location_64);
      log_message(3, "Could not become a daemon: fork #1 failed: %s", return_value_strerror_65);
      exit(1);
    }

    if(!(pid == 0))
      exit(0);

    signed int return_value_setsid_68;
    return_value_setsid_68=setsid();
    if(return_value_setsid_68 == -1)
    {
      signed int *return_value___errno_location_66;
      return_value___errno_location_66=__errno_location();
      char *return_value_strerror_67;
      return_value_strerror_67=strerror(*return_value___errno_location_66);
      log_message(3, "Could not become a daemon: setsid failed: %s", return_value_strerror_67);
      _exit(1);
    }

    pid=fork();
    if(pid == -1)
    {
      signed int *return_value___errno_location_69;
      return_value___errno_location_69=__errno_location();
      char *return_value_strerror_70;
      return_value_strerror_70=strerror(*return_value___errno_location_69);
      log_message(3, "Could not become a daemon: fork #2 failed: %s", return_value_strerror_70);
      _exit(1);
    }

    if(!(pid == 0))
    {
      signed int exitval = 0;
      if(!(global.pidfile == ((char *)NULL)))
      {
        signed int return_value_fsprintf_73;
        return_value_fsprintf_73=fsprintf(pfd, "%i\n", (signed int)pid);
        if(!(return_value_fsprintf_73 >= 0))
        {
          signed int *return_value___errno_location_71;
          return_value___errno_location_71=__errno_location();
          char *return_value_strerror_72;
          return_value_strerror_72=strerror(*return_value___errno_location_71);
          log_message(3, "Error: could not write to pid file %s: %s", global.pidfile, return_value_strerror_72);
          exitval = 1;
        }

        signed int return_value_close_76;
        return_value_close_76=close(pfd);
        if(!(return_value_close_76 >= 0))
        {
          signed int *return_value___errno_location_74;
          return_value___errno_location_74=__errno_location();
          char *return_value_strerror_75;
          return_value_strerror_75=strerror(*return_value___errno_location_74);
          log_message(3, "Error: could not close pid file %s: %s", global.pidfile, return_value_strerror_75);
          exitval = 1;
        }

      }

      _exit(exitval);
    }

    if(!(global.pidfile == ((char *)NULL)))
      close(pfd);

    signed int return_value_chdir_79;
    return_value_chdir_79=chdir("/");
    if(!(return_value_chdir_79 == 0))
    {
      return_value___errno_location_77=__errno_location();
      return_value_strerror_78=strerror(*return_value___errno_location_77);
      log_message(4, "Cannot chdir to root directory: %s", return_value_strerror_78);
    }

    fd=open("/dev/null", 00);
    if(fd == -1)
    {
      signed int *return_value___errno_location_80;
      return_value___errno_location_80=__errno_location();
      char *return_value_strerror_81;
      return_value_strerror_81=strerror(*return_value___errno_location_80);
      log_message(3, "Could not become a daemon: open for /dev/null failed: %s", return_value_strerror_81);
      _exit(1);
    }

    dup2(fd, 0);
    close(fd);
    fd=open("/dev/null", 01);
    if(fd == -1)
    {
      signed int *return_value___errno_location_82;
      return_value___errno_location_82=__errno_location();
      char *return_value_strerror_83;
      return_value_strerror_83=strerror(*return_value___errno_location_82);
      log_message(3, "Could not become a daemon: open for /dev/null failed: %s", return_value_strerror_83);
      _exit(1);
    }

    dup2(fd, 1);
    dup2(fd, 2);
    close(fd);
    if(!(global.debug == 0))
    {
      signed long int exitval_array_size0;
      unsigned long int return_value_strlen_84;
      return_value_strlen_84=strlen(global.cache_dir);
      exitval_array_size0 = (signed long int)(return_value_strlen_84 + sizeof(char [13l]) /*13ul*/ );
      char dbgpath[exitval_array_size0];
      char *return_value_stpcpy_85;
      return_value_stpcpy_85=stpcpy(dbgpath, global.cache_dir);
      stpcpy(return_value_stpcpy_85, "/pdnsd.debug");
      dbg_file=fopen(dbgpath, "w");
      if(dbg_file == ((struct _IO_FILE *)NULL))
      {
        return_value___errno_location_86=__errno_location();
        return_value_strerror_87=strerror(*return_value___errno_location_86);
        log_message(4, "Warning: could not open debug file %s: %s", (const void *)dbgpath, return_value_strerror_87);
      }

    }

  }

  else
    dbg_file = stdout;
  debug_p = (signed short int)(global.debug != 0 && dbg_file != ((struct _IO_FILE *)NULL));
  if((signed int)global.verbosity >= 0)
    log_message(6, "pdnsd-%s starting.\n", (const void *)"1.2.9a-par");

  if(!(debug_p == 0))
    debug_msg(0, "Debug messages activated\n");

  if(!(debug_p == 0))
    debug_msg(0, run_ipv4 != 0 ? "Using IPv4.\n" : "Using IPv6.\n");

  pthread_attr_init(&attr_detached);
  pthread_attr_setdetachstate(&attr_detached, 1);
  read_disk_cache();
  if(!(stat_pipe == 0))
    init_stat_sock();

  init_log_lock();
  init_cache_lock();
  sigemptyset(&sigs_msk);
  sigaddset(&sigs_msk, 1);
  sigaddset(&sigs_msk, 2);
  sigaddset(&sigs_msk, 6);
  sigaddset(&sigs_msk, 8);
  sigaddset(&sigs_msk, 15);
  pthread_sigmask(0, &sigs_msk, (struct anonymous_41 *)(void *)0);
  signed int err;
  err=pthread_key_create(&thrid_key, (void (*)(void *))(void *)0);
  if(!(err == 0))
  {
    char *return_value_strerror_88;
    return_value_strerror_88=strerror(err);
    log_message(3, "pthread_key_create failed: %s", return_value_strerror_88);
    _exit(1);
  }

  signed int thrdsucc = 1;
  signed int return_value_start_servstat_thread_89;
  return_value_start_servstat_thread_89=start_servstat_thread();
  if(!(return_value_start_servstat_thread_89 == 0))
    thrdsucc = 0;

  if(global.strict_suid == 0)
  {
    signed int return_value_run_as_90;
    return_value_run_as_90=run_as(global.run_as);
    if(return_value_run_as_90 == 0)
      _exit(1);

  }

  signed int return_value_start_stat_sock_91;
  if(!(stat_pipe == 0))
  {
    return_value_start_stat_sock_91=start_stat_sock();
    if(!(return_value_start_stat_sock_91 == 0))
      thrdsucc = 0;

  }

  start_dns_servers();
  if(!(thrdsucc == 0))
  {
    if(!(debug_p == 0))
      debug_msg(0, "All threads started successfully.\n");

  }

  signed int main__1__16__err;
  do
  {
    main__1__16__err=sigwait(&sigs_msk, &sig);
    if(main__1__16__err == 0)
      break;

    if(!(main__1__16__err == 4))
    {
      char *return_value_strerror_92;
      return_value_strerror_92=strerror(main__1__16__err);
      log_message(3, "sigwait failed: %s", return_value_strerror_92);
      sig = 0;
      break;
    }

  }
  while((_Bool)1);
  if(!(sig == 0))
  {
    if(!(debug_p == 0))
      debug_msg(0, "Signal %i caught.\n", sig);

  }

  write_disk_cache();
  destroy_cache();
  if(!(sig == 0))
    log_message(4, "Caught signal %i. Exiting.", sig);

  if(sig == 4 || sig == 7 || sig == 11)
    crash_msg("This is a fatal signal probably triggered by a bug.");

  if(!(ping_isocket == -1))
    close(ping_isocket);

  if(!(ping6_isocket == -1))
    close(ping6_isocket);

  if(!(stat_pipe == 0))
    close(stat_sock);

  signed int return_value_unlink_95;
  signed int *return_value___errno_location_93;
  char *return_value_strerror_94;
  if(!(sock_path == ((char *)NULL)))
  {
    return_value_unlink_95=unlink(sock_path);
    if(!(return_value_unlink_95 == 0))
    {
      return_value___errno_location_93=__errno_location();
      return_value_strerror_94=strerror(*return_value___errno_location_93);
      log_message(4, "Failed to unlink %s: %s", sock_path, return_value_strerror_94);
    }

  }

  signed int return_value_fclose_98;
  if(!(global.daemon == 0) && !(debug_p == 0))
  {
    return_value_fclose_98=fclose(dbg_file);
    if(!(return_value_fclose_98 >= 0))
    {
      signed int *return_value___errno_location_96;
      return_value___errno_location_96=__errno_location();
      char *return_value_strerror_97;
      return_value_strerror_97=strerror(*return_value___errno_location_96);
      log_message(4, "Could not close debug file: %s", return_value_strerror_97);
    }

  }

  _exit(0);
}

// mark_servers
// file servers.h line 39
signed int mark_servers(signed int i, char *label, signed int up)
{
  signed int retval = 0;
  signed int n;
  signed int signal_test;
  pthread_mutex_lock(&servers_lock);
  signal_test = 0;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link5((struct anonymous_3 *)servers);
  n = (signed int)return_value_da_nel_1;
  if(i >= 0)
  {
    if(!(i >= n))
      n = i + 1;

  }

  else
    i = 0;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous_7 *sp = &servers->elem[(signed long int)i];
    _Bool tmp_if_expr_5;
    if(label == ((char *)NULL))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      if(!(sp->label == ((char *)NULL)))
      {
        return_value_strcmp_3=strcmp(sp->label, label);
        tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
    {
      signed int j;
      signed int m;
      unsigned int return_value_da_nel_2;
      return_value_da_nel_2=da_nel_link5((struct anonymous_3 *)sp->atup_a);
      m = (signed int)return_value_da_nel_2;
      if(!(m == 0))
      {
        if((signed int)sp->rootserver >= 2)
        {
          if(up >= 1)
            signal_test = 1;

        }

      }

      j = 0;
      for( ; !(j >= m); j = j + 1)
      {
        struct anonymous_20 *at = &sp->atup_a->elem[(signed long int)j];
        if(up >= 0)
        {
          at->is_up = (char)up;
          at->i_ts=time((signed long int *)(void *)0);
        }

        else
          if(!(at->i_ts == 0l))
          {
            at->i_ts = (signed long int)0;
            signal_test = 1;
          }

      }
    }

  }
  if(!(signal_test == 0))
  {
    signed int return_value_pthread_equal_6;
    return_value_pthread_equal_6=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal_6 == 0))
      retval=start_servstat_thread();

    else
    {
      retest_flag = (signed short int)1;
      retval=pthread_cond_signal(&server_test_cond);
    }
  }

  pthread_mutex_unlock(&servers_lock);
  return retval;
}

// mk_dns_hash
// file hash.h line 61
static inline void mk_dns_hash()
{
  signed int i = 0;
  for( ; !(i >= 1024); i = i + 1)
    hash_buckets[(signed long int)i] = (struct dns_hash_ent_s *)(void *)0;
}

// mk_error_reply
// file dns_answer.c line 1133
static void mk_error_reply(unsigned short int id, unsigned short int opcode, unsigned short int rescode, struct anonymous_29 *rep)
{
  rep->id = id;
  rep->qr = (unsigned int)1;
  rep->opcode = (unsigned int)opcode;
  rep->aa = (unsigned int)0;
  rep->tc = (unsigned int)0;
  rep->rd = (unsigned int)0;
  rep->ra = (unsigned int)1;
  rep->z = (unsigned int)0;
  rep->ad = (unsigned int)0;
  rep->cd = (unsigned int)0;
  rep->rcode = (unsigned int)rescode;
  rep->qdcount = (unsigned short int)0;
  rep->ancount = (unsigned short int)0;
  rep->nscount = (unsigned short int)0;
  rep->arcount = (unsigned short int)0;
}

// mk_flag_val
// file cache.h line 187
static inline unsigned int mk_flag_val(struct anonymous_7 *server)
{
  unsigned int fl = (unsigned int)0;
  if(server->purge_cache == 0)
    fl = fl | (unsigned int)32;

  if(!(server->nocache == 0))
    fl = fl | (unsigned int)8;

  if(!(server->rootserver == 0))
    fl = fl | (unsigned int)64;

  return fl;
}

// mk_netmask4
// file conf-parser.c line 1903
static inline unsigned int mk_netmask4(signed int len)
{
  unsigned int m;
  unsigned int return_value_htonl_1;
  if(!(len >= 1))
    return (unsigned int)0;

  else
  {
    m = ~((unsigned int)0);
    unsigned int tmp_if_expr_2;
    if(!(len >= 32))
    {
      return_value_htonl_1=htonl(m << 32 - len);
      tmp_if_expr_2 = return_value_htonl_1;
    }

    else
      tmp_if_expr_2 = m;
    return tmp_if_expr_2;
  }
}

// mk_netmask6
// file conf-parser.c line 1915
static inline void mk_netmask6(struct in6_addr *m, signed int len)
{
  unsigned int *ma = (unsigned int *)m;
  ma[(signed long int)0]=mk_netmask4(len);
  len = len - 32;
  ma[(signed long int)1]=mk_netmask4(len);
  len = len - 32;
  ma[(signed long int)2]=mk_netmask4(len);
  len = len - 32;
  ma[(signed long int)3]=mk_netmask4(len);
}

// needs_intermittent_testing
// file servers.h line 56
static inline signed int needs_intermittent_testing(struct anonymous_7 *sp)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(sp->interval >= 1l)
  {
    if(!((signed int)sp->uptest == 5))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = sp->scheme[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// needs_testing
// file servers.h line 49
static inline signed int needs_testing(struct anonymous_7 *sp)
{
  _Bool tmp_if_expr_1;
  if(sp->interval >= 1l)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = sp->interval == (signed long int)-2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
  {
    if(!((signed int)sp->uptest == 5))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = sp->scheme[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return (signed int)tmp_if_expr_3;
}

// needs_testing_link1
// file servers.h line 49
static inline signed int needs_testing_link1(struct anonymous_7 *sp_link1)
{
  _Bool tmp_if_expr_1_link1;
  if(sp_link1->interval >= 1l)
    tmp_if_expr_1_link1 = (_Bool)1;

  else
    tmp_if_expr_1_link1 = sp_link1->interval == (signed long int)-2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3_link1;
  _Bool tmp_if_expr_2_link1;
  if(tmp_if_expr_1_link1)
  {
    if(!((signed int)sp_link1->uptest == 5))
      tmp_if_expr_2_link1 = (_Bool)1;

    else
      tmp_if_expr_2_link1 = sp_link1->scheme[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_3_link1 = tmp_if_expr_2_link1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3_link1 = (_Bool)0;
  return (signed int)tmp_if_expr_3_link1;
}

// negate_cent
// file cache.h line 205
void negate_cent(struct anonymous_0 *cent, signed long int ttl, signed long int ts)
{
  signed int i;
  signed int return_value_del_rrset_2;
  if((1 & (signed int)cent->flags) == 0)
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      struct anonymous *negate_cent__1__1__1__1__rrs = cent->_anon0.rr.rrmu[(signed long int)i];
      if(!(negate_cent__1__1__1__1__rrs == ((struct anonymous *)NULL)))
      {
        signed int return_value_del_rrset_1;
        return_value_del_rrset_1=del_rrset(negate_cent__1__1__1__1__rrs);
        cent->cs = cent->cs - (unsigned long int)return_value_del_rrset_1;
      }

    }
    struct anonymous **rrext = cent->_anon0.rr.rrext;
    if(!(rrext == ((struct anonymous **)NULL)))
    {
      i = 0;
      for( ; !(i >= 39); i = i + 1)
      {
        struct anonymous *rrs = rrext[(signed long int)i];
        if(!(rrs == ((struct anonymous *)NULL)))
        {
          return_value_del_rrset_2=del_rrset(rrs);
          cent->cs = cent->cs - (unsigned long int)return_value_del_rrset_2;
        }

      }
      free((void *)rrext);
      cent->cs = cent->cs - sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39;
    }

    cent->num_rrs = (unsigned short int)0;
    cent->flags = cent->flags | (unsigned short int)1;
    cent->_anon0.neg.lent = (struct rr_lent_s *)(void *)0;
  }

  cent->_anon0.neg.ttl = ttl;
  cent->_anon0.neg.ts = ts;
}

// p_cancel_query
// file dns_query.c line 1926
static void p_cancel_query(struct anonymous_5 *st)
{
  switch((signed int)st->state)
  {
    case 2:

    case 3:

    case 5:
      close(st->sock);
    case 1:

    case 4:
    {
      free((void *)st->recvbuf);
      free((void *)st->msg);
    }
    default:
      if(!((signed int)st->state == 0))
      {
        if(!((signed int)st->state == 8))
          st->state = (signed short int)7;

      }

  }
}

// p_dns_cached_resolve
// file dns_query.c line 3340
static signed int p_dns_cached_resolve(struct anonymous_4 *q, const unsigned char *name, signed int thint, struct anonymous_0 **cachedp, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa)
{
  struct anonymous_0 *cached = (struct anonymous_0 *)(void *)0;
  signed int rc;
  unsigned short int flags = (unsigned short int)0;
  unsigned char _debugstrbuf[256l];
  const unsigned char *return_value_rhn2str_1;
  const char *return_value_get_tname_2;
  if(!(debug_p == 0))
  {
    return_value_rhn2str_1=rhn2str(name, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
    return_value_get_tname_2=get_tname(thint);
    debug_msg(0, "Starting cached resolve for: %s, query %s\n", return_value_rhn2str_1, return_value_get_tname_2);
  }

  rc=lookup_cache_status(name, thint, &cached, &flags, queryts, c_soa);
  if(rc == 0)
  {
    *cachedp = cached;
    return 0;
  }

  else
    if(rc == 3)
      return 3;

  if(!(global.onquery == 0))
    test_onquery();

  if((2 & (signed int)flags) == 0 && !(global.lndown_kluge == 0))
  {
    signed int i;
    signed int n;
    signed int linkdown = 1;
    lock_server_data();
    unsigned int return_value_da_nel_3;
    return_value_da_nel_3=da_nel_link2((struct anonymous_3 *)servers);
    n = (signed int)return_value_da_nel_3;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous_7 *sp = &servers->elem[(signed long int)i];
      if(!((signed int)sp->rootserver >= 2))
      {
        signed int j;
        signed int m;
        unsigned int return_value_da_nel_4;
        return_value_da_nel_4=da_nel_link2((struct anonymous_3 *)sp->atup_a);
        m = (signed int)return_value_da_nel_4;
        j = 0;
        for( ; !(j >= m); j = j + 1)
          if(!(sp->atup_a->elem[(signed long int)j].is_up == 0))
          {
            linkdown = 0;
            goto done;
          }

      }

    }

  done:
    ;
    unlock_server_data();
    if(!(linkdown == 0))
    {
      if(!(debug_p == 0))
        debug_msg(0, "Link is down.\n");

      rc = 2;
      goto cleanup_return;
    }

  }

  if(!(rc == 0xfffb))
  {
    struct anonymous_0 *ent;
    if(!(debug_p == 0))
      debug_msg(0, "Trying name servers.\n");

    if(!(q == ((struct anonymous_4 *)NULL)))
      rc=p_recursive_query(q, name, thint, &ent, (signed int *)(void *)0, hops, qslist, qhlist, c_soa);

    else
      rc=p_dns_resolve(name, thint, &ent, hops, qhlist, c_soa);
    if(!(rc == 0))
    {
      if(rc == 2 && !((32 & (signed int)flags) == 0) && !(cached == ((struct anonymous_0 *)NULL)))
      {
        if(!(debug_p == 0))
          debug_msg(0, "Falling back to cached record.\n");

      }

      else
        goto cleanup_return;
    }

    else
    {
      if(!(cached == ((struct anonymous_0 *)NULL)))
      {
        free_cent(cached);
        free((void *)cached);
      }

      cached = ent;
    }
  }

  else
    if(!(debug_p == 0))
      debug_msg(0, "Using cached record.\n");

  *cachedp = cached;
  return 0;

cleanup_return:
  ;
  if(!(cached == ((struct anonymous_0 *)NULL)))
  {
    free_cent(cached);
    free((void *)cached);
  }

  return rc;
}

// p_dns_resolve
// file dns_query.c line 3066
static signed int p_dns_resolve(const unsigned char *name, signed int thint, struct anonymous_0 **cachedp, signed int hops, struct qhintnode_s *qhlist, unsigned char *c_soa)
{
  signed int i;
  signed int n;
  signed int rc;
  signed int one_up = 0;
  signed int seenrootserv = 0;
  struct anonymous_4 *serv = (struct anonymous_4 *)(void *)0;
  struct rejectlist_s *rejectlist = (struct rejectlist_s *)(void *)0;
  lock_server_data();
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link2((struct anonymous_3 *)servers);
  n = (signed int)return_value_da_nel_1;
  i = 0;
  signed int return_value_use_server_15;
  signed long int return_value_random_3;
  signed long int return_value_random_6;
  const char *return_value_pdnsd_a2str_10;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous_7 *sp = &servers->elem[(signed long int)i];
    if(!((signed int)sp->rootserver >= 2))
    {
      return_value_use_server_15=use_server(sp, name);
      if(!(return_value_use_server_15 == 0))
      {
        signed int m;
        unsigned int return_value_da_nel_2;
        return_value_da_nel_2=da_nel_link2((struct anonymous_3 *)sp->atup_a);
        m = (signed int)return_value_da_nel_2;
        if(m >= 1)
        {
          struct rejectlist_s *rjl = (struct rejectlist_s *)(void *)0;
          signed int j = 0;
          signed int jstart = 0;
          if(!(sp->rand_servers == 0))
          {
            return_value_random_3=random();
            jstart = (signed int)(return_value_random_3 % (signed long int)m);
            j = jstart;
          }

          do
          {
            struct anonymous_20 *at = &sp->atup_a->elem[(signed long int)j];
            if(!(at->is_up == 0))
            {
              if(!(sp->rootserver == 0))
              {
                if(seenrootserv == 0)
                {
                  signed int nseg;
                  signed int mseg = 1;
                  signed int l = 0;
                  const unsigned char *topdomain = (const unsigned char *)(void *)0;
                  struct anonymous_14 *adrs = (struct anonymous_14 *)(void *)0;
                  seenrootserv = 1;
                  unsigned int return_value_rhnsegcnt_4;
                  return_value_rhnsegcnt_4=rhnsegcnt_link1(name);
                  nseg = (signed int)return_value_rhnsegcnt_4;
                  if(nseg >= 2)
                  {
                    unsigned int rem;
                    static const unsigned char rhn_arpa[6l] = { (const unsigned char)4, (const unsigned char)97, (const unsigned char)114, (const unsigned char)112, (const unsigned char)97, (const unsigned char)0 };
                    domain_match(rhn_arpa, name, &rem, (unsigned int *)(void *)0);
                    if(rem == 0u)
                      mseg = 3;

                  }

                  if(mseg >= nseg)
                  {
                    if(nseg >= 1)
                      mseg = nseg - 1;

                    else
                      mseg = 0;
                  }

                  for( ; mseg >= 1; mseg = mseg - 1)
                  {
                    topdomain=skipsegs_link1(name, (unsigned int)(nseg - mseg));
                    adrs=lookup_ns(topdomain);
                    unsigned int return_value_da_nel_5;
                    return_value_da_nel_5=da_nel_link2((struct anonymous_3 *)adrs);
                    l = (signed int)return_value_da_nel_5;
                    if(l >= 1)
                      break;

                    if(!(adrs == ((struct anonymous_14 *)NULL)))
                      free((void *)adrs);

                  }
                  if(l >= 1)
                  {
                    signed int k = 0;
                    signed int kstart = 0;
                    if(!(sp->rand_servers == 0))
                    {
                      return_value_random_6=random();
                      kstart = (signed int)(return_value_random_6 % (signed long int)l);
                      k = kstart;
                    }

                    _Bool tmp_if_expr_7;
                    if(!(sp->reject_a4 == ((struct anonymous_10 *)NULL)))
                      tmp_if_expr_7 = (_Bool)1;

                    else
                      tmp_if_expr_7 = sp->reject_a6 != (struct anonymous_12 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_7)
                    {
                      if(!(sp->rejectrecursively == 0))
                      {
                        if(rjl == ((struct rejectlist_s *)NULL))
                        {
                          rjl=add_rejectlist(rejectlist, sp);
                          if(rjl == ((struct rejectlist_s *)NULL))
                          {
                            one_up = 0;
                            free((void *)adrs);
                            goto done;
                          }

                          rejectlist = rjl;
                        }

                      }

                    }

                    do
                    {
                      unsigned int return_value_mk_flag_val_8;
                      return_value_mk_flag_val_8=mk_flag_val(sp);
                      one_up=add_qserv(&serv, &adrs->elem[(signed long int)k], 53, sp->timeout, return_value_mk_flag_val_8 & (unsigned int)~(2 | 4 | 16 | 64), (signed int)sp->nocache, sp->lean_query, sp->edns_query, (char)2, (char)0, (char)!(global.paranoid != 0), topdomain, rjl);
                      if(one_up == 0)
                      {
                        free((void *)adrs);
                        goto done;
                      }

                      k = k + 1;
                      if(k == l)
                        k = 0;

                    }
                    while(!(k == kstart));
                    free((void *)adrs);
                    char _debugsockabuf[46l];
                    if(!(debug_p == 0))
                    {
                      union anonymous_6 *tmp_if_expr_9;
                      if(!(run_ipv4 == 0))
                        tmp_if_expr_9 = (union anonymous_6 *)&(&at->a)->ipv4;

                      else
                        tmp_if_expr_9 = (union anonymous_6 *)&(&at->a)->ipv6;
                      return_value_pdnsd_a2str_10=pdnsd_a2str(tmp_if_expr_9, _debugsockabuf, 46);
                      debug_msg(0, "Not querying root-server %s, using cached information instead.\n", return_value_pdnsd_a2str_10);
                    }

                    seenrootserv = 2;
                    break;
                  }

                }

                else
                  if(seenrootserv == 2)
                    break;

              }

              _Bool tmp_if_expr_11;
              if(!(sp->reject_a4 == ((struct anonymous_10 *)NULL)))
                tmp_if_expr_11 = (_Bool)1;

              else
                tmp_if_expr_11 = sp->reject_a6 != (struct anonymous_12 *)(void *)0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_11)
              {
                if(rjl == ((struct rejectlist_s *)NULL))
                {
                  rjl=add_rejectlist(rejectlist, sp);
                  if(rjl == ((struct rejectlist_s *)NULL))
                  {
                    one_up = 0;
                    goto done;
                  }

                  rejectlist = rjl;
                }

              }

              unsigned int return_value_mk_flag_val_12;
              return_value_mk_flag_val_12=mk_flag_val(sp);
              signed int tmp_if_expr_13;
              if(!(sp->rootserver == 0))
                tmp_if_expr_13 = 3;

              else
                tmp_if_expr_13 = (signed int)!(sp->is_proxy != 0);
              signed int return_value_needs_testing_14;
              return_value_needs_testing_14=needs_testing(sp);
              one_up=add_qserv(&serv, &at->a, (signed int)sp->port, sp->timeout, return_value_mk_flag_val_12, (signed int)sp->nocache, sp->lean_query, sp->edns_query, (char)tmp_if_expr_13, (char)return_value_needs_testing_14, (char)1, (const unsigned char *)(void *)0, rjl);
              if(one_up == 0)
                goto done;

            }

            j = j + 1;
            if(j == m)
              j = 0;

          }
          while(!(j == jstart));
        }

      }

    }

  }

done:
  ;
  unlock_server_data();
  if(!(one_up == 0))
  {
    struct anonymous_0 *cached;
    signed int nocache;
    rc=p_recursive_query(serv, name, thint, &cached, &nocache, hops, (struct qstatnode_s *)(void *)0, qhlist, c_soa);
    if(rc == 0)
    {
      if(nocache == 0)
      {
        struct anonymous_0 *tc;
        add_cache(cached);
        tc=lookup_cache(name, (signed int *)(void *)0);
        if(!(tc == ((struct anonymous_0 *)NULL)))
        {
          free_cent(cached);
          free((void *)cached);
          cached = tc;
        }

        else
          if(!(debug_p == 0))
            debug_msg(0, "p_dns_resolve: merging answer with cache failed, using local cent copy.\n");

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "p_dns_resolve: nocache.\n");

      *cachedp = cached;
    }

  }

  else
  {
    if(!(debug_p == 0))
      debug_msg(0, "No server is marked up and allowed for this domain.\n");

    rc = 2;
  }
  del_qserv(serv);
  free_rejectlist(rejectlist);
  return rc;
}

// p_exec_query
// file dns_query.c line 1137
static signed int p_exec_query(struct anonymous_0 **entp, const unsigned char *name, signed int thint, struct anonymous_5 *st, struct _dynamic_list_head **ns, unsigned char *c_soa)
{
  signed int rv;
  signed int rcode;
  unsigned short int rd;
  const char *return_value_pdnsd_a2str_11;
  const char *return_value_get_ename_12;
  char *return_value_dnsflags2str_13;
  const char *return_value_pdnsd_a2str_16;
  const char *return_value_get_ename_17;
  const char *return_value_pdnsd_a2str_19;
  const char *return_value_get_ename_20;
  unsigned long int p_exec_query__1__1__13__2__transl;
  const char *return_value_pdnsd_a2str_25;
  const char *return_value_get_ename_26;
  _Bool tmp_if_expr_30;
  const char *return_value_pdnsd_a2str_29;
  const char *return_value_pdnsd_a2str_32;
  switch((signed int)st->state)
  {
    case 0:
    {
      unsigned long int transl;
      unsigned long int allocsz;
      unsigned int rrnlen = (unsigned int)0;
      allocsz = sizeof(struct anonymous_28) /*14ul*/ ;
      if(!(name == ((const unsigned char *)NULL)))
      {
        rrnlen=rhnlen_link3(name);
        allocsz = allocsz + (unsigned long int)(rrnlen + (unsigned int)4);
        if(!(st->edns_query == 0))
          allocsz = allocsz + (unsigned long int)(1 + 10);

      }

      void *return_value_malloc_1;
      return_value_malloc_1=malloc(allocsz);
      st->msg = (struct anonymous_28 *)return_value_malloc_1;
      if(st->msg == ((struct anonymous_28 *)NULL))
      {
        st->state = (signed short int)8;
        return 0xffff;
      }

      st->myrid=get_rand16();
      st->msg->hdr.id=htons(st->myrid);
      st->msg->hdr.qr = (unsigned int)0;
      st->msg->hdr.opcode = (unsigned int)0;
      st->msg->hdr.aa = (unsigned int)0;
      st->msg->hdr.tc = (unsigned int)0;
      _Bool tmp_if_expr_2;
      if(!(name == ((const unsigned char *)NULL)))
        tmp_if_expr_2 = st->trusted != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      st->msg->hdr.rd = (unsigned int)tmp_if_expr_2;
      st->msg->hdr.ra = (unsigned int)0;
      st->msg->hdr.z = (unsigned int)0;
      st->msg->hdr.ad = (unsigned int)0;
      st->msg->hdr.cd = (unsigned int)0;
      st->msg->hdr.rcode = (unsigned int)0;
      st->msg->hdr.qdcount=htons((unsigned short int)(name != (const unsigned char *)(void *)0));
      st->msg->hdr.ancount = (unsigned short int)0;
      st->msg->hdr.nscount = (unsigned short int)0;
      st->msg->hdr.arcount = (unsigned short int)0;
      transl = sizeof(struct anonymous_29) /*12ul*/ ;
      if(!(name == ((const unsigned char *)NULL)))
      {
        unsigned char *p;
        void *return_value_mempcpy_3;
        return_value_mempcpy_3=mempcpy((void *)(unsigned char *)(&st->msg->hdr + (signed long int)1), (const void *)name, (unsigned long int)rrnlen);
        p = (unsigned char *)return_value_mempcpy_3;
        unsigned short int qtype = (unsigned short int)(st->lean_query != 0 ? thint : 255);
        do
        {
          unsigned short int t_s = (unsigned short int)qtype;
          unsigned char *t_cp = (unsigned char *)p;
          unsigned char *tmp_post_4 = t_cp;
          t_cp = t_cp + 1l;
          *tmp_post_4 = (unsigned char)((signed int)t_s >> 8);
          unsigned char *tmp_post_5 = t_cp;
          t_cp = t_cp + 1l;
          *tmp_post_5 = (unsigned char)t_s;
          p = (unsigned char *)(void *)t_cp;
        }
        while((_Bool)0);
        do
        {
          unsigned short int p_exec_query__1__1__1__3__2__t_s = (unsigned short int)1;
          unsigned char *p_exec_query__1__1__1__3__2__t_cp = (unsigned char *)p;
          unsigned char *tmp_post_6 = p_exec_query__1__1__1__3__2__t_cp;
          p_exec_query__1__1__1__3__2__t_cp = p_exec_query__1__1__1__3__2__t_cp + 1l;
          *tmp_post_6 = (unsigned char)((signed int)p_exec_query__1__1__1__3__2__t_s >> 8);
          unsigned char *tmp_post_7 = p_exec_query__1__1__1__3__2__t_cp;
          p_exec_query__1__1__1__3__2__t_cp = p_exec_query__1__1__1__3__2__t_cp + 1l;
          *tmp_post_7 = (unsigned char)p_exec_query__1__1__1__3__2__t_s;
          p = (unsigned char *)(void *)p_exec_query__1__1__1__3__2__t_cp;
        }
        while((_Bool)0);
        transl = transl + (unsigned long int)(rrnlen + (unsigned int)4);
        if(!(st->edns_query == 0))
          add_opt_pseudo_rr(&st->msg, &transl, &allocsz, (unsigned short int)global.udpbufsize, (unsigned short int)0, (unsigned short int)0, (unsigned short int)0);

      }

      st->transl = (unsigned short int)transl;
      st->msg->len=htons(st->transl);
      st->recvbuf = (struct anonymous_29 *)(void *)0;
      _Bool tmp_if_expr_8;
      if((signed int)st->qm == 12)
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = (signed int)st->qm == 15 ? (_Bool)1 : (_Bool)0;
      st->state = (signed short int)(tmp_if_expr_8 ? 4 : 1);
    }
    case 1:

    case 2:

    case 3:

    case 4:

    case 5:
    {
      do
      {

      tryagain:
        ;
        rv=p_query_sm(st);
        if(rv == -1)
          return -1;

        if(!(rv == 0))
        {
          free((void *)st->msg);
          free((void *)st->recvbuf);
          st->state = (signed short int)8;
          if(!(st->needs_testing == 0))
          {
            if(st->s_errno == 64 || st->s_errno == 92 || st->s_errno == 100 || st->s_errno == 101 || st->s_errno == 111 || st->s_errno == 112 || st->s_errno == 113)
            {
              union anonymous_6 *tmp_if_expr_9;
              if(!(run_ipv4 == 0))
                tmp_if_expr_9 = (union anonymous_6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr_9 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
              sched_server_test(tmp_if_expr_9, 1, 0);
              st->needs_testing = (char)0;
            }

          }

          return rv;
        }

        char p_exec_query__1__1__4___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_10;
          if(!(run_ipv4 == 0))
            tmp_if_expr_10 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_10 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_11=pdnsd_a2str(tmp_if_expr_10, p_exec_query__1__1__4___debugsockabuf, 46);
          debug_msg(0, "Received reply from %s (msg len=%u).\n", return_value_pdnsd_a2str_11, st->recvl);
        }

        if(!((unsigned long int)st->recvl >= sizeof(struct anonymous_29) /*12ul*/ ))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Message too short!\n");

          goto discard_reply;
        }

        unsigned short int recvid;
        recvid=ntohs(st->recvbuf->id);
        if(!(recvid == st->myrid))
        {
          if(!(debug_p == 0))
            debug_msg(0, "ID mismatch: expected %04x, got %04x!\n", st->myrid, recvid);

          goto discard_reply;
        }

        if(!((signed int)st->recvbuf->qr == 1))
        {
          if(!(debug_p == 0))
            debug_msg(0, "The QR bit indicates this is a query, not a response!\n");

          goto discard_reply;
        }

        if(!((signed int)st->recvbuf->opcode == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Not a reply to a standard query (opcode=%u).\n", st->recvbuf->opcode);

          goto discard_reply;
        }

        rcode = (signed int)st->recvbuf->rcode;
        char flgsbuf[22l];
        if(!(debug_p == 0))
        {
          return_value_get_ename_12=get_ename(rcode);
          return_value_dnsflags2str_13=dnsflags2str(st->recvbuf, flgsbuf);
          debug_msg(0, "rcode=%u (%s), flags:%s\n", rcode, return_value_get_ename_12, return_value_dnsflags2str_13);
        }

        if(!((signed int)st->recvbuf->z == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Malformed response (nonzero Z bit).\n");

          goto discard_reply;
        }

        if(!(st->needs_testing == 0))
        {
          union anonymous_6 *tmp_if_expr_14;
          if(!(run_ipv4 == 0))
            tmp_if_expr_14 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_14 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          sched_server_test(tmp_if_expr_14, 1, 1);
          st->needs_testing = (char)0;
        }

        rv = rcode;
        if(rcode == 0 || rcode == 3)
        {
          st->state = (signed short int)8;
          goto __CPROVER_DUMP_L75;
        }

        if(entp == ((struct anonymous_0 **)NULL))
          goto discard_reply;

        if(rcode == 2 || rcode == 4 || rcode == 5)
        {
          _Bool tmp_if_expr_23;
          if(!(st->msg->hdr.rd == 0u))
            tmp_if_expr_23 = !(st->recvbuf->ra != 0u) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_23 = (_Bool)0;
          if(tmp_if_expr_23)
          {
            char p_exec_query__1__1__13__1__1__1___debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              union anonymous_6 *tmp_if_expr_15;
              if(!(run_ipv4 == 0))
                tmp_if_expr_15 = (union anonymous_6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr_15 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
              return_value_pdnsd_a2str_16=pdnsd_a2str(tmp_if_expr_15, p_exec_query__1__1__13__1__1__1___debugsockabuf, 46);
              return_value_get_ename_17=get_ename(rcode);
              debug_msg(0, "Server %s returned error code: %s. Maybe does not support recursive query? Querying non-recursively.\n", return_value_pdnsd_a2str_16, return_value_get_ename_17);
            }

            st->msg->hdr.rd = (unsigned int)0;
            goto resetstate_tryagain;
          }

          else
          {
            _Bool tmp_if_expr_21;
            if(!(rcode == 2))
              tmp_if_expr_21 = st->edns_query != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_21 = (_Bool)0;
            _Bool tmp_if_expr_22;
            if(tmp_if_expr_21)
              tmp_if_expr_22 = st->msg->hdr.arcount != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_22 = (_Bool)0;
            if(tmp_if_expr_22)
              goto try_withoutedns;

            else
              if(!(st->recvbuf->ancount == 0))
              {
                if((signed int)st->auth_serv == 2)
                {
                  char p_exec_query__1__1__13__1__2__1___debugsockabuf[46l];
                  if(!(debug_p == 0))
                  {
                    union anonymous_6 *tmp_if_expr_18;
                    if(!(run_ipv4 == 0))
                      tmp_if_expr_18 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                    else
                      tmp_if_expr_18 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                    return_value_pdnsd_a2str_19=pdnsd_a2str(tmp_if_expr_18, p_exec_query__1__1__13__1__2__1___debugsockabuf, 46);
                    return_value_get_ename_20=get_ename(rcode);
                    debug_msg(0, "Server %s returned error code: %s, but the answer section is not empty. Using the answer tentatively.\n", return_value_pdnsd_a2str_19, return_value_get_ename_20);
                  }

                  st->failed = (char)3;
                  st->state = (signed short int)8;
                  goto __CPROVER_DUMP_L75;
                }

              }

          }
          goto discard_reply;
        }

        if(!(rcode == 1))
          goto discard_reply;

        if(st->edns_query == 0)
          goto discard_reply;

        if(st->msg->hdr.arcount == 0)
          goto discard_reply;


      try_withoutedns:
        ;
        char p_exec_query__1__1__13__2__1___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_24;
          if(!(run_ipv4 == 0))
            tmp_if_expr_24 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_24 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_25=pdnsd_a2str(tmp_if_expr_24, p_exec_query__1__1__13__2__1___debugsockabuf, 46);
          return_value_get_ename_26=get_ename(rcode);
          debug_msg(0, "Server %s returned error code: %s. Maybe cannot handle EDNS? Querying with empty additional section.\n", return_value_pdnsd_a2str_25, return_value_get_ename_26);
        }

        p_exec_query__1__1__13__2__transl=remove_opt_pseudo_rr(st->msg, (unsigned long int)st->transl);
        if(!(p_exec_query__1__1__13__2__transl == 0ul))
          tmp_if_expr_30 = (signed int)st->msg->hdr.arcount == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_30 = (_Bool)0;
        if(!tmp_if_expr_30)
          break;

        st->transl = (unsigned short int)p_exec_query__1__1__13__2__transl;
        st->msg->len=htons(st->transl);
        st->edns_query = (char)0;

      resetstate_tryagain:
        ;
        st->myrid=get_rand16();
        st->msg->hdr.id=htons(st->myrid);
        _Bool tmp_if_expr_27;
        if((signed int)st->qm == 12)
          tmp_if_expr_27 = (_Bool)1;

        else
          tmp_if_expr_27 = (signed int)st->qm == 15 ? (_Bool)1 : (_Bool)0;
        st->state = (signed short int)(tmp_if_expr_27 ? 4 : 1);
      }
      while((_Bool)1);
      char p_exec_query__1__1__13__2__3__1___debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous_6 *tmp_if_expr_28;
        if(!(run_ipv4 == 0))
          tmp_if_expr_28 = (union anonymous_6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr_28 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str_29=pdnsd_a2str(tmp_if_expr_28, p_exec_query__1__1__13__2__3__1___debugsockabuf, 46);
        debug_msg(0, "Internal error: could not remove additional section from query to server %s\n", return_value_pdnsd_a2str_29);
      }


    discard_reply:
      ;
      free((void *)st->msg);
      free((void *)st->recvbuf);
      st->state = (signed short int)8;
      if(!(entp == ((struct anonymous_0 **)NULL)))
      {
        char p_exec_query__1__1__14__1___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_31;
          if(!(run_ipv4 == 0))
            tmp_if_expr_31 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_31 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_32=pdnsd_a2str(tmp_if_expr_31, p_exec_query__1__1__14__1___debugsockabuf, 46);
          debug_msg(0, "Discarding reply from server %s\n", return_value_pdnsd_a2str_32);
        }

      }

      if(!(rv == 0))
        return rv;

      return 2;
    }
    default:
    {
      st->state = (signed short int)8;
      return 2;
    }
  }

__CPROVER_DUMP_L75:
  ;
  rd = (unsigned short int)st->msg->hdr.rd;
  free((void *)st->msg);
  const char *return_value_pdnsd_a2str_34;
  const char *return_value_pdnsd_a2str_37;
  const char *return_value_pdnsd_a2str_39;
  const char *return_value_pdnsd_a2str_42;
  const char *return_value_pdnsd_a2str_48;
  unsigned short int return_value_ntohs_53;
  const char *return_value_pdnsd_a2str_55;
  const char *return_value_pdnsd_a2str_57;
  const char *return_value_get_ename_58;
  _Bool tmp_if_expr_61;
  const char *return_value_pdnsd_a2str_60;
  struct anonymous *return_value_getrrset_72;
  _Bool tmp_if_expr_74;
  const char *return_value_pdnsd_a2str_79;
  const unsigned char *return_value_rhn2str_80;
  const char *return_value_inet_ntop_81;
  const char *return_value_pdnsd_a2str_84;
  const unsigned char *return_value_rhn2str_85;
  const char *return_value_inet_ntop_86;
  const char *return_value_pdnsd_a2str_88;
  const char *return_value_get_ename_89;
  _Bool tmp_if_expr_93;
  const unsigned char *return_value_skipsegs_91;
  const unsigned char *return_value_rhn2str_92;
  struct anonymous *tmp_if_expr_101;
  const unsigned char *return_value_rhn2str_103;
  const unsigned char *return_value_rhn2str_104;
  const char *return_value_pdnsd_a2str_106;
  struct anonymous *return_value_getrrset_124;
  _Bool tmp_if_expr_122;
  _Bool tmp_if_expr_121;
  _Bool tmp_if_expr_120;
  _Bool tmp_if_expr_110;
  const unsigned char *tmp_if_expr_112;
  const unsigned char *return_value_skipsegs_111;
  _Bool tmp_if_expr_114;
  struct anonymous *tmp_if_expr_113;
  _Bool tmp_if_expr_115;
  const char *return_value_getrrtpname_117;
  const unsigned char *return_value_rhn2str_118;
  unsigned char *return_value_skiprhn_128;
  void *return_value_dlist_next_127;
  unsigned int return_value_rhnlen_131;
  const char *return_value_pdnsd_a2str_141;
  void *return_value_malloc_142;
  const char *return_value_pdnsd_a2str_145;
  const unsigned char *return_value_rhn2str_146;
  const unsigned char *return_value_rhn2str_147;
  const unsigned char *return_value_rhn2str_149;
  const unsigned char *return_value_rhn2str_150;
  const char *return_value_pdnsd_a2str_154;
  unsigned int return_value_da_nel_156;
  if(!(entp == ((struct anonymous_0 **)NULL)))
  {
    signed long int queryts;
    queryts=time((signed long int *)(void *)0);
    unsigned long int lcnt = (unsigned long int)st->recvl - sizeof(struct anonymous_29) /*12ul*/ ;
    unsigned char *rrp = (unsigned char *)(st->recvbuf + (signed long int)1);
    struct anonymous_16 *secs[3l] = { (struct anonymous_16 *)(void *)0, (struct anonymous_16 *)(void *)0, (struct anonymous_16 *)(void *)0 };
    unsigned short int p_exec_query__1__2__qtype;
    unsigned short int flags;
    unsigned short int aa;
    unsigned short int neg_ans = (unsigned short int)0;
    unsigned short int reject_ans = (unsigned short int)0;
    unsigned short int num_ns = (unsigned short int)0;
    signed int numoptrr;
    struct anonymous_17 ednsinfo = { .udpsize=(unsigned short int)0, .rcode=0, .version=0,
    .do_flg=0 };
    unsigned short int return_value_ntohs_35;
    return_value_ntohs_35=ntohs(st->recvbuf->qdcount);
    if(!((signed int)return_value_ntohs_35 == 1))
    {
      char p_exec_query__1__2__1__1___debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous_6 *tmp_if_expr_33;
        if(!(run_ipv4 == 0))
          tmp_if_expr_33 = (union anonymous_6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr_33 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str_34=pdnsd_a2str(tmp_if_expr_33, p_exec_query__1__2__1__1___debugsockabuf, 46);
        debug_msg(0, "Bad number of query records in answer from %s\n", return_value_pdnsd_a2str_34);
      }

      rv = 2;
    }

    else
    {
      unsigned char nbuf[256l];
      rv=decompress_name((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, nbuf, (unsigned int *)(void *)0);
      if(!(rv == 0))
      {
        char p_exec_query__1__2__2__1__1___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_36;
          if(!(run_ipv4 == 0))
            tmp_if_expr_36 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_36 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_37=pdnsd_a2str(tmp_if_expr_36, p_exec_query__1__2__2__1__1___debugsockabuf, 46);
          debug_msg(0, "Cannot decompress QNAME in answer from %s\n", return_value_pdnsd_a2str_37);
        }

        rv = 2;
      }

      else
      {
        signed int return_value_rhnicmp_40;
        return_value_rhnicmp_40=rhnicmp_link1(nbuf, name);
        if(return_value_rhnicmp_40 == 0)
        {
          char p_exec_query__1__2__2__2__1___debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous_6 *tmp_if_expr_38;
            if(!(run_ipv4 == 0))
              tmp_if_expr_38 = (union anonymous_6 *)&st->a.sin4.sin_addr;

            else
              tmp_if_expr_38 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
            return_value_pdnsd_a2str_39=pdnsd_a2str(tmp_if_expr_38, p_exec_query__1__2__2__2__1___debugsockabuf, 46);
            debug_msg(0, "Answer from %s does not match query.\n", return_value_pdnsd_a2str_39);
          }

          rv = 2;
        }

        else
        {
          p_exec_query__1__2__qtype = (unsigned short int)(st->lean_query != 0 ? thint : 255);
          if(!(lcnt >= 4ul))
          {
            char p_exec_query__1__2__3__1___debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              union anonymous_6 *tmp_if_expr_41;
              if(!(run_ipv4 == 0))
                tmp_if_expr_41 = (union anonymous_6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr_41 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
              return_value_pdnsd_a2str_42=pdnsd_a2str(tmp_if_expr_41, p_exec_query__1__2__3__1___debugsockabuf, 46);
              debug_msg(0, "Format error in reply from %s (message truncated in qtype or qclass).\n", return_value_pdnsd_a2str_42);
            }

            rv = 2;
          }

          else
          {
            unsigned short int qt;
            unsigned short int qc;
            do
            {
              unsigned short int p_exec_query__1__2__4__1__t_s;
              const unsigned char *p_exec_query__1__2__4__1__t_cp = (const unsigned char *)rrp;
              const unsigned char *tmp_post_43 = p_exec_query__1__2__4__1__t_cp;
              p_exec_query__1__2__4__1__t_cp = p_exec_query__1__2__4__1__t_cp + 1l;
              p_exec_query__1__2__4__1__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_43 << 8);
              const unsigned char *tmp_post_44 = p_exec_query__1__2__4__1__t_cp;
              p_exec_query__1__2__4__1__t_cp = p_exec_query__1__2__4__1__t_cp + 1l;
              p_exec_query__1__2__4__1__t_s = p_exec_query__1__2__4__1__t_s | (unsigned short int)*tmp_post_44;
              qt = p_exec_query__1__2__4__1__t_s;
              rrp = (unsigned char *)(void *)p_exec_query__1__2__4__1__t_cp;
            }
            while((_Bool)0);
            do
            {
              unsigned short int p_exec_query__1__2__4__2__t_s;
              const unsigned char *p_exec_query__1__2__4__2__t_cp = (const unsigned char *)rrp;
              const unsigned char *tmp_post_45 = p_exec_query__1__2__4__2__t_cp;
              p_exec_query__1__2__4__2__t_cp = p_exec_query__1__2__4__2__t_cp + 1l;
              p_exec_query__1__2__4__2__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_45 << 8);
              const unsigned char *tmp_post_46 = p_exec_query__1__2__4__2__t_cp;
              p_exec_query__1__2__4__2__t_cp = p_exec_query__1__2__4__2__t_cp + 1l;
              p_exec_query__1__2__4__2__t_s = p_exec_query__1__2__4__2__t_s | (unsigned short int)*tmp_post_46;
              qc = p_exec_query__1__2__4__2__t_s;
              rrp = (unsigned char *)(void *)p_exec_query__1__2__4__2__t_cp;
            }
            while((_Bool)0);
            if(!(qt == p_exec_query__1__2__qtype))
            {
              char _debugsockabuf[46l];
              if(!(debug_p == 0))
              {
                union anonymous_6 *tmp_if_expr_47;
                if(!(run_ipv4 == 0))
                  tmp_if_expr_47 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                else
                  tmp_if_expr_47 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                return_value_pdnsd_a2str_48=pdnsd_a2str(tmp_if_expr_47, _debugsockabuf, 46);
                debug_msg(0, "qtype in answer (%u) from %s does not match expected qtype (%u).\n", qt, return_value_pdnsd_a2str_48, p_exec_query__1__2__qtype);
              }

              rv = 2;
            }

            else
            {
              lcnt = lcnt - (unsigned long int)4;
              _Bool tmp_if_expr_49;
              if(!(st->recvbuf->aa == 0u))
                tmp_if_expr_49 = !(st->failed != 0) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_49 = (_Bool)0;
              st->aa = (char)tmp_if_expr_49;
              st->tc = (char)st->recvbuf->tc;
              _Bool tmp_if_expr_50;
              if(!(st->aa == 0))
                tmp_if_expr_50 = !(st->tc != 0) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_50 = (_Bool)0;
              aa = (unsigned short int)tmp_if_expr_50;
              flags = st->flags;
              if(!(aa == 0))
                flags = flags | (unsigned short int)4;

              struct anonymous_3 *return_value_da_grow1_51;
              return_value_da_grow1_51=da_grow1((struct anonymous_3 *)secs[(signed long int)0], (unsigned long int)((struct anonymous_16 *)0)->elem, sizeof(struct anonymous_0) /*104ul*/ , (void (*)(void *))(void *)0);
              secs[(signed long int)0] = (struct anonymous_16 *)return_value_da_grow1_51;
              if(secs[0l] == ((struct anonymous_16 *)NULL))
                rv = 0xffff;

              else
              {
                signed int return_value_init_cent_52;
                return_value_init_cent_52=init_cent(&secs[(signed long int)0]->elem[(signed long int)0], name, (signed long int)0, (signed long int)0, (unsigned int)(aa != 0 && (signed int)p_exec_query__1__2__qtype == 255 ? 4 : 0));
                if(return_value_init_cent_52 == 0)
                  rv = 0xffff;

                else
                {
                  numoptrr = 0;
                  return_value_ntohs_53=ntohs(st->recvbuf->ancount);
                  rv=rrs2cent((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, (signed int)return_value_ntohs_53, (unsigned int)flags, queryts, &secs[(signed long int)0], &numoptrr, &ednsinfo);
                  if(!(numoptrr == 0))
                  {
                    if(!(debug_p == 0))
                      debug_msg(0, "Answer section in reply contains %d OPT pseudo-RRs!\n", numoptrr);

                  }

                  numoptrr = 0;
                  if(rv == 0)
                  {
                    unsigned short int nscount;
                    nscount=ntohs(st->recvbuf->nscount);
                    if(!(nscount == 0))
                    {
                      rv=rrs2cent((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, (signed int)nscount, (unsigned int)((signed int)flags | 16), queryts, &secs[(signed long int)1], &numoptrr, &ednsinfo);
                      if(!(numoptrr == 0))
                      {
                        if(!(debug_p == 0))
                          debug_msg(0, "Authority section in reply contains %d OPT pseudo-RRs!\n", numoptrr);

                      }

                    }

                  }

                  numoptrr = 0;
                  if(rv == 0)
                  {
                    unsigned short int arcount;
                    arcount=ntohs(st->recvbuf->arcount);
                    if(!(arcount == 0))
                    {
                      rv=rrs2cent((unsigned char *)st->recvbuf, (unsigned long int)st->recvl, &rrp, &lcnt, (signed int)arcount, (unsigned int)((signed int)flags | 16), queryts, &secs[(signed long int)2], &numoptrr, &ednsinfo);
                      if(!(numoptrr == 0))
                      {
                        if(!(numoptrr == 1))
                        {
                          if(!(debug_p == 0))
                            debug_msg(0, "Additional section in reply contains %d OPT pseudo-RRs!\n", numoptrr);

                        }

                        char p_exec_query__1__2__9__1__1__2___debugsockabuf[46l];
                        if(!(debug_p == 0))
                        {
                          union anonymous_6 *tmp_if_expr_54;
                          if(!(run_ipv4 == 0))
                            tmp_if_expr_54 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                          else
                            tmp_if_expr_54 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                          return_value_pdnsd_a2str_55=pdnsd_a2str(tmp_if_expr_54, p_exec_query__1__2__9__1__1__2___debugsockabuf, 46);
                          debug_msg(0, "Reply from %s contains OPT pseudosection: EDNS version = %u, udp size = %u, flag DO=%u\n", return_value_pdnsd_a2str_55, ednsinfo.version, ednsinfo.udpsize, ednsinfo.do_flg);
                        }

                        if(!(rcode == (signed int)ednsinfo.rcode))
                        {
                          char p_exec_query__1__2__9__1__1__3__1___debugsockabuf[46l];
                          if(!(debug_p == 0))
                          {
                            union anonymous_6 *tmp_if_expr_56;
                            if(!(run_ipv4 == 0))
                              tmp_if_expr_56 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                            else
                              tmp_if_expr_56 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                            return_value_pdnsd_a2str_57=pdnsd_a2str(tmp_if_expr_56, p_exec_query__1__2__9__1__1__3__1___debugsockabuf, 46);
                            return_value_get_ename_58=get_ename((signed int)ednsinfo.rcode);
                            debug_msg(0, "Reply from %s contains unexpected EDNS rcode %u (%s)!\n", return_value_pdnsd_a2str_57, ednsinfo.rcode, return_value_get_ename_58);
                          }

                          rcode = (signed int)ednsinfo.rcode;
                          if(st->failed == 0)
                            st->failed = (char)1;

                        }

                      }

                    }

                  }

                  _Bool tmp_if_expr_62;
                  if(rv == 0)
                    tmp_if_expr_62 = (_Bool)1;

                  else
                  {
                    if(rv == 0xfffe)
                      tmp_if_expr_61 = st->recvbuf->tc != 0u ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_61 = (_Bool)0;
                    tmp_if_expr_62 = tmp_if_expr_61 ? (_Bool)1 : (_Bool)0;
                  }
                  if(!tmp_if_expr_62)
                  {
                    char p_exec_query__1__2__10__1___debugsockabuf[46l];
                    if(!(debug_p == 0))
                    {
                      union anonymous_6 *tmp_if_expr_59;
                      if(!(run_ipv4 == 0))
                        tmp_if_expr_59 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                      else
                        tmp_if_expr_59 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                      return_value_pdnsd_a2str_60=pdnsd_a2str(tmp_if_expr_59, p_exec_query__1__2__10__1___debugsockabuf, 46);
                      debug_msg(0, rv == 1 ? "Format error in reply from %s.\n" : (rv == 0xfffe ? "Format error in reply from %s (message unexpectedly truncated).\n" : (rv == 2 ? "Inconsistent timestamps in reply from %s.\n" : "Out of memory while processing reply from %s.\n")), return_value_pdnsd_a2str_60);
                    }

                    if(rv == 2)
                    {
                      if(st->failed == 0)
                        st->failed = (char)1;

                      goto __CPROVER_DUMP_L127;
                    }

                    if(!(rv == 0xffff))
                      rv = 2;

                  }

                  else
                  {

                  __CPROVER_DUMP_L127:
                    ;
                    signed int p_exec_query__1__2__11__i;
                    signed int p_exec_query__1__2__11__n;
                    unsigned int return_value_da_nel_63;
                    return_value_da_nel_63=da_nel_link2((struct anonymous_3 *)secs[(signed long int)0]);
                    p_exec_query__1__2__11__n = (signed int)return_value_da_nel_63;
                    p_exec_query__1__2__11__i = 0;
                    for( ; !(p_exec_query__1__2__11__i >= p_exec_query__1__2__11__n); p_exec_query__1__2__11__i = p_exec_query__1__2__11__i + 1)
                    {
                      struct anonymous_0 *p_exec_query__1__2__11__1__1__cent = &secs[(signed long int)0]->elem[(signed long int)p_exec_query__1__2__11__i];
                      unsigned int p_exec_query__1__2__11__1__1__scnt;
                      p_exec_query__1__2__11__1__1__scnt=rhnsegcnt_link1(p_exec_query__1__2__11__1__1__cent->qname);
                      struct anonymous *tmp_if_expr_64;
                      if((1 & (signed int)p_exec_query__1__2__11__1__1__cent->flags) == 0)
                        tmp_if_expr_64 = p_exec_query__1__2__11__1__1__cent->_anon0.rr.rrmu[(signed long int)1];

                      else
                        tmp_if_expr_64 = (struct anonymous *)(void *)0;
                      if(!(tmp_if_expr_64 == ((struct anonymous *)NULL)))
                        p_exec_query__1__2__11__1__1__cent->c_ns = (unsigned char)p_exec_query__1__2__11__1__1__scnt;

                      struct anonymous *tmp_if_expr_65;
                      if((1 & (signed int)p_exec_query__1__2__11__1__1__cent->flags) == 0)
                        tmp_if_expr_65 = p_exec_query__1__2__11__1__1__cent->_anon0.rr.rrmu[(signed long int)3];

                      else
                        tmp_if_expr_65 = (struct anonymous *)(void *)0;
                      if(!(tmp_if_expr_65 == ((struct anonymous *)NULL)))
                        p_exec_query__1__2__11__1__1__cent->c_soa = (unsigned char)p_exec_query__1__2__11__1__1__scnt;

                      _Bool tmp_if_expr_73;
                      if((signed int)p_exec_query__1__2__qtype >= 251 && !((signed int)p_exec_query__1__2__qtype >= 256))
                        tmp_if_expr_73 = (_Bool)1;

                      else
                      {
                        return_value_getrrset_72=getrrset_link1(p_exec_query__1__2__11__1__1__cent, (signed int)p_exec_query__1__2__qtype);
                        tmp_if_expr_73 = return_value_getrrset_72 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
                      }
                      _Bool tmp_if_expr_75;
                      if(tmp_if_expr_73)
                        tmp_if_expr_75 = (_Bool)1;

                      else
                      {
                        if(p_exec_query__1__2__11__n == 1)
                          tmp_if_expr_74 = (signed int)p_exec_query__1__2__11__1__1__cent->num_rrs == 0 ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr_74 = (_Bool)0;
                        tmp_if_expr_75 = tmp_if_expr_74 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_75)
                      {
                        signed int p_exec_query__1__2__11__1__1__1__j;
                        signed int p_exec_query__1__2__11__1__1__1__m;
                        unsigned int return_value_da_nel_66;
                        return_value_da_nel_66=da_nel_link2((struct anonymous_3 *)secs[(signed long int)1]);
                        p_exec_query__1__2__11__1__1__1__m = (signed int)return_value_da_nel_66;
                        p_exec_query__1__2__11__1__1__1__j = 0;
                        for( ; !(p_exec_query__1__2__11__1__1__1__j >= p_exec_query__1__2__11__1__1__1__m); p_exec_query__1__2__11__1__1__1__j = p_exec_query__1__2__11__1__1__1__j + 1)
                        {
                          struct anonymous_0 *p_exec_query__1__2__11__1__1__1__1__1__ce = &secs[(signed long int)1]->elem[(signed long int)p_exec_query__1__2__11__1__1__1__j];
                          unsigned int ml;
                          unsigned int p_exec_query__1__2__11__1__1__1__1__1__rem;
                          ml=domain_match(p_exec_query__1__2__11__1__1__1__1__1__ce->qname, p_exec_query__1__2__11__1__1__cent->qname, &p_exec_query__1__2__11__1__1__1__1__1__rem, (unsigned int *)(void *)0);
                          if(p_exec_query__1__2__11__1__1__1__1__1__rem == 0u)
                          {
                            _Bool tmp_if_expr_71;
                            if(!(ml == 0u))
                              tmp_if_expr_71 = (_Bool)1;

                            else
                              tmp_if_expr_71 = (signed int)st->auth_serv != 2 ? (_Bool)1 : (_Bool)0;
                            if(tmp_if_expr_71)
                            {
                              struct anonymous *tmp_if_expr_68;
                              if((1 & (signed int)p_exec_query__1__2__11__1__1__1__1__1__ce->flags) == 0)
                                tmp_if_expr_68 = p_exec_query__1__2__11__1__1__1__1__1__ce->_anon0.rr.rrmu[(signed long int)1];

                              else
                                tmp_if_expr_68 = (struct anonymous *)(void *)0;
                              if(!(tmp_if_expr_68 == ((struct anonymous *)NULL)))
                              {
                                _Bool tmp_if_expr_67;
                                if((signed int)p_exec_query__1__2__11__1__1__cent->c_ns == 0xff)
                                  tmp_if_expr_67 = (_Bool)1;

                                else
                                  tmp_if_expr_67 = (unsigned int)p_exec_query__1__2__11__1__1__cent->c_ns < ml ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr_67)
                                  p_exec_query__1__2__11__1__1__cent->c_ns = (unsigned char)ml;

                              }

                              struct anonymous *tmp_if_expr_70;
                              if((1 & (signed int)p_exec_query__1__2__11__1__1__1__1__1__ce->flags) == 0)
                                tmp_if_expr_70 = p_exec_query__1__2__11__1__1__1__1__1__ce->_anon0.rr.rrmu[(signed long int)3];

                              else
                                tmp_if_expr_70 = (struct anonymous *)(void *)0;
                              if(!(tmp_if_expr_70 == ((struct anonymous *)NULL)))
                              {
                                _Bool tmp_if_expr_69;
                                if((signed int)p_exec_query__1__2__11__1__1__cent->c_soa == 0xff)
                                  tmp_if_expr_69 = (_Bool)1;

                                else
                                  tmp_if_expr_69 = (unsigned int)p_exec_query__1__2__11__1__1__cent->c_soa < ml ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr_69)
                                  p_exec_query__1__2__11__1__1__cent->c_soa = (unsigned char)ml;

                              }

                            }

                          }

                        }
                      }

                    }
                    if(!(st->rejectlist == ((struct rejectlist_s *)NULL)))
                    {
                      signed int p_exec_query__1__2__12__i;
                      signed int na4 = st->rejectlist->na4;
                      struct anonymous_11 *a4arr = (struct anonymous_11 *)((struct anonymous_13 *)st->rejectlist->rdata + (signed long int)st->rejectlist->na6);
                      signed int na6 = st->rejectlist->na6;
                      struct anonymous_13 *a6arr = (struct anonymous_13 *)st->rejectlist->rdata;
                      p_exec_query__1__2__12__i = 0;
                      for( ; !(p_exec_query__1__2__12__i >= 3); p_exec_query__1__2__12__i = p_exec_query__1__2__12__i + 1)
                      {
                        struct anonymous_16 *p_exec_query__1__2__12__1__1__sec = secs[(signed long int)p_exec_query__1__2__12__i];
                        signed int p_exec_query__1__2__12__1__1__j;
                        signed int nce;
                        unsigned int return_value_da_nel_76;
                        return_value_da_nel_76=da_nel_link2((struct anonymous_3 *)p_exec_query__1__2__12__1__1__sec);
                        nce = (signed int)return_value_da_nel_76;
                        p_exec_query__1__2__12__1__1__j = 0;
                        for( ; !(p_exec_query__1__2__12__1__1__j >= nce); p_exec_query__1__2__12__1__1__j = p_exec_query__1__2__12__1__1__j + 1)
                        {
                          struct anonymous_0 *p_exec_query__1__2__12__1__1__1__1__cent = &p_exec_query__1__2__12__1__1__sec->elem[(signed long int)p_exec_query__1__2__12__1__1__j];
                          struct anonymous *p_exec_query__1__2__12__1__1__1__1__rrset;
                          struct anonymous *tmp_if_expr_77;
                          if((1 & (signed int)p_exec_query__1__2__12__1__1__1__1__cent->flags) == 0)
                            tmp_if_expr_77 = p_exec_query__1__2__12__1__1__1__1__cent->_anon0.rr.rrmu[(signed long int)0];

                          else
                            tmp_if_expr_77 = (struct anonymous *)(void *)0;
                          p_exec_query__1__2__12__1__1__1__1__rrset = tmp_if_expr_77;
                          if(!(p_exec_query__1__2__12__1__1__1__1__rrset == ((struct anonymous *)NULL)) && !(na4 == 0))
                          {
                            struct rr_b_s *p_exec_query__1__2__12__1__1__1__1__1__rr = p_exec_query__1__2__12__1__1__1__1__rrset->rrs;
                            for( ; !(p_exec_query__1__2__12__1__1__1__1__1__rr == ((struct rr_b_s *)NULL)); p_exec_query__1__2__12__1__1__1__1__1__rr = p_exec_query__1__2__12__1__1__1__1__1__rr->next)
                            {
                              struct in_addr *a = (struct in_addr *)p_exec_query__1__2__12__1__1__1__1__1__rr->data;
                              signed int p_exec_query__1__2__12__1__1__1__1__1__1__1__k = 0;
                              for( ; !(p_exec_query__1__2__12__1__1__1__1__1__1__1__k >= na4); p_exec_query__1__2__12__1__1__1__1__1__1__1__k = p_exec_query__1__2__12__1__1__1__1__1__1__1__k + 1)
                              {
                                struct anonymous_11 *am = &a4arr[(signed long int)p_exec_query__1__2__12__1__1__1__1__1__1__1__k];
                                if(((a->s_addr ^ am->a.s_addr) & am->mask.s_addr) == 0u)
                                {
                                  unsigned char p_exec_query__1__2__12__1__1__1__1__1__1__1__1__1__1__nmbuf[256l];
                                  char abuf[46l];
                                  char p_exec_query__1__2__12__1__1__1__1__1__1__1__1__1__1__1___debugsockabuf[46l];
                                  if(!(debug_p == 0))
                                  {
                                    union anonymous_6 *tmp_if_expr_78;
                                    if(!(run_ipv4 == 0))
                                      tmp_if_expr_78 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                                    else
                                      tmp_if_expr_78 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                                    return_value_pdnsd_a2str_79=pdnsd_a2str(tmp_if_expr_78, p_exec_query__1__2__12__1__1__1__1__1__1__1__1__1__1__1___debugsockabuf, 46);
                                    return_value_rhn2str_80=rhn2str(p_exec_query__1__2__12__1__1__1__1__cent->qname, p_exec_query__1__2__12__1__1__1__1__1__1__1__1__1__1__nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                    return_value_inet_ntop_81=inet_ntop(2, (const void *)a, abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                    debug_msg(0, "Rejecting answer from server %s because it contains an A record for \"%s\" with an address in the reject list: %s\n", return_value_pdnsd_a2str_79, return_value_rhn2str_80, return_value_inet_ntop_81);
                                  }

                                  reject_ans = (unsigned short int)1;
                                  goto rejectlist_scan_done;
                                }

                              }
                            }
                          }

                          struct anonymous *tmp_if_expr_82;
                          if((1 & (signed int)p_exec_query__1__2__12__1__1__1__1__cent->flags) == 0)
                            tmp_if_expr_82 = p_exec_query__1__2__12__1__1__1__1__cent->_anon0.rr.rrmu[(signed long int)7];

                          else
                            tmp_if_expr_82 = (struct anonymous *)(void *)0;
                          p_exec_query__1__2__12__1__1__1__1__rrset = tmp_if_expr_82;
                          if(!(p_exec_query__1__2__12__1__1__1__1__rrset == ((struct anonymous *)NULL)) && !(na6 == 0))
                          {
                            struct rr_b_s *p_exec_query__1__2__12__1__1__1__1__2__rr = p_exec_query__1__2__12__1__1__1__1__rrset->rrs;
                            for( ; !(p_exec_query__1__2__12__1__1__1__1__2__rr == ((struct rr_b_s *)NULL)); p_exec_query__1__2__12__1__1__1__1__2__rr = p_exec_query__1__2__12__1__1__1__1__2__rr->next)
                            {
                              struct in6_addr *p_exec_query__1__2__12__1__1__1__1__2__1__1__a = (struct in6_addr *)p_exec_query__1__2__12__1__1__1__1__2__rr->data;
                              signed int p_exec_query__1__2__12__1__1__1__1__2__1__1__k = 0;
                              for( ; !(p_exec_query__1__2__12__1__1__1__1__2__1__1__k >= na6); p_exec_query__1__2__12__1__1__1__1__2__1__1__k = p_exec_query__1__2__12__1__1__1__1__2__1__1__k + 1)
                              {
                                struct anonymous_13 *p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am = &a6arr[(signed long int)p_exec_query__1__2__12__1__1__1__1__2__1__1__k];
                                if(((*((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->a) ^ *((unsigned int *)p_exec_query__1__2__12__1__1__1__1__2__1__1__a)) & *((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->mask)) == 0u)
                                {
                                  if(((((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->a)[1l] ^ ((unsigned int *)p_exec_query__1__2__12__1__1__1__1__2__1__1__a)[1l]) & ((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->mask)[1l]) == 0u)
                                  {
                                    if(((((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->a)[2l] ^ ((unsigned int *)p_exec_query__1__2__12__1__1__1__1__2__1__1__a)[2l]) & ((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->mask)[2l]) == 0u)
                                    {
                                      if(((((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->a)[3l] ^ ((unsigned int *)p_exec_query__1__2__12__1__1__1__1__2__1__1__a)[3l]) & ((unsigned int *)&p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__am->mask)[3l]) == 0u)
                                      {
                                        unsigned char p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__1__nmbuf[256l];
                                        char p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__1__abuf[46l];
                                        char p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__1__1___debugsockabuf[46l];
                                        if(!(debug_p == 0))
                                        {
                                          union anonymous_6 *tmp_if_expr_83;
                                          if(!(run_ipv4 == 0))
                                            tmp_if_expr_83 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                                          else
                                            tmp_if_expr_83 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                                          return_value_pdnsd_a2str_84=pdnsd_a2str(tmp_if_expr_83, p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__1__1___debugsockabuf, 46);
                                          return_value_rhn2str_85=rhn2str(p_exec_query__1__2__12__1__1__1__1__cent->qname, p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__1__nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                          return_value_inet_ntop_86=inet_ntop(10, (const void *)p_exec_query__1__2__12__1__1__1__1__2__1__1__a, p_exec_query__1__2__12__1__1__1__1__2__1__1__1__1__1__abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                          debug_msg(0, "Rejecting answer from server %s because it contains an AAAA record for \"%s\" with an address in the reject list: %s\n", return_value_pdnsd_a2str_84, return_value_rhn2str_85, return_value_inet_ntop_86);
                                        }

                                        reject_ans = (unsigned short int)1;
                                        goto rejectlist_scan_done;
                                      }

                                    }

                                  }

                                }

                              }
                            }
                          }

                        }
                      }
                    }


                  rejectlist_scan_done:
                    ;
                    if(rcode == 3)
                    {
                      char p_exec_query__1__2__13__1___debugsockabuf[46l];
                      if(!(debug_p == 0))
                      {
                        union anonymous_6 *tmp_if_expr_87;
                        if(!(run_ipv4 == 0))
                          tmp_if_expr_87 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                        else
                          tmp_if_expr_87 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                        return_value_pdnsd_a2str_88=pdnsd_a2str(tmp_if_expr_87, p_exec_query__1__2__13__1___debugsockabuf, 46);
                        return_value_get_ename_89=get_ename(rcode);
                        debug_msg(0, "Server %s returned error code: %s\n", return_value_pdnsd_a2str_88, return_value_get_ename_89);
                      }


                    name_error:
                      ;
                      neg_ans = (unsigned short int)1;
                      struct anonymous_0 *p_exec_query__1__2__13__2__ent = &secs[(signed long int)0]->elem[(signed long int)0];
                      signed int neg_domain_pol = (signed int)global.neg_domain_pol;
                      _Bool tmp_if_expr_94;
                      if(neg_domain_pol == 1)
                        tmp_if_expr_94 = (_Bool)1;

                      else
                      {
                        if(neg_domain_pol == 22)
                          tmp_if_expr_93 = st->recvbuf->aa != 0u ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr_93 = (_Bool)0;
                        tmp_if_expr_94 = tmp_if_expr_93 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_94)
                      {
                        signed long int p_exec_query__1__2__13__2__1__ttl = global.neg_ttl;
                        if(!((signed int)p_exec_query__1__2__13__2__ent->c_soa == 0xff))
                        {
                          unsigned int p_exec_query__1__2__13__2__1__1__scnt;
                          p_exec_query__1__2__13__2__1__1__scnt=rhnsegcnt_link1(name);
                          struct anonymous_0 *p_exec_query__1__2__13__2__1__1__cent;
                          if(!((unsigned int)p_exec_query__1__2__13__2__ent->c_soa >= p_exec_query__1__2__13__2__1__1__scnt))
                          {
                            return_value_skipsegs_91=skipsegs_link1(name, p_exec_query__1__2__13__2__1__1__scnt - (unsigned int)p_exec_query__1__2__13__2__ent->c_soa);
                            p_exec_query__1__2__13__2__1__1__cent=lookup_cent_array(secs[(signed long int)1], return_value_skipsegs_91);
                            if(!(p_exec_query__1__2__13__2__1__1__cent == ((struct anonymous_0 *)NULL)))
                            {
                              struct anonymous *p_exec_query__1__2__13__2__1__1__1__rrset;
                              struct anonymous *tmp_if_expr_90;
                              if((1 & (signed int)p_exec_query__1__2__13__2__1__1__cent->flags) == 0)
                                tmp_if_expr_90 = p_exec_query__1__2__13__2__1__1__cent->_anon0.rr.rrmu[(signed long int)3];

                              else
                                tmp_if_expr_90 = (struct anonymous *)(void *)0;
                              p_exec_query__1__2__13__2__1__1__1__rrset = tmp_if_expr_90;
                              if(!(p_exec_query__1__2__13__2__1__1__1__rrset == ((struct anonymous *)NULL)))
                              {
                                if(!(p_exec_query__1__2__13__2__1__1__1__rrset->rrs == ((struct rr_b_s *)NULL)))
                                {
                                  signed long int p_exec_query__1__2__13__2__1__1__1__1__min;
                                  p_exec_query__1__2__13__2__1__1__1__1__min=soa_minimum(p_exec_query__1__2__13__2__1__1__1__rrset->rrs);
                                  p_exec_query__1__2__13__2__1__ttl = p_exec_query__1__2__13__2__1__1__1__rrset->ttl;
                                  if(!(p_exec_query__1__2__13__2__1__1__1__1__min >= p_exec_query__1__2__13__2__1__ttl))
                                    p_exec_query__1__2__13__2__1__ttl = p_exec_query__1__2__13__2__1__1__1__1__min;

                                }

                              }

                            }

                          }

                        }

                        unsigned char p_exec_query__1__2__13__2__1__2___debugstrbuf[256l];
                        if(!(debug_p == 0))
                        {
                          return_value_rhn2str_92=rhn2str(name, p_exec_query__1__2__13__2__1__2___debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                          debug_msg(0, "Caching domain %s negative with ttl %li\n", return_value_rhn2str_92, (signed long int)p_exec_query__1__2__13__2__1__ttl);
                        }

                        negate_cent(p_exec_query__1__2__13__2__ent, p_exec_query__1__2__13__2__1__ttl, queryts);
                        if(!(st->nocache == 0))
                          p_exec_query__1__2__13__2__ent->flags = p_exec_query__1__2__13__2__ent->flags | (unsigned short int)8;

                        goto cleanup_return_OK;
                      }

                      else
                      {
                        if(!(c_soa == ((unsigned char *)NULL)))
                          *c_soa = p_exec_query__1__2__13__2__ent->c_soa;

                        free_cent(p_exec_query__1__2__13__2__ent);
                        rv = 3;
                        goto add_additional;
                      }
                    }

                    if(!(reject_ans == 0))
                    {
                      _Bool tmp_if_expr_95;
                      if((signed int)st->rejectlist->policy == 25)
                        tmp_if_expr_95 = (signed int)st->failed <= 1 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_95 = (_Bool)0;
                      if(tmp_if_expr_95)
                        goto name_error;

                      else
                      {
                        rv = 2;
                        goto free_ent_centarrays_recvbuf_return;
                      }
                    }

                    if(!(global.deleg_only_zones == ((struct anonymous_30 *)NULL)))
                    {
                      if(!((signed int)st->auth_serv >= 3))
                      {
                        signed int missingdelegation;
                        signed int authcnt;
                        lock_server_data();
                        missingdelegation = 0;
                        authcnt = 0;
                        signed int i;
                        signed int n;
                        unsigned int return_value_da_nel_96;
                        return_value_da_nel_96=da_nel_link2((struct anonymous_3 *)global.deleg_only_zones);
                        n = (signed int)return_value_da_nel_96;
                        unsigned int rem;
                        unsigned int zrem;
                        i = 0;
                        for( ; !(i >= n); i = i + 1)
                        {
                          unsigned int return_value_domain_match_97;
                          return_value_domain_match_97=domain_match(name, global.deleg_only_zones->elem[(signed long int)i], &rem, &zrem);
                          if(!(return_value_domain_match_97 == 0u))
                          {
                            if(zrem == 0u)
                              goto zone_match;

                          }

                        }
                        goto delegation_OK;

                      zone_match:
                        ;
                        if(!(rem == 0u))
                        {
                          signed int j = 0;
                          for( ; !(j >= 2); j = j + 1)
                          {
                            struct anonymous_16 *sec = secs[(signed long int)j];
                            signed int k;
                            signed int m;
                            unsigned int return_value_da_nel_98;
                            return_value_da_nel_98=da_nel_link2((struct anonymous_3 *)sec);
                            m = (signed int)return_value_da_nel_98;
                            k = 0;
                            for( ; !(k >= m); k = k + 1)
                            {
                              struct anonymous_0 *ce = &sec->elem[(signed long int)k];
                              struct anonymous *tmp_if_expr_100;
                              if((1 & (signed int)ce->flags) == 0)
                                tmp_if_expr_100 = ce->_anon0.rr.rrmu[(signed long int)1];

                              else
                                tmp_if_expr_100 = (struct anonymous *)(void *)0;
                              _Bool tmp_if_expr_102;
                              if(!(tmp_if_expr_100 == ((struct anonymous *)NULL)))
                                tmp_if_expr_102 = (_Bool)1;

                              else
                              {
                                if((1 & (signed int)ce->flags) == 0)
                                  tmp_if_expr_101 = ce->_anon0.rr.rrmu[(signed long int)3];

                                else
                                  tmp_if_expr_101 = (struct anonymous *)(void *)0;
                                tmp_if_expr_102 = tmp_if_expr_101 != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_102)
                              {
                                signed int l;
                                authcnt = authcnt + 1;
                                l = 0;
                                for( ; !(l >= n); l = l + 1)
                                {
                                  unsigned int return_value_domain_match_99;
                                  return_value_domain_match_99=domain_match(ce->qname, global.deleg_only_zones->elem[(signed long int)l], &rem, &zrem);
                                  if(!(return_value_domain_match_99 == 0u))
                                  {
                                    if(zrem == 0u)
                                    {
                                      if(!(rem == 0u))
                                        break;

                                      else
                                        goto try_next_auth;
                                    }

                                  }

                                }
                                goto delegation_OK;
                              }


                            try_next_auth:
                              ;
                            }
                          }
                          unsigned char nmbuf[256l];
                          unsigned char zbuf[256l];
                          char p_exec_query__1__2__15__1__2__2__1___debugsockabuf[46l];
                          if(!(debug_p == 0))
                          {
                            return_value_rhn2str_103=rhn2str(name, nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                            return_value_rhn2str_104=rhn2str(global.deleg_only_zones->elem[(signed long int)i], zbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                            union anonymous_6 *tmp_if_expr_105;
                            if(!(run_ipv4 == 0))
                              tmp_if_expr_105 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                            else
                              tmp_if_expr_105 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                            return_value_pdnsd_a2str_106=pdnsd_a2str(tmp_if_expr_105, p_exec_query__1__2__15__1__2__2__1___debugsockabuf, 46);
                            debug_msg(0, authcnt != 0 ? "%s is in %s zone, but no delegation found in answer returned by server %s\n" : "%s is in %s zone, but no authority information provided by server %s\n", return_value_rhn2str_103, return_value_rhn2str_104, return_value_pdnsd_a2str_106);
                          }

                          missingdelegation = 1;
                        }


                      delegation_OK:
                        ;
                        unlock_server_data();
                        if(!(missingdelegation == 0))
                        {
                          _Bool tmp_if_expr_107;
                          if(!(authcnt == 0))
                            tmp_if_expr_107 = (signed int)st->failed <= 1 ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr_107 = (_Bool)0;
                          if(tmp_if_expr_107)
                            goto name_error;

                          else
                            if(!((signed int)st->auth_serv >= 2))
                            {
                              rv = 2;
                              goto free_ent_centarrays_recvbuf_return;
                            }

                        }

                      }

                    }

                    struct anonymous_0 *ent = &secs[(signed long int)0]->elem[(signed long int)0];
                    if(ent->num_rrs == 0)
                      neg_ans = (unsigned short int)1;

                    if(thint >= 1 && !(thint >= 52))
                    {
                      return_value_getrrset_124=getrrset_link1(ent, thint);
                      if(return_value_getrrset_124 == ((struct anonymous *)NULL))
                      {
                        if(st->tc == 0)
                        {
                          if(!((signed int)st->failed >= 2))
                          {
                            signed int neg_rrs_pol = (signed int)global.neg_rrs_pol;
                            _Bool tmp_if_expr_123;
                            if(neg_rrs_pol == 1 || neg_rrs_pol == 22 && !(aa == 0))
                              tmp_if_expr_123 = (_Bool)1;

                            else
                            {
                              if(neg_rrs_pol == 3)
                              {
                                if(!(aa == 0))
                                  tmp_if_expr_121 = (_Bool)1;

                                else
                                {
                                  if(!(rd == 0))
                                    tmp_if_expr_120 = st->recvbuf->ra != 0u ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr_120 = (_Bool)0;
                                  tmp_if_expr_121 = tmp_if_expr_120 ? (_Bool)1 : (_Bool)0;
                                }
                                tmp_if_expr_122 = tmp_if_expr_121 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr_122 = (_Bool)0;
                              tmp_if_expr_123 = tmp_if_expr_122 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_123)
                            {
                              signed long int ttl = global.neg_ttl;
                              struct anonymous *rrset;
                              struct anonymous *tmp_if_expr_108;
                              if((1 & (signed int)ent->flags) == 0)
                                tmp_if_expr_108 = ent->_anon0.rr.rrmu[(signed long int)3];

                              else
                                tmp_if_expr_108 = (struct anonymous *)(void *)0;
                              rrset = tmp_if_expr_108;
                              struct anonymous_0 *cent;
                              unsigned int scnt;
                              _Bool tmp_if_expr_109;
                              if(!(rrset == ((struct anonymous *)NULL)))
                                tmp_if_expr_109 = rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr_109 = (_Bool)0;
                              _Bool tmp_if_expr_116;
                              if(tmp_if_expr_109)
                                tmp_if_expr_116 = (_Bool)1;

                              else
                              {
                                if(!((signed int)ent->c_soa == 0xff))
                                {
                                  scnt=rhnsegcnt_link1(name);
                                  tmp_if_expr_110 = (unsigned int)ent->c_soa < scnt ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr_110 = (_Bool)0;
                                if(tmp_if_expr_110)
                                {
                                  return_value_skipsegs_111=skipsegs_link1(name, scnt - (unsigned int)ent->c_soa);
                                  tmp_if_expr_112 = return_value_skipsegs_111;
                                }

                                else
                                  tmp_if_expr_112 = name;
                                cent=lookup_cent_array(secs[(signed long int)1], tmp_if_expr_112);
                                if(!(cent == ((struct anonymous_0 *)NULL)))
                                {
                                  if((1 & (signed int)cent->flags) == 0)
                                    tmp_if_expr_113 = cent->_anon0.rr.rrmu[(signed long int)3];

                                  else
                                    tmp_if_expr_113 = (struct anonymous *)(void *)0;
                                  rrset = tmp_if_expr_113;
                                  tmp_if_expr_114 = rrset != ((struct anonymous *)NULL) ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr_114 = (_Bool)0;
                                if(tmp_if_expr_114)
                                  tmp_if_expr_115 = rrset->rrs != ((struct rr_b_s *)NULL) ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr_115 = (_Bool)0;
                                tmp_if_expr_116 = tmp_if_expr_115 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_116)
                              {
                                signed long int min;
                                min=soa_minimum(rrset->rrs);
                                ttl = rrset->ttl;
                                if(!(min >= ttl))
                                  ttl = min;

                              }

                              unsigned char _debugstrbuf[256l];
                              if(!(debug_p == 0))
                              {
                                return_value_getrrtpname_117=getrrtpname(thint);
                                return_value_rhn2str_118=rhn2str(name, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                debug_msg(0, "Caching type %s for domain %s negative with ttl %li\n", return_value_getrrtpname_117, return_value_rhn2str_118, (signed long int)ttl);
                              }

                              signed int return_value_add_cent_rrset_by_type_119;
                              return_value_add_cent_rrset_by_type_119=add_cent_rrset_by_type(ent, thint, ttl, queryts, (unsigned int)(1 | (signed int)flags));
                              if(return_value_add_cent_rrset_by_type_119 == 0)
                              {
                                rv = 0xffff;
                                goto free_ent_centarrays_recvbuf_return;
                              }

                            }

                          }

                        }

                      }

                    }

                    if(!((signed int)st->failed >= 2))
                    {
                      signed int p_exec_query__1__2__17__i = 0;
                      for( ; !(p_exec_query__1__2__17__i >= 2); p_exec_query__1__2__17__i = p_exec_query__1__2__17__i + 1)
                      {
                        struct anonymous_16 *p_exec_query__1__2__17__1__1__sec = secs[(signed long int)p_exec_query__1__2__17__i];
                        signed int p_exec_query__1__2__17__1__1__j;
                        signed int p_exec_query__1__2__17__1__1__n;
                        unsigned int return_value_da_nel_125;
                        return_value_da_nel_125=da_nel_link2((struct anonymous_3 *)p_exec_query__1__2__17__1__1__sec);
                        p_exec_query__1__2__17__1__1__n = (signed int)return_value_da_nel_125;
                        p_exec_query__1__2__17__1__1__j = 0;
                        for( ; !(p_exec_query__1__2__17__1__1__j >= p_exec_query__1__2__17__1__1__n); p_exec_query__1__2__17__1__1__j = p_exec_query__1__2__17__1__1__j + 1)
                        {
                          struct anonymous_0 *p_exec_query__1__2__17__1__1__1__1__cent = &p_exec_query__1__2__17__1__1__sec->elem[(signed long int)p_exec_query__1__2__17__1__1__j];
                          unsigned int p_exec_query__1__2__17__1__1__1__1__rem;
                          _Bool tmp_if_expr_139;
                          if(!(*p_exec_query__1__2__17__1__1__1__1__cent->qname == 0))
                            tmp_if_expr_139 = (_Bool)1;

                          else
                            tmp_if_expr_139 = (signed int)st->auth_serv != 2 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr_139)
                          {
                            _Bool tmp_if_expr_137;
                            if(!(st->trusted == 0))
                              tmp_if_expr_137 = (_Bool)1;

                            else
                              tmp_if_expr_137 = !(st->nsdomain != ((const unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
                            _Bool tmp_if_expr_138;
                            if(tmp_if_expr_137)
                              tmp_if_expr_138 = (_Bool)1;

                            else
                            {
                              domain_match(st->nsdomain, p_exec_query__1__2__17__1__1__1__1__cent->qname, &p_exec_query__1__2__17__1__1__1__1__rem, (unsigned int *)(void *)0);
                              tmp_if_expr_138 = p_exec_query__1__2__17__1__1__1__1__rem == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr_138)
                            {
                              if(!((signed int)*p_exec_query__1__2__17__1__1__1__1__cent->qname == 0xff))
                              {
                                signed int p_exec_query__1__2__17__1__1__1__1__1__k = 0;
                                for( ; !(p_exec_query__1__2__17__1__1__1__1__1__k >= 2); p_exec_query__1__2__17__1__1__1__1__1__k = p_exec_query__1__2__17__1__1__1__1__1__k + 1)
                                {
                                  struct anonymous *p_exec_query__1__2__17__1__1__1__1__1__1__1__rrset;
                                  static const unsigned short int nstypes[2l] = { (const unsigned short int)2, (const unsigned short int)6 };
                                  p_exec_query__1__2__17__1__1__1__1__1__1__1__rrset=getrrset_link1(p_exec_query__1__2__17__1__1__1__1__cent, (signed int)nstypes[(signed long int)p_exec_query__1__2__17__1__1__1__1__1__k]);
                                  if(!(p_exec_query__1__2__17__1__1__1__1__1__1__1__rrset == ((struct anonymous *)NULL)))
                                  {
                                    struct rr_b_s *rr;
                                    unsigned short int first = (unsigned short int)1;
                                    rr = p_exec_query__1__2__17__1__1__1__1__1__1__1__rrset->rrs;
                                    for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
                                    {
                                      unsigned long int sz1;
                                      unsigned long int sz2;
                                      unsigned char *p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p;
                                      void *return_value_dlist_first_126;
                                      return_value_dlist_first_126=dlist_first_link2(*ns);
                                      p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p = (unsigned char *)return_value_dlist_first_126;
                                      for( ; !(p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p == ((unsigned char *)NULL)); p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p = (unsigned char *)return_value_dlist_next_127)
                                      {
                                        unsigned char *tmp_if_expr_129;
                                        if((signed int)*p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p == 0xff)
                                          tmp_if_expr_129 = p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p + (signed long int)1;

                                        else
                                        {
                                          return_value_skiprhn_128=skiprhn_link1(p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p);
                                          tmp_if_expr_129 = return_value_skiprhn_128;
                                        }
                                        signed int return_value_rhnicmp_130;
                                        return_value_rhnicmp_130=rhnicmp_link1(tmp_if_expr_129, (unsigned char *)rr->data);
                                        if(!(return_value_rhnicmp_130 == 0))
                                          goto next_nsr;

                                        return_value_dlist_next_127=dlist_next_link2((void *)p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p);
                                      }
                                      unsigned int tmp_if_expr_132;
                                      if(!(first == 0))
                                      {
                                        return_value_rhnlen_131=rhnlen_link3(p_exec_query__1__2__17__1__1__1__1__cent->qname);
                                        tmp_if_expr_132 = return_value_rhnlen_131;
                                      }

                                      else
                                        tmp_if_expr_132 = (unsigned int)1;
                                      sz1 = (unsigned long int)tmp_if_expr_132;
                                      unsigned int return_value_rhnlen_133;
                                      return_value_rhnlen_133=rhnlen_link3((unsigned char *)rr->data);
                                      sz2 = (unsigned long int)return_value_rhnlen_133;
                                      *ns=dlist_grow(*ns, sz1 + sz2);
                                      if(*ns == ((struct _dynamic_list_head *)NULL))
                                      {
                                        rv = 0xffff;
                                        goto free_ent_centarrays_recvbuf_return;
                                      }

                                      void *return_value_dlist_last_134;
                                      return_value_dlist_last_134=dlist_last_link2(*ns);
                                      p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p = (unsigned char *)return_value_dlist_last_134;
                                      if(!(first == 0))
                                      {
                                        first = (unsigned short int)0;
                                        void *return_value_mempcpy_135;
                                        return_value_mempcpy_135=mempcpy((void *)p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p, (const void *)p_exec_query__1__2__17__1__1__1__1__cent->qname, sz1);
                                        p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p = (unsigned char *)return_value_mempcpy_135;
                                      }

                                      else
                                      {
                                        unsigned char *tmp_post_136 = p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p;
                                        p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p = p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p + 1l;
                                        *tmp_post_136 = (unsigned char)0xff;
                                      }
                                      memcpy((void *)p_exec_query__1__2__17__1__1__1__1__1__1__1__1__1__1__p, (const void *)(unsigned char *)rr->data, sz2);
                                      num_ns = num_ns + 1;

                                    next_nsr:
                                      ;
                                    }
                                  }

                                }
                              }

                            }

                          }

                        }
                      }
                    }


                  cleanup_return_OK:
                    ;
                    if(!(st->failed == 0))
                    {
                      if(neg_ans == 0)
                        goto __CPROVER_DUMP_L307;

                      if(!((signed int)num_ns == 0))
                        goto __CPROVER_DUMP_L307;

                      char p_exec_query__1__2__18__1___debugsockabuf[46l];
                      if(!(debug_p == 0))
                      {
                        union anonymous_6 *tmp_if_expr_140;
                        if(!(run_ipv4 == 0))
                          tmp_if_expr_140 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                        else
                          tmp_if_expr_140 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                        return_value_pdnsd_a2str_141=pdnsd_a2str(tmp_if_expr_140, p_exec_query__1__2__18__1___debugsockabuf, 46);
                        debug_msg(0, "Answer from server %s does not contain usable records.\n", return_value_pdnsd_a2str_141);
                      }

                      rv = 2;
                    }

                    else
                    {

                    __CPROVER_DUMP_L307:
                      ;
                      return_value_malloc_142=malloc(sizeof(struct anonymous_0) /*104ul*/ );
                      *entp = (struct anonymous_0 *)return_value_malloc_142;
                      if(*entp == ((struct anonymous_0 *)NULL))
                        rv = 0xffff;

                      else
                      {
                        *(*entp) = secs[(signed long int)0]->elem[(signed long int)0];
                        rv = 0;

                      add_additional:
                        ;
                        if(st->failed == 0)
                        {
                          if(reject_ans == 0)
                          {
                            signed int p_exec_query__1__2__20__i;
                            if(!(debug_p == 0) && !(neg_ans == 0))
                            {
                              signed int p_exec_query__1__2__20__1__j;
                              signed int p_exec_query__1__2__20__1__n;
                              unsigned int return_value_da_nel_143;
                              return_value_da_nel_143=da_nel_link2((struct anonymous_3 *)secs[(signed long int)0]);
                              p_exec_query__1__2__20__1__n = (signed int)return_value_da_nel_143;
                              p_exec_query__1__2__20__1__j = 1;
                              for( ; !(p_exec_query__1__2__20__1__j >= p_exec_query__1__2__20__1__n); p_exec_query__1__2__20__1__j = p_exec_query__1__2__20__1__j + 1)
                              {
                                unsigned char p_exec_query__1__2__20__1__1__1__nmbuf[256l];
                                unsigned char nmbuf2[256l];
                                char p_exec_query__1__2__20__1__1__1__1___debugsockabuf[46l];
                                if(!(debug_p == 0))
                                {
                                  union anonymous_6 *tmp_if_expr_144;
                                  if(!(run_ipv4 == 0))
                                    tmp_if_expr_144 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                                  else
                                    tmp_if_expr_144 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                                  return_value_pdnsd_a2str_145=pdnsd_a2str(tmp_if_expr_144, p_exec_query__1__2__20__1__1__1__1___debugsockabuf, 46);
                                  return_value_rhn2str_146=rhn2str(name, p_exec_query__1__2__20__1__1__1__nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                  return_value_rhn2str_147=rhn2str(secs[(signed long int)0]->elem[(signed long int)p_exec_query__1__2__20__1__j].qname, nmbuf2, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                  debug_msg(0, "Reply from %s is negative for %s, dropping record(s) for %s in answer section.\n", return_value_pdnsd_a2str_145, return_value_rhn2str_146, return_value_rhn2str_147);
                                }

                              }
                            }

                            p_exec_query__1__2__20__i = (signed int)neg_ans;
                            for( ; !(p_exec_query__1__2__20__i >= 3); p_exec_query__1__2__20__i = p_exec_query__1__2__20__i + 1)
                            {
                              struct anonymous_16 *p_exec_query__1__2__20__2__1__sec = secs[(signed long int)p_exec_query__1__2__20__i];
                              signed int p_exec_query__1__2__20__2__1__j;
                              signed int p_exec_query__1__2__20__2__1__n;
                              unsigned int return_value_da_nel_148;
                              return_value_da_nel_148=da_nel_link2((struct anonymous_3 *)p_exec_query__1__2__20__2__1__sec);
                              p_exec_query__1__2__20__2__1__n = (signed int)return_value_da_nel_148;
                              p_exec_query__1__2__20__2__1__j = (signed int)!(p_exec_query__1__2__20__i != 0);
                              for( ; !(p_exec_query__1__2__20__2__1__j >= p_exec_query__1__2__20__2__1__n); p_exec_query__1__2__20__2__1__j = p_exec_query__1__2__20__2__1__j + 1)
                              {
                                struct anonymous_0 *p_exec_query__1__2__20__2__1__1__1__cent = &p_exec_query__1__2__20__2__1__sec->elem[(signed long int)p_exec_query__1__2__20__2__1__j];
                                _Bool tmp_if_expr_155;
                                if(!(*p_exec_query__1__2__20__2__1__1__1__cent->qname == 0))
                                  tmp_if_expr_155 = (_Bool)1;

                                else
                                  tmp_if_expr_155 = (signed int)st->auth_serv != 2 ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr_155)
                                {
                                  unsigned int p_exec_query__1__2__20__2__1__1__1__1__rem;
                                  _Bool tmp_if_expr_151;
                                  if(!(st->trusted == 0))
                                    tmp_if_expr_151 = (_Bool)1;

                                  else
                                    tmp_if_expr_151 = !(st->nsdomain != ((const unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
                                  _Bool tmp_if_expr_152;
                                  if(tmp_if_expr_151)
                                    tmp_if_expr_152 = (_Bool)1;

                                  else
                                  {
                                    domain_match(st->nsdomain, p_exec_query__1__2__20__2__1__1__1__cent->qname, &p_exec_query__1__2__20__2__1__1__1__1__rem, (unsigned int *)(void *)0);
                                    tmp_if_expr_152 = p_exec_query__1__2__20__2__1__1__1__1__rem == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
                                  }
                                  if(tmp_if_expr_152)
                                    add_cache(p_exec_query__1__2__20__2__1__1__1__cent);

                                  else
                                  {
                                    unsigned char p_exec_query__1__2__20__2__1__1__1__1__1__nmbuf[256l];
                                    unsigned char nsbuf[256l];
                                    if(!(debug_p == 0))
                                    {
                                      return_value_rhn2str_149=rhn2str(p_exec_query__1__2__20__2__1__1__1__cent->qname, p_exec_query__1__2__20__2__1__1__1__1__1__nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                      return_value_rhn2str_150=rhn2str(st->nsdomain, nsbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                      debug_msg(0, "Record for %s not in nsdomain %s; dropped.\n", return_value_rhn2str_149, return_value_rhn2str_150);
                                    }

                                  }
                                }

                                else
                                {
                                  char p_exec_query__1__2__20__2__1__1__1__2__1___debugsockabuf[46l];
                                  if(!(debug_p == 0))
                                  {
                                    union anonymous_6 *tmp_if_expr_153;
                                    if(!(run_ipv4 == 0))
                                      tmp_if_expr_153 = (union anonymous_6 *)&st->a.sin4.sin_addr;

                                    else
                                      tmp_if_expr_153 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
                                    return_value_pdnsd_a2str_154=pdnsd_a2str(tmp_if_expr_153, p_exec_query__1__2__20__2__1__1__1__2__1___debugsockabuf, 46);
                                    static const char * const secname[3l] = { "answer", "authority", "additional" };
                                    debug_msg(0, "Record(s) for root domain in %s section from %s dropped.\n", secname[(signed long int)p_exec_query__1__2__20__i], return_value_pdnsd_a2str_154);
                                  }

                                }
                              }
                            }
                          }

                        }

                        goto free_centarrays_recvbuf_return;
                      }
                    }

                  free_ns_ent_centarrays_recvbuf_return:
                    ;
                    free((void *)*ns);
                    *ns = (struct _dynamic_list_head *)(void *)0;
                  }

                free_ent_centarrays_recvbuf_return:
                  ;
                  return_value_da_nel_156=da_nel_link2((struct anonymous_3 *)secs[(signed long int)0]);
                  if(return_value_da_nel_156 >= 1u)
                    free_cent(&secs[(signed long int)0]->elem[(signed long int)0]);

                }

              free_centarrays_recvbuf_return:
                ;
                signed int p_exec_query__1__2__21__i = 0;
                for( ; !(p_exec_query__1__2__21__i >= 3); p_exec_query__1__2__21__i = p_exec_query__1__2__21__i + 1)
                {
                  struct anonymous_16 *p_exec_query__1__2__21__1__1__sec = secs[(signed long int)p_exec_query__1__2__21__i];
                  signed int p_exec_query__1__2__21__1__1__j;
                  signed int p_exec_query__1__2__21__1__1__n;
                  unsigned int return_value_da_nel_157;
                  return_value_da_nel_157=da_nel_link2((struct anonymous_3 *)p_exec_query__1__2__21__1__1__sec);
                  p_exec_query__1__2__21__1__1__n = (signed int)return_value_da_nel_157;
                  p_exec_query__1__2__21__1__1__j = (signed int)!(p_exec_query__1__2__21__i != 0);
                  for( ; !(p_exec_query__1__2__21__1__1__j >= p_exec_query__1__2__21__1__1__n); p_exec_query__1__2__21__1__1__j = p_exec_query__1__2__21__1__1__j + 1)
                    free_cent(&p_exec_query__1__2__21__1__1__sec->elem[(signed long int)p_exec_query__1__2__21__1__1__j]);
                  free((void *)p_exec_query__1__2__21__1__1__sec);
                }
              }
            }
          }
        }
      }
    }
  }


free_recvbuf_return:
  ;
  free((void *)st->recvbuf);
  return rv;
}

// p_query_sm
// file dns_query.c line 847
static signed int p_query_sm(struct anonymous_5 *st)
{
  signed int retval = 2;
  signed int rv;

tryagain:
  ;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int return_value_bind_socket_3;
  signed int return_value_fcntl_8;
  const char *return_value_pdnsd_a2str_5;
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  signed int return_value_connect_29;
  signed int *return_value___errno_location_26;
  _Bool tmp_if_expr_28;
  signed int *return_value___errno_location_27;
  signed int *return_value___errno_location_25;
  const char *return_value_pdnsd_a2str_12;
  signed int *return_value___errno_location_18;
  _Bool tmp_if_expr_20;
  signed int *return_value___errno_location_19;
  char p_query_sm__1__1__4__3__1__abuf[46l];
  const char *return_value_pdnsd_a2str_14;
  signed int *return_value___errno_location_15;
  char *return_value_strerror_16;
  const char *return_value_inet_ntop_17;
  const char *return_value_pdnsd_a2str_22;
  signed int *return_value___errno_location_23;
  char *return_value_strerror_24;
  const char *return_value_pdnsd_a2str_34;
  char *return_value_strerror_35;
  const char *return_value_pdnsd_a2str_39;
  char *return_value_strerror_40;
  signed int *return_value___errno_location_42;
  signed int *return_value___errno_location_46;
  const char *return_value_pdnsd_a2str_48;
  signed int *return_value___errno_location_49;
  char *return_value_strerror_50;
  _Bool tmp_if_expr_51;
  const char *return_value_pdnsd_a2str_54;
  while((_Bool)1)
  {
    if(!((signed int)st->state == 1))
    {
      if((signed int)st->state == 2)
        goto __CPROVER_DUMP_L33;

      if((signed int)st->state == 3)
        goto __CPROVER_DUMP_L50;

      if((signed int)st->state == 4)
        goto __CPROVER_DUMP_L74;

      if((signed int)st->state == 5)
        goto __CPROVER_DUMP_L95;

      goto __CPROVER_DUMP_L106;
    }

    st->sock=socket(run_ipv4 != 0 ? 2 : 10, 1, 6);
    if(st->sock == -1)
    {
      if(!(debug_p == 0))
      {
        return_value___errno_location_1=__errno_location();
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        debug_msg(0, "Could not open socket: %s\n", return_value_strerror_2);
      }

      goto __CPROVER_DUMP_L106;
    }

    return_value_bind_socket_3=bind_socket(st->sock);
    if(return_value_bind_socket_3 == 0)
    {
      close(st->sock);
      goto __CPROVER_DUMP_L106;
    }

    signed int oldflags;
    oldflags=fcntl(st->sock, 3, 0);
    _Bool tmp_if_expr_9;
    if(oldflags == -1)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_fcntl_8=fcntl(st->sock, 4, oldflags | 04000);
      tmp_if_expr_9 = return_value_fcntl_8 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
    {
      char p_query_sm__1__1__3__1__1___debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous_6 *tmp_if_expr_4;
        if(!(run_ipv4 == 0))
          tmp_if_expr_4 = (union anonymous_6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr_4 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str_5=pdnsd_a2str(tmp_if_expr_4, p_query_sm__1__1__3__1__1___debugsockabuf, 46);
        return_value___errno_location_6=__errno_location();
        return_value_strerror_7=strerror(*return_value___errno_location_6);
        debug_msg(0, "fcntl error while trying to make socket to %s non-blocking: %s\n", return_value_pdnsd_a2str_5, return_value_strerror_7);
      }

      close(st->sock);
      goto __CPROVER_DUMP_L106;
    }

    st->iolen = 0;
    do
    {

    retry_tcp_connect:
      ;
      return_value_connect_29=connect(st->sock, (struct sockaddr *)&st->a, (unsigned int)(run_ipv4 != 0 ? sizeof(struct sockaddr_in) /*16ul*/  : sizeof(struct sockaddr_in6) /*28ul*/ ));
      if(!(return_value_connect_29 == -1))
        goto __CPROVER_DUMP_L32;

      return_value___errno_location_26=__errno_location();
      if(*return_value___errno_location_26 == 115)
        tmp_if_expr_28 = (_Bool)1;

      else
      {
        return_value___errno_location_27=__errno_location();
        tmp_if_expr_28 = *return_value___errno_location_27 == 32 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_28)
      {
        st->state = (signed short int)2;
        return -1;
      }

      return_value___errno_location_25=__errno_location();
      if(*return_value___errno_location_25 == 111)
      {
        signed int *return_value___errno_location_10;
        return_value___errno_location_10=__errno_location();
        st->s_errno = *return_value___errno_location_10;
        char p_query_sm__1__1__4__2__1___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_11;
          if(!(run_ipv4 == 0))
            tmp_if_expr_11 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_11 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_12=pdnsd_a2str(tmp_if_expr_11, p_query_sm__1__1__4__2__1___debugsockabuf, 46);
          debug_msg(0, "TCP connection refused by %s\n", return_value_pdnsd_a2str_12);
        }

        close(st->sock);
        goto tcp_failed;
      }

      if(!(run_ipv4 == 0))
        goto __CPROVER_DUMP_L26;

      return_value___errno_location_18=__errno_location();
      if(*return_value___errno_location_18 == 101)
        tmp_if_expr_20 = (_Bool)1;

      else
      {
        return_value___errno_location_19=__errno_location();
        tmp_if_expr_20 = *return_value___errno_location_19 == 100 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_20)
        break;

      if(st->a4fallback.s_addr == 0u)
        break;

      char p_query_sm__1__1__4__3__1__1___debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous_6 *tmp_if_expr_13;
        if(!(run_ipv4 == 0))
          tmp_if_expr_13 = (union anonymous_6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr_13 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str_14=pdnsd_a2str(tmp_if_expr_13, p_query_sm__1__1__4__3__1__1___debugsockabuf, 46);
        return_value___errno_location_15=__errno_location();
        return_value_strerror_16=strerror(*return_value___errno_location_15);
        return_value_inet_ntop_17=inet_ntop(2, (const void *)&st->a4fallback, p_query_sm__1__1__4__3__1__abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
        debug_msg(0, "Connecting to %s failed: %s, retrying with IPv4 address %s\n", return_value_pdnsd_a2str_14, return_value_strerror_16, return_value_inet_ntop_17);
      }

      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)3] = (&st->a4fallback)->s_addr;
      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)2]=htonl((unsigned int)0xffff);
      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0] = (unsigned int)0;
      ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)1] = ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0];
      st->a4fallback.s_addr = (unsigned int)0x00000000;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L26:
    ;
    char p_query_sm__1__1__4__3__2___debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous_6 *tmp_if_expr_21;
      if(!(run_ipv4 == 0))
        tmp_if_expr_21 = (union anonymous_6 *)&st->a.sin4.sin_addr;

      else
        tmp_if_expr_21 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
      return_value_pdnsd_a2str_22=pdnsd_a2str(tmp_if_expr_21, p_query_sm__1__1__4__3__2___debugsockabuf, 46);
      return_value___errno_location_23=__errno_location();
      return_value_strerror_24=strerror(*return_value___errno_location_23);
      debug_msg(0, "Error while connecting to %s: %s\n", return_value_pdnsd_a2str_22, return_value_strerror_24);
    }

    close(st->sock);
    goto __CPROVER_DUMP_L106;

  __CPROVER_DUMP_L32:
    ;
    st->state = (signed short int)2;

  __CPROVER_DUMP_L33:
    ;
    signed int p_query_sm__1__1__5__rem = (2 + (signed int)st->transl) - st->iolen;
    if(p_query_sm__1__1__5__rem >= 1)
    {
      signed long int return_value_write_30;
      return_value_write_30=write(st->sock, (const void *)((unsigned char *)st->msg + (signed long int)st->iolen), (unsigned long int)p_query_sm__1__1__5__rem);
      rv = (signed int)return_value_write_30;
      if(rv == -1)
      {
        signed int *return_value___errno_location_31;
        return_value___errno_location_31=__errno_location();
        if(*return_value___errno_location_31 == 11)
          return -1;

        signed int *return_value___errno_location_32;
        return_value___errno_location_32=__errno_location();
        st->s_errno = *return_value___errno_location_32;
        close(st->sock);
        if(st->iolen == 0)
        {
          _Bool tmp_if_expr_36;
          if(st->s_errno == 111)
            tmp_if_expr_36 = (_Bool)1;

          else
            tmp_if_expr_36 = st->s_errno == 104 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_37;
          if(tmp_if_expr_36)
            tmp_if_expr_37 = (_Bool)1;

          else
            tmp_if_expr_37 = st->s_errno == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_37)
          {
            char p_query_sm__1__1__5__1__1__1__1___debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              union anonymous_6 *tmp_if_expr_33;
              if(!(run_ipv4 == 0))
                tmp_if_expr_33 = (union anonymous_6 *)&st->a.sin4.sin_addr;

              else
                tmp_if_expr_33 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
              return_value_pdnsd_a2str_34=pdnsd_a2str(tmp_if_expr_33, p_query_sm__1__1__5__1__1__1__1___debugsockabuf, 46);
              return_value_strerror_35=strerror(st->s_errno);
              debug_msg(0, "TCP connection to %s failed: %s\n", return_value_pdnsd_a2str_34, return_value_strerror_35);
            }

            goto tcp_failed;
          }

        }

        char _debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_38;
          if(!(run_ipv4 == 0))
            tmp_if_expr_38 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_38 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_39=pdnsd_a2str(tmp_if_expr_38, _debugsockabuf, 46);
          return_value_strerror_40=strerror(st->s_errno);
          debug_msg(0, "Error while sending data to %s: %s\n", return_value_pdnsd_a2str_39, return_value_strerror_40);
        }

        goto __CPROVER_DUMP_L106;
      }

      st->iolen = st->iolen + rv;
      if(!(rv >= p_query_sm__1__1__5__rem))
        return -1;

    }

    st->state = (signed short int)3;
    st->iolen = 0;

  __CPROVER_DUMP_L50:
    ;
    if(st->iolen == 0)
    {
      unsigned short int recvl_net;
      signed long int return_value_read_41;
      return_value_read_41=read(st->sock, (void *)&recvl_net, sizeof(unsigned short int) /*2ul*/ );
      rv = (signed int)return_value_read_41;
      if(rv == -1)
      {
        return_value___errno_location_42=__errno_location();
        if(*return_value___errno_location_42 == 11)
          return -1;

      }

      if(!((unsigned long int)rv == sizeof(unsigned short int) /*2ul*/ ))
        goto error_receiv_data;

      st->iolen = rv;
      st->recvl=ntohs(recvl_net);
      void *return_value_realloc_or_cleanup_43;
      return_value_realloc_or_cleanup_43=realloc_or_cleanup((void *)st->recvbuf, (unsigned long int)st->recvl);
      st->recvbuf = (struct anonymous_29 *)return_value_realloc_or_cleanup_43;
      if(st->recvbuf == ((struct anonymous_29 *)NULL))
      {
        close(st->sock);
        if(!(debug_p == 0))
          debug_msg(0, "Out of memory in query.\n");

        retval = 0xffff;
        goto __CPROVER_DUMP_L106;
      }

    }

    signed int offset = (signed int)((unsigned long int)st->iolen - sizeof(unsigned short int) /*2ul*/ );
    signed int rem = (signed int)st->recvl - offset;
    if(rem >= 1)
    {
      signed long int return_value_read_44;
      return_value_read_44=read(st->sock, (void *)((unsigned char *)st->recvbuf + (signed long int)offset), (unsigned long int)rem);
      rv = (signed int)return_value_read_44;
      if(rv == -1)
      {
        signed int *return_value___errno_location_45;
        return_value___errno_location_45=__errno_location();
        if(*return_value___errno_location_45 == 11)
          return -1;

        goto error_receiv_data;
      }

      if(rv == 0)
        goto error_receiv_data;

      st->iolen = st->iolen + rv;
      if(!(rv >= rem))
        return -1;

    }

    close(st->sock);
    st->state = (signed short int)8;
    return 0;

  error_receiv_data:
    ;
    if(rv == -1)
    {
      return_value___errno_location_46=__errno_location();
      st->s_errno = *return_value___errno_location_46;
    }

    char p_query_sm__1__1__8___debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous_6 *tmp_if_expr_47;
      if(!(run_ipv4 == 0))
        tmp_if_expr_47 = (union anonymous_6 *)&st->a.sin4.sin_addr;

      else
        tmp_if_expr_47 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
      return_value_pdnsd_a2str_48=pdnsd_a2str(tmp_if_expr_47, p_query_sm__1__1__8___debugsockabuf, 46);
      char *tmp_if_expr_52;
      if(rv == -1)
      {
        return_value___errno_location_49=__errno_location();
        return_value_strerror_50=strerror(*return_value___errno_location_49);
        tmp_if_expr_52 = return_value_strerror_50;
      }

      else
      {
        if(rv == 0)
          tmp_if_expr_51 = st->iolen == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_51 = (_Bool)0;
        tmp_if_expr_52 = tmp_if_expr_51 ? "no data" : "incomplete data";
      }
      debug_msg(0, "Error while receiving data from %s: %s\n", return_value_pdnsd_a2str_48, tmp_if_expr_52);
    }

    close(st->sock);

  tcp_failed:
    ;
    if(!((signed int)st->qm == 14))
      break;

    switch_to_udp(st);
    char p_query_sm__1__1__9__1___debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous_6 *tmp_if_expr_53;
      if(!(run_ipv4 == 0))
        tmp_if_expr_53 = (union anonymous_6 *)&st->a.sin4.sin_addr;

      else
        tmp_if_expr_53 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
      return_value_pdnsd_a2str_54=pdnsd_a2str(tmp_if_expr_53, p_query_sm__1__1__9__1___debugsockabuf, 46);
      debug_msg(0, "TCP query to %s failed. Trying to use UDP.\n", return_value_pdnsd_a2str_54);
    }

  }
  goto __CPROVER_DUMP_L106;

__CPROVER_DUMP_L74:
  ;
  st->sock=socket(run_ipv4 != 0 ? 2 : 10, 2, 17);
  signed int *return_value___errno_location_55;
  char *return_value_strerror_56;
  signed int return_value_connect_72;
  signed int *return_value___errno_location_67;
  signed int *return_value___errno_location_58;
  signed int *return_value___errno_location_64;
  _Bool tmp_if_expr_66;
  signed int *return_value___errno_location_65;
  char abuf[46l];
  const char *return_value_pdnsd_a2str_60;
  signed int *return_value___errno_location_61;
  char *return_value_strerror_62;
  const char *return_value_inet_ntop_63;
  const char *return_value_pdnsd_a2str_69;
  signed int *return_value___errno_location_70;
  char *return_value_strerror_71;
  const char *return_value_pdnsd_a2str_75;
  signed int *return_value___errno_location_76;
  char *return_value_strerror_77;
  const char *return_value_pdnsd_a2str_82;
  signed int *return_value___errno_location_83;
  char *return_value_strerror_84;
  unsigned short int return_value_ntohs_86;
  if(st->sock == -1)
  {
    if(!(debug_p == 0))
    {
      return_value___errno_location_55=__errno_location();
      return_value_strerror_56=strerror(*return_value___errno_location_55);
      debug_msg(0, "Could not open socket: %s\n", return_value_strerror_56);
    }

  }

  else
  {
    signed int return_value_bind_socket_57;
    return_value_bind_socket_57=bind_socket(st->sock);
    if(return_value_bind_socket_57 == 0)
      close(st->sock);

    else
    {
      do
      {

      retry_udp_connect:
        ;
        return_value_connect_72=connect(st->sock, (struct sockaddr *)&st->a, (unsigned int)(run_ipv4 != 0 ? sizeof(struct sockaddr_in) /*16ul*/  : sizeof(struct sockaddr_in6) /*28ul*/ ));
        if(!(return_value_connect_72 == -1))
          goto __CPROVER_DUMP_L90;

        return_value___errno_location_67=__errno_location();
        if(*return_value___errno_location_67 == 111)
        {
          return_value___errno_location_58=__errno_location();
          st->s_errno = *return_value___errno_location_58;
          goto __CPROVER_DUMP_L86;
        }

        if(!(run_ipv4 == 0))
          goto __CPROVER_DUMP_L86;

        return_value___errno_location_64=__errno_location();
        if(*return_value___errno_location_64 == 101)
          tmp_if_expr_66 = (_Bool)1;

        else
        {
          return_value___errno_location_65=__errno_location();
          tmp_if_expr_66 = *return_value___errno_location_65 == 100 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr_66)
          break;

        if(st->a4fallback.s_addr == 0u)
          break;

        char p_query_sm__1__1__12__1__1___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_59;
          if(!(run_ipv4 == 0))
            tmp_if_expr_59 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_59 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_60=pdnsd_a2str(tmp_if_expr_59, p_query_sm__1__1__12__1__1___debugsockabuf, 46);
          return_value___errno_location_61=__errno_location();
          return_value_strerror_62=strerror(*return_value___errno_location_61);
          return_value_inet_ntop_63=inet_ntop(2, (const void *)&st->a4fallback, abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
          debug_msg(0, "Connecting to %s failed: %s, retrying with IPv4 address %s\n", return_value_pdnsd_a2str_60, return_value_strerror_62, return_value_inet_ntop_63);
        }

        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)3] = (&st->a4fallback)->s_addr;
        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)2]=htonl((unsigned int)0xffff);
        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0] = (unsigned int)0;
        ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)1] = ((unsigned int *)&st->a.sin6.sin6_addr)[(signed long int)0];
        st->a4fallback.s_addr = (unsigned int)0x00000000;
      }
      while((_Bool)1);

    __CPROVER_DUMP_L86:
      ;
      char p_query_sm__1__1__12__2___debugsockabuf[46l];
      if(!(debug_p == 0))
      {
        union anonymous_6 *tmp_if_expr_68;
        if(!(run_ipv4 == 0))
          tmp_if_expr_68 = (union anonymous_6 *)&st->a.sin4.sin_addr;

        else
          tmp_if_expr_68 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
        return_value_pdnsd_a2str_69=pdnsd_a2str(tmp_if_expr_68, p_query_sm__1__1__12__2___debugsockabuf, 46);
        return_value___errno_location_70=__errno_location();
        return_value_strerror_71=strerror(*return_value___errno_location_70);
        debug_msg(0, "Error while connecting to %s: %s\n", return_value_pdnsd_a2str_69, return_value_strerror_71);
      }

      close(st->sock);
      goto __CPROVER_DUMP_L106;

    __CPROVER_DUMP_L90:
      ;
      signed long int return_value_send_78;
      return_value_send_78=send(st->sock, (const void *)&st->msg->hdr, (unsigned long int)st->transl, 0);
      if(return_value_send_78 == -1l)
      {
        signed int *return_value___errno_location_73;
        return_value___errno_location_73=__errno_location();
        st->s_errno = *return_value___errno_location_73;
        char p_query_sm__1__1__13__1___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_74;
          if(!(run_ipv4 == 0))
            tmp_if_expr_74 = (union anonymous_6 *)&st->a.sin4.sin_addr;

          else
            tmp_if_expr_74 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_75=pdnsd_a2str(tmp_if_expr_74, p_query_sm__1__1__13__1___debugsockabuf, 46);
          return_value___errno_location_76=__errno_location();
          return_value_strerror_77=strerror(*return_value___errno_location_76);
          debug_msg(0, "Error while sending data to %s: %s\n", return_value_pdnsd_a2str_75, return_value_strerror_77);
        }

        close(st->sock);
        goto __CPROVER_DUMP_L106;
      }

      st->state = (signed short int)5;
      return -1;

    __CPROVER_DUMP_L95:
      ;
      signed int udpbufsize = st->edns_query != 0 ? global.udpbufsize : 512;
      void *return_value_realloc_or_cleanup_79;
      return_value_realloc_or_cleanup_79=realloc_or_cleanup((void *)st->recvbuf, (unsigned long int)udpbufsize);
      st->recvbuf = (struct anonymous_29 *)return_value_realloc_or_cleanup_79;
      if(st->recvbuf == ((struct anonymous_29 *)NULL))
      {
        close(st->sock);
        if(!(debug_p == 0))
          debug_msg(0, "Out of memory in query.\n");

        retval = 0xffff;
      }

      else
      {
        signed long int return_value_recv_85;
        return_value_recv_85=recv(st->sock, (void *)st->recvbuf, (unsigned long int)udpbufsize, 0);
        rv = (signed int)return_value_recv_85;
        if(rv == -1)
        {
          signed int *return_value___errno_location_80;
          return_value___errno_location_80=__errno_location();
          st->s_errno = *return_value___errno_location_80;
          char p_query_sm__1__1__14__2__1___debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous_6 *tmp_if_expr_81;
            if(!(run_ipv4 == 0))
              tmp_if_expr_81 = (union anonymous_6 *)&st->a.sin4.sin_addr;

            else
              tmp_if_expr_81 = (union anonymous_6 *)&st->a.sin6.sin6_addr;
            return_value_pdnsd_a2str_82=pdnsd_a2str(tmp_if_expr_81, p_query_sm__1__1__14__2__1___debugsockabuf, 46);
            return_value___errno_location_83=__errno_location();
            return_value_strerror_84=strerror(*return_value___errno_location_83);
            debug_msg(0, "Error while receiving data from %s: %s\n", return_value_pdnsd_a2str_82, return_value_strerror_84);
          }

          close(st->sock);
          goto __CPROVER_DUMP_L106;
        }

        st->recvl = (unsigned short int)rv;
        _Bool tmp_if_expr_87;
        if(!((unsigned long int)st->recvl >= sizeof(struct anonymous_29) /*12ul*/ ))
          tmp_if_expr_87 = (_Bool)1;

        else
        {
          return_value_ntohs_86=ntohs(st->recvbuf->id);
          tmp_if_expr_87 = return_value_ntohs_86 != st->myrid ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_87)
        {
          if(!(debug_p == 0))
            debug_msg(0, "Bad answer received. Ignoring it.\n");

          st->state = (signed short int)5;
          return -1;
        }

        close(st->sock);
        st->state = (signed short int)8;
        return 0;
      }
    }
  }

__CPROVER_DUMP_L106:
  ;
  st->state = (signed short int)8;
  return retval;
}

// p_recursive_query
// file dns_query.c line 2070
static signed int p_recursive_query(struct anonymous_4 *q, const unsigned char *name, signed int thint, struct anonymous_0 **entp, signed int *nocache, signed int hops, struct qstatnode_s *qslist, struct qhintnode_s *qhlist, unsigned char *c_soa)
{
  struct anonymous_0 *ent;
  struct anonymous_0 *entsave = (struct anonymous_0 *)(void *)0;
  signed int i;
  signed int j;
  signed int k;
  signed int rv = 2;
  signed int qualval = 0;
  struct anonymous_5 *qse = (struct anonymous_5 *)(void *)0;
  struct _dynamic_list_head *ns = (struct _dynamic_list_head *)(void *)0;
  struct _dynamic_list_head *nssave = (struct _dynamic_list_head *)(void *)0;
  struct anonymous_4 *serv = (struct anonymous_4 *)(void *)0;
  struct anonymous_4 *servsave = (struct anonymous_4 *)(void *)0;
  signed long int ts0;
  ts0=time((signed long int *)(void *)0);
  signed long int global_timeout = global.timeout;
  signed int dc = 0;
  signed int mc = 0;
  signed int nq;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link2((struct anonymous_3 *)q);
  nq = (signed int)return_value_da_nel_1;
  signed int parqueries = global.par_queries;
  j = 0;
  const char *return_value_pdnsd_a2str_3;
  signed int p_recursive_query__1__1__1__1__1__1__1__2__authok;
  const char *return_value_pdnsd_a2str_5;
  const char *return_value_pdnsd_a2str_9;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_19;
  const char *return_value_pdnsd_a2str_15;
  const char *return_value_pdnsd_a2str_17;
  signed long int return_value_time_21;
  signed int authok;
  const char *return_value_pdnsd_a2str_24;
  const char *return_value_pdnsd_a2str_28;
  for( ; !(j >= nq); j = j + parqueries)
  {
    mc = j + parqueries;
    if(!(nq >= mc))
      mc = nq;

    i = dc;
    for( ; !(i >= mc); i = i + 1)
    {
      struct anonymous_5 *p_recursive_query__1__1__1__1__1__1__qs = &q->elem[(signed long int)i];
      if(i >= j)
      {
        char p_recursive_query__1__1__1__1__1__1__1__1___debugsockabuf[46l];
        if(!(debug_p == 0))
        {
          union anonymous_6 *tmp_if_expr_2;
          if(!(run_ipv4 == 0))
            tmp_if_expr_2 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__1__1__qs->a.sin4.sin_addr;

          else
            tmp_if_expr_2 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__1__1__qs->a.sin6.sin6_addr;
          return_value_pdnsd_a2str_3=pdnsd_a2str(tmp_if_expr_2, p_recursive_query__1__1__1__1__1__1__1__1___debugsockabuf, 46);
          debug_msg(0, "Sending query to %s\n", return_value_pdnsd_a2str_3);
        }

        do
        {

        retryquery:
          ;
          rv=p_exec_query(&ent, name, thint, p_recursive_query__1__1__1__1__1__1__qs, &ns, c_soa);
          if(!(rv == 0))
            goto __CPROVER_DUMP_L26;

          char p_recursive_query__1__1__1__1__1__1__1__2__1___debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous_6 *tmp_if_expr_4;
            if(!(run_ipv4 == 0))
              tmp_if_expr_4 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__1__1__qs->a.sin4.sin_addr;

            else
              tmp_if_expr_4 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__1__1__qs->a.sin6.sin6_addr;
            return_value_pdnsd_a2str_5=pdnsd_a2str(tmp_if_expr_4, p_recursive_query__1__1__1__1__1__1__1__2__1___debugsockabuf, 46);
            debug_msg(0, "Query to %s succeeded.\n", return_value_pdnsd_a2str_5);
          }

          p_recursive_query__1__1__1__1__1__1__1__2__authok=auth_ok(q, name, thint, ent, hops, qslist, qhlist, p_recursive_query__1__1__1__1__1__1__qs, ns, &serv);
          if(!(p_recursive_query__1__1__1__1__1__1__1__2__authok == 0))
          {
            if(p_recursive_query__1__1__1__1__1__1__1__2__authok >= 0)
            {
              if(p_recursive_query__1__1__1__1__1__1__qs->failed == 0)
              {
                _Bool tmp_if_expr_6;
                if((signed int)p_recursive_query__1__1__1__1__1__1__qs->qm == 15)
                  tmp_if_expr_6 = p_recursive_query__1__1__1__1__1__1__qs->tc != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_6 = (_Bool)0;
                if(!tmp_if_expr_6)
                {
                  qse = p_recursive_query__1__1__1__1__1__1__qs;
                  mc = i;
                  goto done;
                }

              }

            }

            else
            {
              mc = i;
              goto free_ent_return_failed;
            }
          }

          signed int p_recursive_query__1__1__1__1__1__1__1__2__3__qval = p_recursive_query__1__1__1__1__1__1__1__2__authok * 8 + (3 - (signed int)p_recursive_query__1__1__1__1__1__1__qs->failed) * 2 + (signed int)!(p_recursive_query__1__1__1__1__1__1__qs->tc != 0) * 1;
          if(!(entsave == ((struct anonymous_0 *)NULL)) && !(qualval >= p_recursive_query__1__1__1__1__1__1__1__2__3__qval))
          {
            free_cent(entsave);
            free((void *)entsave);
            entsave = (struct anonymous_0 *)(void *)0;
            del_qserv(servsave);
            free((void *)nssave);
          }

          if(entsave == ((struct anonymous_0 *)NULL))
          {
            entsave = ent;
            servsave = serv;
            unsigned int return_value_da_nel_7;
            return_value_da_nel_7=da_nel_link2((struct anonymous_3 *)serv);
            if(return_value_da_nel_7 >= 1u)
              nssave = ns;

            else
            {
              nssave = (struct _dynamic_list_head *)(void *)0;
              free((void *)ns);
            }
            qualval = p_recursive_query__1__1__1__1__1__1__1__2__3__qval;
            qse = p_recursive_query__1__1__1__1__1__1__qs;
          }

          else
          {
            free_cent(ent);
            free((void *)ent);
            del_qserv(serv);
            free((void *)ns);
          }
          serv = (struct anonymous_4 *)(void *)0;
          ns = (struct _dynamic_list_head *)(void *)0;
          if(!((signed int)p_recursive_query__1__1__1__1__1__1__qs->qm == 15))
            break;

          if(p_recursive_query__1__1__1__1__1__1__qs->tc == 0)
            break;

          switch_to_tcp(p_recursive_query__1__1__1__1__1__1__qs);
          char p_recursive_query__1__1__1__1__1__1__1__2__4__1___debugsockabuf[46l];
          if(!(debug_p == 0))
          {
            union anonymous_6 *tmp_if_expr_8;
            if(!(run_ipv4 == 0))
              tmp_if_expr_8 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__1__1__qs->a.sin4.sin_addr;

            else
              tmp_if_expr_8 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__1__1__qs->a.sin6.sin6_addr;
            return_value_pdnsd_a2str_9=pdnsd_a2str(tmp_if_expr_8, p_recursive_query__1__1__1__1__1__1__1__2__4__1___debugsockabuf, 46);
            debug_msg(0, "Reply from %s was truncated. Trying again using TCP.\n", return_value_pdnsd_a2str_9);
          }

        }
        while((_Bool)1);
        goto __CPROVER_DUMP_L27;

      __CPROVER_DUMP_L26:
        ;
        if(rv == 3 || rv == 0xffff)
        {
          mc = i;
          goto done;
        }

      }


    __CPROVER_DUMP_L27:
      ;
      if((signed int)p_recursive_query__1__1__1__1__1__1__qs->state == 8)
      {
        if(i == dc)
          dc = dc + 1;

      }

    }
    if(!(dc >= mc))
    {
      signed long int ts;
      signed long int maxto;
      signed long int now;
      signed int pc;
      signed int nevents;
      signed int ic;
      const signed long int ic_array_size0 = (signed long int)(mc - dc);
      struct pollfd polls[ic_array_size0];
      ts=time((signed long int *)(void *)0);
      do
      {
        maxto = (signed long int)0;
        pc = 0;
        rv = 2;
        i = dc;
        for( ; !(i >= mc); i = i + 1)
        {
          struct anonymous_5 *p_recursive_query__1__1__1__1__2__1__1__1__qs = &q->elem[(signed long int)i];
          if(!((signed int)p_recursive_query__1__1__1__1__2__1__1__1__qs->state == 8))
          {
            if(i >= j)
            {
              if(!(maxto >= p_recursive_query__1__1__1__1__2__1__1__1__qs->timeout))
                maxto = p_recursive_query__1__1__1__1__2__1__1__1__qs->timeout;

            }

            polls[(signed long int)pc].fd = p_recursive_query__1__1__1__1__2__1__1__1__qs->sock;
            switch((signed int)p_recursive_query__1__1__1__1__2__1__1__1__qs->state)
            {
              case 3:

              case 5:
              {
                polls[(signed long int)pc].events = (signed short int)0x001;
                break;
              }
              case 2:
              {
                polls[(signed long int)pc].events = (signed short int)0x004;
                break;
              }
              default:
                polls[(signed long int)pc].events = (signed short int)0;
            }
            pc = pc + 1;
          }

        }
        if(pc == 0)
        {
          dc = mc;
          break;
        }

        now=time((signed long int *)(void *)0);
        maxto = maxto - (now - ts);
        if(mc == nq)
        {
          i = j;
          for( ; !(i >= mc); i = i + 1)
          {
            struct anonymous_5 *p_recursive_query__1__1__1__1__2__1__3__1__1__qs = &q->elem[(signed long int)i];
            if((signed int)p_recursive_query__1__1__1__1__2__1__3__1__1__qs->qm == 14)
            {
              _Bool tmp_if_expr_11;
              if((signed int)p_recursive_query__1__1__1__1__2__1__3__1__1__qs->state == 2)
                tmp_if_expr_11 = (_Bool)1;

              else
              {
                if((signed int)p_recursive_query__1__1__1__1__2__1__3__1__1__qs->state == 3)
                  tmp_if_expr_10 = p_recursive_query__1__1__1__1__2__1__3__1__1__qs->iolen == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_10 = (_Bool)0;
                tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_11)
                goto skip_globto;

            }

          }
          signed long int globto = global_timeout - (now - ts0);
          if(!(maxto >= globto))
            maxto = globto;

        }


      skip_globto:
        ;
        nevents=poll(polls, (unsigned long int)pc, (signed int)(maxto > (signed long int)0 ? maxto * (signed long int)1000 : (signed long int)0));
        if(!(nevents >= 0))
        {
          signed int *return_value___errno_location_12;
          return_value___errno_location_12=__errno_location();
          char *return_value_strerror_13;
          return_value_strerror_13=strerror(*return_value___errno_location_12);
          log_message(4, "poll/select failed: %s", return_value_strerror_13);
          goto done;
        }

        if(nevents == 0)
        {
          i = j;
          for( ; !(i >= mc); i = i + 1)
          {
            struct anonymous_5 *p_recursive_query__1__1__1__1__2__1__5__1__1__qs = &q->elem[(signed long int)i];
            if(!((signed int)p_recursive_query__1__1__1__1__2__1__5__1__1__qs->state == 8))
            {
              if(!(p_recursive_query__1__1__1__1__2__1__5__1__1__qs->needs_testing == 0))
                p_recursive_query__1__1__1__1__2__1__5__1__1__qs->needs_testing = (char)2;

            }

            if((signed int)p_recursive_query__1__1__1__1__2__1__5__1__1__qs->qm == 14)
            {
              _Bool tmp_if_expr_20;
              if((signed int)p_recursive_query__1__1__1__1__2__1__5__1__1__qs->state == 2)
                tmp_if_expr_20 = (_Bool)1;

              else
              {
                if((signed int)p_recursive_query__1__1__1__1__2__1__5__1__1__qs->state == 3)
                  tmp_if_expr_19 = p_recursive_query__1__1__1__1__2__1__5__1__1__qs->iolen == 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_19 = (_Bool)0;
                tmp_if_expr_20 = tmp_if_expr_19 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_20)
              {
                close(p_recursive_query__1__1__1__1__2__1__5__1__1__qs->sock);
                switch_to_udp(p_recursive_query__1__1__1__1__2__1__5__1__1__qs);
                char p_recursive_query__1__1__1__1__2__1__5__1__1__1__1___debugsockabuf[46l];
                if(!(debug_p == 0))
                {
                  union anonymous_6 *tmp_if_expr_14;
                  if(!(run_ipv4 == 0))
                    tmp_if_expr_14 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__2__1__5__1__1__qs->a.sin4.sin_addr;

                  else
                    tmp_if_expr_14 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__2__1__5__1__1__qs->a.sin6.sin6_addr;
                  return_value_pdnsd_a2str_15=pdnsd_a2str(tmp_if_expr_14, p_recursive_query__1__1__1__1__2__1__5__1__1__1__1___debugsockabuf, 46);
                  debug_msg(0, "TCP connection to %s timed out. Trying to use UDP.\n", return_value_pdnsd_a2str_15);
                }

                rv=p_exec_query(&ent, name, thint, p_recursive_query__1__1__1__1__2__1__5__1__1__qs, &ns, c_soa);
                if(rv == 0)
                {
                  signed int p_recursive_query__1__1__1__1__2__1__5__1__1__1__2__authok;
                  char _debugsockabuf[46l];
                  if(!(debug_p == 0))
                  {
                    union anonymous_6 *tmp_if_expr_16;
                    if(!(run_ipv4 == 0))
                      tmp_if_expr_16 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__2__1__5__1__1__qs->a.sin4.sin_addr;

                    else
                      tmp_if_expr_16 = (union anonymous_6 *)&p_recursive_query__1__1__1__1__2__1__5__1__1__qs->a.sin6.sin6_addr;
                    return_value_pdnsd_a2str_17=pdnsd_a2str(tmp_if_expr_16, _debugsockabuf, 46);
                    debug_msg(0, "Query to %s succeeded.\n", return_value_pdnsd_a2str_17);
                  }

                  p_recursive_query__1__1__1__1__2__1__5__1__1__1__2__authok=auth_ok(q, name, thint, ent, hops, qslist, qhlist, p_recursive_query__1__1__1__1__2__1__5__1__1__qs, ns, &serv);
                  if(!(p_recursive_query__1__1__1__1__2__1__5__1__1__1__2__authok == 0))
                  {
                    if(p_recursive_query__1__1__1__1__2__1__5__1__1__1__2__authok >= 0)
                    {
                      if(p_recursive_query__1__1__1__1__2__1__5__1__1__qs->failed == 0)
                      {
                        qse = p_recursive_query__1__1__1__1__2__1__5__1__1__qs;
                        goto done;
                      }

                    }

                    else
                      goto free_ent_return_failed;
                  }

                  signed int qval = p_recursive_query__1__1__1__1__2__1__5__1__1__1__2__authok * 8 + (3 - (signed int)p_recursive_query__1__1__1__1__2__1__5__1__1__qs->failed) * 2 + (signed int)!(p_recursive_query__1__1__1__1__2__1__5__1__1__qs->tc != 0) * 1;
                  if(!(entsave == ((struct anonymous_0 *)NULL)) && !(qualval >= qval))
                  {
                    free_cent(entsave);
                    free((void *)entsave);
                    entsave = (struct anonymous_0 *)(void *)0;
                    del_qserv(servsave);
                    free((void *)nssave);
                  }

                  if(entsave == ((struct anonymous_0 *)NULL))
                  {
                    entsave = ent;
                    servsave = serv;
                    unsigned int return_value_da_nel_18;
                    return_value_da_nel_18=da_nel_link2((struct anonymous_3 *)serv);
                    if(return_value_da_nel_18 >= 1u)
                      nssave = ns;

                    else
                    {
                      nssave = (struct _dynamic_list_head *)(void *)0;
                      free((void *)ns);
                    }
                    qualval = qval;
                    qse = p_recursive_query__1__1__1__1__2__1__5__1__1__qs;
                  }

                  else
                  {
                    free_cent(ent);
                    free((void *)ent);
                    del_qserv(serv);
                    free((void *)ns);
                  }
                  serv = (struct anonymous_4 *)(void *)0;
                  ns = (struct _dynamic_list_head *)(void *)0;
                }

                else
                  if(rv == 3 || rv == 0xffff)
                    goto done;

                nevents = nevents + 1;
              }

            }

          }
          if(mc == nq)
          {
            if(!(nevents == 0))
            {
              return_value_time_21=time((signed long int *)(void *)0);
              if(!(return_value_time_21 + -ts0 >= global_timeout))
                continue;

            }

          }

          break;
        }

        ic = 0;
        i = dc;
        for( ; !(i >= mc); i = i + 1)
        {
          struct anonymous_5 *qs = &q->elem[(signed long int)i];
          if(!((signed int)qs->state == 8))
          {
            signed int srv_event = 0;
            while((_Bool)1)
            {
              if(ic >= pc)
              {
                log_message(3, "%s:%d: %s", (const void *)"dns_query.c", 2364, (const void *)"file descriptor not found in poll() array");
                pdnsd_exit();
              }

              signed int tmp_post_22 = ic;
              ic = ic + 1;
              k = tmp_post_22;
              if(polls[(signed long int)k].fd == qs->sock)
                break;

            }
            switch((signed int)qs->state)
            {
              case 3:

              case 5:
              {
                srv_event = (signed int)polls[(signed long int)k].revents & (0x001 | 0x008 | 0x010 | 0x020);
                break;
              }
              case 2:
                srv_event = (signed int)polls[(signed long int)k].revents & (0x004 | 0x008 | 0x010 | 0x020);
            }
            if(!(srv_event == 0))
            {
              nevents = nevents - 1;
              do
              {

              retryquery2:
                ;
                rv=p_exec_query(&ent, name, thint, qs, &ns, c_soa);
                if(!(rv == 0))
                  goto __CPROVER_DUMP_L104;

                char p_recursive_query__1__1__1__1__2__1__6__1__1__3__1__1___debugsockabuf[46l];
                if(!(debug_p == 0))
                {
                  union anonymous_6 *tmp_if_expr_23;
                  if(!(run_ipv4 == 0))
                    tmp_if_expr_23 = (union anonymous_6 *)&qs->a.sin4.sin_addr;

                  else
                    tmp_if_expr_23 = (union anonymous_6 *)&qs->a.sin6.sin6_addr;
                  return_value_pdnsd_a2str_24=pdnsd_a2str(tmp_if_expr_23, p_recursive_query__1__1__1__1__2__1__6__1__1__3__1__1___debugsockabuf, 46);
                  debug_msg(0, "Query to %s succeeded.\n", return_value_pdnsd_a2str_24);
                }

                authok=auth_ok(q, name, thint, ent, hops, qslist, qhlist, qs, ns, &serv);
                if(!(authok == 0))
                {
                  if(authok >= 0)
                  {
                    if(qs->failed == 0)
                    {
                      _Bool tmp_if_expr_25;
                      if((signed int)qs->qm == 15)
                        tmp_if_expr_25 = qs->tc != 0 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_25 = (_Bool)0;
                      if(!tmp_if_expr_25)
                      {
                        qse = qs;
                        goto done;
                      }

                    }

                  }

                  else
                    goto free_ent_return_failed;
                }

                signed int p_recursive_query__1__1__1__1__2__1__6__1__1__3__1__3__qval = authok * 8 + (3 - (signed int)qs->failed) * 2 + (signed int)!(qs->tc != 0) * 1;
                if(!(entsave == ((struct anonymous_0 *)NULL)) && !(qualval >= p_recursive_query__1__1__1__1__2__1__6__1__1__3__1__3__qval))
                {
                  free_cent(entsave);
                  free((void *)entsave);
                  entsave = (struct anonymous_0 *)(void *)0;
                  del_qserv(servsave);
                  free((void *)nssave);
                }

                if(entsave == ((struct anonymous_0 *)NULL))
                {
                  entsave = ent;
                  servsave = serv;
                  unsigned int return_value_da_nel_26;
                  return_value_da_nel_26=da_nel_link2((struct anonymous_3 *)serv);
                  if(return_value_da_nel_26 >= 1u)
                    nssave = ns;

                  else
                  {
                    nssave = (struct _dynamic_list_head *)(void *)0;
                    free((void *)ns);
                  }
                  qualval = p_recursive_query__1__1__1__1__2__1__6__1__1__3__1__3__qval;
                  qse = qs;
                }

                else
                {
                  free_cent(ent);
                  free((void *)ent);
                  del_qserv(serv);
                  free((void *)ns);
                }
                serv = (struct anonymous_4 *)(void *)0;
                ns = (struct _dynamic_list_head *)(void *)0;
                if(!((signed int)qs->qm == 15))
                  break;

                if(qs->tc == 0)
                  break;

                switch_to_tcp(qs);
                char p_recursive_query__1__1__1__1__2__1__6__1__1__3__1__4__1___debugsockabuf[46l];
                if(!(debug_p == 0))
                {
                  union anonymous_6 *tmp_if_expr_27;
                  if(!(run_ipv4 == 0))
                    tmp_if_expr_27 = (union anonymous_6 *)&qs->a.sin4.sin_addr;

                  else
                    tmp_if_expr_27 = (union anonymous_6 *)&qs->a.sin6.sin6_addr;
                  return_value_pdnsd_a2str_28=pdnsd_a2str(tmp_if_expr_27, p_recursive_query__1__1__1__1__2__1__6__1__1__3__1__4__1___debugsockabuf, 46);
                  debug_msg(0, "Reply from %s was truncated. Trying again using TCP.\n", return_value_pdnsd_a2str_28);
                }

              }
              while((_Bool)1);
              goto __CPROVER_DUMP_L105;

            __CPROVER_DUMP_L104:
              ;
              if(rv == 3 || rv == 0xffff)
                goto done;

            }

          }


        __CPROVER_DUMP_L105:
          ;
          if((signed int)qs->state == 8)
          {
            if(i == dc)
              dc = dc + 1;

          }

        }
        if(nevents >= 1)
        {
          poll_errs = poll_errs + 1ul;
          if(!(poll_errs >= 11ul))
            log_message(3, "%d unhandled poll/select event(s) in p_recursive_query() at %s, line %d.", nevents, (const void *)"dns_query.c", 2426);

          rv = 2;
          goto done;
        }

      }
      while(!(dc >= mc));
    }

  }
  goto cancel_queries;

free_ent_return_failed:
  ;
  free_cent(ent);
  free((void *)ent);
  rv = 0xffff;

done:
  ;
  if(!(entsave == ((struct anonymous_0 *)NULL)))
  {
    free_cent(entsave);
    free((void *)entsave);
    entsave = (struct anonymous_0 *)(void *)0;
    del_qserv(servsave);
    free((void *)nssave);
  }


cancel_queries:
  ;
  i = dc;
  for( ; !(i >= mc); i = i + 1)
    p_cancel_query(&q->elem[(signed long int)i]);
  signed int n = 0;
  i = 0;
  for( ; !(i >= mc); i = i + 1)
    if((signed int)q->elem[(signed long int)i].needs_testing >= 2)
      n = n + 1;

  if(n >= 1)
  {
    const signed long int n_array_size0 = (signed long int)n;
    union anonymous_6 addrs[n_array_size0];
    k = 0;
    i = 0;
    for( ; !(i >= mc); i = i + 1)
    {
      struct anonymous_5 *p_recursive_query__1__1__4__2__1__1__qs = &q->elem[(signed long int)i];
      if((signed int)p_recursive_query__1__1__4__2__1__1__qs->needs_testing >= 2)
      {
        signed int tmp_post_29 = k;
        k = k + 1;
        union anonymous_6 *tmp_if_expr_30;
        if(!(run_ipv4 == 0))
          tmp_if_expr_30 = (union anonymous_6 *)&p_recursive_query__1__1__4__2__1__1__qs->a.sin4.sin_addr;

        else
          tmp_if_expr_30 = (union anonymous_6 *)&p_recursive_query__1__1__4__2__1__1__qs->a.sin6.sin6_addr;
        addrs[(signed long int)tmp_post_29] = *tmp_if_expr_30;
      }

    }
    sched_server_test(addrs, n, -1);
  }

  const char *return_value_pdnsd_a2str_32;
  const char *return_value_get_ename_35;
  if(!(entsave == ((struct anonymous_0 *)NULL)))
  {
    char p_recursive_query__1__2__1___debugsockabuf[46l];
    if(!(debug_p == 0))
    {
      union anonymous_6 *tmp_if_expr_31;
      if(!(run_ipv4 == 0))
        tmp_if_expr_31 = (union anonymous_6 *)&qse->a.sin4.sin_addr;

      else
        tmp_if_expr_31 = (union anonymous_6 *)&qse->a.sin6.sin6_addr;
      return_value_pdnsd_a2str_32=pdnsd_a2str(tmp_if_expr_31, p_recursive_query__1__2__1___debugsockabuf, 46);
      debug_msg(0, "Using %s reply from %s.\n", !((qualval & 6) != 0) ? "reportedly failed" : (!((qualval & 2) != 0) ? "inconsistent" : (!((qualval & 1) != 0) ? "truncated" : (!((qualval & 8) != 0) ? "non-authoritative" : "good"))), return_value_pdnsd_a2str_32);
    }

    ent = entsave;
    serv = servsave;
    ns = nssave;
    if(!(qualval >= 2))
    {
      if((1 & (signed int)ent->flags) == 0)
      {
        signed int jlim;
        signed int tmp_if_expr_33;
        if(!((1 & (signed int)ent->flags) == 0))
          tmp_if_expr_33 = 0;

        else
          tmp_if_expr_33 = ent->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        jlim = tmp_if_expr_33;
        j = 0;
        for( ; !(j >= jlim); j = j + 1)
        {
          struct anonymous *rrs;
          struct anonymous *tmp_if_expr_34;
          if(!(j >= 8))
            tmp_if_expr_34 = ent->_anon0.rr.rrmu[(signed long int)j];

          else
            tmp_if_expr_34 = ent->_anon0.rr.rrext[(signed long int)(j - 8)];
          rrs = tmp_if_expr_34;
          if(!(rrs == ((struct anonymous *)NULL)))
            rrs->flags = rrs->flags | (unsigned short int)8;

        }
      }

      else
        ent->flags = ent->flags | (unsigned short int)8;
    }

    rv = 0;
  }

  else
    if(!(rv == 0))
    {
      if(rv == 0xffff)
      {
        if(!(debug_p == 0))
          debug_msg(0, "Unrecoverable error encountered while processing query.\n");

        rv = 2;
      }

      if(!(debug_p == 0))
      {
        return_value_get_ename_35=get_ename(rv);
        debug_msg(0, "No query succeeded. Returning error code \"%s\"\n", return_value_get_ename_35);
      }

      goto clean_up_return;
    }

  if(!(nocache == ((signed int *)NULL)))
    *nocache = (signed int)qse->nocache;

  unsigned int return_value_da_nel_40;
  return_value_da_nel_40=da_nel_link2((struct anonymous_3 *)serv);
  if(return_value_da_nel_40 >= 1u)
  {
    struct qstatnode_s qsn = { .qa=q, .next=qslist };
    unsigned char save_ns = ent->c_ns;
    unsigned char save_soa = ent->c_soa;
    free_cent(ent);
    free((void *)ent);
    signed long int return_value_time_36;
    return_value_time_36=time((signed long int *)(void *)0);
    rv=p_dns_cached_resolve(serv, name, thint, &ent, hops - 1, &qsn, qhlist, return_value_time_36, c_soa);
    if(rv == 0)
    {
      if(!((signed int)save_ns == 0xff))
      {
        _Bool tmp_if_expr_37;
        if((signed int)ent->c_ns == 0xff)
          tmp_if_expr_37 = (_Bool)1;

        else
          tmp_if_expr_37 = (signed int)ent->c_ns < (signed int)save_ns ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_37)
          ent->c_ns = save_ns;

      }

      if(!((signed int)save_soa == 0xff))
      {
        _Bool tmp_if_expr_38;
        if((signed int)ent->c_soa == 0xff)
          tmp_if_expr_38 = (_Bool)1;

        else
          tmp_if_expr_38 = (signed int)ent->c_soa < (signed int)save_soa ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_38)
          ent->c_soa = save_soa;

      }

    }

    else
      if(rv == 3 && !(c_soa == ((unsigned char *)NULL)))
      {
        if(!((signed int)save_soa == 0xff))
        {
          _Bool tmp_if_expr_39;
          if((signed int)*c_soa == 0xff)
            tmp_if_expr_39 = (_Bool)1;

          else
            tmp_if_expr_39 = (signed int)*c_soa < (signed int)save_soa ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_39)
            *c_soa = save_soa;

        }

      }

  }


clean_up_return:
  ;
  del_qserv(serv);
  free((void *)ns);
  if(rv == 0)
    *entp = ent;

  return rv;
}

// parse_ip
// file conf-parser.c line 1841
static const char * parse_ip(const char *ipstr, union anonymous_6 *a)
{
  if(cmdlineipv == 0)
    cmdlineipv = (signed short int)-2;

  signed int return_value_strcmp_3;
  return_value_strcmp_3=strcmp(ipstr, "any");
  signed int return_value_str2pdnsd_a_2;
  signed int return_value_inet_pton_1;
  if(return_value_strcmp_3 == 0)
  {
    if(!(run_ipv4 == 0))
      a->ipv4.s_addr = (unsigned int)0x00000000;

    else
      a->ipv6 = in6addr_any;
  }

  else
  {
    return_value_str2pdnsd_a_2=str2pdnsd_a(ipstr, a);
    if(return_value_str2pdnsd_a_2 == 0)
    {
      if(!(run_ipv4 == 0))
      {
        return_value_inet_pton_1=inet_pton(10, ipstr, (void *)&a->ipv6);
        if(return_value_inet_pton_1 >= 1)
          return "You should set run_ipv4=off or use the command-line option -6 before specifying an IPv6 address";

      }

      return "bad IP address";
    }

  }
  return (const char *)(void *)0;
}

// parsestr2rhn
// file helpers.h line 54
const char * parsestr2rhn(const unsigned char *str, unsigned int len, unsigned char *rhn)
{
  unsigned int i;
  unsigned int j;
  if(len >= 1u)
  {
    if((signed int)*str == 46)
    {
      _Bool tmp_if_expr_1;
      if(len == 1u)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = !(str[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        rhn[(signed long int)0] = (unsigned char)0;
        return (const char *)(void *)0;
      }

    }

  }

  i = (unsigned int)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_2;
  do
  {
    unsigned int jlim = i + (unsigned int)63;
    if(jlim >= 255u)
      jlim = (unsigned int)(256 - 2);

    j = i;
    do
    {
      if(!(j >= len))
        tmp_if_expr_3 = str[(signed long int)j] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (signed int)str[(signed long int)j] != 46 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!tmp_if_expr_4)
        break;

      if(j >= jlim)
        return "Domain name element too long";

      rhn[(signed long int)(j + (unsigned int)1)] = str[(signed long int)j];
      j = j + 1u;
    }
    while((_Bool)1);
    if(i >= j)
    {
      _Bool tmp_if_expr_5;
      if(!(j >= len))
        tmp_if_expr_5 = str[(signed long int)j] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        return "Empty name element in domain name";

      else
        break;
    }

    rhn[(signed long int)i] = (unsigned char)(j - i);
    i = j + (unsigned int)1;
    if(!(j >= len))
      tmp_if_expr_2 = str[(signed long int)j] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  rhn[(signed long int)i] = (unsigned char)0;
  if(i == 0u)
    return "Empty domain name not allowed";

  else
    return (const char *)(void *)0;
}

// pdnsd_a2str
// file helpers.h line 157
const char * pdnsd_a2str(union anonymous_6 *a, char *buf, signed int maxlen)
{
  const char *res;
  const char *tmp_if_expr_3;
  const char *return_value_inet_ntop_1;
  const char *return_value_inet_ntop_2;
  if(!(run_ipv4 == 0))
  {
    return_value_inet_ntop_1=inet_ntop(2, (const void *)&a->ipv4, buf, (unsigned int)maxlen);
    tmp_if_expr_3 = return_value_inet_ntop_1;
  }

  else
  {
    return_value_inet_ntop_2=inet_ntop(10, (const void *)&a->ipv6, buf, (unsigned int)maxlen);
    tmp_if_expr_3 = return_value_inet_ntop_2;
  }
  res = tmp_if_expr_3;
  if(res == ((const char *)NULL))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    log_message(3, "inet_ntop: %s", return_value_strerror_5);
    return "?.?.?.?";
  }

  return res;
}

// pdnsd_exit
// file pdnsd_assert.h line 38
void pdnsd_exit(void)
{
  pthread_kill(main_thrid, 15);
  pthread_exit((void *)0);
}

// ping
// file icmp.c line 514
signed int ping(union anonymous_6 *addr, signed int timeout, signed int rep)
{
  signed int return_value_ping4_1;
  _Bool tmp_statement_expression_4;
  unsigned int return_value_htonl_6;
  signed int return_value_ping6_3;
  if(run_ipv4 == 0 ? ping6_isocket == -1 : ping_isocket == -1)
    return -1;

  else
  {
    timeout = timeout / 10;
    if(!(run_ipv4 == 0))
    {
      return_value_ping4_1=ping4(addr->ipv4, timeout, rep);
      return return_value_ping4_1;
    }

    else
    {
      _Bool tmp_if_expr_8;
      if(!(ping_isocket == -1))
      {
        struct in6_addr *__a = (struct in6_addr *)&addr->ipv6;
        _Bool tmp_if_expr_5;
        if(__a->__in6_u.__u6_addr32[0l] == 0u)
          tmp_if_expr_5 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        _Bool tmp_if_expr_7;
        if(tmp_if_expr_5)
        {
          return_value_htonl_6=htonl((unsigned int)0xffff);
          tmp_if_expr_7 = __a->__in6_u.__u6_addr32[(signed long int)2] == return_value_htonl_6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        tmp_statement_expression_4 = tmp_if_expr_7;
        tmp_if_expr_8 = tmp_statement_expression_4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        struct in_addr v4;
        v4.s_addr = ((unsigned int *)&addr->ipv6)[(signed long int)3];
        signed int return_value_ping4_2;
        return_value_ping4_2=ping4(v4, timeout, rep);
        return return_value_ping4_2;
      }

      else
      {
        return_value_ping6_3=ping6(addr->ipv6, timeout, rep);
        return return_value_ping6_3;
      }
    }
    return -1;
  }
}

// ping4
// file icmp.c line 160
static signed int ping4(struct in_addr addr, signed int timeout, signed int rep)
{
  signed int i;
  signed int isock;
  struct icmp_filter f;
  unsigned short int id;
  unsigned short int return_value_get_rand16_1;
  return_value_get_rand16_1=get_rand16();
  id = (unsigned short int)return_value_get_rand16_1;
  isock = ping_isocket;
  f.data = 0xfffff7f6;
  signed int return_value_setsockopt_4;
  return_value_setsockopt_4=setsockopt(isock, 255, 1, (const void *)&f, (unsigned int)sizeof(struct icmp_filter) /*4ul*/ );
  signed int return_value_is_interrupted_servstat_thread_13;
  unsigned short int return_value_ntohs_20;
  unsigned short int return_value_ntohs_22;
  signed int return_value_icmp4_errcmp_18;
  if(return_value_setsockopt_4 == -1)
  {
    icmp_errs = icmp_errs + 1ul;
    if(!(icmp_errs >= 11ul))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_message(4, "icmp ping: setsockopt() failed: %s", return_value_strerror_3);
    }

    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= rep); i = i + 1)
    {
      struct sockaddr_in from;
      struct sockaddr_in to;
      struct icmphdr icmpd;
      unsigned long int sum;
      unsigned short int *ptr;
      signed long int tm;
      signed long int tpassed;
      signed int j;
      icmpd.type = (unsigned char)8;
      icmpd.code = (unsigned char)0;
      icmpd.checksum = (unsigned short int)0;
      icmpd.un.echo.id=htons((unsigned short int)id);
      icmpd.un.echo.sequence=htons((unsigned short int)i);
      ptr = (unsigned short int *)&icmpd;
      sum = (unsigned long int)0;
      j = 0;
      for( ; !(j >= 4); j = j + 1)
      {
        unsigned short int *tmp_post_5 = ptr;
        ptr = ptr + 1l;
        sum = sum + (unsigned long int)*tmp_post_5;
      }
      sum = (sum >> 16) + (sum & (unsigned long int)0xffff);
      sum = sum + (sum >> 16);
      icmpd.checksum = (unsigned short int)~sum;
      memset((void *)&to, 0, sizeof(struct sockaddr_in) /*16ul*/ );
      to.sin_family = (unsigned short int)2;
      to.sin_port = (unsigned short int)0;
      to.sin_addr = addr;
      signed long int return_value_sendto_8;
      return_value_sendto_8=sendto(isock, (const void *)&icmpd, (unsigned long int)8, 0, (struct sockaddr *)&to, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(return_value_sendto_8 == -1l)
      {
        icmp_errs = icmp_errs + 1ul;
        if(!(icmp_errs >= 11ul))
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          char *return_value_strerror_7;
          return_value_strerror_7=strerror(*return_value___errno_location_6);
          log_message(4, "icmp ping: sendto() failed: %s.", return_value_strerror_7);
        }

        return -1;
      }

      tm=time((signed long int *)(void *)0);
      tpassed = (signed long int)0;
      do
      {
        signed int psres;
        struct pollfd pfd;
        pfd.fd = isock;
        pfd.events = (signed short int)0x001;
        signed int return_value_is_interrupted_servstat_thread_9;
        return_value_is_interrupted_servstat_thread_9=is_interrupted_servstat_thread_link1();
        if(!(return_value_is_interrupted_servstat_thread_9 == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "server status thread interrupted.\n");

          return -1;
        }

        psres=poll(&pfd, (unsigned long int)1, (signed int)((signed long int)timeout > tpassed ? ((signed long int)timeout - tpassed) * (signed long int)1000 : (signed long int)0));
        if(!(psres >= 0))
        {
          signed int *return_value___errno_location_12;
          return_value___errno_location_12=__errno_location();
          _Bool tmp_if_expr_14;
          if(*return_value___errno_location_12 == 4)
          {
            return_value_is_interrupted_servstat_thread_13=is_interrupted_servstat_thread_link1();
            tmp_if_expr_14 = return_value_is_interrupted_servstat_thread_13 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_14 = (_Bool)0;
          if(tmp_if_expr_14)
          {
            if(!(debug_p == 0))
              debug_msg(0, "poll/select interrupted in server status thread.\n");

          }

          else
          {
            icmp_errs = icmp_errs + 1ul;
            if(!(icmp_errs >= 11ul))
            {
              signed int *return_value___errno_location_10;
              return_value___errno_location_10=__errno_location();
              char *return_value_strerror_11;
              return_value_strerror_11=strerror(*return_value___errno_location_10);
              log_message(4, "poll/select failed: %s", return_value_strerror_11);
            }

          }
          return -1;
        }

        if(psres == 0)
          break;

        if(!((9 & (signed int)pfd.revents) == 0))
        {
          char buf[1024l];
          unsigned int sl = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
          signed int len;
          signed long int return_value_recvfrom_24;
          return_value_recvfrom_24=recvfrom(isock, (void *)&buf, sizeof(char [1024l]) /*1024ul*/ , 0, (struct sockaddr *)&from, &sl);
          len = (signed int)return_value_recvfrom_24;
          if(!(len == -1))
          {
            if((unsigned long int)len >= 21ul)
            {
              struct iphdr iph;
              memcpy((void *)&iph, (const void *)buf, sizeof(struct iphdr) /*20ul*/ );
              if(len + -(4 * (signed int)iph.ihl) >= 8)
              {
                struct icmphdr icmpp;
                memcpy((void *)&icmpp, (const void *)((unsigned int *)buf + (signed long int)iph.ihl), sizeof(struct icmphdr) /*8ul*/ );
                _Bool tmp_if_expr_21;
                if(iph.saddr == addr.s_addr && (signed int)icmpp.type == 0)
                {
                  return_value_ntohs_20=ntohs(icmpp.un.echo.id);
                  tmp_if_expr_21 = return_value_ntohs_20 == id ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_21 = (_Bool)0;
                _Bool tmp_if_expr_23;
                if(tmp_if_expr_21)
                {
                  return_value_ntohs_22=ntohs(icmpp.un.echo.sequence);
                  tmp_if_expr_23 = (signed int)return_value_ntohs_22 <= i ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_23 = (_Bool)0;
                if(tmp_if_expr_23)
                {
                  unsigned short int return_value_ntohs_15;
                  return_value_ntohs_15=ntohs(icmpp.un.echo.sequence);
                  signed long int return_value_time_16;
                  return_value_time_16=time((signed long int *)(void *)0);
                  return (signed int)((signed long int)((i - (signed int)return_value_ntohs_15) * timeout) + (return_value_time_16 - tm));
                }

                else
                {
                  signed int return_value_icmp4_errcmp_17;
                  return_value_icmp4_errcmp_17=icmp4_errcmp((char *)&icmpd, 8, &to.sin_addr, buf, len, 3);
                  _Bool tmp_if_expr_19;
                  if(!(return_value_icmp4_errcmp_17 == 0))
                    tmp_if_expr_19 = (_Bool)1;

                  else
                  {
                    return_value_icmp4_errcmp_18=icmp4_errcmp((char *)&icmpd, 8, &to.sin_addr, buf, len, 11);
                    tmp_if_expr_19 = return_value_icmp4_errcmp_18 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_19)
                    return -1;

                }
              }

            }

          }

          else
            return -1;
        }

        else
        {
          icmp_errs = icmp_errs + 1ul;
          if(!(icmp_errs >= 11ul))
            log_message(3, "Unhandled poll/select event in ping4() at %s, line %d.", (const void *)"icmp.c", 310);

          return -1;
        }
        signed long int return_value_time_25;
        return_value_time_25=time((signed long int *)(void *)0);
        tpassed = return_value_time_25 - tm;
      }
      while(!(tpassed >= (signed long int)timeout));
    }
    return -1;
  }
}

// ping6
// file icmp.c line 371
static signed int ping6(struct in6_addr a, signed int timeout, signed int rep)
{
  signed int i;
  signed int isock;
  struct icmp6_filter f;
  unsigned short int id;
  signed int return_value_rand_1;
  return_value_rand_1=rand();
  id = (unsigned short int)(return_value_rand_1 & 0xffff);
  isock = ping6_isocket;
  memset((void *)&f, 0xFF, sizeof(struct icmp6_filter) /*32ul*/ );
  (&f)->icmp6_filt[(signed long int)(129 >> 5)] = (&f)->icmp6_filt[(signed long int)(129 >> 5)] & (unsigned int)~(1 << (129 & 31));
  (&f)->icmp6_filt[(signed long int)(1 >> 5)] = (&f)->icmp6_filt[(signed long int)(1 >> 5)] & (unsigned int)~(1 << (1 & 31));
  (&f)->icmp6_filt[(signed long int)(3 >> 5)] = (&f)->icmp6_filt[(signed long int)(3 >> 5)] & (unsigned int)~(1 << (3 & 31));
  signed int return_value_setsockopt_4;
  return_value_setsockopt_4=setsockopt(isock, 58, 1, (const void *)&f, (unsigned int)sizeof(struct icmp6_filter) /*32ul*/ );
  signed int return_value_is_interrupted_servstat_thread_12;
  unsigned short int return_value_ntohs_22;
  unsigned short int return_value_ntohs_24;
  signed int return_value_icmp6_errcmp_17;
  if(return_value_setsockopt_4 == -1)
  {
    icmp_errs = icmp_errs + 1ul;
    if(!(icmp_errs >= 11ul))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_message(4, "icmpv6 ping: setsockopt() failed: %s", return_value_strerror_3);
    }

    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= rep); i = i + 1)
    {
      struct sockaddr_in6 from;
      struct icmp6_hdr icmpd;
      signed long int tm;
      signed long int tpassed;
      icmpd.icmp6_type = (unsigned char)128;
      icmpd.icmp6_code = (unsigned char)0;
      icmpd.icmp6_cksum = (unsigned short int)0;
      icmpd.icmp6_dataun.icmp6_un_data16[(signed long int)0]=htons((unsigned short int)id);
      icmpd.icmp6_dataun.icmp6_un_data16[(signed long int)1]=htons((unsigned short int)i);
      memset((void *)&from, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
      from.sin6_family = (unsigned short int)10;
      from.sin6_flowinfo = (unsigned int)0;
      from.sin6_port = (unsigned short int)0;
      from.sin6_addr = a;
      signed long int return_value_sendto_7;
      return_value_sendto_7=sendto(isock, (const void *)&icmpd, sizeof(struct icmp6_hdr) /*8ul*/ , 0, (struct sockaddr *)&from, (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ );
      if(return_value_sendto_7 == -1l)
      {
        icmp_errs = icmp_errs + 1ul;
        if(!(icmp_errs >= 11ul))
        {
          signed int *return_value___errno_location_5;
          return_value___errno_location_5=__errno_location();
          char *return_value_strerror_6;
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          log_message(4, "icmpv6 ping: sendto() failed: %s.", return_value_strerror_6);
        }

        return -1;
      }

      tm=time((signed long int *)(void *)0);
      tpassed = (signed long int)0;
      do
      {
        signed int psres;
        struct pollfd pfd;
        pfd.fd = isock;
        pfd.events = (signed short int)0x001;
        signed int return_value_is_interrupted_servstat_thread_8;
        return_value_is_interrupted_servstat_thread_8=is_interrupted_servstat_thread_link1();
        if(!(return_value_is_interrupted_servstat_thread_8 == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "server status thread interrupted.\n");

          return -1;
        }

        psres=poll(&pfd, (unsigned long int)1, (signed int)((signed long int)timeout > tpassed ? ((signed long int)timeout - tpassed) * (signed long int)1000 : (signed long int)0));
        if(!(psres >= 0))
        {
          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          _Bool tmp_if_expr_13;
          if(*return_value___errno_location_11 == 4)
          {
            return_value_is_interrupted_servstat_thread_12=is_interrupted_servstat_thread_link1();
            tmp_if_expr_13 = return_value_is_interrupted_servstat_thread_12 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_13 = (_Bool)0;
          if(tmp_if_expr_13)
          {
            if(!(debug_p == 0))
              debug_msg(0, "poll/select interrupted in server status thread.\n");

          }

          else
          {
            icmp_errs = icmp_errs + 1ul;
            if(!(icmp_errs >= 11ul))
            {
              signed int *return_value___errno_location_9;
              return_value___errno_location_9=__errno_location();
              char *return_value_strerror_10;
              return_value_strerror_10=strerror(*return_value___errno_location_9);
              log_message(4, "poll/select failed: %s", return_value_strerror_10);
            }

          }
          return -1;
        }

        if(psres == 0)
          break;

        if(!((9 & (signed int)pfd.revents) == 0))
        {
          char buf[1024l];
          unsigned int sl = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
          signed int len;
          signed long int return_value_recvfrom_26;
          return_value_recvfrom_26=recvfrom(isock, (void *)&buf, sizeof(char [1024l]) /*1024ul*/ , 0, (struct sockaddr *)&from, &sl);
          len = (signed int)return_value_recvfrom_26;
          if(!(len == -1))
          {
            if((unsigned long int)len >= sizeof(struct icmp6_hdr) /*8ul*/ )
            {
              struct icmp6_hdr icmpp;
              memcpy((void *)&icmpp, (const void *)buf, sizeof(struct icmp6_hdr) /*8ul*/ );
              _Bool tmp_if_expr_19;
              if(*((unsigned int *)&from.sin6_addr) == *((unsigned int *)&a))
                tmp_if_expr_19 = ((unsigned int *)&from.sin6_addr)[(signed long int)1] == ((unsigned int *)&a)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_19 = (_Bool)0;
              _Bool tmp_if_expr_20;
              if(tmp_if_expr_19)
                tmp_if_expr_20 = ((unsigned int *)&from.sin6_addr)[(signed long int)2] == ((unsigned int *)&a)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_20 = (_Bool)0;
              _Bool tmp_if_expr_21;
              if(tmp_if_expr_20)
                tmp_if_expr_21 = ((unsigned int *)&from.sin6_addr)[(signed long int)3] == ((unsigned int *)&a)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_21 = (_Bool)0;
              _Bool tmp_if_expr_23;
              if(tmp_if_expr_21)
              {
                return_value_ntohs_22=ntohs(icmpp.icmp6_dataun.icmp6_un_data16[(signed long int)0]);
                tmp_if_expr_23 = return_value_ntohs_22 == id ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_23 = (_Bool)0;
              _Bool tmp_if_expr_25;
              if(tmp_if_expr_23)
              {
                return_value_ntohs_24=ntohs(icmpp.icmp6_dataun.icmp6_un_data16[(signed long int)1]);
                tmp_if_expr_25 = (signed int)return_value_ntohs_24 <= i ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_25 = (_Bool)0;
              if(tmp_if_expr_25)
              {
                unsigned short int return_value_ntohs_14;
                return_value_ntohs_14=ntohs(icmpp.icmp6_dataun.icmp6_un_data16[(signed long int)1]);
                signed long int return_value_time_15;
                return_value_time_15=time((signed long int *)(void *)0);
                return (signed int)((signed long int)((i - (signed int)return_value_ntohs_14) * timeout) + (return_value_time_15 - tm));
              }

              else
              {
                signed int return_value_icmp6_errcmp_16;
                return_value_icmp6_errcmp_16=icmp6_errcmp((char *)&icmpd, (signed int)sizeof(struct icmp6_hdr) /*8ul*/ , &from.sin6_addr, buf, len, 1);
                _Bool tmp_if_expr_18;
                if(!(return_value_icmp6_errcmp_16 == 0))
                  tmp_if_expr_18 = (_Bool)1;

                else
                {
                  return_value_icmp6_errcmp_17=icmp6_errcmp((char *)&icmpd, (signed int)sizeof(struct icmp6_hdr) /*8ul*/ , &from.sin6_addr, buf, len, 3);
                  tmp_if_expr_18 = return_value_icmp6_errcmp_17 != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_18)
                  return -1;

              }
            }

          }

          else
            return -1;
        }

        else
        {
          icmp_errs = icmp_errs + 1ul;
          if(!(icmp_errs >= 11ul))
            log_message(3, "Unhandled poll/select event in ping6() at %s, line %d.", (const void *)"icmp.c", 497);

          return -1;
        }
        signed long int return_value_time_27;
        return_value_time_27=time((signed long int *)(void *)0);
        tpassed = return_value_time_27 - tm;
      }
      while(!(tpassed >= (signed long int)timeout));
    }
    return -1;
  }
}

// precsize_ntoa
// file rr_types.c line 60
static const char * precsize_ntoa(unsigned char prec, char *retbuf)
{
  unsigned int mantissa;
  unsigned int exponent;
  mantissa = (unsigned int)((signed int)prec >> 4);
  exponent = (unsigned int)((signed int)prec & 0x0f);
  if(exponent >= 10u || mantissa >= 10u)
    return (const char *)(void *)0;

  else
  {
    if(exponent >= 2u)
      sprintf(retbuf, "%u", mantissa * poweroften[(signed long int)(exponent - (unsigned int)2)]);

    else
      sprintf(retbuf, "0.%.2u", mantissa * poweroften[(signed long int)exponent]);
    return retbuf;
  }
}

// print_serr
// file status.c line 61
static signed int print_serr(signed int rs, const char *msg)
{
  unsigned short int cmd;
  if(!(debug_p == 0))
    debug_msg(0, "Sending error message to control socket: '%s'\n", msg);

  cmd=htons((unsigned short int)1);
  signed long int return_value_write_3;
  return_value_write_3=write(rs, (const void *)&cmd, sizeof(unsigned short int) /*2ul*/ );
  _Bool tmp_if_expr_6;
  unsigned long int return_value_strlen_4;
  signed long int return_value_write_all_5;
  if(!((unsigned long int)return_value_write_3 == sizeof(unsigned short int) /*2ul*/ ))
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_strlen_4=strlen(msg);
    return_value_write_all_5=write_all_link2(rs, (const void *)msg, return_value_strlen_4);
    tmp_if_expr_6 = return_value_write_all_5 < (signed long int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(tmp_if_expr_6)
  {
    if(!(debug_p == 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      debug_msg(0, "Error writing to control socket: %s\n", return_value_strerror_2);
    }

    return 0;
  }

  else
    return 1;
}

// print_succ
// file status.c line 77
static signed int print_succ(signed int rs)
{
  unsigned short int cmd;
  cmd=htons((unsigned short int)0);
  signed long int return_value_write_3;
  return_value_write_3=write(rs, (const void *)&cmd, sizeof(unsigned short int) /*2ul*/ );
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!((unsigned long int)return_value_write_3 == sizeof(unsigned short int) /*2ul*/ ))
  {
    if(!(debug_p == 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      debug_msg(0, "Error writing to control socket: %s\nFailed to send success code.\n", return_value_strerror_2);
    }

    return 0;
  }

  else
    return 1;
}

// process_query
// file dns_answer.c line 1156
static struct anonymous_28 * process_query(unsigned char *data, unsigned long int *rlenp, unsigned int *udp, signed int *rcodep)
{
  unsigned long int rlen = *rlenp;
  signed int res;
  struct anonymous_29 *hdr;
  struct anonymous_40 ql;
  struct anonymous_28 *ans;
  struct anonymous_17 ednsinfo = { .udpsize=(unsigned short int)0, .rcode=0, .version=0,
    .do_flg=0 };
  struct anonymous_17 *ednsinfop = (struct anonymous_17 *)(void *)0;
  if(!(debug_p == 0))
    debug_msg(0, "Received query (msg len=%u).\n", (unsigned int)rlen);

  hdr = (struct anonymous_29 *)data;
  signed int return_value_llist_isempty_1;
  _Bool tmp_if_expr_3;
  const char *return_value_get_cname_7;
  const char *return_value_get_tname_8;
  const unsigned char *return_value_rhn2str_9;
  void *return_value_llist_next_6;
  signed int return_value_llist_isempty_11;
  if(!(rlen >= 2ul))
  {
    if(!(debug_p == 0))
      debug_msg(0, "Message too short.\n");

    return (struct anonymous_28 *)(void *)0;
  }

  else
  {
    if(!(rlen >= sizeof(struct anonymous_29) /*12ul*/ ))
    {
      if(!(debug_p == 0))
        debug_msg(0, "Message too short.\n");

      res = 1;
    }

    else
    {
      if(!((signed int)hdr->qr == 0))
      {
        if(!(debug_p == 0))
          debug_msg(0, "The QR bit indicates this is a response, not a query.\n");

        return (struct anonymous_28 *)(void *)0;
      }

      if(!((signed int)hdr->opcode == 0))
      {
        if(!(debug_p == 0))
          debug_msg(0, "Not a standard query (opcode=%u).\n", hdr->opcode);

        res = 4;
      }

      else
      {
        if(!(debug_p == 0))
        {
          char flgsbuf[22l];
          dnsflags2str(hdr, flgsbuf);
          if(!(flgsbuf[0l] == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Flags:%s\n", (const void *)flgsbuf);

          }

        }

        if(!((signed int)hdr->z == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "Malformed query (nonzero Z bit).\n");

          res = 1;
        }

        else
        {
          if(!((signed int)hdr->rcode == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Bad rcode(%u).\n", hdr->rcode);

            return (struct anonymous_28 *)(void *)0;
          }

          if(!(hdr->ancount == 0))
          {
            if(!(debug_p == 0))
              debug_msg(0, "Query has a non-empty answer section!\n");

            res = 1;
          }

          else
            if(!(hdr->nscount == 0))
            {
              if(!(debug_p == 0))
                debug_msg(0, "Query has a non-empty authority section!\n");

              res = 1;
            }

            else
            {
              unsigned char *ptr;
              unsigned long int sz;
              unsigned short int arcount;
              res=decode_query(data, rlen, &ptr, &sz, &ql);
              if(!(res == 0))
              {
                if(res == 0xfffe)
                {
                  _Bool tmp_if_expr_2;
                  if(hdr->tc == 0u)
                    tmp_if_expr_2 = (_Bool)1;

                  else
                  {
                    return_value_llist_isempty_1=llist_isempty(&ql);
                    tmp_if_expr_2 = return_value_llist_isempty_1 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_2)
                  {
                    res = 1;
                    goto free_ql_error_reply;
                  }

                  goto __CPROVER_DUMP_L24;
                }

              }

              else
              {

              __CPROVER_DUMP_L24:
                ;
                arcount=ntohs(hdr->arcount);
                if(!(arcount == 0))
                {
                  signed int numoptrr = 0;
                  if(!(debug_p == 0))
                    debug_msg(0, "Query has a non-empty additional section: checking for OPT pseudo-RR.\n");

                  if(res == 0xfffe)
                  {
                    if(!(debug_p == 0))
                      debug_msg(0, "Additional section cannot be read due to truncation!\n");

                    res = 1;
                    goto free_ql_error_reply;
                  }

                  res=decode_query_additional(data, rlen, ptr, sz, (signed int)arcount, &numoptrr, &ednsinfo);
                  _Bool tmp_if_expr_4;
                  if(res == 0)
                    tmp_if_expr_4 = (_Bool)1;

                  else
                  {
                    if(res == 0xfffe)
                      tmp_if_expr_3 = hdr->tc != 0u ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_3 = (_Bool)0;
                    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
                  }
                  if(!tmp_if_expr_4)
                  {
                    res = 1;
                    goto free_ql_error_reply;
                  }

                  if(!(numoptrr == 0))
                  {
                    if(!(numoptrr == 1))
                    {
                      if(!(debug_p == 0))
                        debug_msg(0, "Additional section in query contains %d OPT pseudo-RRs!\n", numoptrr);

                    }

                    if(!((signed int)ednsinfo.version == 0))
                    {
                      if(!(debug_p == 0))
                        debug_msg(0, "Query contains unsupported EDNS version %d!\n", ednsinfo.version);

                      res = 16;
                      goto free_ql_error_reply;
                    }

                    if(!((signed int)ednsinfo.rcode == 0))
                    {
                      if(!(debug_p == 0))
                        debug_msg(0, "Query contains non-zero EDNS rcode (%d)!\n", ednsinfo.rcode);

                      res = 1;
                      goto free_ql_error_reply;
                    }

                    if(!(debug_p == 0))
                      debug_msg(0, "Query contains OPT pseudosection: EDNS udp size = %u, flag DO=%u\n", ednsinfo.udpsize, ednsinfo.do_flg);

                    ednsinfop = &ednsinfo;
                    if((signed int)ednsinfo.udpsize >= 513 && !(udp == ((unsigned int *)NULL)))
                    {
                      unsigned int udpbufsize = (unsigned int)global.udpbufsize;
                      if(!((unsigned int)ednsinfo.udpsize >= udpbufsize))
                        udpbufsize = (unsigned int)ednsinfo.udpsize;

                      *udp = udpbufsize;
                    }

                  }

                }

                if(!(debug_p == 0))
                {
                  signed int return_value_llist_isempty_10;
                  return_value_llist_isempty_10=llist_isempty(&ql);
                  if(return_value_llist_isempty_10 == 0)
                  {
                    struct anonymous_70 *qe;
                    if(!(debug_p == 0))
                      debug_msg(0, "Questions are:\n");

                    void *return_value_llist_first_5;
                    return_value_llist_first_5=llist_first(&ql);
                    qe = (struct anonymous_70 *)return_value_llist_first_5;
                    for( ; !(qe == ((struct anonymous_70 *)NULL)); qe = (struct anonymous_70 *)return_value_llist_next_6)
                    {
                      unsigned char _debugstrbuf[256l];
                      if(!(debug_p == 0))
                      {
                        return_value_get_cname_7=get_cname((signed int)qe->qclass);
                        return_value_get_tname_8=get_tname((signed int)qe->qtype);
                        return_value_rhn2str_9=rhn2str(qe->query, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                        debug_msg(0, "\tqc=%s (%u), qt=%s (%u), query=\"%s\"\n", return_value_get_cname_7, qe->qclass, return_value_get_tname_8, qe->qtype, return_value_rhn2str_9);
                      }

                      return_value_llist_next_6=llist_next((void *)qe);
                    }
                  }

                  else
                    if(!(debug_p == 0))
                      debug_msg(0, "Query contains no questions.\n");

                }

                return_value_llist_isempty_11=llist_isempty(&ql);
                if(!(return_value_llist_isempty_11 == 0))
                  res = 1;

                else
                {
                  ans=compose_answer(&ql, hdr, rlenp, ednsinfop, udp, rcodep);
                  if(ans == ((struct anonymous_28 *)NULL))
                    res = 2;

                  else
                  {
                    llist_free(&ql);
                    return ans;
                  }

                free_ql_error_reply:
                  ;
                  llist_free(&ql);
                }
              }
            }
        }
      }
    }

  error_reply:
    ;
    *rlenp = sizeof(struct anonymous_29) /*12ul*/ ;
    unsigned long int allocsz = sizeof(struct anonymous_28) /*14ul*/ ;
    if(!((-16 & res) == 0))
      allocsz = allocsz + (unsigned long int)(1 + 10);

    void *return_value_malloc_12;
    return_value_malloc_12=malloc(allocsz);
    ans = (struct anonymous_28 *)return_value_malloc_12;
    if(!(ans == ((struct anonymous_28 *)NULL)))
    {
      signed int tmp_if_expr_13;
      if(rlen >= 3ul)
        tmp_if_expr_13 = (signed int)hdr->opcode;

      else
        tmp_if_expr_13 = 0;
      mk_error_reply(hdr->id, (unsigned short int)tmp_if_expr_13, (unsigned short int)res, &ans->hdr);
      if(!((-16 & res) == 0))
        add_opt_pseudo_rr(&ans, rlenp, &allocsz, (unsigned short int)global.udpbufsize, (unsigned short int)res, (unsigned short int)0, (unsigned short int)0);

    }

    else
    {
      da_mem_errs = da_mem_errs + 1ul;
      if(!(da_mem_errs >= 11ul))
        log_message(3, "Out of memory in query processing.");

    }
    if(!(rcodep == ((signed int *)NULL)))
      *rcodep = res;

    return ans;
  }
}

// purge_all_rrsets
// file cache.c line 1207
static signed int purge_all_rrsets(struct anonymous_0 *cent, signed int test, signed int *numrrsrem)
{
  signed int rv = 0;
  signed int numrrs = 0;
  signed int numrrext = 0;
  signed long int tmp_if_expr_5;
  signed long int return_value_time_6;
  signed int return_value_del_cent_rrset_by_index_3;
  if((1 & (signed int)cent->flags) == 0)
  {
    signed int i;
    signed int ilim;
    signed int tmp_if_expr_1;
    if(!((1 & (signed int)cent->flags) == 0))
      tmp_if_expr_1 = 0;

    else
      tmp_if_expr_1 = cent->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
    ilim = tmp_if_expr_1;
    i = 0;
    for( ; !(i >= ilim); i = i + 1)
    {
      struct anonymous *rrs;
      struct anonymous *tmp_if_expr_2;
      if(!(i >= 8))
        tmp_if_expr_2 = cent->_anon0.rr.rrmu[(signed long int)i];

      else
        tmp_if_expr_2 = cent->_anon0.rr.rrext[(signed long int)(i - 8)];
      rrs = tmp_if_expr_2;
      if(!(rrs == ((struct anonymous *)NULL)))
      {
        _Bool tmp_if_expr_4;
        if(!((32 & (signed int)rrs->flags) == 0))
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = ((signed int)rrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_7;
        if(!tmp_if_expr_4)
        {
          if(!(rrs->ttl >= 120l))
            tmp_if_expr_5 = (signed long int)120;

          else
            tmp_if_expr_5 = rrs->ttl;
          return_value_time_6=time((signed long int *)(void *)0);
          tmp_if_expr_7 = rrs->ts + tmp_if_expr_5 < return_value_time_6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
        {
          if(test == 0)
          {
            return_value_del_cent_rrset_by_index_3=del_cent_rrset_by_index(cent, i);
            cache_size = cache_size - (volatile signed long int)return_value_del_cent_rrset_by_index_3;
          }

          rv = rv + 1;
        }

        else
        {
          numrrs = numrrs + 1;
          if(i >= 8)
            numrrext = numrrext + 1;

        }
      }

    }
    if(!(cent->_anon0.rr.rrext == ((struct anonymous **)NULL)))
    {
      if(numrrext == 0)
      {
        if(test == 0)
        {
          free((void *)cent->_anon0.rr.rrext);
          cent->_anon0.rr.rrext = (struct anonymous **)(void *)0;
          cent->cs = cent->cs - sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39;
          cache_size = cache_size - (volatile signed long int)(sizeof(struct anonymous *) /*8ul*/  * (unsigned long int)39);
        }

        rv = rv + 1;
      }

    }

  }

  if(!(numrrsrem == ((signed int *)NULL)))
    *numrrsrem = numrrs;

  return rv;
}

// purge_cache
// file cache.c line 1314
static void purge_cache(signed long int sz, signed int lazy)
{
  struct rr_lent_s *le = rrset_l;
  _Bool tmp_if_expr_3;
  signed long int tmp_if_expr_1;
  signed long int return_value_time_2;
  while(!(le == ((struct rr_lent_s *)NULL)) && (lazy == 0 || !(sz >= cache_size)))
  {
    struct rr_lent_s *purge_cache__1__1__next = le->next;
    _Bool tmp_if_expr_5;
    if(!(le->rrset == ((struct anonymous *)NULL)))
      tmp_if_expr_5 = ((signed int)le->rrset->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    _Bool tmp_if_expr_6;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = ((signed int)le->cent->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_6)
    {
      struct anonymous_0 *purge_cache__1__1__1__ce = le->cent;
      if(!(le->rrset == ((struct anonymous *)NULL)))
        purge_rrset(purge_cache__1__1__1__ce, le->idx, 0);

      if((signed int)purge_cache__1__1__1__ce->num_rrs == 0)
      {
        _Bool tmp_if_expr_4;
        if((1 & (signed int)purge_cache__1__1__1__ce->flags) == 0)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if((2 & (signed int)purge_cache__1__1__1__ce->flags) == 0)
          {
            if(!(purge_cache__1__1__1__ce->_anon0.neg.ttl >= 120l))
              tmp_if_expr_1 = (signed long int)120;

            else
              tmp_if_expr_1 = purge_cache__1__1__1__ce->_anon0.neg.ttl;
            return_value_time_2=time((signed long int *)(void *)0);
            tmp_if_expr_3 = purge_cache__1__1__1__ce->_anon0.neg.ts + tmp_if_expr_1 < return_value_time_2 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          del_cache_ent(purge_cache__1__1__1__ce, (struct anonymous_58 *)(void *)0);

      }

    }

    le = purge_cache__1__1__next;
  }
  signed int return_value_del_cent_rrset_by_index_7;
  if(!(sz >= cache_size))
  {
    if(insert_sort == 0)
    {
      sort_rrl();
      insert_sort = (signed short int)1;
    }

    le = rrset_l;
    while(!(le == ((struct rr_lent_s *)NULL)) && !(sz >= cache_size))
    {
      struct rr_lent_s *next = le->next;
      _Bool tmp_if_expr_8;
      if(!(le->rrset == ((struct anonymous *)NULL)))
        tmp_if_expr_8 = ((signed int)le->rrset->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_8 = (_Bool)0;
      _Bool tmp_if_expr_9;
      if(tmp_if_expr_8)
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = ((signed int)le->cent->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_9)
      {
        struct anonymous_0 *ce = le->cent;
        if(!(le->rrset == ((struct anonymous *)NULL)))
        {
          return_value_del_cent_rrset_by_index_7=del_cent_rrset_by_index(ce, le->idx);
          cache_size = cache_size - (volatile signed long int)return_value_del_cent_rrset_by_index_7;
        }

        if((signed int)ce->num_rrs == 0)
          del_cache_ent(ce, (struct anonymous_58 *)(void *)0);

      }

      le = next;
    }
  }

}

// purge_cent
// file cache.c line 1257
static signed int purge_cent(struct anonymous_0 *cent, signed int delete, signed int test)
{
  signed int npurge;
  signed int numrrs;
  npurge=purge_all_rrsets(cent, test, &numrrs);
  _Bool tmp_if_expr_3;
  signed long int tmp_if_expr_1;
  signed long int return_value_time_2;
  if(numrrs == 0 && !(delete == 0))
  {
    _Bool tmp_if_expr_4;
    if((1 & (signed int)cent->flags) == 0)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if((2 & (signed int)cent->flags) == 0)
      {
        if(!(cent->_anon0.neg.ttl >= 120l))
          tmp_if_expr_1 = (signed long int)120;

        else
          tmp_if_expr_1 = cent->_anon0.neg.ttl;
        return_value_time_2=time((signed long int *)(void *)0);
        tmp_if_expr_3 = cent->_anon0.neg.ts + tmp_if_expr_1 < return_value_time_2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      if(test == 0)
        del_cache_ent(cent, (struct anonymous_58 *)(void *)0);

      return -1;
    }

  }

  _Bool tmp_if_expr_11;
  signed long int tmp_if_expr_9;
  signed long int return_value_time_10;
  _Bool tmp_if_expr_19;
  signed long int tmp_if_expr_17;
  signed long int return_value_time_18;
  if((2 & (signed int)cent->flags) == 0)
  {
    unsigned int scnt;
    scnt=rhnsegcnt_link2(cent->qname);
    if(!((signed int)cent->c_ns == 0xff))
    {
      struct anonymous *rrset = (struct anonymous *)(void *)0;
      if((unsigned int)cent->c_ns == scnt)
      {
        struct anonymous *tmp_if_expr_5;
        if((1 & (signed int)cent->flags) == 0)
          tmp_if_expr_5 = cent->_anon0.rr.rrmu[(signed long int)1];

        else
          tmp_if_expr_5 = (struct anonymous *)(void *)0;
        rrset = tmp_if_expr_5;
      }

      else
        if(!((unsigned int)cent->c_ns >= scnt))
        {
          struct anonymous_0 *ce;
          const unsigned char *return_value_skipsegs_6;
          return_value_skipsegs_6=skipsegs_link2(cent->qname, scnt - (unsigned int)cent->c_ns);
          ce=dns_lookup(return_value_skipsegs_6, (struct anonymous_58 *)(void *)0);
          if(!(ce == ((struct anonymous_0 *)NULL)))
          {
            struct anonymous *tmp_if_expr_7;
            if((1 & (signed int)ce->flags) == 0)
              tmp_if_expr_7 = ce->_anon0.rr.rrmu[(signed long int)1];

            else
              tmp_if_expr_7 = (struct anonymous *)(void *)0;
            rrset = tmp_if_expr_7;
          }

        }

      _Bool tmp_if_expr_8;
      if(rrset == ((struct anonymous *)NULL))
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = !(rrset->rrs != ((struct rr_b_s *)NULL)) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_12;
      if(tmp_if_expr_8)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        if((2 & (signed int)rrset->flags) == 0)
        {
          if(!(rrset->ttl >= 120l))
            tmp_if_expr_9 = (signed long int)120;

          else
            tmp_if_expr_9 = rrset->ttl;
          return_value_time_10=time((signed long int *)(void *)0);
          tmp_if_expr_11 = rrset->ts + tmp_if_expr_9 < return_value_time_10 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_11 = (_Bool)0;
        tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
      {
        if(test == 0)
          cent->c_ns = (unsigned char)0xff;

        npurge = npurge + 1;
      }

    }

    if(!((signed int)cent->c_soa == 0xff))
    {
      struct anonymous *purge_cent__1__2__2__rrset = (struct anonymous *)(void *)0;
      if((unsigned int)cent->c_soa == scnt)
      {
        struct anonymous *tmp_if_expr_13;
        if((1 & (signed int)cent->flags) == 0)
          tmp_if_expr_13 = cent->_anon0.rr.rrmu[(signed long int)3];

        else
          tmp_if_expr_13 = (struct anonymous *)(void *)0;
        purge_cent__1__2__2__rrset = tmp_if_expr_13;
      }

      else
        if(!((unsigned int)cent->c_soa >= scnt))
        {
          struct anonymous_0 *purge_cent__1__2__2__1__ce;
          const unsigned char *return_value_skipsegs_14;
          return_value_skipsegs_14=skipsegs_link2(cent->qname, scnt - (unsigned int)cent->c_soa);
          purge_cent__1__2__2__1__ce=dns_lookup(return_value_skipsegs_14, (struct anonymous_58 *)(void *)0);
          if(!(purge_cent__1__2__2__1__ce == ((struct anonymous_0 *)NULL)))
          {
            struct anonymous *tmp_if_expr_15;
            if((1 & (signed int)purge_cent__1__2__2__1__ce->flags) == 0)
              tmp_if_expr_15 = purge_cent__1__2__2__1__ce->_anon0.rr.rrmu[(signed long int)3];

            else
              tmp_if_expr_15 = (struct anonymous *)(void *)0;
            purge_cent__1__2__2__rrset = tmp_if_expr_15;
          }

        }

      _Bool tmp_if_expr_16;
      if(purge_cent__1__2__2__rrset == ((struct anonymous *)NULL))
        tmp_if_expr_16 = (_Bool)1;

      else
        tmp_if_expr_16 = !(purge_cent__1__2__2__rrset->rrs != ((struct rr_b_s *)NULL)) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_20;
      if(tmp_if_expr_16)
        tmp_if_expr_20 = (_Bool)1;

      else
      {
        if((2 & (signed int)purge_cent__1__2__2__rrset->flags) == 0)
        {
          if(!(purge_cent__1__2__2__rrset->ttl >= 120l))
            tmp_if_expr_17 = (signed long int)120;

          else
            tmp_if_expr_17 = purge_cent__1__2__2__rrset->ttl;
          return_value_time_18=time((signed long int *)(void *)0);
          tmp_if_expr_19 = purge_cent__1__2__2__rrset->ts + tmp_if_expr_17 < return_value_time_18 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_19 = (_Bool)0;
        tmp_if_expr_20 = tmp_if_expr_19 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_20)
      {
        if(test == 0)
          cent->c_soa = (unsigned char)0xff;

        npurge = npurge + 1;
      }

    }

  }

  return npurge;
}

// purge_rrset
// file cache.c line 1188
static signed int purge_rrset(struct anonymous_0 *cent, signed int idx, signed int test)
{
  struct anonymous *rrs;
  struct anonymous *tmp_if_expr_3;
  struct anonymous *tmp_if_expr_2;
  struct anonymous *tmp_if_expr_1;
  if(!((1 & (signed int)cent->flags) == 0))
    tmp_if_expr_3 = (struct anonymous *)(void *)0;

  else
  {
    if(!(idx >= 8))
      tmp_if_expr_2 = cent->_anon0.rr.rrmu[(signed long int)idx];

    else
    {
      if(!(cent->_anon0.rr.rrext == ((struct anonymous **)NULL)))
        tmp_if_expr_1 = cent->_anon0.rr.rrext[(signed long int)(idx - 8)];

      else
        tmp_if_expr_1 = (struct anonymous *)(void *)0;
      tmp_if_expr_2 = tmp_if_expr_1;
    }
    tmp_if_expr_3 = tmp_if_expr_2;
  }
  rrs = tmp_if_expr_3;
  signed long int return_value_time_6;
  signed int return_value_del_cent_rrset_by_index_4;
  if(!(rrs == ((struct anonymous *)NULL)))
  {
    _Bool tmp_if_expr_7;
    if(!((32 & (signed int)rrs->flags) == 0))
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = ((signed int)rrs->flags & 2) != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_7)
    {
      signed long int tmp_if_expr_5;
      if(!(rrs->ttl >= 120l))
        tmp_if_expr_5 = (signed long int)120;

      else
        tmp_if_expr_5 = rrs->ttl;
      return_value_time_6=time((signed long int *)(void *)0);
      if(!(rrs->ts + tmp_if_expr_5 >= return_value_time_6))
      {
        if(test == 0)
        {
          return_value_del_cent_rrset_by_index_4=del_cent_rrset_by_index(cent, idx);
          cache_size = cache_size - (volatile signed long int)return_value_del_cent_rrset_by_index_4;
        }

        return 1;
      }

    }

  }

  return 0;
}

// query_stat_same_inaddr2
// file dns_query.c line 2013
static inline signed int query_stat_same_inaddr2(struct anonymous_5 *qs, struct anonymous_15 *b)
{
  signed int tmp_if_expr_5;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(run_ipv4 == 0))
    tmp_if_expr_5 = (signed int)(qs->a.sin4.sin_addr.s_addr == b->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&qs->a.sin6.sin6_addr) == *((unsigned int *)&b->ipv6))
      tmp_if_expr_1 = ((unsigned int *)&qs->a.sin6.sin6_addr)[(signed long int)1] == ((unsigned int *)&b->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = ((unsigned int *)&qs->a.sin6.sin6_addr)[(signed long int)2] == ((unsigned int *)&b->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = ((unsigned int *)&qs->a.sin6.sin6_addr)[(signed long int)3] == ((unsigned int *)&b->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = qs->a4fallback.s_addr == b->ipv4.s_addr ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_if_expr_5 = (signed int)tmp_if_expr_4;
  }
  return tmp_if_expr_5;
}

// query_uptest
// file dns_query.c line 3513
signed int query_uptest(union anonymous_6 *addr, signed int port, const unsigned char *name, signed long int timeout, signed int rep)
{
  struct anonymous_5 qs;
  signed int iter = 0;
  signed int rv;
  if(!(run_ipv4 == 0))
  {
    memset((void *)&qs.a.sin4, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    qs.a.sin4.sin_family = (unsigned short int)2;
    qs.a.sin4.sin_port=htons((unsigned short int)port);
    qs.a.sin4.sin_addr = addr->ipv4;
  }

  else
  {
    memset((void *)&qs.a.sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
    qs.a.sin6.sin6_family = (unsigned short int)10;
    qs.a.sin6.sin6_port=htons((unsigned short int)port);
    qs.a.sin6.sin6_flowinfo = (unsigned int)0;
    qs.a.sin6.sin6_addr = addr->ipv6;
    qs.a4fallback.s_addr = (unsigned int)0x00000000;
  }
  qs.timeout = timeout;
  qs.flags = (unsigned short int)0;
  qs.nocache = (signed short int)0;
  qs.auth_serv = (char)0;
  qs.lean_query = (char)1;
  qs.edns_query = (char)0;
  qs.needs_testing = (char)0;
  qs.trusted = (char)1;
  qs.aa = (char)0;
  qs.tc = (char)0;
  qs.nsdomain = (const unsigned char *)(void *)0;
  qs.rejectlist = (struct rejectlist_s *)(void *)0;
  signed long int ts;
  signed long int tpassed;
  signed int event;
  struct pollfd pfd;
  signed int return_value_is_interrupted_servstat_thread_2;
  signed int return_value_is_interrupted_servstat_thread_6;
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  do
  {

  try_again:
    ;
    qs.state = (signed short int)0;
    qs.qm = (signed short int)global.query_method;
    qs.s_errno = 0;
    rv=p_exec_query((struct anonymous_0 **)(void *)0, name, 1, &qs, (struct _dynamic_list_head **)(void *)0, (unsigned char *)(void *)0);
    if(!(rv == -1))
      goto __CPROVER_DUMP_L25;

    ts=time((signed long int *)(void *)0);
    tpassed = (signed long int)0;

  __CPROVER_DUMP_L4:
    ;
    pfd.fd = qs.sock;
    switch((signed int)qs.state)
    {
      case 3:

      case 5:
      {
        pfd.events = (signed short int)0x001;
        break;
      }
      case 2:
      {
        pfd.events = (signed short int)0x004;
        break;
      }
      default:
        pfd.events = (signed short int)0;
    }
    return_value_is_interrupted_servstat_thread_2=is_interrupted_servstat_thread();
    if(!(return_value_is_interrupted_servstat_thread_2 == 0))
    {
      if(!(debug_p == 0))
        debug_msg(0, "server status thread interrupted.\n");

      p_cancel_query(&qs);
      return 0;
    }

    event=poll(&pfd, (unsigned long int)1, (signed int)(timeout > tpassed ? (timeout - tpassed) * (signed long int)1000 : (signed long int)0));
    if(!(event >= 0))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      _Bool tmp_if_expr_7;
      if(*return_value___errno_location_5 == 4)
      {
        return_value_is_interrupted_servstat_thread_6=is_interrupted_servstat_thread();
        tmp_if_expr_7 = return_value_is_interrupted_servstat_thread_6 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        if(!(debug_p == 0))
          debug_msg(0, "poll/select interrupted in server status thread.\n");

      }

      else
      {
        return_value___errno_location_3=__errno_location();
        return_value_strerror_4=strerror(*return_value___errno_location_3);
        log_message(4, "poll/select failed: %s", return_value_strerror_4);
      }
      p_cancel_query(&qs);
      return 0;
    }

    if(!(event == 0))
      goto __CPROVER_DUMP_L17;

    p_cancel_query(&qs);
    iter = iter + 1;
  }
  while(!(iter >= rep));
  return 0;

__CPROVER_DUMP_L17:
  ;
  event = 0;
  switch((signed int)qs.state)
  {
    case 3:

    case 5:
    {
      event = (signed int)pfd.revents & (0x001 | 0x008 | 0x010 | 0x020);
      break;
    }
    case 2:
      event = (signed int)pfd.revents & (0x004 | 0x008 | 0x010 | 0x020);
  }
  if(!(event == 0))
  {
    rv=p_exec_query((struct anonymous_0 **)(void *)0, name, 1, &qs, (struct _dynamic_list_head **)(void *)0, (unsigned char *)(void *)0);
    if(!(rv == -1))
      goto __CPROVER_DUMP_L24;

  }

  else
  {
    poll_errs = poll_errs + 1ul;
    if(!(poll_errs >= 11ul))
      log_message(3, "Unhandled poll/select event in query_uptest() at %s, line %d.", (const void *)"dns_query.c", 3653);

    p_cancel_query(&qs);
    return 0;
  }
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  tpassed = return_value_time_1 - ts;
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L24:
  ;

__CPROVER_DUMP_L25:
  ;
  return (signed int)(rv != 2 && rv != 0xffff);
}

// r_dns_cached_resolve
// file dns_query.h line 36
signed int r_dns_cached_resolve(unsigned char *name, signed int thint, struct anonymous_0 **cachedp, signed int hops, struct qhintnode_s *qhlist, signed long int queryts, unsigned char *c_soa)
{
  struct anonymous_0 *cached;
  signed int rc;
  rc=p_dns_cached_resolve((struct anonymous_4 *)(void *)0, name, thint, &cached, hops, (struct qstatnode_s *)(void *)0, qhlist, queryts, c_soa);
  if(rc == 0)
  {
    if(!((1 & (signed int)cached->flags) == 0))
    {
      if(!(c_soa == ((unsigned char *)NULL)))
        *c_soa = cached->c_soa;

      free_cent(cached);
      free((void *)cached);
      rc = 3;
    }

    else
      *cachedp = cached;
  }

  return rc;
}

// randrr
// file dns_answer.c line 519
static inline struct rr_b_s * randrr(struct rr_b_s *rrb)
{
  struct rr_b_s *rr;
  unsigned int cnt = (unsigned int)0;
  rr = rrb;
  for( ; !(rr == ((struct rr_b_s *)NULL)); rr = rr->next)
    cnt = cnt + 1u;
  if(!(cnt == 0u))
  {
    signed long int return_value_random_1;
    return_value_random_1=random();
    cnt = (unsigned int)(return_value_random_1 % (signed long int)cnt);
    for( ; !(cnt == 0u); cnt = cnt - 1u)
      rrb = rrb->next;
  }

  return rrb;
}

// read_allocstring
// file status.c line 122
static signed int read_allocstring(signed int fh, char **res, unsigned int *len)
{
  unsigned short int count;
  char *buf;
  unsigned int nread;
  signed int return_value_read_short_1;
  return_value_read_short_1=read_short(fh, &count);
  if(return_value_read_short_1 == 0)
    return 0;

  else
    if(count == 65535)
    {
      *res = (char *)(void *)0;
      return -1;
    }

    else
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)((signed int)count + 1));
      buf = (char *)return_value_malloc_2;
      if(buf == ((char *)NULL))
        return 0;

      else
      {
        nread = (unsigned int)0;
        while(!(nread >= (unsigned int)count))
        {
          signed long int m;
          m=read(fh, (void *)(buf + (signed long int)nread), (unsigned long int)((unsigned int)count - nread));
          if(!(m >= 1l))
          {
            free((void *)buf);
            return 0;
          }

          nread = nread + (unsigned int)m;
        }
        buf[(signed long int)count] = (char)0;
        *res = buf;
        if(!(len == ((unsigned int *)NULL)))
          *len = (unsigned int)count;

        return 1;
      }
    }
}

// read_config_file
// file conff.h line 182
signed int read_config_file(const char *nm, struct anonymous_21 *global, struct anonymous_18 **servers, signed int includedepth, char **errstr)
{
  signed int retval = 0;
  const char *conftype = global != ((struct anonymous_21 *)NULL) ? "config" : "include";
  struct _IO_FILE *in;
  if(nm == ((const char *)NULL))
    nm = conf_file;

  in=fopen(nm, "r");
  if(in == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    signed int return_value_asprintf_3;
    return_value_asprintf_3=asprintf(errstr, "Error: Could not open %s file %s: %s", conftype, nm, return_value_strerror_2);
    if(!(return_value_asprintf_3 >= 0))
      *errstr = (char *)(void *)0;

    return 0;
  }

  signed int return_value_fstat_9;
  if(!(servers == ((struct anonymous_18 **)NULL)) || !(global == ((struct anonymous_21 *)NULL)))
  {
    signed int fd;
    fd=fileno(in);
    struct stat sb;
    _Bool tmp_if_expr_10;
    if(fd == -1)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_fstat_9=fstat(fd, &sb);
      tmp_if_expr_10 = return_value_fstat_9 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_10)
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      signed int return_value_asprintf_6;
      return_value_asprintf_6=asprintf(errstr, "Error: Could not stat %s file %s: %s", conftype, nm, return_value_strerror_5);
      if(!(return_value_asprintf_6 >= 0))
        *errstr = (char *)(void *)0;

      goto close_file;
    }

    else
      if(!(sb.st_uid == init_uid))
      {
        struct passwd *pws;
        char owner[24l];
        char user[24l];
        pws=getpwuid(sb.st_uid);
        if(!(pws == ((struct passwd *)NULL)))
          strncp(owner, pws->pw_name, sizeof(char [24l]) /*24ul*/ );

        else
          sprintf(owner, "%i", sb.st_uid);
        pws=getpwuid(init_uid);
        if(!(pws == ((struct passwd *)NULL)))
          strncp(user, pws->pw_name, sizeof(char [24l]) /*24ul*/ );

        else
          sprintf(user, "%i", init_uid);
        signed int return_value_asprintf_7;
        return_value_asprintf_7=asprintf(errstr, "Error: %s file %s is owned by '%s', but pdnsd was started as user '%s'.", conftype, nm, (const void *)owner, (const void *)user);
        if(!(return_value_asprintf_7 >= 0))
          *errstr = (char *)(void *)0;

        goto close_file;
      }

      else
        if(!((18u & sb.st_mode) == 0u))
        {
          signed int return_value_asprintf_8;
          return_value_asprintf_8=asprintf(errstr, "Error: Bad %s file permissions: file %s must be only writeable by the user.", conftype, nm);
          if(!(return_value_asprintf_8 >= 0))
            *errstr = (char *)(void *)0;

          goto close_file;
        }

  }

  retval=confparse(in, (char *)(void *)0, global, servers, includedepth, errstr);

close_file:
  ;
  signed int return_value_fclose_14;
  return_value_fclose_14=fclose(in);
  if(!(return_value_fclose_14 == 0))
  {
    if(!(retval == 0))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      signed int return_value_asprintf_13;
      return_value_asprintf_13=asprintf(errstr, "Error: Could not close %s file %s: %s", conftype, nm, return_value_strerror_12);
      if(!(return_value_asprintf_13 >= 0))
        *errstr = (char *)(void *)0;

      return 0;
    }

  }

  unsigned int return_value_da_nel_16;
  if(!(servers == ((struct anonymous_18 **)NULL)) && !(retval == 0))
  {
    return_value_da_nel_16=da_nel_link1((struct anonymous_3 *)*servers);
    if(return_value_da_nel_16 == 0u)
    {
      signed int return_value_asprintf_15;
      return_value_asprintf_15=asprintf(errstr, "Error: no server sections defined in config file %s", nm);
      if(!(return_value_asprintf_15 >= 0))
        *errstr = (char *)(void *)0;

      return 0;
    }

  }

  return retval;
}

// read_disk_cache
// file cache.h line 164
void read_disk_cache(void)
{
  struct anonymous_0 ce;
  signed int dtsz = 512;
  unsigned char *data;
  unsigned long int cnt;
  struct _IO_FILE *f;
  signed long int f_array_size0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(global.cache_dir);
  f_array_size0 = (signed long int)(return_value_strlen_1 + sizeof(char [13l]) /*13ul*/ );
  char path[f_array_size0];
  char *return_value_stpcpy_2;
  return_value_stpcpy_2=stpcpy(path, global.cache_dir);
  stpcpy(return_value_stpcpy_2, "/pdnsd.cache");
  f=fopen(path, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    log_message(4, "Could not open disk cache file %s: %s", (const void *)path, return_value_strerror_4);
    goto __CPROVER_DUMP_L55;
  }

  void *return_value_malloc_5;
  return_value_malloc_5=malloc((unsigned long int)dtsz);
  data = (unsigned char *)return_value_malloc_5;
  signed int return_value_feof_10;
  signed int return_value_feof_8;
  unsigned long int return_value_fread_16;
  signed int return_value_feof_14;
  signed int return_value_feof_18;
  signed int return_value_feof_22;
  signed int return_value_feof_26;
  signed int return_value_feof_32;
  signed int return_value_feof_38;
  unsigned long int return_value_fread_45;
  signed int return_value_feof_43;
  if(!(data == ((unsigned char *)NULL)))
  {
    insert_sort = (signed short int)0;
    unsigned int read_disk_cache__1__3__nb;
    char buf[(signed long int)sizeof(const char [4l]) /*4l*/ ];
    unsigned long int return_value_fread_6;
    return_value_fread_6=fread((void *)buf, (unsigned long int)1, sizeof(const char [4l]) /*4ul*/ , f);
    read_disk_cache__1__3__nb = (unsigned int)return_value_fread_6;
    if(!((unsigned long int)read_disk_cache__1__3__nb == sizeof(const char [4l]) /*4ul*/ ))
    {
      _Bool tmp_if_expr_11;
      if(!(read_disk_cache__1__3__nb == 0u))
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_feof_10=feof(f);
        tmp_if_expr_11 = !(return_value_feof_10 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
      {
        signed int return_value_ferror_7;
        return_value_ferror_7=ferror(f);
        char *tmp_if_expr_9;
        if(!(return_value_ferror_7 == 0))
          tmp_if_expr_9 = "Error";

        else
        {
          return_value_feof_8=feof(f);
          tmp_if_expr_9 = return_value_feof_8 != 0 ? "EOF" : "Incomplete item";
        }
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_9, (const void *)"cache version identifier");
      }

      goto free_data_fclose;
    }

    signed int return_value_memcmp_12;
    return_value_memcmp_12=memcmp((const void *)buf, (const void *)cachverid, sizeof(const char [4l]) /*4ul*/ );
    if(!(return_value_memcmp_12 == 0))
      log_message(4, "Cache file %s ignored because of incompatible version identifier", (const void *)path);

    else
    {
      return_value_fread_16=fread((void *)&cnt, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, f);
      if(!(return_value_fread_16 == 1ul))
      {
        signed int return_value_ferror_13;
        return_value_ferror_13=ferror(f);
        char *tmp_if_expr_15;
        if(!(return_value_ferror_13 == 0))
          tmp_if_expr_15 = "Error";

        else
        {
          return_value_feof_14=feof(f);
          tmp_if_expr_15 = return_value_feof_14 != 0 ? "EOF" : "Incomplete item";
        }
        log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_15, (const void *)"entry count");
        goto free_data_fclose;
      }

      for( ; cnt >= 1ul; cnt = cnt - 1ul)
      {
        struct anonymous_62 fe;
        struct anonymous_63 fttlts = { .ttl=(signed long int)0, .ts=(signed long int)0 };
        unsigned char nb[256l];
        unsigned int num_rrs;
        unsigned char prevtp;
        unsigned long int return_value_fread_20;
        return_value_fread_20=fread((void *)&fe, sizeof(struct anonymous_62) /*6ul*/ , (unsigned long int)1, f);
        if(!(return_value_fread_20 == 1ul))
        {
          signed int return_value_ferror_17;
          return_value_ferror_17=ferror(f);
          char *tmp_if_expr_19;
          if(!(return_value_ferror_17 == 0))
            tmp_if_expr_19 = "Error";

          else
          {
            return_value_feof_18=feof(f);
            tmp_if_expr_19 = return_value_feof_18 != 0 ? "EOF" : "Incomplete item";
          }
          log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_19, (const void *)"cache entry header");
          goto free_data_fclose;
        }

        if(!((1 & (signed int)fe.flags) == 0))
        {
          unsigned long int return_value_fread_24;
          return_value_fread_24=fread((void *)&fttlts, sizeof(struct anonymous_63) /*16ul*/ , (unsigned long int)1, f);
          if(!(return_value_fread_24 == 1ul))
          {
            signed int return_value_ferror_21;
            return_value_ferror_21=ferror(f);
            char *tmp_if_expr_23;
            if(!(return_value_ferror_21 == 0))
              tmp_if_expr_23 = "Error";

            else
            {
              return_value_feof_22=feof(f);
              tmp_if_expr_23 = return_value_feof_22 != 0 ? "EOF" : "Incomplete item";
            }
            log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_23, (const void *)"cache TTL and timestamp");
            goto free_data_fclose;
          }

        }

        if(!(fe.qlen == 0))
        {
          signed int i;
          unsigned long int return_value_fread_28;
          return_value_fread_28=fread((void *)nb, (unsigned long int)fe.qlen, (unsigned long int)1, f);
          if(!(return_value_fread_28 == 1ul))
          {
            signed int return_value_ferror_25;
            return_value_ferror_25=ferror(f);
            char *tmp_if_expr_27;
            if(!(return_value_ferror_25 == 0))
              tmp_if_expr_27 = "Error";

            else
            {
              return_value_feof_26=feof(f);
              tmp_if_expr_27 = return_value_feof_26 != 0 ? "EOF" : "Incomplete item";
            }
            log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_27, (const void *)"domain name");
            goto free_data_fclose;
          }

          i = 0;
          while(!(i >= (signed int)fe.qlen))
          {
            unsigned int lb = (unsigned int)nb[(signed long int)i];
            _Bool tmp_if_expr_29;
            if(lb == 0u || lb >= 64u)
              tmp_if_expr_29 = (_Bool)1;

            else
            {
              i = i + (signed int)(lb + (unsigned int)1);
              tmp_if_expr_29 = i > (signed int)fe.qlen ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_29)
            {
              log_message(4, "Invalid domain name encountered while reading disk cache file.");
              goto free_data_fclose;
            }

          }
        }

        nb[(signed long int)fe.qlen] = (unsigned char)0;
        signed int return_value_init_cent_30;
        return_value_init_cent_30=init_cent(&ce, nb, fttlts.ttl, fttlts.ts, (unsigned int)fe.flags);
        if(return_value_init_cent_30 == 0)
          goto free_data_fclose_exit;

        ce.c_ns = fe.c_ns;
        ce.c_soa = fe.c_soa;
        prevtp = (unsigned char)0;
        num_rrs = (unsigned int)fe.num_rrs;
        for( ; !(num_rrs == 0u); num_rrs = num_rrs - 1u)
        {
          struct anonymous_61 sh;
          unsigned int num_rr;
          unsigned long int return_value_fread_34;
          return_value_fread_34=fread((void *)&sh, sizeof(struct anonymous_61) /*20ul*/ , (unsigned long int)1, f);
          if(!(return_value_fread_34 == 1ul))
          {
            signed int return_value_ferror_31;
            return_value_ferror_31=ferror(f);
            char *tmp_if_expr_33;
            if(!(return_value_ferror_31 == 0))
              tmp_if_expr_33 = "Error";

            else
            {
              return_value_feof_32=feof(f);
              tmp_if_expr_33 = return_value_feof_32 != 0 ? "EOF" : "Incomplete item";
            }
            log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_33, (const void *)"rr header");
            goto free_cent_data_fclose;
          }

          _Bool tmp_if_expr_35;
          if((signed int)sh.tp >= 52 || !((signed int)sh.tp >= 1))
            tmp_if_expr_35 = (_Bool)1;

          else
            tmp_if_expr_35 = (signed int)rrlkuptab[(signed long int)((signed int)sh.tp - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_35)
          {
            log_message(4, "Invalid rr type encountered while reading disk cache file.");
            goto free_data_fclose;
          }

          if((signed int)prevtp >= (signed int)sh.tp)
          {
            log_message(4, "Unexpected rr type encountered (not in strict ascending order) while reading disk cache file.");
            goto free_data_fclose;
          }

          prevtp = sh.tp;
          signed int return_value_add_cent_rrset_by_type_36;
          return_value_add_cent_rrset_by_type_36=add_cent_rrset_by_type(&ce, (signed int)sh.tp, sh.ttl, sh.ts, (unsigned int)sh.flags);
          if(return_value_add_cent_rrset_by_type_36 == 0)
            goto free_cent_data_fclose_exit;

          num_rr = (unsigned int)sh.num_rr;
          for( ; !(num_rr == 0u); num_rr = num_rr - 1u)
          {
            struct anonymous_60 rr;
            unsigned long int return_value_fread_40;
            return_value_fread_40=fread((void *)&rr, sizeof(struct anonymous_60) /*2ul*/ , (unsigned long int)1, f);
            if(!(return_value_fread_40 == 1ul))
            {
              signed int return_value_ferror_37;
              return_value_ferror_37=ferror(f);
              char *tmp_if_expr_39;
              if(!(return_value_ferror_37 == 0))
                tmp_if_expr_39 = "Error";

              else
              {
                return_value_feof_38=feof(f);
                tmp_if_expr_39 = return_value_feof_38 != 0 ? "EOF" : "Incomplete item";
              }
              log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_39, (const void *)"rr data length");
              goto free_cent_data_fclose;
            }

            if(!(dtsz >= (signed int)rr.rdlen))
            {
              unsigned char *tmp;
              dtsz = (signed int)rr.rdlen;
              void *return_value_realloc_41;
              return_value_realloc_41=realloc((void *)data, (unsigned long int)dtsz);
              tmp = (unsigned char *)return_value_realloc_41;
              if(tmp == ((unsigned char *)NULL))
                goto free_cent_data_fclose_exit;

              data = tmp;
            }

            if(!(rr.rdlen == 0))
            {
              return_value_fread_45=fread((void *)data, (unsigned long int)rr.rdlen, (unsigned long int)1, f);
              if(!(return_value_fread_45 == 1ul))
              {
                signed int return_value_ferror_42;
                return_value_ferror_42=ferror(f);
                char *tmp_if_expr_44;
                if(!(return_value_ferror_42 == 0))
                  tmp_if_expr_44 = "Error";

                else
                {
                  return_value_feof_43=feof(f);
                  tmp_if_expr_44 = return_value_feof_43 != 0 ? "EOF" : "Incomplete item";
                }
                log_message(4, "%s encountered while reading %s from disk cache file.", tmp_if_expr_44, (const void *)"rr data");
                goto free_cent_data_fclose;
              }

            }

            signed int return_value_add_cent_rr_46;
            return_value_add_cent_rr_46=add_cent_rr(&ce, (signed int)sh.tp, sh.ttl, sh.ts, (unsigned int)sh.flags, (unsigned int)rr.rdlen, (void *)data);
            if(return_value_add_cent_rr_46 == 0)
              goto free_cent_data_fclose_exit;

          }
        }
        add_cache(&ce);
        free_cent(&ce);
      }
      goto free_data_fclose;

    free_cent_data_fclose:
      ;
      free_cent(&ce);
    }

  free_data_fclose:
    ;
    free((void *)data);
    fclose(f);
    lock_cache_r();
    if(insert_sort == 0)
    {
      sort_rrl();
      insert_sort = (signed short int)1;
    }

    unlock_cache_r();
    goto __CPROVER_DUMP_L55;

  free_cent_data_fclose_exit:
    ;
    free_cent(&ce);

  free_data_fclose_exit:
    ;
    free((void *)data);
  }


fclose_exit:
  ;
  fclose(f);
  log_message(3, "Out of memory in reading cache file. Exiting.");
  pdnsd_exit();

__CPROVER_DUMP_L55:
  ;
}

// read_domain
// file status.c line 148
static signed int read_domain(signed int fh, char *buf, unsigned int buflen)
{
  unsigned short int count;
  unsigned int nread;
  signed int return_value_read_short_1;
  return_value_read_short_1=read_short(fh, &count);
  if(return_value_read_short_1 == 0)
    return 0;

  else
    if(count == 65535)
      return -1;

    else
      if((unsigned int)count >= buflen)
        return 0;

      else
      {
        nread = (unsigned int)0;
        while(!(nread >= (unsigned int)count))
        {
          signed long int m;
          m=read(fh, (void *)(buf + (signed long int)nread), (unsigned long int)((unsigned int)count - nread));
          if(!(m >= 1l))
            return 0;

          nread = nread + (unsigned int)m;
        }
        buf[(signed long int)count] = (char)0;
        return 1;
      }
}

// read_hosts
// file dns.h line 291
signed int read_hosts(const char *fn, unsigned char *rns, signed long int ttl, unsigned int flags, signed int aliases, char **errstr)
{
  signed int rv = 0;
  struct _IO_FILE *f;
  char *buf;
  unsigned long int buflen = (unsigned long int)256;
  f=fopen(fn, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    signed int return_value_asprintf_3;
    return_value_asprintf_3=asprintf(errstr, "Failed to source %s: %s", fn, return_value_strerror_2);
    if(!(return_value_asprintf_3 >= 0))
      *errstr = (char *)(void *)0;

    return 0;
  }

  void *return_value_malloc_4;
  return_value_malloc_4=malloc(buflen);
  buf = (char *)return_value_malloc_4;
  signed long int return_value_getline_5;
  const unsigned short int **return_value___ctype_b_loc_8;
  const unsigned short int **return_value___ctype_b_loc_9;
  _Bool tmp_if_expr_11;
  const unsigned short int **return_value___ctype_b_loc_10;
  _Bool tmp_if_expr_17;
  const unsigned short int **return_value___ctype_b_loc_16;
  signed int return_value_feof_23;
  signed int *return_value___errno_location_20;
  char *return_value_strerror_21;
  signed int return_value_asprintf_22;
  if(buf == ((char *)NULL))
    *errstr = (char *)(void *)0;

  else
  {
    do
    {
      return_value_getline_5=getline(&buf, &buflen, f);
      if(!(return_value_getline_5 >= 0l))
        break;

      unsigned int len;
      unsigned char *p;
      unsigned char *pn;
      unsigned char *pi;
      unsigned char rhn[256l];
      signed int tp;
      signed int sz;
      union anonymous_6 a;
      char *return_value_strchr_6;
      return_value_strchr_6=strchr(buf, 35);
      p = (unsigned char *)return_value_strchr_6;
      if(!(p == ((unsigned char *)NULL)))
        *p = (unsigned char)0;

      p = (unsigned char *)buf;
      while((_Bool)1)
      {
        if(*p == 0)
          goto nextline;

        const unsigned short int **return_value___ctype_b_loc_7;
        return_value___ctype_b_loc_7=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)*p]) == 0)
          break;

        p = p + 1l;
      }
      pi = p;
      do
      {
        p = p + 1l;
        if(*p == 0)
          goto nextline;

        return_value___ctype_b_loc_8=__ctype_b_loc();
      }
      while((8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)*p]) == 0);
      *p = (unsigned char)0;
      do
      {
        p = p + 1l;
        if(*p == 0)
          goto nextline;

        return_value___ctype_b_loc_9=__ctype_b_loc();
      }
      while(!((8192 & (signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)*p]) == 0));
      pn = p;
      do
      {
        p = p + 1l;
        if(!(*p == 0))
        {
          return_value___ctype_b_loc_10=__ctype_b_loc();
          tmp_if_expr_11 = !(((signed int)(*return_value___ctype_b_loc_10)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_11 = (_Bool)0;
      }
      while(tmp_if_expr_11);
      len = (unsigned int)(p - pn);
      const char *return_value_parsestr2rhn_12;
      return_value_parsestr2rhn_12=parsestr2rhn(pn, len, rhn);
      if(return_value_parsestr2rhn_12 == ((const char *)NULL))
      {
        signed int return_value_inet_aton_14;
        return_value_inet_aton_14=inet_aton((char *)pi, &a.ipv4);
        if(!(return_value_inet_aton_14 == 0))
        {
          tp = 1;
          sz = (signed int)sizeof(struct in_addr) /*4ul*/ ;
        }

        else
        {
          signed int return_value_inet_pton_13;
          return_value_inet_pton_13=inet_pton(10, (char *)pi, (void *)&a.ipv6);
          if(return_value_inet_pton_13 >= 1)
          {
            tp = 28;
            sz = (signed int)sizeof(struct in6_addr) /*16ul*/ ;
          }

          else
            continue;
        }
        signed int res;
        res=add_host(rhn, rns, &a, tp, sz, ttl, flags, 1);
        if(res == 0)
        {
          *errstr = (char *)(void *)0;
          goto cleanup_return;
        }

        else
          if(!(res >= 0))
            continue;

        if(!(aliases == 0))
        {

        __CPROVER_DUMP_L18:
          ;
          while(!(*p == 0))
          {
            const unsigned short int **return_value___ctype_b_loc_15;
            return_value___ctype_b_loc_15=__ctype_b_loc();
            if(!((8192 & (signed int)(*return_value___ctype_b_loc_15)[(signed long int)(signed int)*p]) == 0))
            {
              p = p + 1l;
              goto __CPROVER_DUMP_L18;
            }

            pn = p;
            do
            {
              p = p + 1l;
              if(!(*p == 0))
              {
                return_value___ctype_b_loc_16=__ctype_b_loc();
                tmp_if_expr_17 = !(((signed int)(*return_value___ctype_b_loc_16)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_17 = (_Bool)0;
            }
            while(tmp_if_expr_17);
            len = (unsigned int)(p - pn);
            const char *return_value_parsestr2rhn_18;
            return_value_parsestr2rhn_18=parsestr2rhn(pn, len, rhn);
            if(!(return_value_parsestr2rhn_18 == ((const char *)NULL)))
              break;

            signed int return_value_add_host_19;
            return_value_add_host_19=add_host(rhn, rns, &a, tp, sz, ttl, flags, 0);
            if(return_value_add_host_19 == 0)
            {
              *errstr = (char *)(void *)0;
              goto cleanup_return;
            }

          }
        }

      }


    nextline:
      ;
    }
    while((_Bool)1);
    return_value_feof_23=feof(f);
    if(!(return_value_feof_23 == 0))
      rv = 1;

    else
    {
      return_value___errno_location_20=__errno_location();
      return_value_strerror_21=strerror(*return_value___errno_location_20);
      return_value_asprintf_22=asprintf(errstr, "Failed to source %s: %s", fn, return_value_strerror_21);
      if(!(return_value_asprintf_22 >= 0))
        *errstr = (char *)(void *)0;

    }

  cleanup_return:
    ;
    free((void *)buf);
  }

fclose_return:
  ;
  fclose(f);
  return rv;
}

// read_long
// file status.c line 104
static signed int read_long(signed int fh, unsigned int *res)
{
  unsigned int cmd;
  signed long int return_value_read_1;
  return_value_read_1=read(fh, (void *)&cmd, sizeof(unsigned int) /*4ul*/ );
  if(!((unsigned long int)return_value_read_1 == sizeof(unsigned int) /*4ul*/ ))
    return 0;

  else
  {
    *res=ntohl(cmd);
    return 1;
  }
}

// read_resolv_conf
// file conf-parser.c line 2009
static signed int read_resolv_conf(const char *fn, struct anonymous_19 **ata, char **errstr)
{
  signed int rv = 0;
  struct _IO_FILE *f;
  char *buf;
  unsigned long int buflen = (unsigned long int)256;
  unsigned int linenr = (unsigned int)0;
  f=fopen(fn, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    signed int return_value_asprintf_3;
    return_value_asprintf_3=asprintf(errstr, "Failed to open %s: %s", fn, return_value_strerror_2);
    if(!(return_value_asprintf_3 >= 0))
      *errstr = (char *)(void *)0;

    return 0;
  }

  void *return_value_malloc_4;
  return_value_malloc_4=malloc(buflen);
  buf = (char *)return_value_malloc_4;
  signed long int return_value_getline_5;
  const unsigned short int **return_value___ctype_b_loc_7;
  signed int return_value_strncmp_12;
  const unsigned short int **return_value___ctype_b_loc_8;
  _Bool tmp_if_expr_10;
  const unsigned short int **return_value___ctype_b_loc_9;
  signed int return_value_feof_16;
  signed int *return_value___errno_location_13;
  char *return_value_strerror_14;
  signed int return_value_asprintf_15;
  if(buf == ((char *)NULL))
    *errstr = (char *)(void *)0;

  else
  {
    do
    {
      return_value_getline_5=getline(&buf, &buflen, f);
      if(!(return_value_getline_5 >= 0l))
        break;

      unsigned long int len;
      char *p;
      char *ps;
      linenr = linenr + 1u;
      p = buf;
      for( ; (_Bool)1; p = p + 1l)
      {
        if(*p == 0)
          goto nextline;

        const unsigned short int **return_value___ctype_b_loc_6;
        return_value___ctype_b_loc_6=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_6)[(signed long int)(signed int)*p]) == 0)
          break;

      }
      ps = p;
      do
      {
        p = p + 1l;
        if(*p == 0)
          goto nextline;

        return_value___ctype_b_loc_7=__ctype_b_loc();
      }
      while((8192 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)*p]) == 0);
      len = (unsigned long int)(p - ps);
      if(len == 10ul)
      {
        return_value_strncmp_12=strncmp(ps, "nameserver", len);
        if(return_value_strncmp_12 == 0)
        {
          const char *errmsg;
          do
          {
            p = p + 1l;
            if(*p == 0)
              goto nextline;

            return_value___ctype_b_loc_8=__ctype_b_loc();
          }
          while(!((8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)(signed int)*p]) == 0));
          ps = p;
          do
          {
            p = p + 1l;
            if(!(*p == 0))
            {
              return_value___ctype_b_loc_9=__ctype_b_loc();
              tmp_if_expr_10 = !(((signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_10 = (_Bool)0;
          }
          while(tmp_if_expr_10);
          len = (unsigned long int)(p - ps);
          const signed long int errmsg_array_size0 = (signed long int)(len + (unsigned long int)1);
          char ipstr[errmsg_array_size0];
          memcpy((void *)ipstr, (const void *)ps, len);
          ipstr[(signed long int)len] = (char)0;
          errmsg=addr_add(ata, ipstr);
          if(!(errmsg == ((const char *)NULL)))
          {
            signed int return_value_asprintf_11;
            return_value_asprintf_11=asprintf(errstr, "%s in line %u of file %s", errmsg, linenr, fn);
            if(!(return_value_asprintf_11 >= 0))
              *errstr = (char *)(void *)0;

            goto cleanup_return;
          }

        }

      }


    nextline:
      ;
    }
    while((_Bool)1);
    return_value_feof_16=feof(f);
    if(!(return_value_feof_16 == 0))
      rv = 1;

    else
    {
      return_value___errno_location_13=__errno_location();
      return_value_strerror_14=strerror(*return_value___errno_location_13);
      return_value_asprintf_15=asprintf(errstr, "Failed to read %s: %s", fn, return_value_strerror_14);
      if(!(return_value_asprintf_15 >= 0))
        *errstr = (char *)(void *)0;

    }

  cleanup_return:
    ;
    free((void *)buf);
  }

fclose_return:
  ;
  fclose(f);
  return rv;
}

// read_short
// file status.c line 91
static signed int read_short(signed int fh, unsigned short int *res)
{
  unsigned short int cmd;
  signed long int return_value_read_1;
  return_value_read_1=read(fh, (void *)&cmd, sizeof(unsigned short int) /*2ul*/ );
  if(!((unsigned long int)return_value_read_1 == sizeof(unsigned short int) /*2ul*/ ))
    return 0;

  else
  {
    *res=ntohs(cmd);
    return 1;
  }
}

// realloc_or_cleanup
// file dns_query.c line 784
static inline void * realloc_or_cleanup(void *ptr, unsigned long int size)
{
  void *retval;
  retval=realloc(ptr, size);
  if(retval == NULL)
    free(ptr);

  return retval;
}

// reject_add
// file conf-parser.c line 1926
static const char * reject_add(struct anonymous_7 *serv, const char *ipstr)
{
  char *slash;
  slash=strchr(ipstr, 47);
  signed int mlen = 0;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(!(slash == ((char *)NULL)))
  {
    char *tmp_post_1 = slash;
    slash = slash + 1l;
    *tmp_post_1 = (char)0;
    if(!(*slash == 0))
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*slash]) == 0))
      {
        char *endptr;
        signed int l;
        signed long int return_value_strtol_2;
        return_value_strtol_2=strtol(slash, &endptr, 10);
        l = (signed int)return_value_strtol_2;
        if(*endptr == 0)
        {
          mlen = l;
          slash = (char *)(void *)0;
        }

      }

    }

  }

  else
    mlen = 128;
  struct anonymous_11 am;
  am.mask.s_addr=mk_netmask4(mlen);
  signed int return_value_inet_aton_7;
  return_value_inet_aton_7=inet_aton(ipstr, &am.a);
  signed int return_value_inet_aton_5;
  if(!(return_value_inet_aton_7 == 0))
  {
    _Bool tmp_if_expr_6;
    if(slash == ((char *)NULL))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_inet_aton_5=inet_aton(slash, &am.mask);
      tmp_if_expr_6 = return_value_inet_aton_5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      struct anonymous_3 *return_value_da_grow1_4;
      return_value_da_grow1_4=da_grow1((struct anonymous_3 *)serv->reject_a4, (unsigned long int)((struct anonymous_10 *)0)->elem, sizeof(struct anonymous_11) /*8ul*/ , (void (*)(void *))(void *)0);
      serv->reject_a4 = (struct anonymous_10 *)return_value_da_grow1_4;
      if(serv->reject_a4 == ((struct anonymous_10 *)NULL))
        return "out of memory!";

      serv->reject_a4->elem[(signed long int)(serv->reject_a4->nel - (unsigned long int)1)] = am;
      return (const char *)(void *)0;
    }

  }

  struct anonymous_13 reject_add__1__3__am;
  mk_netmask6(&reject_add__1__3__am.mask, mlen);
  signed int return_value_inet_pton_11;
  return_value_inet_pton_11=inet_pton(10, ipstr, (void *)&reject_add__1__3__am.a);
  signed int return_value_inet_pton_9;
  if(return_value_inet_pton_11 >= 1)
  {
    _Bool tmp_if_expr_10;
    if(slash == ((char *)NULL))
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_inet_pton_9=inet_pton(10, slash, (void *)&reject_add__1__3__am.mask);
      tmp_if_expr_10 = return_value_inet_pton_9 > 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_10)
    {
      struct anonymous_3 *return_value_da_grow1_8;
      return_value_da_grow1_8=da_grow1((struct anonymous_3 *)serv->reject_a6, (unsigned long int)((struct anonymous_12 *)0)->elem, sizeof(struct anonymous_13) /*32ul*/ , (void (*)(void *))(void *)0);
      serv->reject_a6 = (struct anonymous_12 *)return_value_da_grow1_8;
      if(serv->reject_a6 == ((struct anonymous_12 *)NULL))
        return "out of memory!";

      serv->reject_a6->elem[(signed long int)(serv->reject_a6->nel - (unsigned long int)1)] = reject_add__1__3__am;
      return (const char *)(void *)0;
    }

  }

  return "bad IP address";
}

// reload_config_file
// file conff.c line 222
signed int reload_config_file(const char *nm, char **errstr)
{
  struct anonymous_21 global_new;
  struct anonymous_18 *servers_new;
  global_new = global;
  global_new.cache_dir = (char *)(void *)0;
  global_new.pidfile = (char *)(void *)0;
  global_new.scheme_file = (char *)(void *)0;
  global_new.deleg_only_zones = (struct anonymous_30 *)(void *)0;
  global_new.onquery = (char)0;
  servers_new = (struct anonymous_18 *)(void *)0;
  signed int return_value_read_config_file_16;
  return_value_read_config_file_16=read_config_file(nm, &global_new, &servers_new, 0, errstr);
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(!(return_value_read_config_file_16 == 0))
  {
    if(!(global_new.cache_dir == ((char *)NULL)))
    {
      return_value_strcmp_1=strcmp(global_new.cache_dir, global.cache_dir);
      if(!(return_value_strcmp_1 == 0))
      {
        *errstr=strdup("Cannot reload config file: the specified cache_dir directory has changed.\nTry restarting pdnsd instead.");
        goto cleanup_return;
      }

    }

    if(!(global_new.pidfile == ((char *)NULL)))
    {
      _Bool tmp_if_expr_3;
      if(global.pidfile == ((char *)NULL))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_strcmp_2=strcmp(global_new.pidfile, global.pidfile);
        tmp_if_expr_3 = return_value_strcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
      {
        *errstr=strdup("Cannot reload config file: the specified pid_file has changed.\nTry restarting pdnsd instead.");
        goto cleanup_return;
      }

    }

    if(!(global_new.scheme_file == ((char *)NULL)))
    {
      return_value_strcmp_4=strcmp(global_new.scheme_file, global.scheme_file);
      if(!(return_value_strcmp_4 == 0))
      {
        *errstr=strdup("Cannot reload config file: the specified scheme_file has changed.\nTry restarting pdnsd instead.");
        goto cleanup_return;
      }

    }

    if(!(global_new.port == global.port))
    {
      *errstr=strdup("Cannot reload config file: the specified server_port has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    signed int tmp_if_expr_8;
    if(!(run_ipv4 == 0))
      tmp_if_expr_8 = (signed int)(((struct in_addr *)&global_new.a)->s_addr == ((struct in_addr *)&global.a)->s_addr);

    else
    {
      if(*((unsigned int *)&global_new.a) == *((unsigned int *)&global.a))
        tmp_if_expr_5 = ((unsigned int *)(struct in6_addr *)&global_new.a)[(signed long int)1] == ((unsigned int *)(struct in6_addr *)&global.a)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = ((unsigned int *)(struct in6_addr *)&global_new.a)[(signed long int)2] == ((unsigned int *)(struct in6_addr *)&global.a)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = ((unsigned int *)(struct in6_addr *)&global_new.a)[(signed long int)3] == ((unsigned int *)(struct in6_addr *)&global.a)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      tmp_if_expr_8 = (signed int)tmp_if_expr_7;
    }
    if(tmp_if_expr_8 == 0)
    {
      *errstr=strdup("Cannot reload config file: the specified interface address (server_ip) has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    _Bool tmp_if_expr_9;
    if(*((unsigned int *)&global_new.ipv4_6_prefix) == *((unsigned int *)&global.ipv4_6_prefix))
      tmp_if_expr_9 = ((unsigned int *)&global_new.ipv4_6_prefix)[(signed long int)1] == ((unsigned int *)&global.ipv4_6_prefix)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_9 = (_Bool)0;
    _Bool tmp_if_expr_10;
    if(tmp_if_expr_9)
      tmp_if_expr_10 = ((unsigned int *)&global_new.ipv4_6_prefix)[(signed long int)2] == ((unsigned int *)&global.ipv4_6_prefix)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_10 = (_Bool)0;
    _Bool tmp_if_expr_11;
    if(tmp_if_expr_10)
      tmp_if_expr_11 = ((unsigned int *)&global_new.ipv4_6_prefix)[(signed long int)3] == ((unsigned int *)&global.ipv4_6_prefix)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_11 = (_Bool)0;
    if(!tmp_if_expr_11)
    {
      *errstr=strdup("Cannot reload config file: the specified ipv4_6_prefix has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    signed int return_value_strcmp_12;
    return_value_strcmp_12=strcmp(global_new.run_as, global.run_as);
    if(!(return_value_strcmp_12 == 0))
    {
      *errstr=strdup("Cannot reload config file: the specified run_as id has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.daemon == global.daemon))
    {
      *errstr=strdup("Cannot reload config file: the daemon option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.debug == global.debug))
    {
      *errstr=strdup("Cannot reload config file: the debug option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.stat_pipe == global.stat_pipe))
    {
      *errstr=strdup("Cannot reload config file: the status_ctl option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.notcp == global.notcp))
    {
      *errstr=strdup("Cannot reload config file: the tcp_server option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.strict_suid == global.strict_suid))
    {
      *errstr=strdup("Cannot reload config file: the strict_setuid option has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(!(global_new.ctl_perms == global.ctl_perms))
    {
      *errstr=strdup("Cannot reload config file: the specified ctl_perms has changed.\nTry restarting pdnsd instead.");
      goto cleanup_return;
    }

    if(ping6_isocket == -1 && ping_isocket == -1)
    {
      signed int i;
      signed int n;
      unsigned int return_value_da_nel_13;
      return_value_da_nel_13=da_nel_link1((struct anonymous_3 *)servers_new);
      n = (signed int)return_value_da_nel_13;
      i = 0;
      for( ; !(i >= n); i = i + 1)
        if((signed int)servers_new->elem[(signed long int)i].uptest == 8)
        {
          signed int return_value_asprintf_14;
          return_value_asprintf_14=asprintf(errstr, "Cannot reload config file: the ping socket is not initialized and the new config contains uptest=ping in server section %i.\nTry restarting pdnsd instead.", i);
          if(!(return_value_asprintf_14 >= 0))
            *errstr = (char *)(void *)0;

          goto cleanup_return;
        }

    }

    signed int return_value_exclusive_lock_server_data_15;
    return_value_exclusive_lock_server_data_15=exclusive_lock_server_data(60);
    if(return_value_exclusive_lock_server_data_15 == 0)
    {
      *errstr=strdup("Cannot reload config file: Timed out while waiting for access to config data.");
      goto cleanup_return;
    }

    free((void *)global_new.cache_dir);
    global_new.cache_dir = global.cache_dir;
    free((void *)global_new.pidfile);
    global_new.pidfile = global.pidfile;
    free((void *)global_new.scheme_file);
    global_new.scheme_file = global.scheme_file;
    free_zones(global.deleg_only_zones);
    global = global_new;
    free_server_data(servers);
    servers = servers_new;
    exclusive_unlock_server_data(1);
    return 1;
  }


cleanup_return:
  ;
  free((void *)global_new.cache_dir);
  free((void *)global_new.pidfile);
  free((void *)global_new.scheme_file);
  free_zones(global_new.deleg_only_zones);
  free_server_data(servers_new);
  return 0;
}

// remove_opt_pseudo_rr
// file dns_answer.c line 462
unsigned long int remove_opt_pseudo_rr(struct anonymous_28 *ans, unsigned long int sz)
{
  unsigned short int acnt;
  acnt=ntohs(ans->hdr.arcount);
  unsigned short int type;
  unsigned char *ptr;
  if(!(sz >= 23ul) || !((signed int)acnt >= 1))
    return (unsigned long int)0;

  else
  {
    sz = sz - (unsigned long int)(1 + 10);
    ptr = (unsigned char *)&ans->hdr + (signed long int)sz;
    unsigned char *tmp_post_1 = ptr;
    ptr = ptr + 1l;
    if(!(*tmp_post_1 == 0))
      return (unsigned long int)0;

    else
    {
      do
      {
        unsigned short int t_s;
        const unsigned char *t_cp = (const unsigned char *)ptr;
        const unsigned char *tmp_post_2 = t_cp;
        t_cp = t_cp + 1l;
        t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_2 << 8);
        const unsigned char *tmp_post_3 = t_cp;
        t_cp = t_cp + 1l;
        t_s = t_s | (unsigned short int)*tmp_post_3;
        type = t_s;
        ptr = (unsigned char *)(void *)t_cp;
      }
      while((_Bool)0);
      if(!((signed int)type == 41))
        return (unsigned long int)0;

      else
      {
        ans->hdr.arcount=htons((unsigned short int)((signed int)acnt - 1));
        return sz;
      }
    }
  }
}

// remove_rrl
// file cache.c line 953
static void remove_rrl(struct rr_lent_s *le)
{
  struct rr_lent_s *next = le->next;
  struct rr_lent_s *prev = le->prev;
  if(!(next == ((struct rr_lent_s *)NULL)))
    next->prev = prev;

  else
    rrset_l_tail = prev;
  if(!(prev == ((struct rr_lent_s *)NULL)))
    prev->next = next;

  else
    rrset_l = next;
  free((void *)le);
}

// report_cache_stat
// file cache.h line 167
signed int report_cache_stat(signed int f)
{
  signed long int mc = (signed long int)global.perm_cache * (signed long int)1024 + (signed long int)10240;
  signed int _retval;
  _retval=fsprintf(f, "\nCache status:\n=============\n");
  if(!(_retval >= 0))
    return _retval;

  else
  {
    signed int report_cache_stat__1__2___retval;
    report_cache_stat__1__2___retval=fsprintf(f, "%ld kB maximum disk cache size.\n", global.perm_cache);
    if(!(report_cache_stat__1__2___retval >= 0))
      return report_cache_stat__1__2___retval;

    else
    {
      signed int report_cache_stat__1__3___retval;
      report_cache_stat__1__3___retval=fsprintf(f, "%ld of %ld bytes (%.3g%%) memory cache used in %ld entries (avg %.5g bytes/entry).\n", cache_size, mc, ((double)cache_size / (double)mc) * (double)100, ent_num, (double)cache_size / (double)ent_num);
      if(!(report_cache_stat__1__3___retval >= 0))
        return report_cache_stat__1__3___retval;

      else
        return 0;
    }
  }
}

// report_conf_stat
// file conff.c line 399
signed int report_conf_stat(signed int f)
{
  signed int i;
  signed int n;
  signed int retval = 0;
  signed int report_conf_stat__1__1___retval;
  report_conf_stat__1__1___retval=fsprintf(f, "\nConfiguration:\n==============\nGlobal:\n-------\n");
  unsigned int return_value_da_nel_10;
  if(!(report_conf_stat__1__1___retval >= 0))
    return report_conf_stat__1__1___retval;

  else
  {
    signed int report_conf_stat__1__2___retval;
    report_conf_stat__1__2___retval=fsprintf(f, "\tCache size: %li kB\n", global.perm_cache);
    if(!(report_conf_stat__1__2___retval >= 0))
      return report_conf_stat__1__2___retval;

    else
    {
      signed int report_conf_stat__1__3___retval;
      report_conf_stat__1__3___retval=fsprintf(f, "\tServer directory: %s\n", global.cache_dir);
      if(!(report_conf_stat__1__3___retval >= 0))
        return report_conf_stat__1__3___retval;

      else
      {
        signed int report_conf_stat__1__4___retval;
        report_conf_stat__1__4___retval=fsprintf(f, "\tScheme file (for Linux pcmcia support): %s\n", global.scheme_file);
        if(!(report_conf_stat__1__4___retval >= 0))
          return report_conf_stat__1__4___retval;

        else
        {
          signed int report_conf_stat__1__5___retval;
          report_conf_stat__1__5___retval=fsprintf(f, "\tServer port: %i\n", global.port);
          if(!(report_conf_stat__1__5___retval >= 0))
            return report_conf_stat__1__5___retval;

          else
          {
            char report_conf_stat__1__6__buf[46l];
            signed int report_conf_stat__1__6__1___retval;
            const char *return_value_pdnsd_a2str_1;
            return_value_pdnsd_a2str_1=pdnsd_a2str(&global.a, report_conf_stat__1__6__buf, 46);
            report_conf_stat__1__6__1___retval=fsprintf(f, "\tServer IP (%s=any available one): %s\n", run_ipv4 != 0 ? "0.0.0.0" : "::", return_value_pdnsd_a2str_1);
            if(!(report_conf_stat__1__6__1___retval >= 0))
              return report_conf_stat__1__6__1___retval;

            else
            {
              signed int return_value_is_inaddr_any_3;
              return_value_is_inaddr_any_3=is_inaddr_any_link1(&global.out_a);
              if(return_value_is_inaddr_any_3 == 0)
              {
                signed int report_conf_stat__1__6__2__1___retval;
                const char *return_value_pdnsd_a2str_2;
                return_value_pdnsd_a2str_2=pdnsd_a2str(&global.out_a, report_conf_stat__1__6__buf, 46);
                report_conf_stat__1__6__2__1___retval=fsprintf(f, "\tIP bound to interface used for querying remote servers: %s\n", return_value_pdnsd_a2str_2);
                if(!(report_conf_stat__1__6__2__1___retval >= 0))
                  return report_conf_stat__1__6__2__1___retval;

              }

              if(run_ipv4 == 0)
              {
                char report_conf_stat__1__7__buf[46l];
                signed int report_conf_stat__1__7__1___retval;
                const char *return_value_inet_ntop_4;
                return_value_inet_ntop_4=inet_ntop(10, (const void *)&global.ipv4_6_prefix, report_conf_stat__1__7__buf, (unsigned int)46);
                report_conf_stat__1__7__1___retval=fsprintf(f, "\tIPv4 to IPv6 prefix: %s\n", (_Bool)return_value_inet_ntop_4 ? return_value_inet_ntop_4 : "?.?.?.?");
                if(!(report_conf_stat__1__7__1___retval >= 0))
                  return report_conf_stat__1__7__1___retval;

              }

              signed int report_conf_stat__1__8___retval;
              report_conf_stat__1__8___retval=fsprintf(f, "\tIgnore cache when link is down: %s\n", global.lndown_kluge != 0 ? "on" : "off");
              if(!(report_conf_stat__1__8___retval >= 0))
                return report_conf_stat__1__8___retval;

              else
              {
                signed int report_conf_stat__1__9___retval;
                report_conf_stat__1__9___retval=fsprintf(f, "\tMaximum ttl: %li\n", (signed long int)global.max_ttl);
                if(!(report_conf_stat__1__9___retval >= 0))
                  return report_conf_stat__1__9___retval;

                else
                {
                  signed int report_conf_stat__1__10___retval;
                  report_conf_stat__1__10___retval=fsprintf(f, "\tMinimum ttl: %li\n", (signed long int)global.min_ttl);
                  if(!(report_conf_stat__1__10___retval >= 0))
                    return report_conf_stat__1__10___retval;

                  else
                  {
                    signed int report_conf_stat__1__11___retval;
                    report_conf_stat__1__11___retval=fsprintf(f, "\tNegative ttl: %li\n", (signed long int)global.neg_ttl);
                    if(!(report_conf_stat__1__11___retval >= 0))
                      return report_conf_stat__1__11___retval;

                    else
                    {
                      signed int report_conf_stat__1__12___retval;
                      const char *return_value_const_name_5;
                      return_value_const_name_5=const_name((signed int)global.neg_rrs_pol);
                      report_conf_stat__1__12___retval=fsprintf(f, "\tNegative RRS policy: %s\n", return_value_const_name_5);
                      if(!(report_conf_stat__1__12___retval >= 0))
                        return report_conf_stat__1__12___retval;

                      else
                      {
                        signed int report_conf_stat__1__13___retval;
                        const char *return_value_const_name_6;
                        return_value_const_name_6=const_name((signed int)global.neg_domain_pol);
                        report_conf_stat__1__13___retval=fsprintf(f, "\tNegative domain policy: %s\n", return_value_const_name_6);
                        if(!(report_conf_stat__1__13___retval >= 0))
                          return report_conf_stat__1__13___retval;

                        else
                        {
                          signed int report_conf_stat__1__14___retval;
                          report_conf_stat__1__14___retval=fsprintf(f, "\tRun as: %s\n", (const void *)global.run_as);
                          if(!(report_conf_stat__1__14___retval >= 0))
                            return report_conf_stat__1__14___retval;

                          else
                          {
                            signed int report_conf_stat__1__15___retval;
                            report_conf_stat__1__15___retval=fsprintf(f, "\tStrict run as: %s\n", global.strict_suid != 0 ? "on" : "off");
                            if(!(report_conf_stat__1__15___retval >= 0))
                              return report_conf_stat__1__15___retval;

                            else
                            {
                              signed int report_conf_stat__1__16___retval;
                              report_conf_stat__1__16___retval=fsprintf(f, "\tUse NSS: %s\n", global.use_nss != 0 ? "on" : "off");
                              if(!(report_conf_stat__1__16___retval >= 0))
                                return report_conf_stat__1__16___retval;

                              else
                              {
                                signed int report_conf_stat__1__17___retval;
                                report_conf_stat__1__17___retval=fsprintf(f, "\tParanoid mode (cache pollution prevention): %s\n", global.paranoid != 0 ? "on" : "off");
                                if(!(report_conf_stat__1__17___retval >= 0))
                                  return report_conf_stat__1__17___retval;

                                else
                                {
                                  signed int report_conf_stat__1__18___retval;
                                  report_conf_stat__1__18___retval=fsprintf(f, "\tControl socket permissions (mode): %o\n", global.ctl_perms);
                                  if(!(report_conf_stat__1__18___retval >= 0))
                                    return report_conf_stat__1__18___retval;

                                  else
                                  {
                                    signed int report_conf_stat__1__19___retval;
                                    report_conf_stat__1__19___retval=fsprintf(f, "\tMaximum parallel queries served: %i\n", global.proc_limit);
                                    if(!(report_conf_stat__1__19___retval >= 0))
                                      return report_conf_stat__1__19___retval;

                                    else
                                    {
                                      signed int report_conf_stat__1__20___retval;
                                      report_conf_stat__1__20___retval=fsprintf(f, "\tMaximum queries queued for serving: %i\n", global.procq_limit);
                                      if(!(report_conf_stat__1__20___retval >= 0))
                                        return report_conf_stat__1__20___retval;

                                      else
                                      {
                                        signed int report_conf_stat__1__21___retval;
                                        report_conf_stat__1__21___retval=fsprintf(f, "\tGlobal timeout setting: %li\n", (signed long int)global.timeout);
                                        if(!(report_conf_stat__1__21___retval >= 0))
                                          return report_conf_stat__1__21___retval;

                                        else
                                        {
                                          signed int report_conf_stat__1__22___retval;
                                          report_conf_stat__1__22___retval=fsprintf(f, "\tParallel queries increment: %i\n", global.par_queries);
                                          if(!(report_conf_stat__1__22___retval >= 0))
                                            return report_conf_stat__1__22___retval;

                                          else
                                          {
                                            signed int report_conf_stat__1__23___retval;
                                            report_conf_stat__1__23___retval=fsprintf(f, "\tRandomize records in answer: %s\n", global.rnd_recs != 0 ? "on" : "off");
                                            if(!(report_conf_stat__1__23___retval >= 0))
                                              return report_conf_stat__1__23___retval;

                                            else
                                            {
                                              signed int _retval;
                                              const char *return_value_const_name_7;
                                              return_value_const_name_7=const_name(global.query_method);
                                              _retval=fsprintf(f, "\tQuery method: %s\n", return_value_const_name_7);
                                              if(!(_retval >= 0))
                                                return _retval;

                                              else
                                              {
                                                signed int query_port_start = global.query_port_start;
                                                if(query_port_start == -1)
                                                {
                                                  signed int report_conf_stat__1__25__1__1___retval;
                                                  report_conf_stat__1__25__1__1___retval=fsprintf(f, "\tQuery port start: (let kernel choose)\n");
                                                  if(!(report_conf_stat__1__25__1__1___retval >= 0))
                                                    return report_conf_stat__1__25__1__1___retval;

                                                }

                                                else
                                                {
                                                  signed int report_conf_stat__1__25__2__1___retval;
                                                  report_conf_stat__1__25__2__1___retval=fsprintf(f, "\tQuery port start: %i\n", query_port_start);
                                                  if(!(report_conf_stat__1__25__2__1___retval >= 0))
                                                    return report_conf_stat__1__25__2__1___retval;

                                                  signed int report_conf_stat__1__25__2__2___retval;
                                                  report_conf_stat__1__25__2__2___retval=fsprintf(f, "\tQuery port end: %i\n", global.query_port_end);
                                                  if(!(report_conf_stat__1__25__2__2___retval >= 0))
                                                    return report_conf_stat__1__25__2__2___retval;

                                                }
                                                signed int report_conf_stat__1__26___retval;
                                                report_conf_stat__1__26___retval=fsprintf(f, "\tTCP server thread: %s\n", global.notcp != 0 ? "off" : "on");
                                                if(!(report_conf_stat__1__26___retval >= 0))
                                                  return report_conf_stat__1__26___retval;

                                                else
                                                {
                                                  if(global.notcp == 0)
                                                  {
                                                    signed int report_conf_stat__1__27__1___retval;
                                                    report_conf_stat__1__27__1___retval=fsprintf(f, "\tTCP query timeout: %li\n", (signed long int)global.tcp_qtimeout);
                                                    if(!(report_conf_stat__1__27__1___retval >= 0))
                                                      return report_conf_stat__1__27__1___retval;

                                                  }

                                                  signed int report_conf_stat__1__28___retval;
                                                  report_conf_stat__1__28___retval=fsprintf(f, "\tMaximum udp buffer size: %i\n", global.udpbufsize);
                                                  if(!(report_conf_stat__1__28___retval >= 0))
                                                    return report_conf_stat__1__28___retval;

                                                  else
                                                  {
                                                    lock_server_data();
                                                    signed int rv;
                                                    rv=fsprintf(f, "\tDelegation-only zones: ");
                                                    if(!(rv >= 0))
                                                      retval = rv;

                                                    else
                                                    {
                                                      if(global.deleg_only_zones == ((struct anonymous_30 *)NULL))
                                                      {
                                                        signed int report_conf_stat__1__30__rv;
                                                        report_conf_stat__1__30__rv=fsprintf(f, "(none)\n");
                                                        if(!(report_conf_stat__1__30__rv >= 0))
                                                        {
                                                          retval = report_conf_stat__1__30__rv;
                                                          goto unlock_return;
                                                        }

                                                      }

                                                      else
                                                      {
                                                        signed int report_conf_stat__1__31__rv;
                                                        unsigned int return_value_da_nel_8;
                                                        return_value_da_nel_8=da_nel_link1((struct anonymous_3 *)global.deleg_only_zones);
                                                        n = (signed int)return_value_da_nel_8;
                                                        i = 0;
                                                        for( ; !(i >= n); i = i + 1)
                                                        {
                                                          unsigned char buf[256l];
                                                          const unsigned char *return_value_rhn2str_9;
                                                          return_value_rhn2str_9=rhn2str(global.deleg_only_zones->elem[(signed long int)i], buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                                          report_conf_stat__1__31__rv=fsprintf(f, i == 0 ? "%s" : ", %s", return_value_rhn2str_9);
                                                          if(!(report_conf_stat__1__31__rv >= 0))
                                                          {
                                                            retval = report_conf_stat__1__31__rv;
                                                            goto unlock_return;
                                                          }

                                                        }
                                                        report_conf_stat__1__31__rv=fsprintf(f, "\n");
                                                        if(!(report_conf_stat__1__31__rv >= 0))
                                                        {
                                                          retval = report_conf_stat__1__31__rv;
                                                          goto unlock_return;
                                                        }

                                                      }
                                                      return_value_da_nel_10=da_nel_link1((struct anonymous_3 *)servers);
                                                      n = (signed int)return_value_da_nel_10;
                                                      i = 0;
                                                      for( ; !(i >= n); i = i + 1)
                                                      {
                                                        signed int report_conf_stat__1__32__1__rv;
                                                        report_conf_stat__1__32__1__rv=report_server_stat(f, i);
                                                        if(!(report_conf_stat__1__32__1__rv >= 0))
                                                        {
                                                          retval = report_conf_stat__1__32__1__rv;
                                                          break;
                                                        }

                                                      }
                                                    }

                                                  unlock_return:
                                                    ;
                                                    unlock_server_data();
                                                    return retval;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// report_error
// file conf-parser.c line 54
static char * report_error(const char *conftype, unsigned int linenr, const char *msg)
{
  char *retval;
  if(!(linenr == 0u))
  {
    signed int return_value_asprintf_1;
    return_value_asprintf_1=asprintf(&retval, "Error in %s (line %u): %s", conftype, linenr, msg);
    if(!(return_value_asprintf_1 >= 0))
      retval = (char *)(void *)0;

  }

  else
  {
    signed int return_value_asprintf_2;
    return_value_asprintf_2=asprintf(&retval, "Error in %s: %s", conftype, msg);
    if(!(return_value_asprintf_2 >= 0))
      retval = (char *)(void *)0;

  }
  return retval;
}

// report_errorf
// file conf-parser.c line 70
static char * report_errorf(const char *conftype, unsigned int linenr, const char *frm, ...)
{
  char *msg;
  char *retval;
  signed int mlen;
  void **va = (void **)&frm;
  mlen=vasprintf(&msg, frm, va);
  va = ((void **)NULL);
  if(!(mlen >= 0))
    return (char *)(void *)0;

  else
  {
    retval=report_error(conftype, linenr, msg);
    free((void *)msg);
    return retval;
  }
}

// report_server_stat
// file conff.c line 501
static signed int report_server_stat(signed int f, signed int i)
{
  struct anonymous_7 *st = &servers->elem[(signed long int)i];
  signed int j;
  signed int m;
  signed int report_server_stat__1__1___retval;
  report_server_stat__1__1___retval=fsprintf(f, "Server %i:\n------\n", i);
  const char *return_value_pdnsd_a2str_8;
  unsigned int return_value_da_nel_14;
  if(!(report_server_stat__1__1___retval >= 0))
    return report_server_stat__1__1___retval;

  else
  {
    signed int report_server_stat__1__2___retval;
    char *tmp_if_expr_1;
    if(!(st->label == ((char *)NULL)))
      tmp_if_expr_1 = st->label;

    else
      tmp_if_expr_1 = "(none)";
    report_server_stat__1__2___retval=fsprintf(f, "\tlabel: %s\n", tmp_if_expr_1);
    if(!(report_server_stat__1__2___retval >= 0))
      return report_server_stat__1__2___retval;

    else
    {
      unsigned int return_value_da_nel_2;
      return_value_da_nel_2=da_nel_link1((struct anonymous_3 *)st->atup_a);
      m = (signed int)return_value_da_nel_2;
      if((signed int)st->rootserver >= 2)
      {
        if(!(m == 0))
        {
          signed int report_server_stat__1__3___retval;
          report_server_stat__1__3___retval=fsprintf(f, "\tThe following name servers will be used for discovery of rootservers only:\n");
          if(!(report_server_stat__1__3___retval >= 0))
            return report_server_stat__1__3___retval;

        }

      }

      j = 0;
      for( ; !(j >= m); j = j + 1)
      {
        struct anonymous_20 *at = &st->atup_a->elem[(signed long int)j];
        char buf[46l];
        signed int report_server_stat__1__4__1__1__1___retval;
        union anonymous_6 *tmp_if_expr_3;
        if(!(run_ipv4 == 0))
          tmp_if_expr_3 = (union anonymous_6 *)&(&at->a)->ipv4;

        else
          tmp_if_expr_3 = (union anonymous_6 *)&(&at->a)->ipv6;
        const char *return_value_pdnsd_a2str_4;
        return_value_pdnsd_a2str_4=pdnsd_a2str(tmp_if_expr_3, buf, 46);
        report_server_stat__1__4__1__1__1___retval=fsprintf(f, "\tip: %s\n", return_value_pdnsd_a2str_4);
        if(!(report_server_stat__1__4__1__1__1___retval >= 0))
          return report_server_stat__1__4__1__1__1___retval;

        signed int report_server_stat__1__4__1__2___retval;
        report_server_stat__1__4__1__2___retval=fsprintf(f, "\tserver assumed available: %s\n", at->is_up != 0 ? "yes" : "no");
        if(!(report_server_stat__1__4__1__2___retval >= 0))
          return report_server_stat__1__4__1__2___retval;

      }
      signed int report_server_stat__1__5___retval;
      report_server_stat__1__5___retval=fsprintf(f, "\tport: %hu\n", st->port);
      if(!(report_server_stat__1__5___retval >= 0))
        return report_server_stat__1__5___retval;

      else
      {
        signed int report_server_stat__1__6___retval;
        const char *return_value_const_name_5;
        return_value_const_name_5=const_name((signed int)st->uptest);
        report_server_stat__1__6___retval=fsprintf(f, "\tuptest: %s\n", return_value_const_name_5);
        if(!(report_server_stat__1__6___retval >= 0))
          return report_server_stat__1__6___retval;

        else
        {
          signed int report_server_stat__1__7___retval;
          report_server_stat__1__7___retval=fsprintf(f, "\ttimeout: %li\n", (signed long int)st->timeout);
          if(!(report_server_stat__1__7___retval >= 0))
            return report_server_stat__1__7___retval;

          else
          {
            if(st->interval >= 1l)
            {
              signed int report_server_stat__1__8__1___retval;
              report_server_stat__1__8__1___retval=fsprintf(f, "\tuptest interval: %li\n", (signed long int)st->interval);
              if(!(report_server_stat__1__8__1___retval >= 0))
                return report_server_stat__1__8__1___retval;

            }

            else
            {
              signed int report_server_stat__1__9__1___retval;
              char *tmp_if_expr_6;
              if(st->interval == -1l)
                tmp_if_expr_6 = "onquery";

              else
                tmp_if_expr_6 = st->interval == (signed long int)-2 ? "ontimeout" : "(never retest)";
              report_server_stat__1__9__1___retval=fsprintf(f, "\tuptest interval: %s\n", tmp_if_expr_6);
              if(!(report_server_stat__1__9__1___retval >= 0))
                return report_server_stat__1__9__1___retval;

            }
            signed int report_server_stat__1__10___retval;
            report_server_stat__1__10___retval=fsprintf(f, "\tping timeout: %li\n", (signed long int)st->ping_timeout);
            if(!(report_server_stat__1__10___retval >= 0))
              return report_server_stat__1__10___retval;

            else
            {
              char report_server_stat__1__11__buf[46l];
              signed int report_server_stat__1__11__1___retval;
              signed int return_value_is_inaddr_any_7;
              return_value_is_inaddr_any_7=is_inaddr_any_link1(&st->ping_a);
              char *tmp_if_expr_9;
              if(!(return_value_is_inaddr_any_7 == 0))
                tmp_if_expr_9 = "(using server ip)";

              else
              {
                return_value_pdnsd_a2str_8=pdnsd_a2str(&st->ping_a, report_server_stat__1__11__buf, 46);
                tmp_if_expr_9 = return_value_pdnsd_a2str_8;
              }
              report_server_stat__1__11__1___retval=fsprintf(f, "\tping ip: %s\n", tmp_if_expr_9);
              if(!(report_server_stat__1__11__1___retval >= 0))
                return report_server_stat__1__11__1___retval;

              else
              {
                if(!(st->interface[0l] == 0))
                {
                  signed int report_server_stat__1__12__1___retval;
                  report_server_stat__1__12__1___retval=fsprintf(f, "\tinterface: %s\n", (const void *)st->interface);
                  if(!(report_server_stat__1__12__1___retval >= 0))
                    return report_server_stat__1__12__1___retval;

                }

                if(!(st->device[0l] == 0))
                {
                  signed int report_server_stat__1__13__1___retval;
                  report_server_stat__1__13__1___retval=fsprintf(f, "\tdevice (for special Linux ppp device support): %s\n", (const void *)st->device);
                  if(!(report_server_stat__1__13__1___retval >= 0))
                    return report_server_stat__1__13__1___retval;

                }

                if(!(st->uptest_cmd == ((char *)NULL)))
                {
                  signed int report_server_stat__1__14__1___retval;
                  report_server_stat__1__14__1___retval=fsprintf(f, "\tuptest command: %s\n", st->uptest_cmd);
                  if(!(report_server_stat__1__14__1___retval >= 0))
                    return report_server_stat__1__14__1___retval;

                  signed int report_server_stat__1__14__2___retval;
                  char *tmp_if_expr_10;
                  if(!(st->uptest_usr[0l] == 0))
                    tmp_if_expr_10 = st->uptest_usr;

                  else
                    tmp_if_expr_10 = "(process owner)";
                  report_server_stat__1__14__2___retval=fsprintf(f, "\tuptest user: %s\n", tmp_if_expr_10);
                  if(!(report_server_stat__1__14__2___retval >= 0))
                    return report_server_stat__1__14__2___retval;

                }

                if(!(st->query_test_name == ((unsigned char *)NULL)))
                {
                  unsigned char nmbuf[256l];
                  signed int report_server_stat__1__15__1___retval;
                  const unsigned char *return_value_rhn2str_11;
                  return_value_rhn2str_11=rhn2str(st->query_test_name, nmbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                  report_server_stat__1__15__1___retval=fsprintf(f, "\tname used in query uptest: %s\n", return_value_rhn2str_11);
                  if(!(report_server_stat__1__15__1___retval >= 0))
                    return report_server_stat__1__15__1___retval;

                }

                if(!(st->scheme[0l] == 0))
                {
                  signed int report_server_stat__1__16__1___retval;
                  report_server_stat__1__16__1___retval=fsprintf(f, "\tscheme: %s\n", (const void *)st->scheme);
                  if(!(report_server_stat__1__16__1___retval >= 0))
                    return report_server_stat__1__16__1___retval;

                }

                signed int report_server_stat__1__17___retval;
                report_server_stat__1__17___retval=fsprintf(f, "\tforce cache purging: %s\n", st->purge_cache != 0 ? "on" : "off");
                if(!(report_server_stat__1__17___retval >= 0))
                  return report_server_stat__1__17___retval;

                else
                {
                  signed int report_server_stat__1__18___retval;
                  report_server_stat__1__18___retval=fsprintf(f, "\tserver is cached: %s\n", st->nocache != 0 ? "off" : "on");
                  if(!(report_server_stat__1__18___retval >= 0))
                    return report_server_stat__1__18___retval;

                  else
                  {
                    signed int report_server_stat__1__19___retval;
                    report_server_stat__1__19___retval=fsprintf(f, "\tlean query: %s\n", st->lean_query != 0 ? "on" : "off");
                    if(!(report_server_stat__1__19___retval >= 0))
                      return report_server_stat__1__19___retval;

                    else
                    {
                      signed int report_server_stat__1__20___retval;
                      report_server_stat__1__20___retval=fsprintf(f, "\tUse EDNS in outgoing queries: %s\n", st->edns_query != 0 ? "on" : "off");
                      if(!(report_server_stat__1__20___retval >= 0))
                        return report_server_stat__1__20___retval;

                      else
                      {
                        signed int report_server_stat__1__21___retval;
                        report_server_stat__1__21___retval=fsprintf(f, "\tUse only proxy?: %s\n", st->is_proxy != 0 ? "on" : "off");
                        if(!(report_server_stat__1__21___retval >= 0))
                          return report_server_stat__1__21___retval;

                        else
                        {
                          signed int report_server_stat__1__22___retval;
                          char *tmp_if_expr_12;
                          if(!(st->rootserver == 0))
                            tmp_if_expr_12 = (signed int)st->rootserver == 1 ? "yes" : "discover";

                          else
                            tmp_if_expr_12 = "no";
                          report_server_stat__1__22___retval=fsprintf(f, "\tAssumed root server: %s\n", tmp_if_expr_12);
                          if(!(report_server_stat__1__22___retval >= 0))
                            return report_server_stat__1__22___retval;

                          else
                          {
                            signed int report_server_stat__1__23___retval;
                            report_server_stat__1__23___retval=fsprintf(f, "\tRandomize server query order: %s\n", st->rand_servers != 0 ? "yes" : "no");
                            if(!(report_server_stat__1__23___retval >= 0))
                              return report_server_stat__1__23___retval;

                            else
                            {
                              signed int report_server_stat__1__24___retval;
                              const char *return_value_const_name_13;
                              return_value_const_name_13=const_name((signed int)st->policy);
                              report_server_stat__1__24___retval=fsprintf(f, "\tDefault policy: %s\n", return_value_const_name_13);
                              if(!(report_server_stat__1__24___retval >= 0))
                                return report_server_stat__1__24___retval;

                              else
                              {
                                signed int report_server_stat__1__25___retval;
                                report_server_stat__1__25___retval=fsprintf(f, "\tPolicies:%s\n", st->alist != ((struct anonymous_8 *)NULL) ? "" : " (none)");
                                if(!(report_server_stat__1__25___retval >= 0))
                                  return report_server_stat__1__25___retval;

                                else
                                {
                                  j = 0;
                                  do
                                  {
                                    return_value_da_nel_14=da_nel_link1((struct anonymous_3 *)st->alist);
                                    if((unsigned int)j >= return_value_da_nel_14)
                                      break;

                                    struct anonymous_9 *sl = &st->alist->elem[(signed long int)j];
                                    unsigned char report_server_stat__1__26__1__buf[256l];
                                    signed int report_server_stat__1__26__1__1___retval;
                                    const unsigned char *return_value_rhn2str_15;
                                    return_value_rhn2str_15=rhn2str(sl->domain, report_server_stat__1__26__1__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                                    report_server_stat__1__26__1__1___retval=fsprintf(f, "\t\t%s: %s%s\n", (signed int)sl->rule == 18 ? "include" : "exclude", sl->exact != 0 ? "" : ".", return_value_rhn2str_15);
                                    if(!(report_server_stat__1__26__1__1___retval >= 0))
                                      return report_server_stat__1__26__1__1___retval;

                                    j = j + 1;
                                  }
                                  while((_Bool)1);
                                  _Bool tmp_if_expr_23;
                                  if(!(st->reject_a4 == ((struct anonymous_10 *)NULL)))
                                    tmp_if_expr_23 = (_Bool)1;

                                  else
                                    tmp_if_expr_23 = st->reject_a6 != (struct anonymous_12 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                                  if(tmp_if_expr_23)
                                  {
                                    signed int report_server_stat__1__27__1___retval;
                                    report_server_stat__1__27__1___retval=fsprintf(f, "\tAddresses which should be rejected in replies:\n");
                                    if(!(report_server_stat__1__27__1___retval >= 0))
                                      return report_server_stat__1__27__1___retval;

                                    unsigned int return_value_da_nel_16;
                                    return_value_da_nel_16=da_nel_link1((struct anonymous_3 *)st->reject_a4);
                                    m = (signed int)return_value_da_nel_16;
                                    j = 0;
                                    for( ; !(j >= m); j = j + 1)
                                    {
                                      struct anonymous_11 *am = &st->reject_a4->elem[(signed long int)j];
                                      char abuf[46l];
                                      char mbuf[46l];
                                      signed int _retval;
                                      const char *return_value_inet_ntop_17;
                                      return_value_inet_ntop_17=inet_ntop(2, (const void *)&am->a, abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      const char *return_value_inet_ntop_18;
                                      return_value_inet_ntop_18=inet_ntop(2, (const void *)&am->mask, mbuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      _retval=fsprintf(f, "\t\t%s/%s\n", return_value_inet_ntop_17, return_value_inet_ntop_18);
                                      if(!(_retval >= 0))
                                        return _retval;

                                    }
                                    unsigned int return_value_da_nel_19;
                                    return_value_da_nel_19=da_nel_link1((struct anonymous_3 *)st->reject_a6);
                                    m = (signed int)return_value_da_nel_19;
                                    j = 0;
                                    for( ; !(j >= m); j = j + 1)
                                    {
                                      struct anonymous_13 *report_server_stat__1__27__3__1__am = &st->reject_a6->elem[(signed long int)j];
                                      char report_server_stat__1__27__3__1__abuf[46l];
                                      char report_server_stat__1__27__3__1__mbuf[46l];
                                      signed int report_server_stat__1__27__3__1__1___retval;
                                      const char *return_value_inet_ntop_20;
                                      return_value_inet_ntop_20=inet_ntop(10, (const void *)&report_server_stat__1__27__3__1__am->a, report_server_stat__1__27__3__1__abuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      const char *return_value_inet_ntop_21;
                                      return_value_inet_ntop_21=inet_ntop(10, (const void *)&report_server_stat__1__27__3__1__am->mask, report_server_stat__1__27__3__1__mbuf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
                                      report_server_stat__1__27__3__1__1___retval=fsprintf(f, "\t\t%s/%s\n", return_value_inet_ntop_20, return_value_inet_ntop_21);
                                      if(!(report_server_stat__1__27__3__1__1___retval >= 0))
                                        return report_server_stat__1__27__3__1__1___retval;

                                    }
                                    signed int report_server_stat__1__27__4___retval;
                                    const char *return_value_const_name_22;
                                    return_value_const_name_22=const_name((signed int)st->rejectpolicy);
                                    report_server_stat__1__27__4___retval=fsprintf(f, "\tReject policy: %s\n", return_value_const_name_22);
                                    if(!(report_server_stat__1__27__4___retval >= 0))
                                      return report_server_stat__1__27__4___retval;

                                    signed int report_server_stat__1__27__5___retval;
                                    report_server_stat__1__27__5___retval=fsprintf(f, "\tReject recursively: %s\n", st->rejectrecursively != 0 ? "yes" : "no");
                                    if(!(report_server_stat__1__27__5___retval >= 0))
                                      return report_server_stat__1__27__5___retval;

                                  }

                                  return 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// report_thread_stat
// file dns_answer.c line 2141
signed int report_thread_stat(signed int f)
{
  unsigned long int nspawned;
  unsigned long int ndropped;
  signed int nactive;
  signed int ncurrent;
  signed int nqueued;
  pthread_mutex_lock(&proc_lock);
  nspawned = spawned;
  ndropped = dropped;
  nactive = procs;
  ncurrent = qprocs;
  nqueued = ncurrent - nactive;
  pthread_mutex_unlock(&proc_lock);
  signed int _retval;
  _retval=fsprintf(f, "\nThread status:\n==============\n");
  if(!(_retval >= 0))
    return _retval;

  else
  {
    signed int return_value_pthread_equal_1;
    return_value_pthread_equal_1=pthread_equal(servstat_thrid, main_thrid);
    if(return_value_pthread_equal_1 == 0)
    {
      signed int report_thread_stat__1__2___retval;
      report_thread_stat__1__2___retval=fsprintf(f, "server status thread is running.\n");
      if(!(report_thread_stat__1__2___retval >= 0))
        return report_thread_stat__1__2___retval;

    }

    signed int return_value_pthread_equal_2;
    return_value_pthread_equal_2=pthread_equal(statsock_thrid, main_thrid);
    if(return_value_pthread_equal_2 == 0)
    {
      signed int report_thread_stat__1__3___retval;
      report_thread_stat__1__3___retval=fsprintf(f, "pdnsd control thread is running.\n");
      if(!(report_thread_stat__1__3___retval >= 0))
        return report_thread_stat__1__3___retval;

    }

    signed int return_value_pthread_equal_3;
    return_value_pthread_equal_3=pthread_equal(tcps_thrid, main_thrid);
    if(return_value_pthread_equal_3 == 0)
    {
      signed int report_thread_stat__1__4___retval;
      report_thread_stat__1__4___retval=fsprintf(f, "tcp server thread is running.\n");
      if(!(report_thread_stat__1__4___retval >= 0))
        return report_thread_stat__1__4___retval;

    }

    signed int return_value_pthread_equal_4;
    return_value_pthread_equal_4=pthread_equal(udps_thrid, main_thrid);
    if(return_value_pthread_equal_4 == 0)
    {
      signed int report_thread_stat__1__5___retval;
      report_thread_stat__1__5___retval=fsprintf(f, "udp server thread is running.\n");
      if(!(report_thread_stat__1__5___retval >= 0))
        return report_thread_stat__1__5___retval;

    }

    signed int report_thread_stat__1__6___retval;
    report_thread_stat__1__6___retval=fsprintf(f, "%lu query threads spawned in total (%lu queries dropped).\n", nspawned, ndropped);
    if(!(report_thread_stat__1__6___retval >= 0))
      return report_thread_stat__1__6___retval;

    else
    {
      signed int report_thread_stat__1__7___retval;
      report_thread_stat__1__7___retval=fsprintf(f, "%i running query threads (%i active, %i queued).\n", ncurrent, nactive, nqueued);
      if(!(report_thread_stat__1__7___retval >= 0))
        return report_thread_stat__1__7___retval;

      else
        return 0;
    }
  }
}

// resolv_rootserver_addrs
// file servers.c line 289
static struct anonymous_14 * resolv_rootserver_addrs(struct anonymous_19 *a, signed int port, char edns_query, signed long int timeout)
{
  struct anonymous_14 *retval = (struct anonymous_14 *)(void *)0;
  server_data_users = server_data_users + 1;
  pthread_mutex_unlock(&servers_lock);
  retval=dns_rootserver_resolv(a, port, edns_query, timeout);
  pthread_mutex_lock(&servers_lock);
  if(!(server_data_users >= 1))
  {
    log_message(3, "%s:%d: %s", (const void *)"servers.c", 300, (const void *)"server_data_users non-positive before attempt to decrement it");
    pdnsd_exit();
  }

  server_data_users = server_data_users - 1;
  if(server_data_users == 0)
    pthread_cond_broadcast(&server_data_cond);

  return retval;
}

// retest
// file servers.c line 230
static void retest(signed int i, signed int j)
{
  signed long int s_ts;
  struct anonymous_7 *srv = &servers->elem[(signed long int)i];
  signed int nsrvs;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link5((struct anonymous_3 *)srv->atup_a);
  nsrvs = (signed int)return_value_da_nel_1;
  _Bool tmp_if_expr_4;
  signed int return_value_is_inaddr_any_3;
  if(!(nsrvs == 0))
  {
    if(j >= 0)
    {
      if(!(j >= nsrvs))
        nsrvs = j + 1;

    }

    else
      j = 0;
    signed int return_value_scheme_ok_6;
    return_value_scheme_ok_6=scheme_ok(srv);
    if(return_value_scheme_ok_6 == 0)
    {
      s_ts=time((signed long int *)(void *)0);
      for( ; !(j >= nsrvs); j = j + 1)
      {
        struct anonymous_20 *at = &srv->atup_a->elem[(signed long int)j];
        at->is_up = (char)0;
        at->i_ts = s_ts;
      }
    }

    else
      if((signed int)srv->uptest == 5)
      {
        s_ts=time((signed long int *)(void *)0);
        for( ; !(j >= nsrvs); j = j + 1)
          srv->atup_a->elem[(signed long int)j].i_ts = s_ts;
      }

      else
      {
        _Bool tmp_if_expr_5;
        if((signed int)srv->uptest == 9)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          if((signed int)srv->uptest == 8)
          {
            return_value_is_inaddr_any_3=is_inaddr_any_link2(&srv->ping_a);
            tmp_if_expr_4 = return_value_is_inaddr_any_3 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_4 = (_Bool)0;
          tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          for( ; !(j >= nsrvs); j = j + 1)
          {
            struct anonymous_20 *retest__1__5__1__1__at = &srv->atup_a->elem[(signed long int)j];
            s_ts=time((signed long int *)(void *)0);
            signed int return_value_uptest_2;
            return_value_uptest_2=uptest(srv, j);
            retest__1__5__1__1__at->is_up = (char)return_value_uptest_2;
            if(!(signal_interrupt == 0))
              break;

            retest__1__5__1__1__at->i_ts = s_ts;
          }

        else
        {
          signed int res;
          s_ts=time((signed long int *)(void *)0);
          res=uptest(srv, j);
          for( ; !(j >= nsrvs); j = j + 1)
          {
            struct anonymous_20 *retest__1__6__1__1__at = &srv->atup_a->elem[(signed long int)j];
            retest__1__6__1__1__at->is_up = (char)res;
            if(!(signal_interrupt == 0))
            {
              if(!((signed int)srv->uptest == 8))
                goto __CPROVER_DUMP_L20;

            }

            else
            {

            __CPROVER_DUMP_L20:
              ;
              retest__1__6__1__1__at->i_ts = s_ts;
            }
          }
        }
      }
  }

}

// rhn2str
// file helpers.h line 52
const unsigned char * rhn2str(const unsigned char *rhn, unsigned char *str, unsigned int size)
{
  unsigned int i;
  unsigned int j;
  unsigned int lb;
  if(size == 0u)
    return (const unsigned char *)(void *)0;

  else
  {
    i = (unsigned int)0;
    j = (unsigned int)0;
    unsigned int tmp_post_1 = i;
    i = i + 1u;
    lb = (unsigned int)rhn[(signed long int)tmp_post_1];
    if(lb == 0u)
    {
      if(size >= 2u)
      {
        unsigned int tmp_post_2 = j;
        j = j + 1u;
        str[(signed long int)tmp_post_2] = (unsigned char)46;
      }

    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      while((_Bool)1)
      {
        if(!(lb == 0u))
        {
          unsigned char c;
          if(2u + j >= size)
            goto overflow;

          unsigned int tmp_post_3 = i;
          i = i + 1u;
          c = rhn[(signed long int)tmp_post_3];
          const unsigned short int **return_value___ctype_b_loc_7;
          return_value___ctype_b_loc_7=__ctype_b_loc();
          if(!((32768 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)c]) == 0))
          {
            if((signed int)c == 34 || (signed int)c == 46 || (signed int)c == 92)
            {
              unsigned int tmp_post_4 = j;
              j = j + 1u;
              str[(signed long int)tmp_post_4] = (unsigned char)92;
              if(2u + j >= size)
                goto overflow;

            }

            unsigned int tmp_post_5 = j;
            j = j + 1u;
            str[(signed long int)tmp_post_5] = c;
          }

          else
          {
            unsigned int rem = (size - (unsigned int)1) - j;
            signed int n;
            n=snprintf((char *)&str[(signed long int)j], (unsigned long int)rem, "\\%03o", c);
            if((unsigned int)n >= rem || !(n >= 0))
            {
              unsigned int tmp_post_6 = j;
              j = j + 1u;
              str[(signed long int)tmp_post_6] = (unsigned char)46;
              goto overflow;
            }

            j = j + (unsigned int)n;
          }
          lb = lb - 1u;
          goto __CPROVER_DUMP_L3;
        }

        unsigned int tmp_post_8 = j;
        j = j + 1u;
        str[(signed long int)tmp_post_8] = (unsigned char)46;
        unsigned int tmp_post_9 = i;
        i = i + 1u;
        lb = (unsigned int)rhn[(signed long int)tmp_post_9];
        if(lb == 0u)
          break;

      }
    }
    str[(signed long int)j] = (unsigned char)0;
    return str;

  overflow:
    ;
    j = size;
    j = j - 1u;
    str[(signed long int)j] = (unsigned char)0;
    if(j >= 1u)
    {
      j = j - 1u;
      str[(signed long int)j] = (unsigned char)46;
      if(j >= 1u)
      {
        j = j - 1u;
        str[(signed long int)j] = (unsigned char)46;
        if(j >= 1u)
        {
          j = j - 1u;
          str[(signed long int)j] = (unsigned char)46;
        }

      }

    }

    return str;
  }
}

// rhncpy
// file helpers.h line 111
unsigned int rhncpy(unsigned char *dst, const unsigned char *src)
{
  unsigned int len;
  len=rhnlen_link4(src);
  if(len >= 257u)
  {
    log_message(3, "%s:%d: %s", (const void *)"helpers.c", 359, (const void *)"rhncpy: src too long!");
    pdnsd_exit();
  }

  memcpy((void *)dst, (const void *)src, (unsigned long int)(len > (unsigned int)256 ? (unsigned int)256 : len));
  return len;
}

// rhnicmp
// file helpers.h line 214
static inline signed int rhnicmp(const unsigned char *a, const unsigned char *b)
{
  unsigned int i = (unsigned int)0;
  unsigned char lb;
  do
  {
    lb = a[(signed long int)i];
    if(!(lb == b[(signed long int)i]))
      return 0;

    if(lb == 0)
      break;

    i = i + 1u;
    do
    {
      signed int return_value_tolower_1;
      return_value_tolower_1=tolower((signed int)a[(signed long int)i]);
      signed int return_value_tolower_2;
      return_value_tolower_2=tolower((signed int)b[(signed long int)i]);
      if(!(return_value_tolower_1 == return_value_tolower_2))
        return 0;

      i = i + 1u;
      lb = lb - 1;
    }
    while(!(lb == 0));
  }
  while((_Bool)1);
  return 1;
}

// rhnicmp_link1
// file helpers.h line 214
static inline signed int rhnicmp_link1(const unsigned char *a_link1, const unsigned char *b_link1)
{
  unsigned int i_link1 = (unsigned int)0;
  unsigned char lb_link1;
  do
  {
    lb_link1 = a_link1[(signed long int)i_link1];
    if(!(lb_link1 == b_link1[(signed long int)i_link1]))
      return 0;

    if(lb_link1 == 0)
      break;

    i_link1 = i_link1 + 1u;
    do
    {
      signed int return_value_tolower_1_link1;
      return_value_tolower_1_link1=tolower((signed int)a_link1[(signed long int)i_link1]);
      signed int return_value_tolower_2_link1;
      return_value_tolower_2_link1=tolower((signed int)b_link1[(signed long int)i_link1]);
      if(!(return_value_tolower_1_link1 == return_value_tolower_2_link1))
        return 0;

      i_link1 = i_link1 + 1u;
      lb_link1 = lb_link1 - 1;
    }
    while(!(lb_link1 == 0));
  }
  while((_Bool)1);
  return 1;
}

// rhnicmp_link2
// file helpers.h line 214
static inline signed int rhnicmp_link2(const unsigned char *a_link2, const unsigned char *b_link2)
{
  unsigned int i_link2 = (unsigned int)0;
  unsigned char lb_link2;
  do
  {
    lb_link2 = a_link2[(signed long int)i_link2];
    if(!(lb_link2 == b_link2[(signed long int)i_link2]))
      return 0;

    if(lb_link2 == 0)
      break;

    i_link2 = i_link2 + 1u;
    do
    {
      signed int return_value_tolower_1_link2;
      return_value_tolower_1_link2=tolower((signed int)a_link2[(signed long int)i_link2]);
      signed int return_value_tolower_2_link2;
      return_value_tolower_2_link2=tolower((signed int)b_link2[(signed long int)i_link2]);
      if(!(return_value_tolower_1_link2 == return_value_tolower_2_link2))
        return 0;

      i_link2 = i_link2 + 1u;
      lb_link2 = lb_link2 - 1;
    }
    while(!(lb_link2 == 0));
  }
  while((_Bool)1);
  return 1;
}

// rhnlen
// file helpers.h line 62
static inline unsigned int rhnlen(const unsigned char *rhn)
{
  unsigned int i = (unsigned int)0;
  unsigned int lb;
  unsigned int tmp_post_1;
  do
  {
    tmp_post_1 = i;
    i = i + 1u;
    lb = (unsigned int)rhn[(signed long int)tmp_post_1];
    if(lb == 0u)
      break;

    i = i + lb;
  }
  while((_Bool)1);
  return i;
}

// rhnlen_link1
// file helpers.h line 62
static inline unsigned int rhnlen_link1(const unsigned char *rhn_link1)
{
  unsigned int i_link1 = (unsigned int)0;
  unsigned int lb_link1;
  unsigned int tmp_post_1_link1;
  do
  {
    tmp_post_1_link1 = i_link1;
    i_link1 = i_link1 + 1u;
    lb_link1 = (unsigned int)rhn_link1[(signed long int)tmp_post_1_link1];
    if(lb_link1 == 0u)
      break;

    i_link1 = i_link1 + lb_link1;
  }
  while((_Bool)1);
  return i_link1;
}

// rhnlen_link2
// file helpers.h line 62
static inline unsigned int rhnlen_link2(const unsigned char *rhn_link2)
{
  unsigned int i_link2 = (unsigned int)0;
  unsigned int lb_link2;
  unsigned int tmp_post_1_link2;
  do
  {
    tmp_post_1_link2 = i_link2;
    i_link2 = i_link2 + 1u;
    lb_link2 = (unsigned int)rhn_link2[(signed long int)tmp_post_1_link2];
    if(lb_link2 == 0u)
      break;

    i_link2 = i_link2 + lb_link2;
  }
  while((_Bool)1);
  return i_link2;
}

// rhnlen_link3
// file helpers.h line 62
static inline unsigned int rhnlen_link3(const unsigned char *rhn_link3)
{
  unsigned int i_link3 = (unsigned int)0;
  unsigned int lb_link3;
  unsigned int tmp_post_1_link3;
  do
  {
    tmp_post_1_link3 = i_link3;
    i_link3 = i_link3 + 1u;
    lb_link3 = (unsigned int)rhn_link3[(signed long int)tmp_post_1_link3];
    if(lb_link3 == 0u)
      break;

    i_link3 = i_link3 + lb_link3;
  }
  while((_Bool)1);
  return i_link3;
}

// rhnlen_link4
// file helpers.h line 62
static inline unsigned int rhnlen_link4(const unsigned char *rhn_link4)
{
  unsigned int i_link4 = (unsigned int)0;
  unsigned int lb_link4;
  unsigned int tmp_post_1_link4;
  do
  {
    tmp_post_1_link4 = i_link4;
    i_link4 = i_link4 + 1u;
    lb_link4 = (unsigned int)rhn_link4[(signed long int)tmp_post_1_link4];
    if(lb_link4 == 0u)
      break;

    i_link4 = i_link4 + lb_link4;
  }
  while((_Bool)1);
  return i_link4;
}

// rhnlen_link5
// file helpers.h line 62
static inline unsigned int rhnlen_link5(const unsigned char *rhn_link5)
{
  unsigned int i_link5 = (unsigned int)0;
  unsigned int lb_link5;
  unsigned int tmp_post_1_link5;
  do
  {
    tmp_post_1_link5 = i_link5;
    i_link5 = i_link5 + 1u;
    lb_link5 = (unsigned int)rhn_link5[(signed long int)tmp_post_1_link5];
    if(lb_link5 == 0u)
      break;

    i_link5 = i_link5 + lb_link5;
  }
  while((_Bool)1);
  return i_link5;
}

// rhnlen_link6
// file helpers.h line 62
static inline unsigned int rhnlen_link6(const unsigned char *rhn_link6)
{
  unsigned int i_link6 = (unsigned int)0;
  unsigned int lb_link6;
  unsigned int tmp_post_1_link6;
  do
  {
    tmp_post_1_link6 = i_link6;
    i_link6 = i_link6 + 1u;
    lb_link6 = (unsigned int)rhn_link6[(signed long int)tmp_post_1_link6];
    if(lb_link6 == 0u)
      break;

    i_link6 = i_link6 + lb_link6;
  }
  while((_Bool)1);
  return i_link6;
}

// rhnsegcnt
// file helpers.h line 100
static inline unsigned int rhnsegcnt(const unsigned char *rhn)
{
  unsigned int res = (unsigned int)0;
  unsigned int lb;
  do
  {
    lb = (unsigned int)*rhn;
    if(lb == 0u)
      break;

    res = res + 1u;
    rhn = rhn + (signed long int)(lb + (unsigned int)1);
  }
  while((_Bool)1);
  return res;
}

// rhnsegcnt_link1
// file helpers.h line 100
static inline unsigned int rhnsegcnt_link1(const unsigned char *rhn_link1)
{
  unsigned int res_link1 = (unsigned int)0;
  unsigned int lb_link1;
  do
  {
    lb_link1 = (unsigned int)*rhn_link1;
    if(lb_link1 == 0u)
      break;

    res_link1 = res_link1 + 1u;
    rhn_link1 = rhn_link1 + (signed long int)(lb_link1 + (unsigned int)1);
  }
  while((_Bool)1);
  return res_link1;
}

// rhnsegcnt_link2
// file helpers.h line 100
static inline unsigned int rhnsegcnt_link2(const unsigned char *rhn_link2)
{
  unsigned int res_link2 = (unsigned int)0;
  unsigned int lb_link2;
  do
  {
    lb_link2 = (unsigned int)*rhn_link2;
    if(lb_link2 == 0u)
      break;

    res_link2 = res_link2 + 1u;
    rhn_link2 = rhn_link2 + (signed long int)(lb_link2 + (unsigned int)1);
  }
  while((_Bool)1);
  return res_link2;
}

// rr_to_cache
// file dns_query.c line 183
static signed int rr_to_cache(struct anonymous_16 **centa, unsigned char *oname, signed int tp, signed long int ttl, unsigned int dlen, void *data, unsigned int flags, signed long int queryts)
{
  signed int i;
  signed int n;
  struct anonymous_0 *cent;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link2((struct anonymous_3 *)*centa);
  n = (signed int)return_value_da_nel_1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    cent = &(*centa)->elem[(signed long int)i];
    signed int return_value_rhnicmp_3;
    return_value_rhnicmp_3=rhnicmp_link1(cent->qname, oname);
    if(!(return_value_rhnicmp_3 == 0))
    {
      signed int retval = 0;
      signed int return_value_add_cent_rr_2;
      return_value_add_cent_rr_2=add_cent_rr(cent, tp, ttl, queryts, flags, dlen, data);
      return return_value_add_cent_rr_2 != 0 ? retval : 0xffff;
    }

  }
  struct anonymous_3 *return_value_da_grow1_4;
  return_value_da_grow1_4=da_grow1((struct anonymous_3 *)*centa, (unsigned long int)((struct anonymous_16 *)0)->elem, sizeof(struct anonymous_0) /*104ul*/ , free_cent0);
  *centa = (struct anonymous_16 *)return_value_da_grow1_4;
  if(*centa == ((struct anonymous_16 *)NULL))
    return 0xffff;

  else
  {
    cent = &(*centa)->elem[(signed long int)((*centa)->nel - (unsigned long int)1)];
    signed int return_value_init_cent_6;
    return_value_init_cent_6=init_cent(cent, oname, (signed long int)0, (signed long int)0, (unsigned int)0);
    if(return_value_init_cent_6 == 0)
    {
      struct anonymous_3 *return_value_da_resize_5;
      return_value_da_resize_5=da_resize((struct anonymous_3 *)*centa, (unsigned long int)((struct anonymous_16 *)0)->elem, sizeof(struct anonymous_0) /*104ul*/ , (unsigned long int)n, (void (*)(void *))(void *)0);
      *centa = (struct anonymous_16 *)return_value_da_resize_5;
      return 0xffff;
    }

    signed int return_value_add_cent_rr_7;
    return_value_add_cent_rr_7=add_cent_rr(cent, tp, ttl, queryts, flags, dlen, data);
    return return_value_add_cent_rr_7 != 0 ? 0 : 0xffff;
  }
}

// rr_tp_byname
// file rr_types.h line 533
signed int rr_tp_byname(char *name)
{
  signed int i = 0;
  for( ; !(i >= 51); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(name, rrnames[(signed long int)i]);
    if(return_value_strcmp_1 == 0)
      return i + 1;

  }
  return -1;
}

// rrs2cent
// file dns_query.c line 229
static signed int rrs2cent(unsigned char *msg, unsigned long int msgsz, unsigned char **ptr, unsigned long int *lcnt, signed int recnum, unsigned int flags, signed long int queryts, struct anonymous_16 **centa, signed int *numopt, struct anonymous_17 *ep)
{
  signed int rc;
  signed int retval = 0;
  signed int i;
  unsigned short int type;
  unsigned short int class;
  unsigned int ttl;
  unsigned short int rdlength;
  i = 0;
  signed int return_value_isnormalencdomname_12;
  const char *return_value_getrrtpname_16;
  signed int return_value_isnormalencdomname_17;
  signed int return_value_isnormalencdomname_21;
  const char *return_value_getrrtpname_24;
  for( ; !(i >= recnum); i = i + 1)
  {
    unsigned char oname[256l];
    unsigned char *ttlp;
    unsigned int len;
    rc=decompress_name(msg, msgsz, ptr, lcnt, oname, &len);
    if(!(rc == 0))
      return rc;

    if(!(*lcnt >= 10ul))
      return 0xfffe;

    *lcnt = *lcnt - (unsigned long int)10;
    do
    {
      unsigned short int t_s;
      const unsigned char *t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post_1 = t_cp;
      t_cp = t_cp + 1l;
      t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_1 << 8);
      const unsigned char *tmp_post_2 = t_cp;
      t_cp = t_cp + 1l;
      t_s = t_s | (unsigned short int)*tmp_post_2;
      type = t_s;
      *ptr = (unsigned char *)(void *)t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int rrs2cent__1__1__1__4__t_s;
      const unsigned char *rrs2cent__1__1__1__4__t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post_3 = rrs2cent__1__1__1__4__t_cp;
      rrs2cent__1__1__1__4__t_cp = rrs2cent__1__1__1__4__t_cp + 1l;
      rrs2cent__1__1__1__4__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_3 << 8);
      const unsigned char *tmp_post_4 = rrs2cent__1__1__1__4__t_cp;
      rrs2cent__1__1__1__4__t_cp = rrs2cent__1__1__1__4__t_cp + 1l;
      rrs2cent__1__1__1__4__t_s = rrs2cent__1__1__1__4__t_s | (unsigned short int)*tmp_post_4;
      class = rrs2cent__1__1__1__4__t_s;
      *ptr = (unsigned char *)(void *)rrs2cent__1__1__1__4__t_cp;
    }
    while((_Bool)0);
    ttlp = *ptr;
    do
    {
      unsigned int t_l;
      const unsigned char *rrs2cent__1__1__1__5__t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post_5 = rrs2cent__1__1__1__5__t_cp;
      rrs2cent__1__1__1__5__t_cp = rrs2cent__1__1__1__5__t_cp + 1l;
      t_l = (unsigned int)*tmp_post_5 << 24;
      const unsigned char *tmp_post_6 = rrs2cent__1__1__1__5__t_cp;
      rrs2cent__1__1__1__5__t_cp = rrs2cent__1__1__1__5__t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post_6 << 16;
      const unsigned char *tmp_post_7 = rrs2cent__1__1__1__5__t_cp;
      rrs2cent__1__1__1__5__t_cp = rrs2cent__1__1__1__5__t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post_7 << 8;
      const unsigned char *tmp_post_8 = rrs2cent__1__1__1__5__t_cp;
      rrs2cent__1__1__1__5__t_cp = rrs2cent__1__1__1__5__t_cp + 1l;
      t_l = t_l | (unsigned int)*tmp_post_8;
      ttl = t_l;
      *ptr = (unsigned char *)(void *)rrs2cent__1__1__1__5__t_cp;
    }
    while((_Bool)0);
    do
    {
      unsigned short int rrs2cent__1__1__1__6__t_s;
      const unsigned char *rrs2cent__1__1__1__6__t_cp = (const unsigned char *)*ptr;
      const unsigned char *tmp_post_9 = rrs2cent__1__1__1__6__t_cp;
      rrs2cent__1__1__1__6__t_cp = rrs2cent__1__1__1__6__t_cp + 1l;
      rrs2cent__1__1__1__6__t_s = (unsigned short int)((signed int)(unsigned short int)*tmp_post_9 << 8);
      const unsigned char *tmp_post_10 = rrs2cent__1__1__1__6__t_cp;
      rrs2cent__1__1__1__6__t_cp = rrs2cent__1__1__1__6__t_cp + 1l;
      rrs2cent__1__1__1__6__t_s = rrs2cent__1__1__1__6__t_s | (unsigned short int)*tmp_post_10;
      rdlength = rrs2cent__1__1__1__6__t_s;
      *ptr = (unsigned char *)(void *)rrs2cent__1__1__1__6__t_cp;
    }
    while((_Bool)0);
    if(!(*lcnt >= (unsigned long int)rdlength))
      return 0xfffe;

    if((signed int)type == 41)
    {
      signed int tmp_post_11 = *numopt;
      *numopt = *numopt + 1;
      if(tmp_post_11 == 0)
      {
        if(!((signed int)oname[0l] == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "rrs2cent: name in OPT record not empty!\n");

        }

        ep->udpsize = class;
        ep->rcode = (unsigned short int)((signed int)(unsigned short int)ttlp[(signed long int)0] << 4 | (signed int)((struct anonymous_29 *)msg)->rcode);
        ep->version = (unsigned short int)ttlp[(signed long int)1];
        ep->do_flg = (unsigned char)((signed int)ttlp[(signed long int)2] >> 7 & 1);
        if(!(debug_p == 0))
        {
          unsigned int Zflags = (unsigned int)((signed int)(unsigned short int)ttlp[(signed long int)2] << 8 | (signed int)ttlp[(signed long int)3]);
          if(!((32767u & Zflags) == 0u))
          {
            if(!(debug_p == 0))
              debug_msg(0, "rrs2cent: Z field contains unknown nonzero bits (%04x).\n", Zflags);

          }

        }

        if(!(rdlength == 0))
        {
          if(!(debug_p == 0))
            debug_msg(0, "rrs2cent: RDATA field in OPT record not empty!\n");

        }

      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "rrs2cent: ingnoring surplus OPT record.\n");

    }

    else
    {
      _Bool tmp_if_expr_25;
      if((signed int)type >= 52 || !((signed int)type >= 1))
        tmp_if_expr_25 = (_Bool)1;

      else
        tmp_if_expr_25 = (signed int)rrlkuptab[(signed long int)((signed int)type - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
      if((signed int)class == 1 && !tmp_if_expr_25)
      {
        unsigned long int blcnt = (unsigned long int)rdlength;
        unsigned char *bptr = *ptr;
        unsigned char *nptr;
        unsigned int slen;
        switch((signed int)type)
        {
          case 1:
          {
            if(!((signed int)rdlength == 4))
              goto invalid_length;

            goto default_case;
          }
          case 5:

          case 7:

          case 3:

          case 4:

          case 8:

          case 9:

          case 2:

          case 12:
          {
            unsigned char db[256l];
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, db, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, len, (void *)db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 14:

          case 17:
          {
            unsigned char rrs2cent__1__1__1__9__1__2__db[512l];
            nptr = rrs2cent__1__1__1__9__1__2__db;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__2__db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 15:

          case 18:

          case 21:

          case 36:
          {
            unsigned char rrs2cent__1__1__1__9__1__3__db[258l];
            if(!(blcnt >= 2ul))
              goto record_too_short;

            memcpy((void *)rrs2cent__1__1__1__9__1__3__db, (const void *)bptr, (unsigned long int)2);
            blcnt = blcnt - (unsigned long int)2;
            bptr = bptr + (signed long int)2;
            nptr = rrs2cent__1__1__1__9__1__3__db + (signed long int)2;
            slen = (unsigned int)2;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__3__db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 6:
          {
            unsigned char rrs2cent__1__1__1__9__1__4__db[532l];
            nptr = rrs2cent__1__1__1__9__1__4__db;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = slen + len;
            if(!(blcnt >= 20ul))
              goto record_too_short;

            memcpy((void *)nptr, (const void *)bptr, (unsigned long int)20);
            blcnt = blcnt - (unsigned long int)20;
            slen = slen + (unsigned int)20;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__4__db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 28:
          {
            if(!((signed int)rdlength == 16))
              goto invalid_length;

            goto default_case;
          }
          case 26:
          {
            unsigned char rrs2cent__1__1__1__9__1__5__db[514l];
            if(!(blcnt >= 2ul))
              goto record_too_short;

            memcpy((void *)rrs2cent__1__1__1__9__1__5__db, (const void *)bptr, (unsigned long int)2);
            blcnt = blcnt - (unsigned long int)2;
            bptr = bptr + (signed long int)2;
            nptr = rrs2cent__1__1__1__9__1__5__db + (signed long int)2;
            slen = (unsigned int)2;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = slen + len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__5__db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 33:
          {
            unsigned char rrs2cent__1__1__1__9__1__6__db[262l];
            if(!(blcnt >= 6ul))
              goto record_too_short;

            memcpy((void *)rrs2cent__1__1__1__9__1__6__db, (const void *)bptr, (unsigned long int)6);
            blcnt = blcnt - (unsigned long int)6;
            bptr = bptr + (signed long int)6;
            nptr = rrs2cent__1__1__1__9__1__6__db + (signed long int)6;
            slen = (unsigned int)6;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__6__db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 30:
          {
            unsigned char rrs2cent__1__1__1__9__1__7__db[1040l];
            nptr = rrs2cent__1__1__1__9__1__7__db;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            nptr = nptr + (signed long int)len;
            slen = (unsigned int)((unsigned long int)len + blcnt);
            if((unsigned long int)slen >= 1041ul)
              goto buffer_overflow;

            memcpy((void *)nptr, (const void *)bptr, blcnt);
            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__7__db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 35:
          {
            signed int j;
            unsigned char rrs2cent__1__1__1__9__1__8__db[1028l];
            nptr = rrs2cent__1__1__1__9__1__8__db;
            len = (unsigned int)4;
            j = 0;
            for( ; !(j >= 3); j = j + 1)
            {
              if((unsigned long int)len >= blcnt)
                goto record_too_short;

              len = len + (unsigned int)bptr[(signed long int)len] + (unsigned int)1;
            }
            if(!(blcnt >= (unsigned long int)len))
              goto record_too_short;

            memcpy((void *)nptr, (const void *)bptr, (unsigned long int)len);
            blcnt = blcnt - (unsigned long int)len;
            bptr = bptr + (signed long int)len;
            nptr = nptr + (signed long int)len;
            slen = len;
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, nptr, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = slen + len;
            if(!(blcnt == 0ul))
              goto trailing_junk;

            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__8__db, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 45:
          {
            unsigned int gwtp;
            if(!(blcnt >= 3ul))
              goto record_too_short;

            gwtp = (unsigned int)bptr[(signed long int)1];
            blcnt = blcnt - (unsigned long int)3;
            bptr = bptr + (signed long int)3;
            switch(gwtp)
            {
              case (unsigned int)0:
                goto default_case;
              case (unsigned int)1:
              {
                if(!(blcnt >= 4ul))
                  goto record_too_short;

                goto default_case;
              }
              case (unsigned int)2:
              {
                if(!(blcnt >= 16ul))
                  goto record_too_short;

                goto default_case;
              }
              case (unsigned int)3:
              {
                return_value_isnormalencdomname_12=isnormalencdomname(bptr, (unsigned int)blcnt);
                if(!(return_value_isnormalencdomname_12 == 0))
                  goto default_case;

                unsigned char *rbuf;
                unsigned char nmbuf[256l];
                rc=decompress_name(msg, msgsz, &bptr, &blcnt, nmbuf, &len);
                if(!(rc == 0))
                  return rc == 0xfffe ? 1 : rc;

                slen = (unsigned int)((unsigned long int)((unsigned int)3 + len) + blcnt);
                void *return_value_malloc_13;
                return_value_malloc_13=malloc((unsigned long int)slen);
                rbuf = (unsigned char *)return_value_malloc_13;
                if(rbuf == ((unsigned char *)NULL))
                  return 0xffff;

                void *return_value_mempcpy_14;
                return_value_mempcpy_14=mempcpy((void *)rbuf, (const void *)*ptr, (unsigned long int)3);
                nptr = (unsigned char *)return_value_mempcpy_14;
                void *return_value_mempcpy_15;
                return_value_mempcpy_15=mempcpy((void *)nptr, (const void *)nmbuf, (unsigned long int)len);
                nptr = (unsigned char *)return_value_mempcpy_15;
                memcpy((void *)nptr, (const void *)bptr, blcnt);
                rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rbuf, flags, queryts);
                free((void *)rbuf);
                if(!(rc == 0))
                {
                  if(rc == 0xffff)
                    return rc;

                  retval = rc;
                }

                break;
              }
              default:
              {
                if(!(debug_p == 0))
                {
                  return_value_getrrtpname_16=getrrtpname((signed int)type);
                  debug_msg(0, "rrs2cent: %s record contains unsupported gateway type (%u).\n", return_value_getrrtpname_16, gwtp);
                }

                return 1;
              }
            }
            break;
          }
          case 46:
          {
            if(!(blcnt >= 18ul))
              goto record_too_short;

            blcnt = blcnt - (unsigned long int)18;
            bptr = bptr + (signed long int)18;
            return_value_isnormalencdomname_17=isnormalencdomname(bptr, (unsigned int)blcnt);
            if(!(return_value_isnormalencdomname_17 == 0))
              goto default_case;

            unsigned char *rrs2cent__1__1__1__9__1__10__rbuf;
            unsigned char rrs2cent__1__1__1__9__1__10__nmbuf[256l];
            rc=decompress_name(msg, msgsz, &bptr, &blcnt, rrs2cent__1__1__1__9__1__10__nmbuf, &len);
            if(!(rc == 0))
              return rc == 0xfffe ? 1 : rc;

            slen = (unsigned int)((unsigned long int)((unsigned int)18 + len) + blcnt);
            void *return_value_malloc_18;
            return_value_malloc_18=malloc((unsigned long int)slen);
            rrs2cent__1__1__1__9__1__10__rbuf = (unsigned char *)return_value_malloc_18;
            if(rrs2cent__1__1__1__9__1__10__rbuf == ((unsigned char *)NULL))
              return 0xffff;

            void *return_value_mempcpy_19;
            return_value_mempcpy_19=mempcpy((void *)rrs2cent__1__1__1__9__1__10__rbuf, (const void *)*ptr, (unsigned long int)18);
            nptr = (unsigned char *)return_value_mempcpy_19;
            void *return_value_mempcpy_20;
            return_value_mempcpy_20=mempcpy((void *)nptr, (const void *)rrs2cent__1__1__1__9__1__10__nmbuf, (unsigned long int)len);
            nptr = (unsigned char *)return_value_mempcpy_20;
            memcpy((void *)nptr, (const void *)bptr, blcnt);
            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__10__rbuf, flags, queryts);
            free((void *)rrs2cent__1__1__1__9__1__10__rbuf);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

            break;
          }
          case 47:
          {
            return_value_isnormalencdomname_21=isnormalencdomname(bptr, (unsigned int)blcnt);
            if(return_value_isnormalencdomname_21 == 0)
            {
              unsigned char *rrs2cent__1__1__1__9__1__11__rbuf;
              unsigned char rrs2cent__1__1__1__9__1__11__nmbuf[256l];
              rc=decompress_name(msg, msgsz, &bptr, &blcnt, rrs2cent__1__1__1__9__1__11__nmbuf, &len);
              if(!(rc == 0))
                return rc == 0xfffe ? 1 : rc;

              slen = (unsigned int)((unsigned long int)len + blcnt);
              void *return_value_malloc_22;
              return_value_malloc_22=malloc((unsigned long int)slen);
              rrs2cent__1__1__1__9__1__11__rbuf = (unsigned char *)return_value_malloc_22;
              if(rrs2cent__1__1__1__9__1__11__rbuf == ((unsigned char *)NULL))
                return 0xffff;

              void *return_value_mempcpy_23;
              return_value_mempcpy_23=mempcpy((void *)rrs2cent__1__1__1__9__1__11__rbuf, (const void *)rrs2cent__1__1__1__9__1__11__nmbuf, (unsigned long int)len);
              nptr = (unsigned char *)return_value_mempcpy_23;
              memcpy((void *)nptr, (const void *)bptr, blcnt);
              rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, slen, (void *)rrs2cent__1__1__1__9__1__11__rbuf, flags, queryts);
              free((void *)rrs2cent__1__1__1__9__1__11__rbuf);
              if(!(rc == 0))
              {
                if(rc == 0xffff)
                  return rc;

                retval = rc;
              }

              break;
            }

          }
          default:
          {

          default_case:
            ;
            rc=rr_to_cache(centa, oname, (signed int)type, (signed long int)ttl, (unsigned int)rdlength, (void *)*ptr, flags, queryts);
            if(!(rc == 0))
            {
              if(rc == 0xffff)
                return rc;

              retval = rc;
            }

          }
        }
      }

      else
        if(!(debug_p == 0))
        {
          return_value_getrrtpname_24=getrrtpname((signed int)type);
          debug_msg(0, "rrs2cent: ignoring record of type %s (%d), class %s (%d).\n", return_value_getrrtpname_24, type, (signed int)class == 1 ? "IN" : "[unknown]", class);
        }

    }
    *lcnt = *lcnt - (unsigned long int)rdlength;
    *ptr = *ptr + (signed long int)rdlength;
  }
  return retval;

trailing_junk:
  ;
  const char *return_value_getrrtpname_26;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname_26=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: %s record has trailing junk.\n", return_value_getrrtpname_26);
  }

  return 1;

record_too_short:
  ;
  const char *return_value_getrrtpname_27;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname_27=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: %s record too short.\n", return_value_getrrtpname_27);
  }

  return 1;

buffer_overflow:
  ;
  const char *return_value_getrrtpname_28;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname_28=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: buffer too small to process %s record.\n", return_value_getrrtpname_28);
  }

  return 1;

invalid_length:
  ;
  const char *return_value_getrrtpname_29;
  if(!(debug_p == 0))
  {
    return_value_getrrtpname_29=getrrtpname((signed int)type);
    debug_msg(0, "rrs2cent: %s record has length %u.\n", return_value_getrrtpname_29, rdlength);
  }

  return 1;
}

// run_as
// file helpers.h line 37
signed int run_as(const char *user)
{
  signed int return_value_initgroups_6;
  char *return_value_strerror_10;
  if(!(*user == 0))
  {
    struct passwd pwdbuf;
    struct passwd *pwd;
    unsigned long int buflen;
    signed int err;
    buflen = (unsigned long int)128;
    do
    {
      const signed long int err_array_size0 = (signed long int)buflen;
      char buf[err_array_size0];
      err=getpwnam_r(user, &pwdbuf, buf, buflen, &pwd);
      if(err == 0 && !(pwd == ((struct passwd *)NULL)))
      {
        signed int return_value_setgid_3;
        return_value_setgid_3=setgid(pwd->pw_gid);
        if(!(return_value_setgid_3 == 0))
        {
          signed int *return_value___errno_location_1;
          return_value___errno_location_1=__errno_location();
          char *return_value_strerror_2;
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          log_message(3, "Could not change group id to that of run_as user '%s': %s", user, return_value_strerror_2);
          return 0;
        }

        if(!(global.use_nss == 0))
        {
          return_value_initgroups_6=initgroups(user, pwd->pw_gid);
          if(!(return_value_initgroups_6 == 0))
          {
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            char *return_value_strerror_5;
            return_value_strerror_5=strerror(*return_value___errno_location_4);
            log_message(3, "Could not initialize the group access list of run_as user '%s': %s", user, return_value_strerror_5);
            return 0;
          }

        }

        signed int return_value_setuid_9;
        return_value_setuid_9=setuid(pwd->pw_uid);
        if(!(return_value_setuid_9 == 0))
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          char *return_value_strerror_8;
          return_value_strerror_8=strerror(*return_value___errno_location_7);
          log_message(3, "Could not change user id to that of run_as user '%s': %s", user, return_value_strerror_8);
          return 0;
        }

        break;
      }

      else
        if(!(err == 34))
        {
          if(!(err == 0))
          {
            return_value_strerror_10=strerror(err);
            log_message(3, "run_as user '%s' could not be found: %s", user, return_value_strerror_10);
          }

          else
            log_message(3, "run_as user '%s' could not be found.", user);
          return 0;
        }

        else
          if(buflen >= 16384ul)
          {
            log_message(3, "getpwnam_r() requires more than %u bytes of buffer space.", (unsigned int)buflen);
            return 0;
          }

      buflen = buflen * (unsigned long int)2;
    }
    while((_Bool)1);
  }

  return 1;
}

// same_inaddr2
// file helpers.h line 141
static inline signed int same_inaddr2(union anonymous_6 *a, struct anonymous_15 *b)
{
  signed int tmp_if_expr_5;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(run_ipv4 == 0))
    tmp_if_expr_5 = (signed int)(a->ipv4.s_addr == b->ipv4.s_addr);

  else
  {
    if(*((unsigned int *)&a->ipv6) == *((unsigned int *)&b->ipv6))
      tmp_if_expr_1 = ((unsigned int *)&a->ipv6)[(signed long int)1] == ((unsigned int *)&b->ipv6)[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = ((unsigned int *)&a->ipv6)[(signed long int)2] == ((unsigned int *)&b->ipv6)[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = ((unsigned int *)&a->ipv6)[(signed long int)3] == ((unsigned int *)&b->ipv6)[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = b->ipv4.s_addr == (unsigned int)0x00000000 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_if_expr_5 = (signed int)tmp_if_expr_4;
  }
  return tmp_if_expr_5;
}

// scan_string
// file conf-parser.c line 186
static signed int scan_string(char **curp, char *outbuf, unsigned int outbufsz, char **errstr)
{
  char *cur = *curp;
  unsigned int i = (unsigned int)0;
  const unsigned short int **return_value___ctype_b_loc_1;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  if((signed int)*cur == 34)
  {
    cur = cur + 1l;
    for( ; (_Bool)1; cur = cur + 1l)
    {
      if(*cur == 0)
        goto noclosingquote;

      if((signed int)*cur == 34)
        break;

      if((signed int)*cur == 92)
      {
        cur = cur + 1l;
        if(*cur == 0)
          goto nofollowingchar;

        if(!(i >= outbufsz))
          outbuf[(signed long int)i]=translescapedchar(*cur);

      }

      else
        if(!(i >= outbufsz))
          outbuf[(signed long int)i] = *cur;

      i = i + 1u;
    }
    cur = cur + 1l;
  }

  else
    for( ; !(*cur == 0); cur = cur + 1l)
    {
      if((signed int)*cur == 92)
      {
        cur = cur + 1l;
        if(*cur == 0)
          goto nofollowingchar;

        if(!(i >= outbufsz))
          outbuf[(signed long int)i]=translescapedchar(*cur);

      }

      else
      {
        return_value___ctype_b_loc_1=__ctype_b_loc();
        _Bool tmp_if_expr_2;
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*cur]) == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)*cur == 44 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_3;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*cur == 59 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_4;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = (signed int)*cur == 123 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_5;
        if(tmp_if_expr_4)
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = (signed int)*cur == 125 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)*cur == 34 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_7;
        if(tmp_if_expr_6)
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = (signed int)*cur == 35 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_10;
        if(tmp_if_expr_7)
          tmp_if_expr_10 = (_Bool)1;

        else
        {
          if((signed int)*cur == 47)
          {
            if((signed int)cur[1l] == 47)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = (signed int)cur[(signed long int)1] == 42 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_10)
          break;

        else
          if(!(i >= outbufsz))
            outbuf[(signed long int)i] = *cur;

      }
      i = i + 1u;
    }
  if(!(i >= outbufsz))
    outbuf[(signed long int)i] = (char)0;

  *curp = cur;
  return (signed int)i;

noclosingquote:
  ;
  *errstr = "quoted string without closing quote";
  return -1;

nofollowingchar:
  ;
  *errstr = "may not use backslash to escape end-of-line";
  return -1;
}

// sched_server_test
// file servers.h line 38
void sched_server_test(union anonymous_6 *sa, signed int nadr, signed int up)
{
  signed int k;
  signed int signal_test;
  pthread_mutex_lock(&servers_lock);
  signal_test = 0;
  k = 0;
  const char *return_value_pdnsd_a2str_3;
  for( ; !(k >= nadr); k = k + 1)
  {
    union anonymous_6 *sak = &sa[(signed long int)k];
    signed int i;
    signed int n;
    unsigned int return_value_da_nel_1;
    return_value_da_nel_1=da_nel_link5((struct anonymous_3 *)servers);
    n = (signed int)return_value_da_nel_1;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous_7 *sp = &servers->elem[(signed long int)i];
      signed int j;
      signed int m;
      unsigned int return_value_da_nel_2;
      return_value_da_nel_2=da_nel_link5((struct anonymous_3 *)sp->atup_a);
      m = (signed int)return_value_da_nel_2;
      j = 0;
      for( ; !(j >= m); j = j + 1)
      {
        struct anonymous_20 *at = &sp->atup_a->elem[(signed long int)j];
        signed int return_value_equiv_inaddr2_4;
        return_value_equiv_inaddr2_4=equiv_inaddr2_link2(sak, &at->a);
        if(!(return_value_equiv_inaddr2_4 == 0))
        {
          if(up >= 0)
          {
            at->is_up = (char)up;
            at->i_ts=time((signed long int *)(void *)0);
            char _debugsockabuf[46l];
            if(!(debug_p == 0))
            {
              return_value_pdnsd_a2str_3=pdnsd_a2str(sak, _debugsockabuf, 46);
              debug_msg(0, "Marked server %s %s.\n", return_value_pdnsd_a2str_3, up != 0 ? "up" : "down");
            }

          }

          else
            if(!(at->i_ts == 0l))
            {
              at->i_ts = (signed long int)0;
              signal_test = 1;
            }

        }

      }
    }
  }
  if(!(signal_test == 0))
    pthread_cond_signal(&server_test_cond);

  pthread_mutex_unlock(&servers_lock);
}

// scheme_ok
// file servers.c line 203
static signed int scheme_ok(struct anonymous_7 *serv)
{
  if(!(serv->scheme[0l] == 0))
  {
    if(schm[0l] == 0)
    {
      signed long int nschm;
      signed int sc;
      sc=open(global.scheme_file, 00);
      char *s;
      if(!(sc >= 0))
        return 0;

      nschm=read(sc, (void *)schm, sizeof(char [32l]) /*32ul*/  - (unsigned long int)1);
      close(sc);
      if(!(nschm >= 0l))
        return 0;

      schm[nschm] = (char)0;
      s=strchr(schm, 10);
      if(!(s == ((char *)NULL)))
        *s = (char)0;

    }

    signed int return_value_fnmatch_1;
    return_value_fnmatch_1=fnmatch(serv->scheme, schm, 0);
    if(!(return_value_fnmatch_1 == 0))
      return 0;

  }

  return 1;
}

// servstat_thread
// file servers.c line 314
void * servstat_thread(void *p)
{
  struct sigaction action;
  signed int keep_testing;
  pthread_mutex_lock(&servers_lock);
  signal_interrupt = 0;
  action.__sigaction_handler.sa_handler = sigint_handler;
  sigemptyset(&action.sa_mask);
  action.sa_flags = 0;
  signed int return_value_sigaction_3;
  return_value_sigaction_3=sigaction(1, &action, (struct sigaction *)(void *)0);
  if(return_value_sigaction_3 == 0)
  {
    struct anonymous_41 smask;
    sigemptyset(&smask);
    sigaddset(&smask, 1);
    pthread_sigmask(1, &smask, (struct anonymous_41 *)(void *)0);
  }

  else
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_message(4, "Cannot install signal handler for server status thread: %s\n", return_value_strerror_2);
  }
  unsigned int return_value_da_nel_6;
  signed long int return_value_time_16;
  signed int return_value_needs_intermittent_testing_21;
  _Bool tmp_if_expr_22;
  signed int return_value_needs_intermittent_testing_26;
  do
  {

  __CPROVER_DUMP_L3:
    ;
    signed int i;
    signed int n;
    keep_testing = 0;
    retest_flag = (signed short int)0;
    schm[(signed long int)0] = (char)0;
    unsigned int return_value_da_nel_4;
    return_value_da_nel_4=da_nel_link5((struct anonymous_3 *)servers);
    n = (signed int)return_value_da_nel_4;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      struct anonymous_7 *sp = &servers->elem[(signed long int)i];
      signed int j;
      signed int m;
      if((signed int)sp->rootserver == 2)
      {
        struct anonymous_14 *adrs;
        signed int l;
        signed int one_up = 0;
        signed int return_value_scheme_ok_11;
        return_value_scheme_ok_11=scheme_ok(sp);
        if(return_value_scheme_ok_11 == 0)
        {
          signed long int servstat_thread__1__3__1__1__1__1__1__1__now;
          servstat_thread__1__3__1__1__1__1__1__1__now=time((signed long int *)(void *)0);
          unsigned int return_value_da_nel_5;
          return_value_da_nel_5=da_nel_link5((struct anonymous_3 *)sp->atup_a);
          m = (signed int)return_value_da_nel_5;
          j = 0;
          for( ; !(j >= m); j = j + 1)
            sp->atup_a->elem[(signed long int)j].i_ts = servstat_thread__1__3__1__1__1__1__1__1__now;
        }

        else
        {
          _Bool tmp_if_expr_10;
          if((signed int)sp->uptest == 8)
            tmp_if_expr_10 = (_Bool)1;

          else
            tmp_if_expr_10 = (signed int)sp->uptest == 9 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_10)
          {
            if(sp->interval >= 1l)
            {
              return_value_da_nel_6=da_nel_link5((struct anonymous_3 *)sp->atup_a);
              one_up = (signed int)return_value_da_nel_6;
            }

            else
            {
              signed long int servstat_thread__1__3__1__1__1__1__1__2__1__now;
              servstat_thread__1__3__1__1__1__1__1__2__1__now=time((signed long int *)(void *)0);
              unsigned int return_value_da_nel_7;
              return_value_da_nel_7=da_nel_link5((struct anonymous_3 *)sp->atup_a);
              m = (signed int)return_value_da_nel_7;
              j = 0;
              for( ; !(j >= m); j = j + 1)
              {
                struct anonymous_20 *servstat_thread__1__3__1__1__1__1__1__2__1__1__1__at = &sp->atup_a->elem[(signed long int)j];
                _Bool tmp_if_expr_8;
                if(!(servstat_thread__1__3__1__1__1__1__1__2__1__1__1__at->is_up == 0))
                  tmp_if_expr_8 = (_Bool)1;

                else
                  tmp_if_expr_8 = servstat_thread__1__3__1__1__1__1__1__2__1__1__1__at->i_ts == (signed long int)0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_8)
                  one_up = 1;

                servstat_thread__1__3__1__1__1__1__1__2__1__1__1__at->i_ts = servstat_thread__1__3__1__1__1__1__1__2__1__now;
              }
            }
          }

          else
          {
            retest(i, -1);
            unsigned int return_value_da_nel_9;
            return_value_da_nel_9=da_nel_link5((struct anonymous_3 *)sp->atup_a);
            m = (signed int)return_value_da_nel_9;
            j = 0;
            for( ; !(j >= m); j = j + 1)
              if(!(sp->atup_a->elem[(signed long int)j].is_up == 0))
              {
                one_up = 1;
                break;
              }

          }
        }
        if(one_up == 0)
        {
          signed int return_value_needs_intermittent_testing_12;
          return_value_needs_intermittent_testing_12=needs_intermittent_testing(sp);
          if(!(return_value_needs_intermittent_testing_12 == 0))
            keep_testing = 1;

          goto __CPROVER_DUMP_L55;
        }

        if(!(debug_p == 0))
          debug_msg(0, "Attempting to discover root servers for server section #%d.\n", i);

        adrs=resolv_rootserver_addrs(sp->atup_a, (signed int)sp->port, sp->edns_query, sp->timeout);
        unsigned int return_value_da_nel_13;
        return_value_da_nel_13=da_nel_link5((struct anonymous_3 *)adrs);
        l = (signed int)return_value_da_nel_13;
        if(l >= 1)
        {
          struct timeval servstat_thread__1__3__1__1__1__1__1__6__now;
          struct timespec servstat_thread__1__3__1__1__1__1__1__6__timeout;
          struct anonymous_19 *ata;
          if(!(debug_p == 0))
            debug_msg(0, "Filling server section #%d with %d root server addresses.\n", i, l);

          gettimeofday(&servstat_thread__1__3__1__1__1__1__1__6__now, (struct timezone *)(void *)0);
          servstat_thread__1__3__1__1__1__1__1__6__timeout.tv_sec = servstat_thread__1__3__1__1__1__1__1__6__now.tv_sec + (signed long int)60;
          servstat_thread__1__3__1__1__1__1__1__6__timeout.tv_nsec = servstat_thread__1__3__1__1__1__1__1__6__now.tv_usec * (signed long int)1000;
          while(server_data_users >= 1)
          {
            signed int return_value_pthread_cond_timedwait_14;
            return_value_pthread_cond_timedwait_14=pthread_cond_timedwait(&server_data_cond, &servers_lock, &servstat_thread__1__3__1__1__1__1__1__6__timeout);
            if(return_value_pthread_cond_timedwait_14 == 110)
            {
              if(!(debug_p == 0))
                debug_msg(0, "Timed out while waiting for exclusive access to server data to set root server addresses of server section #%d\n", i);

              free((void *)adrs);
              keep_testing = 1;
            }

          }
          struct anonymous_3 *return_value_da_resize_15;
          return_value_da_resize_15=da_resize((struct anonymous_3 *)(void *)0, (unsigned long int)((struct anonymous_19 *)0)->elem, sizeof(struct anonymous_20) /*32ul*/ , (unsigned long int)l, (void (*)(void *))(void *)0);
          ata = (struct anonymous_19 *)return_value_da_resize_15;
          if(ata == ((struct anonymous_19 *)NULL))
          {
            log_message(4, "Out of memory in servstat_thread() while discovering root servers.");
            free((void *)adrs);
            keep_testing = 1;
            goto __CPROVER_DUMP_L55;
          }

          j = 0;
          for( ; !(j >= l); j = j + 1)
          {
            struct anonymous_20 *at = &ata->elem[(signed long int)j];
            at->a = adrs->elem[(signed long int)j];
            at->is_up = sp->preset;
            signed long int tmp_if_expr_17;
            if(!(sp->interval >= 0l))
            {
              return_value_time_16=time((signed long int *)(void *)0);
              tmp_if_expr_17 = return_value_time_16;
            }

            else
              tmp_if_expr_17 = (signed long int)0;
            at->i_ts = tmp_if_expr_17;
          }
          free((void *)sp->atup_a);
          sp->atup_a = ata;
          free((void *)adrs);
          sp->rootserver = (char)1;
        }

        else
        {
          if(!(debug_p == 0))
            debug_msg(0, "Failed to discover root servers in servstat_thread() (server section #%d).\n", i);

          if(!(adrs == ((struct anonymous_14 *)NULL)))
            free((void *)adrs);

          unsigned int return_value_da_nel_18;
          return_value_da_nel_18=da_nel_link5((struct anonymous_3 *)sp->atup_a);
          if(!(return_value_da_nel_18 == 0u))
            keep_testing = 1;

          goto __CPROVER_DUMP_L55;
        }
      }

      signed int return_value_needs_testing_19;
      return_value_needs_testing_19=needs_testing_link1(sp);
      if(!(return_value_needs_testing_19 == 0))
        keep_testing = 1;

      unsigned int return_value_da_nel_20;
      return_value_da_nel_20=da_nel_link5((struct anonymous_3 *)sp->atup_a);
      m = (signed int)return_value_da_nel_20;
      j = 0;
      for( ; !(j >= m); j = j + 1)
        if(!(sp->atup_a->elem[(signed long int)j].i_ts == 0l))
          goto individual_tests;

      if(signal_interrupt == 0)
        retest(i, -1);

      goto __CPROVER_DUMP_L55;

    individual_tests:
      ;
      j = 0;
      for( ; signal_interrupt == 0 && !(j >= m); j = j + 1)
      {
        signed long int ts = sp->atup_a->elem[(signed long int)j].i_ts;
        signed long int now;
        _Bool tmp_if_expr_23;
        if(ts == 0l)
          tmp_if_expr_23 = (_Bool)1;

        else
        {
          return_value_needs_intermittent_testing_21=needs_intermittent_testing(sp);
          if(!(return_value_needs_intermittent_testing_21 == 0))
          {
            now=time((signed long int *)(void *)0);
            tmp_if_expr_22 = (now - ts > sp->interval ? (_Bool)1 : (ts > now ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_22 = (_Bool)0;
          tmp_if_expr_23 = tmp_if_expr_22 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_23)
          retest(i, j);

      }

    __CPROVER_DUMP_L55:
      ;
    }
    if(signal_interrupt == 0 && !(retest_flag == 0))
      goto __CPROVER_DUMP_L3;

    signal_interrupt = 0;
    if(keep_testing == 0)
      break;

    struct timeval servstat_thread__1__3__1__2__now;
    struct timespec timeout;
    signed long int minwait;
    signed int servstat_thread__1__3__1__2__i;
    signed int servstat_thread__1__3__1__2__n;
    signed int retval;
    gettimeofday(&servstat_thread__1__3__1__2__now, (struct timezone *)(void *)0);
    minwait = (signed long int)3600;
    unsigned int return_value_da_nel_24;
    return_value_da_nel_24=da_nel_link5((struct anonymous_3 *)servers);
    servstat_thread__1__3__1__2__n = (signed int)return_value_da_nel_24;
    servstat_thread__1__3__1__2__i = 0;
    for( ; !(servstat_thread__1__3__1__2__i >= servstat_thread__1__3__1__2__n); servstat_thread__1__3__1__2__i = servstat_thread__1__3__1__2__i + 1)
    {
      struct anonymous_7 *servstat_thread__1__3__1__2__1__1__sp = &servers->elem[(signed long int)servstat_thread__1__3__1__2__i];
      signed int servstat_thread__1__3__1__2__1__1__j;
      signed int servstat_thread__1__3__1__2__1__1__m;
      unsigned int return_value_da_nel_25;
      return_value_da_nel_25=da_nel_link5((struct anonymous_3 *)servstat_thread__1__3__1__2__1__1__sp->atup_a);
      servstat_thread__1__3__1__2__1__1__m = (signed int)return_value_da_nel_25;
      servstat_thread__1__3__1__2__1__1__j = 0;
      for( ; !(servstat_thread__1__3__1__2__1__1__j >= servstat_thread__1__3__1__2__1__1__m); servstat_thread__1__3__1__2__1__1__j = servstat_thread__1__3__1__2__1__1__j + 1)
      {
        signed long int servstat_thread__1__3__1__2__1__1__1__1__ts = servstat_thread__1__3__1__2__1__1__sp->atup_a->elem[(signed long int)servstat_thread__1__3__1__2__1__1__j].i_ts;
        if(servstat_thread__1__3__1__2__1__1__1__1__ts == 0l)
        {
          if(minwait >= 1l)
            minwait = (signed long int)0;

        }

        else
        {
          return_value_needs_intermittent_testing_26=needs_intermittent_testing(servstat_thread__1__3__1__2__1__1__sp);
          if(!(return_value_needs_intermittent_testing_26 == 0))
          {
            signed long int wait = (servstat_thread__1__3__1__2__1__1__1__1__ts + servstat_thread__1__3__1__2__1__1__sp->interval) - servstat_thread__1__3__1__2__now.tv_sec;
            if(!(wait >= minwait))
              minwait = wait;

          }

        }
      }
    }
    timeout.tv_sec = servstat_thread__1__3__1__2__now.tv_sec;
    if(minwait >= 1l)
      timeout.tv_sec = timeout.tv_sec + minwait;

    timeout.tv_nsec = servstat_thread__1__3__1__2__now.tv_usec * (signed long int)1000 + (signed long int)500000000;
    if(timeout.tv_nsec >= 1000000000l)
    {
      timeout.tv_nsec = timeout.tv_nsec - (signed long int)1000000000;
      timeout.tv_sec = timeout.tv_sec + 1l;
    }

    retval=pthread_cond_timedwait(&server_test_cond, &servers_lock, &timeout);
    if(!(debug_p == 0))
      debug_msg(0, "Server status thread woke up (%s signal).\n", retval == 0 ? "test condition" : (retval == 110 ? "timer" : (retval == 4 ? "interrupt" : "error")));

  }
  while((_Bool)1);
  servstat_thrid = main_thrid;
  pthread_mutex_unlock(&servers_lock);
  if(!(debug_p == 0))
    debug_msg(0, "Server status thread exiting.\n");

  return (void *)0;
}

// set_all_flags_ttl
// file dns_query.c line 3210
static void set_all_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous_0 *cached)
{
  signed int i;
  signed int ilim;
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)cached->flags) == 0))
    tmp_if_expr_1 = 0;

  else
    tmp_if_expr_1 = cached->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
  ilim = tmp_if_expr_1;
  i = 0;
  for( ; !(i >= ilim); i = i + 1)
  {
    struct anonymous *rrset;
    struct anonymous *tmp_if_expr_2;
    if(!(i >= 8))
      tmp_if_expr_2 = cached->_anon0.rr.rrmu[(signed long int)i];

    else
      tmp_if_expr_2 = cached->_anon0.rr.rrext[(signed long int)(i - 8)];
    rrset = tmp_if_expr_2;
    if(!(rrset == ((struct anonymous *)NULL)))
    {
      signed long int t;
      *flags = *flags | rrset->flags;
      signed long int tmp_if_expr_3;
      if(!(rrset->ttl >= 120l))
        tmp_if_expr_3 = (signed long int)120;

      else
        tmp_if_expr_3 = rrset->ttl;
      t = rrset->ts + tmp_if_expr_3;
      _Bool tmp_if_expr_4;
      if(*ttl == 0l)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = *ttl > t ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        *ttl = t;

    }

  }
}

// set_cent_flags
// file cache.h line 177
signed int set_cent_flags(const unsigned char *name, unsigned int flags)
{
  struct anonymous_0 *ret;
  lock_cache_rw();
  ret=dns_lookup(name, (struct anonymous_58 *)(void *)0);
  if(!(ret == ((struct anonymous_0 *)NULL)))
    ret->flags = ret->flags | (unsigned short int)flags;

  unlock_cache_rw();
  return (signed int)(ret != (struct anonymous_0 *)(void *)0);
}

// set_flags_ttl
// file dns_query.c line 3196
static signed int set_flags_ttl(unsigned short int *flags, signed long int *ttl, struct anonymous_0 *cached, signed int tp)
{
  struct anonymous *rrset;
  rrset=getrrset_link1(cached, tp);
  if(!(rrset == ((struct anonymous *)NULL)))
  {
    signed long int t;
    *flags = *flags | rrset->flags;
    signed long int tmp_if_expr_1;
    if(!(rrset->ttl >= 120l))
      tmp_if_expr_1 = (signed long int)120;

    else
      tmp_if_expr_1 = rrset->ttl;
    t = rrset->ts + tmp_if_expr_1;
    _Bool tmp_if_expr_2;
    if(*ttl == 0l)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = *ttl > t ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      *ttl = t;

    return 1;
  }

  return 0;
}

// sigint_handler
// file servers.c line 853
static void sigint_handler(signed int signum)
{
  signal_interrupt = 1;
}

// simple_dns_cached_resolve
// file dns_query.c line 3446
static signed int simple_dns_cached_resolve(struct anonymous_19 *atup_a, signed int port, char edns_query, signed long int timeout, const unsigned char *name, signed int thint, struct anonymous_0 **cachedp)
{
  struct anonymous_0 *cached = (struct anonymous_0 *)(void *)0;
  signed int rc;
  unsigned char _debugstrbuf[256l];
  const unsigned char *return_value_rhn2str_1;
  const char *return_value_get_tname_2;
  if(!(debug_p == 0))
  {
    return_value_rhn2str_1=rhn2str(name, _debugstrbuf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
    return_value_get_tname_2=get_tname(thint);
    debug_msg(0, "Starting simple cached resolve for: %s, query %s\n", return_value_rhn2str_1, return_value_get_tname_2);
  }

  signed long int return_value_time_3;
  return_value_time_3=time((signed long int *)(void *)0);
  rc=lookup_cache_status(name, thint, &cached, (unsigned short int *)(void *)0, return_value_time_3, (unsigned char *)(void *)0);
  if(rc == 0)
  {
    *cachedp = cached;
    return 0;
  }

  else
    if(rc == 3)
      return 3;

  if(!(rc == 0xfffb))
  {
    struct anonymous_4 *qserv;
    signed int j;
    signed int m;
    if(!(cached == ((struct anonymous_0 *)NULL)))
    {
      free_cent(cached);
      free((void *)cached);
      cached = (struct anonymous_0 *)(void *)0;
    }

    if(!(debug_p == 0))
      debug_msg(0, "Trying name servers.\n");

    qserv = (struct anonymous_4 *)(void *)0;
    unsigned int return_value_da_nel_4;
    return_value_da_nel_4=da_nel_link2((struct anonymous_3 *)atup_a);
    m = (signed int)return_value_da_nel_4;
    j = 0;
    for( ; !(j >= m); j = j + 1)
    {
      signed int return_value_add_qserv_5;
      return_value_add_qserv_5=add_qserv(&qserv, &atup_a->elem[(signed long int)j].a, port, timeout, (unsigned int)0, 0, (char)1, edns_query, (char)0, (char)0, (char)1, (const unsigned char *)(void *)0, (struct rejectlist_s *)(void *)0);
      if(return_value_add_qserv_5 == 0)
        return 2;

    }
    rc=p_recursive_query(qserv, name, thint, &cached, (signed int *)(void *)0, 0, (struct qstatnode_s *)(void *)0, (struct qhintnode_s *)(void *)0, (unsigned char *)(void *)0);
    del_qserv(qserv);
    if(rc == 0)
    {
      struct anonymous_0 *tc;
      add_cache(cached);
      tc=lookup_cache(name, (signed int *)(void *)0);
      if(!(tc == ((struct anonymous_0 *)NULL)))
      {
        free_cent(cached);
        free((void *)cached);
        cached = tc;
      }

      else
        if(!(debug_p == 0))
          debug_msg(0, "simple_dns_cached_resolve: merging answer with cache failed, using local cent copy.\n");

    }

    else
      return rc;
  }

  else
    if(!(debug_p == 0))
      debug_msg(0, "Using cached record.\n");

  if(!((1 & (signed int)cached->flags) == 0))
  {
    free_cent(cached);
    free((void *)cached);
    return 3;
  }

  else
  {
    *cachedp = cached;
    return 0;
  }
}

// skiprhn
// file helpers.h line 88
static inline unsigned char * skiprhn(unsigned char *rhn)
{
  unsigned int lb;
  unsigned char *tmp_post_1;
  do
  {
    tmp_post_1 = rhn;
    rhn = rhn + 1l;
    lb = (unsigned int)*tmp_post_1;
    if(lb == 0u)
      break;

    rhn = rhn + (signed long int)lb;
  }
  while((_Bool)1);
  return rhn;
}

// skiprhn_link1
// file helpers.h line 88
static inline unsigned char * skiprhn_link1(unsigned char *rhn_link1)
{
  unsigned int lb_link1;
  unsigned char *tmp_post_1_link1;
  do
  {
    tmp_post_1_link1 = rhn_link1;
    rhn_link1 = rhn_link1 + 1l;
    lb_link1 = (unsigned int)*tmp_post_1_link1;
    if(lb_link1 == 0u)
      break;

    rhn_link1 = rhn_link1 + (signed long int)lb_link1;
  }
  while((_Bool)1);
  return rhn_link1;
}

// skiprhn_link2
// file helpers.h line 88
static inline unsigned char * skiprhn_link2(unsigned char *rhn_link2)
{
  unsigned int lb_link2;
  unsigned char *tmp_post_1_link2;
  do
  {
    tmp_post_1_link2 = rhn_link2;
    rhn_link2 = rhn_link2 + 1l;
    lb_link2 = (unsigned int)*tmp_post_1_link2;
    if(lb_link2 == 0u)
      break;

    rhn_link2 = rhn_link2 + (signed long int)lb_link2;
  }
  while((_Bool)1);
  return rhn_link2;
}

// skipsegs
// file helpers.h line 74
static inline const unsigned char * skipsegs(const unsigned char *nm, unsigned int k)
{
  unsigned int lb;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(k == 0u))
    {
      lb = (unsigned int)*nm;
      tmp_if_expr_1 = lb != 0u ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    nm = nm + (signed long int)(lb + (unsigned int)1);
    k = k - 1u;
  }
  while((_Bool)1);
  return nm;
}

// skipsegs_link1
// file helpers.h line 74
static inline const unsigned char * skipsegs_link1(const unsigned char *nm_link1, unsigned int k_link1)
{
  unsigned int lb_link1;
  _Bool tmp_if_expr_1_link1;
  do
  {
    if(!(k_link1 == 0u))
    {
      lb_link1 = (unsigned int)*nm_link1;
      tmp_if_expr_1_link1 = lb_link1 != 0u ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1_link1 = (_Bool)0;
    if(!tmp_if_expr_1_link1)
      break;

    nm_link1 = nm_link1 + (signed long int)(lb_link1 + (unsigned int)1);
    k_link1 = k_link1 - 1u;
  }
  while((_Bool)1);
  return nm_link1;
}

// skipsegs_link2
// file helpers.h line 74
static inline const unsigned char * skipsegs_link2(const unsigned char *nm_link2, unsigned int k_link2)
{
  unsigned int lb_link2;
  _Bool tmp_if_expr_1_link2;
  do
  {
    if(!(k_link2 == 0u))
    {
      lb_link2 = (unsigned int)*nm_link2;
      tmp_if_expr_1_link2 = lb_link2 != 0u ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1_link2 = (_Bool)0;
    if(!tmp_if_expr_1_link2)
      break;

    nm_link2 = nm_link2 + (signed long int)(lb_link2 + (unsigned int)1);
    k_link2 = k_link2 - 1u;
  }
  while((_Bool)1);
  return nm_link2;
}

// slist_add
// file conf-parser.c line 2074
static const char * slist_add(struct anonymous_8 **sla, const char *nm, unsigned int len, signed int tp)
{
  struct anonymous_9 *sl;
  signed int exact = 1;
  const char *err;
  unsigned long int sz;
  unsigned char rhn[256l];
  if(len >= 2u)
  {
    if((signed int)*nm == 46)
    {
      exact = 0;
      nm = nm + 1l;
      len = len - 1u;
    }

  }

  err=parsestr2rhn((unsigned char *)nm, len, rhn);
  if(!(err == ((const char *)NULL)))
    return err;

  else
  {
    unsigned int return_value_rhnlen_1;
    return_value_rhnlen_1=rhnlen(rhn);
    sz = (unsigned long int)return_value_rhnlen_1;
    struct anonymous_3 *return_value_da_grow1_2;
    return_value_da_grow1_2=da_grow1((struct anonymous_3 *)*sla, (unsigned long int)((struct anonymous_8 *)0)->elem, sizeof(struct anonymous_9) /*16ul*/ , free_slist_domain);
    *sla = (struct anonymous_8 *)return_value_da_grow1_2;
    if(*sla == ((struct anonymous_8 *)NULL))
      return "out of memory!";

    else
    {
      sl = &(*sla)->elem[(signed long int)((*sla)->nel - (unsigned long int)1)];
      sl->exact = (signed short int)exact;
      sl->rule = (signed short int)tp;
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sz);
      sl->domain = (unsigned char *)return_value_malloc_3;
      if(sl->domain == ((unsigned char *)NULL))
        return "out of memory!";

      else
      {
        memcpy((void *)sl->domain, (const void *)rhn, sz);
        return (const char *)(void *)0;
      }
    }
  }
}

// soa_minimum
// file dns_query.c line 1106
static signed long int soa_minimum(struct rr_b_s *rrs)
{
  unsigned int minimum;
  unsigned char *p = (unsigned char *)rrs->data;
  unsigned char *return_value_skiprhn_1;
  return_value_skiprhn_1=skiprhn_link1(p);
  p=skiprhn_link1(return_value_skiprhn_1);
  p = p + (signed long int)((unsigned long int)4 * sizeof(unsigned int) /*4ul*/ );
  do
  {
    unsigned int t_l;
    const unsigned char *t_cp = (const unsigned char *)p;
    const unsigned char *tmp_post_2 = t_cp;
    t_cp = t_cp + 1l;
    t_l = (unsigned int)*tmp_post_2 << 24;
    const unsigned char *tmp_post_3 = t_cp;
    t_cp = t_cp + 1l;
    t_l = t_l | (unsigned int)*tmp_post_3 << 16;
    const unsigned char *tmp_post_4 = t_cp;
    t_cp = t_cp + 1l;
    t_l = t_l | (unsigned int)*tmp_post_4 << 8;
    const unsigned char *tmp_post_5 = t_cp;
    t_cp = t_cp + 1l;
    t_l = t_l | (unsigned int)*tmp_post_5;
    minimum = t_l;
    p = (unsigned char *)(void *)t_cp;
  }
  while((_Bool)0);
  return (signed long int)minimum;
}

// softlock_cache_r
// file cache.c line 371
static signed int softlock_cache_r(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int lk = 0;
    signed int tr = 0;
    do
    {
      signed int return_value_softlock_mutex_1;
      return_value_softlock_mutex_1=softlock_mutex(&lock_mutex);
      if(return_value_softlock_mutex_1 == 0)
        return 0;

      if(cache_w_lock == 0)
      {
        lk = 1;
        cache_r_lock = cache_r_lock + 1;
      }

      pthread_mutex_unlock(&lock_mutex);
      if(!(lk == 0))
        break;

      tr = tr + 1;
      if(tr >= 1000)
        return 0;

      usleep_r_link3((unsigned long int)1000);
    }
    while((_Bool)1);
    return 1;
  }
}

// softlock_cache_rw
// file cache.c line 408
static signed int softlock_cache_rw(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int lk = 0;
    signed int tr = 0;
    do
    {
      signed int return_value_softlock_mutex_1;
      return_value_softlock_mutex_1=softlock_mutex(&lock_mutex);
      if(return_value_softlock_mutex_1 == 0)
        return 0;

      if(cache_r_lock == 0 && cache_w_lock == 0)
      {
        lk = 1;
        cache_w_lock = 1;
      }

      pthread_mutex_unlock(&lock_mutex);
      if(!(lk == 0))
        break;

      tr = tr + 1;
      if(tr >= 1000)
        return 0;

      usleep_r_link3((unsigned long int)1000);
    }
    while((_Bool)1);
    return 1;
  }
}

// softlock_mutex
// file helpers.h line 39
signed int softlock_mutex(union anonymous_33 *mutex)
{
  unsigned int tr = (unsigned int)0;
  signed int return_value_pthread_mutex_trylock_1;
  do
  {
    return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(mutex);
    if(return_value_pthread_mutex_trylock_1 == 0)
      break;

    tr = tr + 1u;
    if(tr >= 1000u)
      return 0;

    usleep_r_link1((unsigned long int)10000);
  }
  while((_Bool)1);
  return 1;
}

// softunlock_cache_r
// file cache.c line 396
static signed int softunlock_cache_r(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int return_value_softlock_mutex_1;
    return_value_softlock_mutex_1=softlock_mutex(&lock_mutex);
    if(return_value_softlock_mutex_1 == 0)
      return 0;

    else
    {
      if(cache_r_lock >= 1)
        cache_r_lock = cache_r_lock - 1;

      pthread_mutex_unlock(&lock_mutex);
      return 1;
    }
  }
}

// softunlock_cache_rw
// file cache.c line 432
static signed int softunlock_cache_rw(void)
{
  if(use_cache_lock == 0)
    return 0;

  else
  {
    signed int return_value_softlock_mutex_1;
    return_value_softlock_mutex_1=softlock_mutex(&lock_mutex);
    if(return_value_softlock_mutex_1 == 0)
      return 0;

    else
    {
      cache_w_lock = 0;
      pthread_mutex_unlock(&lock_mutex);
      return 1;
    }
  }
}

// sort_rrl
// file cache.c line 1012
static void sort_rrl()
{
  _Bool tmp_if_expr_1;
  if(!(rrset_l == ((struct rr_lent_s *)NULL)))
  {
    if(!(rrset_l->next == ((struct rr_lent_s *)NULL)))
    {
      struct rr_lent_s *tmp[32l];
      struct rr_lent_s **fill = tmp;
      struct rr_lent_s **end = tmp + (signed long int)32;
      struct rr_lent_s **counter;
      struct rr_lent_s *rem = rrset_l;
      struct rr_lent_s *carry;
      do
      {
        carry = rem;
        rem = rem->next;
        carry->next = (struct rr_lent_s *)(void *)0;
        counter = tmp;
        do
        {
          if(!(counter == fill))
            tmp_if_expr_1 = *counter != (struct rr_lent_s *)(void *)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(!tmp_if_expr_1)
            break;

          carry=listmerge(*counter, carry);
          *counter = (struct rr_lent_s *)(void *)0;
          counter = counter + 1l;
        }
        while((_Bool)1);
        if(counter == end)
        {
          log_message(3, "%s:%d: %s", (const void *)"cache.c", 1032, (const void *)"sort_rrl: tmp array overflowed");
          pdnsd_exit();
        }

        *counter = carry;
        if(counter == fill)
          fill = fill + 1l;

      }
      while(!(rem == ((struct rr_lent_s *)NULL)));
      carry = tmp[(signed long int)0];
      counter = tmp;
      do
      {
        counter = counter + 1l;
        if(counter == fill)
          break;

        carry=listmerge(*counter, carry);
      }
      while((_Bool)1);
      rrset_l = carry;
      struct rr_lent_s *p;
      struct rr_lent_s *q = (struct rr_lent_s *)(void *)0;
      p = rrset_l;
      for( ; !(p == ((struct rr_lent_s *)NULL)); p = p->next)
      {
        p->prev = q;
        q = p;
      }
      rrset_l_tail = q;
    }

  }

}

// start_dns_servers
// file dns_answer.c line 2109
void start_dns_servers(void)
{
  if(!(tcp_socket == -1))
  {
    unsigned long int tcps;
    signed int return_value_pthread_create_1;
    return_value_pthread_create_1=pthread_create(&tcps, &attr_detached, tcp_server_thread, (void *)0);
    if(!(return_value_pthread_create_1 == 0))
    {
      log_message(3, "Could not create TCP server thread. Exiting.");
      pdnsd_exit();
    }

    else
    {
      tcps_thrid = tcps;
      if((signed int)global.verbosity >= 2)
        log_message(6, "TCP server thread started.");

    }
  }

  if(!(udp_socket == -1))
  {
    unsigned long int udps;
    signed int return_value_pthread_create_2;
    return_value_pthread_create_2=pthread_create(&udps, &attr_detached, udp_server_thread, (void *)0);
    if(!(return_value_pthread_create_2 == 0))
    {
      log_message(3, "Could not create UDP server thread. Exiting.");
      pdnsd_exit();
    }

    else
    {
      udps_thrid = udps;
      if((signed int)global.verbosity >= 2)
        log_message(6, "UDP server thread started.");

    }
  }

}

// start_servstat_thread
// file servers.h line 37
signed int start_servstat_thread(void)
{
  unsigned long int stt;
  signed int rv;
  rv=pthread_create(&stt, &attr_detached, servstat_thread, (void *)0);
  char *return_value_strerror_1;
  if(!(rv == 0))
  {
    return_value_strerror_1=strerror(rv);
    log_message(4, "Failed to start server status thread: %s", return_value_strerror_1);
  }

  else
  {
    servstat_thrid = stt;
    if((signed int)global.verbosity >= 2)
      log_message(6, "Server status thread started.");

  }
  return rv;
}

// start_stat_sock
// file status.h line 57
signed int start_stat_sock(void)
{
  unsigned long int st;
  signed int rv;
  rv=pthread_create(&st, &attr_detached, status_thread, (void *)0);
  if(!(rv == 0))
    log_message(4, "Failed to start status thread. The status socket will be unuseable");

  else
  {
    statsock_thrid = st;
    if((signed int)global.verbosity >= 2)
      log_message(6, "Status thread started.");

  }
  return rv;
}

// status_thread
// file status.c line 172
static void * status_thread(void *p)
{
  if(global.strict_suid == 0)
  {
    signed int return_value_run_as_1;
    return_value_run_as_1=run_as(global.run_as);
    if(return_value_run_as_1 == 0)
      pdnsd_exit();

  }

  signed int return_value_listen_4;
  return_value_listen_4=listen(stat_sock, 5);
  if(return_value_listen_4 == -1)
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    log_message(4, "Error: could not listen on socket: %s.\nStatus readback will be impossible", return_value_strerror_3);
    goto exit_thread;
  }

  signed int return_value_report_cache_stat_9;
  signed int return_value_report_thread_stat_11;
  signed int return_value_report_conf_stat_13;
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  signed int return_value_read_allocstring_17;
  unsigned int return_value_da_nel_19;
  unsigned int return_value_da_nel_22;
  signed int return_value_strcmp_23;
  unsigned int return_value_da_nel_25;
  signed int return_value_strcmp_26;
  const unsigned short int **return_value___ctype_b_loc_27;
  const unsigned short int **return_value___ctype_b_loc_29;
  signed int return_value_read_long_37;
  signed int return_value_read_short_39;
  signed int return_value_read_short_41;
  signed int return_value_read_short_48;
  void *return_value_malloc_49;
  signed int return_value_read_domain_50;
  signed long int return_value_read_51;
  signed int return_value_read_domain_52;
  unsigned int return_value_rhnlen_53;
  signed int return_value_add_cent_rr_56;
  _Bool tmp_if_expr_80;
  char *tmp_if_expr_78;
  signed int return_value_fsprintf_79;
  signed int *return_value___errno_location_76;
  char *return_value_strerror_77;
  signed int *return_value___errno_location_85;
  do
  {
    struct sockaddr_un ra;
    unsigned int res = (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ ;
    signed int rs;
    rs=accept(stat_sock, (struct sockaddr *)&ra, &res);
    if(!(rs == -1))
    {
      unsigned short int cmd;
      if(!(debug_p == 0))
        debug_msg(0, "Status socket query pending.\n");

      signed int return_value_read_short_82;
      return_value_read_short_82=read_short(rs, &cmd);
      if(!(return_value_read_short_82 == 0))
      {
        if((0xff00 & (signed int)cmd) == 0x6800)
        {
          const char *errmsg;
          cmd = cmd & (unsigned short int)0xff;
          if(!((signed int)cmd == 1))
          {
            if((signed int)cmd == 2)
              goto __CPROVER_DUMP_L17;

            if((signed int)cmd == 3)
              goto __CPROVER_DUMP_L62;

            if((signed int)cmd == 4)
              goto __CPROVER_DUMP_L68;

            if((signed int)cmd == 5)
              goto __CPROVER_DUMP_L84;

            if((signed int)cmd == 6)
              goto __CPROVER_DUMP_L106;

            if((signed int)cmd == 7)
              goto __CPROVER_DUMP_L118;

            if((signed int)cmd == 8)
              goto __CPROVER_DUMP_L123;

            if((signed int)cmd == 9)
              goto __CPROVER_DUMP_L128;

            if((signed int)cmd == 10)
              goto __CPROVER_DUMP_L133;

            if((signed int)cmd == 11)
              goto __CPROVER_DUMP_L152;

          }

          else
          {
            struct utsname nm;
            if(!(debug_p == 0))
              debug_msg(0, "Received STATUS query.\n");

            signed int return_value_print_succ_5;
            return_value_print_succ_5=print_succ(rs);
            if(return_value_print_succ_5 == 0)
              goto __CPROVER_DUMP_L172;

            uname(&nm);
            signed int return_value_fsprintf_8;
            return_value_fsprintf_8=fsprintf(rs, "pdnsd-%s running on %s.\n", (const void *)"1.2.9a-par", (const void *)nm.nodename);
            _Bool tmp_if_expr_10;
            if(!(return_value_fsprintf_8 >= 0))
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              return_value_report_cache_stat_9=report_cache_stat(rs);
              tmp_if_expr_10 = return_value_report_cache_stat_9 < 0 ? (_Bool)1 : (_Bool)0;
            }
            _Bool tmp_if_expr_12;
            if(tmp_if_expr_10)
              tmp_if_expr_12 = (_Bool)1;

            else
            {
              return_value_report_thread_stat_11=report_thread_stat(rs);
              tmp_if_expr_12 = return_value_report_thread_stat_11 < 0 ? (_Bool)1 : (_Bool)0;
            }
            _Bool tmp_if_expr_14;
            if(tmp_if_expr_12)
              tmp_if_expr_14 = (_Bool)1;

            else
            {
              return_value_report_conf_stat_13=report_conf_stat(rs);
              tmp_if_expr_14 = return_value_report_conf_stat_13 < 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_14)
            {
              if(!(debug_p == 0))
              {
                return_value___errno_location_6=__errno_location();
                return_value_strerror_7=strerror(*return_value___errno_location_6);
                debug_msg(0, "Error writing to control socket: %s\nFailed to send status report.\n", return_value_strerror_7);
              }

            }

            goto __CPROVER_DUMP_L172;

          __CPROVER_DUMP_L17:
            ;
            char *label;
            char *dnsaddr;
            signed int indx;
            unsigned short int cmd2;
            if(!(debug_p == 0))
              debug_msg(0, "Received SERVER command.\n");

            signed int return_value_read_allocstring_15;
            return_value_read_allocstring_15=read_allocstring(rs, &label, (unsigned int *)(void *)0);
            if(!(return_value_read_allocstring_15 >= 1))
            {
              print_serr(rs, "Error reading server label.");
              goto __CPROVER_DUMP_L172;
            }

            signed int return_value_read_short_16;
            return_value_read_short_16=read_short(rs, &cmd2);
            if(return_value_read_short_16 == 0)
              print_serr(rs, "Missing up|down|retest.");

            else
            {
              return_value_read_allocstring_17=read_allocstring(rs, &dnsaddr, (unsigned int *)(void *)0);
              if(return_value_read_allocstring_17 == 0)
                print_serr(rs, "Error reading DNS addresses.");

              else
              {
                char *endptr;
                signed long int return_value_strtol_18;
                return_value_strtol_18=strtol(label, &endptr, 0);
                indx = (signed int)return_value_strtol_18;
                if(*endptr == 0)
                {
                  _Bool tmp_if_expr_20;
                  if(!(indx >= 0))
                    tmp_if_expr_20 = (_Bool)1;

                  else
                  {
                    return_value_da_nel_19=da_nel_link4((struct anonymous_3 *)servers);
                    tmp_if_expr_20 = (unsigned int)indx >= return_value_da_nel_19 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_20)
                  {
                    print_serr(rs, "Server index out of range.");
                    goto free_dnsaddr_label_break;
                  }

                }

                else
                {
                  signed int return_value_strcmp_21;
                  return_value_strcmp_21=strcmp(label, "all");
                  if(return_value_strcmp_21 == 0)
                    indx = -2;

                  else
                    indx = -1;
                }
                if((signed int)cmd2 == 1 || (signed int)cmd2 == 2 || (signed int)cmd2 == 3)
                {
                  if(dnsaddr == ((char *)NULL))
                  {
                    if(indx == -1)
                    {
                      signed int i = 0;
                      do
                      {
                        return_value_da_nel_22=da_nel_link4((struct anonymous_3 *)servers);
                        if((unsigned int)i >= return_value_da_nel_22)
                          break;

                        char *servlabel = servers->elem[(signed long int)i].label;
                        if(!(servlabel == ((char *)NULL)))
                        {
                          return_value_strcmp_23=strcmp(servlabel, label);
                          if(return_value_strcmp_23 == 0)
                            goto found_label;

                        }

                        i = i + 1;
                      }
                      while((_Bool)1);
                      print_serr(rs, "Bad server label.");
                      goto free_dnsaddr_label_break;
                    }


                  found_label:
                    ;
                    signed int return_value_mark_servers_24;
                    return_value_mark_servers_24=mark_servers(indx, indx == -1 ? label : (char *)(void *)0, (signed int)cmd2 == 3 ? -1 : (signed int)((signed int)cmd2 == 1));
                    if(return_value_mark_servers_24 == 0)
                      print_succ(rs);

                    else
                      print_serr(rs, "Could not start up or signal server status thread.");
                  }

                  else
                  {
                    if(indx == -2)
                    {
                      print_serr(rs, "Can't use label \"all\" to change server addresses.");
                      goto free_dnsaddr_label_break;
                    }

                    if(indx == -1)
                    {
                      signed int status_thread__1__3__1__1__2__1__1__2__6__2__2__i = 0;
                      do
                      {
                        return_value_da_nel_25=da_nel_link4((struct anonymous_3 *)servers);
                        if((unsigned int)status_thread__1__3__1__1__2__1__1__2__6__2__2__i >= return_value_da_nel_25)
                          break;

                        char *status_thread__1__3__1__1__2__1__1__2__6__2__2__1__1__servlabel = servers->elem[(signed long int)status_thread__1__3__1__1__2__1__1__2__6__2__2__i].label;
                        if(!(status_thread__1__3__1__1__2__1__1__2__6__2__2__1__1__servlabel == ((char *)NULL)))
                        {
                          return_value_strcmp_26=strcmp(status_thread__1__3__1__1__2__1__1__2__6__2__2__1__1__servlabel, label);
                          if(return_value_strcmp_26 == 0)
                          {
                            if(!(indx == -1))
                            {
                              print_serr(rs, "server label must be unique to change server addresses.");
                              goto free_dnsaddr_label_break;
                            }

                            indx = status_thread__1__3__1__1__2__1__1__2__6__2__2__i;
                          }

                        }

                        status_thread__1__3__1__1__2__1__1__2__6__2__2__i = status_thread__1__3__1__1__2__1__1__2__6__2__2__i + 1;
                      }
                      while((_Bool)1);
                      if(indx == -1)
                      {
                        print_serr(rs, "Bad server label.");
                        goto free_dnsaddr_label_break;
                      }

                    }

                    char *ipstr;
                    char *q = dnsaddr;
                    struct anonymous_54 *ar = (struct anonymous_54 *)(void *)0;
                    union anonymous_6 addr;
                    signed int err;

                  __CPROVER_DUMP_L45:
                    ;
                    while(!(*q == 0))
                    {
                      if(!((signed int)*q == 44))
                      {
                        return_value___ctype_b_loc_27=__ctype_b_loc();
                        if((8192 & (signed int)(*return_value___ctype_b_loc_27)[(signed long int)(signed int)*q]) == 0)
                          goto __CPROVER_DUMP_L47;

                      }

                      q = q + 1l;
                      goto __CPROVER_DUMP_L45;

                    __CPROVER_DUMP_L47:
                      ;
                      ipstr = q;
                      do
                      {
                        q = q + 1l;
                        if(*q == 0)
                          break;

                        _Bool tmp_if_expr_30;
                        if((signed int)*q == 44)
                          tmp_if_expr_30 = (_Bool)1;

                        else
                        {
                          return_value___ctype_b_loc_29=__ctype_b_loc();
                          tmp_if_expr_30 = ((signed int)(*return_value___ctype_b_loc_29)[(signed long int)(signed int)*q] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr_30)
                        {
                          char *tmp_post_28 = q;
                          q = q + 1l;
                          *tmp_post_28 = (char)0;
                          break;
                        }

                      }
                      while((_Bool)1);
                      signed int return_value_str2pdnsd_a_31;
                      return_value_str2pdnsd_a_31=str2pdnsd_a(ipstr, &addr);
                      if(return_value_str2pdnsd_a_31 == 0)
                      {
                        print_serr(rs, "Bad server ip");
                        goto free_ar;
                      }

                      struct anonymous_3 *return_value_da_grow1_32;
                      return_value_da_grow1_32=da_grow1((struct anonymous_3 *)ar, (unsigned long int)((struct anonymous_54 *)0)->elem, sizeof(union anonymous_6) /*16ul*/ , (void (*)(void *))(void *)0);
                      ar = (struct anonymous_54 *)return_value_da_grow1_32;
                      if(ar == ((struct anonymous_54 *)NULL))
                      {
                        print_serr(rs, "Out of memory.");
                        goto free_dnsaddr_label_break;
                      }

                      ar->elem[(signed long int)(ar->nel - (unsigned long int)1)] = addr;
                    }

                  change_servs:
                    ;
                    err=change_servers(indx, ar, (signed int)cmd2 == 3 ? -1 : (signed int)((signed int)cmd2 == 1));
                    if(err == 0)
                      print_succ(rs);

                    else
                      print_serr(rs, err == 110 ? "Timed out while trying to gain access to server data." : (err == 12 ? "Out of memory." : "Could not start up or signal server status thread."));

                  free_ar:
                    ;
                    free((void *)ar);
                  }
                }

                else
                  print_serr(rs, "Bad command.");

              free_dnsaddr_label_break:
                ;
                free((void *)dnsaddr);
              }
            }

          free_label_break:
            ;
            free((void *)label);
            goto __CPROVER_DUMP_L172;

          __CPROVER_DUMP_L62:
            ;
            unsigned short int status_thread__1__3__1__1__2__1__1__3__cmd2;
            unsigned char name[256l];
            unsigned char buf[256l];
            if(!(debug_p == 0))
              debug_msg(0, "Received RECORD command.\n");

            signed int return_value_read_short_33;
            return_value_read_short_33=read_short(rs, &status_thread__1__3__1__1__2__1__1__3__cmd2);
            if(!(return_value_read_short_33 == 0))
            {
              signed int return_value_read_domain_34;
              return_value_read_domain_34=read_domain(rs, (char *)buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
              if(return_value_read_domain_34 >= 1)
              {
                errmsg=parsestr2rhn(buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , name);
                if(!(errmsg == ((const char *)NULL)))
                  goto bad_domain_name;

                switch((signed int)status_thread__1__3__1__1__2__1__1__3__cmd2)
                {
                  case 1:
                  {
                    del_cache(name);
                    print_succ(rs);
                    break;
                  }
                  case 2:
                  {
                    invalidate_record(name);
                    print_succ(rs);
                    break;
                  }
                  default:
                    print_serr(rs, "Bad command.");
                }
                goto __CPROVER_DUMP_L172;

              __CPROVER_DUMP_L68:
                ;
                unsigned int ttl;
                char *fn;
                unsigned short int servaliases;
                unsigned short int flags;
                unsigned char status_thread__1__3__1__1__2__1__1__4__buf[256l];
                unsigned char owner[256l];
                if(!(debug_p == 0))
                  debug_msg(0, "Received SOURCE command.\n");

                signed int return_value_read_allocstring_35;
                return_value_read_allocstring_35=read_allocstring(rs, &fn, (unsigned int *)(void *)0);
                if(!(return_value_read_allocstring_35 >= 1))
                {
                  print_serr(rs, "Bad filename name.");
                  goto __CPROVER_DUMP_L172;
                }

                signed int return_value_read_domain_36;
                return_value_read_domain_36=read_domain(rs, (char *)status_thread__1__3__1__1__2__1__1__4__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                _Bool tmp_if_expr_38;
                if(!(return_value_read_domain_36 >= 1))
                  tmp_if_expr_38 = (_Bool)1;

                else
                {
                  return_value_read_long_37=read_long(rs, &ttl);
                  tmp_if_expr_38 = !(return_value_read_long_37 != 0) ? (_Bool)1 : (_Bool)0;
                }
                _Bool tmp_if_expr_40;
                if(tmp_if_expr_38)
                  tmp_if_expr_40 = (_Bool)1;

                else
                {
                  return_value_read_short_39=read_short(rs, &servaliases);
                  tmp_if_expr_40 = !(return_value_read_short_39 != 0) ? (_Bool)1 : (_Bool)0;
                }
                _Bool tmp_if_expr_42;
                if(tmp_if_expr_40)
                  tmp_if_expr_42 = (_Bool)1;

                else
                {
                  return_value_read_short_41=read_short(rs, &flags);
                  tmp_if_expr_42 = !(return_value_read_short_41 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_42)
                  print_serr(rs, "Malformed or incomplete command.");

                else
                {
                  errmsg=parsestr2rhn(status_thread__1__3__1__1__2__1__1__4__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , owner);
                  if(!(errmsg == ((const char *)NULL)))
                    print_serr(rs, errmsg);

                  else
                    if(!((1 & (signed int)flags) == 0))
                      print_serr(rs, "Bad cache flags.");

                    else
                    {
                      char *status_thread__1__3__1__1__2__1__1__4__7__errmsg;
                      signed int return_value_read_hosts_43;
                      return_value_read_hosts_43=read_hosts(fn, owner, (signed long int)ttl, (unsigned int)flags, (signed int)servaliases, &status_thread__1__3__1__1__2__1__1__4__7__errmsg);
                      if(!(return_value_read_hosts_43 == 0))
                        print_succ(rs);

                      else
                      {
                        print_serr(rs, (_Bool)status_thread__1__3__1__1__2__1__1__4__7__errmsg ? status_thread__1__3__1__1__2__1__1__4__7__errmsg : "Out of memory.");
                        free((void *)status_thread__1__3__1__1__2__1__1__4__7__errmsg);
                      }
                    }
                }

              free_fn:
                ;
                free((void *)fn);
                goto __CPROVER_DUMP_L172;

              __CPROVER_DUMP_L84:
                ;
                unsigned int status_thread__1__3__1__1__2__1__1__5__ttl;
                unsigned int sz;
                unsigned short int tp;
                unsigned short int status_thread__1__3__1__1__2__1__1__5__flags;
                unsigned short int nadr = (unsigned short int)0;
                unsigned char status_thread__1__3__1__1__2__1__1__5__name[256l];
                unsigned char status_thread__1__3__1__1__2__1__1__5__buf[256l];
                unsigned char dbuf[258l];
                unsigned long int adrbufsz = (unsigned long int)0;
                unsigned char *adrbuf = (unsigned char *)(void *)0;
                if(!(debug_p == 0))
                  debug_msg(0, "Received ADD command.\n");

                signed int return_value_read_short_44;
                return_value_read_short_44=read_short(rs, &tp);
                if(!(return_value_read_short_44 == 0))
                {
                  signed int return_value_read_domain_45;
                  return_value_read_domain_45=read_domain(rs, (char *)status_thread__1__3__1__1__2__1__1__5__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                  if(return_value_read_domain_45 >= 1)
                  {
                    signed int return_value_read_long_46;
                    return_value_read_long_46=read_long(rs, &status_thread__1__3__1__1__2__1__1__5__ttl);
                    if(!(return_value_read_long_46 == 0))
                    {
                      signed int return_value_read_short_47;
                      return_value_read_short_47=read_short(rs, &status_thread__1__3__1__1__2__1__1__5__flags);
                      if(!(return_value_read_short_47 == 0))
                      {
                        errmsg=parsestr2rhn(status_thread__1__3__1__1__2__1__1__5__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , status_thread__1__3__1__1__2__1__1__5__name);
                        if(!(errmsg == ((const char *)NULL)))
                          goto bad_domain_name;

                        if(!((1 & (signed int)status_thread__1__3__1__1__2__1__1__5__flags) == 0))
                          goto bad_flags;

                        if(!((signed int)tp == 1))
                        {
                          if((signed int)tp == 28)
                            goto __CPROVER_DUMP_L87;

                          if((signed int)tp == 2 || (signed int)tp == 5 || (signed int)tp == 12)
                            goto __CPROVER_DUMP_L92;

                          if((signed int)tp == 15)
                            goto __CPROVER_DUMP_L93;

                        }

                        else
                        {
                          sz = (unsigned int)sizeof(struct in_addr) /*4ul*/ ;
                          goto read_adress_list;

                        __CPROVER_DUMP_L87:
                          ;
                          sz = (unsigned int)sizeof(struct in6_addr) /*16ul*/ ;

                        read_adress_list:
                          ;
                          return_value_read_short_48=read_short(rs, &nadr);
                          if(return_value_read_short_48 == 0)
                            goto incomplete_command;

                          if(nadr == 0)
                            goto bad_arg;

                          adrbufsz = (unsigned long int)nadr * (unsigned long int)sz;
                          return_value_malloc_49=malloc(adrbufsz);
                          adrbuf = (unsigned char *)return_value_malloc_49;
                          if(adrbuf == ((unsigned char *)NULL))
                            goto out_of_memory;

                          unsigned long int nread = (unsigned long int)0;
                          while(!(nread >= adrbufsz))
                          {
                            signed long int m;
                            m=read(rs, (void *)(adrbuf + (signed long int)nread), adrbufsz - nread);
                            if(!(m >= 1l))
                            {
                              free((void *)adrbuf);
                              goto bad_arg;
                            }

                            nread = nread + (unsigned long int)m;
                          }
                          goto __CPROVER_DUMP_L95;

                        __CPROVER_DUMP_L92:
                          ;
                          return_value_read_domain_50=read_domain(rs, (char *)status_thread__1__3__1__1__2__1__1__5__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                          if(!(return_value_read_domain_50 >= 1))
                            goto incomplete_command;

                          errmsg=parsestr2rhn(status_thread__1__3__1__1__2__1__1__5__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , dbuf);
                          if(!(errmsg == ((const char *)NULL)))
                            goto bad_domain_name;

                          sz=rhnlen_link5(dbuf);
                          goto __CPROVER_DUMP_L95;

                        __CPROVER_DUMP_L93:
                          ;
                          return_value_read_51=read(rs, (void *)dbuf, (unsigned long int)2);
                          if(!(return_value_read_51 == 2l))
                            goto bad_arg;

                          return_value_read_domain_52=read_domain(rs, (char *)status_thread__1__3__1__1__2__1__1__5__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                          if(!(return_value_read_domain_52 >= 1))
                            goto incomplete_command;

                          errmsg=parsestr2rhn(status_thread__1__3__1__1__2__1__1__5__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , dbuf + (signed long int)2);
                          if(!(errmsg == ((const char *)NULL)))
                            goto bad_domain_name;

                          return_value_rhnlen_53=rhnlen_link5(dbuf + (signed long int)2);
                          sz = return_value_rhnlen_53 + (unsigned int)2;
                          goto __CPROVER_DUMP_L95;
                        }
                        goto bad_arg;

                      __CPROVER_DUMP_L95:
                        ;
                        struct anonymous_0 cent;
                        signed int return_value_init_cent_54;
                        return_value_init_cent_54=init_cent(&cent, status_thread__1__3__1__1__2__1__1__5__name, (signed long int)0, (signed long int)0, (unsigned int)status_thread__1__3__1__1__2__1__1__5__flags);
                        if(return_value_init_cent_54 == 0)
                        {
                          free((void *)adrbuf);
                          goto out_of_memory;
                        }

                        if(!(adrbuf == ((unsigned char *)NULL)))
                        {
                          unsigned char *adrp;
                          signed int status_thread__1__3__1__1__2__1__1__5__3__2__i;
                          adrp = adrbuf;
                          status_thread__1__3__1__1__2__1__1__5__3__2__i = 0;
                          for( ; !(status_thread__1__3__1__1__2__1__1__5__3__2__i >= (signed int)nadr); status_thread__1__3__1__1__2__1__1__5__3__2__i = status_thread__1__3__1__1__2__1__1__5__3__2__i + 1)
                          {
                            signed int return_value_add_cent_rr_55;
                            return_value_add_cent_rr_55=add_cent_rr(&cent, (signed int)tp, (signed long int)status_thread__1__3__1__1__2__1__1__5__ttl, (signed long int)0, (unsigned int)2, sz, (void *)adrp);
                            if(return_value_add_cent_rr_55 == 0)
                            {
                              free_cent(&cent);
                              free((void *)adrbuf);
                              goto out_of_memory;
                            }

                            adrp = adrp + (signed long int)sz;
                          }
                          free((void *)adrbuf);
                        }

                        else
                        {
                          return_value_add_cent_rr_56=add_cent_rr(&cent, (signed int)tp, (signed long int)status_thread__1__3__1__1__2__1__1__5__ttl, (signed long int)0, (unsigned int)2, sz, (void *)dbuf);
                          if(return_value_add_cent_rr_56 == 0)
                          {
                            free_cent(&cent);
                            goto out_of_memory;
                          }

                        }
                        if((signed int)*cent.qname == 1)
                        {
                          if((signed int)cent.qname[1l] == 42)
                          {
                            signed int return_value_set_cent_flags_57;
                            return_value_set_cent_flags_57=set_cent_flags(&cent.qname[(signed long int)2], (unsigned int)16);
                            if(return_value_set_cent_flags_57 == 0)
                            {
                              print_serr(rs, "Before defining records for a name with a wildcard you must first define some records for the name with '*.' removed.");
                              goto cleanup_cent;
                            }

                          }

                        }

                        add_cache(&cent);
                        print_succ(rs);

                      cleanup_cent:
                        ;
                        free_cent(&cent);
                        goto __CPROVER_DUMP_L172;

                      __CPROVER_DUMP_L106:
                        ;
                        unsigned int status_thread__1__3__1__1__2__1__1__6__ttl;
                        unsigned short int status_thread__1__3__1__1__2__1__1__6__tp;
                        unsigned char status_thread__1__3__1__1__2__1__1__6__name[256l];
                        unsigned char status_thread__1__3__1__1__2__1__1__6__buf[256l];
                        if(!(debug_p == 0))
                          debug_msg(0, "Received NEG command.\n");

                        signed int return_value_read_domain_58;
                        return_value_read_domain_58=read_domain(rs, (char *)status_thread__1__3__1__1__2__1__1__6__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
                        if(return_value_read_domain_58 >= 1)
                        {
                          signed int return_value_read_short_59;
                          return_value_read_short_59=read_short(rs, &status_thread__1__3__1__1__2__1__1__6__tp);
                          if(!(return_value_read_short_59 == 0))
                          {
                            signed int return_value_read_long_60;
                            return_value_read_long_60=read_long(rs, &status_thread__1__3__1__1__2__1__1__6__ttl);
                            if(!(return_value_read_long_60 == 0))
                            {
                              errmsg=parsestr2rhn(status_thread__1__3__1__1__2__1__1__6__buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ , status_thread__1__3__1__1__2__1__1__6__name);
                              if(!(errmsg == ((const char *)NULL)))
                              {
                                if(!(debug_p == 0))
                                  debug_msg(0, "NEG: received bad domain name.\n");

                                goto bad_domain_name;
                              }

                              if(!((signed int)status_thread__1__3__1__1__2__1__1__6__tp == 255))
                              {
                                _Bool tmp_if_expr_61;
                                if((signed int)status_thread__1__3__1__1__2__1__1__6__tp >= 52 || !((signed int)status_thread__1__3__1__1__2__1__1__6__tp >= 1))
                                  tmp_if_expr_61 = (_Bool)1;

                                else
                                  tmp_if_expr_61 = (signed int)rrlkuptab[(signed long int)((signed int)status_thread__1__3__1__1__2__1__1__6__tp - 1)] >= 47 ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr_61)
                                {
                                  if(!(debug_p == 0))
                                    debug_msg(0, "NEG: received bad record type.\n");

                                  print_serr(rs, "Bad record type.");
                                  goto __CPROVER_DUMP_L172;
                                }

                              }

                              struct anonymous_0 status_thread__1__3__1__1__2__1__1__6__4__cent;
                              if((signed int)status_thread__1__3__1__1__2__1__1__6__tp == 255)
                              {
                                signed int return_value_init_cent_62;
                                return_value_init_cent_62=init_cent(&status_thread__1__3__1__1__2__1__1__6__4__cent, status_thread__1__3__1__1__2__1__1__6__name, (signed long int)status_thread__1__3__1__1__2__1__1__6__ttl, (signed long int)0, (unsigned int)(2 | 1));
                                if(return_value_init_cent_62 == 0)
                                  goto out_of_memory;

                              }

                              else
                              {
                                signed int return_value_init_cent_63;
                                return_value_init_cent_63=init_cent(&status_thread__1__3__1__1__2__1__1__6__4__cent, status_thread__1__3__1__1__2__1__1__6__name, (signed long int)0, (signed long int)0, (unsigned int)0);
                                if(return_value_init_cent_63 == 0)
                                  goto out_of_memory;

                                signed int return_value_add_cent_rrset_by_type_64;
                                return_value_add_cent_rrset_by_type_64=add_cent_rrset_by_type(&status_thread__1__3__1__1__2__1__1__6__4__cent, (signed int)status_thread__1__3__1__1__2__1__1__6__tp, (signed long int)status_thread__1__3__1__1__2__1__1__6__ttl, (signed long int)0, (unsigned int)(2 | 1));
                                if(return_value_add_cent_rrset_by_type_64 == 0)
                                {
                                  free_cent(&status_thread__1__3__1__1__2__1__1__6__4__cent);
                                  goto out_of_memory;
                                }

                              }
                              add_cache(&status_thread__1__3__1__1__2__1__1__6__4__cent);
                              free_cent(&status_thread__1__3__1__1__2__1__1__6__4__cent);
                              print_succ(rs);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L118:
                              ;
                              char *status_thread__1__3__1__1__2__1__1__7__fn;
                              char *status_thread__1__3__1__1__2__1__1__7__errmsg;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received CONFIG command.\n");

                              signed int return_value_read_allocstring_65;
                              return_value_read_allocstring_65=read_allocstring(rs, &status_thread__1__3__1__1__2__1__1__7__fn, (unsigned int *)(void *)0);
                              if(return_value_read_allocstring_65 == 0)
                              {
                                print_serr(rs, "Bad filename name.");
                                goto __CPROVER_DUMP_L172;
                              }

                              signed int return_value_reload_config_file_66;
                              return_value_reload_config_file_66=reload_config_file(status_thread__1__3__1__1__2__1__1__7__fn, &status_thread__1__3__1__1__2__1__1__7__errmsg);
                              if(!(return_value_reload_config_file_66 == 0))
                                print_succ(rs);

                              else
                              {
                                print_serr(rs, (_Bool)status_thread__1__3__1__1__2__1__1__7__errmsg ? status_thread__1__3__1__1__2__1__1__7__errmsg : "Out of memory.");
                                free((void *)status_thread__1__3__1__1__2__1__1__7__errmsg);
                              }
                              free((void *)status_thread__1__3__1__1__2__1__1__7__fn);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L123:
                              ;
                              char *status_thread__1__3__1__1__2__1__1__8__fn;
                              char *status_thread__1__3__1__1__2__1__1__8__errmsg;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received INCLUDE command.\n");

                              signed int return_value_read_allocstring_67;
                              return_value_read_allocstring_67=read_allocstring(rs, &status_thread__1__3__1__1__2__1__1__8__fn, (unsigned int *)(void *)0);
                              if(!(return_value_read_allocstring_67 >= 1))
                              {
                                print_serr(rs, "Bad filename name.");
                                goto __CPROVER_DUMP_L172;
                              }

                              signed int return_value_read_config_file_68;
                              return_value_read_config_file_68=read_config_file(status_thread__1__3__1__1__2__1__1__8__fn, (struct anonymous_21 *)(void *)0, (struct anonymous_18 **)(void *)0, 0, &status_thread__1__3__1__1__2__1__1__8__errmsg);
                              if(!(return_value_read_config_file_68 == 0))
                                print_succ(rs);

                              else
                              {
                                print_serr(rs, (_Bool)status_thread__1__3__1__1__2__1__1__8__errmsg ? status_thread__1__3__1__1__2__1__1__8__errmsg : "Out of memory.");
                                free((void *)status_thread__1__3__1__1__2__1__1__8__errmsg);
                              }
                              free((void *)status_thread__1__3__1__1__2__1__1__8__fn);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L128:
                              ;
                              char *str;
                              char *status_thread__1__3__1__1__2__1__1__9__errmsg;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received EVAL command.\n");

                              signed int return_value_read_allocstring_69;
                              return_value_read_allocstring_69=read_allocstring(rs, &str, (unsigned int *)(void *)0);
                              if(return_value_read_allocstring_69 == 0)
                              {
                                print_serr(rs, "Bad input string.");
                                goto __CPROVER_DUMP_L172;
                              }

                              signed int return_value_confparse_70;
                              return_value_confparse_70=confparse((struct _IO_FILE *)(void *)0, str, (struct anonymous_21 *)(void *)0, (struct anonymous_18 **)(void *)0, 0, &status_thread__1__3__1__1__2__1__1__9__errmsg);
                              if(!(return_value_confparse_70 == 0))
                                print_succ(rs);

                              else
                              {
                                print_serr(rs, (_Bool)status_thread__1__3__1__1__2__1__1__9__errmsg ? status_thread__1__3__1__1__2__1__1__9__errmsg : "Out of memory.");
                                free((void *)status_thread__1__3__1__1__2__1__1__9__errmsg);
                              }
                              free((void *)str);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L133:
                              ;
                              struct anonymous_8 *sla = (struct anonymous_8 *)(void *)0;
                              char *names;
                              unsigned int len;
                              if(!(debug_p == 0))
                                debug_msg(0, "Received EMPTY command.\n");

                              signed int return_value_read_allocstring_71;
                              return_value_read_allocstring_71=read_allocstring(rs, &names, &len);
                              if(return_value_read_allocstring_71 == 0)
                              {
                                print_serr(rs, "Bad arguments.");
                                goto __CPROVER_DUMP_L172;
                              }

                              if(!(names == ((char *)NULL)))
                              {
                                char *p = names;
                                char *last = names + (signed long int)len;
                                while(!(p >= last))
                                {
                                  signed int status_thread__1__3__1__1__2__1__1__10__3__1__tp;
                                  char *status_thread__1__3__1__1__2__1__1__10__3__1__q;
                                  struct anonymous_9 *sl;
                                  unsigned int status_thread__1__3__1__1__2__1__1__10__3__1__sz;
                                  unsigned char rhn[256l];
                                  if((signed int)*p == 45)
                                  {
                                    status_thread__1__3__1__1__2__1__1__10__3__1__tp = 19;
                                    p = p + 1l;
                                  }

                                  else
                                  {
                                    status_thread__1__3__1__1__2__1__1__10__3__1__tp = 18;
                                    if((signed int)*p == 43)
                                      p = p + 1l;

                                  }
                                  if(!(p + 1l >= last))
                                  {
                                    if((signed int)*p == 46)
                                    {
                                      if(!(p[1l] == 0))
                                        p = p + 1l;

                                    }

                                  }

                                  status_thread__1__3__1__1__2__1__1__10__3__1__q = p;
                                  for( ; !(status_thread__1__3__1__1__2__1__1__10__3__1__q >= last); status_thread__1__3__1__1__2__1__1__10__3__1__q = status_thread__1__3__1__1__2__1__1__10__3__1__q + 1l)
                                    if(*status_thread__1__3__1__1__2__1__1__10__3__1__q == 0)
                                      break;

                                  errmsg=parsestr2rhn((unsigned char *)p, (unsigned int)(status_thread__1__3__1__1__2__1__1__10__3__1__q - p), rhn);
                                  if(!(errmsg == ((const char *)NULL)))
                                  {
                                    if(!(debug_p == 0))
                                      debug_msg(0, "EMPTY: received bad domain name: %s\n", p);

                                    print_serr(rs, errmsg);
                                    goto free_sla_names_break;
                                  }

                                  status_thread__1__3__1__1__2__1__1__10__3__1__sz=rhnlen_link5(rhn);
                                  struct anonymous_3 *return_value_da_grow1_72;
                                  return_value_da_grow1_72=da_grow1((struct anonymous_3 *)sla, (unsigned long int)((struct anonymous_8 *)0)->elem, sizeof(struct anonymous_9) /*16ul*/ , free_slist_domain);
                                  sla = (struct anonymous_8 *)return_value_da_grow1_72;
                                  if(sla == ((struct anonymous_8 *)NULL))
                                  {
                                    print_serr(rs, "Out of memory.");
                                    goto free_names_break;
                                  }

                                  sl = &sla->elem[(signed long int)(sla->nel - (unsigned long int)1)];
                                  void *return_value_malloc_73;
                                  return_value_malloc_73=malloc((unsigned long int)status_thread__1__3__1__1__2__1__1__10__3__1__sz);
                                  sl->domain = (unsigned char *)return_value_malloc_73;
                                  if(sl->domain == ((unsigned char *)NULL))
                                  {
                                    print_serr(rs, "Out of memory.");
                                    goto free_sla_names_break;
                                  }

                                  memcpy((void *)sl->domain, (const void *)rhn, (unsigned long int)status_thread__1__3__1__1__2__1__1__10__3__1__sz);
                                  sl->exact = (signed short int)0;
                                  sl->rule = (signed short int)status_thread__1__3__1__1__2__1__1__10__3__1__tp;
                                  p = status_thread__1__3__1__1__2__1__1__10__3__1__q + (signed long int)1;
                                }
                              }

                              signed int return_value_empty_cache_74;
                              return_value_empty_cache_74=empty_cache(sla);
                              if(!(return_value_empty_cache_74 == 0))
                                print_succ(rs);

                              else
                                print_serr(rs, "Could not lock the cache.");

                            free_sla_names_break:
                              ;
                              free_slist_array(sla);

                            free_names_break:
                              ;
                              free((void *)names);
                              goto __CPROVER_DUMP_L172;

                            __CPROVER_DUMP_L152:
                              ;
                              signed int rv;
                              signed int exact = 0;
                              unsigned char *status_thread__1__3__1__1__2__1__1__11__nm = (unsigned char *)(void *)0;
                              char status_thread__1__3__1__1__2__1__1__11__buf[256l];
                              unsigned char status_thread__1__3__1__1__2__1__1__11__rhn[256l];
                              if(!(debug_p == 0))
                                debug_msg(0, "Received DUMP command.\n");

                              rv=read_domain(rs, status_thread__1__3__1__1__2__1__1__11__buf, (unsigned int)sizeof(char [256l]) /*256ul*/ );
                              if(rv == 0)
                              {
                                print_serr(rs, "Bad domain name.");
                                goto __CPROVER_DUMP_L172;
                              }

                              if(rv >= 1)
                              {
                                signed int status_thread__1__3__1__1__2__1__1__11__3__sz;
                                exact = 1;
                                status_thread__1__3__1__1__2__1__1__11__nm = (unsigned char *)status_thread__1__3__1__1__2__1__1__11__buf;
                                status_thread__1__3__1__1__2__1__1__11__3__sz = (signed int)sizeof(char [256l]) /*256ul*/ ;
                                if((signed int)status_thread__1__3__1__1__2__1__1__11__buf[0l] == 46)
                                {
                                  if(!(status_thread__1__3__1__1__2__1__1__11__buf[1l] == 0))
                                  {
                                    exact = 0;
                                    status_thread__1__3__1__1__2__1__1__11__nm = status_thread__1__3__1__1__2__1__1__11__nm + 1l;
                                    status_thread__1__3__1__1__2__1__1__11__3__sz = status_thread__1__3__1__1__2__1__1__11__3__sz - 1;
                                  }

                                }

                                errmsg=parsestr2rhn(status_thread__1__3__1__1__2__1__1__11__nm, (unsigned int)status_thread__1__3__1__1__2__1__1__11__3__sz, status_thread__1__3__1__1__2__1__1__11__rhn);
                                if(!(errmsg == ((const char *)NULL)))
                                  goto bad_domain_name;

                                status_thread__1__3__1__1__2__1__1__11__nm = status_thread__1__3__1__1__2__1__1__11__rhn;
                              }

                              signed int return_value_print_succ_75;
                              return_value_print_succ_75=print_succ(rs);
                              if(return_value_print_succ_75 == 0)
                                goto __CPROVER_DUMP_L172;

                              rv=dump_cache(rs, status_thread__1__3__1__1__2__1__1__11__nm, exact);
                              _Bool tmp_if_expr_81;
                              if(!(rv >= 0))
                                tmp_if_expr_81 = (_Bool)1;

                              else
                              {
                                if(rv == 0)
                                {
                                  if(!(status_thread__1__3__1__1__2__1__1__11__nm == ((unsigned char *)NULL)))
                                    tmp_if_expr_78 = status_thread__1__3__1__1__2__1__1__11__buf;

                                  else
                                    tmp_if_expr_78 = "";
                                  return_value_fsprintf_79=fsprintf(rs, "Could not find %s%s in the cache.\n", exact != 0 ? "" : (status_thread__1__3__1__1__2__1__1__11__nm != ((unsigned char *)NULL) ? "any entries matching " : "any entries"), tmp_if_expr_78);
                                  tmp_if_expr_80 = return_value_fsprintf_79 < 0 ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr_80 = (_Bool)0;
                                tmp_if_expr_81 = tmp_if_expr_80 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr_81)
                              {
                                if(!(debug_p == 0))
                                {
                                  return_value___errno_location_76=__errno_location();
                                  return_value_strerror_77=strerror(*return_value___errno_location_76);
                                  debug_msg(0, "Error writing to control socket: %s\n", return_value_strerror_77);
                                }

                              }

                              goto __CPROVER_DUMP_L172;
                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }


          incomplete_command:
            ;
            print_serr(rs, "Malformed or incomplete command.");
            goto __CPROVER_DUMP_L172;

          bad_arg:
            ;
            print_serr(rs, "Bad arg.");
            goto __CPROVER_DUMP_L172;

          bad_domain_name:
            ;
            print_serr(rs, errmsg);
            goto __CPROVER_DUMP_L172;

          bad_ttl:
            ;
            print_serr(rs, "Bad TTL.");
            goto __CPROVER_DUMP_L172;

          bad_flags:
            ;
            print_serr(rs, "Bad cache flags.");
            goto __CPROVER_DUMP_L172;

          out_of_memory:
            ;
            print_serr(rs, "Out of memory.");
            goto __CPROVER_DUMP_L172;
          }
          print_serr(rs, "Unknown command.");
        }

        else
        {
          if(!(debug_p == 0))
            debug_msg(0, "Incorrect magic number in status-socket command code: %02x\n", (signed int)cmd >> 8);

          print_serr(rs, "Command code contains incompatible version number.");
        }
      }

      else
      {
        if(!(debug_p == 0))
          debug_msg(0, "short status-socket query\n");

        print_serr(rs, "Command code missing or too short.");
      }

    __CPROVER_DUMP_L172:
      ;
      close(rs);
      usleep_r_link2((unsigned long int)100000);
    }

    else
    {
      return_value___errno_location_85=__errno_location();
      if(!(*return_value___errno_location_85 == 4))
      {
        signed int *return_value___errno_location_83;
        return_value___errno_location_83=__errno_location();
        char *return_value_strerror_84;
        return_value_strerror_84=strerror(*return_value___errno_location_83);
        log_message(4, "Failed to accept connection on status socket: %s. Status readback will be impossible", return_value_strerror_84);
        break;
      }

    }
  }
  while((_Bool)1);

exit_thread:
  ;
  stat_pipe = (signed short int)0;
  close(stat_sock);
  statsock_thrid = main_thrid;
  return (void *)0;
}

// statusif
// file netdev.c line 110
signed int statusif(char *name)
{
  struct anonymous_53 phone;
  signed int isdninfo;
  signed int rc = 0;
  isdninfo=open("/dev/isdninfo", 00);
  if(!(isdninfo >= 0))
  {
    isdn_errs = isdn_errs + 1ul;
    if(!(isdn_errs >= 3ul))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      log_message(4, "Could not open /dev/isdninfo for uptest: %s", return_value_strerror_2);
    }

    return 0;
  }

  else
  {
    strncp_link2(phone.name, name, sizeof(char [10l]) /*10ul*/ );
    signed int return_value_ioctl_3;
    return_value_ioctl_3=ioctl(isdninfo, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(73 << 0 + 8) | (unsigned int)(34 << 0) | (unsigned int)(0 << 0 + 8 + 8)), &phone);
    if(return_value_ioctl_3 == 0)
      rc = 1;

    close(isdninfo);
    return rc;
  }
}

// str2pdnsd_a
// file helpers.h line 156
signed int str2pdnsd_a(const char *addr, union anonymous_6 *a)
{
  if(!(run_ipv4 == 0))
  {
    signed int return_value_inet_aton_1;
    return_value_inet_aton_1=inet_aton(addr, &a->ipv4);
    return return_value_inet_aton_1;
  }

  else
  {
    struct in_addr a4;
    signed int return_value_inet_aton_2;
    return_value_inet_aton_2=inet_aton(addr, &a4);
    if(!(return_value_inet_aton_2 == 0))
    {
      a->ipv6 = global.ipv4_6_prefix;
      ((unsigned int *)&a->ipv6)[(signed long int)3] = a4.s_addr;
      return 1;
    }

    signed int return_value_inet_pton_3;
    return_value_inet_pton_3=inet_pton(10, addr, (void *)&a->ipv6);
    return (signed int)(return_value_inet_pton_3 > 0);
  }
}

// str2rhn
// file helpers.h line 53
signed int str2rhn(const unsigned char *str, unsigned char *rhn)
{
  unsigned int i;
  unsigned int j;
  _Bool tmp_if_expr_1;
  if((signed int)*str == 46)
  {
    if(!(str[1l] == 0))
      goto __CPROVER_DUMP_L1;

    rhn[(signed long int)0] = (unsigned char)0;
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    i = (unsigned int)0;
    do
    {
      unsigned int jlim = i + (unsigned int)63;
      if(jlim >= 255u)
        jlim = (unsigned int)(256 - 2);

      j = i;
      do
      {
        if(!(str[(signed long int)j] == 0))
          tmp_if_expr_1 = (signed int)str[(signed long int)j] != 46 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        if(j >= jlim)
          return 0;

        rhn[(signed long int)(j + (unsigned int)1)] = str[(signed long int)j];
        j = j + 1u;
      }
      while((_Bool)1);
      if(str[(signed long int)j] == 0)
        break;

      if(i >= j)
        return 0;

      rhn[(signed long int)i] = (unsigned char)(j - i);
      i = j + (unsigned int)1;
    }
    while((_Bool)1);
    rhn[(signed long int)i] = (unsigned char)0;
    if(i == 0u || !(i >= j))
      return 0;

    else
      return 1;
  }
}

// strncp
// file helpers.h line 234
static inline signed int strncp(char *dst, const char *src, unsigned long int dstsz)
{
  char *p;
  p=stpncpy(dst, src, dstsz);
  if(!(p >= dst + (signed long int)dstsz))
    return 1;

  else
  {
    *(p - (signed long int)1) = (char)0;
    return 0;
  }
}

// strncp_link1
// file helpers.h line 234
static inline signed int strncp_link1(char *dst_link1, const char *src_link1, unsigned long int dstsz_link1)
{
  char *p_link1;
  p_link1=stpncpy(dst_link1, src_link1, dstsz_link1);
  if(!(p_link1 >= dst_link1 + (signed long int)dstsz_link1))
    return 1;

  else
  {
    *(p_link1 - (signed long int)1) = (char)0;
    return 0;
  }
}

// strncp_link2
// file helpers.h line 234
static inline signed int strncp_link2(char *dst_link2, const char *src_link2, unsigned long int dstsz_link2)
{
  char *p_link2;
  p_link2=stpncpy(dst_link2, src_link2, dstsz_link2);
  if(!(p_link2 >= dst_link2 + (signed long int)dstsz_link2))
    return 1;

  else
  {
    *(p_link2 - (signed long int)1) = (char)0;
    return 0;
  }
}

// strtotime
// file conf-parser.c line 249
static signed long int strtotime(char *nptr, char **endptr, char **errstr)
{
  signed long int retval = (signed long int)0;
  signed long int t;
  char c;
  *errstr = (char *)(void *)0;
  const unsigned short int **return_value___ctype_b_loc_1;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    c = *nptr;
    if((8 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)c]) == 0)
      break;

    const unsigned short int **return_value___ctype_b_loc_2;
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)c]) == 0)
    {
      *errstr = "no digits before suffix.";
      break;
    }

    t=strtol(nptr, &nptr, 10);
    const unsigned short int **return_value___ctype_b_loc_3;
    return_value___ctype_b_loc_3=__ctype_b_loc();
    c = *nptr;
    if(!((1024 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)c]) == 0))
    {
      if(!((signed int)c == 115))
      {
        if((signed int)c == 109)
          t = t * (signed long int)60;

        else
          if((signed int)c == 104)
            t = t * (signed long int)(60 * 60);

          else
            if((signed int)c == 100)
              t = t * (signed long int)(24 * 60 * 60);

            else
              if((signed int)c == 119)
                t = t * (signed long int)(7 * 24 * 60 * 60);

              else
              {
                *errstr = "allowed suffixes are w,d,h,m,s.";
                break;
              }
      }

      nptr = nptr + 1l;
    }

    retval = retval + t;
  }
  while((_Bool)1);
  if(!(endptr == ((char **)NULL)))
    *endptr = nptr;

  return retval;
}

// sva_add
// file dns_answer.c line 149
static signed int sva_add(struct _dynamic_list_head **sva, const unsigned char *rhn, unsigned short int tp, unsigned short int dlen, void *data)
{
  if(!(sva == ((struct _dynamic_list_head **)NULL)))
  {
    unsigned long int rlen;
    unsigned int return_value_rhnlen_1;
    return_value_rhnlen_1=rhnlen_link2(rhn);
    rlen = (unsigned long int)return_value_rhnlen_1;
    struct anonymous_71 *st;
    *sva=dlist_grow(*sva, sizeof(struct anonymous_71) /*4ul*/  + rlen + (unsigned long int)dlen);
    if(*sva == ((struct _dynamic_list_head *)NULL))
      return 0;

    void *return_value_dlist_last_2;
    return_value_dlist_last_2=dlist_last_link1(*sva);
    st = (struct anonymous_71 *)return_value_dlist_last_2;
    st->tp = tp;
    st->dlen = dlen;
    void *return_value_mempcpy_3;
    return_value_mempcpy_3=mempcpy((void *)st->nm, (const void *)rhn, rlen);
    memcpy(return_value_mempcpy_3, data, (unsigned long int)dlen);
  }

  return 1;
}

// switch_to_tcp
// file dns_query.c line 814
static inline void switch_to_tcp(struct anonymous_5 *st)
{
  st->qm = (signed short int)13;
  st->state = (signed short int)0;
  st->failed = (char)0;
}

// switch_to_udp
// file dns_query.c line 803
static inline void switch_to_udp(struct anonymous_5 *st)
{
  st->qm = (signed short int)12;
  st->myrid=get_rand16();
  st->msg->hdr.id=htons(st->myrid);
  st->state = (signed short int)4;
}

// tcp_answer_thread
// file dns_answer.c line 1811
static void * tcp_answer_thread(void *csock)
{
  signed int sock = *((signed int *)csock);
  unsigned int thrid;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  signed int *return_value___errno_location_11;
  char *return_value_strerror_12;
  signed int *return_value___errno_location_15;
  char *return_value_strerror_16;
  do
  {
    struct anonymous_66 __cancel_buf;
    void (*__cancel_routine)(void *) = tcp_answer_thread_cleanup;
    void *__cancel_arg = csock;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      if(global.strict_suid == 0)
      {
        signed int return_value_run_as_1;
        return_value_run_as_1=run_as(global.run_as);
        if(return_value_run_as_1 == 0)
          pdnsd_exit();

      }

      do
      {
        pthread_mutex_lock(&proc_lock);
        if(!(procs >= global.proc_limit))
          break;

        pthread_mutex_unlock(&proc_lock);
        usleep_r((unsigned long int)50000);
      }
      while((_Bool)1);
      procs = procs + 1;
      thrid_cnt = thrid_cnt + 1u;
      thrid = thrid_cnt;
      pthread_mutex_unlock(&proc_lock);
      if(!(debug_p == 0))
      {
        signed int tcp_answer_thread__1__1__2__3__err;
        tcp_answer_thread__1__1__2__3__err=pthread_setspecific(thrid_key, (const void *)&thrid);
        if(!(tcp_answer_thread__1__1__2__3__err == 0))
        {
          da_misc_errs = da_misc_errs + 1ul;
          if(!(da_misc_errs >= 11ul))
          {
            return_value_strerror_2=strerror(tcp_answer_thread__1__1__2__3__err);
            log_message(3, "pthread_setspecific failed: %s", return_value_strerror_2);
          }

        }

      }

      signed int rlen;
      signed int olen;
      unsigned long int nlen;
      unsigned char *buf;
      struct anonymous_28 *resp;
      struct pollfd pfd;
      pfd.fd = sock;
      pfd.events = (signed short int)0x001;
      signed int return_value_poll_3;
      return_value_poll_3=poll(&pfd, (unsigned long int)1, (signed int)(global.tcp_qtimeout * (signed long int)1000));
      if(!(return_value_poll_3 >= 1))
        pthread_exit((void *)0);

      signed long int err;
      unsigned short int rlen_net;
      err=read(sock, (void *)&rlen_net, sizeof(unsigned short int) /*2ul*/ );
      if(!((unsigned long int)err == sizeof(unsigned short int) /*2ul*/ ))
      {
        if(!(debug_p == 0))
        {
          char *tmp_if_expr_6;
          if(err == -1l)
          {
            return_value___errno_location_4=__errno_location();
            return_value_strerror_5=strerror(*return_value___errno_location_4);
            tmp_if_expr_6 = return_value_strerror_5;
          }

          else
            tmp_if_expr_6 = "incomplete data";
          debug_msg(0, "Error while reading from TCP client: %s\n", tmp_if_expr_6);
        }

        pthread_exit((void *)0);
      }

      unsigned short int return_value_ntohs_7;
      return_value_ntohs_7=ntohs(rlen_net);
      rlen = (signed int)return_value_ntohs_7;
      if(rlen == 0)
      {
        log_message(3, "TCP zero size query received.\n");
        pthread_exit((void *)0);
      }

      void *return_value_malloc_8;
      return_value_malloc_8=malloc((unsigned long int)rlen);
      buf = (unsigned char *)return_value_malloc_8;
      if(buf == ((unsigned char *)NULL))
      {
        da_mem_errs = da_mem_errs + 1ul;
        if(!(da_mem_errs >= 11ul))
          log_message(3, "Out of memory in request handling.");

        pthread_exit((void *)0);
      }

      do
      {
        struct anonymous_66 tcp_answer_thread__1__1__2__4__4____cancel_buf;
        void (*tcp_answer_thread__1__1__2__4__4____cancel_routine)(void *) = free;
        void *tcp_answer_thread__1__1__2__4__4____cancel_arg = (void *)buf;
        signed int tcp_answer_thread__1__1__2__4__4____not_first_call;
        tcp_answer_thread__1__1__2__4__4____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)tcp_answer_thread__1__1__2__4__4____cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)tcp_answer_thread__1__1__2__4__4____not_first_call == 0l))
        {
          tcp_answer_thread__1__1__2__4__4____cancel_routine(tcp_answer_thread__1__1__2__4__4____cancel_arg);
          __pthread_unwind_next(&tcp_answer_thread__1__1__2__4__4____cancel_buf);
        }

        __pthread_register_cancel(&tcp_answer_thread__1__1__2__4__4____cancel_buf);
        do
        {
          olen = 0;
          while(!(olen >= rlen))
          {
            signed int rv;
            pfd.fd = sock;
            pfd.events = (signed short int)0x001;
            signed int return_value_poll_9;
            return_value_poll_9=poll(&pfd, (unsigned long int)1, (signed int)(global.tcp_qtimeout * (signed long int)1000));
            if(!(return_value_poll_9 >= 1))
              pthread_exit((void *)0);

            signed long int return_value_read_10;
            return_value_read_10=read(sock, (void *)(buf + (signed long int)olen), (unsigned long int)(rlen - olen));
            rv = (signed int)return_value_read_10;
            if(!(rv >= 1))
            {
              if(!(debug_p == 0))
              {
                char *tmp_if_expr_13;
                if(rv == -1)
                {
                  return_value___errno_location_11=__errno_location();
                  return_value_strerror_12=strerror(*return_value___errno_location_11);
                  tmp_if_expr_13 = return_value_strerror_12;
                }

                else
                  tmp_if_expr_13 = "incomplete data";
                debug_msg(0, "Error while reading from TCP client: %s\n", tmp_if_expr_13);
              }

              if(olen >= 2)
              {
                struct anonymous_28 tcp_answer_thread__1__1__2__4__4__2__1__1__2__err;
                signed int tmp_if_expr_14;
                if(olen >= 3)
                  tmp_if_expr_14 = (signed int)((struct anonymous_29 *)buf)->opcode;

                else
                  tmp_if_expr_14 = 0;
                mk_error_reply(((struct anonymous_29 *)buf)->id, (unsigned short int)tmp_if_expr_14, (unsigned short int)1, &tcp_answer_thread__1__1__2__4__4__2__1__1__2__err.hdr);
                tcp_answer_thread__1__1__2__4__4__2__1__1__2__err.len=htons((unsigned short int)sizeof(struct anonymous_29) /*12ul*/ );
                write_all(sock, (const void *)&tcp_answer_thread__1__1__2__4__4__2__1__1__2__err, sizeof(struct anonymous_28) /*14ul*/ );
              }

              pthread_exit((void *)0);
            }

            olen = olen + rv;
          }
          nlen = (unsigned long int)rlen;
          resp=process_query(buf, &nlen, (unsigned int *)(void *)0, (signed int *)(void *)0);
          if(resp == ((struct anonymous_28 *)NULL))
            pthread_exit((void *)0);


        __CPROVER_DUMP_L30:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&tcp_answer_thread__1__1__2__4__4____cancel_buf);
        tcp_answer_thread__1__1__2__4__4____cancel_routine(tcp_answer_thread__1__1__2__4__4____cancel_arg);
      }
      while((_Bool)0);
      do
      {
        struct anonymous_66 tcp_answer_thread__1__1__2__4__5____cancel_buf;
        void (*tcp_answer_thread__1__1__2__4__5____cancel_routine)(void *) = free;
        void *tcp_answer_thread__1__1__2__4__5____cancel_arg = (void *)resp;
        signed int tcp_answer_thread__1__1__2__4__5____not_first_call;
        tcp_answer_thread__1__1__2__4__5____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)tcp_answer_thread__1__1__2__4__5____cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)tcp_answer_thread__1__1__2__4__5____not_first_call == 0l))
        {
          tcp_answer_thread__1__1__2__4__5____cancel_routine(tcp_answer_thread__1__1__2__4__5____cancel_arg);
          __pthread_unwind_next(&tcp_answer_thread__1__1__2__4__5____cancel_buf);
        }

        __pthread_register_cancel(&tcp_answer_thread__1__1__2__4__5____cancel_buf);
        do
        {
          signed int tcp_answer_thread__1__1__2__4__5__2__1__err;
          unsigned long int rsize;
          resp->len=htons((unsigned short int)nlen);
          rsize = (unsigned long int)2 + nlen;
          signed long int return_value_write_all_18;
          return_value_write_all_18=write_all(sock, (const void *)resp, rsize);
          tcp_answer_thread__1__1__2__4__5__2__1__err = (signed int)return_value_write_all_18;
          if(!((unsigned long int)tcp_answer_thread__1__1__2__4__5__2__1__err == rsize))
          {
            if(!(debug_p == 0))
            {
              char *tmp_if_expr_17;
              if(tcp_answer_thread__1__1__2__4__5__2__1__err == -1)
              {
                return_value___errno_location_15=__errno_location();
                return_value_strerror_16=strerror(*return_value___errno_location_15);
                tmp_if_expr_17 = return_value_strerror_16;
              }

              else
                tmp_if_expr_17 = "unknown error";
              debug_msg(0, "Error while writing to TCP client: %s\n", tmp_if_expr_17);
            }

            pthread_exit((void *)0);
          }


        __CPROVER_DUMP_L39:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&tcp_answer_thread__1__1__2__4__5____cancel_buf);
        tcp_answer_thread__1__1__2__4__5____cancel_routine(tcp_answer_thread__1__1__2__4__5____cancel_arg);
      }
      while((_Bool)0);

    __CPROVER_DUMP_L41:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// tcp_answer_thread_cleanup
// file dns_answer.c line 1801
static void tcp_answer_thread_cleanup(void *csock)
{
  close(*((signed int *)csock));
  free(csock);
  decrease_procs();
}

// tcp_server_thread
// file dns_answer.c line 2033
void * tcp_server_thread(void *p)
{
  signed int sock;
  unsigned long int pt;
  signed int *csock;
  if(global.strict_suid == 0)
  {
    signed int return_value_run_as_1;
    return_value_run_as_1=run_as(global.run_as);
    if(return_value_run_as_1 == 0)
      pdnsd_exit();

  }

  sock = tcp_socket;
  signed int return_value_listen_4;
  return_value_listen_4=listen(sock, 5);
  char *return_value_strerror_9;
  if(!(return_value_listen_4 == 0))
  {
    da_tcp_errs = da_tcp_errs + 1ul;
    if(!(da_tcp_errs >= 11ul))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      log_message(3, "Could not listen on tcp socket: %s", return_value_strerror_3);
    }

  }

  else
    while((_Bool)1)
    {
      void *return_value_malloc_5;
      return_value_malloc_5=malloc(sizeof(signed int) /*4ul*/ );
      csock = (signed int *)return_value_malloc_5;
      if(csock == ((signed int *)NULL))
      {
        da_mem_errs = da_mem_errs + 1ul;
        if(!(da_mem_errs >= 11ul))
          log_message(3, "Out of memory in request handling.");

        break;
      }

      *csock=accept(sock, (void *)0, ((unsigned int *)NULL));
      if(*csock == -1)
      {
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        if(!(*return_value___errno_location_8 == 4))
        {
          da_tcp_errs = da_tcp_errs + 1ul;
          if(!(da_tcp_errs >= 11ul))
          {
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            char *return_value_strerror_7;
            return_value_strerror_7=strerror(*return_value___errno_location_6);
            log_message(3, "tcp accept failed: %s", return_value_strerror_7);
          }

        }

      }

      else
      {
        pthread_mutex_lock(&proc_lock);
        if(!(qprocs >= global.proc_limit + global.procq_limit))
        {
          signed int err;
          qprocs = qprocs + 1;
          spawned = spawned + 1ul;
          pthread_mutex_unlock(&proc_lock);
          err=pthread_create(&pt, &attr_detached, tcp_answer_thread, (void *)csock);
          if(err == 0)
            continue;

          da_thrd_errs = da_thrd_errs + 1ul;
          if(!(da_thrd_errs >= 11ul))
          {
            return_value_strerror_9=strerror(err);
            log_message(4, "pthread_create failed: %s", return_value_strerror_9);
          }

          pthread_mutex_lock(&proc_lock);
          qprocs = qprocs - 1;
          spawned = spawned - 1ul;
        }

        dropped = dropped + 1ul;
        pthread_mutex_unlock(&proc_lock);
        close(*csock);
      }
      free((void *)csock);
      usleep_r((unsigned long int)50000);
    }

close_sock_return:
  ;
  tcp_socket = -1;
  close(sock);
  tcps_thrid = main_thrid;
  if(udp_socket == -1)
    pdnsd_exit();

  return (void *)0;
}

// test_onquery
// file servers.h line 40
void test_onquery(void)
{
  signed int i;
  signed int n;
  signed int signal_test;
  pthread_mutex_lock(&servers_lock);
  schm[(signed long int)0] = (char)0;
  signal_test = 0;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link5((struct anonymous_3 *)servers);
  n = (signed int)return_value_da_nel_1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous_7 *sp = &servers->elem[(signed long int)i];
    if(sp->interval == -1l)
    {
      if(!((signed int)sp->rootserver >= 2))
        retest(i, -1);

      else
      {
        signed int j;
        signed int m;
        unsigned int return_value_da_nel_2;
        return_value_da_nel_2=da_nel_link5((struct anonymous_3 *)sp->atup_a);
        m = (signed int)return_value_da_nel_2;
        j = 0;
        for( ; !(j >= m); j = j + 1)
          sp->atup_a->elem[(signed long int)j].i_ts = (signed long int)0;
        signal_test = 1;
      }
    }

  }
  char *return_value_strerror_3;
  if(!(signal_test == 0))
  {
    signed int rv;
    signed int return_value_pthread_equal_4;
    return_value_pthread_equal_4=pthread_equal(servstat_thrid, main_thrid);
    if(!(return_value_pthread_equal_4 == 0))
      start_servstat_thread();

    else
    {
      retest_flag = (signed short int)1;
      rv=pthread_cond_signal(&server_test_cond);
      if(!(rv == 0))
      {
        if(!(debug_p == 0))
        {
          return_value_strerror_3=strerror(rv);
          debug_msg(0, "test_onquery(): couldn't signal server status thread: %s\n", return_value_strerror_3);
        }

      }

    }
  }

  pthread_mutex_unlock(&servers_lock);
}

// timedlock_cache_rw
// file cache.c line 285
static signed int timedlock_cache_rw(signed int tm)
{
  signed int retval = 0;
  struct timeval now;
  struct timespec timeout;
  if(use_cache_lock == 0)
    return 0;

  else
  {
    pthread_mutex_lock(&lock_mutex);
    gettimeofday(&now, (struct timezone *)(void *)0);
    timeout.tv_sec = now.tv_sec + (signed long int)tm;
    timeout.tv_nsec = now.tv_usec * (signed long int)1000;
    rw_pend = rw_pend + 1;
    while(!(cache_r_lock == 0) || !(cache_w_lock == 0))
    {
      signed int return_value_pthread_cond_timedwait_1;
      return_value_pthread_cond_timedwait_1=pthread_cond_timedwait(&rw_cond, &lock_mutex, &timeout);
      if(return_value_pthread_cond_timedwait_1 == 110)
        goto cleanup_return;

    }
    cache_w_lock = 1;
    retval = 1;

  cleanup_return:
    ;
    rw_pend = rw_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
    return retval;
  }
}

// translescapedchar
// file conf-parser.c line 149
static char translescapedchar(char c)
{
  switch((signed int)c)
  {
    case 102:
      return (char)12;
    case 110:
      return (char)10;
    case 114:
      return (char)13;
    case 116:
      return (char)9;
    case 118:
      return (char)11;
    default:
      return c;
  }
}

// udp_answer_thread
// file dns_answer.c line 1368
static void * udp_answer_thread(void *data)
{
  struct msghdr msg;
  struct iovec v;
  struct cmsghdr *cmsg;
  char ctrl[40l];
  unsigned long int rlen = ((struct anonymous_69 *)data)->len;
  unsigned int udpmaxrespsize = (unsigned int)512;
  struct anonymous_28 *resp;
  signed int rcode;
  unsigned int thrid;
  char *return_value_strerror_2;
  const char *return_value_get_ename_3;
  const char *return_value_inet_ntop_5;
  const char *return_value_inet_ntop_6;
  const char *return_value_inet_ntop_8;
  const char *return_value_inet_ntop_9;
  do
  {
    struct anonymous_66 __cancel_buf;
    void (*__cancel_routine)(void *) = udp_answer_thread_cleanup;
    void *__cancel_arg = data;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      if(global.strict_suid == 0)
      {
        signed int return_value_run_as_1;
        return_value_run_as_1=run_as(global.run_as);
        if(return_value_run_as_1 == 0)
          pdnsd_exit();

      }

      do
      {
        pthread_mutex_lock(&proc_lock);
        if(!(procs >= global.proc_limit))
          break;

        pthread_mutex_unlock(&proc_lock);
        usleep_r((unsigned long int)50000);
      }
      while((_Bool)1);
      procs = procs + 1;
      thrid_cnt = thrid_cnt + 1u;
      thrid = thrid_cnt;
      pthread_mutex_unlock(&proc_lock);
      if(!(debug_p == 0))
      {
        signed int err;
        err=pthread_setspecific(thrid_key, (const void *)&thrid);
        if(!(err == 0))
        {
          da_misc_errs = da_misc_errs + 1ul;
          if(!(da_misc_errs >= 11ul))
          {
            return_value_strerror_2=strerror(err);
            log_message(3, "pthread_setspecific failed: %s", return_value_strerror_2);
          }

        }

      }

      resp=process_query(((struct anonymous_69 *)data)->buf, &rlen, &udpmaxrespsize, &rcode);
      if(resp == ((struct anonymous_28 *)NULL))
        pthread_exit((void *)0);

      do
      {
        struct anonymous_66 udp_answer_thread__1__1__2__5____cancel_buf;
        void (*udp_answer_thread__1__1__2__5____cancel_routine)(void *) = free;
        void *udp_answer_thread__1__1__2__5____cancel_arg = (void *)resp;
        signed int udp_answer_thread__1__1__2__5____not_first_call;
        udp_answer_thread__1__1__2__5____not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)udp_answer_thread__1__1__2__5____cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)udp_answer_thread__1__1__2__5____not_first_call == 0l))
        {
          udp_answer_thread__1__1__2__5____cancel_routine(udp_answer_thread__1__1__2__5____cancel_arg);
          __pthread_unwind_next(&udp_answer_thread__1__1__2__5____cancel_buf);
        }

        __pthread_register_cancel(&udp_answer_thread__1__1__2__5____cancel_buf);
        do
        {
          if(!((unsigned long int)udpmaxrespsize >= rlen))
          {
            rlen = (unsigned long int)udpmaxrespsize;
            resp->hdr.tc = (unsigned int)1;
          }

          if(!(debug_p == 0))
          {
            return_value_get_ename_3=get_ename(rcode);
            debug_msg(0, "Outbound msg len %li, tc=%u, rc=\"%s\"\n", (signed long int)rlen, resp->hdr.tc, return_value_get_ename_3);
          }

          v.iov_base = (void *)(char *)&resp->hdr;
          v.iov_len = rlen;
          msg.msg_iov = &v;
          msg.msg_iovlen = (unsigned long int)1;
          msg.msg_control = (void *)ctrl;
          msg.msg_controllen = sizeof(char [40l]) /*40ul*/ ;
          msg.msg_flags = 0;
          if(!(run_ipv4 == 0))
          {
            msg.msg_name = (void *)&((struct anonymous_69 *)data)->addr.sin4;
            msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
            ((struct anonymous_69 *)data)->pi.pi4.ipi_spec_dst = ((struct anonymous_69 *)data)->pi.pi4.ipi_addr;
            struct cmsghdr *tmp_if_expr_4;
            if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
              tmp_if_expr_4 = (struct cmsghdr *)(&msg)->msg_control;

            else
              tmp_if_expr_4 = (struct cmsghdr *)0;
            cmsg = tmp_if_expr_4;
            cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(struct in_pktinfo) /*12ul*/ ;
            cmsg->cmsg_level = 0;
            cmsg->cmsg_type = 8;
            memcpy((void *)cmsg->__cmsg_data, (const void *)&((struct anonymous_69 *)data)->pi.pi4, sizeof(struct in_pktinfo) /*12ul*/ );
            msg.msg_controllen = ((sizeof(struct in_pktinfo) /*12ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
            char buf[46l];
            if(!(debug_p == 0))
            {
              return_value_inet_ntop_5=inet_ntop(2, (const void *)&((struct anonymous_69 *)data)->addr.sin4.sin_addr, buf, (unsigned int)46);
              debug_msg(0, "Answering to: %s", return_value_inet_ntop_5);
            }

            if(!(debug_p == 0))
            {
              return_value_inet_ntop_6=inet_ntop(2, (const void *)&((struct anonymous_69 *)data)->pi.pi4.ipi_spec_dst, buf, (unsigned int)46);
              debug_msg(1, ", source address: %s\n", return_value_inet_ntop_6);
            }

          }

          else
          {
            msg.msg_name = (void *)&((struct anonymous_69 *)data)->addr.sin6;
            msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
            struct cmsghdr *tmp_if_expr_7;
            if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
              tmp_if_expr_7 = (struct cmsghdr *)(&msg)->msg_control;

            else
              tmp_if_expr_7 = (struct cmsghdr *)0;
            cmsg = tmp_if_expr_7;
            cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(struct in6_pktinfo) /*20ul*/ ;
            cmsg->cmsg_level = 41;
            cmsg->cmsg_type = 50;
            memcpy((void *)cmsg->__cmsg_data, (const void *)&((struct anonymous_69 *)data)->pi.pi6, sizeof(struct in6_pktinfo) /*20ul*/ );
            msg.msg_controllen = ((sizeof(struct in6_pktinfo) /*20ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1));
            char udp_answer_thread__1__1__2__5__2__4__1__buf[46l];
            if(!(debug_p == 0))
            {
              return_value_inet_ntop_8=inet_ntop(10, (const void *)&((struct anonymous_69 *)data)->addr.sin6.sin6_addr, udp_answer_thread__1__1__2__5__2__4__1__buf, (unsigned int)46);
              debug_msg(0, "Answering to: %s", return_value_inet_ntop_8);
            }

            if(!(debug_p == 0))
            {
              return_value_inet_ntop_9=inet_ntop(10, (const void *)&((struct anonymous_69 *)data)->pi.pi6.ipi6_addr, udp_answer_thread__1__1__2__5__2__4__1__buf, (unsigned int)46);
              debug_msg(1, ", source address: %s\n", return_value_inet_ntop_9);
            }

          }
          signed long int return_value_sendmsg_12;
          return_value_sendmsg_12=sendmsg(((struct anonymous_69 *)data)->sock, &msg, 0);
          if(!(return_value_sendmsg_12 >= 0l))
          {
            da_udp_errs = da_udp_errs + 1ul;
            if(!(da_udp_errs >= 11ul))
            {
              signed int *return_value___errno_location_10;
              return_value___errno_location_10=__errno_location();
              char *return_value_strerror_11;
              return_value_strerror_11=strerror(*return_value___errno_location_10);
              log_message(3, "Error in udp send: %s", return_value_strerror_11);
            }

          }

          else
          {
            signed int tmp;
            unsigned int sl = (unsigned int)sizeof(signed int) /*4ul*/ ;
            getsockopt(((struct anonymous_69 *)data)->sock, 1, 4, (void *)&tmp, &sl);
          }

        __CPROVER_DUMP_L28:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&udp_answer_thread__1__1__2__5____cancel_buf);
        udp_answer_thread__1__1__2__5____cancel_routine(udp_answer_thread__1__1__2__5____cancel_arg);
      }
      while((_Bool)0);

    __CPROVER_DUMP_L30:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  return (void *)0;
}

// udp_answer_thread_cleanup
// file dns_answer.c line 1356
static void udp_answer_thread_cleanup(void *data)
{
  free(data);
  decrease_procs();
}

// udp_server_thread
// file dns_answer.c line 1623
void * udp_server_thread(void *dummy)
{
  signed int sock;
  signed long int qlen;
  unsigned long int pt;
  struct anonymous_69 *buf;
  struct msghdr msg;
  struct iovec v;
  struct cmsghdr *cmsg;
  char ctrl[512l];
  struct in_pktinfo sip;
  if(global.strict_suid == 0)
  {
    signed int return_value_run_as_1;
    return_value_run_as_1=run_as(global.run_as);
    if(return_value_run_as_1 == 0)
      pdnsd_exit();

  }

  sock = udp_socket;
  signed int *return_value___errno_location_6;
  signed int *return_value___errno_location_11;
  char *return_value_strerror_12;
  while((_Bool)1)
  {
    signed int udpbufsize = global.udpbufsize;
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct anonymous_69) /*64ul*/  + (unsigned long int)udpbufsize);
    buf = (struct anonymous_69 *)return_value_calloc_2;
    if(buf == ((struct anonymous_69 *)NULL))
    {
      da_mem_errs = da_mem_errs + 1ul;
      if(!(da_mem_errs >= 11ul))
        log_message(3, "Out of memory in request handling.");

      break;
    }

    buf->sock = sock;
    v.iov_base = (void *)(char *)buf->buf;
    v.iov_len = (unsigned long int)udpbufsize;
    msg.msg_iov = &v;
    msg.msg_iovlen = (unsigned long int)1;
    msg.msg_control = (void *)ctrl;
    msg.msg_controllen = sizeof(char [512l]) /*512ul*/ ;
    if(!(run_ipv4 == 0))
    {
      msg.msg_name = (void *)&buf->addr.sin4;
      msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      qlen=recvmsg(sock, &msg, 0);
      if(qlen >= 0l)
      {
        struct cmsghdr *tmp_if_expr_3;
        if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
          tmp_if_expr_3 = (struct cmsghdr *)(&msg)->msg_control;

        else
          tmp_if_expr_3 = (struct cmsghdr *)0;
        cmsg = tmp_if_expr_3;
        while(!(cmsg == ((struct cmsghdr *)NULL)))
        {
          if(cmsg->cmsg_level == 0)
          {
            if(cmsg->cmsg_type == 8)
            {
              memcpy((void *)&buf->pi.pi4, (const void *)cmsg->__cmsg_data, sizeof(struct in_pktinfo) /*12ul*/ );
              break;
            }

          }

          cmsg=__cmsg_nxthdr(&msg, cmsg);
        }
        if(cmsg == ((struct cmsghdr *)NULL))
        {
          da_udp_errs = da_udp_errs + 1ul;
          if(!(da_udp_errs >= 11ul))
            log_message(3, "Could not discover udp destination address");

          goto free_buf_continue;
        }

      }

      else
      {
        return_value___errno_location_6=__errno_location();
        if(!(*return_value___errno_location_6 == 4))
        {
          da_udp_errs = da_udp_errs + 1ul;
          if(!(da_udp_errs >= 11ul))
          {
            signed int *return_value___errno_location_4;
            return_value___errno_location_4=__errno_location();
            char *return_value_strerror_5;
            return_value_strerror_5=strerror(*return_value___errno_location_4);
            log_message(3, "error in UDP recv: %s", return_value_strerror_5);
          }

        }

      }
    }

    else
    {
      msg.msg_name = (void *)&buf->addr.sin6;
      msg.msg_namelen = (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
      qlen=recvmsg(sock, &msg, 0);
      if(qlen >= 0l)
      {
        struct cmsghdr *tmp_if_expr_7;
        if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
          tmp_if_expr_7 = (struct cmsghdr *)(&msg)->msg_control;

        else
          tmp_if_expr_7 = (struct cmsghdr *)0;
        cmsg = tmp_if_expr_7;
        while(!(cmsg == ((struct cmsghdr *)NULL)))
        {
          if(cmsg->cmsg_level == 41)
          {
            if(cmsg->cmsg_type == 50)
            {
              memcpy((void *)&buf->pi.pi6, (const void *)cmsg->__cmsg_data, sizeof(struct in6_pktinfo) /*20ul*/ );
              break;
            }

          }

          cmsg=__cmsg_nxthdr(&msg, cmsg);
        }
        if(cmsg == ((struct cmsghdr *)NULL))
        {
          struct cmsghdr *tmp_if_expr_8;
          if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
            tmp_if_expr_8 = (struct cmsghdr *)(&msg)->msg_control;

          else
            tmp_if_expr_8 = (struct cmsghdr *)0;
          cmsg = tmp_if_expr_8;
          while(!(cmsg == ((struct cmsghdr *)NULL)))
          {
            if(cmsg->cmsg_level == 0)
            {
              if(cmsg->cmsg_type == 8)
              {
                memcpy((void *)&sip, (const void *)cmsg->__cmsg_data, sizeof(struct in_pktinfo) /*12ul*/ );
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)3] = (&sip.ipi_addr)->s_addr;
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)2]=htonl((unsigned int)0xffff);
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)0] = (unsigned int)0;
                ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)1] = ((unsigned int *)&buf->pi.pi6.ipi6_addr)[(signed long int)0];
                buf->pi.pi6.ipi6_ifindex = (unsigned int)sip.ipi_ifindex;
                break;
              }

            }

            cmsg=__cmsg_nxthdr(&msg, cmsg);
          }
          if(cmsg == ((struct cmsghdr *)NULL))
          {
            da_udp_errs = da_udp_errs + 1ul;
            if(!(da_udp_errs >= 11ul))
              log_message(3, "Could not discover udp destination address");

            goto free_buf_continue;
          }

        }

      }

      else
      {
        return_value___errno_location_11=__errno_location();
        if(!(*return_value___errno_location_11 == 4))
        {
          da_udp_errs = da_udp_errs + 1ul;
          if(!(da_udp_errs >= 11ul))
          {
            signed int *return_value___errno_location_9;
            return_value___errno_location_9=__errno_location();
            char *return_value_strerror_10;
            return_value_strerror_10=strerror(*return_value___errno_location_9);
            log_message(3, "error in UDP recv: %s", return_value_strerror_10);
          }

        }

      }
    }
    if(qlen >= 0l)
    {
      pthread_mutex_lock(&proc_lock);
      if(!(qprocs >= global.proc_limit + global.procq_limit))
      {
        signed int err;
        qprocs = qprocs + 1;
        spawned = spawned + 1ul;
        pthread_mutex_unlock(&proc_lock);
        buf->len = (unsigned long int)qlen;
        err=pthread_create(&pt, &attr_detached, udp_answer_thread, (void *)buf);
        if(err == 0)
          continue;

        da_thrd_errs = da_thrd_errs + 1ul;
        if(!(da_thrd_errs >= 11ul))
        {
          return_value_strerror_12=strerror(err);
          log_message(4, "pthread_create failed: %s", return_value_strerror_12);
        }

        pthread_mutex_lock(&proc_lock);
        qprocs = qprocs - 1;
        spawned = spawned - 1ul;
      }

      dropped = dropped + 1ul;
      pthread_mutex_unlock(&proc_lock);
    }


  free_buf_continue:
    ;
    free((void *)buf);
    usleep_r((unsigned long int)50000);
  }
  udp_socket = -1;
  close(sock);
  udps_thrid = main_thrid;
  if(tcp_socket == -1)
    pdnsd_exit();

  return (void *)0;
}

// unlock_cache_r
// file cache.c line 250
static void unlock_cache_r(void)
{
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    if(cache_r_lock >= 1)
      cache_r_lock = cache_r_lock - 1;

    if(cache_r_lock == 0)
      pthread_cond_signal(&rw_cond);

    pthread_mutex_unlock(&lock_mutex);
  }

}

// unlock_cache_rw
// file cache.c line 311
static void unlock_cache_rw(void)
{
  if(!(use_cache_lock == 0))
  {
    pthread_mutex_lock(&lock_mutex);
    cache_w_lock = 0;
    r_susp = 0;
    if(r_pend == 0 || !(r_pend / 2 + 2 >= rw_pend))
      pthread_cond_signal(&rw_cond);

    else
      pthread_cond_broadcast(&r_cond);
    pthread_mutex_unlock(&lock_mutex);
  }

}

// unlock_server_data
// file servers.h line 42
void unlock_server_data()
{
  pthread_mutex_lock(&servers_lock);
  if(!(server_data_users >= 1))
  {
    log_message(3, "%s:%d: %s", (const void *)"servers.c", 696, (const void *)"server_data_users non-positive before attempt to decrement it");
    pdnsd_exit();
  }

  server_data_users = server_data_users - 1;
  if(server_data_users == 0)
    pthread_cond_broadcast(&server_data_cond);

  pthread_mutex_unlock(&servers_lock);
}

// uptest
// file servers.c line 73
static signed int uptest(struct anonymous_7 *serv, signed int j)
{
  signed int ret = 0;
  signed int count_running_ping = 0;
  union anonymous_6 *s_addr;
  union anonymous_6 *tmp_if_expr_1;
  if(!(run_ipv4 == 0))
    tmp_if_expr_1 = (union anonymous_6 *)&(&serv->atup_a->elem[(signed long int)j].a)->ipv4;

  else
    tmp_if_expr_1 = (union anonymous_6 *)&(&serv->atup_a->elem[(signed long int)j].a)->ipv6;
  s_addr = tmp_if_expr_1;
  char uptest__1__1___debugsockabuf[46l];
  const char *return_value_const_name_2;
  const char *return_value_pdnsd_a2str_3;
  if(!(debug_p == 0))
  {
    return_value_const_name_2=const_name((signed int)serv->uptest);
    return_value_pdnsd_a2str_3=pdnsd_a2str(s_addr, uptest__1__1___debugsockabuf, 46);
    debug_msg(0, "performing uptest (type=%s) for %s\n", return_value_const_name_2, return_value_pdnsd_a2str_3);
  }

  server_data_users = server_data_users + 1;
  _Bool tmp_if_expr_6;
  if((signed int)serv->uptest == 8)
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = (signed int)serv->uptest == 9 ? (_Bool)1 : (_Bool)0;
  unsigned long int return_value_pthread_self_4;
  signed int return_value_pthread_equal_5;
  if(tmp_if_expr_6)
  {
    return_value_pthread_self_4=pthread_self();
    return_value_pthread_equal_5=pthread_equal(return_value_pthread_self_4, servstat_thrid);
    if(!(return_value_pthread_equal_5 == 0))
    {
      count_running_ping = 1;
      server_status_ping = server_status_ping + 1;
    }

  }

  pthread_mutex_unlock(&servers_lock);
  signed int return_value_is_inaddr_any_7;
  signed int return_value_ping_9;
  signed int *return_value___errno_location_10;
  char *return_value_strerror_11;
  unsigned int return_value_getuid_16;
  signed int return_value_setuid_17;
  signed int *return_value___errno_location_25;
  signed int *return_value___errno_location_27;
  char *return_value_strerror_28;
  switch((signed int)serv->uptest)
  {
    case 5:
    {
      ret = (signed int)serv->atup_a->elem[(signed long int)j].is_up;
      break;
    }
    case 8:
    {
      return_value_is_inaddr_any_7=is_inaddr_any_link2(&serv->ping_a);
      union anonymous_6 *tmp_if_expr_8;
      if(!(return_value_is_inaddr_any_7 == 0))
        tmp_if_expr_8 = s_addr;

      else
        tmp_if_expr_8 = &serv->ping_a;
      return_value_ping_9=ping(tmp_if_expr_8, (signed int)serv->ping_timeout, 2);
      ret = (signed int)(return_value_ping_9 != -1);
      break;
    }
    case 6:

    case 16:

    case 17:
    {
      ret=if_up(serv->interface);
      if(!(ret == 0))
      {
        if((signed int)serv->uptest == 16)
          ret=dev_up(serv->interface, serv->device);

        else
          if((signed int)serv->uptest == 17)
            ret=dev_up("diald", serv->device);

      }

      break;
    }
    case 7:
    {
      signed int pid;
      pid=fork();
      if(pid == -1)
      {
        if(!(debug_p == 0))
        {
          return_value___errno_location_10=__errno_location();
          return_value_strerror_11=strerror(*return_value___errno_location_10);
          debug_msg(0, "Could not fork to perform exec uptest: %s\n", return_value_strerror_11);
        }

        break;
      }

      else
        if(pid == 0)
        {
          unsigned int return_value_getgid_14;
          return_value_getgid_14=getgid();
          signed int return_value_setgid_15;
          return_value_setgid_15=setgid(return_value_getgid_14);
          _Bool tmp_if_expr_18;
          if(return_value_setgid_15 == -1)
            tmp_if_expr_18 = (_Bool)1;

          else
          {
            return_value_getuid_16=getuid();
            return_value_setuid_17=setuid(return_value_getuid_16);
            tmp_if_expr_18 = return_value_setuid_17 == -1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_18)
          {
            signed int *return_value___errno_location_12;
            return_value___errno_location_12=__errno_location();
            char *return_value_strerror_13;
            return_value_strerror_13=strerror(*return_value___errno_location_12);
            log_message(3, "Could not reset uid or gid: %s", return_value_strerror_13);
            _exit(1);
          }

          signed int return_value_run_as_19;
          return_value_run_as_19=run_as(serv->uptest_usr);
          if(return_value_run_as_19 == 0)
            _exit(1);

          struct rlimit rl;
          signed int i;
          signed int return_value_getrlimit_22;
          return_value_getrlimit_22=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &rl);
          if(return_value_getrlimit_22 == -1)
          {
            signed int *return_value___errno_location_20;
            return_value___errno_location_20=__errno_location();
            char *return_value_strerror_21;
            return_value_strerror_21=strerror(*return_value___errno_location_20);
            log_message(3, "getrlimit() failed: %s", return_value_strerror_21);
            _exit(1);
          }

          i = 0;
          for( ; !((unsigned long int)i >= rl.rlim_max); i = i + 1)
          {
            signed int return_value_fcntl_26;
            return_value_fcntl_26=fcntl(i, 2, 1);
            if(return_value_fcntl_26 == -1)
            {
              return_value___errno_location_25=__errno_location();
              if(!(*return_value___errno_location_25 == 9))
              {
                signed int *return_value___errno_location_23;
                return_value___errno_location_23=__errno_location();
                char *return_value_strerror_24;
                return_value_strerror_24=strerror(*return_value___errno_location_23);
                log_message(3, "fcntl(F_SETFD) failed: %s", return_value_strerror_24);
                _exit(1);
              }

            }

          }
          execl("/bin/sh", "uptest_sh", (const void *)"-c", serv->uptest_cmd, (char *)(void *)0);
          _exit(1);
        }

        else
        {
          signed int status;
          signed int wpid;
          wpid=waitpid(pid, &status, 0);
          if(wpid == pid)
          {
            /* tag-#anon#lUN[lS32'__in'|S32'__i'] */
union anonymous_57
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
            ;
            if((0x7f & status) == 0)
            {
              signed int exitstatus = (((union anonymous_57){ .__in=status }).__i & 0xff00) >> 8;
              if(!(debug_p == 0))
                debug_msg(0, "uptest command \"%s\" exited with status %d\n", serv->uptest_cmd, exitstatus);

              ret = (signed int)(exitstatus == 0);
            }

            else
              if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
              {
                if(!(debug_p == 0))
                  debug_msg(0, "uptest command \"%s\" was terminated by signal %d\n", serv->uptest_cmd, ((union anonymous_57){ .__in=status }).__i & 0x7f);

              }

              else
                if(!(debug_p == 0))
                  debug_msg(0, "status of uptest command \"%s\" is of unknown type (0x%x)\n", serv->uptest_cmd, status);

          }

          else
            if(wpid == -1)
            {
              if(!(debug_p == 0))
              {
                return_value___errno_location_27=__errno_location();
                return_value_strerror_28=strerror(*return_value___errno_location_27);
                debug_msg(0, "Error while waiting for uptest command \"%s\" to terminate: waitpid for pid %d failed: %s\n", serv->uptest_cmd, pid, return_value_strerror_28);
              }

            }

            else
              if(!(debug_p == 0))
                debug_msg(0, "Error while waiting for uptest command \"%s\" to terminate: waitpid returned %d, expected pid %d\n", serv->uptest_cmd, wpid, pid);

        }
      break;
    }
    case 9:
    {
      signed long int tmp_if_expr_29;
      if(serv->timeout >= global.timeout)
        tmp_if_expr_29 = serv->timeout;

      else
        tmp_if_expr_29 = global.timeout;
      ret=query_uptest(s_addr, (signed int)serv->port, serv->query_test_name, tmp_if_expr_29, 2);
    }
  }
  pthread_mutex_lock(&servers_lock);
  if(!(count_running_ping == 0))
    server_status_ping = server_status_ping - 1;

  if(!(server_data_users >= 1))
  {
    log_message(3, "%s:%d: %s", (const void *)"servers.c", 194, (const void *)"server_data_users non-positive before attempt to decrement it");
    pdnsd_exit();
  }

  server_data_users = server_data_users - 1;
  if(server_data_users == 0)
    pthread_cond_broadcast(&server_data_cond);

  char _debugsockabuf[46l];
  const char *return_value_pdnsd_a2str_30;
  if(!(debug_p == 0))
  {
    return_value_pdnsd_a2str_30=pdnsd_a2str(s_addr, _debugsockabuf, 46);
    debug_msg(0, "result of uptest for %s: %s\n", return_value_pdnsd_a2str_30, ret != 0 ? "OK" : "failed");
  }

  return ret;
}

// use_server
// file dns_query.c line 2820
static signed int use_server(struct anonymous_7 *s, const unsigned char *name)
{
  signed int i;
  signed int n;
  unsigned int return_value_da_nel_1;
  return_value_da_nel_1=da_nel_link2((struct anonymous_3 *)s->alist);
  n = (signed int)return_value_da_nel_1;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    struct anonymous_9 *sl = &s->alist->elem[(signed long int)i];
    unsigned int nrem;
    unsigned int lrem;
    domain_match(name, sl->domain, &nrem, &lrem);
    if(lrem == 0u)
    {
      if(sl->exact == 0 || nrem == 0u)
        return (signed int)((signed int)sl->rule == 18);

    }

  }
  _Bool tmp_if_expr_3;
  if((signed int)s->policy == 20)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)s->policy == 21 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    unsigned int return_value_rhnsegcnt_2;
    return_value_rhnsegcnt_2=rhnsegcnt_link1(name);
    if(!(return_value_rhnsegcnt_2 >= 2u))
      return (signed int)((signed int)s->policy == 20);

    else
      return (signed int)((signed int)s->policy == 21);
  }

  return (signed int)((signed int)s->policy == 18);
}

// usleep_r
// file thread.h line 113
static inline signed int usleep_r(unsigned long int useconds)
{
  struct timespec ts = { .tv_sec=(signed long int)(useconds / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep_1;
  return_value_nanosleep_1=nanosleep(&ts, (struct timespec *)(void *)0);
  return return_value_nanosleep_1;
}

// usleep_r_link1
// file thread.h line 113
static inline signed int usleep_r_link1(unsigned long int useconds_link1)
{
  struct timespec ts_link1 = { .tv_sec=(signed long int)(useconds_link1 / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds_link1 % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep_1_link1;
  return_value_nanosleep_1_link1=nanosleep(&ts_link1, (struct timespec *)(void *)0);
  return return_value_nanosleep_1_link1;
}

// usleep_r_link2
// file thread.h line 113
static inline signed int usleep_r_link2(unsigned long int useconds_link2)
{
  struct timespec ts_link2 = { .tv_sec=(signed long int)(useconds_link2 / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds_link2 % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep_1_link2;
  return_value_nanosleep_1_link2=nanosleep(&ts_link2, (struct timespec *)(void *)0);
  return return_value_nanosleep_1_link2;
}

// usleep_r_link3
// file thread.h line 113
static inline signed int usleep_r_link3(unsigned long int useconds_link3)
{
  struct timespec ts_link3 = { .tv_sec=(signed long int)(useconds_link3 / (unsigned long int)1000000), .tv_nsec=(signed long int)((useconds_link3 % (unsigned long int)1000000) * 1000ul) };
  signed int return_value_nanosleep_1_link3;
  return_value_nanosleep_1_link3=nanosleep(&ts_link3, (struct timespec *)(void *)0);
  return return_value_nanosleep_1_link3;
}

// write_all
// file helpers.h line 182
static inline signed long int write_all(signed int fd, const void *data, unsigned long int n)
{
  signed long int written = (signed long int)0;
  while(!((unsigned long int)written >= n))
  {
    signed long int m;
    m=write(fd, (const void *)((const char *)data + written), n - (unsigned long int)written);
    if(!(m >= 0l))
      return m;

    written = written + m;
  }
  return written;
}

// write_all_link1
// file helpers.h line 182
static inline signed long int write_all_link1(signed int fd_link1, const void *data_link1, unsigned long int n_link1)
{
  signed long int written_link1 = (signed long int)0;
  while(!((unsigned long int)written_link1 >= n_link1))
  {
    signed long int m_link1;
    m_link1=write(fd_link1, (const void *)((const char *)data_link1 + written_link1), n_link1 - (unsigned long int)written_link1);
    if(!(m_link1 >= 0l))
      return m_link1;

    written_link1 = written_link1 + m_link1;
  }
  return written_link1;
}

// write_all_link2
// file helpers.h line 182
static inline signed long int write_all_link2(signed int fd_link2, const void *data_link2, unsigned long int n_link2)
{
  signed long int written_link2 = (signed long int)0;
  while(!((unsigned long int)written_link2 >= n_link2))
  {
    signed long int m_link2;
    m_link2=write(fd_link2, (const void *)((const char *)data_link2 + written_link2), n_link2 - (unsigned long int)written_link2);
    if(!(m_link2 >= 0l))
      return m_link2;

    written_link2 = written_link2 + m_link2;
  }
  return written_link2;
}

// write_disk_cache
// file cache.h line 165
void write_disk_cache(void)
{
  signed int j;
  signed int jlim;
  struct anonymous_0 *le;
  unsigned long int en = (unsigned long int)0;
  struct anonymous_59 pos;
  struct _IO_FILE *f;
  unsigned long int num_rrs_errs = (unsigned long int)0;
  signed long int num_rrs_errs_array_size0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(global.cache_dir);
  num_rrs_errs_array_size0 = (signed long int)(return_value_strlen_1 + sizeof(char [13l]) /*13ul*/ );
  char path[num_rrs_errs_array_size0];
  char *return_value_stpcpy_2;
  return_value_stpcpy_2=stpcpy(path, global.cache_dir);
  stpcpy(return_value_stpcpy_2, "/pdnsd.cache");
  if(!(debug_p == 0))
    debug_msg(0, "Writing cache to %s\n", (const void *)path);

  signed int return_value_softlock_cache_rw_3;
  return_value_softlock_cache_rw_3=softlock_cache_rw();
  signed int return_value_softunlock_cache_rw_4;
  signed int return_value_softlock_cache_r_5;
  unsigned long int return_value_fwrite_10;
  unsigned long int return_value_fwrite_15;
  unsigned long int return_value_fwrite_30;
  const unsigned short int *tmp_if_expr_32;
  signed int return_value_fclose_37;
  if(!(return_value_softlock_cache_rw_3 == 0))
  {
    purge_cache((signed long int)global.perm_cache * (signed long int)1024, 0);
    return_value_softunlock_cache_rw_4=softunlock_cache_rw();
    if(return_value_softunlock_cache_rw_4 == 0)
      goto lock_failed;

    return_value_softlock_cache_r_5=softlock_cache_r();
    if(return_value_softlock_cache_r_5 == 0)
      goto lock_failed;

    f=fopen(path, "w");
    if(f == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      log_message(4, "Could not open disk cache file %s: %s", (const void *)path, return_value_strerror_7);
      goto softunlock_return;
    }

    return_value_fwrite_10=fwrite((const void *)cachverid, sizeof(const char [4l]) /*4ul*/ , (unsigned long int)1, f);
    if(!(return_value_fwrite_10 == 1ul))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      char *return_value_strerror_9;
      return_value_strerror_9=strerror(*return_value___errno_location_8);
      log_message(3, "Error while writing cache version identifier to disk cache: %s", return_value_strerror_9);
      goto fclose_unlock;
    }

    le=fetch_first(&pos);
    while(!(le == ((struct anonymous_0 *)NULL)))
    {
      if(!((1 & (signed int)le->flags) == 0))
      {
        if((2 & (signed int)le->flags) == 0)
          en = en + 1ul;

      }

      else
      {
        signed int tmp_if_expr_11;
        if(!((1 & (signed int)le->flags) == 0))
          tmp_if_expr_11 = 0;

        else
          tmp_if_expr_11 = le->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        jlim = tmp_if_expr_11;
        j = 0;
        for( ; !(j >= jlim); j = j + 1)
        {
          struct anonymous *write_disk_cache__1__7__1__2__1__1__rrset;
          struct anonymous *tmp_if_expr_12;
          if(!(j >= 8))
            tmp_if_expr_12 = le->_anon0.rr.rrmu[(signed long int)j];

          else
            tmp_if_expr_12 = le->_anon0.rr.rrext[(signed long int)(j - 8)];
          write_disk_cache__1__7__1__2__1__1__rrset = tmp_if_expr_12;
          if(!(write_disk_cache__1__7__1__2__1__1__rrset == ((struct anonymous *)NULL)))
          {
            if((2 & (signed int)write_disk_cache__1__7__1__2__1__1__rrset->flags) == 0)
            {
              en = en + 1ul;
              break;
            }

          }

        }
      }
      le=fetch_next(&pos);
    }
    return_value_fwrite_15=fwrite((const void *)&en, sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1, f);
    if(!(return_value_fwrite_15 == 1ul))
    {
      signed int *return_value___errno_location_13;
      return_value___errno_location_13=__errno_location();
      char *return_value_strerror_14;
      return_value_strerror_14=strerror(*return_value___errno_location_13);
      log_message(3, "Error while writing entry count to disk cache: %s", return_value_strerror_14);
      goto fclose_unlock;
    }

    le=fetch_first(&pos);
    while(!(le == ((struct anonymous_0 *)NULL)))
    {
      if(!((1 & (signed int)le->flags) == 0))
      {
        if((2 & (signed int)le->flags) == 0)
          goto write_rrs;

      }

      else
      {
        signed int tmp_if_expr_16;
        if(!((1 & (signed int)le->flags) == 0))
          tmp_if_expr_16 = 0;

        else
          tmp_if_expr_16 = le->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
        jlim = tmp_if_expr_16;
        j = 0;
        for( ; !(j >= jlim); j = j + 1)
        {
          struct anonymous *write_disk_cache__1__9__1__2__1__1__rrset;
          struct anonymous *tmp_if_expr_17;
          if(!(j >= 8))
            tmp_if_expr_17 = le->_anon0.rr.rrmu[(signed long int)j];

          else
            tmp_if_expr_17 = le->_anon0.rr.rrext[(signed long int)(j - 8)];
          write_disk_cache__1__9__1__2__1__1__rrset = tmp_if_expr_17;
          if(!(write_disk_cache__1__9__1__2__1__1__rrset == ((struct anonymous *)NULL)))
          {
            if((2 & (signed int)write_disk_cache__1__9__1__2__1__1__rrset->flags) == 0)
              goto write_rrs;

          }

        }
      }
      goto __CPROVER_DUMP_L48;

    write_rrs:
      ;
      struct anonymous_62 df;
      signed int num_rrs;
      const unsigned short int *iterlist;
      unsigned int return_value_rhnlen_18;
      return_value_rhnlen_18=rhnlen_link6(le->qname);
      df.qlen = (unsigned char)(return_value_rhnlen_18 - (unsigned int)1);
      df.num_rrs = (unsigned char)0;
      df.flags = le->flags;
      df.c_ns = le->c_ns;
      df.c_soa = le->c_soa;
      num_rrs = 0;
      signed int tmp_if_expr_19;
      if(!((1 & (signed int)le->flags) == 0))
        tmp_if_expr_19 = 0;

      else
        tmp_if_expr_19 = le->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      jlim = tmp_if_expr_19;
      j = 0;
      for( ; !(j >= jlim); j = j + 1)
      {
        struct anonymous *write_disk_cache__1__9__1__3__1__1__rrset;
        struct anonymous *tmp_if_expr_20;
        if(!(j >= 8))
          tmp_if_expr_20 = le->_anon0.rr.rrmu[(signed long int)j];

        else
          tmp_if_expr_20 = le->_anon0.rr.rrext[(signed long int)(j - 8)];
        write_disk_cache__1__9__1__3__1__1__rrset = tmp_if_expr_20;
        if(!(write_disk_cache__1__9__1__3__1__1__rrset == ((struct anonymous *)NULL)))
        {
          num_rrs = num_rrs + 1;
          if((2 & (signed int)write_disk_cache__1__9__1__3__1__1__rrset->flags) == 0)
            df.num_rrs = df.num_rrs + 1;

        }

      }
      if(!(num_rrs == (signed int)le->num_rrs))
      {
        num_rrs_errs = num_rrs_errs + 1ul;
        if(!(num_rrs_errs >= 11ul))
        {
          unsigned char buf[256l];
          const unsigned char *return_value_rhn2str_21;
          return_value_rhn2str_21=rhn2str(le->qname, buf, (unsigned int)sizeof(unsigned char [256l]) /*256ul*/ );
          log_message(4, "Counted %d rr record types for %s but cached counter=%d", num_rrs, return_value_rhn2str_21, le->num_rrs);
        }

      }

      unsigned long int return_value_fwrite_24;
      return_value_fwrite_24=fwrite((const void *)&df, sizeof(struct anonymous_62) /*6ul*/ , (unsigned long int)1, f);
      if(!(return_value_fwrite_24 == 1ul))
      {
        signed int *return_value___errno_location_22;
        return_value___errno_location_22=__errno_location();
        char *return_value_strerror_23;
        return_value_strerror_23=strerror(*return_value___errno_location_22);
        log_message(3, "Error while writing cache entry header to disk cache: %s", return_value_strerror_23);
        goto fclose_unlock;
      }

      if(!((1 & (signed int)le->flags) == 0))
      {
        struct anonymous_63 fttlts = { .ttl=le->_anon0.neg.ttl, .ts=le->_anon0.neg.ts };
        unsigned long int return_value_fwrite_27;
        return_value_fwrite_27=fwrite((const void *)&fttlts, sizeof(struct anonymous_63) /*16ul*/ , (unsigned long int)1, f);
        if(!(return_value_fwrite_27 == 1ul))
        {
          signed int *return_value___errno_location_25;
          return_value___errno_location_25=__errno_location();
          char *return_value_strerror_26;
          return_value_strerror_26=strerror(*return_value___errno_location_25);
          log_message(3, "Error while writing cache TTL and timestamp to disk cache: %s", return_value_strerror_26);
          goto fclose_unlock;
        }

      }

      if(!(df.qlen == 0))
      {
        return_value_fwrite_30=fwrite((const void *)le->qname, (unsigned long int)df.qlen, (unsigned long int)1, f);
        if(!(return_value_fwrite_30 == 1ul))
        {
          signed int *return_value___errno_location_28;
          return_value___errno_location_28=__errno_location();
          char *return_value_strerror_29;
          return_value_strerror_29=strerror(*return_value___errno_location_28);
          log_message(3, "Error while writing domain name to disk cache: %s", return_value_strerror_29);
          goto fclose_unlock;
        }

      }

      signed int tmp_if_expr_31;
      if(!((1 & (signed int)le->flags) == 0))
        tmp_if_expr_31 = 0;

      else
        tmp_if_expr_31 = le->_anon0.rr.rrext != ((struct anonymous **)NULL) ? 47 : 8;
      jlim = tmp_if_expr_31;
      const unsigned short int *tmp_if_expr_33;
      if(!((1 & (signed int)le->flags) == 0))
        tmp_if_expr_33 = (const unsigned short int *)(void *)0;

      else
      {
        if(!(le->_anon0.rr.rrext == ((struct anonymous **)NULL)))
          tmp_if_expr_32 = rrcachiterlist;

        else
          tmp_if_expr_32 = rrmuiterlist;
        tmp_if_expr_33 = tmp_if_expr_32;
      }
      iterlist = tmp_if_expr_33;
      j = 0;
      for( ; !(j >= jlim); j = j + 1)
      {
        signed int tp = (signed int)iterlist[(signed long int)j];
        struct anonymous *rrset;
        rrset=getrrset_eff_link3(le, tp);
        if(!(rrset == ((struct anonymous *)NULL)))
        {
          if((2 & (signed int)rrset->flags) == 0)
          {
            signed int return_value_write_rrset_34;
            return_value_write_rrset_34=write_rrset(tp, rrset, f);
            if(return_value_write_rrset_34 == 0)
              goto fclose_unlock;

          }

        }

      }

    __CPROVER_DUMP_L48:
      ;
      le=fetch_next(&pos);
    }
    return_value_fclose_37=fclose(f);
    if(!(return_value_fclose_37 == 0))
    {
      signed int *return_value___errno_location_35;
      return_value___errno_location_35=__errno_location();
      char *return_value_strerror_36;
      return_value_strerror_36=strerror(*return_value___errno_location_35);
      log_message(3, "Could not close cache file %s after writing cache: %s", (const void *)path, return_value_strerror_36);
    }

    softunlock_cache_r();
    if(!(debug_p == 0))
      debug_msg(0, "Finished writing cache to disk.\n");

    goto __CPROVER_DUMP_L55;

  fclose_unlock:
    ;
    fclose(f);

  softunlock_return:
    ;
    softunlock_cache_r();
  }

  else
  {

  lock_failed:
    ;
    crash_msg("Lock failed; could not write disk cache.");
  }

__CPROVER_DUMP_L55:
  ;
}

// write_rrset
// file cache.c line 1554
static signed int write_rrset(signed int tp, struct anonymous *rrs, struct _IO_FILE *f)
{
  struct rr_b_s *rr;
  struct anonymous_61 sh;
  struct anonymous_60 rf;
  unsigned int num_rr;
  sh.tp = (unsigned char)tp;
  num_rr = (unsigned int)0;
  rr = rrs->rrs;
  for( ; !(rr == ((struct rr_b_s *)NULL)) && !(num_rr >= 255u); rr = rr->next)
    num_rr = num_rr + 1u;
  sh.num_rr = (unsigned char)num_rr;
  sh.flags = rrs->flags;
  sh.ttl = rrs->ttl;
  sh.ts = rrs->ts;
  unsigned long int return_value_fwrite_3;
  return_value_fwrite_3=fwrite((const void *)&sh, sizeof(struct anonymous_61) /*20ul*/ , (unsigned long int)1, f);
  if(!(return_value_fwrite_3 == 1ul))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    log_message(3, "Error while writing rr header to disk cache: %s", return_value_strerror_2);
    return 0;
  }

  rr = rrs->rrs;
  _Bool tmp_if_expr_8;
  unsigned long int return_value_fwrite_7;
  for( ; !(num_rr == 0u); num_rr = num_rr - 1u)
  {
    rf.rdlen = (unsigned short int)rr->rdlen;
    unsigned long int return_value_fwrite_6;
    return_value_fwrite_6=fwrite((const void *)&rf, sizeof(struct anonymous_60) /*2ul*/ , (unsigned long int)1, f);
    _Bool tmp_if_expr_9;
    if(!(return_value_fwrite_6 == 1ul))
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      if(!(rf.rdlen == 0))
      {
        return_value_fwrite_7=fwrite((const void *)rr->data, (unsigned long int)rf.rdlen, (unsigned long int)1, f);
        tmp_if_expr_8 = return_value_fwrite_7 != (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      log_message(3, "Error while writing rr data to disk cache: %s", return_value_strerror_5);
      return 0;
    }

    rr = rr->next;
  }
  return 1;
}

// yield_lock_cache_rw
// file cache.c line 336
static void yield_lock_cache_rw()
{
  if(!(use_cache_lock == 0) && (!(r_pend == 0) || !(rw_pend == 0)))
  {
    pthread_mutex_lock(&lock_mutex);
    cache_w_lock = 0;
    r_susp = 0;
    if(r_pend == 0 || !(r_pend / 2 + 2 >= rw_pend))
      pthread_cond_signal(&rw_cond);

    else
      pthread_cond_broadcast(&r_cond);
    pthread_mutex_unlock(&lock_mutex);
    usleep_r_link3((unsigned long int)1000);
    pthread_mutex_lock(&lock_mutex);
    rw_pend = rw_pend + 1;
    while(!(cache_r_lock == 0) || !(cache_w_lock == 0))
      pthread_cond_wait(&rw_cond, &lock_mutex);
    cache_w_lock = 1;
    rw_pend = rw_pend - 1;
    pthread_mutex_unlock(&lock_mutex);
  }

}

// zone_add
// file conf-parser.c line 2103
static const char * zone_add(struct anonymous_30 **za, const char *zone, unsigned int len)
{
  unsigned char *z;
  const char *err;
  unsigned long int sz;
  unsigned char rhn[256l];
  err=parsestr2rhn((unsigned char *)zone, len, rhn);
  void *return_value_malloc_3;
  if(!(err == ((const char *)NULL)))
    return err;

  else
  {
    unsigned int return_value_rhnlen_1;
    return_value_rhnlen_1=rhnlen(rhn);
    sz = (unsigned long int)return_value_rhnlen_1;
    struct anonymous_3 *return_value_da_grow1_2;
    return_value_da_grow1_2=da_grow1((struct anonymous_3 *)*za, (unsigned long int)((struct anonymous_30 *)0)->elem, sizeof(unsigned char *) /*8ul*/ , free_zone);
    *za = (struct anonymous_30 *)return_value_da_grow1_2;
    _Bool tmp_if_expr_4;
    if(*za == ((struct anonymous_30 *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_malloc_3=malloc(sz);
      z = (unsigned char *)return_value_malloc_3;
      (*za)->elem[(signed long int)((*za)->nel - (unsigned long int)1)] = z;
      tmp_if_expr_4 = !((*za)->elem[(signed long int)((*za)->nel - (unsigned long int)1)] != ((unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      return "out of memory!";

    else
    {
      memcpy((void *)z, (const void *)rhn, sz);
      return (const char *)(void *)0;
    }
  }
}

