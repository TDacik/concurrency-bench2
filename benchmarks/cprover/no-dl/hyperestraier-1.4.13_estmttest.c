// tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']
// file /usr/include/qdbm/cabin.h line 74
struct anonymous$9;

// tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|S32'asize']
// file /usr/include/qdbm/cabin.h line 46
struct anonymous$2;

// tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']
// file /usr/include/qdbm/cabin.h line 52
struct anonymous$28;

// tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']
// file estraier.h line 398
struct anonymous;

// tag-#anon#ST[*{S8}$S8$'name'|S32'nsiz'|U32'$pad0'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'nlist'|*{S8}$S8$'oper'|*{S8}$S8$'val'|S32'vsiz'|U32'$pad1'|*{cS8}$cS8$'cop'|S32'sign'|U32'$pad2'|*{S8}$S8$'sval'|S32'ssiz'|U32'$pad3'|*{V}$V$'regex'|S64'num']
// file estraier.c line 240
struct anonymous$11;

// tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']
// file estraier.h line 390
struct anonymous$3;

// tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']
// file /usr/include/qdbm/curia.h line 43
struct anonymous$4;

// tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']
// file /usr/include/qdbm/depot.h line 42
struct anonymous$5;

// tag-#anon#ST[*{S8}$S8$'phrase'|S32'gstep'|S32'tfidf'|S32'pmode'|U32'$pad0'|*{V(*{cS8}$cS8$|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$)->V}$V(*{cS8}$cS8$|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$)->V$'cbxpn'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'attrs'|*{S8}$S8$'order'|S32'max'|S32'skip'|S32'auxmin'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxwords'|S32'scfb'|U32'$pad2'|*{S32}$S32$'scores'|S32'snum'|U32'$pad3'|*{cS32}$cS32$'nscores'|S32'nsnum'|S32'opts'|F64'ecllim'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'shadows'|*{S8}$S8$'distinct'|S32'mask'|U32'$pad4']
// file estraier.h line 256
struct anonymous$8;

// tag-#anon#ST[*{S8}$S8$'url'|*{S8}$S8$'pxhost'|S32'pxport'|S32'timeout'|*{S8}$S8$'auth'|*{S8}$S8$'name'|*{S8}$S8$'label'|S32'dnum'|S32'wnum'|F64'size'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'admins'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'users'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'links'|S32'wwidth'|S32'hwidth'|S32'awidth'|U32'$pad0'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'ilist'|*{S8}$S8$'iprev'|S32'status'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'heads']
// file estnode.h line 177
struct anonymous$24;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']
// file /usr/include/qdbm/cabin.h line 57
struct anonymous$1;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#$'db'|*{S8}$S8$'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']
// file estmtdb.h line 37
struct anonymous$14;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']
// file /usr/include/qdbm/villa.h line 85
struct anonymous$7;

// tag-#anon#ST[*{SYM#tag-_ESTRESDOC#}$SYM#tag-_ESTRESDOC#$'docs'|S32'top'|S32'max'|S32'dnum'|U32'$pad0'|*{*{SYM#tag-_ESTRESDOC#}$SYM#tag-_ESTRESDOC#$}$*{SYM#tag-_ESTRESDOC#}$SYM#tag-_ESTRESDOC#$$'survivors'|S32'snum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'hints'|S64'mdate']
// file estnode.h line 65
struct anonymous$17;

// tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$40;

// tag-#anon#ST[*{V}$V$'db'|S32'type'|U32'$pad0']
// file estraier.c line 199
struct anonymous$16;

// tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$38;

// tag-#anon#ST[*{cS8}$cS8$'key'|S32'score'|U32'$pad0']
// file estraier.h line 779
struct anonymous$10;

// tag-#anon#ST[*{cS8}$cS8$'word'|S32'wsiz'|S32'pt']
// file estraier.c line 255
struct anonymous$31;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$18;

// tag-#anon#ST[ARR16{U64}$U64$'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$25;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']#$'__cancel_jmp_buf'|ARR4{*{V}$V$}$*{V}$V$$'__pad']
// file /usr/include/pthread.h line 525
struct anonymous$22;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'|S32'__mask_was_saved'|U32'$pad0']
// file /usr/include/pthread.h line 527
struct anonymous$21;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$19;

// tag-#anon#ST[S32'alive'|U32'$pad0'|*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']#$'cond'|*{cS8}$cS8$'url'|*{cS8}$cS8$'pxhost'|S32'pxport'|S32'limsize'|*{cS8}$cS8$'auth'|*{cSYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$cSYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'reqheads'|*{cS8}$cS8$'reqbody'|S32'rbsiz'|U32'$pad1'|*{S32}$S32$'rescodep'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'resheads'|*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|S32'asize']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|S32'asize']#$'resbody']
// file estnode.c line 44
struct anonymous$27;

// tag-#anon#ST[S32'db'|S32'id'|S32'score'|U32'$pad0'|*{S8}$S8$'value']
// file estraier.c line 261
struct anonymous$32;

// tag-#anon#ST[S32'id'|S32'score'|*{S8}$S8$'value']
// file estraier.c line 234
struct anonymous$6;

// tag-#anon#ST[S32'id'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'dtexts'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'kwords']
// file estraier.h line 72
struct anonymous$0;

// tag-#anon#ST[S32'id'|U32'$pad0'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#$'db'|*{S8}$S8$'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#$'db'|*{S8}$S8$'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']#$'db'|*{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#$'db'|*{S8}$S8$'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#$'db'|*{S8}$S8$'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#$'db'|*{S8}$S8$'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'inode'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'metadb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'omode'|U32'$pad0'|ARR256{*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$}$*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$$'dbs'|S32'dnum'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'cdb']#$'idxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'fwmdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'auxdb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'xfmdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'attrdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'textdb'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'attr'|*{*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$$'depots'|S32'dnum'|S32'inum'|S32'lrnum'|U32'$pad0']#$'kwddb'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'depot'|*{S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32}$S32(*{cS8}$cS8$|S32|*{cS8}$cS8$|S32)->S32$'cmp'|S32'wmode'|S32'cmode'|S32'root'|S32'last'|S32'lnum'|S32'nnum'|S32'rnum'|U32'$pad0'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'leafc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'nodec'|ARR64{S32}$S32$'hist'|S32'hnum'|S32'hleaf'|S32'lleaf'|S32'curleaf'|S32'curknum'|S32'curvnum'|S32'leafrecmax'|S32'nodeidxmax'|S32'leafcnum'|S32'nodecnum'|S32'avglsiz'|S32'avgnsiz'|S32'tran'|S32'rbroot'|S32'rblast'|S32'rblnum'|S32'rbnnum'|S32'rbrnum']#$'listdb'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'aidxs'|*{SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#}$SYM#tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#}$SYM#tag-#anon#ST[*{S8}$S8$'dptr'|S32'dsize'|U32'$pad0']#$'array'|S32'anum'|S32'start'|S32'num'|U32'$pad0']#$'pdocs'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'puris'|S32'ecode'|S32'fatal'|S32'dseq'|S32'dnum'|S32'amode'|S32'zmode'|S32'smode'|U32'$pad1'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'idxcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'auxcc'|U64'icsiz'|U64'icmax'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'outcc'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'keycc'|S32'kcmnum'|U32'$pad2'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'attrcc'|S32'acmnum'|U32'$pad3'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'textcc'|S32'tcmnum'|U32'$pad4'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'veccc'|S32'vcmnum'|U32'$pad5'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'rescc'|S32'rcmnum'|U32'$pad6'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'spacc'|S32'scmnum'|U32'$pad7'|*{S8}$S8$'scname'|*{V(*{cS8}$cS8$|*{V}$V$)->V}$V(*{cS8}$cS8$|*{V}$V$)->V$'infocb'|*{V}$V$'infoop'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|S32'wmode'|S32'inode'|S64'mtime'|S32'fd'|S32'fsiz'|*{S8}$S8$'map'|S32'msiz'|U32'$pad0'|*{S32}$S32$'buckets'|S32'bnum'|S32'rnum'|S32'fatal'|S32'ioff'|*{S32}$S32$'fbpool'|S32'fbpsiz'|S32'fbpinc'|S32'align'|U32'$pad1']#$'dfdb'|S32'wildmax'|U32'$pad8'|*{SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#}$SYM#tag-#anon#ST[*{*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$}$*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$$'buckets'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'first'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'last'|*{SYM#tag-_CBMAPDATUM#}$SYM#tag-_CBMAPDATUM#$'cur'|S32'bnum'|S32'rnum']#$'metacc'|S32'flsflag'|S32'intflag']#$'db'|*{S8}$S8$'path'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'mutex']#$$'others'|S32'dnum'|U32'$pad1']
// file estmttest.c line 24
struct anonymous$29;

// tag-#anon#ST[S32'quot'|S32'rem']
// file /usr/include/stdlib.h line 97
struct anonymous$15;

// tag-#anon#ST[S32'rm_so'|S32'rm_eo']
// file /usr/include/regex.h line 452
struct anonymous$44;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$34;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$37;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$36;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$42;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$35;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$39;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V$'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$43;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'|ARR8{U16}$U16$'__u6_addr16'|ARR4{U32}$U32$'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous$23;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$41;

// tag-#anon#UN[ARR4{S8}$S8$'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$12;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$20;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$13;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$26;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$30;

// tag-_CBMAPDATUM
// file /usr/include/qdbm/cabin.h line 64
struct _CBMAPDATUM;

// tag-_ESTRESDOC
// file estnode.h line 55
struct _ESTRESDOC;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-md5_state_s
// file md5.h line 67
struct md5_state_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// VL_CMPLEX$object
//
signed int VL_CMPLEX$object(const char *, signed int, const char *, signed int);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$22 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$22 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$22 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$30, unsigned int *);
// acos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 54
extern double acos(double);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$30, unsigned int);
// cbbaseencode
// file /usr/include/qdbm/cabin.h line 885
char * cbbaseencode(const char *, signed int);
// cbdatumcat
// file /usr/include/qdbm/cabin.h line 322
void cbdatumcat(struct anonymous$2 *, const char *, signed int);
// cbdatumclose
// file /usr/include/qdbm/cabin.h line 314
void cbdatumclose(struct anonymous$2 *);
// cbdatumopen
// file /usr/include/qdbm/cabin.h line 302
struct anonymous$2 * cbdatumopen(const char *, signed int);
// cbdatumprintf
// file /usr/include/qdbm/cabin.h line 353
void cbdatumprintf(struct anonymous$2 *, const char *, ...);
// cbdatumptr
// file /usr/include/qdbm/cabin.h line 330
const char * cbdatumptr(const struct anonymous$2 *);
// cbdatumsetbuf
// file /usr/include/qdbm/cabin.h line 1284
void cbdatumsetbuf(struct anonymous$2 *, char *, signed int);
// cbdatumsize
// file /usr/include/qdbm/cabin.h line 336
signed int cbdatumsize(const struct anonymous$2 *);
// cbdatumtomalloc
// file /usr/include/qdbm/cabin.h line 366
char * cbdatumtomalloc(struct anonymous$2 *, signed int *);
// cbdirlist
// file /usr/include/qdbm/cabin.h line 809
struct anonymous$1 * cbdirlist(const char *);
// cbglobalgc
// file /usr/include/qdbm/cabin.h line 142
void cbglobalgc(void *, void (*)(void *));
// cblistclose
// file /usr/include/qdbm/cabin.h line 383
void cblistclose(struct anonymous$1 *);
// cblistdump
// file /usr/include/qdbm/cabin.h line 510
char * cblistdump(const struct anonymous$1 *, signed int *);
// cblistdup
// file /usr/include/qdbm/cabin.h line 377
struct anonymous$1 * cblistdup(const struct anonymous$1 *);
// cblistload
// file /usr/include/qdbm/cabin.h line 517
struct anonymous$1 * cblistload(const char *, signed int);
// cblistnum
// file /usr/include/qdbm/cabin.h line 389
signed int cblistnum(const struct anonymous$1 *);
// cblistopen
// file /usr/include/qdbm/cabin.h line 371
struct anonymous$1 * cblistopen(void);
// cblistover
// file /usr/include/qdbm/cabin.h line 474
void cblistover(struct anonymous$1 *, signed int, const char *, signed int);
// cblistpush
// file /usr/include/qdbm/cabin.h line 409
void cblistpush(struct anonymous$1 *, const char *, signed int);
// cblistshift
// file /usr/include/qdbm/cabin.h line 441
char * cblistshift(struct anonymous$1 *, signed int *);
// cblistsort
// file /usr/include/qdbm/cabin.h line 480
void cblistsort(struct anonymous$1 *);
// cblistunshift
// file /usr/include/qdbm/cabin.h line 429
void cblistunshift(struct anonymous$1 *, const char *, signed int);
// cblistval
// file /usr/include/qdbm/cabin.h line 401
const char * cblistval(const struct anonymous$1 *, signed int, signed int *);
// cbmalloc
// file /usr/include/qdbm/cabin.h line 105
void * cbmalloc(unsigned long int);
// cbmapclose
// file /usr/include/qdbm/cabin.h line 535
void cbmapclose(struct anonymous$9 *);
// cbmapdump
// file /usr/include/qdbm/cabin.h line 655
char * cbmapdump(struct anonymous$9 *, signed int *);
// cbmapdup
// file /usr/include/qdbm/cabin.h line 529
struct anonymous$9 * cbmapdup(struct anonymous$9 *);
// cbmapget
// file /usr/include/qdbm/cabin.h line 584
const char * cbmapget(const struct anonymous$9 *, const char *, signed int, signed int *);
// cbmapiterinit
// file /usr/include/qdbm/cabin.h line 601
void cbmapiterinit(struct anonymous$9 *);
// cbmapiternext
// file /usr/include/qdbm/cabin.h line 613
const char * cbmapiternext(struct anonymous$9 *, signed int *);
// cbmapiterval
// file /usr/include/qdbm/cabin.h line 623
const char * cbmapiterval(const char *, signed int *);
// cbmapkeys
// file /usr/include/qdbm/cabin.h line 637
struct anonymous$1 * cbmapkeys(struct anonymous$9 *);
// cbmapload
// file /usr/include/qdbm/cabin.h line 662
struct anonymous$9 * cbmapload(const char *, signed int);
// cbmaploadone
// file /usr/include/qdbm/cabin.h line 677
char * cbmaploadone(const char *, signed int, const char *, signed int, signed int *);
// cbmapmove
// file /usr/include/qdbm/cabin.h line 595
signed int cbmapmove(struct anonymous$9 *, const char *, signed int, signed int);
// cbmapopen
// file /usr/include/qdbm/cabin.h line 522
struct anonymous$9 * cbmapopen(void);
// cbmapopenex
// file /usr/include/qdbm/cabin.h line 1298
struct anonymous$9 * cbmapopenex(signed int);
// cbmapout
// file /usr/include/qdbm/cabin.h line 570
signed int cbmapout(struct anonymous$9 *, const char *, signed int);
// cbmapput
// file /usr/include/qdbm/cabin.h line 548
signed int cbmapput(struct anonymous$9 *, const char *, signed int, const char *, signed int, signed int);
// cbmapputcat
// file /usr/include/qdbm/cabin.h line 560
void cbmapputcat(struct anonymous$9 *, const char *, signed int, const char *, signed int);
// cbmaprnum
// file /usr/include/qdbm/cabin.h line 629
signed int cbmaprnum(const struct anonymous$9 *);
// cbmemdup
// file /usr/include/qdbm/cabin.h line 126
char * cbmemdup(const char *, signed int);
// cbmyfatal
// file /usr/include/qdbm/cabin.h line 1270
void * cbmyfatal(const char *);
// cbreadfile
// file /usr/include/qdbm/cabin.h line 783
char * cbreadfile(const char *, signed int *);
// cbrealloc
// file /usr/include/qdbm/cabin.h line 114
void * cbrealloc(void *, unsigned long int);
// cbsplit
// file /usr/include/qdbm/cabin.h line 771
struct anonymous$1 * cbsplit(const char *, signed int, const char *);
// cbsprintf
// file /usr/include/qdbm/cabin.h line 748
char * cbsprintf(const char *, ...);
// cbstdiobin
// file /usr/include/qdbm/cabin.h line 1258
void cbstdiobin(void);
// cbstrbwmatch
// file /usr/include/qdbm/cabin.h line 230
signed int cbstrbwmatch(const char *, const char *);
// cbstrfwimatch
// file /usr/include/qdbm/cabin.h line 223
signed int cbstrfwimatch(const char *, const char *);
// cbstrfwmatch
// file /usr/include/qdbm/cabin.h line 215
signed int cbstrfwmatch(const char *, const char *);
// cbstricmp
// file /usr/include/qdbm/cabin.h line 208
signed int cbstricmp(const char *, const char *);
// cbstrmktime
// file /usr/include/qdbm/cabin.h line 1245
signed long int cbstrmktime(const char *);
// cbstrsqzspc
// file /usr/include/qdbm/cabin.h line 280
char * cbstrsqzspc(char *);
// cbstrtrim
// file /usr/include/qdbm/cabin.h line 274
char * cbstrtrim(char *);
// cburlbreak
// file /usr/include/qdbm/cabin.h line 843
struct anonymous$9 * cburlbreak(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$30, unsigned int);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// crbnum
// file /usr/include/qdbm/curia.h line 264
signed int crbnum(struct anonymous$4 *);
// crclose
// file /usr/include/qdbm/curia.h line 101
signed int crclose(struct anonymous$4 *);
// crfsizd
// file /usr/include/qdbm/curia.h line 257
double crfsizd(struct anonymous$4 *);
// crget
// file /usr/include/qdbm/curia.h line 146
char * crget(struct anonymous$4 *, const char *, signed int, signed int, signed int, signed int *);
// crgetlob
// file /usr/include/qdbm/curia.h line 398
char * crgetlob(struct anonymous$4 *, const char *, signed int, signed int, signed int, signed int *);
// criterinit
// file /usr/include/qdbm/curia.h line 181
signed int criterinit(struct anonymous$4 *);
// criternext
// file /usr/include/qdbm/curia.h line 197
char * criternext(struct anonymous$4 *, signed int *);
// crmemflush
// file /usr/include/qdbm/curia.h line 448
signed int crmemflush(struct anonymous$4 *);
// cropen
// file /usr/include/qdbm/curia.h line 92
struct anonymous$4 * cropen(const char *, signed int, signed int, signed int);
// croptimize
// file /usr/include/qdbm/curia.h line 236
signed int croptimize(struct anonymous$4 *, signed int);
// crout
// file /usr/include/qdbm/curia.h line 127
signed int crout(struct anonymous$4 *, const char *, signed int);
// croutlob
// file /usr/include/qdbm/curia.h line 378
signed int croutlob(struct anonymous$4 *, const char *, signed int);
// crput
// file /usr/include/qdbm/curia.h line 117
signed int crput(struct anonymous$4 *, const char *, signed int, const char *, signed int, signed int);
// crputlob
// file /usr/include/qdbm/curia.h line 368
signed int crputlob(struct anonymous$4 *, const char *, signed int, const char *, signed int, signed int);
// crrepair
// file /usr/include/qdbm/curia.h line 317
signed int crrepair(const char *);
// crsetalign
// file /usr/include/qdbm/curia.h line 210
signed int crsetalign(struct anonymous$4 *, signed int);
// crsetfbpsiz
// file /usr/include/qdbm/curia.h line 219
signed int crsetfbpsiz(struct anonymous$4 *, signed int);
// crsync
// file /usr/include/qdbm/curia.h line 226
signed int crsync(struct anonymous$4 *);
// crvsiz
// file /usr/include/qdbm/curia.h line 174
signed int crvsiz(struct anonymous$4 *, const char *, signed int);
// dbinform
// file estmttest.c line 115
static void dbinform(const char *message, void *opaque);
// deflate
// file /usr/include/zlib.h line 246
extern signed int deflate(struct z_stream_s *, signed int);
// deflateEnd
// file /usr/include/zlib.h line 353
extern signed int deflateEnd(struct z_stream_s *);
// deflateInit2_
// file /usr/include/zlib.h line 1637
extern signed int deflateInit2_(struct z_stream_s *, signed int, signed int, signed int, signed int, signed int, const char *, signed int);
// div
// file /usr/include/stdlib.h line 788
extern struct anonymous$15 div(signed int, signed int);
// dpclose
// file /usr/include/qdbm/depot.h line 145
signed int dpclose(struct anonymous$5 *);
// dpecodeptr
// file /usr/include/qdbm/depot.h line 454
signed int * dpecodeptr(void);
// dpfsiz
// file /usr/include/qdbm/depot.h line 295
signed int dpfsiz(struct anonymous$5 *);
// dpget
// file /usr/include/qdbm/depot.h line 190
char * dpget(struct anonymous$5 *, const char *, signed int, signed int, signed int, signed int *);
// dpgetflags
// file /usr/include/qdbm/depot.h line 472
signed int dpgetflags(struct anonymous$5 *);
// dpgetwb
// file /usr/include/qdbm/depot.h line 207
signed int dpgetwb(struct anonymous$5 *, const char *, signed int, signed int, signed int, char *);
// dpinnerhash
// file /usr/include/qdbm/depot.h line 404
signed int dpinnerhash(const char *, signed int);
// dpmemflush
// file /usr/include/qdbm/depot.h line 466
signed int dpmemflush(struct anonymous$5 *);
// dpopen
// file /usr/include/qdbm/depot.h line 136
struct anonymous$5 * dpopen(const char *, signed int, signed int);
// dpoptimize
// file /usr/include/qdbm/depot.h line 280
signed int dpoptimize(struct anonymous$5 *, signed int);
// dpout
// file /usr/include/qdbm/depot.h line 171
signed int dpout(struct anonymous$5 *, const char *, signed int);
// dpouterhash
// file /usr/include/qdbm/depot.h line 413
signed int dpouterhash(const char *, signed int);
// dpput
// file /usr/include/qdbm/depot.h line 161
signed int dpput(struct anonymous$5 *, const char *, signed int, const char *, signed int, signed int);
// dprepair
// file /usr/include/qdbm/depot.h line 362
signed int dprepair(const char *);
// dprnum
// file /usr/include/qdbm/depot.h line 317
signed int dprnum(struct anonymous$5 *);
// dpsetfbpsiz
// file /usr/include/qdbm/depot.h line 263
signed int dpsetfbpsiz(struct anonymous$5 *, signed int);
// dpsetflags
// file /usr/include/qdbm/depot.h line 479
signed int dpsetflags(struct anonymous$5 *, signed int);
// dpsync
// file /usr/include/qdbm/depot.h line 270
signed int dpsync(struct anonymous$5 *);
// dpwritable
// file /usr/include/qdbm/depot.h line 323
signed int dpwritable(struct anonymous$5 *);
// est_accept_conn
// file estnode.c line 1406
signed int est_accept_conn(signed int sock, char *abuf, signed int *pp);
// est_aidx_attr_narrow
// file estraier.c line 7563
static signed int est_aidx_attr_narrow(struct anonymous$7 *db, const struct anonymous$1 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous$6 *scores, signed int snum);
// est_aidx_attr_out
// file estraier.c line 7534
static signed int est_aidx_attr_out(struct anonymous$7 *db, signed int id, const char *vbuf, signed int vsiz);
// est_aidx_attr_put
// file estraier.c line 7513
static signed int est_aidx_attr_put(struct anonymous$7 *db, signed int id, const char *vbuf, signed int vsiz);
// est_aidx_numcmp
// file estraier.c line 7500
static signed int est_aidx_numcmp(const char *aptr, signed int asiz, const char *bptr, signed int bsiz);
// est_aidx_seq_get
// file estraier.c line 7439
static char * est_aidx_seq_get(struct anonymous$5 *db, signed int id, signed int *sp);
// est_aidx_seq_narrow
// file estraier.c line 7461
static signed int est_aidx_seq_narrow(struct anonymous$5 *db, const struct anonymous$1 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous$6 *scores, signed int snum, signed int limit, signed int *restp);
// est_aidx_seq_out
// file estraier.c line 7426
static signed int est_aidx_seq_out(struct anonymous$5 *db, signed int id);
// est_aidx_seq_put
// file estraier.c line 7413
static signed int est_aidx_seq_put(struct anonymous$5 *db, signed int id, const char *vbuf, signed int vsiz);
// est_border_str
// file estraier.c line 4042
const char * est_border_str(void);
// est_break_text
// file estraier.c line 3376
void est_break_text(const char *text, struct anonymous$1 *list, signed int norm, signed int tail);
// est_break_text_chrcat
// file estraier.c line 3509
void est_break_text_chrcat(const char *text, struct anonymous$1 *list, signed int norm);
// est_break_text_perfng
// file estraier.c line 3439
void est_break_text_perfng(const char *text, struct anonymous$1 *list, signed int norm, signed int tail);
// est_bzdecode
// file estraier.c line 3990
char * est_bzdecode(const char *ptr, signed int size, signed int *sp);
// est_bzencode
// file estraier.c line 3936
char * est_bzencode(const char *ptr, signed int size, signed int *sp);
// est_canonicalize_text
// file estraier.c line 6242
static void est_canonicalize_text(unsigned char *utext, signed int size, signed int funcspc);
// est_char_category
// file estraier.c line 6363
static signed int est_char_category(signed int c);
// est_char_category_chrcat
// file estraier.c line 6399
static signed int est_char_category_chrcat(signed int c);
// est_char_category_perfng
// file estraier.c line 6390
static signed int est_char_category_perfng(signed int c);
// est_check_cjk_only
// file estraier.c line 6516
static signed int est_check_cjk_only(const char *str);
// est_check_numbt
// file estraier.c line 10174
static signed int est_check_numbt(const char *tval, const char *oval);
// est_check_strand
// file estraier.c line 10073
static signed int est_check_strand(const char *tval, const char *oval);
// est_check_stror
// file estraier.c line 10109
static signed int est_check_stror(const char *tval, const char *oval);
// est_check_stroreq
// file estraier.c line 10145
static signed int est_check_stroreq(const char *tval, const char *oval);
// est_cond_add_attr
// file estraier.h line 313
void est_cond_add_attr(struct anonymous$8 *cond, const char *expr);
// est_cond_attrs
// file estraier.c line 4315
const struct anonymous$1 * est_cond_attrs(struct anonymous$8 *cond);
// est_cond_auxiliary
// file estraier.c line 4350
signed int est_cond_auxiliary(struct anonymous$8 *cond);
// est_cond_auxiliary_word
// file estraier.c line 4395
signed int est_cond_auxiliary_word(struct anonymous$8 *cond, const char *word);
// est_cond_delete
// file estraier.h line 301
void est_cond_delete(struct anonymous$8 *cond);
// est_cond_distinct
// file estraier.c line 4357
const char * est_cond_distinct(struct anonymous$8 *cond);
// est_cond_dup
// file estraier.c line 4277
struct anonymous$8 * est_cond_dup(struct anonymous$8 *cond);
// est_cond_mask
// file estraier.c line 4364
signed int est_cond_mask(struct anonymous$8 *cond);
// est_cond_max
// file estraier.c line 4329
signed int est_cond_max(struct anonymous$8 *cond);
// est_cond_new
// file estraier.h line 296
struct anonymous$8 * est_cond_new(void);
// est_cond_options
// file estraier.c line 4343
signed int est_cond_options(struct anonymous$8 *cond);
// est_cond_order
// file estraier.c line 4322
const char * est_cond_order(struct anonymous$8 *cond);
// est_cond_phrase
// file estraier.c line 4308
const char * est_cond_phrase(struct anonymous$8 *cond);
// est_cond_score
// file estraier.c line 4371
signed int est_cond_score(struct anonymous$8 *cond, signed int index);
// est_cond_scores
// file estraier.c line 4379
const signed int * est_cond_scores(struct anonymous$8 *cond, signed int *nump);
// est_cond_set_auxiliary
// file estraier.c line 855
void est_cond_set_auxiliary(struct anonymous$8 *cond, signed int min);
// est_cond_set_distinct
// file estraier.c line 869
void est_cond_set_distinct(struct anonymous$8 *cond, const char *name);
// est_cond_set_eclipse
// file estraier.c line 862
void est_cond_set_eclipse(struct anonymous$8 *cond, double limit);
// est_cond_set_expander
// file estraier.c line 4418
void est_cond_set_expander(struct anonymous$8 *cond, void (*func)(const char *, struct anonymous$1 *));
// est_cond_set_expander::func$object
//
void func$object(const char *, struct anonymous$1 *);
// est_cond_set_mask
// file estraier.c line 881
void est_cond_set_mask(struct anonymous$8 *cond, signed int mask);
// est_cond_set_max
// file estraier.c line 824
void est_cond_set_max(struct anonymous$8 *cond, signed int max);
// est_cond_set_narrowing_scores
// file estraier.c line 4387
void est_cond_set_narrowing_scores(struct anonymous$8 *cond, const signed int *scores, signed int num);
// est_cond_set_options
// file estraier.c line 838
void est_cond_set_options(struct anonymous$8 *cond, signed int options);
// est_cond_set_order
// file estraier.h line 319
void est_cond_set_order(struct anonymous$8 *cond, const char *expr);
// est_cond_set_phrase
// file estraier.h line 307
void est_cond_set_phrase(struct anonymous$8 *cond, const char *phrase);
// est_cond_set_skip
// file estraier.c line 831
void est_cond_set_skip(struct anonymous$8 *cond, signed int skip);
// est_cond_shadows
// file estraier.c line 4404
const signed int * est_cond_shadows(struct anonymous$8 *cond, signed int id, signed int *np);
// est_cond_skip
// file estraier.c line 4336
signed int est_cond_skip(struct anonymous$8 *cond);
// est_crget
// file estraier.c line 7370
static char * est_crget(struct anonymous$4 *curia, signed int zmode, signed int id, signed int *sp);
// est_crout
// file estraier.c line 7357
static signed int est_crout(struct anonymous$4 *curia, signed int id);
// est_crput
// file estraier.c line 7307
static signed int est_crput(struct anonymous$4 *curia, signed int zmode, signed int id, const char *vbuf, signed int vsiz, signed int dmode);
// est_db_add_attr_index
// file estraier.c line 1341
signed int est_db_add_attr_index(struct anonymous *db, const char *name, signed int type);
// est_db_add_meta
// file estraier.c line 4525
void est_db_add_meta(struct anonymous *db, const char *name, const char *value);
// est_db_add_pseudo_index
// file estraier.c line 3335
signed int est_db_add_pseudo_index(struct anonymous *db, const char *path);
// est_db_attr_index_exprs
// file estraier.c line 5082
struct anonymous$1 * est_db_attr_index_exprs(struct anonymous *db);
// est_db_cache_num
// file estraier.c line 4957
signed int est_db_cache_num(struct anonymous *db);
// est_db_charge_rescc
// file estraier.c line 5038
void est_db_charge_rescc(struct anonymous *db, signed int max);
// est_db_check_option
// file estraier.c line 4432
signed int est_db_check_option(struct anonymous *db, signed int option);
// est_db_close
// file estraier.c line 1263
signed int est_db_close(struct anonymous *db, signed int *ecp);
// est_db_doc_num
// file estraier.c line 2702
signed int est_db_doc_num(struct anonymous *db);
// est_db_edit_doc
// file estraier.c line 2431
signed int est_db_edit_doc(struct anonymous *db, struct anonymous$0 *doc);
// est_db_error
// file estraier.c line 1327
signed int est_db_error(struct anonymous *db);
// est_db_etch_doc
// file estraier.c line 4560
struct anonymous$9 * est_db_etch_doc(struct anonymous *db, struct anonymous$0 *doc, signed int max);
// est_db_fatal
// file estraier.c line 1334
signed int est_db_fatal(struct anonymous *db);
// est_db_fill_key_cache
// file estraier.c line 4994
void est_db_fill_key_cache(struct anonymous *db);
// est_db_flush
// file estraier.c line 1468
signed int est_db_flush(struct anonymous *db, signed int max);
// est_db_get_doc
// file estraier.c line 2533
struct anonymous$0 * est_db_get_doc(struct anonymous *db, signed int id, signed int options);
// est_db_get_doc_attr
// file estraier.c line 2630
char * est_db_get_doc_attr(struct anonymous *db, signed int id, const char *name);
// est_db_get_doc_entity
// file estraier.c line 4513
char * est_db_get_doc_entity(struct anonymous *db, signed int id, signed int *sp);
// est_db_get_keywords
// file estraier.c line 4774
struct anonymous$9 * est_db_get_keywords(struct anonymous *db, signed int id);
// est_db_inform
// file estraier.c line 7801
static void est_db_inform(struct anonymous *db, const char *info);
// est_db_inode
// file estraier.c line 4475
signed int est_db_inode(struct anonymous *db);
// est_db_interrupt
// file estraier.c line 5110
void est_db_interrupt(struct anonymous *db);
// est_db_iter_init
// file estraier.c line 4815
signed int est_db_iter_init(struct anonymous *db, const char *prev);
// est_db_iter_next
// file estraier.c line 4831
signed int est_db_iter_next(struct anonymous *db);
// est_db_keyword_iter_init
// file estraier.c line 4901
signed int est_db_keyword_iter_init(struct anonymous *db);
// est_db_keyword_iter_next
// file estraier.c line 4913
char * est_db_keyword_iter_next(struct anonymous *db);
// est_db_keyword_num
// file estraier.c line 4892
signed int est_db_keyword_num(struct anonymous *db);
// est_db_keyword_rec_size
// file estraier.c line 4931
signed int est_db_keyword_rec_size(struct anonymous *db, const char *word);
// est_db_keyword_search
// file estraier.c line 4939
signed int * est_db_keyword_search(struct anonymous *db, const char *word, signed int *nump);
// est_db_list_rescc
// file estraier.c line 5060
struct anonymous$1 * est_db_list_rescc(struct anonymous *db);
// est_db_measure_doc
// file estraier.c line 4803
signed int est_db_measure_doc(struct anonymous *db, signed int id, signed int parts);
// est_db_merge
// file estraier.c line 1891
signed int est_db_merge(struct anonymous *db, const char *name, signed int options);
// est_db_meta
// file estraier.c line 4549
char * est_db_meta(struct anonymous *db, const char *name);
// est_db_meta_names
// file estraier.c line 4541
struct anonymous$1 * est_db_meta_names(struct anonymous *db);
// est_db_name
// file estraier.c line 2695
const char * est_db_name(struct anonymous *db);
// est_db_open
// file estraier.c line 914
struct anonymous * est_db_open(const char *name, signed int omode, signed int *ecp);
// est_db_optimize
// file estraier.c line 1742
signed int est_db_optimize(struct anonymous *db, signed int options);
// est_db_out_doc
// file estraier.c line 2323
signed int est_db_out_doc(struct anonymous *db, signed int id, signed int options);
// est_db_out_keywords
// file estraier.c line 4731
signed int est_db_out_keywords(struct anonymous *db, signed int id);
// est_db_prepare_meta
// file estraier.c line 7816
static void est_db_prepare_meta(struct anonymous *db);
// est_db_pseudo_doc_num
// file estraier.c line 5075
signed int est_db_pseudo_doc_num(struct anonymous *db);
// est_db_put_doc
// file estraier.c line 2130
signed int est_db_put_doc(struct anonymous *db, struct anonymous$0 *doc, signed int options);
// est_db_put_keywords
// file estraier.c line 4696
signed int est_db_put_keywords(struct anonymous *db, signed int id, struct anonymous$9 *kwords, double weight);
// est_db_refresh_rescc
// file estraier.c line 5022
void est_db_refresh_rescc(struct anonymous *db);
// est_db_repair
// file estraier.c line 5117
signed int est_db_repair(const char *name, signed int options, signed int *ecp);
// est_db_scan_doc
// file estraier.c line 3226
signed int est_db_scan_doc(struct anonymous *db, struct anonymous$0 *doc, struct anonymous$8 *cond);
// est_db_score_doc
// file estraier.c line 7836
static signed int est_db_score_doc(struct anonymous *db, struct anonymous$0 *doc, struct anonymous$8 *cond, signed int *scp);
// est_db_search
// file estraier.c line 2746
signed int * est_db_search(struct anonymous *db, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints);
// est_db_search_meta
// file estraier.c line 3072
signed int * est_db_search_meta(struct anonymous **dbs, signed int dbnum, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints);
// est_db_set_cache_size
// file estraier.c line 3324
void est_db_set_cache_size(struct anonymous *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum);
// est_db_set_dfdb
// file estraier.c line 5015
void est_db_set_dfdb(struct anonymous *db, struct anonymous$5 *dfdb);
// est_db_set_doc_entity
// file estraier.c line 4482
signed int est_db_set_doc_entity(struct anonymous *db, signed int id, const char *ptr, signed int size);
// est_db_set_ecode
// file estraier.c line 4425
void est_db_set_ecode(struct anonymous *db, signed int ecode);
// est_db_set_informer
// file estraier.c line 4985
void est_db_set_informer(struct anonymous *db, void (*func)(const char *, void *), void *opaque);
// est_db_set_informer::func$object
//
void func$object(const char *, void *);
// est_db_set_special_cache
// file estraier.c line 4972
void est_db_set_special_cache(struct anonymous *db, const char *name, signed int num);
// est_db_set_wildmax
// file estraier.c line 4506
void est_db_set_wildmax(struct anonymous *db, signed int num);
// est_db_size
// file estraier.c line 2718
double est_db_size(struct anonymous *db);
// est_db_sync
// file estraier.c line 1692
signed int est_db_sync(struct anonymous *db);
// est_db_uri_to_id
// file estraier.c line 2681
signed int est_db_uri_to_id(struct anonymous *db, const char *uri);
// est_db_used_cache_size
// file estraier.c line 4964
signed int est_db_used_cache_size(struct anonymous *db);
// est_db_word_iter_init
// file estraier.c line 4853
signed int est_db_word_iter_init(struct anonymous *db);
// est_db_word_iter_next
// file estraier.c line 4865
char * est_db_word_iter_next(struct anonymous *db);
// est_db_word_num
// file estraier.c line 2709
signed int est_db_word_num(struct anonymous *db);
// est_db_word_rec_size
// file estraier.c line 4883
signed int est_db_word_rec_size(struct anonymous *db, const char *word);
// est_db_write_meta
// file estraier.c line 7774
static signed int est_db_write_meta(struct anonymous *db);
// est_decode_idx_rec
// file estraier.c line 6951
static void est_decode_idx_rec(struct anonymous$2 *datum, const char *vbuf, signed int vsiz, signed int smode);
// est_deflate
// file estraier.c line 3750
char * est_deflate(const char *ptr, signed int size, signed int *sp, signed int mode);
// est_doc_add_attr
// file estraier.h line 100
void est_doc_add_attr(struct anonymous$0 *doc, const char *name, const char *value);
// est_doc_add_hidden_text
// file estraier.h line 112
void est_doc_add_hidden_text(struct anonymous$0 *doc, const char *text);
// est_doc_add_text
// file estraier.h line 106
void est_doc_add_text(struct anonymous$0 *doc, const char *text);
// est_doc_attr
// file estraier.c line 616
const char * est_doc_attr(struct anonymous$0 *doc, const char *name);
// est_doc_attr_names
// file estraier.c line 596
struct anonymous$1 * est_doc_attr_names(struct anonymous$0 *doc);
// est_doc_cat_texts
// file estraier.c line 632
char * est_doc_cat_texts(struct anonymous$0 *doc);
// est_doc_delete
// file estraier.h line 93
void est_doc_delete(struct anonymous$0 *doc);
// est_doc_dump_draft
// file estraier.c line 664
char * est_doc_dump_draft(struct anonymous$0 *doc);
// est_doc_dup
// file estraier.c line 4209
struct anonymous$0 * est_doc_dup(struct anonymous$0 *doc);
// est_doc_hidden_texts
// file estraier.c line 4229
const char * est_doc_hidden_texts(struct anonymous$0 *doc);
// est_doc_id
// file estraier.h line 134
signed int est_doc_id(struct anonymous$0 *doc);
// est_doc_is_empty
// file estraier.c line 4268
signed int est_doc_is_empty(struct anonymous$0 *doc);
// est_doc_keywords
// file estraier.c line 648
struct anonymous$9 * est_doc_keywords(struct anonymous$0 *doc);
// est_doc_make_snippet
// file estraier.c line 719
char * est_doc_make_snippet(struct anonymous$0 *doc, const struct anonymous$1 *words, signed int wwidth, signed int hwidth, signed int awidth);
// est_doc_new
// file estraier.h line 82
struct anonymous$0 * est_doc_new(void);
// est_doc_new_from_chaos
// file estmttest.c line 505
static struct anonymous$0 * est_doc_new_from_chaos(signed int cnum, signed int snum, signed int mode);
// est_doc_new_from_draft
// file estraier.c line 429
struct anonymous$0 * est_doc_new_from_draft(const char *draft);
// est_doc_score
// file estraier.c line 655
signed int est_doc_score(struct anonymous$0 *doc);
// est_doc_set_id
// file estraier.c line 4222
void est_doc_set_id(struct anonymous$0 *doc, signed int id);
// est_doc_set_keywords
// file estraier.c line 567
void est_doc_set_keywords(struct anonymous$0 *doc, struct anonymous$9 *kwords);
// est_doc_set_score
// file estraier.c line 575
void est_doc_set_score(struct anonymous$0 *doc, signed int score);
// est_doc_slim
// file estraier.c line 4238
void est_doc_slim(struct anonymous$0 *doc, signed int len);
// est_doc_texts
// file estraier.c line 624
const struct anonymous$1 * est_doc_texts(struct anonymous$0 *doc);
// est_eclipse_scores
// file estraier.c line 9858
static signed int est_eclipse_scores(struct anonymous *db, struct anonymous$6 *scores, signed int snum, signed int num, signed int vnum, signed int tfidf, double limit, struct anonymous$9 *shadows);
// est_enc_miss
// file estraier.c line 5917
static signed int est_enc_miss(const char *ptr, signed int size, const char *icode, const char *ocode);
// est_enc_name
// file estraier.c line 3604
const char * est_enc_name(const char *ptr, signed int size, signed int plang);
// est_encode_idx_rec
// file estraier.c line 6912
static void est_encode_idx_rec(struct anonymous$2 *datum, const char *vbuf, signed int vsiz, signed int lid, signed int smode);
// est_err_msg
// file estraier.h line 511
const char * est_err_msg(signed int ecode);
// est_expand_keyword_bw
// file estraier.c line 8347
static void est_expand_keyword_bw(struct anonymous *db, const char *word, struct anonymous$1 *list);
// est_expand_keyword_ew
// file estraier.c line 8366
static void est_expand_keyword_ew(struct anonymous *db, const char *word, struct anonymous$1 *list);
// est_expand_keyword_rx
// file estraier.c line 8387
static void est_expand_keyword_rx(struct anonymous *db, const char *word, struct anonymous$1 *list);
// est_expand_word_bw
// file estraier.c line 8284
static void est_expand_word_bw(struct anonymous *db, const char *word, struct anonymous$1 *list);
// est_expand_word_ew
// file estraier.c line 8303
static void est_expand_word_ew(struct anonymous *db, const char *word, struct anonymous$1 *list);
// est_expand_word_rx
// file estraier.c line 8324
static void est_expand_word_rx(struct anonymous *db, const char *word, struct anonymous$1 *list);
// est_ext_type
// file estraier.c line 5738
const char * est_ext_type(const char *ext);
// est_free_cattr_list
// file estraier.c line 9831
static void est_free_cattr_list(struct anonymous$11 *list, signed int anum);
// est_free_net_env
// file estnode.c line 110
void est_free_net_env(void);
// est_get_client_sock
// file estnode.c line 1422
signed int est_get_client_sock(const char *addr, signed int port);
// est_get_host_addr
// file estnode.c line 1312
char * est_get_host_addr(const char *name);
// est_get_host_name
// file estnode.c line 1298
const char * est_get_host_name(void);
// est_get_server_sock
// file estnode.c line 1368
signed int est_get_server_sock(const char *addr, signed int port);
// est_get_tvmap
// file estraier.c line 10366
static struct anonymous$9 * est_get_tvmap(struct anonymous *db, signed int id, signed int vnum, signed int tfidf);
// est_gethostaddrbyname
// file estnode.c line 1730
static char * est_gethostaddrbyname(const char *name);
// est_gettimeofday
// file estraier.c line 5632
double est_gettimeofday(void);
// est_global_lock
// file estmtdb.c line 782
static signed int est_global_lock(void);
// est_global_unlock
// file estmtdb.c line 788
static void est_global_unlock(void);
// est_hex_decode
// file estraier.c line 5895
static char * est_hex_decode(const char *str);
// est_hex_encode
// file estraier.c line 5878
static char * est_hex_encode(const char *str);
// est_hints_to_words
// file estraier.c line 5426
struct anonymous$1 * est_hints_to_words(struct anonymous$9 *hints);
// est_iconv
// file estraier.h line 842
char * est_iconv(const char *ptr, signed int size, const char *icode, const char *ocode, signed int *sp, signed int *mp);
// est_idx_add
// file estraier.c line 7107
static signed int est_idx_add(struct anonymous$3 *idx, const char *word, signed int wsiz, const char *vbuf, signed int vsiz, signed int smode);
// est_idx_close
// file estraier.c line 7034
static signed int est_idx_close(struct anonymous$3 *idx);
// est_idx_dnum
// file estraier.c line 7094
static signed int est_idx_dnum(struct anonymous$3 *idx);
// est_idx_get_one
// file estraier.c line 7189
static const char * est_idx_get_one(struct anonymous$3 *idx, signed int inum, const char *word, signed int wsiz, signed int *sp);
// est_idx_increment
// file estraier.c line 7068
static void est_idx_increment(struct anonymous$3 *idx);
// est_idx_memflush
// file estraier.c line 7249
static signed int est_idx_memflush(struct anonymous$3 *idx);
// est_idx_num
// file estraier.c line 7216
static signed int est_idx_num(struct anonymous$3 *idx);
// est_idx_open
// file estraier.c line 6991
static struct anonymous$3 * est_idx_open(const char *name, signed int omode, signed int dnum);
// est_idx_optimize
// file estraier.c line 7275
static signed int est_idx_optimize(struct anonymous$3 *idx);
// est_idx_out
// file estraier.c line 7145
static signed int est_idx_out(struct anonymous$3 *idx, const char *word, signed int wsiz);
// est_idx_put_one
// file estraier.c line 7131
static signed int est_idx_put_one(struct anonymous$3 *idx, signed int inum, const char *word, signed int wsiz, const char *vbuf, signed int vsiz);
// est_idx_rec_last_id
// file estraier.c line 6874
static signed int est_idx_rec_last_id(const char *vbuf, signed int vsiz, signed int smode);
// est_idx_scan
// file estraier.c line 7165
static char * est_idx_scan(struct anonymous$3 *idx, const char *word, signed int wsiz, signed int *sp, signed int smode);
// est_idx_set_current
// file estraier.c line 7287
static void est_idx_set_current(struct anonymous$3 *idx);
// est_idx_set_tuning
// file estraier.c line 7055
static void est_idx_set_tuning(struct anonymous$3 *idx, signed int lrecmax, signed int nidxmax, signed int lcnum, signed int ncnum, signed int fbpsiz);
// est_idx_size
// file estraier.c line 7225
static double est_idx_size(struct anonymous$3 *idx);
// est_idx_size_current
// file estraier.c line 7240
static signed int est_idx_size_current(struct anonymous$3 *idx);
// est_idx_sync
// file estraier.c line 7262
static signed int est_idx_sync(struct anonymous$3 *idx);
// est_idx_vsiz
// file estraier.c line 7201
static signed int est_idx_vsiz(struct anonymous$3 *idx, const char *word, signed int wsiz);
// est_inet_aton
// file estnode.c line 1782
static signed int est_inet_aton(const char *cp, struct in_addr *inp);
// est_inflate
// file estraier.c line 3819
char * est_inflate(const char *ptr, signed int size, signed int *sp, signed int mode);
// est_init_net_env
// file estnode.c line 87
signed int est_init_net_env(void);
// est_inode
// file estraier.c line 5595
signed int est_inode(const char *path);
// est_inodes_delete
// file estraier.c line 7727
static void est_inodes_delete(void *arg);
// est_inodes_delete_informer
// file estraier.c line 7764
static void est_inodes_delete_informer(const char *msg, void *opaque);
// est_int_compare
// file estraier.c line 7708
static signed int est_int_compare(const void *ap, const void *bp);
// est_keysc_compare
// file estraier.c line 10203
static signed int est_keysc_compare(const void *ap, const void *bp);
// est_kill
// file estraier.c line 5715
signed int est_kill(signed int pid, signed int sig);
// est_lzodecode
// file estraier.c line 3905
char * est_lzodecode(const char *ptr, signed int size, signed int *sp);
// est_lzoencode
// file estraier.c line 3882
char * est_lzoencode(const char *ptr, signed int size, signed int *sp);
// est_make_cattr_list
// file estraier.c line 9703
static struct anonymous$11 * est_make_cattr_list(const struct anonymous$1 *attrs, signed int *nump);
// est_make_crypt
// file estraier.c line 4088
char * est_make_crypt(const char *key);
// est_make_snippet
// file estraier.c line 6438
static char * est_make_snippet(const char *str, signed int len, const struct anonymous$1 *words, signed int wwidth, signed int hwidth, signed int awidth);
// est_match_attr
// file estraier.c line 10008
static signed int est_match_attr(const char *tval, signed int tsiz, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum);
// est_match_crypt
// file estraier.c line 4105
signed int est_match_crypt(const char *key, const char *hash);
// est_memory_usage
// file estraier.c line 5725
double est_memory_usage(void);
// est_metascore_compare_by_id_asc
// file estraier.c line 8168
static signed int est_metascore_compare_by_id_asc(const void *ap, const void *bp);
// est_metascore_compare_by_id_desc
// file estraier.c line 8178
static signed int est_metascore_compare_by_id_desc(const void *ap, const void *bp);
// est_metascore_compare_by_num_asc
// file estraier.c line 8228
static signed int est_metascore_compare_by_num_asc(const void *ap, const void *bp);
// est_metascore_compare_by_num_desc
// file estraier.c line 8238
static signed int est_metascore_compare_by_num_desc(const void *ap, const void *bp);
// est_metascore_compare_by_score_asc
// file estraier.c line 8188
static signed int est_metascore_compare_by_score_asc(const void *ap, const void *bp);
// est_metascore_compare_by_score_desc
// file estraier.c line 8198
static signed int est_metascore_compare_by_score_desc(const void *ap, const void *bp);
// est_metascore_compare_by_str_asc
// file estraier.c line 8208
static signed int est_metascore_compare_by_str_asc(const void *ap, const void *bp);
// est_metascore_compare_by_str_desc
// file estraier.c line 8218
static signed int est_metascore_compare_by_str_desc(const void *ap, const void *bp);
// est_mkdir
// file estraier.c line 5533
signed int est_mkdir(const char *path);
// est_mtdb_add_attr_index
// file estmtdb.c line 123
signed int est_mtdb_add_attr_index(struct anonymous$14 *db, const char *name, signed int type);
// est_mtdb_add_meta
// file estmtdb.c line 449
void est_mtdb_add_meta(struct anonymous$14 *db, const char *name, const char *value);
// est_mtdb_add_pseudo_index
// file estmtdb.c line 370
signed int est_mtdb_add_pseudo_index(struct anonymous$14 *db, const char *path);
// est_mtdb_attr_index_exprs
// file estmtdb.c line 744
struct anonymous$1 * est_mtdb_attr_index_exprs(struct anonymous$14 *db);
// est_mtdb_cache_num
// file estmtdb.c line 646
signed int est_mtdb_cache_num(struct anonymous$14 *db);
// est_mtdb_cache_usage
// file estmtdb.c line 768
double est_mtdb_cache_usage(struct anonymous$14 *db);
// est_mtdb_charge_rescc
// file estmtdb.c line 713
void est_mtdb_charge_rescc(struct anonymous$14 *db, signed int max);
// est_mtdb_check_option
// file estmtdb.c line 396
signed int est_mtdb_check_option(struct anonymous$14 *db, signed int option);
// est_mtdb_close
// file estmtdb.h line 49
signed int est_mtdb_close(struct anonymous$14 *db, signed int *ecp);
// est_mtdb_doc_num
// file estmtdb.h line 109
signed int est_mtdb_doc_num(struct anonymous$14 *db);
// est_mtdb_edit_doc
// file estmtdb.c line 200
signed int est_mtdb_edit_doc(struct anonymous$14 *db, struct anonymous$0 *doc);
// est_mtdb_error
// file estmtdb.h line 53
signed int est_mtdb_error(struct anonymous$14 *db);
// est_mtdb_etch_doc
// file estmtdb.c line 480
struct anonymous$9 * est_mtdb_etch_doc(struct anonymous$14 *db, struct anonymous$0 *doc, signed int max);
// est_mtdb_fatal
// file estmtdb.c line 112
signed int est_mtdb_fatal(struct anonymous$14 *db);
// est_mtdb_fill_key_cache
// file estmtdb.c line 686
void est_mtdb_fill_key_cache(struct anonymous$14 *db);
// est_mtdb_flush
// file estmtdb.h line 65
signed int est_mtdb_flush(struct anonymous$14 *db, signed int max);
// est_mtdb_get_doc
// file estmtdb.h line 93
struct anonymous$0 * est_mtdb_get_doc(struct anonymous$14 *db, signed int id, signed int options);
// est_mtdb_get_doc_attr
// file estmtdb.h line 97
char * est_mtdb_get_doc_attr(struct anonymous$14 *db, signed int id, const char *name);
// est_mtdb_get_doc_entity
// file estmtdb.h line 163
char * est_mtdb_get_doc_entity(struct anonymous$14 *db, signed int id, signed int *sp);
// est_mtdb_get_keywords
// file estmtdb.c line 514
struct anonymous$9 * est_mtdb_get_keywords(struct anonymous$14 *db, signed int id);
// est_mtdb_inode
// file estmtdb.c line 407
signed int est_mtdb_inode(struct anonymous$14 *db);
// est_mtdb_interrupt
// file estmtdb.h line 287
void est_mtdb_interrupt(struct anonymous$14 *db);
// est_mtdb_iter_init
// file estmtdb.c line 536
signed int est_mtdb_iter_init(struct anonymous$14 *db, const char *prev);
// est_mtdb_iter_next
// file estmtdb.c line 547
signed int est_mtdb_iter_next(struct anonymous$14 *db);
// est_mtdb_keyword_iter_init
// file estmtdb.c line 602
signed int est_mtdb_keyword_iter_init(struct anonymous$14 *db);
// est_mtdb_keyword_iter_next
// file estmtdb.c line 613
char * est_mtdb_keyword_iter_next(struct anonymous$14 *db);
// est_mtdb_keyword_num
// file estmtdb.c line 591
signed int est_mtdb_keyword_num(struct anonymous$14 *db);
// est_mtdb_keyword_rec_size
// file estmtdb.c line 624
signed int est_mtdb_keyword_rec_size(struct anonymous$14 *db, const char *word);
// est_mtdb_keyword_search
// file estmtdb.c line 635
signed int * est_mtdb_keyword_search(struct anonymous$14 *db, const char *word, signed int *nump);
// est_mtdb_list_rescc
// file estmtdb.c line 722
struct anonymous$1 * est_mtdb_list_rescc(struct anonymous$14 *db);
// est_mtdb_lock
// file estmtdb.c line 796
static signed int est_mtdb_lock(struct anonymous$14 *db);
// est_mtdb_measure_doc
// file estmtdb.c line 525
signed int est_mtdb_measure_doc(struct anonymous$14 *db, signed int id, signed int parts);
// est_mtdb_merge
// file estmtdb.c line 167
signed int est_mtdb_merge(struct anonymous$14 *db, const char *name, signed int options);
// est_mtdb_meta
// file estmtdb.c line 469
char * est_mtdb_meta(struct anonymous$14 *db, const char *name);
// est_mtdb_meta_names
// file estmtdb.c line 458
struct anonymous$1 * est_mtdb_meta_names(struct anonymous$14 *db);
// est_mtdb_name
// file estmtdb.h line 105
const char * est_mtdb_name(struct anonymous$14 *db);
// est_mtdb_open
// file estmtdb.h line 45
struct anonymous$14 * est_mtdb_open(const char *name, signed int omode, signed int *ecp);
// est_mtdb_optimize
// file estmtdb.h line 73
signed int est_mtdb_optimize(struct anonymous$14 *db, signed int options);
// est_mtdb_out_doc
// file estmtdb.h line 85
signed int est_mtdb_out_doc(struct anonymous$14 *db, signed int id, signed int options);
// est_mtdb_out_keywords
// file estmtdb.c line 503
signed int est_mtdb_out_keywords(struct anonymous$14 *db, signed int id);
// est_mtdb_pseudo_doc_num
// file estmtdb.c line 733
signed int est_mtdb_pseudo_doc_num(struct anonymous$14 *db);
// est_mtdb_put_doc
// file estmtdb.h line 81
signed int est_mtdb_put_doc(struct anonymous$14 *db, struct anonymous$0 *doc, signed int options);
// est_mtdb_put_keywords
// file estmtdb.c line 492
signed int est_mtdb_put_keywords(struct anonymous$14 *db, signed int id, struct anonymous$9 *kwords, double weight);
// est_mtdb_refresh_rescc
// file estmtdb.c line 704
void est_mtdb_refresh_rescc(struct anonymous$14 *db);
// est_mtdb_scan_doc
// file estmtdb.c line 350
signed int est_mtdb_scan_doc(struct anonymous$14 *db, struct anonymous$0 *doc, struct anonymous$8 *cond);
// est_mtdb_search
// file estmtdb.h line 121
signed int * est_mtdb_search(struct anonymous$14 *db, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints);
// est_mtdb_search_meta
// file estmtdb.h line 125
signed int * est_mtdb_search_meta(struct anonymous$14 **dbs, signed int dbnum, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints);
// est_mtdb_set_cache_size
// file estmtdb.h line 133
void est_mtdb_set_cache_size(struct anonymous$14 *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum);
// est_mtdb_set_dfdb
// file estmtdb.c line 695
void est_mtdb_set_dfdb(struct anonymous$14 *db, struct anonymous$5 *dfdb);
// est_mtdb_set_doc_entity
// file estmtdb.h line 159
signed int est_mtdb_set_doc_entity(struct anonymous$14 *db, signed int id, const char *ptr, signed int size);
// est_mtdb_set_ecode
// file estmtdb.c line 387
void est_mtdb_set_ecode(struct anonymous$14 *db, signed int ecode);
// est_mtdb_set_informer
// file estmtdb.h line 255
void est_mtdb_set_informer(struct anonymous$14 *db, void (*func)(const char *, void *), void *opaque);
// est_mtdb_set_informer::func$object
//
void func$object(const char *, void *);
// est_mtdb_set_special_cache
// file estmtdb.h line 251
void est_mtdb_set_special_cache(struct anonymous$14 *db, const char *name, signed int num);
// est_mtdb_set_wildmax
// file estmtdb.c line 440
void est_mtdb_set_wildmax(struct anonymous$14 *db, signed int num);
// est_mtdb_size
// file estmtdb.c line 277
double est_mtdb_size(struct anonymous$14 *db);
// est_mtdb_sync
// file estmtdb.h line 69
signed int est_mtdb_sync(struct anonymous$14 *db);
// est_mtdb_unlock
// file estmtdb.c line 815
static void est_mtdb_unlock(struct anonymous$14 *db);
// est_mtdb_uri_to_id
// file estmtdb.c line 233
signed int est_mtdb_uri_to_id(struct anonymous$14 *db, const char *uri);
// est_mtdb_used_cache_size
// file estmtdb.c line 657
signed int est_mtdb_used_cache_size(struct anonymous$14 *db);
// est_mtdb_word_iter_init
// file estmtdb.c line 558
signed int est_mtdb_word_iter_init(struct anonymous$14 *db);
// est_mtdb_word_iter_next
// file estmtdb.c line 569
char * est_mtdb_word_iter_next(struct anonymous$14 *db);
// est_mtdb_word_num
// file estmtdb.c line 266
signed int est_mtdb_word_num(struct anonymous$14 *db);
// est_mtdb_word_rec_size
// file estmtdb.c line 580
signed int est_mtdb_word_rec_size(struct anonymous$14 *db, const char *word);
// est_narrow_scores
// file estraier.c line 9386
static signed int est_narrow_scores(struct anonymous *db, const struct anonymous$1 *attrs, signed int ign, const char *order, const char *distinct, struct anonymous$6 *scores, signed int snum, signed int limit, signed int *restp, struct anonymous$9 *ordattrs);
// est_node_add_header
// file estnode.c line 1638
void est_node_add_header(struct anonymous$24 *node, const char *name, const char *value);
// est_node_admins
// file estnode.c line 1046
const struct anonymous$1 * est_node_admins(struct anonymous$24 *node);
// est_node_cache_usage
// file estnode.c line 1009
double est_node_cache_usage(struct anonymous$24 *node);
// est_node_delete
// file estnode.c line 358
void est_node_delete(struct anonymous$24 *node);
// est_node_doc_num
// file estnode.c line 982
signed int est_node_doc_num(struct anonymous$24 *node);
// est_node_edit_doc
// file estnode.c line 591
signed int est_node_edit_doc(struct anonymous$24 *node, struct anonymous$0 *doc);
// est_node_etch_doc
// file estnode.c line 814
struct anonymous$9 * est_node_etch_doc(struct anonymous$24 *node, signed int id);
// est_node_etch_doc_by_uri
// file estnode.c line 868
struct anonymous$9 * est_node_etch_doc_by_uri(struct anonymous$24 *node, const char *uri);
// est_node_get_doc
// file estnode.c line 638
struct anonymous$0 * est_node_get_doc(struct anonymous$24 *node, signed int id);
// est_node_get_doc_attr
// file estnode.c line 722
char * est_node_get_doc_attr(struct anonymous$24 *node, signed int id, const char *name);
// est_node_get_doc_attr_by_uri
// file estnode.c line 768
char * est_node_get_doc_attr_by_uri(struct anonymous$24 *node, const char *uri, const char *name);
// est_node_get_doc_by_uri
// file estnode.c line 680
struct anonymous$0 * est_node_get_doc_by_uri(struct anonymous$24 *node, const char *uri);
// est_node_iter_delete
// file estnode.c line 2070
static void est_node_iter_delete(struct anonymous$24 *node);
// est_node_iter_init
// file estnode.c line 1614
signed int est_node_iter_init(struct anonymous$24 *node);
// est_node_iter_next
// file estnode.c line 1621
struct anonymous$0 * est_node_iter_next(struct anonymous$24 *node);
// est_node_label
// file estnode.c line 973
const char * est_node_label(struct anonymous$24 *node);
// est_node_links
// file estnode.c line 1064
const struct anonymous$1 * est_node_links(struct anonymous$24 *node);
// est_node_name
// file estnode.c line 964
const char * est_node_name(struct anonymous$24 *node);
// est_node_new
// file estnode.c line 330
struct anonymous$24 * est_node_new(const char *url);
// est_node_optimize
// file estnode.c line 443
signed int est_node_optimize(struct anonymous$24 *node);
// est_node_out_doc
// file estnode.c line 515
signed int est_node_out_doc(struct anonymous$24 *node, signed int id);
// est_node_out_doc_by_uri
// file estnode.c line 553
signed int est_node_out_doc_by_uri(struct anonymous$24 *node, const char *uri);
// est_node_put_doc
// file estnode.c line 480
signed int est_node_put_doc(struct anonymous$24 *node, struct anonymous$0 *doc);
// est_node_read_list
// file estnode.c line 2088
static signed int est_node_read_list(struct anonymous$24 *node);
// est_node_search
// file estnode.c line 1073
struct anonymous$17 * est_node_search(struct anonymous$24 *node, struct anonymous$8 *cond, signed int depth);
// est_node_set_auth
// file estnode.c line 391
void est_node_set_auth(struct anonymous$24 *node, const char *name, const char *passwd);
// est_node_set_info
// file estnode.c line 1951
static signed int est_node_set_info(struct anonymous$24 *node);
// est_node_set_link
// file estnode.c line 1248
signed int est_node_set_link(struct anonymous$24 *node, const char *url, const char *label, signed int credit);
// est_node_set_proxy
// file estnode.c line 375
void est_node_set_proxy(struct anonymous$24 *node, const char *host, signed int port);
// est_node_set_snippet_width
// file estnode.c line 1199
void est_node_set_snippet_width(struct anonymous$24 *node, signed int wwidth, signed int hwidth, signed int awidth);
// est_node_set_timeout
// file estnode.c line 384
void est_node_set_timeout(struct anonymous$24 *node, signed int sec);
// est_node_set_user
// file estnode.c line 1208
signed int est_node_set_user(struct anonymous$24 *node, const char *name, signed int mode);
// est_node_size
// file estnode.c line 1000
double est_node_size(struct anonymous$24 *node);
// est_node_status
// file estnode.c line 399
signed int est_node_status(struct anonymous$24 *node);
// est_node_sync
// file estnode.c line 406
signed int est_node_sync(struct anonymous$24 *node);
// est_node_uri_to_id
// file estnode.c line 923
signed int est_node_uri_to_id(struct anonymous$24 *node, const char *uri);
// est_node_users
// file estnode.c line 1055
const struct anonymous$1 * est_node_users(struct anonymous$24 *node);
// est_node_word_num
// file estnode.c line 991
signed int est_node_word_num(struct anonymous$24 *node);
// est_noderes_add_doc
// file estnode.c line 1673
void est_noderes_add_doc(struct anonymous$17 *nres, struct anonymous$9 *attrs, char *snippet);
// est_noderes_delete
// file estnode.c line 147
void est_noderes_delete(struct anonymous$17 *nres);
// est_noderes_doc_num
// file estnode.c line 240
signed int est_noderes_doc_num(struct anonymous$17 *nres);
// est_noderes_eclipse
// file estnode.c line 174
void est_noderes_eclipse(struct anonymous$17 *nres, signed int num, double limit);
// est_noderes_get_doc
// file estnode.c line 247
struct _ESTRESDOC * est_noderes_get_doc(struct anonymous$17 *nres, signed int index);
// est_noderes_hints
// file estnode.c line 167
struct anonymous$9 * est_noderes_hints(struct anonymous$17 *nres);
// est_noderes_mdate
// file estnode.c line 1713
signed long int est_noderes_mdate(struct anonymous$17 *nres);
// est_noderes_new
// file estnode.c line 1657
struct anonymous$17 * est_noderes_new(void);
// est_noderes_shift_doc
// file estnode.c line 1699
signed int est_noderes_shift_doc(struct anonymous$17 *nres, struct anonymous$9 **attrp, char **snippetp);
// est_normalize_text
// file estraier.c line 5950
static void est_normalize_text(unsigned char *utext, signed int size, signed int *sp);
// est_parse_search_body
// file estnode.c line 2186
static void est_parse_search_body(struct anonymous$17 *nres, char *str);
// est_parse_search_header
// file estnode.c line 2168
static void est_parse_search_header(struct anonymous$17 *nres, const char *str);
// est_phrase_from_isect
// file estraier.c line 6730
static char * est_phrase_from_isect(const char *iphrase);
// est_phrase_from_rough
// file estraier.c line 6632
static char * est_phrase_from_rough(const char *rphrase);
// est_phrase_from_simple
// file estraier.c line 6549
static char * est_phrase_from_simple(const char *sphrase);
// est_phrase_from_union
// file estraier.c line 6699
static char * est_phrase_from_union(const char *uphrase);
// est_phrase_terms
// file estraier.c line 8020
static struct anonymous$1 * est_phrase_terms(const char *phrase);
// est_phrase_vector
// file estraier.c line 10301
static struct anonymous$9 * est_phrase_vector(const char *phrase);
// est_pidx_uri_to_id
// file estraier.c line 7997
static signed int est_pidx_uri_to_id(struct anonymous *db, const char *uri);
// est_proc_env_reset
// file estraier.h line 1485
void est_proc_env_reset(void);
// est_random
// file estraier.h line 966
double est_random(void);
// est_random_fclose
// file estraier.c line 10424
static void est_random_fclose(void);
// est_random_nd
// file estraier.h line 971
double est_random_nd(void);
// est_random_str
// file estmttest.c line 555
static char * est_random_str(signed int cnum, signed int mode);
// est_realpath
// file estraier.c line 5565
char * est_realpath(const char *path);
// est_regex_delete
// file estraier.c line 4132
void est_regex_delete(void *regex);
// est_regex_match
// file estraier.c line 4140
signed int est_regex_match(const void *regex, const char *str);
// est_regex_match_str
// file estraier.c line 4147
signed int est_regex_match_str(const char *rstr, const char *tstr);
// est_regex_new
// file estraier.c line 4117
void * est_regex_new(const char *str);
// est_regex_replace
// file estraier.c line 4159
char * est_regex_replace(const char *str, const char *bef, const char *aft);
// est_rescc_get
// file estraier.c line 8759
static const struct anonymous$6 * est_rescc_get(struct anonymous *db, const char *word, signed int size, signed int *nump);
// est_rescc_put
// file estraier.c line 8777
static void est_rescc_put(struct anonymous *db, const char *word, signed int size, struct anonymous$6 *scores, signed int num);
// est_resdoc_attr
// file estnode.c line 282
const char * est_resdoc_attr(struct _ESTRESDOC *rdoc, const char *name);
// est_resdoc_attr_names
// file estnode.c line 266
struct anonymous$1 * est_resdoc_attr_names(struct _ESTRESDOC *rdoc);
// est_resdoc_keywords
// file estnode.c line 296
const char * est_resdoc_keywords(struct _ESTRESDOC *rdoc);
// est_resdoc_shadows
// file estnode.c line 305
struct _ESTRESDOC ** est_resdoc_shadows(struct _ESTRESDOC *rdoc, signed int *np);
// est_resdoc_similarity
// file estnode.c line 317
double est_resdoc_similarity(struct _ESTRESDOC *rdoc);
// est_resdoc_snippet
// file estnode.c line 289
const char * est_resdoc_snippet(struct _ESTRESDOC *rdoc);
// est_resdoc_uri
// file estnode.c line 259
const char * est_resdoc_uri(struct _ESTRESDOC *rdoc);
// est_resmap_add
// file estraier.c line 5442
void est_resmap_add(struct anonymous$9 *map, const char *key, signed int score, signed int method);
// est_resmap_dump
// file estraier.c line 5485
struct anonymous$10 * est_resmap_dump(struct anonymous$9 *map, signed int min, signed int *nump);
// est_resmapelem_compare
// file estraier.c line 5478
static signed int est_resmapelem_compare(const void *ap, const void *bp);
// est_rmdir_rec
// file estraier.c line 5545
signed int est_rmdir_rec(const char *path);
// est_score_compare_by_id_asc
// file estraier.c line 8088
static signed int est_score_compare_by_id_asc(const void *ap, const void *bp);
// est_score_compare_by_id_desc
// file estraier.c line 8098
static signed int est_score_compare_by_id_desc(const void *ap, const void *bp);
// est_score_compare_by_num_asc
// file estraier.c line 8148
static signed int est_score_compare_by_num_asc(const void *ap, const void *bp);
// est_score_compare_by_num_desc
// file estraier.c line 8158
static signed int est_score_compare_by_num_desc(const void *ap, const void *bp);
// est_score_compare_by_score_asc
// file estraier.c line 8108
static signed int est_score_compare_by_score_asc(const void *ap, const void *bp);
// est_score_compare_by_score_desc
// file estraier.c line 8118
static signed int est_score_compare_by_score_desc(const void *ap, const void *bp);
// est_score_compare_by_str_asc
// file estraier.c line 8128
static signed int est_score_compare_by_str_asc(const void *ap, const void *bp);
// est_score_compare_by_str_desc
// file estraier.c line 8138
static signed int est_score_compare_by_str_desc(const void *ap, const void *bp);
// est_search_aidx_attr
// file estraier.c line 8980
static struct anonymous$6 * est_search_aidx_attr(struct anonymous *db, const char *expr, signed int *nump);
// est_search_keywords
// file estraier.c line 8802
static struct anonymous$6 * est_search_keywords(struct anonymous *db, const char *word, signed int min, signed int *nump);
// est_search_pidxs
// file estraier.c line 9234
static struct anonymous$6 * est_search_pidxs(struct anonymous *db, struct anonymous$8 *cond, struct anonymous$6 *scores, signed int *nump, struct anonymous$9 *ordattrs);
// est_search_rank
// file estraier.c line 8916
static struct anonymous$6 * est_search_rank(struct anonymous *db, const char *name, signed int top, signed int *nump);
// est_search_similar
// file estraier.c line 10222
static struct anonymous$6 * est_search_similar(struct anonymous *db, struct anonymous$9 *svmap, signed int *nump, signed int knum, signed int unum, signed int mnum, signed int tfidf, double nmin, signed int auxmin, struct anonymous$9 *auxwords);
// est_search_union
// file estraier.c line 8420
static struct anonymous$6 * est_search_union(struct anonymous *db, const char *term, signed int gstep, void (*xpn)(const char *, struct anonymous$1 *), signed int *nump, struct anonymous$9 *hints, signed int add, signed int auxmin, struct anonymous$9 *auxwords);
// est_search_union::xpn$object
//
void xpn$object(const char *, struct anonymous$1 *);
// est_search_uvset
// file estraier.c line 8250
static struct anonymous$6 * est_search_uvset(struct anonymous *db, signed int *nump, struct anonymous$9 *hints, signed int add);
// est_set_ecode
// file estraier.c line 5862
static void est_set_ecode(signed int *ecp, signed int value, signed int line);
// est_short_compare
// file estraier.c line 7718
static signed int est_short_compare(const void *ap, const void *bp);
// est_signal
// file estraier.c line 5665
void est_signal(signed int signum, void (*sighandler)(signed int));
// est_signal::sighandler$object
//
void sighandler$object(signed int);
// est_signal_dispatch
// file estraier.c line 10431
static signed int est_signal_dispatch(signed int signum);
// est_snippet_add_text
// file estraier.c line 6765
static void est_snippet_add_text(const unsigned char *rtext, const unsigned char *ctext, signed int size, signed int awsiz, struct anonymous$2 *res, const struct anonymous$1 *rwords);
// est_sock_close
// file estnode.c line 1767
static signed int est_sock_close(signed int sock);
// est_sock_down
// file estnode.c line 1457
void est_sock_down(signed int sock);
// est_sock_recv_all
// file estnode.c line 1465
char * est_sock_recv_all(signed int sock, signed int len);
// est_sock_recv_line
// file estnode.c line 1482
signed int est_sock_recv_line(signed int sock, char *buf, signed int max);
// est_sock_recv_void
// file estnode.c line 1518
void est_sock_recv_void(signed int sock);
// est_sock_send_all
// file estnode.c line 1533
void est_sock_send_all(signed int sock, const char *buf, signed int len);
// est_sockpt_down
// file estnode.c line 1942
static void est_sockpt_down(void *sp);
// est_str_fwmatch_wide
// file estraier.c line 6812
static signed int est_str_fwmatch_wide(const unsigned char *str, signed int size, const unsigned char *key, signed int ksiz);
// est_str_make_snippet
// file estraier.c line 3498
char * est_str_make_snippet(const char *str, const struct anonymous$1 *words, signed int wwidth, signed int hwidth, signed int awidth);
// est_strstr_sparse
// file estraier.c line 6841
static char * est_strstr_sparse(const char *haystack, const char *needle);
// est_uconv_in
// file estraier.c line 3672
char * est_uconv_in(const char *ptr, signed int size, signed int *sp);
// est_uconv_out
// file estraier.c line 3720
char * est_uconv_out(const char *ptr, signed int size, signed int *sp);
// est_url_sameness
// file estraier.c line 10382
static signed int est_url_sameness(const char *aurl, const char *burl);
// est_url_shuttle
// file estnode.c line 1555
signed int est_url_shuttle(const char *url, const char *pxhost, signed int pxport, signed int outsec, signed int limsize, const char *auth, const struct anonymous$1 *reqheads, const char *reqbody, signed int rbsiz, signed int *rescodep, struct anonymous$9 *resheads, struct anonymous$2 *resbody);
// est_url_shuttle_impl
// file estnode.c line 1805
static void * est_url_shuttle_impl(void *targ);
// est_url_shuttle_impl::1::1::2::2::2::2::2::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// est_url_shuttle_impl::1::1::2::2::2::2::__cancel_routine$object
//
void __cancel_routine$object(void *);
// est_url_shuttle_impl::1::1::2::2::__cancel_routine$object
//
void __cancel_routine$object(void *);
// est_url_shuttle_impl::1::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// est_usleep
// file estraier.h line 1528
void est_usleep(unsigned long int usec);
// est_utime
// file estraier.c line 5620
signed int est_utime(const char *path, signed long int mtime);
// est_vector_cosine
// file estraier.c line 5829
double est_vector_cosine(const signed int *avec, const signed int *bvec, signed int vnum);
// est_vector_set_seed
// file estraier.c line 5794
void est_vector_set_seed(struct anonymous$9 *svmap, signed int *svec, signed int vnum);
// est_vector_set_target
// file estraier.c line 5812
void est_vector_set_target(struct anonymous$9 *svmap, struct anonymous$9 *tvmap, signed int *tvec, signed int vnum);
// est_weight_keywords
// file estraier.c line 8880
static void est_weight_keywords(struct anonymous *db, const char *word, struct anonymous$6 *scores, signed int snum);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname_r
// file /usr/include/netdb.h line 179
extern signed int gethostbyname_r(const char *, struct hostent *, char *, unsigned long int, struct hostent ** restrict , signed int *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// iconv
// file /usr/include/iconv.h line 42
extern unsigned long int iconv(void *, char ** restrict , unsigned long int *, char ** restrict , unsigned long int *);
// iconv_close
// file /usr/include/iconv.h line 51
extern signed int iconv_close(void *);
// iconv_open
// file /usr/include/iconv.h line 37
extern void * iconv_open(const char *, const char *);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes);
// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest);
// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms);
// md5_process
// file md5.c line 132
static void md5_process(struct md5_state_s *pms, const unsigned char *data);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mtwkfunc
// file estmttest.c line 396
static void * mtwkfunc(void *mission);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// printferror
// file estmttest.c line 88
static void printferror(const char *format, ...);
// printfinfo
// file estmttest.c line 100
static void printfinfo(const char *format, ...);
// procregression
// file estmttest.c line 276
static signed int procregression(const char *dbname);
// procwicked
// file estmttest.c line 204
static signed int procwicked(const char *dbname, signed int dnum, signed int tnum);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$20 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$20 *, const union anonymous$12 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$20 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$20 *, union anonymous$13 *, struct timespec *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$13 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$13 *, const union anonymous$12 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$13 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$13 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// putchar
// file /usr/include/stdio.h line 580
extern signed int putchar(signed int);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$44 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// runregression
// file estmttest.c line 184
static signed int runregression(signed int argc, char **argv);
// runwicked
// file estmttest.c line 156
static signed int runwicked(signed int argc, char **argv);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$18 *, struct anonymous$18 *, struct anonymous$18 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setsignals
// file estmttest.c line 121
static void setsignals(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$25 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigtermhandler
// file estmttest.c line 131
static void sigtermhandler(signed int num);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file estmttest.c line 144
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// utime
// file /usr/include/utime.h line 45
extern signed int utime(const char *, struct utimbuf *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vlclose
// file /usr/include/qdbm/villa.h line 189
signed int vlclose(struct anonymous$7 *);
// vlcrdnumptr
// file /usr/include/qdbm/villa.h line 570
signed int * vlcrdnumptr(void);
// vlcurfirst
// file /usr/include/qdbm/villa.h line 315
signed int vlcurfirst(struct anonymous$7 *);
// vlcurjump
// file /usr/include/qdbm/villa.h line 351
signed int vlcurjump(struct anonymous$7 *, const char *, signed int, signed int);
// vlcurkey
// file /usr/include/qdbm/villa.h line 364
char * vlcurkey(struct anonymous$7 *, signed int *);
// vlcurkeycache
// file /usr/include/qdbm/villa.h line 608
const char * vlcurkeycache(struct anonymous$7 *, signed int *);
// vlcurlast
// file /usr/include/qdbm/villa.h line 322
signed int vlcurlast(struct anonymous$7 *);
// vlcurnext
// file /usr/include/qdbm/villa.h line 336
signed int vlcurnext(struct anonymous$7 *);
// vlcurprev
// file /usr/include/qdbm/villa.h line 329
signed int vlcurprev(struct anonymous$7 *);
// vlcurval
// file /usr/include/qdbm/villa.h line 378
char * vlcurval(struct anonymous$7 *, signed int *);
// vlcurvalcache
// file /usr/include/qdbm/villa.h line 622
const char * vlcurvalcache(struct anonymous$7 *, signed int *);
// vlfsiz
// file /usr/include/qdbm/villa.h line 458
signed int vlfsiz(struct anonymous$7 *);
// vlget
// file /usr/include/qdbm/villa.h line 238
char * vlget(struct anonymous$7 *, const char *, signed int, signed int *);
// vlgetcache
// file /usr/include/qdbm/villa.h line 597
const char * vlgetcache(struct anonymous$7 *, const char *, signed int, signed int *);
// vlmemflush
// file /usr/include/qdbm/villa.h line 582
signed int vlmemflush(struct anonymous$7 *);
// vlopen
// file /usr/include/qdbm/villa.h line 179
struct anonymous$7 * vlopen(const char *, signed int, signed int (*)(const char *, signed int, const char *, signed int));
// vloptimize
// file /usr/include/qdbm/villa.h line 442
signed int vloptimize(struct anonymous$7 *);
// vlout
// file /usr/include/qdbm/villa.h line 220
signed int vlout(struct anonymous$7 *, const char *, signed int);
// vlput
// file /usr/include/qdbm/villa.h line 208
signed int vlput(struct anonymous$7 *, const char *, signed int, const char *, signed int, signed int);
// vlrepair
// file /usr/include/qdbm/villa.h line 540
signed int vlrepair(const char *, signed int (*)(const char *, signed int, const char *, signed int));
// vlrnum
// file /usr/include/qdbm/villa.h line 477
signed int vlrnum(struct anonymous$7 *);
// vlsetfbpsiz
// file /usr/include/qdbm/villa.h line 425
signed int vlsetfbpsiz(struct anonymous$7 *, signed int);
// vlsettuning
// file /usr/include/qdbm/villa.h line 416
void vlsettuning(struct anonymous$7 *, signed int, signed int, signed int, signed int);
// vlsync
// file /usr/include/qdbm/villa.h line 433
signed int vlsync(struct anonymous$7 *);
// vlvsiz
// file /usr/include/qdbm/villa.h line 248
signed int vlvsiz(struct anonymous$7 *, const char *, signed int);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$9
{
  // buckets
  struct _CBMAPDATUM **buckets;
  // first
  struct _CBMAPDATUM *first;
  // last
  struct _CBMAPDATUM *last;
  // cur
  struct _CBMAPDATUM *cur;
  // bnum
  signed int bnum;
  // rnum
  signed int rnum;
};

struct anonymous$2
{
  // dptr
  char *dptr;
  // dsize
  signed int dsize;
  // asize
  signed int asize;
};

struct anonymous$28
{
  // dptr
  char *dptr;
  // dsize
  signed int dsize;
};

struct anonymous
{
  // name
  char *name;
  // inode
  signed int inode;
  // metadb
  struct anonymous$5 *metadb;
  // idxdb
  struct anonymous$3 *idxdb;
  // fwmdb
  struct anonymous$7 *fwmdb;
  // auxdb
  struct anonymous$7 *auxdb;
  // xfmdb
  struct anonymous$7 *xfmdb;
  // attrdb
  struct anonymous$4 *attrdb;
  // textdb
  struct anonymous$4 *textdb;
  // kwddb
  struct anonymous$4 *kwddb;
  // listdb
  struct anonymous$7 *listdb;
  // aidxs
  struct anonymous$9 *aidxs;
  // pdocs
  struct anonymous$1 *pdocs;
  // puris
  struct anonymous$9 *puris;
  // ecode
  signed int ecode;
  // fatal
  signed int fatal;
  // dseq
  signed int dseq;
  // dnum
  signed int dnum;
  // amode
  signed int amode;
  // zmode
  signed int zmode;
  // smode
  signed int smode;
  // idxcc
  struct anonymous$9 *idxcc;
  // auxcc
  struct anonymous$9 *auxcc;
  // icsiz
  unsigned long int icsiz;
  // icmax
  unsigned long int icmax;
  // outcc
  struct anonymous$9 *outcc;
  // keycc
  struct anonymous$9 *keycc;
  // kcmnum
  signed int kcmnum;
  // attrcc
  struct anonymous$9 *attrcc;
  // acmnum
  signed int acmnum;
  // textcc
  struct anonymous$9 *textcc;
  // tcmnum
  signed int tcmnum;
  // veccc
  struct anonymous$9 *veccc;
  // vcmnum
  signed int vcmnum;
  // rescc
  struct anonymous$9 *rescc;
  // rcmnum
  signed int rcmnum;
  // spacc
  struct anonymous$9 *spacc;
  // scmnum
  signed int scmnum;
  // scname
  char *scname;
  // infocb
  void (*infocb)(const char *, void *);
  // infoop
  void *infoop;
  // dfdb
  struct anonymous$5 *dfdb;
  // wildmax
  signed int wildmax;
  // metacc
  struct anonymous$9 *metacc;
  // flsflag
  signed int flsflag;
  // intflag
  signed int intflag;
};

struct anonymous$11
{
  // name
  char *name;
  // nsiz
  signed int nsiz;
  // nlist
  struct anonymous$1 *nlist;
  // oper
  char *oper;
  // val
  char *val;
  // vsiz
  signed int vsiz;
  // cop
  const char *cop;
  // sign
  signed int sign;
  // sval
  char *sval;
  // ssiz
  signed int ssiz;
  // regex
  void *regex;
  // num
  signed long int num;
};

struct anonymous$7
{
  // depot
  struct anonymous$5 *depot;
  // cmp
  signed int (*cmp)(const char *, signed int, const char *, signed int);
  // wmode
  signed int wmode;
  // cmode
  signed int cmode;
  // root
  signed int root;
  // last
  signed int last;
  // lnum
  signed int lnum;
  // nnum
  signed int nnum;
  // rnum
  signed int rnum;
  // leafc
  struct anonymous$9 *leafc;
  // nodec
  struct anonymous$9 *nodec;
  // hist
  signed int hist[64l];
  // hnum
  signed int hnum;
  // hleaf
  signed int hleaf;
  // lleaf
  signed int lleaf;
  // curleaf
  signed int curleaf;
  // curknum
  signed int curknum;
  // curvnum
  signed int curvnum;
  // leafrecmax
  signed int leafrecmax;
  // nodeidxmax
  signed int nodeidxmax;
  // leafcnum
  signed int leafcnum;
  // nodecnum
  signed int nodecnum;
  // avglsiz
  signed int avglsiz;
  // avgnsiz
  signed int avgnsiz;
  // tran
  signed int tran;
  // rbroot
  signed int rbroot;
  // rblast
  signed int rblast;
  // rblnum
  signed int rblnum;
  // rbnnum
  signed int rbnnum;
  // rbrnum
  signed int rbrnum;
};

struct anonymous$3
{
  // name
  char *name;
  // omode
  signed int omode;
  // dbs
  struct anonymous$7 *dbs[256l];
  // dnum
  signed int dnum;
  // cdb
  struct anonymous$7 *cdb;
};

struct anonymous$4
{
  // name
  char *name;
  // wmode
  signed int wmode;
  // inode
  signed int inode;
  // attr
  struct anonymous$5 *attr;
  // depots
  struct anonymous$5 **depots;
  // dnum
  signed int dnum;
  // inum
  signed int inum;
  // lrnum
  signed int lrnum;
};

struct anonymous$5
{
  // name
  char *name;
  // wmode
  signed int wmode;
  // inode
  signed int inode;
  // mtime
  signed long int mtime;
  // fd
  signed int fd;
  // fsiz
  signed int fsiz;
  // map
  char *map;
  // msiz
  signed int msiz;
  // buckets
  signed int *buckets;
  // bnum
  signed int bnum;
  // rnum
  signed int rnum;
  // fatal
  signed int fatal;
  // ioff
  signed int ioff;
  // fbpool
  signed int *fbpool;
  // fbpsiz
  signed int fbpsiz;
  // fbpinc
  signed int fbpinc;
  // align
  signed int align;
};

struct anonymous$8
{
  // phrase
  char *phrase;
  // gstep
  signed int gstep;
  // tfidf
  signed int tfidf;
  // pmode
  signed int pmode;
  // cbxpn
  void (*cbxpn)(const char *, struct anonymous$1 *);
  // attrs
  struct anonymous$1 *attrs;
  // order
  char *order;
  // max
  signed int max;
  // skip
  signed int skip;
  // auxmin
  signed int auxmin;
  // auxwords
  struct anonymous$9 *auxwords;
  // scfb
  signed int scfb;
  // scores
  signed int *scores;
  // snum
  signed int snum;
  // nscores
  const signed int *nscores;
  // nsnum
  signed int nsnum;
  // opts
  signed int opts;
  // ecllim
  double ecllim;
  // shadows
  struct anonymous$9 *shadows;
  // distinct
  char *distinct;
  // mask
  signed int mask;
};

struct anonymous$24
{
  // url
  char *url;
  // pxhost
  char *pxhost;
  // pxport
  signed int pxport;
  // timeout
  signed int timeout;
  // auth
  char *auth;
  // name
  char *name;
  // label
  char *label;
  // dnum
  signed int dnum;
  // wnum
  signed int wnum;
  // size
  double size;
  // admins
  struct anonymous$1 *admins;
  // users
  struct anonymous$1 *users;
  // links
  struct anonymous$1 *links;
  // wwidth
  signed int wwidth;
  // hwidth
  signed int hwidth;
  // awidth
  signed int awidth;
  // ilist
  struct anonymous$1 *ilist;
  // iprev
  char *iprev;
  // status
  signed int status;
  // heads
  struct anonymous$9 *heads;
};

struct anonymous$1
{
  // array
  struct anonymous$28 *array;
  // anum
  signed int anum;
  // start
  signed int start;
  // num
  signed int num;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$13
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$14
{
  // db
  struct anonymous *db;
  // path
  char *path;
  // mutex
  union anonymous$13 mutex;
};

struct anonymous$17
{
  // docs
  struct _ESTRESDOC *docs;
  // top
  signed int top;
  // max
  signed int max;
  // dnum
  signed int dnum;
  // survivors
  struct _ESTRESDOC **survivors;
  // snum
  signed int snum;
  // hints
  struct anonymous$9 *hints;
  // mdate
  signed long int mdate;
};

struct anonymous$40
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$16
{
  // db
  void *db;
  // type
  signed int type;
};

struct anonymous$38
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$10
{
  // key
  const char *key;
  // score
  signed int score;
};

struct anonymous$31
{
  // word
  const char *word;
  // wsiz
  signed int wsiz;
  // pt
  signed int pt;
};

struct anonymous$18
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$25
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$21
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$22
{
  // __cancel_jmp_buf
  struct anonymous$21 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$19
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$27
{
  // alive
  signed int alive;
  // cond
  union anonymous$20 *cond;
  // url
  const char *url;
  // pxhost
  const char *pxhost;
  // pxport
  signed int pxport;
  // limsize
  signed int limsize;
  // auth
  const char *auth;
  // reqheads
  const struct anonymous$1 *reqheads;
  // reqbody
  const char *reqbody;
  // rbsiz
  signed int rbsiz;
  // rescodep
  signed int *rescodep;
  // resheads
  struct anonymous$9 *resheads;
  // resbody
  struct anonymous$2 *resbody;
};

struct anonymous$32
{
  // db
  signed int db;
  // id
  signed int id;
  // score
  signed int score;
  // value
  char *value;
};

struct anonymous$6
{
  // id
  signed int id;
  // score
  signed int score;
  // value
  char *value;
};

struct anonymous$0
{
  // id
  signed int id;
  // attrs
  struct anonymous$9 *attrs;
  // dtexts
  struct anonymous$1 *dtexts;
  // kwords
  struct anonymous$9 *kwords;
};

struct anonymous$29
{
  // id
  signed int id;
  // db
  struct anonymous$14 *db;
  // others
  struct anonymous$14 **others;
  // dnum
  signed int dnum;
};

struct anonymous$15
{
  // quot
  signed int quot;
  // rem
  signed int rem;
};

struct anonymous$44
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$34
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$37
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$36
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$35
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$39
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$41
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$34 _kill;
  // _timer
  struct anonymous$35 _timer;
  // _rt
  struct anonymous$36 _rt;
  // _sigchld
  struct anonymous$37 _sigchld;
  // _sigfault
  struct anonymous$38 _sigfault;
  // _sigpoll
  struct anonymous$39 _sigpoll;
  // _sigsys
  struct anonymous$40 _sigsys;
};

struct anonymous$42
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$41 _sifields;
};

union anonymous$43
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$42 *, void *);
};

union anonymous$23
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$12
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$20
{
  // __data
  struct anonymous$19 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$26
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$30
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _CBMAPDATUM
{
  // ksiz
  signed int ksiz;
  // vsiz
  signed int vsiz;
  // hash
  signed int hash;
  // left
  struct _CBMAPDATUM *left;
  // right
  struct _CBMAPDATUM *right;
  // prev
  struct _CBMAPDATUM *prev;
  // next
  struct _CBMAPDATUM *next;
};

struct _ESTRESDOC
{
  // uri
  const char *uri;
  // attrs
  struct anonymous$9 *attrs;
  // snippet
  char *snippet;
  // kwords
  struct anonymous$9 *kwords;
  // similarity
  double similarity;
  // children
  struct _ESTRESDOC **children;
  // cnum
  signed int cnum;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$25 __saved_mask;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous$23 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct md5_state_s
{
  // count
  unsigned int count[2l];
  // abcd
  unsigned int abcd[4l];
  // buf
  unsigned char buf[64l];
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$43 __sigaction_handler;
  // sa_mask
  struct anonymous$25 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// VL_CMPLEX
// file /usr/include/qdbm/villa.h line 80
extern signed int (*VL_CMPLEX)(const char *, signed int, const char *, signed int);
// dpdbgfd
// file /usr/include/qdbm/depot.h line 439
extern signed int dpdbgfd;
// dpisreentrant
// file /usr/include/qdbm/depot.h line 443
extern const signed int dpisreentrant;
// est_global_db_names
// file estmtdb.c line 39
struct anonymous$9 *est_global_db_names = (struct anonymous$9 *)(void *)0;
// est_global_mutex
// file estmtdb.c line 38
union anonymous$13 est_global_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// est_host_addrs
// file estnode.c line 81
struct anonymous$9 *est_host_addrs = (struct anonymous$9 *)(void *)0;
// est_host_addrs_mutex
// file estnode.c line 83
union anonymous$13 est_host_addrs_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// est_host_attrs_cnt
// file estnode.c line 82
signed int est_host_attrs_cnt = 0;
// est_inodes
// file estraier.c line 894
struct anonymous$9 *est_inodes = (struct anonymous$9 *)(void *)0;
// est_random_ifp
// file estraier.c line 3368
struct _IO_FILE *est_random_ifp = (struct _IO_FILE *)(void *)0;
// est_signal_handlers
// file estraier.c line 3372
void (*est_signal_handlers[64l])(signed int);
// est_version
// file estraier.c line 407
const char *est_version = "1.4.13";
// g_progname
// file estmttest.c line 43
const char *g_progname;
// g_sigterm
// file estmttest.c line 44
signed int g_sigterm = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// dbinform
// file estmttest.c line 115
static void dbinform(const char *message, void *opaque)
{
  printfinfo("%s", message);
}

// est_accept_conn
// file estnode.c line 1406
signed int est_accept_conn(signed int sock, char *abuf, signed int *pp)
{
  struct sockaddr_in address;
  unsigned int socklen;
  signed int clsock;
  socklen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  clsock=accept(sock, (struct sockaddr *)&address, &socklen);
  char *return_value_inet_ntoa$1;
  unsigned short int return_value_ntohs$2;
  if(clsock >= 0)
  {
    if(!(abuf == ((char *)NULL)))
    {
      return_value_inet_ntoa$1=inet_ntoa(address.sin_addr);
      sprintf(abuf, "%s", return_value_inet_ntoa$1);
    }

    if(!(pp == ((signed int *)NULL)))
    {
      return_value_ntohs$2=ntohs(address.sin_port);
      *pp = (signed int)return_value_ntohs$2;
    }

    return clsock;
  }

  signed int *return_value___errno_location$3;
  return_value___errno_location$3=__errno_location();
  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  if(*return_value___errno_location$3 == 4)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value___errno_location$4=__errno_location();
    tmp_if_expr$5 = *return_value___errno_location$4 == 11 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr$5 ? 0 : -1;
}

// est_aidx_attr_narrow
// file estraier.c line 7563
static signed int est_aidx_attr_narrow(struct anonymous$7 *db, const struct anonymous$1 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous$6 *scores, signed int snum)
{
  struct anonymous$2 *abuf;
  struct anonymous$1 *tokens;
  const char *kbuf;
  char numbuf[32l];
  char *tmp;
  char *wp;
  signed int i;
  signed int j;
  signed int ksiz;
  signed int len;
  signed int esc;
  signed int jmp;
  signed int id;
  signed int nnum;
  signed int *ary;
  signed int anum;
  signed long int lower;
  signed long int upper;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    abuf = (struct anonymous$2 *)return_value_malloc$1;
    if(!(abuf == ((struct anonymous$2 *)NULL)))
      abuf;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    abuf->dptr = (char *)return_value_malloc$2;
    if(!(abuf->dptr == ((char *)NULL)))
      abuf->dptr;

    else
      cbmyfatal("out of memory");
    abuf->dptr[(signed long int)0] = (char)0;
    abuf->dsize = 0;
    abuf->asize = 12;
  }
  while((_Bool)0);
  signed int return_value_strcmp$3;
  _Bool tmp_if_expr$7;
  char *tmp_post$6;
  signed long int return_value_cbstrmktime$8;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$13;
  signed long int return_value_cbstrmktime$14;
  signed long int return_value_cbstrmktime$16;
  if(cop == "STROREQ" && sval == ((const char *)NULL) && !(sign == 0))
  {
    tokens=cbsplit(oval, osiz, " ,");
    cblistsort(tokens);
    i = 0;
    for( ; !(i >= tokens->num); i = i + 1)
    {
      osiz = (tokens->array + (signed long int)(tokens->start + i))->dsize;
      oval = (const char *)(tokens->array + (signed long int)(tokens->start + i))->dptr;
      if(osiz >= 1)
      {
        vlcurjump(db, oval, osiz, 0);
        do
        {
          kbuf=vlcurkeycache(db, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          return_value_strcmp$3=strcmp(kbuf, oval);
          if(!(return_value_strcmp$3 == 0))
            break;

          do
          {
            if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
            {
              abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
              void *return_value_realloc$4;
              return_value_realloc$4=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
              abuf->dptr = (char *)return_value_realloc$4;
              if(!(abuf->dptr == ((char *)NULL)))
                abuf->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
            abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
            abuf->dptr[(signed long int)abuf->dsize] = (char)0;
          }
          while((_Bool)0);
          vlcurnext(db);
        }
        while((_Bool)1);
      }

    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = tokens->start + tokens->num;
      _CB_i = tokens->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(tokens->array + (signed long int)_CB_i)->dptr);
      free((void *)tokens->array);
      free((void *)tokens);
    }
    while((_Bool)0);
  }

  else
    if(cop == "NUMBT" && sval == ((const char *)NULL) && !(sign == 0))
    {
      do
      {
        void *return_value_malloc$5;
        return_value_malloc$5=malloc((unsigned long int)(osiz + 1));
        tmp = (char *)return_value_malloc$5;
        if(!(tmp == ((char *)NULL)))
          tmp;

        else
          cbmyfatal("out of memory");
        memcpy((void *)tmp, (const void *)oval, (unsigned long int)osiz);
        tmp[(signed long int)osiz] = (char)0;
      }
      while((_Bool)0);
      wp=strchr(tmp, 32);
      if(!(wp == ((char *)NULL)))
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        wp=strchr(tmp, 9);
        tmp_if_expr$7 = wp != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
      {
        tmp_post$6 = wp;
        wp = wp + 1l;
        *tmp_post$6 = (char)0;
        for( ; (_Bool)1; wp = wp + 1l)
          if(!((signed int)*wp == 32))
          {
            if(!((signed int)*wp == 9))
              goto __CPROVER_DUMP_L25;

          }


      __CPROVER_DUMP_L25:
        ;
        lower=cbstrmktime(tmp);
        upper=cbstrmktime(wp);
      }

      else
      {
        lower=cbstrmktime(tmp);
        upper = (signed long int)0x7fffffff;
      }
      len=sprintf(numbuf, "%.0f", (double)lower);
      vlcurjump(db, numbuf, len, 0);
      do
      {
        kbuf=vlcurkeycache(db, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        return_value_cbstrmktime$8=cbstrmktime(kbuf);
        if(!(upper >= return_value_cbstrmktime$8))
          break;

        do
        {
          if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
          {
            abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
            void *return_value_realloc$9;
            return_value_realloc$9=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
            abuf->dptr = (char *)return_value_realloc$9;
            if(!(abuf->dptr == ((char *)NULL)))
              abuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
          abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
          abuf->dptr[(signed long int)abuf->dsize] = (char)0;
        }
        while((_Bool)0);
        vlcurnext(db);
      }
      while((_Bool)1);
      free((void *)tmp);
    }

    else
      if(sign == 0 || !(sval == ((const char *)NULL)))
      {
        esc = 0x7fffffff;
        jmp = 0x7fffffff;
        if(osiz >= 1 && !(sign == 0) && (cop == "STRBW" || cop == "STREQ"))
        {
          if((signed int)*sval >= 1)
            tmp_if_expr$10 = (signed int)*sval < 0x7f ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
          {
            numbuf[(signed long int)0] = *sval;
            numbuf[(signed long int)1] = (char)0;
            esc = (signed int)*((unsigned char *)sval);
            if((signed int)*sval >= 97)
            {
              if(!((signed int)*sval >= 123))
              {
                numbuf[(signed long int)0] = numbuf[(signed long int)0] - (char)(97 - 65);
                jmp = ((signed int)*sval - 97) + 65;
              }

            }

            vlcurjump(db, numbuf, 1, 0);
          }

          else
            if((signed int)*((unsigned char *)sval) >= 0xc0)
            {
              numbuf[(signed long int)0] = *sval;
              numbuf[(signed long int)1] = (char)0;
              esc = (signed int)*((unsigned char *)sval);
              vlcurjump(db, numbuf, 1, 0);
            }

            else
              vlcurfirst(db);
        }

        else
          vlcurfirst(db);
        do
        {
          kbuf=vlcurkeycache(db, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          signed int return_value_est_match_attr$12;
          return_value_est_match_attr$12=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, sign, oval, osiz, sval, ssiz, regex, onum);
          if(!(return_value_est_match_attr$12 == 0))
            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc$11;
                return_value_realloc$11=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc$11;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);

          if(!(jmp >= (signed int)*((unsigned char *)kbuf)))
            tmp_if_expr$13 = (signed int)*((unsigned char *)kbuf) < (signed int)*((unsigned char *)sval) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
          {
            numbuf[(signed long int)0] = *sval;
            numbuf[(signed long int)1] = (char)0;
            vlcurjump(db, numbuf, 1, 0);
            jmp = 0x7fffffff;
          }

          else
            if(!(esc >= (signed int)*((unsigned char *)kbuf)))
              break;

            else
              vlcurnext(db);
        }
        while((_Bool)1);
      }

      else
      {
        if(cop == "NUMEQ" || cop == "NUMGE" || cop == "NUMGT" || cop == "STRBW" || cop == "STREQ")
        {
          vlcurjump(db, oval, osiz, 0);
          if(cop == "NUMGT")
            do
            {
              kbuf=vlcurkeycache(db, (signed int *)(void *)0);
              if(kbuf == ((const char *)NULL))
                break;

              return_value_cbstrmktime$14=cbstrmktime(kbuf);
              if(!((signed long int)onum >= return_value_cbstrmktime$14))
                break;

              vlcurnext(db);
            }
            while((_Bool)1);

        }

        else
          if(cop == "NUMLE" || cop == "NUMLT")
          {
            signed long int return_value_cbstrmktime$15;
            return_value_cbstrmktime$15=cbstrmktime(oval);
            len=sprintf(numbuf, "%.0f", (double)return_value_cbstrmktime$15 + (double)1);
            vlcurjump(db, numbuf, len, 1);
            if(cop == "NUMLT")
              do
              {
                kbuf=vlcurkeycache(db, (signed int *)(void *)0);
                if(kbuf == ((const char *)NULL))
                  break;

                return_value_cbstrmktime$16=cbstrmktime(kbuf);
                if(!(return_value_cbstrmktime$16 >= (signed long int)onum))
                  break;

                vlcurprev(db);
              }
              while((_Bool)1);

          }

          else
            vlcurfirst(db);
        do
        {
          kbuf=vlcurkeycache(db, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          signed int return_value_est_match_attr$18;
          return_value_est_match_attr$18=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, 1, oval, osiz, sval, ssiz, regex, onum);
          if(!(return_value_est_match_attr$18 == 0))
            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc$17;
                return_value_realloc$17=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc$17;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);

          else
            if(cop == "NUMEQ" || cop == "STRBW" || cop == "STREQ")
              break;

          if(cop == "NUMLE" || cop == "NUMLT")
            vlcurprev(db);

          else
            vlcurnext(db);
        }
        while((_Bool)1);
      }
  i = 0;
  for( ; !(i >= pdocs->num); i = i + 1)
  {
    id = 2000000001 + i;
    do
    {
      if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
      {
        abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
        void *return_value_realloc$19;
        return_value_realloc$19=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
        abuf->dptr = (char *)return_value_realloc$19;
        if(!(abuf->dptr == ((char *)NULL)))
          abuf->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)&id, sizeof(signed int) /*4ul*/ );
      abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
      abuf->dptr[(signed long int)abuf->dsize] = (char)0;
    }
    while((_Bool)0);
  }
  nnum = 0;
  ary = (signed int *)(const char *)abuf->dptr;
  anum = (signed int)((unsigned long int)(signed int)abuf->dsize / sizeof(signed int) /*4ul*/ );
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
  qsort((void *)ary, (unsigned long int)anum, sizeof(signed int) /*4ul*/ , est_int_compare);
  i = 0;
  j = 0;
  for( ; !(i >= snum); i = i + 1)
  {
    for( ; !(j >= anum); j = j + 1)
      if(ary[(signed long int)j] >= (scores + (signed long int)i)->id)
        break;

    if(!(j >= anum))
    {
      if((scores + (signed long int)i)->id == ary[(signed long int)j])
      {
        (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
        (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
        nnum = nnum + 1;
      }

    }

  }
  do
  {
    free((void *)abuf->dptr);
    free((void *)abuf);
  }
  while((_Bool)0);
  return nnum;
}

// est_aidx_attr_out
// file estraier.c line 7534
static signed int est_aidx_attr_out(struct anonymous$7 *db, signed int id, const char *vbuf, signed int vsiz)
{
  char *tbuf;
  signed int err;
  signed int tsiz;
  err = 0;
  tsiz = (signed int)((unsigned long int)vsiz + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)tsiz);
  tbuf = (char *)return_value_malloc$1;
  if(!(tbuf == ((char *)NULL)))
    tbuf;

  else
    cbmyfatal("out of memory");
  memcpy((void *)tbuf, (const void *)vbuf, (unsigned long int)(vsiz + 1));
  memcpy((void *)(tbuf + (signed long int)vsiz + (signed long int)1), (const void *)&id, sizeof(signed int) /*4ul*/ );
  signed int return_value_vlout$2;
  return_value_vlout$2=vlout(db, tbuf, tsiz);
  if(return_value_vlout$2 == 0)
    err = 1;

  free((void *)tbuf);
  return err != 0 ? 0 : 1;
}

// est_aidx_attr_put
// file estraier.c line 7513
static signed int est_aidx_attr_put(struct anonymous$7 *db, signed int id, const char *vbuf, signed int vsiz)
{
  char *tbuf;
  signed int err;
  signed int tsiz;
  err = 0;
  tsiz = (signed int)((unsigned long int)vsiz + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)tsiz);
  tbuf = (char *)return_value_malloc$1;
  if(!(tbuf == ((char *)NULL)))
    tbuf;

  else
    cbmyfatal("out of memory");
  memcpy((void *)tbuf, (const void *)vbuf, (unsigned long int)(vsiz + 1));
  memcpy((void *)(tbuf + (signed long int)vsiz + (signed long int)1), (const void *)&id, sizeof(signed int) /*4ul*/ );
  signed int return_value_vlput$2;
  return_value_vlput$2=vlput(db, tbuf, tsiz, "", 0, 1);
  if(return_value_vlput$2 == 0)
    err = 1;

  free((void *)tbuf);
  return err != 0 ? 0 : 1;
}

// est_aidx_numcmp
// file estraier.c line 7500
static signed int est_aidx_numcmp(const char *aptr, signed int asiz, const char *bptr, signed int bsiz)
{
  signed int rv;
  signed long int return_value_cbstrmktime$1;
  return_value_cbstrmktime$1=cbstrmktime(aptr);
  signed long int return_value_cbstrmktime$2;
  return_value_cbstrmktime$2=cbstrmktime(bptr);
  rv = (signed int)(return_value_cbstrmktime$1 - return_value_cbstrmktime$2);
  if(!(rv == 0))
    return rv;

  else
  {
    signed int return_value;
    return_value=VL_CMPLEX(aptr, asiz, bptr, bsiz);
    return return_value;
  }
}

// est_aidx_seq_get
// file estraier.c line 7439
static char * est_aidx_seq_get(struct anonymous$5 *db, signed int id, signed int *sp)
{
  char *return_value_dpget$1;
  return_value_dpget$1=dpget(db, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, sp);
  return return_value_dpget$1;
}

// est_aidx_seq_narrow
// file estraier.c line 7461
static signed int est_aidx_seq_narrow(struct anonymous$5 *db, const struct anonymous$1 *pdocs, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum, struct anonymous$6 *scores, signed int snum, signed int limit, signed int *restp)
{
  char vbuf[8192l];
  signed int i;
  signed int nnum;
  signed int vsiz;
  nnum = 0;
  i = 0;
  for( ; !(i >= snum); i = i + 1)
  {
    if(nnum >= limit)
    {
      *restp = snum - i;
      break;
    }

    if((scores + (signed long int)i)->id >= 2000000001)
    {
      (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
      (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
      nnum = nnum + 1;
    }

    else
    {
      vsiz=dpgetwb(db, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , 0, 8192 - 1, vbuf);
      if(vsiz >= 0)
      {
        vbuf[(signed long int)vsiz] = (char)0;
        signed int return_value_est_match_attr$1;
        return_value_est_match_attr$1=est_match_attr(vbuf, vsiz, cop, sign, oval, osiz, sval, ssiz, regex, onum);
        if(!(return_value_est_match_attr$1 == 0))
        {
          (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
          (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
          nnum = nnum + 1;
        }

      }

    }
  }
  return nnum;
}

// est_aidx_seq_out
// file estraier.c line 7426
static signed int est_aidx_seq_out(struct anonymous$5 *db, signed int id)
{
  signed int err = 0;
  signed int return_value_dpout$1;
  return_value_dpout$1=dpout(db, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
  if(return_value_dpout$1 == 0)
    err = 1;

  return err != 0 ? 0 : 1;
}

// est_aidx_seq_put
// file estraier.c line 7413
static signed int est_aidx_seq_put(struct anonymous$5 *db, signed int id, const char *vbuf, signed int vsiz)
{
  signed int err = 0;
  signed int return_value_dpput$1;
  return_value_dpput$1=dpput(db, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 1);
  if(return_value_dpput$1 == 0)
    err = 1;

  return err != 0 ? 0 : 1;
}

// est_border_str
// file estraier.c line 4042
const char * est_border_str(void)
{
  signed int t;
  signed int p;
  static char border[4096l];
  static signed int first = 1;
  if(!(first == 0))
  {
    signed long int return_value_time$1;
    return_value_time$1=time((signed long int *)(void *)0);
    double return_value_est_random$2;
    return_value_est_random$2=est_random();
    t = (signed int)((double)return_value_time$1 + return_value_est_random$2 * (double)0x7fffffff);
    signed int return_value_getpid$3;
    return_value_getpid$3=getpid();
    double return_value_est_random$4;
    return_value_est_random$4=est_random();
    p = (signed int)((double)return_value_getpid$3 + return_value_est_random$4 * (double)0x7fffffff);
    signed int return_value_dpouterhash$5;
    return_value_dpouterhash$5=dpouterhash((char *)&t, (signed int)sizeof(signed int) /*4ul*/ );
    signed int return_value_dpouterhash$6;
    return_value_dpouterhash$6=dpouterhash((char *)&p, (signed int)sizeof(signed int) /*4ul*/ );
    sprintf(border, "--------[%08X%08X]--------", return_value_dpouterhash$5, return_value_dpouterhash$6);
    first = 0;
  }

  return border;
}

// est_break_text
// file estraier.c line 3376
void est_break_text(const char *text, struct anonymous$1 *list, signed int norm, signed int tail)
{
  struct anonymous$1 *words;
  const unsigned char *word;
  const unsigned char *next;
  unsigned char *utext;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int size;
  signed int cc;
  signed int wsiz;
  signed int nsiz;
  signed int tsiz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(text);
  char *return_value_est_uconv_in$2;
  return_value_est_uconv_in$2=est_uconv_in(text, (signed int)return_value_strlen$1, &size);
  utext = (unsigned char *)return_value_est_uconv_in$2;
  if(!(norm == 0))
    est_normalize_text(utext, size, &size);

  est_canonicalize_text(utext, size, 0);
  do
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    words = (struct anonymous$1 *)return_value_malloc$3;
    if(!(words == ((struct anonymous$1 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous$28 *)return_value_malloc$4;
    if(!(words->array == ((struct anonymous$28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  i = 0;
  while(!(i >= size))
  {
    cc=est_char_category((signed int)utext[(signed long int)i] * 0x100 + (signed int)utext[(signed long int)(i + 1)]);
    j = i + 2;
    for( ; !(j >= size); j = j + 2)
    {
      signed int return_value_est_char_category$5;
      return_value_est_char_category$5=est_char_category((signed int)utext[(signed long int)j] * 0x100 + (signed int)utext[(signed long int)(j + 1)]);
      if(!(return_value_est_char_category$5 == cc))
        break;

    }
    switch(cc)
    {
      case 1:

      case 2:
      {
        do
        {
          signed int _CB_index = words->start + words->num;
          if(_CB_index >= words->anum)
          {
            words->anum = words->anum * 2;
            void *return_value_realloc$6;
            return_value_realloc$6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
            words->array = (struct anonymous$28 *)return_value_realloc$6;
            if(!(words->array == ((struct anonymous$28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$7;
          return_value_malloc$7=malloc((unsigned long int)((j - i < 12 ? 12 : j - i) + 1));
          (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$7;
          if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (words->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)(char *)(utext + (signed long int)i), (unsigned long int)(j - i));
          (words->array + (signed long int)_CB_index)->dptr[(signed long int)(j - i)] = (char)0;
          (words->array + (signed long int)_CB_index)->dsize = j - i;
          words->num = words->num + 1;
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L31;
      }
      case 3:
      {
        k = i;
        for( ; !(k >= j); k = k + 2)
          if(j + -k >= 4)
            do
            {
              signed int est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index = words->start + words->num;
              if(est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc$8;
                return_value_realloc$8=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
                words->array = (struct anonymous$28 *)return_value_realloc$8;
                if(!(words->array == ((struct anonymous$28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc$9;
              return_value_malloc$9=malloc((unsigned long int)((4 < 12 ? 12 : 4) + 1));
              (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index)->dptr = (char *)return_value_malloc$9;
              if(!((words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)4);
              (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index)->dptr[(signed long int)4] = (char)0;
              (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$1$$1$$_CB_index)->dsize = 4;
              words->num = words->num + 1;
            }
            while((_Bool)0);

          else
            do
            {
              signed int est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index = words->start + words->num;
              if(est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc$10;
                return_value_realloc$10=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
                words->array = (struct anonymous$28 *)return_value_realloc$10;
                if(!(words->array == ((struct anonymous$28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc$11;
              return_value_malloc$11=malloc((unsigned long int)((2 < 12 ? 12 : 2) + 1));
              (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index)->dptr = (char *)return_value_malloc$11;
              if(!((words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)2);
              (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index)->dptr[(signed long int)2] = (char)0;
              (words->array + (signed long int)est_break_text$$1$$2$$1$$2$$2$$1$$2$$1$$_CB_index)->dsize = 2;
              words->num = words->num + 1;
            }
            while((_Bool)0);
      }
      default:
      {

      __CPROVER_DUMP_L31:
        ;
        i = j - 2;
        i = i + 2;
      }
    }
  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    signed int return_value_est_char_category$15;
    return_value_est_char_category$15=est_char_category((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
    if(return_value_est_char_category$15 == 3)
    {
      if(wsiz == 2)
      {
        if(!(i >= words->num + -1))
        {
          const char *return_value_cblistval$12;
          return_value_cblistval$12=cblistval(words, i + 1, &nsiz);
          next = (unsigned char *)return_value_cblistval$12;
          if(nsiz >= 5)
            nsiz = 4;

          signed int return_value_est_char_category$13;
          return_value_est_char_category$13=est_char_category((signed int)next[(signed long int)0] * 0x100 + (signed int)next[(signed long int)1]);
          if(return_value_est_char_category$13 == 3)
          {
            if(nsiz >= 3)
              nsiz = 2;

          }

          void *return_value_malloc$14;
          return_value_malloc$14=malloc((unsigned long int)(wsiz + nsiz + 1));
          tmp = (char *)return_value_malloc$14;
          if(!(tmp == ((char *)NULL)))
            tmp;

          else
            cbmyfatal("out of memory");
          memcpy((void *)tmp, (const void *)word, (unsigned long int)wsiz);
          memcpy((void *)(tmp + (signed long int)wsiz), (const void *)next, (unsigned long int)nsiz);
          cblistover(words, i, tmp, wsiz + nsiz);
          free((void *)tmp);
        }

      }

    }

  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(wsiz == 2 && tail == 0)
    {
      if(i == words->num + -1)
      {
        signed int return_value_est_char_category$16;
        return_value_est_char_category$16=est_char_category((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
        if(return_value_est_char_category$16 == 3)
          goto __CPROVER_DUMP_L46;

      }

    }

    tmp=est_uconv_out((char *)word, wsiz, &tsiz);
    do
    {
      signed int est_break_text$$1$$4$$1$$2$$_CB_index = list->start + list->num;
      if(est_break_text$$1$$4$$1$$2$$_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc$17;
        return_value_realloc$17=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
        list->array = (struct anonymous$28 *)return_value_realloc$17;
        if(!(list->array == ((struct anonymous$28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      (list->array + (signed long int)est_break_text$$1$$4$$1$$2$$_CB_index)->dptr = tmp;
      (list->array + (signed long int)est_break_text$$1$$4$$1$$2$$_CB_index)->dsize = tsiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);

  __CPROVER_DUMP_L46:
    ;
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = words->start + words->num;
    _CB_i = words->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(words->array + (signed long int)_CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
  free((void *)utext);
}

// est_break_text_chrcat
// file estraier.c line 3509
void est_break_text_chrcat(const char *text, struct anonymous$1 *list, signed int norm)
{
  unsigned char *utext;
  char *tmp;
  signed int i;
  signed int j;
  signed int size;
  signed int cc;
  signed int tsiz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(text);
  char *return_value_est_uconv_in$2;
  return_value_est_uconv_in$2=est_uconv_in(text, (signed int)return_value_strlen$1, &size);
  utext = (unsigned char *)return_value_est_uconv_in$2;
  if(!(norm == 0))
    est_normalize_text(utext, size, &size);

  est_canonicalize_text(utext, size, 0);
  i = 0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  for( ; !(i >= size); i = i + 2)
  {
    cc=est_char_category_chrcat((signed int)utext[(signed long int)i] * 0x100 + (signed int)utext[(signed long int)(i + 1)]);
    j = i + 2;
    for( ; !(j >= size); j = j + 2)
    {
      signed int return_value_est_char_category_chrcat$7;
      return_value_est_char_category_chrcat$7=est_char_category_chrcat((signed int)utext[(signed long int)j] * 0x100 + (signed int)utext[(signed long int)(j + 1)]);
      if(!(return_value_est_char_category_chrcat$7 == cc))
      {
        if(!(cc == 2))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)utext[(signed long int)j] != 0x00 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)utext[(signed long int)(j + 1)] != 0x2d ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
        {
          if(!(cc == 4))
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = (signed int)utext[(signed long int)j] != 0x30 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = (signed int)utext[(signed long int)(j + 1)] != 0xfc ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            break;

        }

      }

    }
    if(!(cc == 0))
    {
      tmp=est_uconv_out((char *)(utext + (signed long int)i), j - i, &tsiz);
      do
      {
        signed int _CB_index = list->start + list->num;
        if(_CB_index >= list->anum)
        {
          list->anum = list->anum * 2;
          void *return_value_realloc$8;
          return_value_realloc$8=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
          list->array = (struct anonymous$28 *)return_value_realloc$8;
          if(!(list->array == ((struct anonymous$28 *)NULL)))
            list->array;

          else
            cbmyfatal("out of memory");
        }

        (list->array + (signed long int)_CB_index)->dptr = tmp;
        (list->array + (signed long int)_CB_index)->dsize = tsiz;
        list->num = list->num + 1;
      }
      while((_Bool)0);
    }

    i = j - 2;
  }
  free((void *)utext);
}

// est_break_text_perfng
// file estraier.c line 3439
void est_break_text_perfng(const char *text, struct anonymous$1 *list, signed int norm, signed int tail)
{
  struct anonymous$1 *words;
  const unsigned char *word;
  const unsigned char *next;
  unsigned char *utext;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int size;
  signed int cc;
  signed int wsiz;
  signed int nsiz;
  signed int tsiz;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(text);
  char *return_value_est_uconv_in$2;
  return_value_est_uconv_in$2=est_uconv_in(text, (signed int)return_value_strlen$1, &size);
  utext = (unsigned char *)return_value_est_uconv_in$2;
  if(!(norm == 0))
    est_normalize_text(utext, size, &size);

  est_canonicalize_text(utext, size, 0);
  do
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    words = (struct anonymous$1 *)return_value_malloc$3;
    if(!(words == ((struct anonymous$1 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous$28 *)return_value_malloc$4;
    if(!(words->array == ((struct anonymous$28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= size); i = i + 2)
  {
    cc=est_char_category_perfng((signed int)utext[(signed long int)i] * 0x100 + (signed int)utext[(signed long int)(i + 1)]);
    j = i + 2;
    for( ; !(j >= size); j = j + 2)
    {
      signed int return_value_est_char_category_perfng$5;
      return_value_est_char_category_perfng$5=est_char_category_perfng((signed int)utext[(signed long int)j] * 0x100 + (signed int)utext[(signed long int)(j + 1)]);
      if(!(return_value_est_char_category_perfng$5 == cc))
        break;

    }
    if(cc == 3)
    {
      k = i;
      for( ; !(k >= j); k = k + 2)
        if(j + -k >= 4)
          do
          {
            signed int _CB_index = words->start + words->num;
            if(_CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc$6;
              return_value_realloc$6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
              words->array = (struct anonymous$28 *)return_value_realloc$6;
              if(!(words->array == ((struct anonymous$28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            void *return_value_malloc$7;
            return_value_malloc$7=malloc((unsigned long int)((4 < 12 ? 12 : 4) + 1));
            (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$7;
            if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
              (words->array + (signed long int)_CB_index)->dptr;

            else
              cbmyfatal("out of memory");
            memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)4);
            (words->array + (signed long int)_CB_index)->dptr[(signed long int)4] = (char)0;
            (words->array + (signed long int)_CB_index)->dsize = 4;
            words->num = words->num + 1;
          }
          while((_Bool)0);

        else
          do
          {
            signed int est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index = words->start + words->num;
            if(est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc$8;
              return_value_realloc$8=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
              words->array = (struct anonymous$28 *)return_value_realloc$8;
              if(!(words->array == ((struct anonymous$28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            void *return_value_malloc$9;
            return_value_malloc$9=malloc((unsigned long int)((2 < 12 ? 12 : 2) + 1));
            (words->array + (signed long int)est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index)->dptr = (char *)return_value_malloc$9;
            if(!((words->array + (signed long int)est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index)->dptr == ((char *)NULL)))
              (words->array + (signed long int)est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index)->dptr;

            else
              cbmyfatal("out of memory");
            memcpy((void *)(words->array + (signed long int)est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index)->dptr, (const void *)(char *)(utext + (signed long int)k), (unsigned long int)2);
            (words->array + (signed long int)est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index)->dptr[(signed long int)2] = (char)0;
            (words->array + (signed long int)est_break_text_perfng$$1$$2$$1$$2$$1$$1$$2$$1$$_CB_index)->dsize = 2;
            words->num = words->num + 1;
          }
          while((_Bool)0);
    }

    i = j - 2;
  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    signed int return_value_est_char_category_perfng$13;
    return_value_est_char_category_perfng$13=est_char_category_perfng((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
    if(return_value_est_char_category_perfng$13 == 3)
    {
      if(wsiz == 2)
      {
        if(!(i >= words->num + -1))
        {
          const char *return_value_cblistval$10;
          return_value_cblistval$10=cblistval(words, i + 1, &nsiz);
          next = (unsigned char *)return_value_cblistval$10;
          if(nsiz >= 5)
            nsiz = 4;

          signed int return_value_est_char_category_perfng$11;
          return_value_est_char_category_perfng$11=est_char_category_perfng((signed int)next[(signed long int)0] * 0x100 + (signed int)next[(signed long int)1]);
          if(return_value_est_char_category_perfng$11 == 3)
          {
            if(nsiz >= 3)
              nsiz = 2;

          }

          void *return_value_malloc$12;
          return_value_malloc$12=malloc((unsigned long int)(wsiz + nsiz + 1));
          tmp = (char *)return_value_malloc$12;
          if(!(tmp == ((char *)NULL)))
            tmp;

          else
            cbmyfatal("out of memory");
          memcpy((void *)tmp, (const void *)word, (unsigned long int)wsiz);
          memcpy((void *)(tmp + (signed long int)wsiz), (const void *)next, (unsigned long int)nsiz);
          cblistover(words, i, tmp, wsiz + nsiz);
          free((void *)tmp);
        }

      }

    }

  }
  i = 0;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (unsigned char *)(const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(wsiz == 2 && tail == 0)
    {
      if(i == words->num + -1)
      {
        signed int return_value_est_char_category_perfng$14;
        return_value_est_char_category_perfng$14=est_char_category_perfng((signed int)word[(signed long int)0] * 0x100 + (signed int)word[(signed long int)1]);
        if(return_value_est_char_category_perfng$14 == 3)
          goto __CPROVER_DUMP_L40;

      }

    }

    tmp=est_uconv_out((char *)word, wsiz, &tsiz);
    do
    {
      signed int est_break_text_perfng$$1$$4$$1$$2$$_CB_index = list->start + list->num;
      if(est_break_text_perfng$$1$$4$$1$$2$$_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc$15;
        return_value_realloc$15=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
        list->array = (struct anonymous$28 *)return_value_realloc$15;
        if(!(list->array == ((struct anonymous$28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      (list->array + (signed long int)est_break_text_perfng$$1$$4$$1$$2$$_CB_index)->dptr = tmp;
      (list->array + (signed long int)est_break_text_perfng$$1$$4$$1$$2$$_CB_index)->dsize = tsiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);

  __CPROVER_DUMP_L40:
    ;
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = words->start + words->num;
    _CB_i = words->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(words->array + (signed long int)_CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
  free((void *)utext);
}

// est_bzdecode
// file estraier.c line 3990
char * est_bzdecode(const char *ptr, signed int size, signed int *sp)
{
  if(!(sp == ((signed int *)NULL)))
    *sp = size;

  char *return_value_cbmemdup$1;
  return_value_cbmemdup$1=cbmemdup(ptr, size);
  return return_value_cbmemdup$1;
}

// est_bzencode
// file estraier.c line 3936
char * est_bzencode(const char *ptr, signed int size, signed int *sp)
{
  unsigned long int return_value_strlen$1;
  if(!(size >= 0))
  {
    return_value_strlen$1=strlen(ptr);
    size = (signed int)return_value_strlen$1;
  }

  *sp = size;
  char *return_value_cbmemdup$2;
  return_value_cbmemdup$2=cbmemdup(ptr, size);
  return return_value_cbmemdup$2;
}

// est_canonicalize_text
// file estraier.c line 6242
static void est_canonicalize_text(unsigned char *utext, signed int size, signed int funcspc)
{
  signed int i = 0;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$39;
  _Bool tmp_if_expr$38;
  _Bool tmp_if_expr$37;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$35;
  _Bool tmp_if_expr$34;
  _Bool tmp_if_expr$33;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$31;
  _Bool tmp_if_expr$30;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$26;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$24;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$40;
  for( ; !(i >= size); i = i + 2)
    if((signed int)utext[(signed long int)i] == 0x0)
    {
      if(!((signed int)utext[(signed long int)(1 + i)] >= 32))
      {
        if(funcspc == 0)
          utext[(signed long int)(i + 1)] = (unsigned char)32;

      }

      else
      {
        if((signed int)utext[(signed long int)(1 + i)] >= 65)
          tmp_if_expr$11 = (signed int)utext[(signed long int)(i + 1)] <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        if(tmp_if_expr$11)
          utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)(97 - 65);

        else
          if((signed int)utext[(signed long int)(1 + i)] >= 0xc0)
          {
            if((signed int)utext[(signed long int)(1 + i)] >= 0xc0)
              tmp_if_expr$1 = (signed int)utext[(signed long int)(i + 1)] <= 0xd6 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$1 = (_Bool)0;
            if(tmp_if_expr$1)
              tmp_if_expr$3 = (_Bool)1;

            else
            {
              if((signed int)utext[(signed long int)(1 + i)] >= 0xd8)
                tmp_if_expr$2 = (signed int)utext[(signed long int)(i + 1)] <= 0xde ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$2 = (_Bool)0;
              tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$3)
              utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x20;

            if((signed int)utext[(signed long int)(1 + i)] >= 0xe0)
              tmp_if_expr$10 = (signed int)utext[(signed long int)(i + 1)] <= 0xe5 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$10 = (_Bool)0;
            if(tmp_if_expr$10)
              utext[(signed long int)(i + 1)] = (unsigned char)97;

            else
              if((signed int)utext[(signed long int)(1 + i)] == 0xe7)
                utext[(signed long int)(i + 1)] = (unsigned char)99;

              else
              {
                if((signed int)utext[(signed long int)(1 + i)] >= 0xe8)
                  tmp_if_expr$9 = (signed int)utext[(signed long int)(i + 1)] <= 0xeb ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$9 = (_Bool)0;
                if(tmp_if_expr$9)
                  utext[(signed long int)(i + 1)] = (unsigned char)101;

                else
                {
                  if((signed int)utext[(signed long int)(1 + i)] >= 0xec)
                    tmp_if_expr$8 = (signed int)utext[(signed long int)(i + 1)] <= 0xef ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$8 = (_Bool)0;
                  if(tmp_if_expr$8)
                    utext[(signed long int)(i + 1)] = (unsigned char)105;

                  else
                    if((signed int)utext[(signed long int)(1 + i)] == 0xf1)
                      utext[(signed long int)(i + 1)] = (unsigned char)110;

                    else
                    {
                      if((signed int)utext[(signed long int)(1 + i)] >= 0xf2)
                        tmp_if_expr$6 = (signed int)utext[(signed long int)(i + 1)] <= 0xf6 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr$6 = (_Bool)0;
                      if(tmp_if_expr$6)
                        tmp_if_expr$7 = (_Bool)1;

                      else
                        tmp_if_expr$7 = (signed int)utext[(signed long int)(i + 1)] == 0xf8 ? (_Bool)1 : (_Bool)0;
                      if(tmp_if_expr$7)
                        utext[(signed long int)(i + 1)] = (unsigned char)111;

                      else
                      {
                        if((signed int)utext[(signed long int)(1 + i)] >= 0xf9)
                          tmp_if_expr$5 = (signed int)utext[(signed long int)(i + 1)] <= 0xfc ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr$5 = (_Bool)0;
                        if(tmp_if_expr$5)
                          utext[(signed long int)(i + 1)] = (unsigned char)117;

                        else
                        {
                          if((signed int)utext[(signed long int)(1 + i)] == 0xfd)
                            tmp_if_expr$4 = (_Bool)1;

                          else
                            tmp_if_expr$4 = (signed int)utext[(signed long int)(i + 1)] == 0xff ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$4)
                            utext[(signed long int)(i + 1)] = (unsigned char)121;

                        }
                      }
                    }
                }
              }
          }

      }
    }

    else
      if((signed int)utext[(signed long int)i] == 0x1)
      {
        if(!((signed int)utext[(signed long int)(1 + i)] >= 55))
          tmp_if_expr$12 = (signed int)utext[(signed long int)(i + 1)] % 2 == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$12 = (_Bool)0;
        if(tmp_if_expr$12)
          tmp_if_expr$15 = (_Bool)1;

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x39)
            tmp_if_expr$13 = (signed int)utext[(signed long int)(i + 1)] <= 0x47 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
            tmp_if_expr$14 = (signed int)utext[(signed long int)(i + 1)] % 2 == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$14 = (_Bool)0;
          tmp_if_expr$15 = tmp_if_expr$14 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$15)
          tmp_if_expr$18 = (_Bool)1;

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x4a)
            tmp_if_expr$16 = (signed int)utext[(signed long int)(i + 1)] <= 0x76 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$16 = (_Bool)0;
          if(tmp_if_expr$16)
            tmp_if_expr$17 = (signed int)utext[(signed long int)(i + 1)] % 2 == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$17 = (_Bool)0;
          tmp_if_expr$18 = tmp_if_expr$17 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$18)
          tmp_if_expr$21 = (_Bool)1;

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x79)
            tmp_if_expr$19 = (signed int)utext[(signed long int)(i + 1)] <= 0x7d ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$19 = (_Bool)0;
          if(tmp_if_expr$19)
            tmp_if_expr$20 = (signed int)utext[(signed long int)(i + 1)] % 2 == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$20 = (_Bool)0;
          tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$21)
          utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x1;

        if(!((signed int)utext[(signed long int)(1 + i)] >= 6))
        {
          utext[(signed long int)i] = (unsigned char)0x0;
          utext[(signed long int)(i + 1)] = (unsigned char)97;
        }

        else
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x06)
            tmp_if_expr$39 = (signed int)utext[(signed long int)(i + 1)] <= 0x0d ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$39 = (_Bool)0;
          if(tmp_if_expr$39)
          {
            utext[(signed long int)i] = (unsigned char)0x0;
            utext[(signed long int)(i + 1)] = (unsigned char)99;
          }

          else
          {
            if((signed int)utext[(signed long int)(1 + i)] >= 0x0e)
              tmp_if_expr$38 = (signed int)utext[(signed long int)(i + 1)] <= 0x11 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$38 = (_Bool)0;
            if(tmp_if_expr$38)
            {
              utext[(signed long int)i] = (unsigned char)0x0;
              utext[(signed long int)(i + 1)] = (unsigned char)100;
            }

            else
            {
              if((signed int)utext[(signed long int)(1 + i)] >= 0x12)
                tmp_if_expr$37 = (signed int)utext[(signed long int)(i + 1)] <= 0x1b ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$37 = (_Bool)0;
              if(tmp_if_expr$37)
              {
                utext[(signed long int)i] = (unsigned char)0x0;
                utext[(signed long int)(i + 1)] = (unsigned char)101;
              }

              else
              {
                if((signed int)utext[(signed long int)(1 + i)] >= 0x1c)
                  tmp_if_expr$36 = (signed int)utext[(signed long int)(i + 1)] <= 0x23 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$36 = (_Bool)0;
                if(tmp_if_expr$36)
                {
                  utext[(signed long int)i] = (unsigned char)0x0;
                  utext[(signed long int)(i + 1)] = (unsigned char)103;
                }

                else
                {
                  if((signed int)utext[(signed long int)(1 + i)] >= 0x24)
                    tmp_if_expr$35 = (signed int)utext[(signed long int)(i + 1)] <= 0x27 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$35 = (_Bool)0;
                  if(tmp_if_expr$35)
                  {
                    utext[(signed long int)i] = (unsigned char)0x0;
                    utext[(signed long int)(i + 1)] = (unsigned char)104;
                  }

                  else
                  {
                    if((signed int)utext[(signed long int)(1 + i)] >= 0x28)
                      tmp_if_expr$34 = (signed int)utext[(signed long int)(i + 1)] <= 0x31 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$34 = (_Bool)0;
                    if(tmp_if_expr$34)
                    {
                      utext[(signed long int)i] = (unsigned char)0x0;
                      utext[(signed long int)(i + 1)] = (unsigned char)105;
                    }

                    else
                    {
                      if((signed int)utext[(signed long int)(1 + i)] >= 0x34)
                        tmp_if_expr$33 = (signed int)utext[(signed long int)(i + 1)] <= 0x35 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr$33 = (_Bool)0;
                      if(tmp_if_expr$33)
                      {
                        utext[(signed long int)i] = (unsigned char)0x0;
                        utext[(signed long int)(i + 1)] = (unsigned char)106;
                      }

                      else
                      {
                        if((signed int)utext[(signed long int)(1 + i)] >= 0x36)
                          tmp_if_expr$32 = (signed int)utext[(signed long int)(i + 1)] <= 0x38 ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr$32 = (_Bool)0;
                        if(tmp_if_expr$32)
                        {
                          utext[(signed long int)i] = (unsigned char)0x0;
                          utext[(signed long int)(i + 1)] = (unsigned char)107;
                        }

                        else
                        {
                          if((signed int)utext[(signed long int)(1 + i)] >= 0x39)
                            tmp_if_expr$31 = (signed int)utext[(signed long int)(i + 1)] <= 0x42 ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr$31 = (_Bool)0;
                          if(tmp_if_expr$31)
                          {
                            utext[(signed long int)i] = (unsigned char)0x0;
                            utext[(signed long int)(i + 1)] = (unsigned char)108;
                          }

                          else
                          {
                            if((signed int)utext[(signed long int)(1 + i)] >= 0x43)
                              tmp_if_expr$30 = (signed int)utext[(signed long int)(i + 1)] <= 0x4b ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr$30 = (_Bool)0;
                            if(tmp_if_expr$30)
                            {
                              utext[(signed long int)i] = (unsigned char)0x0;
                              utext[(signed long int)(i + 1)] = (unsigned char)110;
                            }

                            else
                            {
                              if((signed int)utext[(signed long int)(1 + i)] >= 0x4c)
                                tmp_if_expr$29 = (signed int)utext[(signed long int)(i + 1)] <= 0x51 ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$29 = (_Bool)0;
                              if(tmp_if_expr$29)
                              {
                                utext[(signed long int)i] = (unsigned char)0x0;
                                utext[(signed long int)(i + 1)] = (unsigned char)111;
                              }

                              else
                              {
                                if((signed int)utext[(signed long int)(1 + i)] >= 0x54)
                                  tmp_if_expr$28 = (signed int)utext[(signed long int)(i + 1)] <= 0x59 ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr$28 = (_Bool)0;
                                if(tmp_if_expr$28)
                                {
                                  utext[(signed long int)i] = (unsigned char)0x0;
                                  utext[(signed long int)(i + 1)] = (unsigned char)114;
                                }

                                else
                                {
                                  if((signed int)utext[(signed long int)(1 + i)] >= 0x5a)
                                    tmp_if_expr$26 = (signed int)utext[(signed long int)(i + 1)] <= 0x61 ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr$26 = (_Bool)0;
                                  if(tmp_if_expr$26)
                                    tmp_if_expr$27 = (_Bool)1;

                                  else
                                    tmp_if_expr$27 = (signed int)utext[(signed long int)(i + 1)] == 0x7f ? (_Bool)1 : (_Bool)0;
                                  if(tmp_if_expr$27)
                                  {
                                    utext[(signed long int)i] = (unsigned char)0x0;
                                    utext[(signed long int)(i + 1)] = (unsigned char)115;
                                  }

                                  else
                                  {
                                    if((signed int)utext[(signed long int)(1 + i)] >= 0x62)
                                      tmp_if_expr$25 = (signed int)utext[(signed long int)(i + 1)] <= 0x67 ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr$25 = (_Bool)0;
                                    if(tmp_if_expr$25)
                                    {
                                      utext[(signed long int)i] = (unsigned char)0x0;
                                      utext[(signed long int)(i + 1)] = (unsigned char)116;
                                    }

                                    else
                                    {
                                      if((signed int)utext[(signed long int)(1 + i)] >= 0x68)
                                        tmp_if_expr$24 = (signed int)utext[(signed long int)(i + 1)] <= 0x73 ? (_Bool)1 : (_Bool)0;

                                      else
                                        tmp_if_expr$24 = (_Bool)0;
                                      if(tmp_if_expr$24)
                                      {
                                        utext[(signed long int)i] = (unsigned char)0x0;
                                        utext[(signed long int)(i + 1)] = (unsigned char)117;
                                      }

                                      else
                                      {
                                        if((signed int)utext[(signed long int)(1 + i)] >= 0x74)
                                          tmp_if_expr$23 = (signed int)utext[(signed long int)(i + 1)] <= 0x75 ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr$23 = (_Bool)0;
                                        if(tmp_if_expr$23)
                                        {
                                          utext[(signed long int)i] = (unsigned char)0x0;
                                          utext[(signed long int)(i + 1)] = (unsigned char)119;
                                        }

                                        else
                                        {
                                          if((signed int)utext[(signed long int)(1 + i)] >= 0x76)
                                            tmp_if_expr$22 = (signed int)utext[(signed long int)(i + 1)] <= 0x78 ? (_Bool)1 : (_Bool)0;

                                          else
                                            tmp_if_expr$22 = (_Bool)0;
                                          if(tmp_if_expr$22)
                                          {
                                            utext[(signed long int)i] = (unsigned char)0x0;
                                            utext[(signed long int)(i + 1)] = (unsigned char)121;
                                          }

                                          else
                                            if((signed int)utext[(signed long int)(1 + i)] >= 0x79)
                                            {
                                              if(!((signed int)utext[(signed long int)(1 + i)] >= 127))
                                              {
                                                utext[(signed long int)i] = (unsigned char)0x0;
                                                utext[(signed long int)(i + 1)] = (unsigned char)122;
                                              }

                                            }

                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      else
        if((signed int)utext[(signed long int)i] == 0x3)
        {
          if((signed int)utext[(signed long int)(1 + i)] >= 0x91)
          {
            if(!((signed int)utext[(signed long int)(1 + i)] >= 170))
              utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x20;

          }

        }

        else
          if((signed int)utext[(signed long int)i] == 0x4)
          {
            if((signed int)utext[(signed long int)(1 + i)] >= 0x10)
              tmp_if_expr$40 = (signed int)utext[(signed long int)(i + 1)] <= 0x2f ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$40 = (_Bool)0;
            if(tmp_if_expr$40)
              utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x20;

            else
              if(!((signed int)utext[(signed long int)(1 + i)] >= 16))
                utext[(signed long int)(i + 1)] = utext[(signed long int)(i + 1)] + (unsigned char)0x50;

          }

          else
            if((signed int)utext[(signed long int)i] == 0xff)
            {
              if((signed int)utext[(signed long int)(1 + i)] >= 0xf0)
              {
                utext[(signed long int)i] = (unsigned char)0x0;
                utext[(signed long int)(i + 1)] = (unsigned char)32;
              }

            }

}

// est_char_category
// file estraier.c line 6363
static signed int est_char_category(signed int c)
{
  if(!(c >= 33))
    return 0;

  else
    if(c >= 0x0030 && !(c >= 58) || c >= 0x0041 && !(c >= 91) || c >= 0x0061 && !(c >= 123))
      return 2;

    else
      if(c >= 0x0100 && !(c >= 384) || c >= 0x00c0 && !(c == 0x00d7) && !(c == 0x00f7) && !(c >= 256))
        return 2;

      else
        if(c >= 0x0600 && !(c >= 2304))
          return 3;

        else
          if(c >= 0x0900 && !(c >= 4256) || c >= 0x1700 && !(c >= 7424))
            return 3;

          else
            if(c >= 0x1100 && !(c >= 4608) || c >= 0x2e80 && !(c >= 57344) || c >= 0xf900 && !(c >= 64256) || c >= 0xff00 && !(c >= 65520))
              return 3;

            else
              if(c >= 0xfb50 && !(c >= 65024) || c >= 0xfe30 && !(c >= 65104) || c >= 0xfe70 && !(c >= 65280))
                return 3;

              else
                return 1;
}

// est_char_category_chrcat
// file estraier.c line 6399
static signed int est_char_category_chrcat(signed int c)
{
  if(!(c >= 33))
    return 0;

  else
    if(c >= 0x0030 && !(c >= 58) || c >= 0x0041 && !(c >= 91) || c >= 0x0061 && !(c >= 123))
      return 2;

    else
      if(c >= 0x0100 && !(c >= 384) || c >= 0x00c0 && !(c == 0x00d7) && !(c == 0x00f7) && !(c >= 256))
        return 2;

      else
        if(c >= 0x0600 && !(c >= 2304))
          return 3;

        else
          if(c >= 0x0900 && !(c >= 4256) || c >= 0x1700 && !(c >= 7424))
            return 3;

          else
            if(c >= 0x3040 && !(c >= 12448))
              return 4;

            else
              if(c >= 0x30a0 && !(c >= 12544))
                return 5;

              else
                if(c >= 0x1100 && !(c >= 4608) || c >= 0x3130 && !(c >= 12688) || c >= 0xac00 && !(c >= 55216))
                  return 6;

                else
                  if(c >= 0x4e00 && !(c >= 40880))
                    return 7;

                  else
                    if(c >= 0x2e80 && !(c >= 57344) || c >= 0xf900 && !(c >= 64256) || c >= 0xff00 && !(c >= 65520))
                      return 3;

                    else
                      if(c >= 0xfb50 && !(c >= 65024) || c >= 0xfe30 && !(c >= 65104) || c >= 0xfe70 && !(c >= 65280))
                        return 3;

                      else
                        return 1;
}

// est_char_category_perfng
// file estraier.c line 6390
static signed int est_char_category_perfng(signed int c)
{
  if(!(c >= 33))
    return 0;

  else
    return 3;
}

// est_check_cjk_only
// file estraier.c line 6516
static signed int est_check_cjk_only(const char *str)
{
  const unsigned char *rp;
  signed int size;
  rp = (unsigned char *)str;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  size = (signed int)return_value_strlen$1;
  while(!(rp >= (unsigned char *)str + (signed long int)size))
    if(!((signed int)*rp >= 0x7f))
      return 0;

    else
      if(!((signed int)*rp >= 0xdf))
        return 0;

      else
        if(!((signed int)*rp >= 0xf0))
        {
          if(rp >= (unsigned char *)str + (signed long int)size + -2l)
            break;

          rp = rp + (signed long int)3;
        }

        else
          if(!((signed int)*rp >= 0xf8))
          {
            if(rp >= (unsigned char *)str + (signed long int)size + -3l)
              break;

            rp = rp + (signed long int)4;
          }

          else
            if(!((signed int)*rp >= 0xfb))
            {
              if(rp >= (unsigned char *)str + (signed long int)size + -4l)
                break;

              rp = rp + (signed long int)5;
            }

            else
              if(!((signed int)*rp >= 0xfd))
              {
                if(rp >= (unsigned char *)str + (signed long int)size + -5l)
                  break;

                rp = rp + (signed long int)6;
              }

              else
                break;
  return 1;
}

// est_check_numbt
// file estraier.c line 10174
static signed int est_check_numbt(const char *tval, const char *oval)
{
  signed long int val;
  signed long int lower;
  signed long int upper;
  signed long int swap;
  char numbuf[32l];
  signed int i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  do
  {
    if(!(i >= 32))
      tmp_if_expr$1 = (signed int)oval[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (signed int)oval[(signed long int)i] != 32 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (signed int)oval[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    numbuf[(signed long int)i] = oval[(signed long int)i];
    i = i + 1;
  }
  while((_Bool)1);
  numbuf[(signed long int)i] = (char)0;
  oval = oval + (signed long int)i;
  for( ; (_Bool)1; oval = oval + 1l)
    if(!((signed int)*oval == 32))
    {
      if(!((signed int)*oval == 9))
        goto __CPROVER_DUMP_L11;

    }


__CPROVER_DUMP_L11:
  ;
  if((signed int)*oval == 0)
    return 0;

  else
  {
    val=cbstrmktime(tval);
    lower=cbstrmktime(numbuf);
    upper=cbstrmktime(oval);
    if(!(upper >= lower))
    {
      swap = lower;
      lower = upper;
      upper = swap;
    }

    return (signed int)(val >= lower && val <= upper);
  }
}

// est_check_strand
// file estraier.c line 10073
static signed int est_check_strand(const char *tval, const char *oval)
{
  const char *sp;
  const char *ep;
  const char *rp;
  const char *pp;
  const char *qp;
  signed int hit;
  sp = oval;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  for( ; !((signed int)*sp == 0); sp = ep)
  {
    for( ; (_Bool)1; sp = sp + 1l)
      if(!((signed int)*sp == 32))
      {
        if(!((signed int)*sp == 44))
          goto __CPROVER_DUMP_L4;

      }


  __CPROVER_DUMP_L4:
    ;
    ep = sp;
    for( ; !((signed int)*ep == 0); ep = ep + 1l)
    {
      if((signed int)*ep == 32)
        break;

      if((signed int)*ep == 44)
        break;

    }
    if(!(sp >= ep))
    {
      hit = 0;
      rp = tval;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
      {
        pp = sp;
        qp = rp;
        for( ; !(pp >= ep); qp = qp + 1l)
        {
          if(!(*pp == *qp))
            break;

          pp = pp + 1l;
        }
        if(pp == ep)
        {
          if((signed int)*qp == 0)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = (signed int)*qp == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = (signed int)*qp == 44 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
          {
            hit = 1;
            break;
          }

        }

      }
      if(hit == 0)
        return 0;

    }

  }
  return 1;
}

// est_check_stror
// file estraier.c line 10109
static signed int est_check_stror(const char *tval, const char *oval)
{
  const char *sp;
  const char *ep;
  const char *rp;
  const char *pp;
  const char *qp;
  signed int hit;
  sp = oval;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  for( ; !((signed int)*sp == 0); sp = ep)
  {
    for( ; (_Bool)1; sp = sp + 1l)
      if(!((signed int)*sp == 32))
      {
        if(!((signed int)*sp == 44))
          goto __CPROVER_DUMP_L4;

      }


  __CPROVER_DUMP_L4:
    ;
    ep = sp;
    for( ; !((signed int)*ep == 0); ep = ep + 1l)
    {
      if((signed int)*ep == 32)
        break;

      if((signed int)*ep == 44)
        break;

    }
    if(!(sp >= ep))
    {
      hit = 0;
      rp = tval;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
      {
        pp = sp;
        qp = rp;
        for( ; !(pp >= ep); qp = qp + 1l)
        {
          if(!(*pp == *qp))
            break;

          pp = pp + 1l;
        }
        if(pp == ep)
        {
          if((signed int)*qp == 0)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = (signed int)*qp == 32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = (signed int)*qp == 44 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
          {
            hit = 1;
            break;
          }

        }

      }
      if(!(hit == 0))
        return 1;

    }

  }
  return 0;
}

// est_check_stroreq
// file estraier.c line 10145
static signed int est_check_stroreq(const char *tval, const char *oval)
{
  const char *sp;
  const char *ep;
  const char *rp;
  sp = oval;
  for( ; !((signed int)*sp == 0); sp = ep)
  {
    for( ; (_Bool)1; sp = sp + 1l)
      if(!((signed int)*sp == 32))
      {
        if(!((signed int)*sp == 44))
          goto __CPROVER_DUMP_L4;

      }


  __CPROVER_DUMP_L4:
    ;
    ep = sp;
    for( ; !((signed int)*ep == 0); ep = ep + 1l)
    {
      if((signed int)*ep == 32)
        break;

      if((signed int)*ep == 44)
        break;

    }
    if(!(sp >= ep))
    {
      rp = tval;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
      {
        if(sp >= ep || !(*sp == *rp))
          break;

        sp = sp + 1l;
      }
      if((signed int)*rp == 0)
      {
        if(sp == ep)
          return 1;

      }

    }

  }
  return 0;
}

// est_cond_add_attr
// file estraier.h line 313
void est_cond_add_attr(struct anonymous$8 *cond, const char *expr)
{
  for( ; (signed int)*expr >= 1; expr = expr + 1l)
    if((signed int)*expr >= 33)
      break;

  unsigned long int tmp_if_expr$6;
  unsigned long int return_value_strlen$5;
  if(!((signed int)*expr == 0))
  {
    if(cond->attrs == ((struct anonymous$1 *)NULL))
      do
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
        cond->attrs = (struct anonymous$1 *)return_value_malloc$1;
        if(!(cond->attrs == ((struct anonymous$1 *)NULL)))
          cond->attrs;

        else
          cbmyfatal("out of memory");
        cond->attrs->anum = 64;
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)cond->attrs->anum);
        cond->attrs->array = (struct anonymous$28 *)return_value_malloc$2;
        if(!(cond->attrs->array == ((struct anonymous$28 *)NULL)))
          cond->attrs->array;

        else
          cbmyfatal("out of memory");
        cond->attrs->start = 0;
        cond->attrs->num = 0;
      }
      while((_Bool)0);

    do
    {
      signed int _CB_index = cond->attrs->start + cond->attrs->num;
      if(_CB_index >= cond->attrs->anum)
      {
        cond->attrs->anum = cond->attrs->anum * 2;
        void *return_value_realloc$3;
        return_value_realloc$3=realloc((void *)cond->attrs->array, (unsigned long int)cond->attrs->anum * sizeof(struct anonymous$28) /*16ul*/ );
        cond->attrs->array = (struct anonymous$28 *)return_value_realloc$3;
        if(!(cond->attrs->array == ((struct anonymous$28 *)NULL)))
          cond->attrs->array;

        else
          cbmyfatal("out of memory");
      }

      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(expr);
      if(!(return_value_strlen$4 >= 12ul))
        tmp_if_expr$6 = (unsigned long int)12;

      else
      {
        return_value_strlen$5=strlen(expr);
        tmp_if_expr$6 = return_value_strlen$5;
      }
      void *return_value_malloc$7;
      return_value_malloc$7=malloc(tmp_if_expr$6 + (unsigned long int)1);
      (cond->attrs->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$7;
      if(!((cond->attrs->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
        (cond->attrs->array + (signed long int)_CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      unsigned long int return_value_strlen$8;
      return_value_strlen$8=strlen(expr);
      memcpy((void *)(cond->attrs->array + (signed long int)_CB_index)->dptr, (const void *)expr, return_value_strlen$8);
      unsigned long int return_value_strlen$9;
      return_value_strlen$9=strlen(expr);
      (cond->attrs->array + (signed long int)_CB_index)->dptr[(signed long int)return_value_strlen$9] = (char)0;
      unsigned long int return_value_strlen$10;
      return_value_strlen$10=strlen(expr);
      (cond->attrs->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen$10;
      cond->attrs->num = cond->attrs->num + 1;
    }
    while((_Bool)0);
  }

}

// est_cond_attrs
// file estraier.c line 4315
const struct anonymous$1 * est_cond_attrs(struct anonymous$8 *cond)
{
  return cond->attrs;
}

// est_cond_auxiliary
// file estraier.c line 4350
signed int est_cond_auxiliary(struct anonymous$8 *cond)
{
  return cond->auxmin;
}

// est_cond_auxiliary_word
// file estraier.c line 4395
signed int est_cond_auxiliary_word(struct anonymous$8 *cond, const char *word)
{
  const char *return_value_cbmapget$1;
  if(cond->auxwords == ((struct anonymous$9 *)NULL))
    return 0;

  else
    if(!((signed int)*word == 0))
    {
      return_value_cbmapget$1=cbmapget(cond->auxwords, word, -1, (signed int *)(void *)0);
      return (signed int)(return_value_cbmapget$1 != (const char *)(void *)0);
    }

    else
    {
      signed int return_value_cbmaprnum$2;
      return_value_cbmaprnum$2=cbmaprnum(cond->auxwords);
      return (signed int)(return_value_cbmaprnum$2 > 0);
    }
}

// est_cond_delete
// file estraier.h line 301
void est_cond_delete(struct anonymous$8 *cond)
{
  if(!(cond->distinct == ((char *)NULL)))
    free((void *)cond->distinct);

  if(!(cond->shadows == ((struct anonymous$9 *)NULL)))
    cbmapclose(cond->shadows);

  if(!(cond->auxwords == ((struct anonymous$9 *)NULL)))
    cbmapclose(cond->auxwords);

  if(!(cond->scores == ((signed int *)NULL)))
    free((void *)cond->scores);

  if(!(cond->order == ((char *)NULL)))
    free((void *)cond->order);

  if(!(cond->attrs == ((struct anonymous$1 *)NULL)))
    do
    {
      signed int _CB_i;
      signed int _CB_end = cond->attrs->start + cond->attrs->num;
      _CB_i = cond->attrs->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(cond->attrs->array + (signed long int)_CB_i)->dptr);
      free((void *)cond->attrs->array);
      free((void *)cond->attrs);
    }
    while((_Bool)0);

  if(!(cond->phrase == ((char *)NULL)))
    free((void *)cond->phrase);

  free((void *)cond);
}

// est_cond_distinct
// file estraier.c line 4357
const char * est_cond_distinct(struct anonymous$8 *cond)
{
  return cond->distinct;
}

// est_cond_dup
// file estraier.c line 4277
struct anonymous$8 * est_cond_dup(struct anonymous$8 *cond)
{
  struct anonymous$8 *ncond;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$8) /*144ul*/ );
  ncond = (struct anonymous$8 *)return_value_malloc$1;
  if(!(ncond == ((struct anonymous$8 *)NULL)))
    ncond;

  else
    cbmyfatal("out of memory");
  char *tmp_if_expr$3;
  char *return_value_cbmemdup$2;
  if(!(cond->phrase == ((char *)NULL)))
  {
    return_value_cbmemdup$2=cbmemdup(cond->phrase, -1);
    tmp_if_expr$3 = return_value_cbmemdup$2;
  }

  else
    tmp_if_expr$3 = (char *)(void *)0;
  ncond->phrase = tmp_if_expr$3;
  ncond->gstep = cond->gstep;
  ncond->tfidf = cond->tfidf;
  ncond->pmode = cond->pmode;
  ncond->cbxpn = cond->cbxpn;
  struct anonymous$1 *tmp_if_expr$5;
  struct anonymous$1 *return_value_cblistdup$4;
  if(!(cond->attrs == ((struct anonymous$1 *)NULL)))
  {
    return_value_cblistdup$4=cblistdup(cond->attrs);
    tmp_if_expr$5 = return_value_cblistdup$4;
  }

  else
    tmp_if_expr$5 = (struct anonymous$1 *)(void *)0;
  ncond->attrs = tmp_if_expr$5;
  char *tmp_if_expr$7;
  char *return_value_cbmemdup$6;
  if(!(cond->order == ((char *)NULL)))
  {
    return_value_cbmemdup$6=cbmemdup(cond->order, -1);
    tmp_if_expr$7 = return_value_cbmemdup$6;
  }

  else
    tmp_if_expr$7 = (char *)(void *)0;
  ncond->order = tmp_if_expr$7;
  ncond->max = cond->max;
  ncond->skip = cond->skip;
  ncond->auxmin = cond->auxmin;
  struct anonymous$9 *tmp_if_expr$9;
  struct anonymous$9 *return_value_cbmapdup$8;
  if(!(cond->auxwords == ((struct anonymous$9 *)NULL)))
  {
    return_value_cbmapdup$8=cbmapdup(cond->auxwords);
    tmp_if_expr$9 = return_value_cbmapdup$8;
  }

  else
    tmp_if_expr$9 = (struct anonymous$9 *)(void *)0;
  ncond->auxwords = tmp_if_expr$9;
  ncond->scfb = cond->scfb;
  signed int *tmp_if_expr$11;
  char *return_value_cbmemdup$10;
  if(!(cond->scores == ((signed int *)NULL)))
  {
    return_value_cbmemdup$10=cbmemdup((char *)cond->scores, (signed int)((unsigned long int)cond->snum * sizeof(signed int) /*4ul*/ ));
    tmp_if_expr$11 = (signed int *)return_value_cbmemdup$10;
  }

  else
    tmp_if_expr$11 = (signed int *)(void *)0;
  ncond->scores = tmp_if_expr$11;
  ncond->snum = cond->snum;
  ncond->nscores = cond->nscores;
  ncond->nsnum = cond->nsnum;
  ncond->opts = cond->opts;
  ncond->ecllim = cond->ecllim;
  struct anonymous$9 *tmp_if_expr$13;
  struct anonymous$9 *return_value_cbmapdup$12;
  if(!(cond->shadows == ((struct anonymous$9 *)NULL)))
  {
    return_value_cbmapdup$12=cbmapdup(cond->shadows);
    tmp_if_expr$13 = return_value_cbmapdup$12;
  }

  else
    tmp_if_expr$13 = (struct anonymous$9 *)(void *)0;
  ncond->shadows = tmp_if_expr$13;
  char *tmp_if_expr$15;
  char *return_value_cbmemdup$14;
  if(!(cond->distinct == ((char *)NULL)))
  {
    return_value_cbmemdup$14=cbmemdup(cond->distinct, -1);
    tmp_if_expr$15 = return_value_cbmemdup$14;
  }

  else
    tmp_if_expr$15 = (char *)(void *)0;
  ncond->distinct = tmp_if_expr$15;
  ncond->mask = cond->mask;
  return ncond;
}

// est_cond_mask
// file estraier.c line 4364
signed int est_cond_mask(struct anonymous$8 *cond)
{
  return cond->mask;
}

// est_cond_max
// file estraier.c line 4329
signed int est_cond_max(struct anonymous$8 *cond)
{
  return cond->max;
}

// est_cond_new
// file estraier.h line 296
struct anonymous$8 * est_cond_new(void)
{
  struct anonymous$8 *cond;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$8) /*144ul*/ );
  cond = (struct anonymous$8 *)return_value_malloc$1;
  if(!(cond == ((struct anonymous$8 *)NULL)))
    cond;

  else
    cbmyfatal("out of memory");
  cond->phrase = (char *)(void *)0;
  cond->gstep = 2;
  cond->tfidf = 1;
  cond->pmode = 0;
  cond->cbxpn = (void (*)(const char *, struct anonymous$1 *))(void *)0;
  cond->attrs = (struct anonymous$1 *)(void *)0;
  cond->order = (char *)(void *)0;
  cond->max = -1;
  cond->skip = 0;
  cond->auxmin = 32;
  cond->auxwords = (struct anonymous$9 *)(void *)0;
  cond->scfb = 0;
  cond->scores = (signed int *)(void *)0;
  cond->snum = 0;
  cond->nscores = (const signed int *)(void *)0;
  cond->nsnum = -1;
  cond->opts = 0;
  cond->ecllim = -1.0;
  cond->shadows = (struct anonymous$9 *)(void *)0;
  cond->distinct = (char *)(void *)0;
  cond->mask = 0;
  return cond;
}

// est_cond_options
// file estraier.c line 4343
signed int est_cond_options(struct anonymous$8 *cond)
{
  return cond->opts;
}

// est_cond_order
// file estraier.c line 4322
const char * est_cond_order(struct anonymous$8 *cond)
{
  return cond->order;
}

// est_cond_phrase
// file estraier.c line 4308
const char * est_cond_phrase(struct anonymous$8 *cond)
{
  return cond->phrase;
}

// est_cond_score
// file estraier.c line 4371
signed int est_cond_score(struct anonymous$8 *cond, signed int index)
{
  _Bool tmp_if_expr$1;
  if(cond->scores == ((signed int *)NULL) || !(index >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = index >= cond->snum ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
    return cond->scores[(signed long int)index];
}

// est_cond_scores
// file estraier.c line 4379
const signed int * est_cond_scores(struct anonymous$8 *cond, signed int *nump)
{
  *nump = cond->snum;
  return cond->scores;
}

// est_cond_set_auxiliary
// file estraier.c line 855
void est_cond_set_auxiliary(struct anonymous$8 *cond, signed int min)
{
  cond->auxmin = min;
}

// est_cond_set_distinct
// file estraier.c line 869
void est_cond_set_distinct(struct anonymous$8 *cond, const char *name)
{
  for( ; (signed int)*name >= 1; name = name + 1l)
    if((signed int)*name >= 33)
      break;

  if(!((signed int)*name == 0))
  {
    if(!(cond->distinct == ((char *)NULL)))
      free((void *)cond->distinct);

    cond->distinct=cbmemdup(name, -1);
  }

}

// est_cond_set_eclipse
// file estraier.c line 862
void est_cond_set_eclipse(struct anonymous$8 *cond, double limit)
{
  if(limit > 0.0)
    cond->ecllim = limit;

}

// est_cond_set_expander
// file estraier.c line 4418
void est_cond_set_expander(struct anonymous$8 *cond, void (*func)(const char *, struct anonymous$1 *))
{
  cond->cbxpn = func;
}

// est_cond_set_mask
// file estraier.c line 881
void est_cond_set_mask(struct anonymous$8 *cond, signed int mask)
{
  cond->mask = mask & 0x7fffffff;
}

// est_cond_set_max
// file estraier.c line 824
void est_cond_set_max(struct anonymous$8 *cond, signed int max)
{
  cond->max = max;
}

// est_cond_set_narrowing_scores
// file estraier.c line 4387
void est_cond_set_narrowing_scores(struct anonymous$8 *cond, const signed int *scores, signed int num)
{
  cond->nscores = scores;
  cond->nsnum = num;
}

// est_cond_set_options
// file estraier.c line 838
void est_cond_set_options(struct anonymous$8 *cond, signed int options)
{
  if(!((1 & options) == 0))
    cond->gstep = 1;

  if(!((2 & options) == 0))
    cond->gstep = 2;

  if(!((4 & options) == 0))
    cond->gstep = 3;

  if(!((8 & options) == 0))
    cond->gstep = 4;

  if(!((16 & options) == 0))
    cond->tfidf = 0;

  if(!((1024 & options) == 0))
    cond->pmode = 1;

  if(!((2048 & options) == 0))
    cond->pmode = 2;

  if(!((32768 & options) == 0))
    cond->pmode = 3;

  if(!((65536 & options) == 0))
    cond->pmode = 4;

  if(!((1073741824 & options) == 0))
    cond->scfb = 1;

  cond->opts = cond->opts | options;
}

// est_cond_set_order
// file estraier.h line 319
void est_cond_set_order(struct anonymous$8 *cond, const char *expr)
{
  for( ; (signed int)*expr >= 1; expr = expr + 1l)
    if((signed int)*expr >= 33)
      break;

  if(!((signed int)*expr == 0))
  {
    if(!(cond->order == ((char *)NULL)))
      free((void *)cond->order);

    cond->order=cbmemdup(expr, -1);
  }

}

// est_cond_set_phrase
// file estraier.h line 307
void est_cond_set_phrase(struct anonymous$8 *cond, const char *phrase)
{
  if(!(cond->phrase == ((char *)NULL)))
    free((void *)cond->phrase);

  for( ; (signed int)*phrase >= 1; phrase = phrase + 1l)
    if((signed int)*phrase >= 33)
      break;

  cond->phrase=cbmemdup(phrase, -1);
}

// est_cond_set_skip
// file estraier.c line 831
void est_cond_set_skip(struct anonymous$8 *cond, signed int skip)
{
  cond->skip = skip;
}

// est_cond_shadows
// file estraier.c line 4404
const signed int * est_cond_shadows(struct anonymous$8 *cond, signed int id, signed int *np)
{
  const char *vbuf;
  signed int vsiz;
  _Bool tmp_if_expr$1;
  if(cond->shadows == ((struct anonymous$9 *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    vbuf=cbmapget(cond->shadows, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &vsiz);
    tmp_if_expr$1 = !(vbuf != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$1)
  {
    *np = 0;
    return (signed int *)"";
  }

  else
  {
    *np = (signed int)((unsigned long int)vsiz / sizeof(signed int) /*4ul*/ );
    return (signed int *)vbuf;
  }
}

// est_cond_skip
// file estraier.c line 4336
signed int est_cond_skip(struct anonymous$8 *cond)
{
  return cond->skip;
}

// est_crget
// file estraier.c line 7370
static char * est_crget(struct anonymous$4 *curia, signed int zmode, signed int id, signed int *sp)
{
  char *zbuf;
  char *vbuf;
  signed int zsiz;
  switch(zmode)
  {
    case 32768:
    {
      zbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, &zsiz);
      if(zbuf == ((char *)NULL))
        return (char *)(void *)0;

      vbuf=est_inflate(zbuf, zsiz, sp, -1);
      if(vbuf == ((char *)NULL))
      {
        free((void *)zbuf);
        return (char *)(void *)0;
      }

      free((void *)zbuf);
      break;
    }
    case 65536:
    {
      zbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, &zsiz);
      if(zbuf == ((char *)NULL))
        return (char *)(void *)0;

      vbuf=est_lzodecode(zbuf, zsiz, sp);
      if(vbuf == ((char *)NULL))
      {
        free((void *)zbuf);
        return (char *)(void *)0;
      }

      free((void *)zbuf);
      break;
    }
    case 131072:
    {
      zbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, &zsiz);
      if(zbuf == ((char *)NULL))
        return (char *)(void *)0;

      vbuf=est_bzdecode(zbuf, zsiz, sp);
      if(vbuf == ((char *)NULL))
      {
        free((void *)zbuf);
        return (char *)(void *)0;
      }

      free((void *)zbuf);
      break;
    }
    default:
    {
      vbuf=crget(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, sp);
      if(vbuf == ((char *)NULL))
        return (char *)(void *)0;

    }
  }
  return vbuf;
}

// est_crout
// file estraier.c line 7357
static signed int est_crout(struct anonymous$4 *curia, signed int id)
{
  signed int return_value_crout$1;
  return_value_crout$1=crout(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
  return return_value_crout$1;
}

// est_crput
// file estraier.c line 7307
static signed int est_crput(struct anonymous$4 *curia, signed int zmode, signed int id, const char *vbuf, signed int vsiz, signed int dmode)
{
  char *zbuf;
  signed int zsiz;
  signed int return_value_crput$2;
  signed int return_value_crput$4;
  signed int return_value_crput$6;
  signed int return_value_crput$7;
  switch(zmode)
  {
    case 32768:
    {
      zbuf=est_deflate(vbuf, vsiz, &zsiz, -1);
      if(zbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr$1;
        return_value_dpecodeptr$1=dpecodeptr();
        *return_value_dpecodeptr$1 = 9999;
        return 0;
      }

      return_value_crput$2=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , zbuf, zsiz, dmode);
      if(return_value_crput$2 == 0)
      {
        free((void *)zbuf);
        return 0;
      }

      free((void *)zbuf);
      break;
    }
    case 65536:
    {
      zbuf=est_lzoencode(vbuf, vsiz, &zsiz);
      if(zbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr$3;
        return_value_dpecodeptr$3=dpecodeptr();
        *return_value_dpecodeptr$3 = 9999;
        return 0;
      }

      return_value_crput$4=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , zbuf, zsiz, dmode);
      if(return_value_crput$4 == 0)
      {
        free((void *)zbuf);
        return 0;
      }

      free((void *)zbuf);
      break;
    }
    case 131072:
    {
      zbuf=est_bzencode(vbuf, vsiz, &zsiz);
      if(zbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr$5;
        return_value_dpecodeptr$5=dpecodeptr();
        *return_value_dpecodeptr$5 = 9999;
        return 0;
      }

      return_value_crput$6=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , zbuf, zsiz, dmode);
      if(return_value_crput$6 == 0)
      {
        free((void *)zbuf);
        return 0;
      }

      free((void *)zbuf);
      break;
    }
    default:
    {
      return_value_crput$7=crput(curia, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, dmode);
      if(return_value_crput$7 == 0)
        return 0;

    }
  }
  return 1;
}

// est_db_add_attr_index
// file estraier.c line 1341
signed int est_db_add_attr_index(struct anonymous *db, const char *name, signed int type)
{
  struct anonymous$16 attridx;
  struct anonymous$6 *scores;
  void *aidxdb;
  char path[4096l];
  char *enc;
  char *vbuf;
  signed int i;
  signed int domode;
  signed int vomode;
  signed int crdnum;
  signed int err;
  signed int snum;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  signed int *return_value_vlcrdnumptr$4;
  struct anonymous$7 *return_value_vlopen$6;
  signed int return_value_est_db_doc_num$9;
  signed int *return_value_vlcrdnumptr$10;
  struct anonymous$7 *return_value_vlopen$12;
  signed int return_value_est_db_doc_num$15;
  signed int return_value_crbnum$17;
  struct anonymous$5 *return_value_dpopen$18;
  signed int return_value_est_db_doc_num$21;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1349);
    return 0;
  }

  else
  {
    const char *return_value_cbmapget$2;
    return_value_cbmapget$2=cbmapget(db->aidxs, name, -1, (signed int *)(void *)0);
    if(!(return_value_cbmapget$2 == ((const char *)NULL)))
    {
      est_set_ecode(&db->ecode, 9999, 1353);
      return 0;
    }

    else
    {
      enc=est_hex_encode(name);
      switch(type)
      {
        case 0:
        {
          sprintf(path, "%s%c%s%s", db->name, 47, (const void *)"__seq_", enc);
          break;
        }
        case 1:
        {
          sprintf(path, "%s%c%s%s", db->name, 47, (const void *)"__str_", enc);
          break;
        }
        case 2:
        {
          sprintf(path, "%s%c%s%s", db->name, 47, (const void *)"__num_", enc);
          break;
        }
        default:
        {
          free((void *)enc);
          est_set_ecode(&db->ecode, 1, 1369);
          return 0;
        }
      }
      free((void *)enc);
      domode = 2 | 4 | 8;
      vomode = 2 | 4 | 8;
      vomode = vomode | 64;
      err = 0;
      signed int *return_value_vlcrdnumptr$3;
      return_value_vlcrdnumptr$3=vlcrdnumptr();
      crdnum = *return_value_vlcrdnumptr$3;
      switch(type)
      {
        case 1:
        {
          return_value_vlcrdnumptr$4=vlcrdnumptr();
          *return_value_vlcrdnumptr$4 = 2;
          return_value_vlopen$6=vlopen(path, vomode, VL_CMPLEX);
          aidxdb = (void *)return_value_vlopen$6;
          if(aidxdb == NULL)
          {
            est_set_ecode(&db->ecode, 4, 1388);
            signed int *return_value_vlcrdnumptr$5;
            return_value_vlcrdnumptr$5=vlcrdnumptr();
            *return_value_vlcrdnumptr$5 = crdnum;
            return 0;
          }

          vlsettuning((struct anonymous$7 *)aidxdb, 99, 120, 1024, 256);
          vlsetfbpsiz((struct anonymous$7 *)aidxdb, 128);
          return_value_est_db_doc_num$9=est_db_doc_num(db);
          if(return_value_est_db_doc_num$9 >= 1)
          {
            scores=est_search_uvset(db, &snum, (struct anonymous$9 *)(void *)0, 1);
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, name);
              if(!(vbuf == ((char *)NULL)))
              {
                unsigned long int return_value_strlen$7;
                return_value_strlen$7=strlen(vbuf);
                signed int return_value_est_aidx_attr_put$8;
                return_value_est_aidx_attr_put$8=est_aidx_attr_put((struct anonymous$7 *)aidxdb, (scores + (signed long int)i)->id, vbuf, (signed int)return_value_strlen$7);
                if(return_value_est_aidx_attr_put$8 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1399);
                  db->fatal = 1;
                  err = 1;
                }

                free((void *)vbuf);
              }

              if(i % 1000 == 0)
                est_db_inform(db, "entering existing attributes");

            }
            free((void *)scores);
          }

          break;
        }
        case 2:
        {
          return_value_vlcrdnumptr$10=vlcrdnumptr();
          *return_value_vlcrdnumptr$10 = 2;
          return_value_vlopen$12=vlopen(path, vomode, est_aidx_numcmp);
          aidxdb = (void *)return_value_vlopen$12;
          if(aidxdb == NULL)
          {
            est_set_ecode(&db->ecode, 4, 1413);
            signed int *return_value_vlcrdnumptr$11;
            return_value_vlcrdnumptr$11=vlcrdnumptr();
            *return_value_vlcrdnumptr$11 = crdnum;
            return 0;
          }

          vlsettuning((struct anonymous$7 *)aidxdb, 99, 120, 1024, 256);
          vlsetfbpsiz((struct anonymous$7 *)aidxdb, 128);
          return_value_est_db_doc_num$15=est_db_doc_num(db);
          if(return_value_est_db_doc_num$15 >= 1)
          {
            scores=est_search_uvset(db, &snum, (struct anonymous$9 *)(void *)0, 1);
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, name);
              if(!(vbuf == ((char *)NULL)))
              {
                unsigned long int return_value_strlen$13;
                return_value_strlen$13=strlen(vbuf);
                signed int return_value_est_aidx_attr_put$14;
                return_value_est_aidx_attr_put$14=est_aidx_attr_put((struct anonymous$7 *)aidxdb, (scores + (signed long int)i)->id, vbuf, (signed int)return_value_strlen$13);
                if(return_value_est_aidx_attr_put$14 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1424);
                  db->fatal = 1;
                  err = 1;
                }

                free((void *)vbuf);
              }

              if(i % 1000 == 0)
                est_db_inform(db, "entering existing attributes");

            }
            free((void *)scores);
          }

          break;
        }
        default:
        {
          return_value_crbnum$17=crbnum(db->attrdb);
          return_value_dpopen$18=dpopen(path, domode, (signed int)((double)return_value_crbnum$17 * 0.8));
          aidxdb = (void *)return_value_dpopen$18;
          if(aidxdb == NULL)
          {
            est_set_ecode(&db->ecode, 4, 1437);
            signed int *return_value_vlcrdnumptr$16;
            return_value_vlcrdnumptr$16=vlcrdnumptr();
            *return_value_vlcrdnumptr$16 = crdnum;
            return 0;
          }

          dpsetfbpsiz((struct anonymous$5 *)aidxdb, 32);
          return_value_est_db_doc_num$21=est_db_doc_num(db);
          if(return_value_est_db_doc_num$21 >= 1)
          {
            scores=est_search_uvset(db, &snum, (struct anonymous$9 *)(void *)0, 1);
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, name);
              if(!(vbuf == ((char *)NULL)))
              {
                unsigned long int return_value_strlen$19;
                return_value_strlen$19=strlen(vbuf);
                signed int return_value_est_aidx_seq_put$20;
                return_value_est_aidx_seq_put$20=est_aidx_seq_put((struct anonymous$5 *)aidxdb, (scores + (signed long int)i)->id, vbuf, (signed int)return_value_strlen$19);
                if(return_value_est_aidx_seq_put$20 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1447);
                  db->fatal = 1;
                  err = 1;
                }

                free((void *)vbuf);
              }

              if(i % 1000 == 0)
                est_db_inform(db, "entering existing attributes");

            }
            free((void *)scores);
          }

        }
      }
      signed int *return_value_vlcrdnumptr$22;
      return_value_vlcrdnumptr$22=vlcrdnumptr();
      *return_value_vlcrdnumptr$22 = crdnum;
      attridx.db = aidxdb;
      attridx.type = type;
      cbmapput(db->aidxs, name, -1, (char *)&attridx, (signed int)sizeof(struct anonymous$16) /*16ul*/ , 0);
      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_add_meta
// file estraier.c line 4525
void est_db_add_meta(struct anonymous *db, const char *name, const char *value)
{
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  if(return_value_dpwritable$1 == 0)
    est_set_ecode(&db->ecode, 2, 4528);

  else
  {
    if(db->metacc == ((struct anonymous$9 *)NULL))
      est_db_prepare_meta(db);

    if(!(value == ((const char *)NULL)))
      cbmapput(db->metacc, name, -1, value, -1, 1);

    else
      cbmapout(db->metacc, name, -1);
  }
}

// est_db_add_pseudo_index
// file estraier.c line 3335
signed int est_db_add_pseudo_index(struct anonymous *db, const char *path)
{
  struct anonymous$1 *files;
  const char *file;
  char pbuf[4096l];
  signed int i;
  signed int len;
  files=cbdirlist(path);
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(files == ((struct anonymous$1 *)NULL))
  {
    est_set_ecode(&db->ecode, 1, 3342);
    return 0;
  }

  else
  {
    cblistsort(files);
    i = 0;
    for( ; !(i >= files->num); i = i + 1)
    {
      file = (const char *)(files->array + (signed long int)(files->start + i))->dptr;
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(file, ".");
      if(return_value_strcmp$1 == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strcmp$2=strcmp(file, "..");
        tmp_if_expr$3 = !(return_value_strcmp$2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$3)
      {
        len=sprintf(pbuf, "%s%c%s", path, 47, file);
        do
        {
          signed int _CB_index = db->pdocs->start + db->pdocs->num;
          if(_CB_index >= db->pdocs->anum)
          {
            db->pdocs->anum = db->pdocs->anum * 2;
            void *return_value_realloc$4;
            return_value_realloc$4=realloc((void *)db->pdocs->array, (unsigned long int)db->pdocs->anum * sizeof(struct anonymous$28) /*16ul*/ );
            db->pdocs->array = (struct anonymous$28 *)return_value_realloc$4;
            if(!(db->pdocs->array == ((struct anonymous$28 *)NULL)))
              db->pdocs->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$5;
          return_value_malloc$5=malloc((unsigned long int)((len < 12 ? 12 : len) + 1));
          (db->pdocs->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$5;
          if(!((db->pdocs->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (db->pdocs->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(db->pdocs->array + (signed long int)_CB_index)->dptr, (const void *)pbuf, (unsigned long int)len);
          (db->pdocs->array + (signed long int)_CB_index)->dptr[(signed long int)len] = (char)0;
          (db->pdocs->array + (signed long int)_CB_index)->dsize = len;
          db->pdocs->num = db->pdocs->num + 1;
        }
        while((_Bool)0);
      }

    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = files->start + files->num;
      _CB_i = files->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(files->array + (signed long int)_CB_i)->dptr);
      free((void *)files->array);
      free((void *)files);
    }
    while((_Bool)0);
    if(!(db->puris == ((struct anonymous$9 *)NULL)))
    {
      cbmapclose(db->puris);
      db->puris = (struct anonymous$9 *)(void *)0;
    }

    return 1;
  }
}

// est_db_attr_index_exprs
// file estraier.c line 5082
struct anonymous$1 * est_db_attr_index_exprs(struct anonymous *db)
{
  struct anonymous$16 *attridx;
  struct anonymous$1 *list;
  const char *kbuf;
  char *expr;
  list=cblistopen();
  cbmapiterinit(db->aidxs);
  do
  {
    kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
    if(kbuf == ((const char *)NULL))
      break;

    const char *return_value_cbmapiterval$1;
    return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
    attridx = (struct anonymous$16 *)return_value_cbmapiterval$1;
    switch(attridx->type)
    {
      case 1:
      {
        expr=cbsprintf("%s=str", kbuf);
        break;
      }
      case 2:
      {
        expr=cbsprintf("%s=num", kbuf);
        break;
      }
      default:
        expr=cbsprintf("%s=seq", kbuf);
    }
    do
    {
      signed int _CB_index = list->start + list->num;
      if(_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
        list->array = (struct anonymous$28 *)return_value_realloc$2;
        if(!(list->array == ((struct anonymous$28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      (list->array + (signed long int)_CB_index)->dptr = expr;
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(expr);
      (list->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen$3;
      list->num = list->num + 1;
    }
    while((_Bool)0);
  }
  while((_Bool)1);
  return list;
}

// est_db_cache_num
// file estraier.c line 4957
signed int est_db_cache_num(struct anonymous *db)
{
  signed int return_value_cbmaprnum$1;
  return_value_cbmaprnum$1=cbmaprnum(db->idxcc);
  return return_value_cbmaprnum$1;
}

// est_db_charge_rescc
// file estraier.c line 5038
void est_db_charge_rescc(struct anonymous *db, signed int max)
{
  struct anonymous$1 *words;
  const char *word;
  const char *vbuf;
  signed int i;
  signed int num;
  signed int size;
  signed int vsiz;
  if(!(max >= 0))
    max = 0x7fffffff;

  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    words = (struct anonymous$1 *)return_value_malloc$1;
    if(!(words == ((struct anonymous$1 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous$28 *)return_value_malloc$2;
    if(!(words->array == ((struct anonymous$28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  cbmapiterinit(db->rescc);
  do
  {
    word=cbmapiternext(db->rescc, &size);
    if(word == ((const char *)NULL))
      break;

    do
    {
      struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(word - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
      vsiz = _CB_datum->vsiz;
      vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
    }
    while((_Bool)0);
    if((unsigned long int)vsiz == sizeof(struct anonymous$6) /*16ul*/ )
    {
      if(((struct anonymous$6 *)vbuf)->id == -1)
        do
        {
          signed int _CB_index = words->start + words->num;
          if(_CB_index >= words->anum)
          {
            words->anum = words->anum * 2;
            void *return_value_realloc$3;
            return_value_realloc$3=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
            words->array = (struct anonymous$28 *)return_value_realloc$3;
            if(!(words->array == ((struct anonymous$28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$4;
          return_value_malloc$4=malloc((unsigned long int)((size < 12 ? 12 : size) + 1));
          (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$4;
          if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (words->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)word, (unsigned long int)size);
          (words->array + (signed long int)_CB_index)->dptr[(signed long int)size] = (char)0;
          (words->array + (signed long int)_CB_index)->dsize = size;
          words->num = words->num + 1;
        }
        while((_Bool)0);

    }

  }
  while((_Bool)1);
  num = (signed int)words->num;
  i = 0;
  for( ; !(i >= num) && !(i >= max); i = i + 1)
  {
    word=cblistval(words, (num - i) - 1, &size);
    struct anonymous$6 *return_value_est_search_union$5;
    return_value_est_search_union$5=est_search_union(db, word, 1, (void (*)(const char *, struct anonymous$1 *))(void *)0, &size, (struct anonymous$9 *)(void *)0, 1, -1, (struct anonymous$9 *)(void *)0);
    free((void *)return_value_est_search_union$5);
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = words->start + words->num;
    _CB_i = words->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(words->array + (signed long int)_CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
}

// est_db_check_option
// file estraier.c line 4432
signed int est_db_check_option(struct anonymous *db, signed int option)
{
  signed int return_value_dpwritable$1;
  signed int return_value_dpwritable$2;
  switch(option)
  {
    case 1:
    {
      return_value_dpwritable$1=dpwritable(db->metadb);
      return (signed int)!(return_value_dpwritable$1 != 0);
    }
    case 2:
    {
      return_value_dpwritable$2=dpwritable(db->metadb);
      return return_value_dpwritable$2;
    }
    case 4:
      return -1;
    case 8:
      return -1;
    case 16:
      return -1;
    case 32:
      return -1;
    case 1024:
      return (signed int)(db->amode == 1024);
    case 2048:
      return (signed int)(db->amode == 2048);
    case 1048576:
      return -1;
    case 2097152:
      return -1;
    case 4194304:
      return -1;
    case 8388608:
      return -1;
    case 16777216:
      return -1;
    case 33554432:
      return (signed int)(db->smode == 1048576);
    case 67108864:
      return (signed int)(db->smode == 2097152);
    case 134217728:
      return (signed int)(db->smode == 4194304);
    default:
      return -1;
  }
}

// est_db_close
// file estraier.c line 1263
signed int est_db_close(struct anonymous *db, signed int *ecp)
{
  struct anonymous$16 *attridx;
  const char *kbuf;
  signed int err;
  est_set_ecode(ecp, 0, 1268);
  err = 0;
  cbmapout(est_inodes, (char *)&db->inode, (signed int)sizeof(signed int) /*4ul*/ );
  signed int return_value_dpwritable$3;
  return_value_dpwritable$3=dpwritable(db->metadb);
  if(!(return_value_dpwritable$3 == 0))
  {
    signed int return_value_est_db_flush$1;
    return_value_est_db_flush$1=est_db_flush(db, -1);
    if(return_value_est_db_flush$1 == 0)
      err = 1;

    signed int return_value_est_db_write_meta$2;
    return_value_est_db_write_meta$2=est_db_write_meta(db);
    if(return_value_est_db_write_meta$2 == 0)
      err = 1;

  }

  est_db_inform(db, "closing");
  if(!(db->metacc == ((struct anonymous$9 *)NULL)))
    cbmapclose(db->metacc);

  if(!(db->spacc == ((struct anonymous$9 *)NULL)))
  {
    free((void *)db->scname);
    cbmapclose(db->spacc);
  }

  cbmapclose(db->rescc);
  cbmapclose(db->veccc);
  cbmapclose(db->textcc);
  cbmapclose(db->attrcc);
  cbmapclose(db->keycc);
  cbmapclose(db->outcc);
  cbmapclose(db->auxcc);
  cbmapclose(db->idxcc);
  if(!(db->puris == ((struct anonymous$9 *)NULL)))
    cbmapclose(db->puris);

  do
  {
    signed int _CB_i;
    signed int _CB_end = db->pdocs->start + db->pdocs->num;
    _CB_i = db->pdocs->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(db->pdocs->array + (signed long int)_CB_i)->dptr);
    free((void *)db->pdocs->array);
    free((void *)db->pdocs);
  }
  while((_Bool)0);
  cbmapiterinit(db->aidxs);
  signed int return_value_vlclose$5;
  do
  {
    kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
    if(kbuf == ((const char *)NULL))
      break;

    const char *return_value_cbmapiterval$4;
    return_value_cbmapiterval$4=cbmapiterval(kbuf, (signed int *)(void *)0);
    attridx = (struct anonymous$16 *)return_value_cbmapiterval$4;
    if(attridx->type == 1 || attridx->type == 2)
    {
      return_value_vlclose$5=vlclose((struct anonymous$7 *)attridx->db);
      if(return_value_vlclose$5 == 0)
        err = 1;

      goto __CPROVER_DUMP_L14;
    }

    signed int return_value_dpclose$6;
    return_value_dpclose$6=dpclose((struct anonymous$5 *)attridx->db);
    if(return_value_dpclose$6 == 0)
      err = 1;


  __CPROVER_DUMP_L14:
    ;
  }
  while((_Bool)1);
  cbmapclose(db->aidxs);
  signed int return_value_vlclose$7;
  return_value_vlclose$7=vlclose(db->listdb);
  if(return_value_vlclose$7 == 0)
    err = 1;

  signed int return_value_crclose$8;
  return_value_crclose$8=crclose(db->kwddb);
  if(return_value_crclose$8 == 0)
    err = 1;

  signed int return_value_crclose$9;
  return_value_crclose$9=crclose(db->textdb);
  if(return_value_crclose$9 == 0)
    err = 1;

  signed int return_value_crclose$10;
  return_value_crclose$10=crclose(db->attrdb);
  if(return_value_crclose$10 == 0)
    err = 1;

  signed int return_value_vlclose$11;
  return_value_vlclose$11=vlclose(db->xfmdb);
  if(return_value_vlclose$11 == 0)
    err = 1;

  signed int return_value_vlclose$12;
  return_value_vlclose$12=vlclose(db->auxdb);
  if(return_value_vlclose$12 == 0)
    err = 1;

  signed int return_value_vlclose$13;
  return_value_vlclose$13=vlclose(db->fwmdb);
  if(return_value_vlclose$13 == 0)
    err = 1;

  signed int return_value_est_idx_close$14;
  return_value_est_idx_close$14=est_idx_close(db->idxdb);
  if(return_value_est_idx_close$14 == 0)
    err = 1;

  signed int return_value_dpclose$15;
  return_value_dpclose$15=dpclose(db->metadb);
  if(return_value_dpclose$15 == 0)
    err = 1;

  free((void *)db->name);
  if(!(db->fatal == 0))
  {
    est_set_ecode(ecp, db->ecode, 1316);
    err = 1;
  }

  else
    if(!(err == 0))
      est_set_ecode(ecp, 4, 1319);

  free((void *)db);
  return err != 0 ? 0 : 1;
}

// est_db_doc_num
// file estraier.c line 2702
signed int est_db_doc_num(struct anonymous *db)
{
  return db->dnum;
}

// est_db_edit_doc
// file estraier.c line 2431
signed int est_db_edit_doc(struct anonymous *db, struct anonymous$0 *doc)
{
  struct anonymous$0 *odoc;
  struct anonymous$16 *attridx;
  const char *uri;
  const char *tmp;
  const char *kbuf;
  const char *vbuf;
  char *ouri;
  char numbuf[32l];
  char *text;
  char *sbuf;
  signed int err;
  signed int id;
  signed int oid;
  signed int ksiz;
  signed int vsiz;
  signed int ssiz;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  signed int return_value_vlput$6;
  signed int return_value_est_aidx_attr_out$9;
  signed int return_value_est_aidx_attr_put$12;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 2439);
    return 0;
  }

  else
  {
    id = -1;
    uri = (const char *)(void *)0;
    if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
    {
      tmp=cbmapget(doc->attrs, "@id", -1, (signed int *)(void *)0);
      if(!(tmp == ((const char *)NULL)))
        id=atoi(tmp);

      tmp=cbmapget(doc->attrs, "@uri", -1, (signed int *)(void *)0);
      if(!(tmp == ((const char *)NULL)))
        uri = tmp;

    }

    if(id >= 2000000001 || !(id >= 1))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(doc->id >= 1)
        tmp_if_expr$2 = doc->id != id ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(uri == ((const char *)NULL) || tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      est_set_ecode(&db->ecode, 1, 2449);
      return 0;
    }

    else
    {
      err = 0;
      oid=est_db_uri_to_id(db, uri);
      if(oid == -1)
      {
        ouri=est_db_get_doc_attr(db, id, "@uri");
        if(ouri == ((char *)NULL))
        {
          est_set_ecode(&db->ecode, 1, 2455);
          return 0;
        }

        sprintf(numbuf, "%d", id);
        signed int return_value_vlout$5;
        return_value_vlout$5=vlout(db->listdb, ouri, -1);
        if(return_value_vlout$5 == 0)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_vlput$6=vlput(db->listdb, uri, -1, numbuf, -1, 1);
          tmp_if_expr$7 = !(return_value_vlput$6 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
          err = 1;

        free((void *)ouri);
      }

      else
        if(!(oid == id))
        {
          est_set_ecode(&db->ecode, 1, 2463);
          return 0;
        }

      doc->id = id;
      signed int return_value_cbmaprnum$14;
      return_value_cbmaprnum$14=cbmaprnum(db->aidxs);
      if(return_value_cbmaprnum$14 >= 1)
      {
        odoc=est_db_get_doc(db, id, 2);
        if(!(odoc == ((struct anonymous$0 *)NULL)))
        {
          if(odoc->attrs == ((struct anonymous$9 *)NULL))
            odoc->attrs=cbmapopenex(31);

          cbmapiterinit(db->aidxs);
          do
          {
            kbuf=cbmapiternext(db->aidxs, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            vbuf=cbmapget(odoc->attrs, kbuf, ksiz, &vsiz);
            if(!(vbuf == ((const char *)NULL)))
            {
              const char *return_value_cbmapiterval$8;
              return_value_cbmapiterval$8=cbmapiterval(kbuf, (signed int *)(void *)0);
              attridx = (struct anonymous$16 *)return_value_cbmapiterval$8;
              if(attridx->type == 1 || attridx->type == 2)
              {
                return_value_est_aidx_attr_out$9=est_aidx_attr_out((struct anonymous$7 *)attridx->db, id, vbuf, vsiz);
                if(return_value_est_aidx_attr_out$9 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 2477);
                  db->fatal = 1;
                  err = 1;
                }

                goto __CPROVER_DUMP_L23;
              }

              signed int return_value_est_aidx_seq_out$10;
              return_value_est_aidx_seq_out$10=est_aidx_seq_out((struct anonymous$5 *)attridx->db, id);
              if(return_value_est_aidx_seq_out$10 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2484);
                db->fatal = 1;
                err = 1;
              }

            }


          __CPROVER_DUMP_L23:
            ;
          }
          while((_Bool)1);
          cbmapiterinit(db->aidxs);
          do
          {
            kbuf=cbmapiternext(db->aidxs, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
            if(!(vbuf == ((const char *)NULL)))
            {
              const char *return_value_cbmapiterval$11;
              return_value_cbmapiterval$11=cbmapiterval(kbuf, (signed int *)(void *)0);
              attridx = (struct anonymous$16 *)return_value_cbmapiterval$11;
              if(attridx->type == 1 || attridx->type == 2)
              {
                return_value_est_aidx_attr_put$12=est_aidx_attr_put((struct anonymous$7 *)attridx->db, id, vbuf, vsiz);
                if(return_value_est_aidx_attr_put$12 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 2499);
                  db->fatal = 1;
                  err = 1;
                }

                goto __CPROVER_DUMP_L31;
              }

              signed int return_value_est_aidx_seq_put$13;
              return_value_est_aidx_seq_put$13=est_aidx_seq_put((struct anonymous$5 *)attridx->db, id, vbuf, vsiz);
              if(return_value_est_aidx_seq_put$13 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2506);
                db->fatal = 1;
                err = 1;
              }

            }


          __CPROVER_DUMP_L31:
            ;
          }
          while((_Bool)1);
          est_doc_delete(odoc);
        }

      }

      text=est_db_get_doc_attr(db, id, "");
      if(!(text == ((char *)NULL)))
      {
        cbmapput(doc->attrs, "", 0, text, -1, 1);
        free((void *)text);
      }

      sbuf=cbmapdump(doc->attrs, &ssiz);
      signed int return_value_est_crput$15;
      return_value_est_crput$15=est_crput(db->attrdb, db->zmode, id, sbuf, ssiz, 0);
      if(return_value_est_crput$15 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2521);
        db->fatal = 1;
        err = 1;
      }

      free((void *)sbuf);
      cbmapout(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
      if(!(db->spacc == ((struct anonymous$9 *)NULL)))
        cbmapout(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );

      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_error
// file estraier.c line 1327
signed int est_db_error(struct anonymous *db)
{
  return db->ecode;
}

// est_db_etch_doc
// file estraier.c line 4560
struct anonymous$9 * est_db_etch_doc(struct anonymous *db, struct anonymous$0 *doc, signed int max)
{
  struct anonymous$31 *scores;
  struct anonymous$9 *keys;
  struct anonymous$9 *umap;
  struct anonymous$1 *words;
  const char *text;
  const char *word;
  const char *vbuf;
  const unsigned char *uword;
  char numbuf[32l];
  signed int i;
  signed int wsiz;
  signed int num;
  signed int smax;
  signed int snum;
  signed int vsiz;
  struct anonymous$9 *return_value_cbmapopenex$1;
  _Bool tmp_if_expr$4;
  signed int tmp_if_expr$5;
  const char *return_value_cbmapiternext$8;
  signed int tmp_if_expr$9;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$24;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$26;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$30;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$31;
  _Bool tmp_if_expr$34;
  _Bool tmp_if_expr$33;
  signed int return_value_cbmaprnum$38;
  _Bool tmp_if_expr$37;
  signed int tmp_if_expr$39;
  if(doc->dtexts == ((struct anonymous$1 *)NULL))
  {
    return_value_cbmapopenex$1=cbmapopenex(1);
    return return_value_cbmapopenex$1;
  }

  else
  {
    keys=cbmapopenex(max * 2 + 1);
    do
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct anonymous$1) /*24ul*/ );
      words = (struct anonymous$1 *)return_value_malloc$2;
      if(!(words == ((struct anonymous$1 *)NULL)))
        words;

      else
        cbmyfatal("out of memory");
      words->anum = 64;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
      words->array = (struct anonymous$28 *)return_value_malloc$3;
      if(!(words->array == ((struct anonymous$28 *)NULL)))
        words->array;

      else
        cbmyfatal("out of memory");
      words->start = 0;
      words->num = 0;
    }
    while((_Bool)0);
    i = -1;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      if(!(i >= 0))
      {
        if(doc->attrs == ((struct anonymous$9 *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          tmp_if_expr$4 = !(text != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          goto __CPROVER_DUMP_L17;

      }

      else
        text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      if(!(db == ((struct anonymous *)NULL)))
        switch(db->amode)
        {
          case 1024:
          {
            est_break_text_perfng(text, words, 0, 0);
            break;
          }
          case 2048:
          {
            est_break_text_chrcat(text, words, 0);
            break;
          }
          default:
            est_break_text(text, words, 0, 0);
        }

      else
        est_break_text(text, words, 0, 0);

    __CPROVER_DUMP_L17:
      ;
    }
    umap=cbmapopenex((signed int)words->num + 1);
    i = 0;
    for( ; !(i >= words->num); i = i + 1)
    {
      wsiz = (words->array + (signed long int)(words->start + i))->dsize;
      word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
      if(!(wsiz >= 49))
      {
        vbuf=cbmapget(umap, word, wsiz, (signed int *)(void *)0);
        if(!(vbuf == ((const char *)NULL)))
          tmp_if_expr$5 = *((signed int *)vbuf) + 1;

        else
          tmp_if_expr$5 = 1;
        num = tmp_if_expr$5;
        cbmapput(umap, word, wsiz, (char *)&num, (signed int)sizeof(signed int) /*4ul*/ , 1);
      }

    }
    signed int return_value_cbmaprnum$6;
    return_value_cbmaprnum$6=cbmaprnum(umap);
    void *return_value_malloc$7;
    return_value_malloc$7=malloc((unsigned long int)return_value_cbmaprnum$6 * sizeof(struct anonymous$31) /*16ul*/  + (unsigned long int)1);
    scores = (struct anonymous$31 *)return_value_malloc$7;
    if(!(scores == ((struct anonymous$31 *)NULL)))
      scores;

    else
      cbmyfatal("out of memory");
    snum = 0;
    cbmapiterinit(umap);
    do
    {
      return_value_cbmapiternext$8=cbmapiternext(umap, &wsiz);
      uword = (unsigned char *)return_value_cbmapiternext$8;
      if(uword == ((const unsigned char *)NULL))
        break;

      (scores + (signed long int)snum)->word = (char *)uword;
      (scores + (signed long int)snum)->wsiz = wsiz;
      vbuf=cbmapiterval((char *)uword, (signed int *)(void *)0);
      if(!(vbuf == ((const char *)NULL)))
        tmp_if_expr$9 = *((signed int *)vbuf);

      else
        tmp_if_expr$9 = 0;
      (scores + (signed long int)snum)->pt = tmp_if_expr$9;
      if((signed int)*uword >= 0xe3)
      {
        if(!(wsiz >= 4))
        {
          (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;
          if((signed int)*uword == 0xe3)
          {
            if((signed int)uword[1l] == 0x80)
              tmp_if_expr$10 = (_Bool)1;

            else
              tmp_if_expr$10 = (signed int)uword[(signed long int)1] == 0x81 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$10)
              tmp_if_expr$12 = (_Bool)1;

            else
            {
              if((signed int)uword[1l] == 0x82)
                tmp_if_expr$11 = (signed int)uword[(signed long int)2] <= 0x9f ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$11 = (_Bool)0;
              tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr$13 = tmp_if_expr$12 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
            tmp_if_expr$15 = (_Bool)1;

          else
          {
            if((signed int)*uword == 0xef)
              tmp_if_expr$14 = (signed int)uword[(signed long int)1] >= 0xbc ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$14 = (_Bool)0;
            tmp_if_expr$15 = tmp_if_expr$14 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$15)
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

        }

        else
        {
          if((signed int)*uword == 0xe3)
          {
            if((signed int)uword[1l] == 0x80)
              tmp_if_expr$16 = (_Bool)1;

            else
              tmp_if_expr$16 = (signed int)uword[(signed long int)1] == 0x81 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$16)
              tmp_if_expr$18 = (_Bool)1;

            else
            {
              if((signed int)uword[1l] == 0x82)
                tmp_if_expr$17 = (signed int)uword[(signed long int)2] <= 0x9f ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$17 = (_Bool)0;
              tmp_if_expr$18 = tmp_if_expr$17 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr$19 = tmp_if_expr$18 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$19 = (_Bool)0;
          if(tmp_if_expr$19)
            tmp_if_expr$21 = (_Bool)1;

          else
          {
            if((signed int)*uword == 0xef)
              tmp_if_expr$20 = (signed int)uword[(signed long int)1] >= 0xbc ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$20 = (_Bool)0;
            tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$21)
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

          if((signed int)uword[3l] == 0xe3)
          {
            if((signed int)uword[4l] == 0x80)
              tmp_if_expr$22 = (_Bool)1;

            else
              tmp_if_expr$22 = (signed int)uword[(signed long int)4] == 0x81 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$22)
              tmp_if_expr$24 = (_Bool)1;

            else
            {
              if((signed int)uword[4l] == 0x82)
                tmp_if_expr$23 = (signed int)uword[(signed long int)5] <= 0x9f ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$23 = (_Bool)0;
              tmp_if_expr$24 = tmp_if_expr$23 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr$25 = tmp_if_expr$24 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$25 = (_Bool)0;
          if(tmp_if_expr$25)
            tmp_if_expr$27 = (_Bool)1;

          else
          {
            if((signed int)uword[3l] == 0xef)
              tmp_if_expr$26 = (signed int)uword[(signed long int)4] >= 0xbc ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$26 = (_Bool)0;
            tmp_if_expr$27 = tmp_if_expr$26 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$27)
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

        }
      }

      else
      {
        if((signed int)*uword >= 1)
          tmp_if_expr$28 = (signed int)uword[(signed long int)0] <= 47 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$28 = (_Bool)0;
        if(tmp_if_expr$28)
          tmp_if_expr$30 = (_Bool)1;

        else
        {
          if((signed int)*uword >= 58)
            tmp_if_expr$29 = (signed int)uword[(signed long int)0] <= 64 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$29 = (_Bool)0;
          tmp_if_expr$30 = tmp_if_expr$29 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$30)
          tmp_if_expr$32 = (_Bool)1;

        else
        {
          if((signed int)*uword >= 91)
            tmp_if_expr$31 = (signed int)uword[(signed long int)0] <= 96 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$31 = (_Bool)0;
          tmp_if_expr$32 = tmp_if_expr$31 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$32)
          tmp_if_expr$34 = (_Bool)1;

        else
        {
          if((signed int)*uword >= 123)
            tmp_if_expr$33 = (signed int)uword[(signed long int)0] <= 126 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$33 = (_Bool)0;
          tmp_if_expr$34 = tmp_if_expr$33 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$34)
        {
          (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 25;
          if(!(wsiz >= 2))
            (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;

        }

        else
          switch(wsiz)
          {
            case 1:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 9;
              break;
            }
            case 2:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 5;
              break;
            }
            case 3:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 3;
              break;
            }
            case 4:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / 2;
              break;
            }
            case 5:
            {
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / (signed int)1.5;
              break;
            }
            case 6:
              (scores + (signed long int)snum)->pt = (scores + (signed long int)snum)->pt / (signed int)1.25;
          }
      }
      snum = snum + 1;
    }
    while((_Bool)1);
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$31) /*16ul*/ , est_keysc_compare);
    smax = max * (db != ((struct anonymous *)NULL) ? 3 : 1) + 1;
    snum = snum > smax ? smax : snum;
    if(!(db == ((struct anonymous *)NULL)))
    {
      i = 0;
      for( ; !(i >= snum); i = i + 1)
      {
        vbuf=cbmapget(db->keycc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, (signed int *)(void *)0);
        if(!(vbuf == ((const char *)NULL)))
        {
          cbmapmove(db->keycc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, 0);
          vsiz = *((signed int *)vbuf);
        }

        else
        {
          if(!(db->dfdb == ((struct anonymous$5 *)NULL)))
          {
            vsiz=dpgetwb(db->dfdb, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, 0, 32 - 1, numbuf);
            if(vsiz >= 1)
            {
              numbuf[(signed long int)vsiz] = (char)0;
              vsiz=atoi(numbuf);
            }

            else
              vsiz = 0;
          }

          else
          {
            vsiz=est_idx_vsiz(db->idxdb, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz);
            const char *return_value_cbmapget$35;
            return_value_cbmapget$35=cbmapget(db->idxcc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, &num);
            if(!(return_value_cbmapget$35 == ((const char *)NULL)))
              vsiz = vsiz + num;

          }
          cbmapput(db->keycc, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, (char *)&vsiz, (signed int)sizeof(signed int) /*4ul*/ , 0);
        }
        double return_value_pow$36;
        return_value_pow$36=pow((double)(vsiz + 64), 0.6);
        (scores + (signed long int)i)->pt = (scores + (signed long int)i)->pt * (signed int)(100000.0 / return_value_pow$36);
      }
      if(db->kcmnum >= 0)
      {
        return_value_cbmaprnum$38=cbmaprnum(db->keycc);
        if(!(db->kcmnum >= return_value_cbmaprnum$38))
        {
          num = (signed int)((double)db->kcmnum * 0.1 + (double)1);
          cbmapiterinit(db->keycc);
          i = 0;
          do
          {
            if(!(i >= num))
            {
              word=cbmapiternext(db->keycc, &wsiz);
              tmp_if_expr$37 = word != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$37 = (_Bool)0;
            if(!tmp_if_expr$37)
              break;

            cbmapout(db->keycc, word, wsiz);
            i = i + 1;
          }
          while((_Bool)1);
        }

      }

      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$31) /*16ul*/ , est_keysc_compare);
    }

    i = 0;
    for( ; !(i >= snum) && !(i >= max); i = i + 1)
    {
      if((scores + (signed long int)i)->pt >= 1)
        tmp_if_expr$39 = (scores + (signed long int)i)->pt;

      else
        tmp_if_expr$39 = 1;
      vsiz=sprintf(numbuf, "%d", tmp_if_expr$39);
      cbmapput(keys, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, numbuf, vsiz, 0);
    }
    free((void *)scores);
    cbmapclose(umap);
    do
    {
      signed int _CB_i;
      signed int _CB_end = words->start + words->num;
      _CB_i = words->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(words->array + (signed long int)_CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    return keys;
  }
}

// est_db_fatal
// file estraier.c line 1334
signed int est_db_fatal(struct anonymous *db)
{
  return db->fatal;
}

// est_db_fill_key_cache
// file estraier.c line 4994
void est_db_fill_key_cache(struct anonymous *db)
{
  const char *kbuf;
  char *msg;
  signed int i;
  signed int ksiz;
  signed int vsiz;
  vlcurfirst(db->fwmdb);
  i = 0;
  do
  {
    kbuf=vlcurkeycache(db->fwmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    vsiz=est_idx_vsiz(db->idxdb, kbuf, ksiz);
    cbmapput(db->keycc, kbuf, ksiz, (char *)&vsiz, (signed int)sizeof(signed int) /*4ul*/ , 1);
    vlcurnext(db->fwmdb);
    if(i % 10000 == 0)
    {
      msg=cbsprintf("filling the key cache for TF-IDF (%d)", i + 1);
      est_db_inform(db, msg);
      free((void *)msg);
    }

    i = i + 1;
  }
  while((_Bool)1);
  db->kcmnum = -1;
}

// est_db_flush
// file estraier.c line 1468
signed int est_db_flush(struct anonymous *db, signed int max)
{
  struct anonymous$16 *attridx;
  struct anonymous$9 *ids;
  struct anonymous$1 *keys;
  struct anonymous$2 *nval;
  const char *kbuf;
  const char *vbuf;
  const char *rp;
  const char *pv;
  const char *ep;
  char *tbuf;
  char *wp;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int inc;
  signed int err;
  signed int ksiz;
  signed int vsiz;
  signed int rnum;
  signed int len;
  signed int id;
  signed int sum;
  signed int cid;
  signed int vnum;
  signed int lid;
  signed int dnum;
  signed int tsiz;
  signed int vstep;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  signed int return_value_vlmemflush$9;
  signed int return_value_cbmaprnum$12;
  signed int return_value_cbmaprnum$11;
  _Bool tmp_if_expr$23;
  signed int return_value_vlput$20;
  _Bool tmp_if_expr$22;
  signed int *return_value_dpecodeptr$21;
  signed int return_value_cbmaprnum$55;
  signed int *return_value_dpecodeptr$43;
  signed int return_value_vlout$52;
  signed int *return_value_dpecodeptr$51;
  _Bool tmp_if_expr$57;
  signed int return_value_est_idx_size_current$56;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1478);
    return 0;
  }

  else
  {
    if(max >= 0x7fffffff || !(max >= 1))
    {
      signed int return_value_est_db_write_meta$2;
      return_value_est_db_write_meta$2=est_db_write_meta(db);
      if(return_value_est_db_write_meta$2 == 0)
        err = 1;

      signed int return_value_dpmemflush$3;
      return_value_dpmemflush$3=dpmemflush(db->metadb);
      if(return_value_dpmemflush$3 == 0)
        err = 1;

      signed int return_value_crmemflush$4;
      return_value_crmemflush$4=crmemflush(db->attrdb);
      if(return_value_crmemflush$4 == 0)
        err = 1;

      signed int return_value_crmemflush$5;
      return_value_crmemflush$5=crmemflush(db->textdb);
      if(return_value_crmemflush$5 == 0)
        err = 1;

      signed int return_value_crmemflush$6;
      return_value_crmemflush$6=crmemflush(db->kwddb);
      if(return_value_crmemflush$6 == 0)
        err = 1;

      signed int return_value_vlmemflush$7;
      return_value_vlmemflush$7=vlmemflush(db->listdb);
      if(return_value_vlmemflush$7 == 0)
        err = 1;

      cbmapiterinit(db->aidxs);
      do
      {
        kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
        if(kbuf == ((const char *)NULL))
          break;

        const char *return_value_cbmapiterval$8;
        return_value_cbmapiterval$8=cbmapiterval(kbuf, (signed int *)(void *)0);
        attridx = (struct anonymous$16 *)return_value_cbmapiterval$8;
        if(attridx->type == 1 || attridx->type == 2)
        {
          return_value_vlmemflush$9=vlmemflush((struct anonymous$7 *)attridx->db);
          if(return_value_vlmemflush$9 == 0)
            err = 1;

          goto __CPROVER_DUMP_L13;
        }

        signed int return_value_dpmemflush$10;
        return_value_dpmemflush$10=dpmemflush((struct anonymous$5 *)attridx->db);
        if(return_value_dpmemflush$10 == 0)
          err = 1;


      __CPROVER_DUMP_L13:
        ;
      }
      while((_Bool)1);
    }

    signed int return_value_cbmaprnum$13;
    return_value_cbmaprnum$13=cbmaprnum(db->idxcc);
    if(!(return_value_cbmaprnum$13 >= 1))
    {
      return_value_cbmaprnum$12=cbmaprnum(db->auxcc);
      if(return_value_cbmaprnum$12 >= 1)
        goto __CPROVER_DUMP_L16;

      return_value_cbmaprnum$11=cbmaprnum(db->outcc);
      if(return_value_cbmaprnum$11 >= 1)
        goto __CPROVER_DUMP_L16;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      db->flsflag = 1;
      db->intflag = 0;
      signed int return_value_est_db_used_cache_size$14;
      return_value_est_db_used_cache_size$14=est_db_used_cache_size(db);
      inc = (signed int)((unsigned long int)return_value_est_db_used_cache_size$14 > db->icmax);
      err = 0;
      do
      {
        void *return_value_malloc$15;
        return_value_malloc$15=malloc(sizeof(struct anonymous$1) /*24ul*/ );
        keys = (struct anonymous$1 *)return_value_malloc$15;
        if(!(keys == ((struct anonymous$1 *)NULL)))
          keys;

        else
          cbmyfatal("out of memory");
        keys->anum = 64;
        void *return_value_malloc$16;
        return_value_malloc$16=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)keys->anum);
        keys->array = (struct anonymous$28 *)return_value_malloc$16;
        if(!(keys->array == ((struct anonymous$28 *)NULL)))
          keys->array;

        else
          cbmyfatal("out of memory");
        keys->start = 0;
        keys->num = 0;
      }
      while((_Bool)0);
      cbmapiterinit(db->idxcc);
      do
      {
        kbuf=cbmapiternext(db->idxcc, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        do
        {
          signed int _CB_index = keys->start + keys->num;
          if(_CB_index >= keys->anum)
          {
            keys->anum = keys->anum * 2;
            void *return_value_realloc$17;
            return_value_realloc$17=realloc((void *)keys->array, (unsigned long int)keys->anum * sizeof(struct anonymous$28) /*16ul*/ );
            keys->array = (struct anonymous$28 *)return_value_realloc$17;
            if(!(keys->array == ((struct anonymous$28 *)NULL)))
              keys->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$18;
          return_value_malloc$18=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (keys->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$18;
          if(!((keys->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (keys->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(keys->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (keys->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (keys->array + (signed long int)_CB_index)->dsize = ksiz;
          keys->num = keys->num + 1;
        }
        while((_Bool)0);
      }
      while((_Bool)1);
      rnum = (signed int)keys->num;
      cblistsort(keys);
      if(max >= 1)
        while(!(max >= keys->num))
          do
            if(keys->num >= 1)
            {
              free((void *)(keys->array + (signed long int)((keys->start + keys->num) - 1))->dptr);
              keys->num = keys->num - 1;
            }

          while((_Bool)0);

      i = 0;
      for( ; !(i >= keys->num); i = i + 1)
      {
        ksiz = (keys->array + (signed long int)(keys->start + i))->dsize;
        kbuf = (const char *)(keys->array + (signed long int)(keys->start + i))->dptr;
        vbuf=cbmapget(db->idxcc, kbuf, ksiz, &vsiz);
        signed int return_value_est_idx_add$19;
        return_value_est_idx_add$19=est_idx_add(db->idxdb, kbuf, ksiz, vbuf, vsiz, db->smode);
        if(return_value_est_idx_add$19 == 0)
          tmp_if_expr$23 = (_Bool)1;

        else
        {
          return_value_vlput$20=vlput(db->fwmdb, kbuf, ksiz, "", 0, 1);
          if(return_value_vlput$20 == 0)
          {
            return_value_dpecodeptr$21=dpecodeptr();
            tmp_if_expr$22 = *return_value_dpecodeptr$21 != 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$22 = (_Bool)0;
          tmp_if_expr$23 = tmp_if_expr$22 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$23)
        {
          err = 1;
          break;
        }

        cbmapout(db->idxcc, kbuf, ksiz);
        db->icsiz = db->icsiz - (unsigned long int)vsiz;
        if(i % 10000 == 0)
        {
          est_db_inform(db, "flushing index words");
          signed int return_value_est_idx_size_current$24;
          return_value_est_idx_size_current$24=est_idx_size_current(db->idxdb);
          if(return_value_est_idx_size_current$24 >= 1536)
          {
            est_db_inform(db, "adding a new database file");
            est_idx_increment(db->idxdb);
            inc = 0;
          }

        }

        if(max >= 1)
        {
          if(!(db->intflag == 0))
          {
            if(i >= 1)
            {
              if(i % 256 == 0)
                break;

            }

          }

        }

      }
      do
      {
        signed int _CB_i;
        signed int _CB_end = keys->start + keys->num;
        _CB_i = keys->start;
        for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
          free((void *)(keys->array + (signed long int)_CB_i)->dptr);
        free((void *)keys->array);
        free((void *)keys);
      }
      while((_Bool)0);
      signed int return_value_cbmaprnum$34;
      return_value_cbmaprnum$34=cbmaprnum(db->idxcc);
      if(!(return_value_cbmaprnum$34 >= 1))
      {
        cbmapclose(db->idxcc);
        db->idxcc=cbmapopenex((signed int)(rnum > 524288 ? (double)rnum * 1.5 : (double)524288));
        signed int return_value_cbmaprnum$33;
        return_value_cbmaprnum$33=cbmaprnum(db->auxcc);
        if(return_value_cbmaprnum$33 >= 1)
        {
          do
          {
            void *return_value_malloc$25;
            return_value_malloc$25=malloc(sizeof(struct anonymous$1) /*24ul*/ );
            keys = (struct anonymous$1 *)return_value_malloc$25;
            if(!(keys == ((struct anonymous$1 *)NULL)))
              keys;

            else
              cbmyfatal("out of memory");
            keys->anum = 64;
            void *return_value_malloc$26;
            return_value_malloc$26=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)keys->anum);
            keys->array = (struct anonymous$28 *)return_value_malloc$26;
            if(!(keys->array == ((struct anonymous$28 *)NULL)))
              keys->array;

            else
              cbmyfatal("out of memory");
            keys->start = 0;
            keys->num = 0;
          }
          while((_Bool)0);
          cbmapiterinit(db->auxcc);
          do
          {
            kbuf=cbmapiternext(db->auxcc, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              signed int est_db_flush$$1$$8$$1$$2$$1$$_CB_index = keys->start + keys->num;
              if(est_db_flush$$1$$8$$1$$2$$1$$_CB_index >= keys->anum)
              {
                keys->anum = keys->anum * 2;
                void *return_value_realloc$27;
                return_value_realloc$27=realloc((void *)keys->array, (unsigned long int)keys->anum * sizeof(struct anonymous$28) /*16ul*/ );
                keys->array = (struct anonymous$28 *)return_value_realloc$27;
                if(!(keys->array == ((struct anonymous$28 *)NULL)))
                  keys->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc$28;
              return_value_malloc$28=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
              (keys->array + (signed long int)est_db_flush$$1$$8$$1$$2$$1$$_CB_index)->dptr = (char *)return_value_malloc$28;
              if(!((keys->array + (signed long int)est_db_flush$$1$$8$$1$$2$$1$$_CB_index)->dptr == ((char *)NULL)))
                (keys->array + (signed long int)est_db_flush$$1$$8$$1$$2$$1$$_CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(keys->array + (signed long int)est_db_flush$$1$$8$$1$$2$$1$$_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
              (keys->array + (signed long int)est_db_flush$$1$$8$$1$$2$$1$$_CB_index)->dptr[(signed long int)ksiz] = (char)0;
              (keys->array + (signed long int)est_db_flush$$1$$8$$1$$2$$1$$_CB_index)->dsize = ksiz;
              keys->num = keys->num + 1;
            }
            while((_Bool)0);
          }
          while((_Bool)1);
          cblistsort(keys);
          i = 0;
          for( ; !(i >= keys->num); i = i + 1)
          {
            ksiz = (keys->array + (signed long int)(keys->start + i))->dsize;
            kbuf = (const char *)(keys->array + (signed long int)(keys->start + i))->dptr;
            vbuf=cbmapget(db->auxcc, kbuf, ksiz, &vsiz);
            signed int return_value_vlput$29;
            return_value_vlput$29=vlput(db->auxdb, kbuf, ksiz, vbuf, vsiz, 2);
            if(return_value_vlput$29 == 0)
            {
              err = 1;
              break;
            }

            signed int return_value_vlvsiz$30;
            return_value_vlvsiz$30=vlvsiz(db->auxdb, kbuf, ksiz);
            len=sprintf(numbuf, "%d", return_value_vlvsiz$30 / (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2));
            signed int return_value_vlput$31;
            return_value_vlput$31=vlput(db->xfmdb, kbuf, ksiz, numbuf, len, 0);
            if(return_value_vlput$31 == 0)
            {
              err = 1;
              break;
            }

            cbmapout(db->auxcc, kbuf, ksiz);
            db->icsiz = db->icsiz - (unsigned long int)vsiz;
            if(i % 10000 == 0)
              est_db_inform(db, "flushing auxiliary keywords");

            if(max >= 1)
            {
              if(!(db->intflag == 0))
              {
                if(i >= 1)
                {
                  if(i % 256 == 0)
                    break;

                }

              }

            }

          }
          do
          {
            signed int est_db_flush$$1$$8$$1$$4$$_CB_i;
            signed int est_db_flush$$1$$8$$1$$4$$_CB_end = keys->start + keys->num;
            est_db_flush$$1$$8$$1$$4$$_CB_i = keys->start;
            for( ; !(est_db_flush$$1$$8$$1$$4$$_CB_i >= est_db_flush$$1$$8$$1$$4$$_CB_end); est_db_flush$$1$$8$$1$$4$$_CB_i = est_db_flush$$1$$8$$1$$4$$_CB_i + 1)
              free((void *)(keys->array + (signed long int)est_db_flush$$1$$8$$1$$4$$_CB_i)->dptr);
            free((void *)keys->array);
            free((void *)keys);
          }
          while((_Bool)0);
          signed int return_value_cbmaprnum$32;
          return_value_cbmaprnum$32=cbmaprnum(db->auxcc);
          if(!(return_value_cbmaprnum$32 >= 1))
          {
            cbmapclose(db->auxcc);
            db->auxcc=cbmapopenex(65521);
          }

        }

      }

      if(!(max >= 1))
      {
        return_value_cbmaprnum$55=cbmaprnum(db->outcc);
        if(return_value_cbmaprnum$55 >= 1)
        {
          ids=cbmapopen();
          do
          {
            void *return_value_malloc$35;
            return_value_malloc$35=malloc(sizeof(struct anonymous$1) /*24ul*/ );
            keys = (struct anonymous$1 *)return_value_malloc$35;
            if(!(keys == ((struct anonymous$1 *)NULL)))
              keys;

            else
              cbmyfatal("out of memory");
            keys->anum = 64;
            void *return_value_malloc$36;
            return_value_malloc$36=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)keys->anum);
            keys->array = (struct anonymous$28 *)return_value_malloc$36;
            if(!(keys->array == ((struct anonymous$28 *)NULL)))
              keys->array;

            else
              cbmyfatal("out of memory");
            keys->start = 0;
            keys->num = 0;
          }
          while((_Bool)0);
          cbmapiterinit(db->outcc);
          do
          {
            kbuf=cbmapiternext(db->outcc, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            if((signed int)*kbuf == 9)
            {
              id=atoi(kbuf + (signed long int)1);
              cbmapput(ids, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , "", 0, 0);
            }

            else
              do
              {
                signed int est_db_flush$$1$$9$$2$$2$$1$$_CB_index = keys->start + keys->num;
                if(est_db_flush$$1$$9$$2$$2$$1$$_CB_index >= keys->anum)
                {
                  keys->anum = keys->anum * 2;
                  void *return_value_realloc$37;
                  return_value_realloc$37=realloc((void *)keys->array, (unsigned long int)keys->anum * sizeof(struct anonymous$28) /*16ul*/ );
                  keys->array = (struct anonymous$28 *)return_value_realloc$37;
                  if(!(keys->array == ((struct anonymous$28 *)NULL)))
                    keys->array;

                  else
                    cbmyfatal("out of memory");
                }

                void *return_value_malloc$38;
                return_value_malloc$38=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
                (keys->array + (signed long int)est_db_flush$$1$$9$$2$$2$$1$$_CB_index)->dptr = (char *)return_value_malloc$38;
                if(!((keys->array + (signed long int)est_db_flush$$1$$9$$2$$2$$1$$_CB_index)->dptr == ((char *)NULL)))
                  (keys->array + (signed long int)est_db_flush$$1$$9$$2$$2$$1$$_CB_index)->dptr;

                else
                  cbmyfatal("out of memory");
                memcpy((void *)(keys->array + (signed long int)est_db_flush$$1$$9$$2$$2$$1$$_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
                (keys->array + (signed long int)est_db_flush$$1$$9$$2$$2$$1$$_CB_index)->dptr[(signed long int)ksiz] = (char)0;
                (keys->array + (signed long int)est_db_flush$$1$$9$$2$$2$$1$$_CB_index)->dsize = ksiz;
                keys->num = keys->num + 1;
              }
              while((_Bool)0);
          }
          while((_Bool)1);
          cblistsort(keys);
          dnum=est_idx_dnum(db->idxdb);
          i = 0;
          for( ; !(i >= keys->num); i = i + 1)
          {
            ksiz = (keys->array + (signed long int)(keys->start + i))->dsize;
            kbuf = (const char *)(keys->array + (signed long int)(keys->start + i))->dptr;
            if((signed int)*kbuf == 32)
            {
              tbuf=vlget(db->auxdb, kbuf + (signed long int)1, ksiz - 1, &tsiz);
              if(!(tbuf == ((char *)NULL)))
              {
                rp = tbuf;
                wp = tbuf;
                ep = tbuf + (signed long int)tsiz;
                while(!(rp >= ep))
                {
                  const char *return_value_cbmapget$39;
                  return_value_cbmapget$39=cbmapget(ids, rp, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
                  if(return_value_cbmapget$39 == ((const char *)NULL))
                  {
                    memmove((void *)wp, (const void *)rp, sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                    wp = wp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                  }

                  rp = rp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                }
                if(!(tbuf >= wp))
                {
                  signed int return_value_vlput$40;
                  return_value_vlput$40=vlput(db->auxdb, kbuf + (signed long int)1, ksiz - 1, tbuf, (signed int)(wp - tbuf), 0);
                  if(return_value_vlput$40 == 0)
                    err = 1;

                  len=sprintf(numbuf, "%d", (signed int)((unsigned long int)(wp - tbuf) / (sizeof(signed int) /*4ul*/  * (unsigned long int)2)));
                  signed int return_value_vlput$41;
                  return_value_vlput$41=vlput(db->xfmdb, kbuf + (signed long int)1, ksiz - 1, numbuf, len, 0);
                  if(return_value_vlput$41 == 0)
                    err = 1;

                }

                else
                {
                  signed int return_value_vlout$42;
                  return_value_vlout$42=vlout(db->auxdb, kbuf + (signed long int)1, ksiz - 1);
                  if(return_value_vlout$42 == 0)
                    err = 1;

                  signed int return_value_vlout$44;
                  return_value_vlout$44=vlout(db->xfmdb, kbuf + (signed long int)1, ksiz - 1);
                  if(return_value_vlout$44 == 0)
                  {
                    return_value_dpecodeptr$43=dpecodeptr();
                    if(!(*return_value_dpecodeptr$43 == 5))
                      err = 1;

                  }

                }
                free((void *)tbuf);
              }

            }

            else
            {
              sum = 0;
              j = 0;
              for( ; !(j >= dnum); j = j + 1)
              {
                vbuf=est_idx_get_one(db->idxdb, j, kbuf, ksiz, &tsiz);
                if(!(vbuf == ((const char *)NULL)))
                {
                  do
                  {
                    void *return_value_malloc$45;
                    return_value_malloc$45=malloc(sizeof(struct anonymous$2) /*16ul*/ );
                    nval = (struct anonymous$2 *)return_value_malloc$45;
                    if(!(nval == ((struct anonymous$2 *)NULL)))
                      nval;

                    else
                      cbmyfatal("out of memory");
                    void *return_value_malloc$46;
                    return_value_malloc$46=malloc((unsigned long int)12);
                    nval->dptr = (char *)return_value_malloc$46;
                    if(!(nval->dptr == ((char *)NULL)))
                      nval->dptr;

                    else
                      cbmyfatal("out of memory");
                    nval->dptr[(signed long int)0] = (char)0;
                    nval->dsize = 0;
                    nval->asize = 12;
                  }
                  while((_Bool)0);
                  rp = vbuf;
                  ep = vbuf + (signed long int)tsiz;
                  lid = 0;
                  cid = 0;
                  while(!(rp >= ep))
                  {
                    do
                    {
                      signed int _EST_i;
                      signed int _EST_base;
                      vnum = 0;
                      _EST_base = 1;
                      _EST_i = 0;
                      for( ; (_Bool)1; _EST_i = _EST_i + 1)
                      {
                        if((signed int)rp[(signed long int)_EST_i] >= 0)
                        {
                          vnum = vnum + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                          break;
                        }

                        vnum = vnum + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                        _EST_base = _EST_base * 128;
                      }
                      vstep = _EST_i + 1;
                    }
                    while((_Bool)0);
                    cid = cid + vnum + 1;
                    rp = rp + (signed long int)vstep;
                    pv = rp;
                    if(!(db->smode == 1048576))
                    {
                      if(db->smode == 2097152 || db->smode == 4194304)
                        goto __CPROVER_DUMP_L109;

                    }

                    else
                      goto __CPROVER_DUMP_L110;
                    rp = rp + 1l;
                    goto __CPROVER_DUMP_L110;

                  __CPROVER_DUMP_L109:
                    ;
                    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

                  __CPROVER_DUMP_L110:
                    ;
                    for( ; !((signed int)*rp == 0x0); rp = rp + (signed long int)2)
                      ;
                    rp = rp + 1l;
                    const char *return_value_cbmapget$49;
                    return_value_cbmapget$49=cbmapget(ids, (char *)&cid, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
                    if(return_value_cbmapget$49 == ((const char *)NULL))
                    {
                      do
                      {
                        signed int _EST_num = (cid - lid) - 1;
                        struct anonymous$15 EST_d;
                        if(_EST_num == 0)
                        {
                          ((signed char *)numbuf)[(signed long int)0] = (signed char)0;
                          vstep = 1;
                        }

                        else
                        {
                          vstep = 0;
                          for( ; _EST_num >= 1; vstep = vstep + 1)
                          {
                            EST_d=div(_EST_num, 128);
                            _EST_num = EST_d.quot;
                            if(_EST_num >= 1)
                              ((signed char *)numbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

                            else
                              ((signed char *)numbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
                          }
                        }
                      }
                      while((_Bool)0);
                      do
                      {
                        if(nval->dsize + vstep >= nval->asize)
                        {
                          nval->asize = nval->asize * 2 + vstep + 1;
                          void *return_value_realloc$47;
                          return_value_realloc$47=realloc((void *)nval->dptr, (unsigned long int)nval->asize);
                          nval->dptr = (char *)return_value_realloc$47;
                          if(!(nval->dptr == ((char *)NULL)))
                            nval->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        memcpy((void *)(nval->dptr + (signed long int)nval->dsize), (const void *)numbuf, (unsigned long int)vstep);
                        nval->dsize = nval->dsize + vstep;
                        nval->dptr[(signed long int)nval->dsize] = (char)0;
                      }
                      while((_Bool)0);
                      do
                      {
                        if((rp - pv) + (signed long int)nval->dsize >= (signed long int)nval->asize)
                        {
                          nval->asize = (signed int)((signed long int)(nval->asize * 2) + (rp - pv) + (signed long int)1);
                          void *return_value_realloc$48;
                          return_value_realloc$48=realloc((void *)nval->dptr, (unsigned long int)nval->asize);
                          nval->dptr = (char *)return_value_realloc$48;
                          if(!(nval->dptr == ((char *)NULL)))
                            nval->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        memcpy((void *)(nval->dptr + (signed long int)nval->dsize), (const void *)pv, (unsigned long int)(rp - pv));
                        nval->dsize = nval->dsize + (signed int)(rp - pv);
                        nval->dptr[(signed long int)nval->dsize] = (char)0;
                      }
                      while((_Bool)0);
                      lid = cid;
                    }

                  }
                  signed int return_value_est_idx_put_one$50;
                  return_value_est_idx_put_one$50=est_idx_put_one(db->idxdb, j, kbuf, ksiz, (const char *)nval->dptr, (signed int)nval->dsize);
                  if(return_value_est_idx_put_one$50 == 0)
                    err = 1;

                  sum = sum + (signed int)nval->dsize;
                  do
                  {
                    free((void *)nval->dptr);
                    free((void *)nval);
                  }
                  while((_Bool)0);
                }

              }
              if(!(sum >= 1))
              {
                return_value_vlout$52=vlout(db->fwmdb, kbuf, ksiz);
                if(return_value_vlout$52 == 0)
                {
                  return_value_dpecodeptr$51=dpecodeptr();
                  if(!(*return_value_dpecodeptr$51 == 5))
                    err = 1;

                }

              }

            }
            cbmapout(db->outcc, kbuf, ksiz);
            if(i % 10000 == 0)
              est_db_inform(db, "cleaning dispensable keys");

            if(max >= 1)
            {
              if(!(db->intflag == 0))
              {
                if(i >= 1)
                {
                  if(i % 256 == 0)
                    break;

                }

              }

            }

          }
          signed int return_value_cbmaprnum$53;
          return_value_cbmaprnum$53=cbmaprnum(db->outcc);
          signed int return_value_cbmaprnum$54;
          return_value_cbmaprnum$54=cbmaprnum(ids);
          if(return_value_cbmaprnum$54 >= return_value_cbmaprnum$53)
          {
            cbmapclose(db->outcc);
            db->outcc=cbmapopenex(131072);
          }

          do
          {
            signed int est_db_flush$$1$$9$$5$$_CB_i;
            signed int est_db_flush$$1$$9$$5$$_CB_end = keys->start + keys->num;
            est_db_flush$$1$$9$$5$$_CB_i = keys->start;
            for( ; !(est_db_flush$$1$$9$$5$$_CB_i >= est_db_flush$$1$$9$$5$$_CB_end); est_db_flush$$1$$9$$5$$_CB_i = est_db_flush$$1$$9$$5$$_CB_i + 1)
              free((void *)(keys->array + (signed long int)est_db_flush$$1$$9$$5$$_CB_i)->dptr);
            free((void *)keys->array);
            free((void *)keys);
          }
          while((_Bool)0);
          cbmapclose(ids);
        }

      }

      cbmapclose(db->keycc);
      db->keycc=cbmapopenex(65536 + 1);
      db->kcmnum = 65536;
      if(max >= 1)
        tmp_if_expr$57 = db->intflag != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$57 = (_Bool)0;
      if(!tmp_if_expr$57)
      {
        if(!(inc == 0))
        {
          return_value_est_idx_size_current$56=est_idx_size_current(db->idxdb);
          if(return_value_est_idx_size_current$56 >= 512)
          {
            est_db_inform(db, "adding a new database file");
            est_idx_increment(db->idxdb);
          }

        }

      }

      if(max >= 0x7fffffff || !(max >= 1))
      {
        signed int return_value_vlmemflush$58;
        return_value_vlmemflush$58=vlmemflush(db->auxdb);
        if(return_value_vlmemflush$58 == 0)
          err = 1;

        signed int return_value_est_idx_memflush$59;
        return_value_est_idx_memflush$59=est_idx_memflush(db->idxdb);
        if(return_value_est_idx_memflush$59 == 0)
          err = 1;

      }

      if(max >= 1)
      {
        if(!(db->intflag == 0))
          est_db_inform(db, "flushing interrupted");

      }

      db->flsflag = 0;
      db->intflag = 0;
      if(!(err == 0))
      {
        est_set_ecode(&db->ecode, 4, 1683);
        db->fatal = 1;
        return 0;
      }

      else
        return 1;
    }
  }
}

// est_db_get_doc
// file estraier.c line 2533
struct anonymous$0 * est_db_get_doc(struct anonymous *db, signed int id, signed int options)
{
  struct anonymous$0 *doc;
  const char *cbuf;
  char *vbuf;
  char numbuf[32l];
  signed int i;
  signed int csiz;
  signed int vsiz;
  signed int num;
  if(id >= 2000000001)
  {
    num = id - 2000000001;
    if(num >= db->pdocs->num)
    {
      est_set_ecode(&db->ecode, 6, 2541);
      return (struct anonymous$0 *)(void *)0;
    }

    vbuf=cbreadfile((const char *)(db->pdocs->array + (signed long int)(db->pdocs->start + num))->dptr, (signed int *)(void *)0);
    if(!(vbuf == ((char *)NULL)))
    {
      doc=est_doc_new_from_draft(vbuf);
      free((void *)vbuf);
    }

    else
      doc=est_doc_new();
    doc->id = id;
    sprintf(numbuf, "%d", id);
    est_doc_add_attr(doc, "@id", numbuf);
    const char *return_value_est_doc_attr$1;
    return_value_est_doc_attr$1=est_doc_attr(doc, "@uri");
    if(return_value_est_doc_attr$1 == ((const char *)NULL))
      est_doc_add_attr(doc, "@uri", (const char *)(db->pdocs->array + (signed long int)(db->pdocs->start + num))->dptr);

    return doc;
  }

  cbuf = (const char *)(void *)0;
  if(!((1 & options) == 0))
  {
    signed int return_value_crvsiz$3;
    return_value_crvsiz$3=crvsiz(db->attrdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(return_value_crvsiz$3 == -1)
    {
      signed int *return_value_dpecodeptr$2;
      return_value_dpecodeptr$2=dpecodeptr();
      if(*return_value_dpecodeptr$2 == 5)
      {
        est_set_ecode(&db->ecode, 6, 2561);
        return (struct anonymous$0 *)(void *)0;
      }

      else
      {
        est_set_ecode(&db->ecode, 4, 2564);
        db->fatal = 1;
        return (struct anonymous$0 *)(void *)0;
      }
    }

    vbuf = (char *)(void *)0;
  }

  else
  {
    cbuf=cbmapget(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
    if(!(cbuf == ((const char *)NULL)))
    {
      cbmapmove(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
      vbuf = (char *)(void *)0;
    }

    else
    {
      vbuf=est_crget(db->attrdb, db->zmode, id, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr$4;
        return_value_dpecodeptr$4=dpecodeptr();
        if(*return_value_dpecodeptr$4 == 5)
        {
          est_set_ecode(&db->ecode, 6, 2575);
          return (struct anonymous$0 *)(void *)0;
        }

        else
        {
          est_set_ecode(&db->ecode, 4, 2578);
          db->fatal = 1;
          return (struct anonymous$0 *)(void *)0;
        }
      }

    }
  }
  doc=est_doc_new();
  doc->id = id;
  _Bool tmp_if_expr$6;
  if(!(cbuf == ((const char *)NULL)))
    doc->attrs=cbmapload(cbuf, csiz);

  else
    if(!(vbuf == ((char *)NULL)))
    {
      doc->attrs=cbmapload(vbuf, vsiz);
      if(db->acmnum >= 1)
        cbmapput(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 1);

      free((void *)vbuf);
      signed int return_value_cbmaprnum$7;
      return_value_cbmaprnum$7=cbmaprnum(db->attrcc);
      if(!(db->acmnum >= return_value_cbmaprnum$7))
      {
        signed int return_value_cbmaprnum$5;
        return_value_cbmaprnum$5=cbmaprnum(db->attrcc);
        num = (signed int)((double)return_value_cbmaprnum$5 * 0.1 + (double)1);
        cbmapiterinit(db->attrcc);
        i = 0;
        do
        {
          if(!(i >= num))
          {
            cbuf=cbmapiternext(db->attrcc, (signed int *)(void *)0);
            tmp_if_expr$6 = cbuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$6 = (_Bool)0;
          if(!tmp_if_expr$6)
            break;

          cbmapout(db->attrcc, cbuf, (signed int)sizeof(signed int) /*4ul*/ );
          i = i + 1;
        }
        while((_Bool)1);
      }

    }

    else
      doc->attrs = (struct anonymous$9 *)(void *)0;
  _Bool tmp_if_expr$9;
  if((2 & options) == 0)
  {
    cbuf=cbmapget(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
    if(!(cbuf == ((const char *)NULL)))
    {
      cbmapmove(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
      doc->dtexts=cblistload(cbuf, csiz);
    }

    else
    {
      vbuf=est_crget(db->textdb, db->zmode, id, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        est_set_ecode(&db->ecode, 4, 2607);
        db->fatal = 1;
        est_doc_delete(doc);
        return (struct anonymous$0 *)(void *)0;
      }

      doc->dtexts=cblistload(vbuf, vsiz);
      if(db->tcmnum >= 1)
        cbmapput(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 1);

      free((void *)vbuf);
      signed int return_value_cbmaprnum$10;
      return_value_cbmaprnum$10=cbmaprnum(db->textcc);
      if(!(db->tcmnum >= return_value_cbmaprnum$10))
      {
        signed int return_value_cbmaprnum$8;
        return_value_cbmaprnum$8=cbmaprnum(db->textcc);
        num = (signed int)((double)return_value_cbmaprnum$8 * 0.1 + (double)1);
        cbmapiterinit(db->textcc);
        i = 0;
        do
        {
          if(!(i >= num))
          {
            cbuf=cbmapiternext(db->textcc, (signed int *)(void *)0);
            tmp_if_expr$9 = cbuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$9 = (_Bool)0;
          if(!tmp_if_expr$9)
            break;

          cbmapout(db->textcc, cbuf, (signed int)sizeof(signed int) /*4ul*/ );
          i = i + 1;
        }
        while((_Bool)1);
      }

    }
  }

  if((4 & options) == 0)
    doc->kwords=est_db_get_keywords(db, id);

  return doc;
}

// est_db_get_doc_attr
// file estraier.c line 2630
char * est_db_get_doc_attr(struct anonymous *db, signed int id, const char *name)
{
  struct anonymous$16 *attridx;
  struct anonymous$0 *doc;
  const char *cbuf;
  char *mbuf;
  char *vbuf;
  signed int cb;
  signed int csiz;
  signed int msiz;
  signed int vsiz;
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(id >= 2000000001)
  {
    doc=est_db_get_doc(db, id, 0);
    if(doc == ((struct anonymous$0 *)NULL))
    {
      est_set_ecode(&db->ecode, 6, 2639);
      return (char *)(void *)0;
    }

    cbuf=est_doc_attr(doc, name);
    if(cbuf == ((const char *)NULL))
    {
      est_set_ecode(&db->ecode, 6, 2643);
      est_doc_delete(doc);
      return (char *)(void *)0;
    }

    vbuf=cbmemdup(cbuf, -1);
    est_doc_delete(doc);
    return vbuf;
  }

  else
  {
    if(!(db->spacc == ((struct anonymous$9 *)NULL)))
    {
      return_value_strcmp$1=strcmp(name, db->scname);
      tmp_if_expr$2 = !(return_value_strcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    cb = (signed int)tmp_if_expr$2;
    if(!(cb == 0))
    {
      cbuf=cbmapget(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
      if(!(cbuf == ((const char *)NULL)))
      {
        cbmapmove(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
        char *return_value_cbmemdup$3;
        return_value_cbmemdup$3=cbmemdup(cbuf, csiz);
        return return_value_cbmemdup$3;
      }

    }

    const char *return_value_cbmapget$4;
    return_value_cbmapget$4=cbmapget(db->aidxs, name, -1, (signed int *)(void *)0);
    attridx = (struct anonymous$16 *)return_value_cbmapget$4;
    if(!(attridx == ((struct anonymous$16 *)NULL)))
    {
      if(!(attridx->type == 0))
        goto __CPROVER_DUMP_L9;

      vbuf=est_aidx_seq_get((struct anonymous$5 *)attridx->db, id, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        est_set_ecode(&db->ecode, 6, 2659);
        return (char *)(void *)0;
      }

      if(!(cb == 0))
        cbmapput(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

      return vbuf;
    }

    else
    {

    __CPROVER_DUMP_L9:
      ;
      mbuf=est_crget(db->attrdb, db->zmode, id, &msiz);
      if(mbuf == ((char *)NULL))
      {
        signed int *return_value_dpecodeptr$5;
        return_value_dpecodeptr$5=dpecodeptr();
        est_set_ecode(&db->ecode, *return_value_dpecodeptr$5 == 5 ? 6 : 4, 2666);
        return (char *)(void *)0;
      }

      vbuf=cbmaploadone(mbuf, msiz, name, -1, &vsiz);
      if(vbuf == ((char *)NULL))
      {
        est_set_ecode(&db->ecode, 6, 2670);
        free((void *)mbuf);
        return (char *)(void *)0;
      }

      else
      {
        if(!(cb == 0))
          cbmapput(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

        free((void *)mbuf);
        return vbuf;
      }
    }
  }
}

// est_db_get_doc_entity
// file estraier.c line 4513
char * est_db_get_doc_entity(struct anonymous *db, signed int id, signed int *sp)
{
  char *ptr;
  ptr=crgetlob(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0, -1, sp);
  if(ptr == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr$1;
    return_value_dpecodeptr$1=dpecodeptr();
    est_set_ecode(&db->ecode, *return_value_dpecodeptr$1 == 5 ? 6 : 4, 4517);
    return (char *)(void *)0;
  }

  return ptr;
}

// est_db_get_keywords
// file estraier.c line 4774
struct anonymous$9 * est_db_get_keywords(struct anonymous *db, signed int id)
{
  struct anonymous$9 *kwords;
  const char *cbuf;
  char *mbuf;
  signed int i;
  signed int csiz;
  signed int msiz;
  signed int num;
  cbuf=cbmapget(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
  if(!(cbuf == ((const char *)NULL)))
  {
    cbmapmove(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , 0);
    struct anonymous$9 *return_value_cbmapload$1;
    return_value_cbmapload$1=cbmapload(cbuf, csiz);
    return return_value_cbmapload$1;
  }

  mbuf=est_crget(db->kwddb, db->zmode, id, &msiz);
  _Bool tmp_if_expr$3;
  if(mbuf == ((char *)NULL))
  {
    est_set_ecode(&db->ecode, 6, 4785);
    return (struct anonymous$9 *)(void *)0;
  }

  else
  {
    kwords=cbmapload(mbuf, msiz);
    if(db->vcmnum >= 1)
      cbmapput(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , mbuf, msiz, 1);

    free((void *)mbuf);
    signed int return_value_cbmaprnum$4;
    return_value_cbmaprnum$4=cbmaprnum(db->veccc);
    if(!(db->vcmnum >= return_value_cbmaprnum$4))
    {
      signed int return_value_cbmaprnum$2;
      return_value_cbmaprnum$2=cbmaprnum(db->veccc);
      num = (signed int)((double)return_value_cbmaprnum$2 * 0.1 + (double)1);
      cbmapiterinit(db->veccc);
      i = 0;
      do
      {
        if(!(i >= num))
        {
          cbuf=cbmapiternext(db->veccc, (signed int *)(void *)0);
          tmp_if_expr$3 = cbuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        cbmapout(db->veccc, cbuf, (signed int)sizeof(signed int) /*4ul*/ );
        i = i + 1;
      }
      while((_Bool)1);
    }

    return kwords;
  }
}

// est_db_inform
// file estraier.c line 7801
static void est_db_inform(struct anonymous *db, const char *info)
{
  char *msg;
  if(!(db->infocb == ((void (*)(const char *, void *))NULL)))
  {
    signed int return_value_vlrnum$1;
    return_value_vlrnum$1=vlrnum(db->fwmdb);
    double return_value_est_db_size$2;
    return_value_est_db_size$2=est_db_size(db);
    signed int return_value_cbmaprnum$3;
    return_value_cbmaprnum$3=cbmaprnum(db->idxcc);
    signed int return_value_cbmaprnum$4;
    return_value_cbmaprnum$4=cbmaprnum(db->auxcc);
    signed int return_value_est_db_used_cache_size$5;
    return_value_est_db_used_cache_size$5=est_db_used_cache_size(db);
    signed int return_value_cbmaprnum$6;
    return_value_cbmaprnum$6=cbmaprnum(db->outcc);
    msg=cbsprintf("%s: name=%s dnum=%d wnum=%d fsiz=%.0f crnum=%d csiz=%d dknum=%d", info, db->name, db->dnum, return_value_vlrnum$1, (double)return_value_est_db_size$2, return_value_cbmaprnum$3 + return_value_cbmaprnum$4, return_value_est_db_used_cache_size$5, return_value_cbmaprnum$6);
    db->infocb(msg, db->infoop);
    free((void *)msg);
  }

}

// est_db_inode
// file estraier.c line 4475
signed int est_db_inode(struct anonymous *db)
{
  return db->inode;
}

// est_db_interrupt
// file estraier.c line 5110
void est_db_interrupt(struct anonymous *db)
{
  db->intflag = 1;
}

// est_db_iter_init
// file estraier.c line 4815
signed int est_db_iter_init(struct anonymous *db, const char *prev)
{
  char *vbuf;
  signed int *return_value_dpecodeptr$1;
  if(!(prev == ((const char *)NULL)))
  {
    signed int return_value_vlcurjump$2;
    return_value_vlcurjump$2=vlcurjump(db->listdb, prev, -1, 0);
    if(return_value_vlcurjump$2 == 0)
    {
      return_value_dpecodeptr$1=dpecodeptr();
      return (signed int)(*return_value_dpecodeptr$1 == 5);
    }

    vbuf=vlcurkey(db->listdb, (signed int *)(void *)0);
    if(!(vbuf == ((char *)NULL)))
    {
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(prev, vbuf);
      if(return_value_strcmp$3 >= 0)
        vlcurnext(db->listdb);

      free((void *)vbuf);
    }

    return 1;
  }

  signed int return_value_vlcurfirst$4;
  return_value_vlcurfirst$4=vlcurfirst(db->listdb);
  _Bool tmp_if_expr$6;
  signed int *return_value_dpecodeptr$5;
  if(!(return_value_vlcurfirst$4 == 0))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_dpecodeptr$5=dpecodeptr();
    tmp_if_expr$6 = *return_value_dpecodeptr$5 == 5 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$6;
}

// est_db_iter_next
// file estraier.c line 4831
signed int est_db_iter_next(struct anonymous *db)
{
  char *vbuf;
  signed int id;
  vbuf=vlcurval(db->listdb, (signed int *)(void *)0);
  if(vbuf == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr$1;
    return_value_dpecodeptr$1=dpecodeptr();
    if(*return_value_dpecodeptr$1 == 5)
    {
      est_set_ecode(&db->ecode, 6, 4837);
      return 0;
    }

    else
    {
      est_set_ecode(&db->ecode, 4, 4840);
      db->fatal = 1;
      return -1;
    }
  }

  id=atoi(vbuf);
  free((void *)vbuf);
  vlcurnext(db->listdb);
  return id;
}

// est_db_keyword_iter_init
// file estraier.c line 4901
signed int est_db_keyword_iter_init(struct anonymous *db)
{
  signed int return_value_vlcurfirst$2;
  return_value_vlcurfirst$2=vlcurfirst(db->xfmdb);
  signed int *return_value_dpecodeptr$1;
  if(return_value_vlcurfirst$2 == 0)
  {
    return_value_dpecodeptr$1=dpecodeptr();
    if(*return_value_dpecodeptr$1 == 5)
      goto __CPROVER_DUMP_L1;

    est_set_ecode(&db->ecode, 4, 4904);
    db->fatal = 1;
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// est_db_keyword_iter_next
// file estraier.c line 4913
char * est_db_keyword_iter_next(struct anonymous *db)
{
  char *word;
  word=vlcurkey(db->xfmdb, (signed int *)(void *)0);
  if(word == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr$1;
    return_value_dpecodeptr$1=dpecodeptr();
    if(*return_value_dpecodeptr$1 == 5)
      est_set_ecode(&db->ecode, 6, 4918);

    else
    {
      est_set_ecode(&db->ecode, 4, 4920);
      db->fatal = 1;
    }
    return (char *)(void *)0;
  }

  vlcurnext(db->xfmdb);
  return word;
}

// est_db_keyword_num
// file estraier.c line 4892
signed int est_db_keyword_num(struct anonymous *db)
{
  signed int wnum;
  wnum=vlrnum(db->xfmdb);
  return wnum > 0 ? wnum : 0;
}

// est_db_keyword_rec_size
// file estraier.c line 4931
signed int est_db_keyword_rec_size(struct anonymous *db, const char *word)
{
  const char *kbuf;
  kbuf=vlgetcache(db->xfmdb, word, -1, (signed int *)(void *)0);
  signed int tmp_if_expr$2;
  signed int return_value_atoi$1;
  if(!(kbuf == ((const char *)NULL)))
  {
    return_value_atoi$1=atoi(kbuf);
    tmp_if_expr$2 = return_value_atoi$1;
  }

  else
    tmp_if_expr$2 = 0;
  return tmp_if_expr$2;
}

// est_db_keyword_search
// file estraier.c line 4939
signed int * est_db_keyword_search(struct anonymous *db, const char *word, signed int *nump)
{
  signed int i;
  signed int *res;
  signed int rnum;
  char *return_value_vlget$2;
  return_value_vlget$2=vlget(db->auxdb, word, -1, &rnum);
  res = (signed int *)return_value_vlget$2;
  if(res == ((signed int *)NULL))
  {
    *nump = 0;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)1);
    res = (signed int *)return_value_malloc$1;
    if(!(res == ((signed int *)NULL)))
      res;

    else
      cbmyfatal("out of memory");
    return res;
  }

  rnum = rnum / (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
  i = 0;
  for( ; !(i >= rnum); i = i + 1)
    res[(signed long int)i] = res[(signed long int)(i * 2)];
  *nump = rnum;
  return res;
}

// est_db_list_rescc
// file estraier.c line 5060
struct anonymous$1 * est_db_list_rescc(struct anonymous *db)
{
  struct anonymous$1 *words;
  const char *word;
  signed int size;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    words = (struct anonymous$1 *)return_value_malloc$1;
    if(!(words == ((struct anonymous$1 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous$28 *)return_value_malloc$2;
    if(!(words->array == ((struct anonymous$28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  cbmapiterinit(db->rescc);
  do
  {
    word=cbmapiternext(db->rescc, &size);
    if(word == ((const char *)NULL))
      break;

    cblistunshift(words, word, size);
  }
  while((_Bool)1);
  return words;
}

// est_db_measure_doc
// file estraier.c line 4803
signed int est_db_measure_doc(struct anonymous *db, signed int id, signed int parts)
{
  signed int sum;
  signed int num;
  sum = 0;
  if(!((1 & parts) == 0))
  {
    num=crvsiz(db->attrdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(num >= 1)
      sum = sum + num;

  }

  if(!((2 & parts) == 0))
  {
    num=crvsiz(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(num >= 1)
      sum = sum + num;

  }

  if(!((4 & parts) == 0))
  {
    num=crvsiz(db->kwddb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(num >= 1)
      sum = sum + num;

  }

  return sum;
}

// est_db_merge
// file estraier.c line 1891
signed int est_db_merge(struct anonymous *db, const char *name, signed int options)
{
  struct anonymous *tgdb;
  struct anonymous$16 *attridx;
  struct anonymous$9 *idmap;
  struct anonymous$9 *seqmap;
  struct anonymous$9 *attrs;
  struct anonymous$1 *words;
  struct anonymous$2 *rbuf;
  const char *kbuf;
  const char *vbuf;
  const char *rp;
  const char *ep;
  const char *sp;
  char *tbuf;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int ecode;
  signed int err;
  signed int ksiz;
  signed int vsiz;
  signed int tsiz;
  signed int oid;
  signed int nid;
  signed int len;
  signed int vstep;
  signed int anum;
  signed int *ary;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  signed int return_value_atoi$5;
  signed int return_value_est_db_out_doc$6;
  signed int return_value_est_aidx_attr_put$12;
  signed int *return_value_dpecodeptr$17;
  signed int tmp_if_expr$22;
  signed int tmp_if_expr$36;
  signed int return_value_atoi$40;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1902);
    return 0;
  }

  else
  {
    est_db_inform(db, "opening the target database");
    tgdb=est_db_open(name, 1, &ecode);
    if(tgdb == ((struct anonymous *)NULL))
    {
      est_set_ecode(&db->ecode, ecode, 1907);
      return 0;
    }

    else
    {
      signed int return_value_dpgetflags$2;
      return_value_dpgetflags$2=dpgetflags(db->metadb);
      signed int return_value_dpgetflags$3;
      return_value_dpgetflags$3=dpgetflags(tgdb->metadb);
      if(!(return_value_dpgetflags$2 == return_value_dpgetflags$3))
      {
        est_db_close(tgdb, &ecode);
        est_set_ecode(&db->ecode, 9999, 1912);
        return 0;
      }

      else
      {
        err = 0;
        signed int return_value_est_db_doc_num$4;
        return_value_est_db_doc_num$4=est_db_doc_num(tgdb);
        idmap=cbmapopenex(return_value_est_db_doc_num$4 + 1);
        vlcurfirst(tgdb->listdb);
        i = 0;
        do
        {
          kbuf=vlcurkeycache(tgdb->listdb, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          vbuf=vlgetcache(db->listdb, kbuf, ksiz, (signed int *)(void *)0);
          if(!(vbuf == ((const char *)NULL)))
          {
            return_value_atoi$5=atoi(vbuf);
            return_value_est_db_out_doc$6=est_db_out_doc(db, return_value_atoi$5, (options & 1) != 0 ? 1 : 0);
            if(return_value_est_db_out_doc$6 == 0)
              err = 1;

          }

          const char *return_value_vlcurvalcache$7;
          return_value_vlcurvalcache$7=vlcurvalcache(tgdb->listdb, (signed int *)(void *)0);
          oid=atoi(return_value_vlcurvalcache$7);
          db->dseq = db->dseq + 1;
          db->dnum = db->dnum + 1;
          cbmapput(idmap, (char *)&oid, (signed int)sizeof(signed int) /*4ul*/ , (char *)&db->dseq, (signed int)sizeof(signed int) /*4ul*/ , 0);
          vlcurnext(tgdb->listdb);
          if(i % 1000 == 0)
            est_db_inform(db, "calculating ID mapping");

          i = i + 1;
        }
        while((_Bool)1);
        signed int return_value_est_db_flush$8;
        return_value_est_db_flush$8=est_db_flush(db, -1);
        if(return_value_est_db_flush$8 == 0)
        {
          cbmapclose(idmap);
          est_db_close(tgdb, &ecode);
          return 0;
        }

        else
        {
          cbmapiterinit(idmap);
          i = 0;
          do
          {
            kbuf=cbmapiternext(idmap, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(kbuf - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
              vsiz = _CB_datum->vsiz;
              vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
            }
            while((_Bool)0);
            oid = *((signed int *)kbuf);
            nid = *((signed int *)vbuf);
            tbuf=est_crget(tgdb->attrdb, tgdb->zmode, oid, &tsiz);
            if(!(tbuf == ((char *)NULL)))
            {
              attrs=cbmapload(tbuf, tsiz);
              len=sprintf(numbuf, "%d", nid);
              cbmapput(attrs, "@id", -1, numbuf, len, 1);
              free((void *)tbuf);
              tbuf=cbmapdump(attrs, &tsiz);
              vbuf=cbmapget(attrs, "@uri", -1, &vsiz);
              if(!(vbuf == ((const char *)NULL)))
              {
                signed int return_value_vlput$9;
                return_value_vlput$9=vlput(db->listdb, vbuf, vsiz, numbuf, len, 1);
                if(return_value_vlput$9 == 0)
                {
                  est_set_ecode(&db->ecode, 4, 1946);
                  db->fatal = 1;
                  err = 1;
                }

              }

              else
              {
                est_set_ecode(&db->ecode, 4, 1951);
                db->fatal = 1;
                err = 1;
              }
              signed int return_value_est_crput$10;
              return_value_est_crput$10=est_crput(db->attrdb, db->zmode, nid, tbuf, tsiz, 1);
              if(return_value_est_crput$10 == 0)
              {
                est_set_ecode(&db->ecode, 4, 1956);
                db->fatal = 1;
                err = 1;
              }

              signed int return_value_cbmaprnum$14;
              return_value_cbmaprnum$14=cbmaprnum(db->aidxs);
              if(return_value_cbmaprnum$14 >= 1)
              {
                cbmapiterinit(db->aidxs);
                do
                {
                  kbuf=cbmapiternext(db->aidxs, &ksiz);
                  if(kbuf == ((const char *)NULL))
                    break;

                  vbuf=cbmapget(attrs, kbuf, ksiz, &vsiz);
                  if(!(vbuf == ((const char *)NULL)))
                  {
                    const char *return_value_cbmapiterval$11;
                    return_value_cbmapiterval$11=cbmapiterval(kbuf, (signed int *)(void *)0);
                    attridx = (struct anonymous$16 *)return_value_cbmapiterval$11;
                    if(attridx->type == 1 || attridx->type == 2)
                    {
                      return_value_est_aidx_attr_put$12=est_aidx_attr_put((struct anonymous$7 *)attridx->db, nid, vbuf, vsiz);
                      if(return_value_est_aidx_attr_put$12 == 0)
                      {
                        est_set_ecode(&db->ecode, 4, 1969);
                        db->fatal = 1;
                        err = 1;
                      }

                      goto __CPROVER_DUMP_L20;
                    }

                    signed int return_value_est_aidx_seq_put$13;
                    return_value_est_aidx_seq_put$13=est_aidx_seq_put((struct anonymous$5 *)attridx->db, nid, vbuf, vsiz);
                    if(return_value_est_aidx_seq_put$13 == 0)
                    {
                      est_set_ecode(&db->ecode, 4, 1976);
                      db->fatal = 1;
                      err = 1;
                    }

                  }


                __CPROVER_DUMP_L20:
                  ;
                }
                while((_Bool)1);
              }

              cbmapclose(attrs);
              free((void *)tbuf);
            }

            else
            {
              est_set_ecode(&db->ecode, 4, 1987);
              err = 1;
            }
            tbuf=est_crget(tgdb->textdb, tgdb->zmode, oid, &tsiz);
            if(!(tbuf == ((char *)NULL)))
            {
              signed int return_value_est_crput$15;
              return_value_est_crput$15=est_crput(db->textdb, db->zmode, nid, tbuf, tsiz, 1);
              if(return_value_est_crput$15 == 0)
              {
                est_set_ecode(&db->ecode, 4, 1992);
                db->fatal = 1;
                err = 1;
              }

              free((void *)tbuf);
            }

            else
            {
              est_set_ecode(&db->ecode, 4, 1998);
              err = 1;
            }
            tbuf=est_crget(tgdb->kwddb, tgdb->zmode, oid, &tsiz);
            if(!(tbuf == ((char *)NULL)))
            {
              signed int return_value_est_crput$16;
              return_value_est_crput$16=est_crput(db->kwddb, db->zmode, nid, tbuf, tsiz, 1);
              if(return_value_est_crput$16 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2003);
                db->fatal = 1;
                err = 1;
              }

              free((void *)tbuf);
            }

            else
            {
              return_value_dpecodeptr$17=dpecodeptr();
              if(!(*return_value_dpecodeptr$17 == 5))
              {
                est_set_ecode(&db->ecode, 4, 2009);
                db->fatal = 1;
                err = 1;
              }

            }
            if(i % 1000 == 0)
              est_db_inform(db, "importing documents");

            i = i + 1;
          }
          while((_Bool)1);
          do
          {
            void *return_value_malloc$18;
            return_value_malloc$18=malloc(sizeof(struct anonymous$1) /*24ul*/ );
            words = (struct anonymous$1 *)return_value_malloc$18;
            if(!(words == ((struct anonymous$1 *)NULL)))
              words;

            else
              cbmyfatal("out of memory");
            words->anum = 64;
            void *return_value_malloc$19;
            return_value_malloc$19=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
            words->array = (struct anonymous$28 *)return_value_malloc$19;
            if(!(words->array == ((struct anonymous$28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
            words->start = 0;
            words->num = 0;
          }
          while((_Bool)0);
          vlcurfirst(tgdb->fwmdb);
          do
          {
            kbuf=vlcurkeycache(tgdb->fwmdb, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              signed int est_db_merge$$1$$8$$1$$_CB_index = words->start + words->num;
              if(est_db_merge$$1$$8$$1$$_CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc$20;
                return_value_realloc$20=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
                words->array = (struct anonymous$28 *)return_value_realloc$20;
                if(!(words->array == ((struct anonymous$28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc$21;
              return_value_malloc$21=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
              (words->array + (signed long int)est_db_merge$$1$$8$$1$$_CB_index)->dptr = (char *)return_value_malloc$21;
              if(!((words->array + (signed long int)est_db_merge$$1$$8$$1$$_CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)est_db_merge$$1$$8$$1$$_CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)est_db_merge$$1$$8$$1$$_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
              (words->array + (signed long int)est_db_merge$$1$$8$$1$$_CB_index)->dptr[(signed long int)ksiz] = (char)0;
              (words->array + (signed long int)est_db_merge$$1$$8$$1$$_CB_index)->dsize = ksiz;
              words->num = words->num + 1;
            }
            while((_Bool)0);
            vlcurnext(tgdb->fwmdb);
          }
          while((_Bool)1);
          i = 0;
          for( ; !(i >= words->num); i = i + 1)
          {
            ksiz = (words->array + (signed long int)(words->start + i))->dsize;
            kbuf = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
            seqmap=cbmapopenex((signed int)((unsigned long int)tsiz / sizeof(signed int) /*4ul*/  + (unsigned long int)1));
            tbuf=est_idx_scan(tgdb->idxdb, kbuf, ksiz, &tsiz, tgdb->smode);
            rp = tbuf;
            ep = tbuf + (signed long int)tsiz;
            while(!(rp >= ep))
            {
              do
              {
                signed int _EST_i;
                signed int _EST_base;
                oid = 0;
                _EST_base = 1;
                _EST_i = 0;
                for( ; (_Bool)1; _EST_i = _EST_i + 1)
                {
                  if((signed int)rp[(signed long int)_EST_i] >= 0)
                  {
                    oid = oid + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                    break;
                  }

                  oid = oid + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                  _EST_base = _EST_base * 128;
                }
                vstep = _EST_i + 1;
              }
              while((_Bool)0);
              rp = rp + (signed long int)vstep;
              vbuf=cbmapget(idmap, (char *)&oid, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
              if(!(vbuf == ((const char *)NULL)))
                tmp_if_expr$22 = *((signed int *)vbuf);

              else
                tmp_if_expr$22 = -1;
              nid = tmp_if_expr$22;
              sp = rp;
              if(!(tgdb->smode == 1048576))
              {
                if(tgdb->smode == 2097152 || tgdb->smode == 4194304)
                  goto __CPROVER_DUMP_L55;

              }

              else
                goto __CPROVER_DUMP_L56;
              rp = rp + 1l;
              goto __CPROVER_DUMP_L56;

            __CPROVER_DUMP_L55:
              ;
              rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

            __CPROVER_DUMP_L56:
              ;
              for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
                ;
              rp = rp + 1l;
              if(nid >= 1)
                cbmapputcat(seqmap, (char *)&nid, (signed int)sizeof(signed int) /*4ul*/ , sp, (signed int)(rp - sp));

            }
            anum=cbmaprnum(seqmap);
            void *return_value_malloc$23;
            return_value_malloc$23=malloc((unsigned long int)anum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
            ary = (signed int *)return_value_malloc$23;
            if(!(ary == ((signed int *)NULL)))
              ary;

            else
              cbmyfatal("out of memory");
            cbmapiterinit(seqmap);
            j = 0;
            do
            {
              rp=cbmapiternext(seqmap, (signed int *)(void *)0);
              if(rp == ((const char *)NULL))
                break;

              ary[(signed long int)j] = *((signed int *)rp);
              j = j + 1;
            }
            while((_Bool)1);
            qsort((void *)ary, (unsigned long int)anum, sizeof(signed int) /*4ul*/ , est_int_compare);
            do
            {
              void *return_value_malloc$24;
              return_value_malloc$24=malloc(sizeof(struct anonymous$2) /*16ul*/ );
              rbuf = (struct anonymous$2 *)return_value_malloc$24;
              if(!(rbuf == ((struct anonymous$2 *)NULL)))
                rbuf;

              else
                cbmyfatal("out of memory");
              void *return_value_malloc$25;
              return_value_malloc$25=malloc((unsigned long int)12);
              rbuf->dptr = (char *)return_value_malloc$25;
              if(!(rbuf->dptr == ((char *)NULL)))
                rbuf->dptr;

              else
                cbmyfatal("out of memory");
              rbuf->dptr[(signed long int)0] = (char)0;
              rbuf->dsize = 0;
              rbuf->asize = 12;
            }
            while((_Bool)0);
            j = 0;
            for( ; !(j >= anum); j = j + 1)
            {
              do
              {
                signed int _EST_num = ary[(signed long int)j];
                struct anonymous$15 EST_d;
                if(_EST_num == 0)
                {
                  ((signed char *)numbuf)[(signed long int)0] = (signed char)0;
                  vstep = 1;
                }

                else
                {
                  vstep = 0;
                  for( ; _EST_num >= 1; vstep = vstep + 1)
                  {
                    EST_d=div(_EST_num, 128);
                    _EST_num = EST_d.quot;
                    if(_EST_num >= 1)
                      ((signed char *)numbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

                    else
                      ((signed char *)numbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
                  }
                }
              }
              while((_Bool)0);
              do
              {
                if(rbuf->dsize + vstep >= rbuf->asize)
                {
                  rbuf->asize = rbuf->asize * 2 + vstep + 1;
                  void *return_value_realloc$26;
                  return_value_realloc$26=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                  rbuf->dptr = (char *)return_value_realloc$26;
                  if(!(rbuf->dptr == ((char *)NULL)))
                    rbuf->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)numbuf, (unsigned long int)vstep);
                rbuf->dsize = rbuf->dsize + vstep;
                rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
              }
              while((_Bool)0);
              vbuf=cbmapget(seqmap, (char *)(ary + (signed long int)j), (signed int)sizeof(signed int) /*4ul*/ , &vsiz);
              do
              {
                if(rbuf->dsize + vsiz >= rbuf->asize)
                {
                  rbuf->asize = rbuf->asize * 2 + vsiz + 1;
                  void *return_value_realloc$27;
                  return_value_realloc$27=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                  rbuf->dptr = (char *)return_value_realloc$27;
                  if(!(rbuf->dptr == ((char *)NULL)))
                    rbuf->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)vbuf, (unsigned long int)vsiz);
                rbuf->dsize = rbuf->dsize + vsiz;
                rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
              }
              while((_Bool)0);
            }
            signed int return_value_est_idx_add$28;
            return_value_est_idx_add$28=est_idx_add(db->idxdb, kbuf, ksiz, (const char *)rbuf->dptr, (signed int)rbuf->dsize, db->smode);
            if(return_value_est_idx_add$28 == 0)
            {
              est_set_ecode(&db->ecode, 4, 2065);
              db->fatal = 1;
              err = 1;
            }

            do
            {
              free((void *)rbuf->dptr);
              free((void *)rbuf);
            }
            while((_Bool)0);
            free((void *)ary);
            cbmapclose(seqmap);
            free((void *)tbuf);
            vlput(db->fwmdb, kbuf, ksiz, "", 0, 1);
            if(i % 10000 == 0)
            {
              est_db_inform(db, "importing words");
              signed int return_value_est_idx_size_current$29;
              return_value_est_idx_size_current$29=est_idx_size_current(db->idxdb);
              if(return_value_est_idx_size_current$29 >= 1536)
              {
                est_db_inform(db, "adding a new database file");
                est_idx_increment(db->idxdb);
              }

            }

          }
          do
          {
            signed int _CB_i;
            signed int _CB_end = words->start + words->num;
            _CB_i = words->start;
            for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
              free((void *)(words->array + (signed long int)_CB_i)->dptr);
            free((void *)words->array);
            free((void *)words);
          }
          while((_Bool)0);
          do
          {
            void *return_value_malloc$30;
            return_value_malloc$30=malloc(sizeof(struct anonymous$1) /*24ul*/ );
            words = (struct anonymous$1 *)return_value_malloc$30;
            if(!(words == ((struct anonymous$1 *)NULL)))
              words;

            else
              cbmyfatal("out of memory");
            words->anum = 64;
            void *return_value_malloc$31;
            return_value_malloc$31=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
            words->array = (struct anonymous$28 *)return_value_malloc$31;
            if(!(words->array == ((struct anonymous$28 *)NULL)))
              words->array;

            else
              cbmyfatal("out of memory");
            words->start = 0;
            words->num = 0;
          }
          while((_Bool)0);
          vlcurfirst(tgdb->auxdb);
          do
          {
            kbuf=vlcurkeycache(tgdb->auxdb, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            do
            {
              signed int _CB_index = words->start + words->num;
              if(_CB_index >= words->anum)
              {
                words->anum = words->anum * 2;
                void *return_value_realloc$32;
                return_value_realloc$32=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
                words->array = (struct anonymous$28 *)return_value_realloc$32;
                if(!(words->array == ((struct anonymous$28 *)NULL)))
                  words->array;

                else
                  cbmyfatal("out of memory");
              }

              void *return_value_malloc$33;
              return_value_malloc$33=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
              (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$33;
              if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                (words->array + (signed long int)_CB_index)->dptr;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
              (words->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
              (words->array + (signed long int)_CB_index)->dsize = ksiz;
              words->num = words->num + 1;
            }
            while((_Bool)0);
            vlcurnext(tgdb->auxdb);
          }
          while((_Bool)1);
          i = 0;
          for( ; !(i >= words->num); i = i + 1)
          {
            ksiz = (words->array + (signed long int)(words->start + i))->dsize;
            kbuf = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
            vbuf=vlgetcache(tgdb->auxdb, kbuf, ksiz, &vsiz);
            do
            {
              void *return_value_malloc$34;
              return_value_malloc$34=malloc(sizeof(struct anonymous$2) /*16ul*/ );
              rbuf = (struct anonymous$2 *)return_value_malloc$34;
              if(!(rbuf == ((struct anonymous$2 *)NULL)))
                rbuf;

              else
                cbmyfatal("out of memory");
              void *return_value_malloc$35;
              return_value_malloc$35=malloc((unsigned long int)12);
              rbuf->dptr = (char *)return_value_malloc$35;
              if(!(rbuf->dptr == ((char *)NULL)))
                rbuf->dptr;

              else
                cbmyfatal("out of memory");
              rbuf->dptr[(signed long int)0] = (char)0;
              rbuf->dsize = 0;
              rbuf->asize = 12;
            }
            while((_Bool)0);
            rp = vbuf;
            ep = vbuf + (signed long int)vsiz;
            for( ; !(rp >= ep); rp = rp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2))
            {
              oid = *((signed int *)rp);
              vbuf=cbmapget(idmap, rp, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
              if(!(vbuf == ((const char *)NULL)))
                tmp_if_expr$36 = *((signed int *)vbuf);

              else
                tmp_if_expr$36 = -1;
              nid = tmp_if_expr$36;
              if(nid >= 1)
              {
                do
                {
                  if(sizeof(signed int) /*4ul*/  + (unsigned long int)rbuf->dsize >= (unsigned long int)rbuf->asize)
                  {
                    rbuf->asize = (signed int)((unsigned long int)(rbuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                    void *return_value_realloc$37;
                    return_value_realloc$37=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                    rbuf->dptr = (char *)return_value_realloc$37;
                    if(!(rbuf->dptr == ((char *)NULL)))
                      rbuf->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)(char *)&nid, sizeof(signed int) /*4ul*/ );
                  rbuf->dsize = rbuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
                  rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
                }
                while((_Bool)0);
                do
                {
                  if(sizeof(signed int) /*4ul*/  + (unsigned long int)rbuf->dsize >= (unsigned long int)rbuf->asize)
                  {
                    rbuf->asize = (signed int)((unsigned long int)(rbuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                    void *return_value_realloc$38;
                    return_value_realloc$38=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
                    rbuf->dptr = (char *)return_value_realloc$38;
                    if(!(rbuf->dptr == ((char *)NULL)))
                      rbuf->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)(rp + (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
                  rbuf->dsize = rbuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
                  rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
                }
                while((_Bool)0);
              }

            }
            signed int return_value_vlput$39;
            return_value_vlput$39=vlput(db->auxdb, kbuf, ksiz, (const char *)rbuf->dptr, (signed int)rbuf->dsize, 2);
            if(return_value_vlput$39 == 0)
            {
              est_set_ecode(&db->ecode, 4, 2106);
              db->fatal = 1;
              err = 1;
            }

            do
            {
              free((void *)rbuf->dptr);
              free((void *)rbuf);
            }
            while((_Bool)0);
            anum = 0;
            vbuf=vlgetcache(tgdb->xfmdb, kbuf, ksiz, (signed int *)(void *)0);
            if(!(vbuf == ((const char *)NULL)))
            {
              return_value_atoi$40=atoi(vbuf);
              anum = anum + return_value_atoi$40;
            }

            len=sprintf(numbuf, "%d", anum);
            vlput(db->xfmdb, kbuf, ksiz, numbuf, len, 0);
            if(i % 10000 == 0)
              est_db_inform(db, "importing auxiliary words");

          }
          do
          {
            signed int est_db_merge$$1$$14$$_CB_i;
            signed int est_db_merge$$1$$14$$_CB_end = words->start + words->num;
            est_db_merge$$1$$14$$_CB_i = words->start;
            for( ; !(est_db_merge$$1$$14$$_CB_i >= est_db_merge$$1$$14$$_CB_end); est_db_merge$$1$$14$$_CB_i = est_db_merge$$1$$14$$_CB_i + 1)
              free((void *)(words->array + (signed long int)est_db_merge$$1$$14$$_CB_i)->dptr);
            free((void *)words->array);
            free((void *)words);
          }
          while((_Bool)0);
          cbmapclose(idmap);
          est_db_inform(db, "closing the target database");
          signed int return_value_est_db_close$41;
          return_value_est_db_close$41=est_db_close(tgdb, &ecode);
          if(return_value_est_db_close$41 == 0)
          {
            est_set_ecode(&db->ecode, ecode, 2121);
            return 0;
          }

          else
          {
            signed int return_value_est_db_flush$42;
            return_value_est_db_flush$42=est_db_flush(db, -1);
            if(return_value_est_db_flush$42 == 0)
              err = 1;

            return err != 0 ? 0 : 1;
          }
        }
      }
    }
  }
}

// est_db_meta
// file estraier.c line 4549
char * est_db_meta(struct anonymous *db, const char *name)
{
  const char *vbuf;
  signed int vsiz;
  if(db->metacc == ((struct anonymous$9 *)NULL))
    est_db_prepare_meta(db);

  vbuf=cbmapget(db->metacc, name, -1, &vsiz);
  if(vbuf == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_cbmemdup$1;
    return_value_cbmemdup$1=cbmemdup(vbuf, vsiz);
    return return_value_cbmemdup$1;
  }
}

// est_db_meta_names
// file estraier.c line 4541
struct anonymous$1 * est_db_meta_names(struct anonymous *db)
{
  if(db->metacc == ((struct anonymous$9 *)NULL))
    est_db_prepare_meta(db);

  struct anonymous$1 *return_value_cbmapkeys$1;
  return_value_cbmapkeys$1=cbmapkeys(db->metacc);
  return return_value_cbmapkeys$1;
}

// est_db_name
// file estraier.c line 2695
const char * est_db_name(struct anonymous *db)
{
  return db->name;
}

// est_db_open
// file estraier.c line 914
struct anonymous * est_db_open(const char *name, signed int omode, signed int *ecp)
{
  struct anonymous *db;
  struct anonymous$5 *metadb;
  struct anonymous$3 *idxdb;
  struct anonymous$4 *attrdb;
  struct anonymous$4 *textdb;
  struct anonymous$4 *kwddb;
  struct anonymous$7 *fwmdb;
  struct anonymous$7 *auxdb;
  struct anonymous$7 *xfmdb;
  struct anonymous$7 *listdb;
  struct anonymous$9 *aidxs;
  struct anonymous$1 *list;
  struct anonymous$16 attridx;
  void *aidxdb;
  const char *elem;
  char path[4096l];
  char vbuf[32l];
  char *dec;
  signed int i;
  signed int inode;
  signed int domode;
  signed int comode;
  signed int vomode;
  signed int flags;
  signed int idxnum;
  signed int dseq;
  signed int dnum;
  signed int amode;
  signed int zmode;
  signed int smode;
  signed int vsiz;
  signed int type;
  signed int crdnum;
  double bdiam;
  double ddiam;
  if(est_inodes == ((struct anonymous$9 *)NULL))
  {
    est_inodes=cbmapopenex(31);
    cbglobalgc((void *)est_inodes, est_inodes_delete);
  }

  est_set_ecode(ecp, 0, 934);
  signed int return_value_est_mkdir$2;
  if(!((2 & omode) == 0) && !((4 & omode) == 0))
  {
    return_value_est_mkdir$2=est_mkdir(name);
    if(return_value_est_mkdir$2 == 0)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      switch(*return_value___errno_location$1)
      {
        case 13:
        {
          est_set_ecode(ecp, 2, 938);
          return (struct anonymous *)(void *)0;
        }
        case 17:
          break;
        default:
        {
          est_set_ecode(ecp, 5, 943);
          return (struct anonymous *)(void *)0;
        }
      }
    }

  }

  inode=est_inode(name);
  _Bool tmp_if_expr$15;
  signed int return_value_cbstrfwmatch$14;
  _Bool tmp_if_expr$17;
  signed int return_value_cbstrfwmatch$16;
  signed int return_value_cbstrfwmatch$22;
  signed int return_value_cbstrfwmatch$21;
  struct anonymous$7 *return_value_vlopen$24;
  struct anonymous$7 *return_value_vlopen$25;
  signed int return_value_crbnum$26;
  struct anonymous$5 *return_value_dpopen$27;
  if(!(inode >= 1))
  {
    est_set_ecode(ecp, 5, 948);
    return (struct anonymous *)(void *)0;
  }

  else
  {
    const char *return_value_cbmapget$3;
    return_value_cbmapget$3=cbmapget(est_inodes, (char *)&inode, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
    if(!(return_value_cbmapget$3 == ((const char *)NULL)))
    {
      if(!((16 & omode) == 0))
        goto __CPROVER_DUMP_L8;

      est_set_ecode(ecp, 2, 952);
      return (struct anonymous *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      domode = 1;
      comode = 1;
      vomode = 1;
      if(!((2 & omode) == 0))
      {
        domode = 2;
        comode = 2;
        vomode = 2;
        vomode = vomode | 64;
        if(!((4 & omode) == 0))
        {
          domode = domode | 4;
          comode = comode | 4;
          vomode = vomode | 4;
        }

        if(!((8 & omode) == 0))
        {
          domode = domode | 8;
          comode = comode | 8;
          vomode = vomode | 8;
        }

      }

      if(!((16 & omode) == 0))
      {
        domode = domode | 16;
        comode = comode | 16;
        vomode = vomode | 16;
      }

      if(!((32 & omode) == 0))
      {
        domode = domode | 32;
        comode = comode | 32;
        vomode = vomode | 32;
      }

      flags = 0;
      idxnum = 0;
      dseq = 0;
      dnum = 0;
      amode = 0;
      zmode = 0;
      smode = 0;
      if(!((1048576 & omode) == 0))
      {
        bdiam = 0.3;
        ddiam = 0.4;
      }

      else
        if(!((2097152 & omode) == 0))
        {
          bdiam = 3.0;
          ddiam = 1.0;
        }

        else
          if(!((4194304 & omode) == 0))
          {
            bdiam = 5.0;
            ddiam = 2.0;
          }

          else
            if(!((8388608 & omode) == 0))
            {
              bdiam = 5.0 * 1.4;
              ddiam = 2.0 * 1.4;
            }

            else
              if(!((16777216 & omode) == 0))
              {
                bdiam = 5.0 * 2.0;
                ddiam = 2.0 * 2.0;
              }

              else
              {
                bdiam = 1.0;
                ddiam = 1.0;
              }
      sprintf(path, "%s%c%s", name, 47, (const void *)"_meta");
      metadb=dpopen(path, domode, 31);
      if(!(metadb == ((struct anonymous$5 *)NULL)))
      {
        flags=dpgetflags(metadb);
        signed int return_value_dprnum$4;
        return_value_dprnum$4=dprnum(metadb);
        if(!(return_value_dprnum$4 >= 1))
        {
          if(!((1024 & omode) == 0))
            flags = flags | 1024;

          else
            if(!((2048 & omode) == 0))
              flags = flags | 2048;

          flags = flags | 32768;
          if(!((33554432 & omode) == 0))
            flags = flags | 1048576;

          else
            if(!((67108864 & omode) == 0))
              flags = flags | 2097152;

            else
              if(!((134217728 & omode) == 0))
                flags = flags | 4194304;

          dpsetflags(metadb, flags);
        }

        vsiz=dpgetwb(metadb, "_idxnum", -1, 0, 32 - 1, vbuf);
        if(vsiz >= 1)
        {
          vbuf[(signed long int)vsiz] = (char)0;
          idxnum=atoi(vbuf);
        }

        vsiz=dpgetwb(metadb, "_dseq", -1, 0, 32 - 1, vbuf);
        if(vsiz >= 1)
        {
          vbuf[(signed long int)vsiz] = (char)0;
          dseq=atoi(vbuf);
        }

        vsiz=dpgetwb(metadb, "_dnum", -1, 0, 32 - 1, vbuf);
        if(vsiz >= 1)
        {
          vbuf[(signed long int)vsiz] = (char)0;
          dnum=atoi(vbuf);
        }

        if(!((1024 & flags) == 0))
          amode = 1024;

        else
          if(!((2048 & flags) == 0))
            amode = 2048;

        if(!((32768 & flags) == 0))
          zmode = 32768;

        else
          if(!((65536 & flags) == 0))
            zmode = 65536;

          else
            if(!((131072 & flags) == 0))
              zmode = 131072;

        if(!((1048576 & flags) == 0))
          smode = 1048576;

        else
          if(!((2097152 & flags) == 0))
            smode = 2097152;

          else
            if(!((4194304 & flags) == 0))
              smode = 4194304;

      }

      else
      {
        signed int *return_value_dpecodeptr$5;
        return_value_dpecodeptr$5=dpecodeptr();
        est_set_ecode(ecp, *return_value_dpecodeptr$5 == 16 ? 3 : 4, 1073);
        return (struct anonymous *)(void *)0;
      }
      if(!(idxnum >= 1))
        idxnum = 1;

      if(!(dseq >= 0))
        dseq = 0;

      if(!(dnum >= 0))
        dnum = 0;

      signed int *return_value_vlcrdnumptr$6;
      return_value_vlcrdnumptr$6=vlcrdnumptr();
      crdnum = *return_value_vlcrdnumptr$6;
      sprintf(path, "%s%c%s", name, 47, (const void *)"_idx");
      idxdb=est_idx_open(path, vomode, idxnum);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_fwm");
      signed int *return_value_vlcrdnumptr$7;
      return_value_vlcrdnumptr$7=vlcrdnumptr();
      *return_value_vlcrdnumptr$7 = 2;
      fwmdb=vlopen(path, vomode, VL_CMPLEX);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_aux");
      signed int *return_value_vlcrdnumptr$8;
      return_value_vlcrdnumptr$8=vlcrdnumptr();
      *return_value_vlcrdnumptr$8 = 7;
      auxdb=vlopen(path, vomode, VL_CMPLEX);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_xfm");
      signed int *return_value_vlcrdnumptr$9;
      return_value_vlcrdnumptr$9=vlcrdnumptr();
      *return_value_vlcrdnumptr$9 = 2;
      xfmdb=vlopen(path, vomode, VL_CMPLEX);
      sprintf(path, "%s%c%s", name, 47, (const void *)"_attr");
      attrdb=cropen(path, comode, (signed int)((double)212987 * bdiam), (signed int)((double)3 * ddiam));
      sprintf(path, "%s%c%s", name, 47, (const void *)"_text");
      textdb=cropen(path, comode, (signed int)((double)61417 * bdiam), (signed int)((double)7 * ddiam));
      sprintf(path, "%s%c%s", name, 47, (const void *)"_kwd");
      kwddb=cropen(path, comode, (signed int)((double)163819 * bdiam), (signed int)((double)3 * ddiam));
      sprintf(path, "%s%c%s", name, 47, (const void *)"_list");
      signed int *return_value_vlcrdnumptr$10;
      return_value_vlcrdnumptr$10=vlcrdnumptr();
      *return_value_vlcrdnumptr$10 = 2;
      listdb=vlopen(path, vomode, VL_CMPLEX);
      signed int *return_value_vlcrdnumptr$11;
      return_value_vlcrdnumptr$11=vlcrdnumptr();
      *return_value_vlcrdnumptr$11 = crdnum;
      if(idxdb == ((struct anonymous$3 *)NULL) || attrdb == ((struct anonymous$4 *)NULL) || kwddb == ((struct anonymous$4 *)NULL) || textdb == ((struct anonymous$4 *)NULL) || auxdb == ((struct anonymous$7 *)NULL) || fwmdb == ((struct anonymous$7 *)NULL) || listdb == ((struct anonymous$7 *)NULL) || xfmdb == ((struct anonymous$7 *)NULL))
      {
        if(!(listdb == ((struct anonymous$7 *)NULL)))
          vlclose(listdb);

        if(!(kwddb == ((struct anonymous$4 *)NULL)))
          crclose(kwddb);

        if(!(textdb == ((struct anonymous$4 *)NULL)))
          crclose(textdb);

        if(!(attrdb == ((struct anonymous$4 *)NULL)))
          crclose(attrdb);

        if(!(xfmdb == ((struct anonymous$7 *)NULL)))
          vlclose(xfmdb);

        if(!(auxdb == ((struct anonymous$7 *)NULL)))
          vlclose(auxdb);

        if(!(fwmdb == ((struct anonymous$7 *)NULL)))
          vlclose(fwmdb);

        if(!(idxdb == ((struct anonymous$3 *)NULL)))
          est_idx_close(idxdb);

        dpclose(metadb);
        est_set_ecode(ecp, 4, 1111);
        return (struct anonymous *)(void *)0;
      }

      else
      {
        if(!((2 & omode) == 0))
        {
          est_idx_set_tuning(idxdb, amode == 1024 ? 17 : 109, 160, 16, 16, 512);
          est_idx_set_current(idxdb);
          vlsettuning(fwmdb, 251, 110, 32, 16);
          vlsetfbpsiz(fwmdb, 128);
          vlsettuning(auxdb, 23, 160, 16, 16);
          vlsetfbpsiz(auxdb, 256);
          vlsettuning(xfmdb, 111, 110, 32, 16);
          vlsetfbpsiz(xfmdb, 128);
          crsetalign(attrdb, -5);
          crsetfbpsiz(attrdb, 64);
          crsetalign(textdb, -5);
          crsetfbpsiz(textdb, 128);
          crsetalign(kwddb, -5);
          crsetfbpsiz(kwddb, 64);
          vlsettuning(listdb, 99, 200, 64, 16);
          vlsetfbpsiz(listdb, 128);
        }

        else
        {
          est_idx_set_tuning(idxdb, -1, -1, amode == 1024 ? 32 : 128, 256, -1);
          vlsettuning(fwmdb, -1, -1, 32, 16);
          vlsettuning(auxdb, -1, -1, 256, 64);
          vlsettuning(xfmdb, -1, -1, 32, 16);
          vlsettuning(listdb, -1, -1, 64, 16);
        }
        if(!((2 & omode) == 0) && !((8 & omode) == 0))
        {
          list=cbdirlist(name);
          if(!(list == ((struct anonymous$1 *)NULL)))
          {
            i = 0;
            for( ; !(i >= list->num); i = i + 1)
            {
              elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
              signed int return_value_cbstrfwmatch$13;
              return_value_cbstrfwmatch$13=cbstrfwmatch(elem, "__seq_");
              if(!(return_value_cbstrfwmatch$13 == 0))
                tmp_if_expr$15 = (_Bool)1;

              else
              {
                return_value_cbstrfwmatch$14=cbstrfwmatch(elem, "__str_");
                tmp_if_expr$15 = return_value_cbstrfwmatch$14 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$15)
                tmp_if_expr$17 = (_Bool)1;

              else
              {
                return_value_cbstrfwmatch$16=cbstrfwmatch(elem, "__num_");
                tmp_if_expr$17 = return_value_cbstrfwmatch$16 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$17)
              {
                sprintf(path, "%s%c%s", name, 47, elem);
                signed int return_value_unlink$12;
                return_value_unlink$12=unlink(path);
                if(return_value_unlink$12 == -1)
                  est_rmdir_rec(path);

              }

            }
            do
            {
              signed int _CB_i;
              signed int _CB_end = list->start + list->num;
              _CB_i = list->start;
              for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                free((void *)(list->array + (signed long int)_CB_i)->dptr);
              free((void *)list->array);
              free((void *)list);
            }
            while((_Bool)0);
          }

        }

        aidxs=cbmapopenex(31);
        list=cbdirlist(name);
        if(!(list == ((struct anonymous$1 *)NULL)))
        {
          i = 0;
          for( ; !(i >= list->num); i = i + 1)
          {
            elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
            dec = (char *)(void *)0;
            type = -1;
            signed int return_value_cbstrfwmatch$23;
            return_value_cbstrfwmatch$23=cbstrfwmatch(elem, "__seq_");
            if(!(return_value_cbstrfwmatch$23 == 0))
            {
              unsigned long int return_value_strlen$18;
              return_value_strlen$18=strlen("__seq_");
              dec=est_hex_decode(elem + (signed long int)return_value_strlen$18);
              type = 0;
            }

            else
            {
              return_value_cbstrfwmatch$22=cbstrfwmatch(elem, "__str_");
              if(!(return_value_cbstrfwmatch$22 == 0))
              {
                unsigned long int return_value_strlen$19;
                return_value_strlen$19=strlen("__str_");
                dec=est_hex_decode(elem + (signed long int)return_value_strlen$19);
                type = 1;
              }

              else
              {
                return_value_cbstrfwmatch$21=cbstrfwmatch(elem, "__num_");
                if(!(return_value_cbstrfwmatch$21 == 0))
                {
                  unsigned long int return_value_strlen$20;
                  return_value_strlen$20=strlen("__num_");
                  dec=est_hex_decode(elem + (signed long int)return_value_strlen$20);
                  type = 2;
                }

              }
            }
            if(!(dec == ((char *)NULL)))
            {
              sprintf(path, "%s%c%s", name, 47, elem);
              switch(type)
              {
                case 1:
                {
                  return_value_vlopen$24=vlopen(path, vomode, VL_CMPLEX);
                  aidxdb = (void *)return_value_vlopen$24;
                  if(!(aidxdb == NULL))
                  {
                    vlsettuning((struct anonymous$7 *)aidxdb, 99, 120, 1024, 256);
                    vlsetfbpsiz((struct anonymous$7 *)aidxdb, 128);
                    attridx.db = aidxdb;
                    attridx.type = type;
                    cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous$16) /*16ul*/ , 0);
                  }

                  break;
                }
                case 2:
                {
                  return_value_vlopen$25=vlopen(path, vomode, est_aidx_numcmp);
                  aidxdb = (void *)return_value_vlopen$25;
                  if(!(aidxdb == NULL))
                  {
                    vlsettuning((struct anonymous$7 *)aidxdb, 99, 120, 1024, 256);
                    vlsetfbpsiz((struct anonymous$7 *)aidxdb, 128);
                    attridx.db = aidxdb;
                    attridx.type = type;
                    cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous$16) /*16ul*/ , 0);
                  }

                  break;
                }
                default:
                {
                  return_value_crbnum$26=crbnum(attrdb);
                  return_value_dpopen$27=dpopen(path, domode, (signed int)((double)return_value_crbnum$26 / 0.8));
                  aidxdb = (void *)return_value_dpopen$27;
                  if(!(aidxdb == NULL))
                  {
                    dpsetfbpsiz((struct anonymous$5 *)aidxdb, 32);
                    attridx.db = aidxdb;
                    attridx.type = type;
                    cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous$16) /*16ul*/ , 0);
                  }

                }
              }
              free((void *)dec);
            }

          }
          do
          {
            signed int est_db_open$$1$$20$$2$$_CB_i;
            signed int est_db_open$$1$$20$$2$$_CB_end = list->start + list->num;
            est_db_open$$1$$20$$2$$_CB_i = list->start;
            for( ; !(est_db_open$$1$$20$$2$$_CB_i >= est_db_open$$1$$20$$2$$_CB_end); est_db_open$$1$$20$$2$$_CB_i = est_db_open$$1$$20$$2$$_CB_i + 1)
              free((void *)(list->array + (signed long int)est_db_open$$1$$20$$2$$_CB_i)->dptr);
            free((void *)list->array);
            free((void *)list);
          }
          while((_Bool)0);
        }

        void *return_value_malloc$28;
        return_value_malloc$28=malloc(sizeof(struct anonymous) /*336ul*/ );
        db = (struct anonymous *)return_value_malloc$28;
        if(!(db == ((struct anonymous *)NULL)))
          db;

        else
          cbmyfatal("out of memory");
        db->name=cbmemdup(name, -1);
        db->inode = inode;
        db->metadb = metadb;
        db->idxdb = idxdb;
        db->fwmdb = fwmdb;
        db->auxdb = auxdb;
        db->xfmdb = xfmdb;
        db->attrdb = attrdb;
        db->textdb = textdb;
        db->kwddb = kwddb;
        db->listdb = listdb;
        db->aidxs = aidxs;
        do
        {
          void *return_value_malloc$29;
          return_value_malloc$29=malloc(sizeof(struct anonymous$1) /*24ul*/ );
          db->pdocs = (struct anonymous$1 *)return_value_malloc$29;
          if(!(db->pdocs == ((struct anonymous$1 *)NULL)))
            db->pdocs;

          else
            cbmyfatal("out of memory");
          db->pdocs->anum = 64;
          void *return_value_malloc$30;
          return_value_malloc$30=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)db->pdocs->anum);
          db->pdocs->array = (struct anonymous$28 *)return_value_malloc$30;
          if(!(db->pdocs->array == ((struct anonymous$28 *)NULL)))
            db->pdocs->array;

          else
            cbmyfatal("out of memory");
          db->pdocs->start = 0;
          db->pdocs->num = 0;
        }
        while((_Bool)0);
        db->puris = (struct anonymous$9 *)(void *)0;
        est_set_ecode(&db->ecode, 0, 1217);
        db->fatal = 0;
        db->dseq = dseq;
        db->dnum = dnum;
        db->amode = amode;
        db->zmode = zmode;
        db->smode = smode;
        if(!((2 & omode) == 0))
        {
          db->idxcc=cbmapopenex(524288);
          db->auxcc=cbmapopenex(65521);
          db->icsiz = (unsigned long int)0;
          db->icmax = (unsigned long int)(1048576 * 64);
          db->outcc=cbmapopenex(131072);
        }

        else
        {
          db->idxcc=cbmapopenex(1);
          db->auxcc=cbmapopenex(1);
          db->icsiz = (unsigned long int)0;
          db->icmax = (unsigned long int)0;
          db->outcc=cbmapopenex(1);
        }
        db->keycc=cbmapopenex(65536 + 1);
        db->kcmnum = 65536;
        db->attrcc=cbmapopenex(8192 + 1);
        db->acmnum = 8192;
        db->textcc=cbmapopenex(1024 + 1);
        db->tcmnum = 1024;
        db->veccc=cbmapopenex(8192 / 2 + 1);
        db->vcmnum = 8192 / 2;
        db->rescc=cbmapopenex(256 * 2 + 1);
        db->rcmnum = 256;
        db->spacc = (struct anonymous$9 *)(void *)0;
        db->scmnum = 0;
        db->scname = (char *)(void *)0;
        db->infocb = (void (*)(const char *, void *))(void *)0;
        db->infoop = (void *)0;
        db->dfdb = (struct anonymous$5 *)(void *)0;
        db->metacc = (struct anonymous$9 *)(void *)0;
        db->wildmax = 256;
        db->flsflag = 0;
        db->intflag = 0;
        cbmapput(est_inodes, (char *)&inode, (signed int)sizeof(signed int) /*4ul*/ , (char *)&db, (signed int)sizeof(struct anonymous *) /*8ul*/ , 0);
        return db;
      }
    }
  }
}

// est_db_optimize
// file estraier.c line 1742
signed int est_db_optimize(struct anonymous *db, signed int options)
{
  struct anonymous$9 *dmap;
  struct anonymous$1 *words;
  struct anonymous$2 *nval;
  struct anonymous$16 *attridx;
  const char *word;
  const char *rp;
  const char *pv;
  const char *ep;
  char *kbuf;
  char *vbuf;
  char *wp;
  char numbuf[32l];
  signed int i;
  signed int err;
  signed int id;
  signed int ksiz;
  signed int vsiz;
  signed int wsiz;
  signed int len;
  signed int vstep;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  signed int *return_value_dpecodeptr$21;
  signed int return_value_vloptimize$32;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1752);
    return 0;
  }

  else
  {
    signed int return_value_est_db_flush$2;
    return_value_est_db_flush$2=est_db_flush(db, -1);
    if(return_value_est_db_flush$2 == 0)
      return 0;

    else
    {
      err = 0;
      if((1 & options) == 0)
      {
        signed int return_value_vlrnum$3;
        return_value_vlrnum$3=vlrnum(db->listdb);
        dmap=cbmapopenex(return_value_vlrnum$3 + 1);
        vlcurfirst(db->listdb);
        do
        {
          vbuf=vlcurval(db->listdb, (signed int *)(void *)0);
          if(vbuf == ((char *)NULL))
            break;

          id=atoi(vbuf);
          cbmapput(dmap, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , "", 0, 0);
          free((void *)vbuf);
          vlcurnext(db->listdb);
        }
        while((_Bool)1);
        do
        {
          void *return_value_malloc$4;
          return_value_malloc$4=malloc(sizeof(struct anonymous$1) /*24ul*/ );
          words = (struct anonymous$1 *)return_value_malloc$4;
          if(!(words == ((struct anonymous$1 *)NULL)))
            words;

          else
            cbmyfatal("out of memory");
          words->anum = 64;
          void *return_value_malloc$5;
          return_value_malloc$5=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
          words->array = (struct anonymous$28 *)return_value_malloc$5;
          if(!(words->array == ((struct anonymous$28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
          words->start = 0;
          words->num = 0;
        }
        while((_Bool)0);
        vlcurfirst(db->fwmdb);
        do
        {
          kbuf=vlcurkey(db->fwmdb, &ksiz);
          if(kbuf == ((char *)NULL))
            break;

          do
          {
            signed int est_db_optimize$$1$$2$$3$$1$$_CB_index = words->start + words->num;
            if(est_db_optimize$$1$$2$$3$$1$$_CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc$6;
              return_value_realloc$6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
              words->array = (struct anonymous$28 *)return_value_realloc$6;
              if(!(words->array == ((struct anonymous$28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            (words->array + (signed long int)est_db_optimize$$1$$2$$3$$1$$_CB_index)->dptr = kbuf;
            (words->array + (signed long int)est_db_optimize$$1$$2$$3$$1$$_CB_index)->dsize = ksiz;
            words->num = words->num + 1;
          }
          while((_Bool)0);
          vlcurnext(db->fwmdb);
        }
        while((_Bool)1);
        i = 0;
        for( ; !(i >= words->num); i = i + 1)
        {
          if(i % 4 == 0)
            est_idx_set_current(db->idxdb);

          wsiz = (words->array + (signed long int)(words->start + i))->dsize;
          word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
          vbuf=est_idx_scan(db->idxdb, word, wsiz, &vsiz, db->smode);
          do
          {
            void *return_value_malloc$7;
            return_value_malloc$7=malloc(sizeof(struct anonymous$2) /*16ul*/ );
            nval = (struct anonymous$2 *)return_value_malloc$7;
            if(!(nval == ((struct anonymous$2 *)NULL)))
              nval;

            else
              cbmyfatal("out of memory");
            void *return_value_malloc$8;
            return_value_malloc$8=malloc((unsigned long int)12);
            nval->dptr = (char *)return_value_malloc$8;
            if(!(nval->dptr == ((char *)NULL)))
              nval->dptr;

            else
              cbmyfatal("out of memory");
            nval->dptr[(signed long int)0] = (char)0;
            nval->dsize = 0;
            nval->asize = 12;
          }
          while((_Bool)0);
          rp = vbuf;
          ep = vbuf + (signed long int)vsiz;
          while(!(rp >= ep))
          {
            pv = rp;
            do
            {
              signed int _EST_i;
              signed int _EST_base;
              id = 0;
              _EST_base = 1;
              _EST_i = 0;
              for( ; (_Bool)1; _EST_i = _EST_i + 1)
              {
                if((signed int)rp[(signed long int)_EST_i] >= 0)
                {
                  id = id + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                  break;
                }

                id = id + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                _EST_base = _EST_base * 128;
              }
              vstep = _EST_i + 1;
            }
            while((_Bool)0);
            rp = rp + (signed long int)vstep;
            if(!(db->smode == 1048576))
            {
              if(db->smode == 2097152 || db->smode == 4194304)
                goto __CPROVER_DUMP_L29;

            }

            else
              goto __CPROVER_DUMP_L30;
            rp = rp + 1l;
            goto __CPROVER_DUMP_L30;

          __CPROVER_DUMP_L29:
            ;
            rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

          __CPROVER_DUMP_L30:
            ;
            for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
              ;
            rp = rp + 1l;
            const char *return_value_cbmapget$10;
            return_value_cbmapget$10=cbmapget(dmap, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
            if(!(return_value_cbmapget$10 == ((const char *)NULL)))
              do
              {
                if((rp - pv) + (signed long int)nval->dsize >= (signed long int)nval->asize)
                {
                  nval->asize = (signed int)((signed long int)(nval->asize * 2) + (rp - pv) + (signed long int)1);
                  void *return_value_realloc$9;
                  return_value_realloc$9=realloc((void *)nval->dptr, (unsigned long int)nval->asize);
                  nval->dptr = (char *)return_value_realloc$9;
                  if(!(nval->dptr == ((char *)NULL)))
                    nval->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(nval->dptr + (signed long int)nval->dsize), (const void *)pv, (unsigned long int)(rp - pv));
                nval->dsize = nval->dsize + (signed int)(rp - pv);
                nval->dptr[(signed long int)nval->dsize] = (char)0;
              }
              while((_Bool)0);

          }
          signed int return_value_est_idx_out$11;
          return_value_est_idx_out$11=est_idx_out(db->idxdb, word, wsiz);
          if(return_value_est_idx_out$11 == 0)
            err = 1;

          if(nval->dsize >= 1)
          {
            signed int return_value_est_idx_add$12;
            return_value_est_idx_add$12=est_idx_add(db->idxdb, word, wsiz, (const char *)nval->dptr, (signed int)nval->dsize, db->smode);
            if(return_value_est_idx_add$12 == 0)
              err = 1;

          }

          else
          {
            signed int return_value_vlout$13;
            return_value_vlout$13=vlout(db->fwmdb, word, wsiz);
            if(return_value_vlout$13 == 0)
              err = 1;

          }
          do
          {
            free((void *)nval->dptr);
            free((void *)nval);
          }
          while((_Bool)0);
          free((void *)vbuf);
          free((void *)kbuf);
          if(i % 10000 == 0)
            est_db_inform(db, "cleaning dispensable keys");

        }
        do
        {
          signed int est_db_optimize$$1$$2$$5$$_CB_i;
          signed int _CB_end = words->start + words->num;
          est_db_optimize$$1$$2$$5$$_CB_i = words->start;
          for( ; !(est_db_optimize$$1$$2$$5$$_CB_i >= _CB_end); est_db_optimize$$1$$2$$5$$_CB_i = est_db_optimize$$1$$2$$5$$_CB_i + 1)
            free((void *)(words->array + (signed long int)est_db_optimize$$1$$2$$5$$_CB_i)->dptr);
          free((void *)words->array);
          free((void *)words);
        }
        while((_Bool)0);
        do
        {
          void *return_value_malloc$14;
          return_value_malloc$14=malloc(sizeof(struct anonymous$1) /*24ul*/ );
          words = (struct anonymous$1 *)return_value_malloc$14;
          if(!(words == ((struct anonymous$1 *)NULL)))
            words;

          else
            cbmyfatal("out of memory");
          words->anum = 64;
          void *return_value_malloc$15;
          return_value_malloc$15=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
          words->array = (struct anonymous$28 *)return_value_malloc$15;
          if(!(words->array == ((struct anonymous$28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
          words->start = 0;
          words->num = 0;
        }
        while((_Bool)0);
        vlcurfirst(db->auxdb);
        do
        {
          kbuf=vlcurkey(db->auxdb, &ksiz);
          if(kbuf == ((char *)NULL))
            break;

          do
          {
            signed int _CB_index = words->start + words->num;
            if(_CB_index >= words->anum)
            {
              words->anum = words->anum * 2;
              void *return_value_realloc$16;
              return_value_realloc$16=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
              words->array = (struct anonymous$28 *)return_value_realloc$16;
              if(!(words->array == ((struct anonymous$28 *)NULL)))
                words->array;

              else
                cbmyfatal("out of memory");
            }

            (words->array + (signed long int)_CB_index)->dptr = kbuf;
            (words->array + (signed long int)_CB_index)->dsize = ksiz;
            words->num = words->num + 1;
          }
          while((_Bool)0);
          vlcurnext(db->auxdb);
        }
        while((_Bool)1);
        i = 0;
        for( ; !(i >= words->num); i = i + 1)
        {
          wsiz = (words->array + (signed long int)(words->start + i))->dsize;
          word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
          vbuf=vlget(db->auxdb, word, wsiz, &vsiz);
          if(!(vbuf == ((char *)NULL)))
          {
            rp = vbuf;
            wp = vbuf;
            ep = vbuf + (signed long int)vsiz;
            while(!(rp >= ep))
            {
              const char *return_value_cbmapget$17;
              return_value_cbmapget$17=cbmapget(dmap, rp, (signed int)sizeof(signed int) /*4ul*/ , (signed int *)(void *)0);
              if(!(return_value_cbmapget$17 == ((const char *)NULL)))
              {
                memmove((void *)wp, (const void *)rp, sizeof(signed int) /*4ul*/  * (unsigned long int)2);
                wp = wp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
              }

              rp = rp + (signed long int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2);
            }
            if(!(vbuf >= wp))
            {
              signed int return_value_vlput$18;
              return_value_vlput$18=vlput(db->auxdb, word, wsiz, vbuf, (signed int)(wp - vbuf), 0);
              if(return_value_vlput$18 == 0)
                err = 1;

              len=sprintf(numbuf, "%d", (signed int)((unsigned long int)(wp - vbuf) / (sizeof(signed int) /*4ul*/  * (unsigned long int)2)));
              signed int return_value_vlput$19;
              return_value_vlput$19=vlput(db->xfmdb, word, wsiz, numbuf, len, 0);
              if(return_value_vlput$19 == 0)
                err = 1;

            }

            else
            {
              signed int return_value_vlout$20;
              return_value_vlout$20=vlout(db->auxdb, word, wsiz);
              if(return_value_vlout$20 == 0)
                err = 1;

              signed int return_value_vlout$22;
              return_value_vlout$22=vlout(db->xfmdb, word, wsiz);
              if(return_value_vlout$22 == 0)
              {
                return_value_dpecodeptr$21=dpecodeptr();
                if(!(*return_value_dpecodeptr$21 == 5))
                  err = 1;

              }

            }
            free((void *)vbuf);
            if(i % 10000 == 0)
              est_db_inform(db, "cleaning dispensable auxiliary keys");

          }

        }
        do
        {
          signed int _CB_i;
          signed int est_db_optimize$$1$$2$$9$$_CB_end = words->start + words->num;
          _CB_i = words->start;
          for( ; !(_CB_i >= est_db_optimize$$1$$2$$9$$_CB_end); _CB_i = _CB_i + 1)
            free((void *)(words->array + (signed long int)_CB_i)->dptr);
          free((void *)words->array);
          free((void *)words);
        }
        while((_Bool)0);
        cbmapclose(dmap);
      }

      if((2 & options) == 0)
      {
        est_db_inform(db, "optimizing the inverted index");
        signed int return_value_est_idx_optimize$23;
        return_value_est_idx_optimize$23=est_idx_optimize(db->idxdb);
        if(return_value_est_idx_optimize$23 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for forward matching");
        signed int return_value_vloptimize$24;
        return_value_vloptimize$24=vloptimize(db->fwmdb);
        if(return_value_vloptimize$24 == 0)
          err = 1;

        est_db_inform(db, "optimizing the auxiliary index");
        signed int return_value_vloptimize$25;
        return_value_vloptimize$25=vloptimize(db->auxdb);
        if(return_value_vloptimize$25 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for auxiliary forward matching");
        signed int return_value_vloptimize$26;
        return_value_vloptimize$26=vloptimize(db->xfmdb);
        if(return_value_vloptimize$26 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for attributes");
        signed int return_value_croptimize$27;
        return_value_croptimize$27=croptimize(db->attrdb, -1);
        if(return_value_croptimize$27 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for texts");
        signed int return_value_croptimize$28;
        return_value_croptimize$28=croptimize(db->textdb, -1);
        if(return_value_croptimize$28 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for keywords");
        signed int return_value_croptimize$29;
        return_value_croptimize$29=croptimize(db->kwddb, -1);
        if(return_value_croptimize$29 == 0)
          err = 1;

        est_db_inform(db, "optimizing the database for document list");
        signed int return_value_vloptimize$30;
        return_value_vloptimize$30=vloptimize(db->listdb);
        if(return_value_vloptimize$30 == 0)
          err = 1;

        signed int return_value_cbmaprnum$34;
        return_value_cbmaprnum$34=cbmaprnum(db->aidxs);
        if(return_value_cbmaprnum$34 >= 1)
        {
          est_db_inform(db, "optimizing the databases for attribute narrowing");
          cbmapiterinit(db->aidxs);
          do
          {
            rp=cbmapiternext(db->aidxs, (signed int *)(void *)0);
            if(rp == ((const char *)NULL))
              break;

            const char *return_value_cbmapiterval$31;
            return_value_cbmapiterval$31=cbmapiterval(rp, (signed int *)(void *)0);
            attridx = (struct anonymous$16 *)return_value_cbmapiterval$31;
            if(attridx->type == 1 || attridx->type == 2)
            {
              return_value_vloptimize$32=vloptimize((struct anonymous$7 *)attridx->db);
              if(return_value_vloptimize$32 == 0)
                err = 1;

              goto __CPROVER_DUMP_L86;
            }

            signed int return_value_dpoptimize$33;
            return_value_dpoptimize$33=dpoptimize((struct anonymous$5 *)attridx->db, -1);
            if(return_value_dpoptimize$33 == 0)
              err = 1;


          __CPROVER_DUMP_L86:
            ;
          }
          while((_Bool)1);
        }

      }

      cbmapclose(db->rescc);
      db->rescc=cbmapopenex(db->rcmnum * 2 + 1);
      if(!(err == 0))
      {
        est_set_ecode(&db->ecode, 4, 1883);
        db->fatal = 1;
      }

      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_out_doc
// file estraier.c line 2323
signed int est_db_out_doc(struct anonymous *db, signed int id, signed int options)
{
  struct anonymous$0 *doc;
  struct anonymous$1 *words;
  struct anonymous$16 *attridx;
  const char *uri;
  const char *kbuf;
  const char *vbuf;
  const char *text;
  const char *word;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int ksiz;
  signed int vsiz;
  signed int len;
  signed int wsiz;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  signed int return_value_est_crout$4;
  _Bool tmp_if_expr$7;
  signed int return_value_vlout$6;
  signed int return_value_est_aidx_attr_out$9;
  signed int *return_value_dpecodeptr$15;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 2332);
    return 0;
  }

  else
    if(id >= 2000000001)
    {
      est_set_ecode(&db->ecode, 1, 2336);
      return 0;
    }

    else
    {
      doc=est_db_get_doc(db, id, 4);
      if(doc == ((struct anonymous$0 *)NULL))
        return 0;

      else
      {
        if(doc->attrs == ((struct anonymous$9 *)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          uri=cbmapget(doc->attrs, "@uri", -1, (signed int *)(void *)0);
          tmp_if_expr$2 = !(uri != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
        {
          est_doc_delete(doc);
          est_set_ecode(&db->ecode, 4, 2342);
          db->fatal = 1;
          return 0;
        }

        else
        {
          signed int return_value_est_crout$3;
          return_value_est_crout$3=est_crout(db->attrdb, id);
          if(return_value_est_crout$3 == 0)
            tmp_if_expr$5 = (_Bool)1;

          else
          {
            return_value_est_crout$4=est_crout(db->textdb, id);
            tmp_if_expr$5 = !(return_value_est_crout$4 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$5)
            tmp_if_expr$7 = (_Bool)1;

          else
          {
            return_value_vlout$6=vlout(db->listdb, uri, -1);
            tmp_if_expr$7 = !(return_value_vlout$6 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$7)
          {
            est_doc_delete(doc);
            est_set_ecode(&db->ecode, 4, 2348);
            db->fatal = 1;
            return 0;
          }

          else
          {
            cbmapout(db->attrcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
            cbmapout(db->textcc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
            if(!(db->spacc == ((struct anonymous$9 *)NULL)))
              cbmapout(db->spacc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );

            signed int return_value_cbmaprnum$11;
            return_value_cbmaprnum$11=cbmaprnum(db->aidxs);
            if(return_value_cbmaprnum$11 >= 1)
            {
              cbmapiterinit(db->aidxs);
              do
              {
                kbuf=cbmapiternext(db->aidxs, &ksiz);
                if(kbuf == ((const char *)NULL))
                  break;

                vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
                if(!(vbuf == ((const char *)NULL)))
                {
                  const char *return_value_cbmapiterval$8;
                  return_value_cbmapiterval$8=cbmapiterval(kbuf, (signed int *)(void *)0);
                  attridx = (struct anonymous$16 *)return_value_cbmapiterval$8;
                  if(attridx->type == 1 || attridx->type == 2)
                  {
                    return_value_est_aidx_attr_out$9=est_aidx_attr_out((struct anonymous$7 *)attridx->db, doc->id, vbuf, vsiz);
                    if(return_value_est_aidx_attr_out$9 == 0)
                    {
                      est_doc_delete(doc);
                      est_set_ecode(&db->ecode, 4, 2365);
                      db->fatal = 1;
                      return 0;
                    }

                    goto __CPROVER_DUMP_L18;
                  }

                  signed int return_value_est_aidx_seq_out$10;
                  return_value_est_aidx_seq_out$10=est_aidx_seq_out((struct anonymous$5 *)attridx->db, doc->id);
                  if(return_value_est_aidx_seq_out$10 == 0)
                  {
                    est_doc_delete(doc);
                    est_set_ecode(&db->ecode, 4, 2373);
                    db->fatal = 1;
                    return 0;
                  }

                }


              __CPROVER_DUMP_L18:
                ;
              }
              while((_Bool)1);
            }

            if(!((1 & options) == 0))
            {
              len=sprintf(numbuf, "\t%d", doc->id);
              cbmapput(db->outcc, numbuf, len, "", 0, 0);
              i = -1;
              for( ; !(i >= doc->dtexts->num); i = i + 1)
              {
                if(!(i >= 0))
                {
                  text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
                  if(text == ((const char *)NULL))
                    goto __CPROVER_DUMP_L36;

                }

                else
                  text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
                do
                {
                  void *return_value_malloc$12;
                  return_value_malloc$12=malloc(sizeof(struct anonymous$1) /*24ul*/ );
                  words = (struct anonymous$1 *)return_value_malloc$12;
                  if(!(words == ((struct anonymous$1 *)NULL)))
                    words;

                  else
                    cbmyfatal("out of memory");
                  words->anum = 64;
                  void *return_value_malloc$13;
                  return_value_malloc$13=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
                  words->array = (struct anonymous$28 *)return_value_malloc$13;
                  if(!(words->array == ((struct anonymous$28 *)NULL)))
                    words->array;

                  else
                    cbmyfatal("out of memory");
                  words->start = 0;
                  words->num = 0;
                }
                while((_Bool)0);
                switch(db->amode)
                {
                  case 1024:
                  {
                    est_break_text_perfng(text, words, 0, 1);
                    break;
                  }
                  case 2048:
                  {
                    est_break_text_chrcat(text, words, 0);
                    break;
                  }
                  default:
                    est_break_text(text, words, 0, 1);
                }
                j = 0;
                for( ; !(j >= words->num); j = j + 1)
                {
                  wsiz = (words->array + (signed long int)(words->start + j))->dsize;
                  word = (const char *)(words->array + (signed long int)(words->start + j))->dptr;
                  cbmapput(db->outcc, word, wsiz, "", 0, 0);
                }
                do
                {
                  signed int _CB_i;
                  signed int _CB_end = words->start + words->num;
                  _CB_i = words->start;
                  for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                    free((void *)(words->array + (signed long int)_CB_i)->dptr);
                  free((void *)words->array);
                  free((void *)words);
                }
                while((_Bool)0);

              __CPROVER_DUMP_L36:
                ;
              }
              signed int return_value_est_db_out_keywords$14;
              return_value_est_db_out_keywords$14=est_db_out_keywords(db, id);
              if(return_value_est_db_out_keywords$14 == 0)
              {
                if(!(db->ecode == 6))
                {
                  est_doc_delete(doc);
                  est_set_ecode(&db->ecode, 4, 2410);
                  db->fatal = 1;
                  return 0;
                }

              }

            }

            else
            {
              signed int return_value_est_crout$16;
              return_value_est_crout$16=est_crout(db->kwddb, id);
              if(return_value_est_crout$16 == 0)
              {
                return_value_dpecodeptr$15=dpecodeptr();
                if(!(*return_value_dpecodeptr$15 == 5))
                {
                  est_doc_delete(doc);
                  est_set_ecode(&db->ecode, 4, 2417);
                  db->fatal = 1;
                  return 0;
                }

              }

              cbmapout(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
            }
            est_doc_delete(doc);
            signed int return_value_est_db_set_doc_entity$17;
            return_value_est_db_set_doc_entity$17=est_db_set_doc_entity(db, id, (const char *)(void *)0, -1);
            if(return_value_est_db_set_doc_entity$17 == 0)
            {
              if(db->ecode == 6)
                goto __CPROVER_DUMP_L42;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L42:
              ;
              db->dnum = db->dnum - 1;
              return 1;
            }
          }
        }
      }
    }
}

// est_db_out_keywords
// file estraier.c line 4731
signed int est_db_out_keywords(struct anonymous *db, signed int id)
{
  struct anonymous$9 *kwords;
  const char *word;
  char wbuf[51l];
  char *tbuf;
  signed int wsiz;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 4738);
    return 0;
  }

  else
    if(id >= 2000000001)
    {
      est_set_ecode(&db->ecode, 1, 4742);
      return 0;
    }

    else
    {
      kwords=est_db_get_keywords(db, id);
      if(!(kwords == ((struct anonymous$9 *)NULL)))
      {
        cbmapiterinit(kwords);
        do
        {
          word=cbmapiternext(kwords, &wsiz);
          if(word == ((const char *)NULL))
            break;

          if(wsiz >= 49)
          {
            tbuf=cbsprintf(" %s", word);
            cbmapput(db->outcc, tbuf, wsiz + 1, "", 0, 0);
            free((void *)tbuf);
          }

          else
          {
            sprintf(wbuf, " %s", word);
            cbmapput(db->outcc, wbuf, wsiz + 1, "", 0, 0);
          }
        }
        while((_Bool)1);
        cbmapclose(kwords);
      }

      signed int return_value_est_crout$3;
      return_value_est_crout$3=est_crout(db->kwddb, id);
      if(return_value_est_crout$3 == 0)
      {
        signed int *return_value_dpecodeptr$2;
        return_value_dpecodeptr$2=dpecodeptr();
        if(*return_value_dpecodeptr$2 == 5)
          est_set_ecode(&db->ecode, 6, 4761);

        else
        {
          est_set_ecode(&db->ecode, 4, 4763);
          db->fatal = 1;
        }
        return 0;
      }

      cbmapout(db->veccc, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
      return 1;
    }
}

// est_db_prepare_meta
// file estraier.c line 7816
static void est_db_prepare_meta(struct anonymous *db)
{
  char *sbuf;
  signed int ssiz;
  sbuf=dpget(db->metadb, "_meta", -1, 0, -1, &ssiz);
  if(!(sbuf == ((char *)NULL)))
  {
    db->metacc=cbmapload(sbuf, ssiz);
    free((void *)sbuf);
  }

  else
    db->metacc=cbmapopenex(31);
}

// est_db_pseudo_doc_num
// file estraier.c line 5075
signed int est_db_pseudo_doc_num(struct anonymous *db)
{
  signed int return_value_cblistnum$1;
  return_value_cblistnum$1=cblistnum(db->pdocs);
  return return_value_cblistnum$1;
}

// est_db_put_doc
// file estraier.c line 2130
signed int est_db_put_doc(struct anonymous *db, struct anonymous$0 *doc, signed int options)
{
  struct anonymous$9 *ocmap;
  struct anonymous$9 *fmap;
  struct anonymous$9 *qmap;
  struct anonymous$1 *words;
  struct anonymous$2 *ocbuf;
  struct anonymous$16 *attridx;
  struct md5_state_s ms;
  const char *uri;
  const char *ndig;
  const char *text;
  const char *word;
  const char *fnext;
  const char *snext;
  const char *kbuf;
  const char *vbuf;
  unsigned char junc[2l];
  unsigned char c;
  char dobuf[32l];
  char dsbuf[64l];
  char *wp;
  char *odig;
  char wbuf[51l];
  char *sbuf;
  char nbuf[32l];
  signed int i;
  signed int j;
  signed int id;
  signed int err;
  signed int wnum;
  signed int wsiz;
  signed int fnsiz;
  signed int snsiz;
  signed int *np;
  signed int score;
  signed int num;
  signed int ksiz;
  signed int vsiz;
  signed int ssiz;
  double tune;
  double weight;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  signed int tmp_if_expr$13;
  signed int return_value_dpinnerhash$12;
  signed int tmp_if_expr$15;
  signed int return_value_dpouterhash$14;
  signed int tmp_if_expr$17;
  signed int tmp_if_expr$20;
  signed int return_value_atoi$19;
  double tmp_if_expr$26;
  const char *return_value_cbmapget$25;
  double tmp_if_expr$29;
  const char *return_value_cbmapget$28;
  signed int return_value_est_db_put_keywords$35;
  signed int return_value_est_aidx_attr_put$38;
  signed int return_value_est_db_flush$41;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 2143);
    return 0;
  }

  else
  {
    if(doc->attrs == ((struct anonymous$9 *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      uri=cbmapget(doc->attrs, "@uri", -1, (signed int *)(void *)0);
      tmp_if_expr$2 = !(uri != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)uri[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      est_set_ecode(&db->ecode, 1, 2147);
      return 0;
    }

    else
    {
      if(doc->dtexts == ((struct anonymous$1 *)NULL))
        do
        {
          void *return_value_malloc$4;
          return_value_malloc$4=malloc(sizeof(struct anonymous$1) /*24ul*/ );
          doc->dtexts = (struct anonymous$1 *)return_value_malloc$4;
          if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
            doc->dtexts;

          else
            cbmyfatal("out of memory");
          doc->dtexts->anum = 64;
          void *return_value_malloc$5;
          return_value_malloc$5=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
          doc->dtexts->array = (struct anonymous$28 *)return_value_malloc$5;
          if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
            doc->dtexts->array;

          else
            cbmyfatal("out of memory");
          doc->dtexts->start = 0;
          doc->dtexts->num = 0;
        }
        while((_Bool)0);

      ndig=cbmapget(doc->attrs, "@digest", -1, (signed int *)(void *)0);
      if(ndig == ((const char *)NULL))
      {
        md5_init(&ms);
        i = 0;
        for( ; !(i >= doc->dtexts->num); i = i + 1)
        {
          vsiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
          vbuf = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
          md5_append(&ms, (unsigned char *)vbuf, vsiz);
          md5_append(&ms, (unsigned char *)"\n", 1);
        }
        vbuf=cbmapget(doc->attrs, "", 0, &vsiz);
        if(!(vbuf == ((const char *)NULL)))
        {
          md5_append(&ms, (unsigned char *)"\t", 1);
          md5_append(&ms, (unsigned char *)vbuf, vsiz);
          md5_append(&ms, (unsigned char *)"\n", 1);
        }

        md5_finish(&ms, (unsigned char *)dobuf);
        wp = dsbuf;
        i = 0;
        for( ; !(i >= 16); i = i + 1)
        {
          signed int return_value_sprintf$6;
          return_value_sprintf$6=sprintf(wp, "%02x", ((unsigned char *)dobuf)[(signed long int)i]);
          wp = wp + (signed long int)return_value_sprintf$6;
        }
        ndig = dsbuf;
        cbmapput(doc->attrs, "@digest", -1, ndig, -1, 0);
      }

      id=est_db_uri_to_id(db, uri);
      if(id >= 1)
      {
        odig=est_db_get_doc_attr(db, id, "@digest");
        if(!(odig == ((char *)NULL)))
        {
          signed int return_value_strcmp$8;
          return_value_strcmp$8=strcmp(odig, ndig);
          if(return_value_strcmp$8 == 0)
          {
            free((void *)odig);
            doc->id = id;
            sprintf(nbuf, "%d", id);
            cbmapput(doc->attrs, "@id", -1, nbuf, -1, 1);
            signed int return_value_est_db_edit_doc$7;
            return_value_est_db_edit_doc$7=est_db_edit_doc(db, doc);
            return return_value_est_db_edit_doc$7;
          }

          free((void *)odig);
        }

        signed int return_value_est_db_out_doc$9;
        return_value_est_db_out_doc$9=est_db_out_doc(db, id, (options & 1) != 0 ? 1 : 0);
        if(return_value_est_db_out_doc$9 == 0)
          return 0;

      }

      db->dseq = db->dseq + 1;
      doc->id = db->dseq;
      sprintf(nbuf, "%d", doc->id);
      cbmapput(doc->attrs, "@id", -1, nbuf, -1, 1);
      ocmap=cbmapopen();
      fmap=cbmapopen();
      qmap=cbmapopen();
      wnum = 0;
      i = -1;
      for( ; !(i >= doc->dtexts->num); i = i + 1)
      {
        if(!(i >= 0))
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          if(text == ((const char *)NULL))
            goto __CPROVER_DUMP_L46;

        }

        else
          text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
        do
        {
          void *return_value_malloc$10;
          return_value_malloc$10=malloc(sizeof(struct anonymous$1) /*24ul*/ );
          words = (struct anonymous$1 *)return_value_malloc$10;
          if(!(words == ((struct anonymous$1 *)NULL)))
            words;

          else
            cbmyfatal("out of memory");
          words->anum = 64;
          void *return_value_malloc$11;
          return_value_malloc$11=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
          words->array = (struct anonymous$28 *)return_value_malloc$11;
          if(!(words->array == ((struct anonymous$28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
          words->start = 0;
          words->num = 0;
        }
        while((_Bool)0);
        switch(db->amode)
        {
          case 1024:
          {
            est_break_text_perfng(text, words, 0, 1);
            break;
          }
          case 2048:
          {
            est_break_text_chrcat(text, words, 0);
            break;
          }
          default:
            est_break_text(text, words, 0, 1);
        }
        wnum = wnum + (signed int)words->num;
        j = 0;
        for( ; !(j >= words->num); j = j + 1)
        {
          wsiz = (words->array + (signed long int)(words->start + j))->dsize;
          word = (const char *)(words->array + (signed long int)(words->start + j))->dptr;
          if(!(wsiz >= 49))
          {
            fnext=cblistval(words, j + 1, &fnsiz);
            snext=cblistval(words, j + 2, &snsiz);
            if(!(fnext == ((const char *)NULL)))
            {
              return_value_dpinnerhash$12=dpinnerhash(fnext, fnsiz);
              tmp_if_expr$13 = return_value_dpinnerhash$12 % 251 + 1;
            }

            else
              tmp_if_expr$13 = 0xff;
            junc[(signed long int)0] = (unsigned char)tmp_if_expr$13;
            if(!(snext == ((const char *)NULL)))
            {
              return_value_dpouterhash$14=dpouterhash(snext, snsiz);
              tmp_if_expr$15 = return_value_dpouterhash$14 % 251 + 1;
            }

            else
              tmp_if_expr$15 = 0xff;
            junc[(signed long int)1] = (unsigned char)tmp_if_expr$15;
            memcpy((void *)wbuf, (const void *)word, (unsigned long int)wsiz);
            memcpy((void *)(wbuf + (signed long int)wsiz), (const void *)"\t", (unsigned long int)1);
            memcpy((void *)(wbuf + (signed long int)wsiz + (signed long int)1), (const void *)junc, (unsigned long int)2);
            const char *return_value_cbmapget$16;
            return_value_cbmapget$16=cbmapget(fmap, word, wsiz, (signed int *)(void *)0);
            np = (signed int *)return_value_cbmapget$16;
            if(!(np == ((signed int *)NULL)))
              tmp_if_expr$17 = *((signed int *)np);

            else
              tmp_if_expr$17 = 0;
            num = tmp_if_expr$17;
            num = num + 16;
            cbmapput(fmap, word, wsiz, (char *)&num, (signed int)sizeof(signed int) /*4ul*/ , 1);
            signed int return_value_cbmapput$18;
            return_value_cbmapput$18=cbmapput(qmap, wbuf, wsiz + 3, "", 0, 0);
            if(!(return_value_cbmapput$18 == 0))
              cbmapputcat(ocmap, word, wsiz, (char *)junc, fnext != ((const char *)NULL) ? 2 : 0);

          }

        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = words->start + words->num;
          _CB_i = words->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(words->array + (signed long int)_CB_i)->dptr);
          free((void *)words->array);
          free((void *)words);
        }
        while((_Bool)0);

      __CPROVER_DUMP_L46:
        ;
      }
      vbuf=cbmapget(doc->attrs, "\t", 1, (signed int *)(void *)0);
      if(!(vbuf == ((const char *)NULL)))
      {
        return_value_atoi$19=atoi(vbuf);
        tmp_if_expr$20 = return_value_atoi$19;
      }

      else
        tmp_if_expr$20 = -1;
      score = tmp_if_expr$20;
      weight = 1.0;
      if(!((2 & options) == 0) && !(score >= 0))
      {
        vbuf=cbmapget(doc->attrs, "@weight", -1, (signed int *)(void *)0);
        if(!(vbuf == ((const char *)NULL)))
        {
          weight=strtod(vbuf, (char ** restrict )(void *)0);
          weight = weight >= 0.01 ? weight : 0.01;
        }

      }

      double return_value_sqrt$21;
      return_value_sqrt$21=sqrt((double)(wnum + 128));
      tune = (return_value_sqrt$21 / 16.0) / weight;
      cbmapiterinit(ocmap);
      do
      {
        kbuf=cbmapiternext(ocmap, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        do
        {
          struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(kbuf - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
          vsiz = _CB_datum->vsiz;
          vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
        }
        while((_Bool)0);
        if(vsiz >= 3)
          qsort((void *)vbuf, (unsigned long int)(vsiz / 2), (unsigned long int)2, est_short_compare);

        do
        {
          void *return_value_malloc$22;
          return_value_malloc$22=malloc(sizeof(struct anonymous$2) /*16ul*/ );
          ocbuf = (struct anonymous$2 *)return_value_malloc$22;
          if(!(ocbuf == ((struct anonymous$2 *)NULL)))
            ocbuf;

          else
            cbmyfatal("out of memory");
          void *return_value_malloc$23;
          return_value_malloc$23=malloc((unsigned long int)12);
          ocbuf->dptr = (char *)return_value_malloc$23;
          if(!(ocbuf->dptr == ((char *)NULL)))
            ocbuf->dptr;

          else
            cbmyfatal("out of memory");
          ocbuf->dptr[(signed long int)0] = (char)0;
          ocbuf->dsize = 0;
          ocbuf->asize = 12;
        }
        while((_Bool)0);
        do
        {
          signed int _EST_num = doc->id;
          struct anonymous$15 EST_d;
          if(_EST_num == 0)
          {
            ((signed char *)wbuf)[(signed long int)0] = (signed char)0;
            wsiz = 1;
          }

          else
          {
            wsiz = 0;
            for( ; _EST_num >= 1; wsiz = wsiz + 1)
            {
              EST_d=div(_EST_num, 128);
              _EST_num = EST_d.quot;
              if(_EST_num >= 1)
                ((signed char *)wbuf)[(signed long int)wsiz] = (signed char)(-EST_d.rem - 1);

              else
                ((signed char *)wbuf)[(signed long int)wsiz] = (signed char)EST_d.rem;
            }
          }
        }
        while((_Bool)0);
        do
        {
          if(ocbuf->dsize + wsiz >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + wsiz + 1;
            void *return_value_realloc$24;
            return_value_realloc$24=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc$24;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)wbuf, (unsigned long int)wsiz);
          ocbuf->dsize = ocbuf->dsize + wsiz;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        if(!(db->smode == 1048576))
        {
          if(db->smode == 2097152 || db->smode == 4194304)
            goto __CPROVER_DUMP_L78;

        }

        else
          goto __CPROVER_DUMP_L85;
        if(!(score >= 0))
        {
          return_value_cbmapget$25=cbmapget(fmap, kbuf, ksiz, (signed int *)(void *)0);
          tmp_if_expr$26 = (double)*((signed int *)return_value_cbmapget$25) / tune;
        }

        else
          tmp_if_expr$26 = (double)score;
        num = (signed int)tmp_if_expr$26;
        if(num >= 0x80)
          num = num + (signed int)((double)(0x80 - num) * 0.75);

        if(num >= 0xc0)
          num = num + (signed int)((double)(0xc0 - num) * 0.75);

        c = (unsigned char)(num < 0xff ? num : 0xff);
        do
        {
          if(1 + ocbuf->dsize >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + 1 + 1;
            void *return_value_realloc$27;
            return_value_realloc$27=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc$27;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)(char *)&c, (unsigned long int)1);
          ocbuf->dsize = ocbuf->dsize + 1;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L85;

      __CPROVER_DUMP_L78:
        ;
        if(!(score >= 0))
        {
          return_value_cbmapget$28=cbmapget(fmap, kbuf, ksiz, (signed int *)(void *)0);
          tmp_if_expr$29 = (double)(*((signed int *)return_value_cbmapget$28) * 10) / tune;
        }

        else
          tmp_if_expr$29 = (double)score;
        num = (signed int)tmp_if_expr$29;
        do
        {
          if(sizeof(signed int) /*4ul*/  + (unsigned long int)ocbuf->dsize >= (unsigned long int)ocbuf->asize)
          {
            ocbuf->asize = (signed int)((unsigned long int)(ocbuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
            void *return_value_realloc$30;
            return_value_realloc$30=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc$30;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)(char *)&num, sizeof(signed int) /*4ul*/ );
          ocbuf->dsize = ocbuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);

      __CPROVER_DUMP_L85:
        ;
        do
        {
          if(ocbuf->dsize + vsiz >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + vsiz + 1;
            void *return_value_realloc$31;
            return_value_realloc$31=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc$31;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)vbuf, (unsigned long int)vsiz);
          ocbuf->dsize = ocbuf->dsize + vsiz;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        c = (unsigned char)0x00;
        do
        {
          if(1 + ocbuf->dsize >= ocbuf->asize)
          {
            ocbuf->asize = ocbuf->asize * 2 + 1 + 1;
            void *return_value_realloc$32;
            return_value_realloc$32=realloc((void *)ocbuf->dptr, (unsigned long int)ocbuf->asize);
            ocbuf->dptr = (char *)return_value_realloc$32;
            if(!(ocbuf->dptr == ((char *)NULL)))
              ocbuf->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(ocbuf->dptr + (signed long int)ocbuf->dsize), (const void *)(char *)&c, (unsigned long int)1);
          ocbuf->dsize = ocbuf->dsize + 1;
          ocbuf->dptr[(signed long int)ocbuf->dsize] = (char)0;
        }
        while((_Bool)0);
        cbmapputcat(db->idxcc, kbuf, ksiz, (const char *)ocbuf->dptr, (signed int)ocbuf->dsize);
        db->icsiz = db->icsiz + (unsigned long int)(signed int)ocbuf->dsize;
        do
        {
          free((void *)ocbuf->dptr);
          free((void *)ocbuf);
        }
        while((_Bool)0);
      }
      while((_Bool)1);
      cbmapclose(qmap);
      cbmapclose(fmap);
      cbmapclose(ocmap);
      err = 0;
      sbuf=cbmapdump(doc->attrs, &ssiz);
      signed int return_value_est_crput$33;
      return_value_est_crput$33=est_crput(db->attrdb, db->zmode, doc->id, sbuf, ssiz, 1);
      if(return_value_est_crput$33 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2273);
        db->fatal = 1;
        err = 1;
      }

      free((void *)sbuf);
      sbuf=cblistdump(doc->dtexts, &ssiz);
      signed int return_value_est_crput$34;
      return_value_est_crput$34=est_crput(db->textdb, db->zmode, doc->id, sbuf, ssiz, 1);
      if(return_value_est_crput$34 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2280);
        db->fatal = 1;
        err = 1;
      }

      free((void *)sbuf);
      if(!(doc->kwords == ((struct anonymous$9 *)NULL)))
      {
        return_value_est_db_put_keywords$35=est_db_put_keywords(db, doc->id, doc->kwords, weight);
        if(return_value_est_db_put_keywords$35 == 0)
          err = 1;

      }

      sprintf(nbuf, "%d", doc->id);
      signed int return_value_vlput$36;
      return_value_vlput$36=vlput(db->listdb, uri, -1, nbuf, -1, 1);
      if(return_value_vlput$36 == 0)
      {
        est_set_ecode(&db->ecode, 4, 2288);
        db->fatal = 1;
        err = 1;
      }

      signed int return_value_cbmaprnum$40;
      return_value_cbmaprnum$40=cbmaprnum(db->aidxs);
      if(return_value_cbmaprnum$40 >= 1)
      {
        cbmapiterinit(db->aidxs);
        do
        {
          kbuf=cbmapiternext(db->aidxs, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
          if(!(vbuf == ((const char *)NULL)))
          {
            const char *return_value_cbmapiterval$37;
            return_value_cbmapiterval$37=cbmapiterval(kbuf, (signed int *)(void *)0);
            attridx = (struct anonymous$16 *)return_value_cbmapiterval$37;
            if(attridx->type == 1 || attridx->type == 2)
            {
              return_value_est_aidx_attr_put$38=est_aidx_attr_put((struct anonymous$7 *)attridx->db, doc->id, vbuf, vsiz);
              if(return_value_est_aidx_attr_put$38 == 0)
              {
                est_set_ecode(&db->ecode, 4, 2301);
                db->fatal = 1;
                err = 1;
              }

              goto __CPROVER_DUMP_L104;
            }

            signed int return_value_est_aidx_seq_put$39;
            return_value_est_aidx_seq_put$39=est_aidx_seq_put((struct anonymous$5 *)attridx->db, doc->id, vbuf, vsiz);
            if(return_value_est_aidx_seq_put$39 == 0)
            {
              est_set_ecode(&db->ecode, 4, 2308);
              db->fatal = 1;
              err = 1;
            }

          }


        __CPROVER_DUMP_L104:
          ;
        }
        while((_Bool)1);
      }

      db->dnum = db->dnum + 1;
      signed int return_value_est_db_used_cache_size$42;
      return_value_est_db_used_cache_size$42=est_db_used_cache_size(db);
      if(!(db->icmax >= (unsigned long int)return_value_est_db_used_cache_size$42))
      {
        return_value_est_db_flush$41=est_db_flush(db, 0x7fffffff);
        if(return_value_est_db_flush$41 == 0)
          err = 1;

      }

      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_put_keywords
// file estraier.c line 4696
signed int est_db_put_keywords(struct anonymous *db, signed int id, struct anonymous$9 *kwords, double weight)
{
  const char *kbuf;
  char *mbuf;
  signed int err;
  signed int ksiz;
  signed int pair[2l];
  signed int msiz;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 4702);
    return 0;
  }

  else
  {
    signed int return_value_crvsiz$2;
    return_value_crvsiz$2=crvsiz(db->attrdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
    if(return_value_crvsiz$2 == -1)
    {
      est_set_ecode(&db->ecode, 6, 4706);
      return 0;
    }

    else
    {
      err = 0;
      signed int return_value_est_db_out_keywords$3;
      return_value_est_db_out_keywords$3=est_db_out_keywords(db, id);
      if(return_value_est_db_out_keywords$3 == 0)
      {
        if(!(db->ecode == 6))
          err = 1;

      }

      pair[(signed long int)0] = id;
      cbmapiterinit(kwords);
      do
      {
        kbuf=cbmapiternext(kwords, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        if(!(ksiz >= 1))
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          if((signed int)*kbuf >= 0)
            tmp_if_expr$4 = (signed int)kbuf[(signed long int)0] <= 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$5)
        {
          const char *return_value_cbmapiterval$6;
          return_value_cbmapiterval$6=cbmapiterval(kbuf, (signed int *)(void *)0);
          signed int return_value_atoi$7;
          return_value_atoi$7=atoi(return_value_cbmapiterval$6);
          pair[(signed long int)1] = (signed int)((double)return_value_atoi$7 * weight);
          cbmapputcat(db->auxcc, kbuf, ksiz, (char *)pair, (signed int)sizeof(signed int [2l]) /*8ul*/ );
          db->icsiz = db->icsiz + sizeof(signed int [2l]) /*8ul*/ ;
        }

      }
      while((_Bool)1);
      mbuf=cbmapdump(kwords, &msiz);
      signed int return_value_est_crput$8;
      return_value_est_crput$8=est_crput(db->kwddb, db->zmode, id, mbuf, msiz, 0);
      if(return_value_est_crput$8 == 0)
      {
        est_set_ecode(&db->ecode, 4, 4721);
        db->fatal = 1;
        err = 1;
      }

      free((void *)mbuf);
      return err != 0 ? 0 : 1;
    }
  }
}

// est_db_refresh_rescc
// file estraier.c line 5022
void est_db_refresh_rescc(struct anonymous *db)
{
  struct anonymous$6 sc;
  const char *word;
  signed int size;
  sc.id = -1;
  sc.score = 0;
  sc.value = (char *)(void *)0;
  cbmapiterinit(db->rescc);
  do
  {
    word=cbmapiternext(db->rescc, &size);
    if(word == ((const char *)NULL))
      break;

    cbmapput(db->rescc, word, size, (char *)&sc, (signed int)sizeof(struct anonymous$6) /*16ul*/ , 1);
  }
  while((_Bool)1);
}

// est_db_repair
// file estraier.c line 5117
signed int est_db_repair(const char *name, signed int options, signed int *ecp)
{
  struct anonymous *db;
  struct anonymous$5 *depot;
  struct anonymous$5 *metadb;
  struct anonymous$4 *curia;
  struct anonymous$4 *attrdb;
  struct anonymous$4 *textdb;
  struct anonymous$4 *kwddb;
  struct anonymous$7 *villa;
  struct anonymous$7 *listdb;
  struct anonymous$1 *list;
  struct anonymous$9 *aidxs;
  struct anonymous$9 *attrs;
  struct anonymous$16 attridx;
  struct anonymous$16 *attridxp;
  void *aidxdb;
  const char *elem;
  const char *abuf;
  char path[4096l];
  char *kbuf;
  char vbuf[32l];
  char *dec;
  char *mbuf;
  signed int i;
  signed int err;
  signed int idmax;
  signed int flags;
  signed int zmode;
  signed int dnum;
  signed int dseq;
  signed int ksiz;
  signed int vsiz;
  signed int type;
  signed int id;
  signed int msiz;
  signed int esiz;
  signed int asiz;
  sprintf(path, "%s%c%s", name, 47, (const void *)"_meta");
  signed int return_value_est_inode$1;
  return_value_est_inode$1=est_inode(path);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  signed int return_value_cbstrfwmatch$24;
  _Bool tmp_if_expr$21;
  signed int return_value_cbstrfwmatch$23;
  _Bool tmp_if_expr$22;
  signed int return_value_cbstrfwmatch$31;
  signed int return_value_cbstrfwmatch$30;
  struct anonymous$7 *return_value_vlopen$33;
  struct anonymous$7 *return_value_vlopen$34;
  signed int return_value_crbnum$35;
  struct anonymous$5 *return_value_dpopen$36;
  _Bool tmp_if_expr$44;
  _Bool tmp_if_expr$46;
  signed int return_value_crvsiz$45;
  _Bool tmp_if_expr$48;
  signed int return_value_crvsiz$47;
  signed int return_value_vlclose$53;
  if(return_value_est_inode$1 == -1)
  {
    est_set_ecode(ecp, 5, 5132);
    return 0;
  }

  else
  {
    if((1 & options) == 0)
    {
      depot=dpopen(path, 2, -1);
      tmp_if_expr$2 = depot != (struct anonymous$5 *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      dpclose(depot);

    else
      dprepair(path);
    sprintf(path, "%s%c%s", name, 47, (const void *)"_idx");
    signed int return_value_est_inode$3;
    return_value_est_inode$3=est_inode(path);
    if(return_value_est_inode$3 == -1)
    {
      est_set_ecode(ecp, 5, 5142);
      return 0;
    }

    else
    {
      list=cbdirlist(path);
      if(!(list == ((struct anonymous$1 *)NULL)))
      {
        i = 1;
        for( ; !(i >= list->num); i = i + 1)
        {
          elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
          if(!((signed int)*elem >= 48))
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = (signed int)elem[(signed long int)0] > 57 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$4)
          {
            sprintf(path, "%s%c%s%c%s", name, 47, (const void *)"_idx", 47, elem);
            if((1 & options) == 0)
            {
              villa=vlopen(path, 2, VL_CMPLEX);
              tmp_if_expr$5 = villa != (struct anonymous$7 *)(void *)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
              vlclose(villa);

            else
              vlrepair(path, VL_CMPLEX);
          }

        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = list->start + list->num;
          _CB_i = list->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(list->array + (signed long int)_CB_i)->dptr);
          free((void *)list->array);
          free((void *)list);
        }
        while((_Bool)0);
      }

      sprintf(path, "%s%c%s", name, 47, (const void *)"_fwm");
      signed int return_value_est_inode$6;
      return_value_est_inode$6=est_inode(path);
      if(return_value_est_inode$6 == -1)
      {
        est_set_ecode(ecp, 5, 5160);
        return 0;
      }

      else
      {
        if((1 & options) == 0)
        {
          villa=vlopen(path, 2, VL_CMPLEX);
          tmp_if_expr$7 = villa != (struct anonymous$7 *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
          vlclose(villa);

        else
          vlrepair(path, VL_CMPLEX);
        sprintf(path, "%s%c%s", name, 47, (const void *)"_aux");
        signed int return_value_est_inode$8;
        return_value_est_inode$8=est_inode(path);
        if(return_value_est_inode$8 == -1)
        {
          est_set_ecode(ecp, 5, 5170);
          return 0;
        }

        else
        {
          if((1 & options) == 0)
          {
            villa=vlopen(path, 2, VL_CMPLEX);
            tmp_if_expr$9 = villa != (struct anonymous$7 *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$9 = (_Bool)0;
          if(tmp_if_expr$9)
            vlclose(villa);

          else
            vlrepair(path, VL_CMPLEX);
          sprintf(path, "%s%c%s", name, 47, (const void *)"_xfm");
          signed int return_value_est_inode$10;
          return_value_est_inode$10=est_inode(path);
          if(return_value_est_inode$10 == -1)
          {
            est_set_ecode(ecp, 5, 5180);
            return 0;
          }

          else
          {
            if((1 & options) == 0)
            {
              villa=vlopen(path, 2, VL_CMPLEX);
              tmp_if_expr$11 = villa != (struct anonymous$7 *)(void *)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$11 = (_Bool)0;
            if(tmp_if_expr$11)
              vlclose(villa);

            else
              vlrepair(path, VL_CMPLEX);
            sprintf(path, "%s%c%s", name, 47, (const void *)"_attr");
            signed int return_value_est_inode$12;
            return_value_est_inode$12=est_inode(path);
            if(return_value_est_inode$12 == -1)
            {
              est_set_ecode(ecp, 5, 5190);
              return 0;
            }

            else
            {
              if((1 & options) == 0)
              {
                curia=cropen(path, 2, -1, -1);
                tmp_if_expr$13 = curia != (struct anonymous$4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$13 = (_Bool)0;
              if(tmp_if_expr$13)
                crclose(curia);

              else
                crrepair(path);
              sprintf(path, "%s%c%s", name, 47, (const void *)"_text");
              signed int return_value_est_inode$14;
              return_value_est_inode$14=est_inode(path);
              if(return_value_est_inode$14 == -1)
              {
                est_set_ecode(ecp, 5, 5200);
                return 0;
              }

              else
              {
                if((1 & options) == 0)
                {
                  curia=cropen(path, 2, -1, -1);
                  tmp_if_expr$15 = curia != (struct anonymous$4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$15 = (_Bool)0;
                if(tmp_if_expr$15)
                  crclose(curia);

                else
                  crrepair(path);
                sprintf(path, "%s%c%s", name, 47, (const void *)"_kwd");
                signed int return_value_est_inode$16;
                return_value_est_inode$16=est_inode(path);
                if(return_value_est_inode$16 == -1)
                {
                  est_set_ecode(ecp, 5, 5210);
                  return 0;
                }

                else
                {
                  if((1 & options) == 0)
                  {
                    curia=cropen(path, 2, -1, -1);
                    tmp_if_expr$17 = curia != (struct anonymous$4 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$17 = (_Bool)0;
                  if(tmp_if_expr$17)
                    crclose(curia);

                  else
                    crrepair(path);
                  sprintf(path, "%s%c%s", name, 47, (const void *)"_list");
                  signed int return_value_est_inode$18;
                  return_value_est_inode$18=est_inode(path);
                  if(return_value_est_inode$18 == -1)
                  {
                    est_set_ecode(ecp, 5, 5220);
                    return 0;
                  }

                  else
                  {
                    if((1 & options) == 0)
                    {
                      villa=vlopen(path, 2, VL_CMPLEX);
                      tmp_if_expr$19 = villa != (struct anonymous$7 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$19 = (_Bool)0;
                    if(tmp_if_expr$19)
                      vlclose(villa);

                    else
                      vlrepair(path, VL_CMPLEX);
                    list=cbdirlist(name);
                    if(!(list == ((struct anonymous$1 *)NULL)))
                    {
                      i = 0;
                      for( ; !(i >= list->num); i = i + 1)
                      {
                        elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
                        signed int return_value_cbstrfwmatch$25;
                        return_value_cbstrfwmatch$25=cbstrfwmatch(elem, "__seq_");
                        if(!(return_value_cbstrfwmatch$25 == 0))
                        {
                          sprintf(path, "%s%c%s", name, 47, elem);
                          if((1 & options) == 0)
                          {
                            depot=dpopen(path, 2, -1);
                            tmp_if_expr$20 = depot != (struct anonymous$5 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr$20 = (_Bool)0;
                          if(tmp_if_expr$20)
                            dpclose(depot);

                          else
                            dprepair(path);
                        }

                        else
                        {
                          return_value_cbstrfwmatch$24=cbstrfwmatch(elem, "__str_");
                          if(!(return_value_cbstrfwmatch$24 == 0))
                          {
                            sprintf(path, "%s%c%s", name, 47, elem);
                            if((1 & options) == 0)
                            {
                              villa=vlopen(path, 2, VL_CMPLEX);
                              tmp_if_expr$21 = villa != (struct anonymous$7 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                            }

                            else
                              tmp_if_expr$21 = (_Bool)0;
                            if(tmp_if_expr$21)
                              vlclose(villa);

                            else
                              vlrepair(path, VL_CMPLEX);
                          }

                          else
                          {
                            return_value_cbstrfwmatch$23=cbstrfwmatch(elem, "__num_");
                            if(!(return_value_cbstrfwmatch$23 == 0))
                            {
                              sprintf(path, "%s%c%s", name, 47, elem);
                              if((1 & options) == 0)
                              {
                                villa=vlopen(path, 2, VL_CMPLEX);
                                tmp_if_expr$22 = villa != (struct anonymous$7 *)(void *)0 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr$22 = (_Bool)0;
                              if(tmp_if_expr$22)
                                vlclose(villa);

                              else
                                vlrepair(path, VL_CMPLEX);
                            }

                          }
                        }
                      }
                      do
                      {
                        signed int est_db_repair$$1$$27$$2$$_CB_i;
                        signed int est_db_repair$$1$$27$$2$$_CB_end = list->start + list->num;
                        est_db_repair$$1$$27$$2$$_CB_i = list->start;
                        for( ; !(est_db_repair$$1$$27$$2$$_CB_i >= est_db_repair$$1$$27$$2$$_CB_end); est_db_repair$$1$$27$$2$$_CB_i = est_db_repair$$1$$27$$2$$_CB_i + 1)
                          free((void *)(list->array + (signed long int)est_db_repair$$1$$27$$2$$_CB_i)->dptr);
                        free((void *)list->array);
                        free((void *)list);
                      }
                      while((_Bool)0);
                    }

                    if(!((2 & options) == 0))
                    {
                      db=est_db_open(name, 2, ecp);
                      if(!(db == ((struct anonymous *)NULL)))
                      {
                        signed int return_value_est_db_close$26;
                        return_value_est_db_close$26=est_db_close(db, ecp);
                        if(return_value_est_db_close$26 == 0)
                          return 0;

                        return 1;
                      }

                    }

                    sprintf(path, "%s%c%s", name, 47, (const void *)"_meta");
                    metadb=dpopen(path, 2, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_attr");
                    attrdb=cropen(path, 2, -1, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_text");
                    textdb=cropen(path, 2, -1, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_kwd");
                    kwddb=cropen(path, 2, -1, -1);
                    sprintf(path, "%s%c%s", name, 47, (const void *)"_list");
                    listdb=vlopen(path, 2, VL_CMPLEX);
                    if(attrdb == ((struct anonymous$4 *)NULL) || kwddb == ((struct anonymous$4 *)NULL) || textdb == ((struct anonymous$4 *)NULL) || listdb == ((struct anonymous$7 *)NULL))
                    {
                      if(!(listdb == ((struct anonymous$7 *)NULL)))
                        vlclose(listdb);

                      if(!(kwddb == ((struct anonymous$4 *)NULL)))
                        crclose(kwddb);

                      if(!(textdb == ((struct anonymous$4 *)NULL)))
                        crclose(textdb);

                      if(!(attrdb == ((struct anonymous$4 *)NULL)))
                        crclose(attrdb);

                      if(!(metadb == ((struct anonymous$5 *)NULL)))
                        dpclose(metadb);

                      est_set_ecode(ecp, 4, 5276);
                      return 0;
                    }

                    else
                    {
                      aidxs=cbmapopenex(31);
                      list=cbdirlist(name);
                      if(!(list == ((struct anonymous$1 *)NULL)))
                      {
                        i = 0;
                        for( ; !(i >= list->num); i = i + 1)
                        {
                          elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
                          dec = (char *)(void *)0;
                          type = -1;
                          signed int return_value_cbstrfwmatch$32;
                          return_value_cbstrfwmatch$32=cbstrfwmatch(elem, "__seq_");
                          if(!(return_value_cbstrfwmatch$32 == 0))
                          {
                            unsigned long int return_value_strlen$27;
                            return_value_strlen$27=strlen("__seq_");
                            dec=est_hex_decode(elem + (signed long int)return_value_strlen$27);
                            type = 0;
                          }

                          else
                          {
                            return_value_cbstrfwmatch$31=cbstrfwmatch(elem, "__str_");
                            if(!(return_value_cbstrfwmatch$31 == 0))
                            {
                              unsigned long int return_value_strlen$28;
                              return_value_strlen$28=strlen("__str_");
                              dec=est_hex_decode(elem + (signed long int)return_value_strlen$28);
                              type = 1;
                            }

                            else
                            {
                              return_value_cbstrfwmatch$30=cbstrfwmatch(elem, "__num_");
                              if(!(return_value_cbstrfwmatch$30 == 0))
                              {
                                unsigned long int return_value_strlen$29;
                                return_value_strlen$29=strlen("__num_");
                                dec=est_hex_decode(elem + (signed long int)return_value_strlen$29);
                                type = 2;
                              }

                            }
                          }
                          if(!(dec == ((char *)NULL)))
                          {
                            sprintf(path, "%s%c%s", name, 47, elem);
                            switch(type)
                            {
                              case 1:
                              {
                                return_value_vlopen$33=vlopen(path, 2, VL_CMPLEX);
                                aidxdb = (void *)return_value_vlopen$33;
                                if(!(aidxdb == NULL))
                                {
                                  vlsettuning((struct anonymous$7 *)aidxdb, 99, 120, 1024, 256);
                                  vlsetfbpsiz((struct anonymous$7 *)aidxdb, 128);
                                  attridx.db = aidxdb;
                                  attridx.type = type;
                                  cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous$16) /*16ul*/ , 0);
                                }

                                break;
                              }
                              case 2:
                              {
                                return_value_vlopen$34=vlopen(path, 2, est_aidx_numcmp);
                                aidxdb = (void *)return_value_vlopen$34;
                                if(!(aidxdb == NULL))
                                {
                                  vlsettuning((struct anonymous$7 *)aidxdb, 99, 120, 1024, 256);
                                  vlsetfbpsiz((struct anonymous$7 *)aidxdb, 128);
                                  attridx.db = aidxdb;
                                  attridx.type = type;
                                  cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous$16) /*16ul*/ , 0);
                                }

                                break;
                              }
                              default:
                              {
                                return_value_crbnum$35=crbnum(attrdb);
                                return_value_dpopen$36=dpopen(path, 2, (signed int)((double)return_value_crbnum$35 / 0.8));
                                aidxdb = (void *)return_value_dpopen$36;
                                if(!(aidxdb == NULL))
                                {
                                  dpsetfbpsiz((struct anonymous$5 *)aidxdb, 32);
                                  attridx.db = aidxdb;
                                  attridx.type = type;
                                  cbmapput(aidxs, dec, -1, (char *)&attridx, (signed int)sizeof(struct anonymous$16) /*16ul*/ , 0);
                                }

                              }
                            }
                            free((void *)dec);
                          }

                        }
                        do
                        {
                          signed int est_db_repair$$1$$30$$2$$_CB_i;
                          signed int est_db_repair$$1$$30$$2$$_CB_end = list->start + list->num;
                          est_db_repair$$1$$30$$2$$_CB_i = list->start;
                          for( ; !(est_db_repair$$1$$30$$2$$_CB_i >= est_db_repair$$1$$30$$2$$_CB_end); est_db_repair$$1$$30$$2$$_CB_i = est_db_repair$$1$$30$$2$$_CB_i + 1)
                            free((void *)(list->array + (signed long int)est_db_repair$$1$$30$$2$$_CB_i)->dptr);
                          free((void *)list->array);
                          free((void *)list);
                        }
                        while((_Bool)0);
                      }

                      err = 0;
                      idmax = 0;
                      vsiz=dpgetwb(metadb, "_dnum", -1, 0, 32 - 1, vbuf);
                      if(vsiz >= 1)
                      {
                        vbuf[(signed long int)vsiz] = (char)0;
                        idmax=atoi(vbuf);
                      }

                      flags=dpgetflags(metadb);
                      zmode = 0;
                      if(!((32768 & flags) == 0))
                        zmode = 32768;

                      else
                        if(!((65536 & flags) == 0))
                          zmode = 65536;

                        else
                          if(!((131072 & flags) == 0))
                            zmode = 131072;

                      dnum = 0;
                      dseq = 0;
                      do
                      {
                        void *return_value_malloc$37;
                        return_value_malloc$37=malloc(sizeof(struct anonymous$1) /*24ul*/ );
                        list = (struct anonymous$1 *)return_value_malloc$37;
                        if(!(list == ((struct anonymous$1 *)NULL)))
                          list;

                        else
                          cbmyfatal("out of memory");
                        list->anum = 64;
                        void *return_value_malloc$38;
                        return_value_malloc$38=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)list->anum);
                        list->array = (struct anonymous$28 *)return_value_malloc$38;
                        if(!(list->array == ((struct anonymous$28 *)NULL)))
                          list->array;

                        else
                          cbmyfatal("out of memory");
                        list->start = 0;
                        list->num = 0;
                      }
                      while((_Bool)0);
                      signed int return_value_criterinit$39;
                      return_value_criterinit$39=criterinit(attrdb);
                      if(return_value_criterinit$39 == 0)
                        err = 1;

                      do
                      {
                        kbuf=criternext(attrdb, &ksiz);
                        if(kbuf == ((char *)NULL))
                          break;

                        if((unsigned long int)ksiz == sizeof(signed int) /*4ul*/ )
                        {
                          id = *((signed int *)kbuf);
                          tmp_if_expr$44 = id > 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr$44 = (_Bool)0;
                        if(idmax >= id && tmp_if_expr$44)
                        {
                          return_value_crvsiz$45=crvsiz(attrdb, kbuf, ksiz);
                          tmp_if_expr$46 = return_value_crvsiz$45 > 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr$46 = (_Bool)0;
                        if(tmp_if_expr$46)
                        {
                          return_value_crvsiz$47=crvsiz(textdb, kbuf, ksiz);
                          tmp_if_expr$48 = return_value_crvsiz$47 > 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr$48 = (_Bool)0;
                        if(tmp_if_expr$48)
                        {
                          dnum = dnum + 1;
                          if(!(dseq >= id))
                            dseq = id;

                          if(!((1 & options) == 0))
                          {
                            mbuf=est_crget(attrdb, zmode, id, &msiz);
                            if(!(mbuf == ((char *)NULL)))
                            {
                              attrs=cbmapload(mbuf, msiz);
                              elem=cbmapget(attrs, "@uri", -1, &esiz);
                              if(!(elem == ((const char *)NULL)))
                              {
                                vsiz=sprintf(vbuf, "%d", id);
                                vlput(listdb, elem, esiz, vbuf, vsiz, 1);
                              }

                              signed int return_value_cbmaprnum$41;
                              return_value_cbmaprnum$41=cbmaprnum(aidxs);
                              if(return_value_cbmaprnum$41 >= 1)
                              {
                                cbmapiterinit(aidxs);
                                do
                                {
                                  abuf=cbmapiternext(aidxs, &asiz);
                                  if(abuf == ((const char *)NULL))
                                    break;

                                  elem=cbmapget(attrs, abuf, asiz, &esiz);
                                  if(!(elem == ((const char *)NULL)))
                                  {
                                    const char *return_value_cbmapiterval$40;
                                    return_value_cbmapiterval$40=cbmapiterval(abuf, (signed int *)(void *)0);
                                    attridxp = (struct anonymous$16 *)return_value_cbmapiterval$40;
                                    if(attridxp->type == 1 || attridxp->type == 2)
                                    {
                                      est_aidx_attr_put((struct anonymous$7 *)attridxp->db, id, elem, esiz);
                                      goto __CPROVER_DUMP_L117;
                                    }

                                    est_aidx_seq_put((struct anonymous$5 *)attridxp->db, id, elem, esiz);
                                  }


                                __CPROVER_DUMP_L117:
                                  ;
                                }
                                while((_Bool)1);
                              }

                              cbmapclose(attrs);
                              free((void *)mbuf);
                            }

                          }

                        }

                        else
                          do
                          {
                            signed int _CB_index = list->start + list->num;
                            if(_CB_index >= list->anum)
                            {
                              list->anum = list->anum * 2;
                              void *return_value_realloc$42;
                              return_value_realloc$42=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
                              list->array = (struct anonymous$28 *)return_value_realloc$42;
                              if(!(list->array == ((struct anonymous$28 *)NULL)))
                                list->array;

                              else
                                cbmyfatal("out of memory");
                            }

                            void *return_value_malloc$43;
                            return_value_malloc$43=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
                            (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$43;
                            if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                              (list->array + (signed long int)_CB_index)->dptr;

                            else
                              cbmyfatal("out of memory");
                            memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
                            (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
                            (list->array + (signed long int)_CB_index)->dsize = ksiz;
                            list->num = list->num + 1;
                          }
                          while((_Bool)0);
                        free((void *)kbuf);
                      }
                      while((_Bool)1);
                      signed int *return_value_dpecodeptr$49;
                      return_value_dpecodeptr$49=dpecodeptr();
                      if(!(*return_value_dpecodeptr$49 == 5))
                        err = 1;

                      i = 0;
                      for( ; !(i >= list->num); i = i + 1)
                      {
                        esiz = (list->array + (signed long int)(list->start + i))->dsize;
                        elem = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
                        crout(attrdb, elem, esiz);
                        crout(textdb, elem, esiz);
                        crout(kwddb, elem, esiz);
                      }
                      do
                      {
                        signed int est_db_repair$$1$$38$$_CB_i;
                        signed int est_db_repair$$1$$38$$_CB_end = list->start + list->num;
                        est_db_repair$$1$$38$$_CB_i = list->start;
                        for( ; !(est_db_repair$$1$$38$$_CB_i >= est_db_repair$$1$$38$$_CB_end); est_db_repair$$1$$38$$_CB_i = est_db_repair$$1$$38$$_CB_i + 1)
                          free((void *)(list->array + (signed long int)est_db_repair$$1$$38$$_CB_i)->dptr);
                        free((void *)list->array);
                        free((void *)list);
                      }
                      while((_Bool)0);
                      sprintf(vbuf, "%d", dseq);
                      signed int return_value_dpput$50;
                      return_value_dpput$50=dpput(metadb, "_dseq", -1, vbuf, -1, 0);
                      if(return_value_dpput$50 == 0)
                        err = 1;

                      sprintf(vbuf, "%d", dnum);
                      signed int return_value_dpput$51;
                      return_value_dpput$51=dpput(metadb, "_dnum", -1, vbuf, -1, 0);
                      if(return_value_dpput$51 == 0)
                        err = 1;

                      cbmapiterinit(aidxs);
                      do
                      {
                        elem=cbmapiternext(aidxs, (signed int *)(void *)0);
                        if(elem == ((const char *)NULL))
                          break;

                        const char *return_value_cbmapiterval$52;
                        return_value_cbmapiterval$52=cbmapiterval(elem, (signed int *)(void *)0);
                        attridxp = (struct anonymous$16 *)return_value_cbmapiterval$52;
                        if(attridxp->type == 1 || attridxp->type == 2)
                        {
                          return_value_vlclose$53=vlclose((struct anonymous$7 *)attridxp->db);
                          if(return_value_vlclose$53 == 0)
                            err = 1;

                          goto __CPROVER_DUMP_L141;
                        }

                        signed int return_value_dpclose$54;
                        return_value_dpclose$54=dpclose((struct anonymous$5 *)attridxp->db);
                        if(return_value_dpclose$54 == 0)
                          err = 1;


                      __CPROVER_DUMP_L141:
                        ;
                      }
                      while((_Bool)1);
                      cbmapclose(aidxs);
                      signed int return_value_vlclose$55;
                      return_value_vlclose$55=vlclose(listdb);
                      if(return_value_vlclose$55 == 0)
                        err = 1;

                      signed int return_value_crclose$56;
                      return_value_crclose$56=crclose(kwddb);
                      if(return_value_crclose$56 == 0)
                        err = 1;

                      signed int return_value_crclose$57;
                      return_value_crclose$57=crclose(textdb);
                      if(return_value_crclose$57 == 0)
                        err = 1;

                      signed int return_value_crclose$58;
                      return_value_crclose$58=crclose(attrdb);
                      if(return_value_crclose$58 == 0)
                        err = 1;

                      signed int return_value_dpclose$59;
                      return_value_dpclose$59=dpclose(metadb);
                      if(return_value_dpclose$59 == 0)
                        err = 1;

                      if(!(err == 0))
                      {
                        est_set_ecode(ecp, 4, 5418);
                        return 0;
                      }

                      else
                        return err != 0 ? 0 : 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// est_db_scan_doc
// file estraier.c line 3226
signed int est_db_scan_doc(struct anonymous *db, struct anonymous$0 *doc, struct anonymous$8 *cond)
{
  /* tag-#anon#lST[l*{S8}$S8$'word'|S32'num'|U32'$pad0'] */
struct anonymous$33
{
  // word
  char *word;
  // num
  signed int num;
};

/* */
  ;
  struct anonymous$33 wsets[256l];
  struct anonymous$1 *terms;
  struct anonymous$1 *words;
  const char *term;
  const char *text;
  unsigned char *rbuf;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int wsnum;
  signed int add;
  signed int rsiz;
  signed int hit;
  _Bool tmp_if_expr$2;
  signed int return_value_cbstrfwmatch$1;
  if(cond->phrase == ((char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch$1=cbstrfwmatch(cond->phrase, "[SIMILAR]");
    tmp_if_expr$2 = return_value_cbstrfwmatch$1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  signed int return_value_cbstrfwmatch$3;
  if(tmp_if_expr$2)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch$3=cbstrfwmatch(cond->phrase, "[ID]");
    tmp_if_expr$4 = return_value_cbstrfwmatch$3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$6;
  signed int return_value_cbstrfwmatch$5;
  if(tmp_if_expr$4)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch$5=cbstrfwmatch(cond->phrase, "[URI]");
    tmp_if_expr$6 = return_value_cbstrfwmatch$5 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  _Bool tmp_if_expr$12;
  if(tmp_if_expr$6)
    return 0;

  else
  {
    if(doc->dtexts == ((struct anonymous$1 *)NULL))
      do
      {
        void *return_value_malloc$7;
        return_value_malloc$7=malloc(sizeof(struct anonymous$1) /*24ul*/ );
        doc->dtexts = (struct anonymous$1 *)return_value_malloc$7;
        if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
          doc->dtexts;

        else
          cbmyfatal("out of memory");
        doc->dtexts->anum = 64;
        void *return_value_malloc$8;
        return_value_malloc$8=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
        doc->dtexts->array = (struct anonymous$28 *)return_value_malloc$8;
        if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
          doc->dtexts->array;

        else
          cbmyfatal("out of memory");
        doc->dtexts->start = 0;
        doc->dtexts->num = 0;
      }
      while((_Bool)0);

    if(!(cond->pmode == 1))
    {
      if(cond->pmode == 2)
        goto __CPROVER_DUMP_L15;

      if(cond->pmode == 3)
        goto __CPROVER_DUMP_L16;

      if(cond->pmode == 4)
        goto __CPROVER_DUMP_L17;

      terms=est_phrase_terms(cond->phrase);
    }

    else
    {
      tmp=est_phrase_from_simple(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L15:
      ;
      tmp=est_phrase_from_rough(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L16:
      ;
      tmp=est_phrase_from_union(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L17:
      ;
      tmp=est_phrase_from_isect(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
    }

  __CPROVER_DUMP_L18:
    ;
    wsnum = 0;
    add = 1;
    i = 0;
    for( ; !(i >= terms->num); i = i + 1)
    {
      term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
      signed int return_value_strcmp$11;
      return_value_strcmp$11=strcmp(term, "AND");
      if(return_value_strcmp$11 == 0)
        add = 1;

      else
      {
        return_value_strcmp$10=strcmp(term, "ANDNOT");
        if(return_value_strcmp$10 == 0)
          add = 0;

        else
          if(!(add == 0))
          {
            return_value_strcmp$9=strcmp(term, "[UVSET]");
            if(!(return_value_strcmp$9 == 0))
            {
              if((signed int)*term == 32)
              {
                term = term + 1l;
                if((signed int)*term == 98)
                  term = term + 1l;

                else
                  if((signed int)*term == 101)
                    term = term + 1l;

              }

              words=cbsplit(term, -1, "\t");
              for( ; !(wsnum >= 256); wsnum = wsnum + 1)
              {
                if(!(words->num >= 1))
                  break;

                wsets[(signed long int)wsnum].word=cblistshift(words, (signed int *)(void *)0);
                wsets[(signed long int)wsnum].num = i;
              }
              do
              {
                signed int _CB_i;
                signed int _CB_end = words->start + words->num;
                _CB_i = words->start;
                for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                  free((void *)(words->array + (signed long int)_CB_i)->dptr);
                free((void *)words->array);
                free((void *)words);
              }
              while((_Bool)0);
            }

          }

      }
    }
    i = -1;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      if(!(i >= 0))
      {
        if(doc->attrs == ((struct anonymous$9 *)NULL))
          tmp_if_expr$12 = (_Bool)1;

        else
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          tmp_if_expr$12 = !(text != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$12)
          goto __CPROVER_DUMP_L41;

      }

      else
        text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      unsigned long int return_value_strlen$13;
      return_value_strlen$13=strlen(text);
      char *return_value_est_uconv_in$14;
      return_value_est_uconv_in$14=est_uconv_in(text, (signed int)return_value_strlen$13, &rsiz);
      rbuf = (unsigned char *)return_value_est_uconv_in$14;
      est_canonicalize_text(rbuf, rsiz, 0);
      tmp=est_uconv_out((char *)rbuf, rsiz, &rsiz);
      j = 0;
      for( ; !(j >= wsnum); j = j + 1)
        if(!(wsets[(signed long int)j].word == ((char *)NULL)))
        {
          char *return_value_est_strstr_sparse$15;
          return_value_est_strstr_sparse$15=est_strstr_sparse(tmp, wsets[(signed long int)j].word);
          if(!(return_value_est_strstr_sparse$15 == ((char *)NULL)))
          {
            k = 0;
            for( ; !(k >= wsnum); k = k + 1)
              if(!(wsets[(signed long int)k].word == ((char *)NULL)))
              {
                if(wsets[(signed long int)k].num == wsets[(signed long int)j].num)
                {
                  free((void *)wsets[(signed long int)k].word);
                  wsets[(signed long int)k].word = (char *)(void *)0;
                }

              }

          }

        }

      free((void *)tmp);
      free((void *)rbuf);

    __CPROVER_DUMP_L41:
      ;
    }
    hit = 1;
    i = 0;
    for( ; !(i >= wsnum); i = i + 1)
      if(!(wsets[(signed long int)i].word == ((char *)NULL)))
      {
        free((void *)wsets[(signed long int)i].word);
        hit = 0;
      }

    do
    {
      signed int est_db_scan_doc$$1$$6$$_CB_i;
      signed int est_db_scan_doc$$1$$6$$_CB_end = terms->start + terms->num;
      est_db_scan_doc$$1$$6$$_CB_i = terms->start;
      for( ; !(est_db_scan_doc$$1$$6$$_CB_i >= est_db_scan_doc$$1$$6$$_CB_end); est_db_scan_doc$$1$$6$$_CB_i = est_db_scan_doc$$1$$6$$_CB_i + 1)
        free((void *)(terms->array + (signed long int)est_db_scan_doc$$1$$6$$_CB_i)->dptr);
      free((void *)terms->array);
      free((void *)terms);
    }
    while((_Bool)0);
    return hit;
  }
}

// est_db_score_doc
// file estraier.c line 7836
static signed int est_db_score_doc(struct anonymous *db, struct anonymous$0 *doc, struct anonymous$8 *cond, signed int *scp)
{
  /* tag-#anon#lST[l*{S8}$S8$'word'|S32'num'|U32'$pad0'] */
struct anonymous$33
{
  // word
  char *word;
  // num
  signed int num;
};

/* */
  ;
  struct anonymous$33 wsets[256l];
  struct anonymous$33 nsets[256l];
  struct anonymous$1 *terms;
  struct anonymous$1 *words;
  const char *term;
  const char *text;
  const char *rp;
  unsigned char *rbuf;
  char *tmp;
  signed int i;
  signed int j;
  signed int k;
  signed int sc;
  signed int wsnum;
  signed int nsnum;
  signed int asiz;
  signed int tsiz;
  signed int add;
  signed int rsiz;
  signed int hit;
  double tune;
  *scp = 0;
  _Bool tmp_if_expr$2;
  signed int return_value_cbstrfwmatch$1;
  if(cond->phrase == ((char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch$1=cbstrfwmatch(cond->phrase, "[SIMILAR]");
    tmp_if_expr$2 = return_value_cbstrfwmatch$1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  signed int return_value_cbstrfwmatch$3;
  if(tmp_if_expr$2)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch$3=cbstrfwmatch(cond->phrase, "[ID]");
    tmp_if_expr$4 = return_value_cbstrfwmatch$3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$6;
  signed int return_value_cbstrfwmatch$5;
  if(tmp_if_expr$4)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_cbstrfwmatch$5=cbstrfwmatch(cond->phrase, "[URI]");
    tmp_if_expr$6 = return_value_cbstrfwmatch$5 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_atoi$12;
  _Bool tmp_if_expr$13;
  if(tmp_if_expr$6)
    return 0;

  else
  {
    if(doc->dtexts == ((struct anonymous$1 *)NULL))
      do
      {
        void *return_value_malloc$7;
        return_value_malloc$7=malloc(sizeof(struct anonymous$1) /*24ul*/ );
        doc->dtexts = (struct anonymous$1 *)return_value_malloc$7;
        if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
          doc->dtexts;

        else
          cbmyfatal("out of memory");
        doc->dtexts->anum = 64;
        void *return_value_malloc$8;
        return_value_malloc$8=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
        doc->dtexts->array = (struct anonymous$28 *)return_value_malloc$8;
        if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
          doc->dtexts->array;

        else
          cbmyfatal("out of memory");
        doc->dtexts->start = 0;
        doc->dtexts->num = 0;
      }
      while((_Bool)0);

    if(!(cond->pmode == 1))
    {
      if(cond->pmode == 2)
        goto __CPROVER_DUMP_L15;

      if(cond->pmode == 3)
        goto __CPROVER_DUMP_L16;

      if(cond->pmode == 4)
        goto __CPROVER_DUMP_L17;

      terms=est_phrase_terms(cond->phrase);
    }

    else
    {
      tmp=est_phrase_from_simple(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L15:
      ;
      tmp=est_phrase_from_rough(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L16:
      ;
      tmp=est_phrase_from_union(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
      goto __CPROVER_DUMP_L18;

    __CPROVER_DUMP_L17:
      ;
      tmp=est_phrase_from_isect(cond->phrase);
      terms=est_phrase_terms(tmp);
      free((void *)tmp);
    }

  __CPROVER_DUMP_L18:
    ;
    wsnum = 0;
    nsnum = 0;
    add = 1;
    i = 0;
    for( ; !(i >= terms->num); i = i + 1)
    {
      term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
      signed int return_value_strcmp$11;
      return_value_strcmp$11=strcmp(term, "AND");
      if(return_value_strcmp$11 == 0)
        add = 1;

      else
      {
        return_value_strcmp$10=strcmp(term, "ANDNOT");
        if(return_value_strcmp$10 == 0)
          add = 0;

        else
        {
          return_value_strcmp$9=strcmp(term, "[UVSET]");
          if(!(return_value_strcmp$9 == 0))
          {
            if((signed int)*term == 32)
            {
              term = term + 1l;
              if((signed int)*term == 98)
                term = term + 1l;

              else
                if((signed int)*term == 101)
                  term = term + 1l;

            }

            words=cbsplit(term, -1, "\t");
            if(!(add == 0))
              for( ; !(wsnum >= 256); wsnum = wsnum + 1)
              {
                if(!(words->num >= 1))
                  break;

                wsets[(signed long int)wsnum].word=cblistshift(words, (signed int *)(void *)0);
                wsets[(signed long int)wsnum].num = i;
              }

            else
              for( ; !(nsnum >= 256); nsnum = nsnum + 1)
              {
                if(!(words->num >= 1))
                  break;

                nsets[(signed long int)nsnum].word=cblistshift(words, (signed int *)(void *)0);
                nsets[(signed long int)nsnum].num = i;
              }
            do
            {
              signed int est_db_score_doc$$1$$3$$1$$3$$4$$_CB_i;
              signed int est_db_score_doc$$1$$3$$1$$3$$4$$_CB_end = words->start + words->num;
              est_db_score_doc$$1$$3$$1$$3$$4$$_CB_i = words->start;
              for( ; !(est_db_score_doc$$1$$3$$1$$3$$4$$_CB_i >= est_db_score_doc$$1$$3$$1$$3$$4$$_CB_end); est_db_score_doc$$1$$3$$1$$3$$4$$_CB_i = est_db_score_doc$$1$$3$$1$$3$$4$$_CB_i + 1)
                free((void *)(words->array + (signed long int)est_db_score_doc$$1$$3$$1$$3$$4$$_CB_i)->dptr);
              free((void *)words->array);
              free((void *)words);
            }
            while((_Bool)0);
          }

        }
      }
    }
    asiz = 0;
    sc = 0;
    rp=cbmapget(doc->attrs, "\t", 1, (signed int *)(void *)0);
    if(!(rp == ((const char *)NULL)))
    {
      return_value_atoi$12=atoi(rp);
      sc = -1 - return_value_atoi$12;
    }

    i = -1;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      if(!(i >= 0))
      {
        if(doc->attrs == ((struct anonymous$9 *)NULL))
          tmp_if_expr$13 = (_Bool)1;

        else
        {
          text=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
          tmp_if_expr$13 = !(text != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$13)
          goto __CPROVER_DUMP_L50;

        unsigned long int return_value_strlen$14;
        return_value_strlen$14=strlen(text);
        asiz = asiz + (signed int)return_value_strlen$14;
      }

      else
      {
        tsiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
        text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
        asiz = asiz + tsiz;
      }
      unsigned long int return_value_strlen$15;
      return_value_strlen$15=strlen(text);
      char *return_value_est_uconv_in$16;
      return_value_est_uconv_in$16=est_uconv_in(text, (signed int)return_value_strlen$15, &rsiz);
      rbuf = (unsigned char *)return_value_est_uconv_in$16;
      est_canonicalize_text(rbuf, rsiz, 0);
      tmp=est_uconv_out((char *)rbuf, rsiz, &rsiz);
      j = 0;
      for( ; !(j >= wsnum); j = j + 1)
        if(!(wsets[(signed long int)j].word == ((char *)NULL)))
        {
          rp=est_strstr_sparse(tmp, wsets[(signed long int)j].word);
          if(!(rp == ((const char *)NULL)))
          {
            if(sc >= 0)
              do
              {
                sc = sc + 16;
                unsigned long int return_value_strlen$17;
                return_value_strlen$17=strlen(wsets[(signed long int)j].word);
                rp = rp + (signed long int)return_value_strlen$17;
                rp=est_strstr_sparse(rp, wsets[(signed long int)j].word);
              }
              while(!(rp == ((const char *)NULL)));

            k = 0;
            for( ; !(k >= wsnum); k = k + 1)
              if(!(wsets[(signed long int)k].word == ((char *)NULL)))
              {
                if(wsets[(signed long int)k].num == wsets[(signed long int)j].num)
                {
                  free((void *)wsets[(signed long int)k].word);
                  wsets[(signed long int)k].word = (char *)(void *)0;
                }

              }

          }

        }

      j = 0;
      for( ; !(j >= nsnum); j = j + 1)
        if(!(nsets[(signed long int)j].word == ((char *)NULL)))
        {
          rp=est_strstr_sparse(tmp, nsets[(signed long int)j].word);
          if(!(rp == ((const char *)NULL)))
          {
            k = 0;
            for( ; !(k >= nsnum); k = k + 1)
              if(!(nsets[(signed long int)k].word == ((char *)NULL)))
              {
                if(nsets[(signed long int)k].num == nsets[(signed long int)j].num)
                {
                  free((void *)nsets[(signed long int)k].word);
                  nsets[(signed long int)k].word = (char *)(void *)0;
                }

              }

          }

        }

      free((void *)tmp);
      free((void *)rbuf);

    __CPROVER_DUMP_L50:
      ;
    }
    hit = 1;
    i = 0;
    for( ; !(i >= wsnum); i = i + 1)
      if(!(wsets[(signed long int)i].word == ((char *)NULL)))
      {
        free((void *)wsets[(signed long int)i].word);
        hit = 0;
      }

    i = 0;
    for( ; !(i >= nsnum); i = i + 1)
      if(nsets[(signed long int)i].word == ((char *)NULL))
        hit = 0;

      else
        free((void *)nsets[(signed long int)i].word);
    do
    {
      signed int _CB_i;
      signed int _CB_end = terms->start + terms->num;
      _CB_i = terms->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(terms->array + (signed long int)_CB_i)->dptr);
      free((void *)terms->array);
      free((void *)terms);
    }
    while((_Bool)0);
    if(!(sc >= 0))
      sc = -1 - sc;

    double return_value_sqrt$18;
    return_value_sqrt$18=sqrt((double)asiz / 8.0 + (double)128);
    tune = return_value_sqrt$18 / 16.0;
    if(!(db->smode == 1048576))
    {
      if(db->smode == 2097152)
        goto __CPROVER_DUMP_L66;

      if(db->smode == 4194304)
        goto __CPROVER_DUMP_L67;

    }

    else
    {
      sc = 0;
      goto __CPROVER_DUMP_L67;
    }
    sc = sc / (signed int)tune;
    if(sc >= 0x80)
      sc = sc + (signed int)((double)(0x80 - sc) * 0.75);

    if(sc >= 0xc0)
      sc = sc + (signed int)((double)(0xc0 - sc) * 0.75);

    sc = sc < 0xff ? sc : 0xff;
    goto __CPROVER_DUMP_L67;

  __CPROVER_DUMP_L66:
    ;
    sc = sc / (signed int)tune;

  __CPROVER_DUMP_L67:
    ;
    *scp = sc;
    return hit;
  }
}

// est_db_search
// file estraier.c line 2746
signed int * est_db_search(struct anonymous *db, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints)
{
  struct anonymous$6 *scores;
  struct anonymous$6 *tscores;
  struct anonymous$9 *svmap;
  struct anonymous$9 *ordattrs;
  struct anonymous$1 *terms;
  const char *term;
  const char *rp;
  char *tmp;
  char numbuf[32l];
  const signed int *nscores;
  signed int i;
  signed int j;
  signed int snum;
  signed int ign;
  signed int nsnum;
  signed int unum;
  signed int knum;
  signed int mnum;
  signed int top;
  signed int pcnum;
  signed int ncnum;
  signed int tsnum;
  signed int add;
  signed int nnum;
  signed int id;
  signed int score;
  signed int hnum;
  signed int len;
  signed int rest;
  signed int *rval;
  signed int rnum;
  double tune;
  if(!(cond->auxwords == ((struct anonymous$9 *)NULL)))
    cbmapclose(cond->auxwords);

  cond->auxwords=cbmapopenex(31);
  scores = (struct anonymous$6 *)(void *)0;
  snum = 0;
  ign = -1;
  nscores = cond->nscores;
  nsnum = cond->nsnum;
  signed int tmp_if_expr$1;
  if(!(cond->order == ((char *)NULL)))
    tmp_if_expr$1 = (signed int)db->pdocs->num + 31;

  else
    tmp_if_expr$1 = 1;
  ordattrs=cbmapopenex(tmp_if_expr$1);
  signed int return_value_cbstrfwmatch$22;
  signed int return_value_cbstrfwmatch$21;
  signed int return_value_cbstrfwmatch$20;
  signed int return_value_strcmp$15;
  _Bool tmp_if_expr$10;
  signed int tmp_if_expr$11;
  signed int tmp_if_expr$14;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  if(!(cond->phrase == ((char *)NULL)))
  {
    signed int return_value_cbstrfwmatch$23;
    return_value_cbstrfwmatch$23=cbstrfwmatch(cond->phrase, "[ID]");
    if(!(return_value_cbstrfwmatch$23 == 0))
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen("[ID]");
      id=atoi(cond->phrase + (signed long int)return_value_strlen$4);
      if(id >= 1)
      {
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(sizeof(struct anonymous$6) /*16ul*/ );
        scores = (struct anonymous$6 *)return_value_malloc$2;
        if(!(scores == ((struct anonymous$6 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        (scores + (signed long int)0)->id = id;
        (scores + (signed long int)0)->score = 0;
        (scores + (signed long int)0)->value = (char *)(void *)0;
        snum = 1;
      }

      else
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc((unsigned long int)1);
        scores = (struct anonymous$6 *)return_value_malloc$3;
        if(!(scores == ((struct anonymous$6 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        snum = 0;
      }
    }

    else
    {
      return_value_cbstrfwmatch$22=cbstrfwmatch(cond->phrase, "[URI]");
      if(!(return_value_cbstrfwmatch$22 == 0))
      {
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen("[URI]");
        rp = cond->phrase + (signed long int)return_value_strlen$5;
        for( ; (signed int)*rp >= 1; rp = rp + 1l)
          if((signed int)*rp >= 33)
            break;

        id=est_db_uri_to_id(db, rp);
        if(id >= 1)
        {
          void *return_value_malloc$6;
          return_value_malloc$6=malloc(sizeof(struct anonymous$6) /*16ul*/ );
          scores = (struct anonymous$6 *)return_value_malloc$6;
          if(!(scores == ((struct anonymous$6 *)NULL)))
            scores;

          else
            cbmyfatal("out of memory");
          (scores + (signed long int)0)->id = id;
          (scores + (signed long int)0)->score = 0;
          (scores + (signed long int)0)->value = (char *)(void *)0;
          snum = 1;
        }

        else
        {
          void *return_value_malloc$7;
          return_value_malloc$7=malloc((unsigned long int)1);
          scores = (struct anonymous$6 *)return_value_malloc$7;
          if(!(scores == ((struct anonymous$6 *)NULL)))
            scores;

          else
            cbmyfatal("out of memory");
          snum = 0;
        }
      }

      else
      {
        return_value_cbstrfwmatch$21=cbstrfwmatch(cond->phrase, "[SIMILAR]");
        if(!(return_value_cbstrfwmatch$21 == 0))
        {
          unsigned long int return_value_strlen$8;
          return_value_strlen$8=strlen("[SIMILAR]");
          rp = cond->phrase + (signed long int)return_value_strlen$8;
          for( ; (signed int)*rp >= 1; rp = rp + 1l)
            if((signed int)*rp >= 33)
              break;

          knum = -1;
          unum = -1;
          mnum = -1;
          if((signed int)*rp >= 48)
          {
            if(!((signed int)*rp >= 58))
            {
              knum=atoi(rp);
              for( ; (signed int)*rp >= 48; rp = rp + 1l)
                if((signed int)*rp >= 58)
                  break;

              for( ; (signed int)*rp >= 1; rp = rp + 1l)
                if((signed int)*rp >= 33)
                  break;

              if((signed int)*rp >= 48)
              {
                if(!((signed int)*rp >= 58))
                {
                  unum=atoi(rp);
                  for( ; (signed int)*rp >= 48; rp = rp + 1l)
                    if((signed int)*rp >= 58)
                      break;

                  for( ; (signed int)*rp >= 1; rp = rp + 1l)
                    if((signed int)*rp >= 33)
                      break;

                  if((signed int)*rp >= 48)
                  {
                    if(!((signed int)*rp >= 58))
                    {
                      mnum=atoi(rp);
                      for( ; (signed int)*rp >= 48; rp = rp + 1l)
                        if((signed int)*rp >= 58)
                          break;

                      for( ; (signed int)*rp >= 1; rp = rp + 1l)
                        if((signed int)*rp >= 33)
                          break;

                    }

                  }

                }

              }

            }

          }

          if(!(knum >= 1))
            knum = 16;

          if(!(unum >= 1))
            unum = 1024;

          if(!(mnum >= 1))
            mnum = 4096;

          svmap=est_phrase_vector(rp);
          scores=est_search_similar(db, svmap, &snum, knum, unum, mnum, cond->tfidf, cond->order != ((char *)NULL) ? 0.5 : 0.0, cond->auxmin, cond->auxwords);
          cbmapclose(svmap);
        }

        else
        {
          return_value_cbstrfwmatch$20=cbstrfwmatch(cond->phrase, "[RANK]");
          if(!(return_value_cbstrfwmatch$20 == 0))
          {
            unsigned long int return_value_strlen$9;
            return_value_strlen$9=strlen("[RANK]");
            rp = cond->phrase + (signed long int)return_value_strlen$9;
            for( ; (signed int)*rp >= 1; rp = rp + 1l)
              if((signed int)*rp >= 33)
                break;

            top=atoi(rp);
            for( ; (_Bool)1; rp = rp + 1l)
              if((signed int)*rp >= 48)
              {
                if((signed int)*rp >= 58)
                  goto __CPROVER_DUMP_L38;

              }

              else
              {

              __CPROVER_DUMP_L38:
                ;
                if(!((signed int)*rp == 45))
                  goto __CPROVER_DUMP_L40;

              }

          __CPROVER_DUMP_L40:
            ;
            for( ; (signed int)*rp >= 1; rp = rp + 1l)
              if((signed int)*rp >= 33)
                break;

            scores=est_search_rank(db, rp, top, &snum);
          }

          else
          {
            if(!(cond->pmode == 1))
            {
              if(cond->pmode == 2)
                goto __CPROVER_DUMP_L44;

              if(cond->pmode == 3)
                goto __CPROVER_DUMP_L45;

              if(cond->pmode == 4)
                goto __CPROVER_DUMP_L46;

              terms=est_phrase_terms(cond->phrase);
            }

            else
            {
              tmp=est_phrase_from_simple(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
              goto __CPROVER_DUMP_L47;

            __CPROVER_DUMP_L44:
              ;
              tmp=est_phrase_from_rough(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
              goto __CPROVER_DUMP_L47;

            __CPROVER_DUMP_L45:
              ;
              tmp=est_phrase_from_union(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
              goto __CPROVER_DUMP_L47;

            __CPROVER_DUMP_L46:
              ;
              tmp=est_phrase_from_isect(cond->phrase);
              terms=est_phrase_terms(tmp);
              free((void *)tmp);
            }

          __CPROVER_DUMP_L47:
            ;
            pcnum = 0;
            ncnum = 0;
            add = 1;
            i = 0;
            for( ; !(i >= terms->num); i = i + 1)
            {
              term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
              signed int return_value_strcmp$16;
              return_value_strcmp$16=strcmp(term, "AND");
              if(return_value_strcmp$16 == 0)
                add = 1;

              else
              {
                return_value_strcmp$15=strcmp(term, "ANDNOT");
                if(return_value_strcmp$15 == 0)
                  add = 0;

                else
                {
                  signed int return_value_strcmp$12;
                  return_value_strcmp$12=strcmp(term, "[UVSET]");
                  if(return_value_strcmp$12 == 0)
                    tscores=est_search_uvset(db, &tsnum, hints, add);

                  else
                  {
                    if(!(add == 0))
                      tmp_if_expr$10 = !(cond->order != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$10 = (_Bool)0;
                    if(tmp_if_expr$10)
                      tmp_if_expr$11 = cond->auxmin;

                    else
                      tmp_if_expr$11 = -1;
                    tscores=est_search_union(db, term, cond->gstep, cond->cbxpn, &tsnum, hints, add, tmp_if_expr$11, cond->auxwords);
                  }
                  if(!(add == 0))
                  {
                    if(!(db->smode == 4194304))
                    {
                      if(!(cond->tfidf == 0))
                      {
                        tune=pow((double)(tsnum + 64), 0.4);
                        j = 0;
                        for( ; !(j >= tsnum); j = j + 1)
                          (tscores + (signed long int)j)->score = (tscores + (signed long int)j)->score * (signed int)(100.0 / tune);
                      }

                      else
                      {
                        j = 0;
                        for( ; !(j >= tsnum); j = j + 1)
                          (tscores + (signed long int)j)->score = (tscores + (signed long int)j)->score * 10;
                      }
                    }

                    pcnum = pcnum + 1;
                  }

                  else
                    ncnum = ncnum + 1;
                  if(!(scores == ((struct anonymous$6 *)NULL)))
                  {
                    void *return_value_realloc$13;
                    return_value_realloc$13=realloc((void *)scores, (unsigned long int)(snum + tsnum) * sizeof(struct anonymous$6) /*16ul*/  + (unsigned long int)1);
                    scores = (struct anonymous$6 *)return_value_realloc$13;
                    if(!(scores == ((struct anonymous$6 *)NULL)))
                      scores;

                    else
                      cbmyfatal("out of memory");
                    j = 0;
                    for( ; !(j >= tsnum); j = j + 1)
                    {
                      (scores + (signed long int)(snum + j))->id = (tscores + (signed long int)j)->id;
                      if(!(add == 0))
                        tmp_if_expr$14 = (tscores + (signed long int)j)->score;

                      else
                        tmp_if_expr$14 = -1;
                      (scores + (signed long int)(snum + j))->score = tmp_if_expr$14;
                      (scores + (signed long int)(snum + j))->value = (char *)(void *)0;
                    }
                    snum = snum + tsnum;
                    free((void *)tscores);
                  }

                  else
                  {
                    scores = tscores;
                    snum = tsnum;
                  }
                }
              }
            }
            if(!(scores == ((struct anonymous$6 *)NULL)))
            {
              if(ncnum >= 1 || pcnum >= 2)
              {
                qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
                nnum = 0;
                i = 0;
                for( ; !(i >= snum); i = i + 1)
                {
                  id = (scores + (signed long int)i)->id;
                  score = (scores + (signed long int)i)->score;
                  hnum = score >= 0 ? 1 : 0;
                  j = i + 1;
                  do
                  {
                    if(!(j >= snum))
                      tmp_if_expr$17 = (scores + (signed long int)j)->id == id ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$17 = (_Bool)0;
                    if(!tmp_if_expr$17)
                      break;

                    if(score >= 0)
                      tmp_if_expr$18 = (scores + (signed long int)j)->score >= 0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$18 = (_Bool)0;
                    if(tmp_if_expr$18)
                    {
                      if(!(db->smode == 4194304))
                        score = score + (scores + (signed long int)j)->score;

                      hnum = hnum + 1;
                    }

                    else
                      score = -1;
                    j = j + 1;
                  }
                  while((_Bool)1);
                  if(hnum >= pcnum && score >= 0)
                  {
                    (scores + (signed long int)nnum)->id = id;
                    (scores + (signed long int)nnum)->score = score;
                    (scores + (signed long int)nnum)->value = (char *)(void *)0;
                    nnum = nnum + 1;
                  }

                  i = j - 1;
                }
                snum = nnum;
              }

            }

            else
            {
              void *return_value_malloc$19;
              return_value_malloc$19=malloc((unsigned long int)1);
              scores = (struct anonymous$6 *)return_value_malloc$19;
              if(!(scores == ((struct anonymous$6 *)NULL)))
                scores;

              else
                cbmyfatal("out of memory");
              snum = 0;
            }
            do
            {
              signed int _CB_i;
              signed int _CB_end = terms->start + terms->num;
              _CB_i = terms->start;
              for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                free((void *)(terms->array + (signed long int)_CB_i)->dptr);
              free((void *)terms->array);
              free((void *)terms);
            }
            while((_Bool)0);
          }
        }
      }
    }
  }

  else
    if(!(cond->attrs == ((struct anonymous$1 *)NULL)))
    {
      if(!(nscores == ((const signed int *)NULL)) && !(nsnum >= 4))
      {
        void *return_value_malloc$24;
        return_value_malloc$24=malloc((unsigned long int)nsnum * sizeof(struct anonymous$6) /*16ul*/  + (unsigned long int)1);
        scores = (struct anonymous$6 *)return_value_malloc$24;
        if(!(scores == ((struct anonymous$6 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        nnum = 0;
        i = 0;
        for( ; !(i >= nsnum); i = i + 1)
        {
          sprintf(numbuf, "%d", nscores[(signed long int)i]);
          id=est_db_uri_to_id(db, numbuf);
          if(id >= 1)
          {
            (scores + (signed long int)nnum)->id = id;
            (scores + (signed long int)nnum)->score = nscores[(signed long int)i];
            (scores + (signed long int)nnum)->value = (char *)(void *)0;
            nnum = nnum + 1;
          }

        }
        snum = nnum;
        nscores = (const signed int *)(void *)0;
        nsnum = -1;
      }

      else
      {
        scores = (struct anonymous$6 *)(void *)0;
        i = 0;
        for( ; !(i >= cond->attrs->num); i = i + 1)
        {
          scores=est_search_aidx_attr(db, (const char *)(cond->attrs->array + (signed long int)(cond->attrs->start + i))->dptr, &snum);
          if(!(scores == ((struct anonymous$6 *)NULL)))
          {
            ign = i;
            break;
          }

        }
        if(scores == ((struct anonymous$6 *)NULL))
          scores=est_search_uvset(db, &snum, hints, 1);

      }
    }

    else
    {
      void *return_value_malloc$25;
      return_value_malloc$25=malloc((unsigned long int)1);
      scores = (struct anonymous$6 *)return_value_malloc$25;
      if(!(scores == ((struct anonymous$6 *)NULL)))
        scores;

      else
        cbmyfatal("out of memory");
      snum = 0;
    }
  if(db->pdocs->num >= 1)
    scores=est_search_pidxs(db, cond, scores, &snum, ordattrs);

  if(!(nscores == ((const signed int *)NULL)))
  {
    if(!(cond->phrase == ((char *)NULL)))
    {
      if(!((signed int)*cond->phrase == 0))
      {
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);
        nnum = 0;
        j = 0;
        i = 0;
        for( ; !(i >= snum); i = i + 1)
        {
          id = (scores + (signed long int)i)->id;
          score = (scores + (signed long int)i)->score;
          for( ; !(j >= nsnum); j = j + 1)
            if(score >= nscores[(signed long int)j])
              break;

          if(!(j >= nsnum))
          {
            if(nscores[(signed long int)j] == score)
            {
              (scores + (signed long int)nnum)->id = id;
              (scores + (signed long int)nnum)->score = score;
              (scores + (signed long int)nnum)->value = (char *)(void *)0;
              nnum = nnum + 1;
              j = j + 1;
            }

          }

        }
        snum = nnum;
      }

    }

  }

  signed int return_value_cbmaprnum$28;
  return_value_cbmaprnum$28=cbmaprnum(db->outcc);
  signed int tmp_post$27;
  if(return_value_cbmaprnum$28 >= 1)
  {
    tsnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      len=sprintf(numbuf, "\t%d", (scores + (signed long int)i)->id);
      const char *return_value_cbmapget$26;
      return_value_cbmapget$26=cbmapget(db->outcc, numbuf, len, (signed int *)(void *)0);
      if(return_value_cbmapget$26 == ((const char *)NULL))
      {
        tmp_post$27 = tsnum;
        tsnum = tsnum + 1;
        scores[(signed long int)tmp_post$27] = scores[(signed long int)i];
      }

    }
    snum = tsnum;
  }

  _Bool tmp_if_expr$31;
  if(cond->max >= 1)
    tmp_if_expr$31 = (double)cond->max * 1.5 + (double)1 < (double)snum ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$31 = (_Bool)0;
  _Bool tmp_if_expr$32;
  if(tmp_if_expr$31)
    tmp_if_expr$32 = cond->attrs != ((struct anonymous$1 *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$32 = (_Bool)0;
  _Bool tmp_if_expr$33;
  if(tmp_if_expr$32)
    tmp_if_expr$33 = !(cond->order != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$33 = (_Bool)0;
  _Bool tmp_if_expr$34;
  if(tmp_if_expr$33)
    tmp_if_expr$34 = !(cond->distinct != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$34 = (_Bool)0;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$30;
  if(tmp_if_expr$34)
  {
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);
    nnum=est_narrow_scores(db, cond->attrs, ign, cond->order, cond->distinct, scores, snum, (signed int)((double)cond->max * 1.5 + (double)1), &rest, ordattrs);
    if(!(hints == ((struct anonymous$9 *)NULL)))
    {
      sprintf(numbuf, "%d", rest > cond->max / 2 ? (signed int)((double)snum * ((double)nnum / (double)(snum - rest))) : nnum);
      cbmapput(hints, "", 0, numbuf, -1, 1);
    }

    snum = nnum;
  }

  else
  {
    if(!(cond->attrs == ((struct anonymous$1 *)NULL)))
      tmp_if_expr$29 = (_Bool)1;

    else
      tmp_if_expr$29 = cond->order != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$29)
      tmp_if_expr$30 = (_Bool)1;

    else
      tmp_if_expr$30 = cond->distinct != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$30)
      snum=est_narrow_scores(db, cond->attrs, ign, cond->order, cond->distinct, scores, snum, 0x7fffffff, &rest, ordattrs);

    if(cond->order == ((char *)NULL))
      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);

    if(!(hints == ((struct anonymous$9 *)NULL)))
    {
      sprintf(numbuf, "%d", snum);
      cbmapput(hints, "", 0, numbuf, -1, 1);
    }

  }
  if(!(cond->shadows == ((struct anonymous$9 *)NULL)))
    cbmapclose(cond->shadows);

  signed int tmp_if_expr$35;
  if(cond->ecllim >= 0.0)
  {
    cond->shadows=cbmapopenex(snum + 1);
    if(cond->max >= 1)
      tmp_if_expr$35 = cond->max;

    else
      tmp_if_expr$35 = snum;
    snum=est_eclipse_scores(db, scores, snum, tmp_if_expr$35, 32, cond->tfidf, cond->ecllim, cond->shadows);
  }

  else
    cond->shadows = (struct anonymous$9 *)(void *)0;
  rnum = snum - cond->skip;
  if(!(rnum >= 0))
    rnum = 0;

  if(cond->max >= 0)
  {
    if(!(cond->max >= rnum))
      rnum = cond->max;

  }

  void *return_value_malloc$36;
  return_value_malloc$36=malloc((unsigned long int)rnum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
  rval = (signed int *)return_value_malloc$36;
  if(!(rval == ((signed int *)NULL)))
    rval;

  else
    cbmyfatal("out of memory");
  tscores = scores + (signed long int)cond->skip;
  i = 0;
  for( ; !(i >= rnum); i = i + 1)
    rval[(signed long int)i] = (tscores + (signed long int)i)->id;
  if(!(cond->scfb == 0))
  {
    if(rnum >= 1)
    {
      void *return_value_realloc$37;
      return_value_realloc$37=realloc((void *)cond->scores, (unsigned long int)rnum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
      cond->scores = (signed int *)return_value_realloc$37;
      if(!(cond->scores == ((signed int *)NULL)))
        cond->scores;

      else
        cbmyfatal("out of memory");
      i = 0;
      for( ; !(i >= rnum); i = i + 1)
        cond->scores[(signed long int)i] = (tscores + (signed long int)i)->score;
      cond->snum = rnum;
    }

    else
    {
      free((void *)cond->scores);
      cond->scores = (signed int *)(void *)0;
      cond->snum = 0;
    }
  }

  *nump = rnum;
  if(!(*nump >= 1))
    est_set_ecode(&db->ecode, 6, 3064);

  cbmapclose(ordattrs);
  free((void *)scores);
  return rval;
}

// est_db_search_meta
// file estraier.c line 3072
signed int * est_db_search_meta(struct anonymous **dbs, signed int dbnum, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints)
{
  struct anonymous$32 *scores;
  struct anonymous$32 *tscores;
  struct anonymous$8 *tcond;
  struct anonymous$9 *thints;
  struct anonymous$9 *umap;
  const char *kbuf;
  const char *otype;
  const char *rp;
  char *distinct;
  char numbuf[32l];
  char *oname;
  char *wp;
  char *vbuf;
  signed int i;
  signed int j;
  signed int max;
  signed int skip;
  signed int smax;
  signed int snum;
  signed int *res;
  signed int rnum;
  signed int ksiz;
  signed int num;
  signed long int tval;
  max = cond->max;
  if(!(cond->distinct == ((char *)NULL)))
    cond->max = -1;

  skip = cond->skip;
  cond->skip = 0;
  distinct = cond->distinct;
  cond->distinct = (char *)(void *)0;
  smax = 1024;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)smax * sizeof(struct anonymous$32) /*24ul*/ );
  scores = (struct anonymous$32 *)return_value_malloc$1;
  if(!(scores == ((struct anonymous$32 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  i = 0;
  signed int return_value_atoi$4;
  for( ; !(i >= dbnum); i = i + 1)
    if((cond->mask & 1 << i) == 0)
    {
      tcond=est_cond_dup(cond);
      est_cond_set_options(tcond, 1073741824);
      thints=cbmapopenex(31);
      res=est_db_search(dbs[(signed long int)i], tcond, &rnum, thints);
      j = 0;
      for( ; !(j >= rnum); j = j + 1)
      {
        if(snum >= smax)
        {
          smax = smax * 2;
          void *return_value_realloc$2;
          return_value_realloc$2=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous$32) /*24ul*/ );
          scores = (struct anonymous$32 *)return_value_realloc$2;
          if(!(scores == ((struct anonymous$32 *)NULL)))
            scores;

          else
            cbmyfatal("out of memory");
        }

        (scores + (signed long int)snum)->db = i;
        (scores + (signed long int)snum)->id = res[(signed long int)j];
        (scores + (signed long int)snum)->score=est_cond_score(tcond, j);
        (scores + (signed long int)snum)->value = (char *)(void *)0;
        snum = snum + 1;
      }
      if(!(hints == ((struct anonymous$9 *)NULL)))
      {
        cbmapiterinit(thints);
        do
        {
          kbuf=cbmapiternext(thints, &ksiz);
          if(kbuf == ((const char *)NULL))
            break;

          const char *return_value_cbmapiterval$3;
          return_value_cbmapiterval$3=cbmapiterval(kbuf, (signed int *)(void *)0);
          num=atoi(return_value_cbmapiterval$3);
          rp=cbmapget(hints, kbuf, ksiz, (signed int *)(void *)0);
          if(!(rp == ((const char *)NULL)))
          {
            return_value_atoi$4=atoi(rp);
            num = num + return_value_atoi$4;
          }

          sprintf(numbuf, "%d", num);
          cbmapput(hints, kbuf, ksiz, numbuf, -1, 1);
        }
        while((_Bool)1);
      }

      free((void *)res);
      cbmapclose(thints);
      est_cond_delete(tcond);
    }

  oname = (char *)(void *)0;
  otype = (const char *)(void *)0;
  if(!(cond->order == ((char *)NULL)))
  {
    oname=cbmemdup(cond->order, -1);
    cbstrtrim(oname);
    otype = "STRA";
    wp=strchr(oname, 32);
    if(!(wp == ((char *)NULL)))
    {
      *wp = (char)0;
      rp = wp + (signed long int)1;
      for( ; (signed int)*rp == 32; rp = rp + 1l)
        ;
      otype = rp;
    }

  }

  signed int return_value_cbstricmp$11;
  signed int return_value_cbstricmp$10;
  signed int return_value_cbstricmp$9;
  signed int return_value_cbstricmp$7;
  signed int return_value_cbstricmp$6;
  signed int return_value_cbstricmp$5;
  if(!(oname == ((char *)NULL)))
  {
    signed int return_value_cbstricmp$12;
    return_value_cbstricmp$12=cbstricmp(oname, "[IDA]");
    if(return_value_cbstricmp$12 == 0)
      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_id_asc);

    else
    {
      return_value_cbstricmp$11=cbstricmp(oname, "[IDD]");
      if(return_value_cbstricmp$11 == 0)
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_id_desc);

      else
      {
        return_value_cbstricmp$10=cbstricmp(oname, "[SCA]");
        if(return_value_cbstricmp$10 == 0)
          qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_score_asc);

        else
        {
          return_value_cbstricmp$9=cbstricmp(oname, "[SCD]");
          if(return_value_cbstricmp$9 == 0)
            qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_score_desc);

          else
          {
            i = 0;
            for( ; !(i >= snum); i = i + 1)
            {
              (scores + (signed long int)i)->value=est_db_get_doc_attr(dbs[(signed long int)(scores + (signed long int)i)->db], (scores + (signed long int)i)->id, oname);
              if((scores + (signed long int)i)->value == ((char *)NULL))
                (scores + (signed long int)i)->value=cbmemdup("", 0);

            }
            signed int return_value_cbstricmp$8;
            return_value_cbstricmp$8=cbstricmp(otype, "STRA");
            if(return_value_cbstricmp$8 == 0)
              qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_str_asc);

            else
            {
              return_value_cbstricmp$7=cbstricmp(otype, "STRD");
              if(return_value_cbstricmp$7 == 0)
                qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_str_desc);

              else
              {
                return_value_cbstricmp$6=cbstricmp(otype, "NUMA");
                if(return_value_cbstricmp$6 == 0)
                {
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                  {
                    tval=cbstrmktime((scores + (signed long int)i)->value);
                    free((void *)(scores + (signed long int)i)->value);
                    (scores + (signed long int)i)->value = (char *)(void *)tval;
                  }
                  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_num_asc);
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                    (scores + (signed long int)i)->value = (char *)(void *)0;
                }

                else
                {
                  return_value_cbstricmp$5=cbstricmp(otype, "NUMD");
                  if(return_value_cbstricmp$5 == 0)
                  {
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                    {
                      tval=cbstrmktime((scores + (signed long int)i)->value);
                      free((void *)(scores + (signed long int)i)->value);
                      (scores + (signed long int)i)->value = (char *)(void *)tval;
                    }
                    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_num_desc);
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                      (scores + (signed long int)i)->value = (char *)(void *)0;
                  }

                }
              }
            }
            i = 0;
            for( ; !(i >= snum); i = i + 1)
              free((void *)(scores + (signed long int)i)->value);
          }
        }
      }
    }
    free((void *)oname);
  }

  else
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$32) /*24ul*/ , est_metascore_compare_by_score_desc);
  signed int tmp_post$13;
  if(!(distinct == ((char *)NULL)))
  {
    umap=cbmapopenex(snum + 1);
    rnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      vbuf=est_db_get_doc_attr(dbs[(signed long int)(scores + (signed long int)i)->db], (scores + (signed long int)i)->id, distinct);
      if(vbuf == ((char *)NULL))
        vbuf=cbmemdup("", 0);

      signed int return_value_cbmapput$14;
      return_value_cbmapput$14=cbmapput(umap, vbuf, -1, "", 0, 0);
      if(!(return_value_cbmapput$14 == 0))
      {
        tmp_post$13 = rnum;
        rnum = rnum + 1;
        scores[(signed long int)tmp_post$13] = scores[(signed long int)i];
      }

      free((void *)vbuf);
    }
    snum = rnum;
    cbmapclose(umap);
  }

  rnum = snum - skip;
  if(!(rnum >= 0))
    rnum = 0;

  if(cond->max >= 0)
  {
    if(!(cond->max >= rnum))
      rnum = cond->max;

  }

  void *return_value_malloc$15;
  return_value_malloc$15=malloc((unsigned long int)rnum * sizeof(signed int) /*4ul*/  * (unsigned long int)2 + (unsigned long int)1);
  res = (signed int *)return_value_malloc$15;
  if(!(res == ((signed int *)NULL)))
    res;

  else
    cbmyfatal("out of memory");
  tscores = scores + (signed long int)skip;
  i = 0;
  for( ; !(i >= rnum); i = i + 1)
  {
    res[(signed long int)(i * 2)] = (tscores + (signed long int)i)->db;
    res[(signed long int)(i * 2 + 1)] = (tscores + (signed long int)i)->id;
  }
  if(!(cond->scfb == 0))
  {
    if(rnum >= 1)
    {
      void *return_value_realloc$16;
      return_value_realloc$16=realloc((void *)cond->scores, (unsigned long int)rnum * sizeof(signed int) /*4ul*/  + (unsigned long int)1);
      cond->scores = (signed int *)return_value_realloc$16;
      if(!(cond->scores == ((signed int *)NULL)))
        cond->scores;

      else
        cbmyfatal("out of memory");
      i = 0;
      for( ; !(i >= rnum); i = i + 1)
        cond->scores[(signed long int)i] = (tscores + (signed long int)i)->score;
      cond->snum = rnum;
    }

    else
    {
      free((void *)cond->scores);
      cond->scores = (signed int *)(void *)0;
      cond->snum = 0;
    }
  }

  *nump = rnum * 2;
  free((void *)scores);
  cond->max = max;
  cond->skip = skip;
  cond->distinct = distinct;
  return res;
}

// est_db_set_cache_size
// file estraier.c line 3324
void est_db_set_cache_size(struct anonymous *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum)
{
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  if(!(return_value_dpwritable$1 == 0))
    db->icmax = size;

  if(anum >= 0)
    db->acmnum = anum;

  if(tnum >= 0)
    db->tcmnum = tnum;

  if(rnum >= 0)
    db->rcmnum = rnum;

  db->vcmnum = db->acmnum / 2;
}

// est_db_set_dfdb
// file estraier.c line 5015
void est_db_set_dfdb(struct anonymous *db, struct anonymous$5 *dfdb)
{
  db->dfdb = dfdb;
}

// est_db_set_doc_entity
// file estraier.c line 4482
signed int est_db_set_doc_entity(struct anonymous *db, signed int id, const char *ptr, signed int size)
{
  signed int err;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 4486);
    return 0;
  }

  else
  {
    err = 0;
    if(!(ptr == ((const char *)NULL)))
    {
      signed int return_value_crputlob$2;
      return_value_crputlob$2=crputlob(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , ptr, size, 0);
      if(return_value_crputlob$2 == 0)
      {
        est_set_ecode(&db->ecode, 4, 4492);
        err = 1;
      }

    }

    else
    {
      signed int return_value_croutlob$4;
      return_value_croutlob$4=croutlob(db->textdb, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ );
      if(return_value_croutlob$4 == 0)
      {
        signed int *return_value_dpecodeptr$3;
        return_value_dpecodeptr$3=dpecodeptr();
        est_set_ecode(&db->ecode, *return_value_dpecodeptr$3 == 5 ? 6 : 4, 4497);
        err = 1;
      }

    }
    return err != 0 ? 0 : 1;
  }
}

// est_db_set_ecode
// file estraier.c line 4425
void est_db_set_ecode(struct anonymous *db, signed int ecode)
{
  est_set_ecode(&db->ecode, ecode, 4427);
}

// est_db_set_informer
// file estraier.c line 4985
void est_db_set_informer(struct anonymous *db, void (*func)(const char *, void *), void *opaque)
{
  db->infocb = func;
  db->infoop = opaque;
  est_db_inform(db, "status");
}

// est_db_set_special_cache
// file estraier.c line 4972
void est_db_set_special_cache(struct anonymous *db, const char *name, signed int num)
{
  if(!(db->spacc == ((struct anonymous$9 *)NULL)))
  {
    free((void *)db->scname);
    cbmapclose(db->spacc);
  }

  db->spacc=cbmapopenex(num + 1);
  db->scmnum = num;
  db->scname=cbmemdup(name, -1);
}

// est_db_set_wildmax
// file estraier.c line 4506
void est_db_set_wildmax(struct anonymous *db, signed int num)
{
  db->wildmax = num;
}

// est_db_size
// file estraier.c line 2718
double est_db_size(struct anonymous *db)
{
  struct anonymous$16 *attridx;
  const char *kbuf;
  double size;
  signed int return_value_dpfsiz$1;
  return_value_dpfsiz$1=dpfsiz(db->metadb);
  double return_value_est_idx_size$2;
  return_value_est_idx_size$2=est_idx_size(db->idxdb);
  signed int return_value_vlfsiz$3;
  return_value_vlfsiz$3=vlfsiz(db->fwmdb);
  signed int return_value_vlfsiz$4;
  return_value_vlfsiz$4=vlfsiz(db->auxdb);
  signed int return_value_vlfsiz$5;
  return_value_vlfsiz$5=vlfsiz(db->xfmdb);
  double return_value_crfsizd$6;
  return_value_crfsizd$6=crfsizd(db->attrdb);
  double return_value_crfsizd$7;
  return_value_crfsizd$7=crfsizd(db->textdb);
  double return_value_crfsizd$8;
  return_value_crfsizd$8=crfsizd(db->kwddb);
  signed int return_value_vlfsiz$9;
  return_value_vlfsiz$9=vlfsiz(db->listdb);
  size = (double)return_value_dpfsiz$1 + return_value_est_idx_size$2 + (double)return_value_vlfsiz$3 + (double)return_value_vlfsiz$4 + (double)return_value_vlfsiz$5 + return_value_crfsizd$6 + return_value_crfsizd$7 + return_value_crfsizd$8 + (double)return_value_vlfsiz$9;
  signed int return_value_cbmaprnum$13;
  return_value_cbmaprnum$13=cbmaprnum(db->aidxs);
  signed int return_value_vlfsiz$11;
  if(return_value_cbmaprnum$13 >= 1)
  {
    cbmapiterinit(db->aidxs);
    do
    {
      kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$10;
      return_value_cbmapiterval$10=cbmapiterval(kbuf, (signed int *)(void *)0);
      attridx = (struct anonymous$16 *)return_value_cbmapiterval$10;
      if(attridx->type == 1 || attridx->type == 2)
      {
        return_value_vlfsiz$11=vlfsiz((struct anonymous$7 *)attridx->db);
        size = size + (double)return_value_vlfsiz$11;
        goto __CPROVER_DUMP_L4;
      }

      signed int return_value_dpfsiz$12;
      return_value_dpfsiz$12=dpfsiz((struct anonymous$5 *)attridx->db);
      size = size + (double)return_value_dpfsiz$12;

    __CPROVER_DUMP_L4:
      ;
    }
    while((_Bool)1);
  }

  return size;
}

// est_db_sync
// file estraier.c line 1692
signed int est_db_sync(struct anonymous *db)
{
  struct anonymous$16 *attridx;
  const char *kbuf;
  signed int err;
  signed int return_value_dpwritable$1;
  return_value_dpwritable$1=dpwritable(db->metadb);
  _Bool tmp_if_expr$4;
  signed int return_value_est_db_write_meta$3;
  signed int return_value_vlsync$13;
  if(return_value_dpwritable$1 == 0)
  {
    est_set_ecode(&db->ecode, 2, 1698);
    return 0;
  }

  else
  {
    err = 0;
    signed int return_value_est_db_flush$2;
    return_value_est_db_flush$2=est_db_flush(db, -1);
    if(return_value_est_db_flush$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_est_db_write_meta$3=est_db_write_meta(db);
      tmp_if_expr$4 = !(return_value_est_db_write_meta$3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      err = 1;

    est_db_inform(db, "synchronizing the database for meta information");
    signed int return_value_dpsync$5;
    return_value_dpsync$5=dpsync(db->metadb);
    if(return_value_dpsync$5 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the inverted index");
    signed int return_value_est_idx_sync$6;
    return_value_est_idx_sync$6=est_idx_sync(db->idxdb);
    if(return_value_est_idx_sync$6 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for forward matching");
    signed int return_value_vlsync$7;
    return_value_vlsync$7=vlsync(db->fwmdb);
    if(return_value_vlsync$7 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for attributes");
    signed int return_value_crsync$8;
    return_value_crsync$8=crsync(db->attrdb);
    if(return_value_crsync$8 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for texts");
    signed int return_value_crsync$9;
    return_value_crsync$9=crsync(db->textdb);
    if(return_value_crsync$9 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for keywords");
    signed int return_value_crsync$10;
    return_value_crsync$10=crsync(db->kwddb);
    if(return_value_crsync$10 == 0)
      err = 1;

    est_db_inform(db, "synchronizing the database for document list");
    signed int return_value_vlsync$11;
    return_value_vlsync$11=vlsync(db->listdb);
    if(return_value_vlsync$11 == 0)
      err = 1;

    signed int return_value_cbmaprnum$15;
    return_value_cbmaprnum$15=cbmaprnum(db->aidxs);
    if(return_value_cbmaprnum$15 >= 1)
    {
      est_db_inform(db, "synchronizing the databases for attribute narrowing");
      cbmapiterinit(db->aidxs);
      do
      {
        kbuf=cbmapiternext(db->aidxs, (signed int *)(void *)0);
        if(kbuf == ((const char *)NULL))
          break;

        const char *return_value_cbmapiterval$12;
        return_value_cbmapiterval$12=cbmapiterval(kbuf, (signed int *)(void *)0);
        attridx = (struct anonymous$16 *)return_value_cbmapiterval$12;
        if(attridx->type == 1 || attridx->type == 2)
        {
          return_value_vlsync$13=vlsync((struct anonymous$7 *)attridx->db);
          if(return_value_vlsync$13 == 0)
            err = 1;

          goto __CPROVER_DUMP_L17;
        }

        signed int return_value_dpsync$14;
        return_value_dpsync$14=dpsync((struct anonymous$5 *)attridx->db);
        if(return_value_dpsync$14 == 0)
          err = 1;


      __CPROVER_DUMP_L17:
        ;
      }
      while((_Bool)1);
    }

    if(!(err == 0))
    {
      est_set_ecode(&db->ecode, 4, 1734);
      db->fatal = 1;
    }

    return err != 0 ? 0 : 1;
  }
}

// est_db_uri_to_id
// file estraier.c line 2681
signed int est_db_uri_to_id(struct anonymous *db, const char *uri)
{
  const char *vbuf;
  signed int id;
  vbuf=vlgetcache(db->listdb, uri, -1, (signed int *)(void *)0);
  if(vbuf == ((const char *)NULL))
  {
    if(db->pdocs->num >= 1)
    {
      id=est_pidx_uri_to_id(db, uri);
      if(id >= 1)
        return id;

    }

    est_set_ecode(&db->ecode, 6, 2687);
    return -1;
  }

  else
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(vbuf);
    return return_value_atoi$1;
  }
}

// est_db_used_cache_size
// file estraier.c line 4964
signed int est_db_used_cache_size(struct anonymous *db)
{
  signed int return_value_cbmaprnum$1;
  return_value_cbmaprnum$1=cbmaprnum(db->idxcc);
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(db->auxcc);
  return (signed int)((double)(db->icsiz + (unsigned long int)(return_value_cbmaprnum$1 + return_value_cbmaprnum$2) * (sizeof(struct _CBMAPDATUM) /*48ul*/  + (unsigned long int)8)) * 1.1);
}

// est_db_word_iter_init
// file estraier.c line 4853
signed int est_db_word_iter_init(struct anonymous *db)
{
  signed int return_value_vlcurfirst$2;
  return_value_vlcurfirst$2=vlcurfirst(db->fwmdb);
  signed int *return_value_dpecodeptr$1;
  if(return_value_vlcurfirst$2 == 0)
  {
    return_value_dpecodeptr$1=dpecodeptr();
    if(*return_value_dpecodeptr$1 == 5)
      goto __CPROVER_DUMP_L1;

    est_set_ecode(&db->ecode, 4, 4856);
    db->fatal = 1;
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// est_db_word_iter_next
// file estraier.c line 4865
char * est_db_word_iter_next(struct anonymous *db)
{
  char *word;
  word=vlcurkey(db->fwmdb, (signed int *)(void *)0);
  if(word == ((char *)NULL))
  {
    signed int *return_value_dpecodeptr$1;
    return_value_dpecodeptr$1=dpecodeptr();
    if(*return_value_dpecodeptr$1 == 5)
      est_set_ecode(&db->ecode, 6, 4870);

    else
    {
      est_set_ecode(&db->ecode, 4, 4872);
      db->fatal = 1;
    }
    return (char *)(void *)0;
  }

  vlcurnext(db->fwmdb);
  return word;
}

// est_db_word_num
// file estraier.c line 2709
signed int est_db_word_num(struct anonymous *db)
{
  signed int wnum;
  wnum=vlrnum(db->fwmdb);
  return wnum > 0 ? wnum : 0;
}

// est_db_word_rec_size
// file estraier.c line 4883
signed int est_db_word_rec_size(struct anonymous *db, const char *word)
{
  signed int num;
  const char *return_value_cbmapget$1;
  return_value_cbmapget$1=cbmapget(db->idxcc, word, -1, &num);
  if(return_value_cbmapget$1 == ((const char *)NULL))
    num = 0;

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(word);
  signed int return_value_est_idx_vsiz$3;
  return_value_est_idx_vsiz$3=est_idx_vsiz(db->idxdb, word, (signed int)return_value_strlen$2);
  return return_value_est_idx_vsiz$3 + num;
}

// est_db_write_meta
// file estraier.c line 7774
static signed int est_db_write_meta(struct anonymous *db)
{
  char vbuf[32l];
  char *sbuf;
  signed int err;
  signed int ssiz;
  err = 0;
  signed int return_value_est_idx_num$1;
  return_value_est_idx_num$1=est_idx_num(db->idxdb);
  sprintf(vbuf, "%d", return_value_est_idx_num$1);
  signed int return_value_dpput$2;
  return_value_dpput$2=dpput(db->metadb, "_idxnum", -1, vbuf, -1, 0);
  if(return_value_dpput$2 == 0)
    err = 1;

  sprintf(vbuf, "%d", db->dseq);
  signed int return_value_dpput$3;
  return_value_dpput$3=dpput(db->metadb, "_dseq", -1, vbuf, -1, 0);
  if(return_value_dpput$3 == 0)
    err = 1;

  sprintf(vbuf, "%d", db->dnum);
  signed int return_value_dpput$4;
  return_value_dpput$4=dpput(db->metadb, "_dnum", -1, vbuf, -1, 0);
  if(return_value_dpput$4 == 0)
    err = 1;

  if(!(db->metacc == ((struct anonymous$9 *)NULL)))
  {
    sbuf=cbmapdump(db->metacc, &ssiz);
    signed int return_value_dpput$5;
    return_value_dpput$5=dpput(db->metadb, "_meta", -1, sbuf, ssiz, 0);
    if(return_value_dpput$5 == 0)
      err = 1;

    free((void *)sbuf);
  }

  if(!(err == 0))
  {
    est_set_ecode(&db->ecode, 4, 7791);
    db->fatal = 1;
  }

  return err != 0 ? 0 : 1;
}

// est_decode_idx_rec
// file estraier.c line 6951
static void est_decode_idx_rec(struct anonymous$2 *datum, const char *vbuf, signed int vsiz, signed int smode)
{
  const char *rp;
  const char *ep;
  const char *sp;
  char nbuf[32l];
  signed int cid;
  signed int vnum;
  signed int vstep;
  rp = vbuf;
  ep = vbuf + (signed long int)vsiz;
  cid = 0;
  while(!(rp >= ep))
  {
    do
    {
      signed int _EST_i;
      signed int _EST_base;
      vnum = 0;
      _EST_base = 1;
      _EST_i = 0;
      for( ; (_Bool)1; _EST_i = _EST_i + 1)
      {
        if((signed int)rp[(signed long int)_EST_i] >= 0)
        {
          vnum = vnum + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
          break;
        }

        vnum = vnum + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
        _EST_base = _EST_base * 128;
      }
      vstep = _EST_i + 1;
    }
    while((_Bool)0);
    cid = cid + vnum + 1;
    rp = rp + (signed long int)vstep;
    sp = rp;
    if(!(smode == 1048576))
    {
      if(smode == 2097152 || smode == 4194304)
        goto __CPROVER_DUMP_L8;

    }

    else
      goto __CPROVER_DUMP_L9;
    rp = rp + 1l;
    goto __CPROVER_DUMP_L9;

  __CPROVER_DUMP_L8:
    ;
    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

  __CPROVER_DUMP_L9:
    ;
    for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
      ;
    rp = rp + 1l;
    do
    {
      signed int _EST_num = cid;
      struct anonymous$15 EST_d;
      if(_EST_num == 0)
      {
        ((signed char *)nbuf)[(signed long int)0] = (signed char)0;
        vstep = 1;
      }

      else
      {
        vstep = 0;
        for( ; _EST_num >= 1; vstep = vstep + 1)
        {
          EST_d=div(_EST_num, 128);
          _EST_num = EST_d.quot;
          if(_EST_num >= 1)
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

          else
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
        }
      }
    }
    while((_Bool)0);
    do
    {
      if(datum->dsize + vstep >= datum->asize)
      {
        datum->asize = datum->asize * 2 + vstep + 1;
        void *return_value_realloc$1;
        return_value_realloc$1=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc$1;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)nbuf, (unsigned long int)vstep);
      datum->dsize = datum->dsize + vstep;
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
    do
    {
      if((rp - sp) + (signed long int)datum->dsize >= (signed long int)datum->asize)
      {
        datum->asize = (signed int)((signed long int)(datum->asize * 2) + (rp - sp) + (signed long int)1);
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc$2;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, (unsigned long int)(rp - sp));
      datum->dsize = datum->dsize + (signed int)(rp - sp);
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
  }
}

// est_deflate
// file estraier.c line 3750
char * est_deflate(const char *ptr, signed int size, signed int *sp, signed int mode)
{
  struct z_stream_s zs;
  char *buf;
  unsigned char obuf[8192l];
  signed int rv;
  signed int asiz;
  signed int bsiz;
  signed int osiz;
  unsigned long int return_value_strlen$1;
  if(!(size >= 0))
  {
    return_value_strlen$1=strlen(ptr);
    size = (signed int)return_value_strlen$1;
  }

  zs.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
  zs.zfree = ((void (*)(void *, void *))NULL);
  zs.opaque = NULL;
  signed int return_value_deflateInit2_$2;
  signed int return_value_deflateInit2_$3;
  if(!(mode == -1))
  {
    if(mode == 1)
      goto __CPROVER_DUMP_L4;

  }

  else
  {
    return_value_deflateInit2_$2=deflateInit2_(&zs, 5, 8, -15, 7, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_deflateInit2_$2 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L8;

  __CPROVER_DUMP_L4:
    ;
    return_value_deflateInit2_$3=deflateInit2_(&zs, 6, 8, 15 + 16, 9, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_deflateInit2_$3 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L8;
  }
  signed int return_value_deflateInit2_$4;
  return_value_deflateInit2_$4=deflateInit2_(&zs, 6, 8, 15, 8, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  if(!(return_value_deflateInit2_$4 == 0))
    return (char *)(void *)0;

  else
  {
    goto __CPROVER_DUMP_L8;

  __CPROVER_DUMP_L8:
    ;
    asiz = size + 16;
    if(!(asiz >= 8192))
      asiz = 8192;

    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)asiz);
    buf = (char *)return_value_malloc$5;
    if(!(buf == ((char *)NULL)))
      buf;

    else
      cbmyfatal("out of memory");
    bsiz = 0;
    zs.next_in = (unsigned char *)ptr;
    zs.avail_in = (unsigned int)size;
    zs.next_out = obuf;
    zs.avail_out = (unsigned int)8192;
    do
    {
      rv=deflate(&zs, 4);
      if(!(rv == 0))
        break;

      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(!(asiz >= bsiz + osiz))
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc$6;
        return_value_realloc$6=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc$6;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      zs.next_out = obuf;
      zs.avail_out = (unsigned int)8192;
    }
    while((_Bool)1);
    if(!(rv == 1))
    {
      free((void *)buf);
      deflateEnd(&zs);
      return (char *)(void *)0;
    }

    else
    {
      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(!(asiz >= 1 + bsiz + osiz))
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc$7;
        return_value_realloc$7=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc$7;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      buf[(signed long int)bsiz] = (char)0;
      if(mode == -1)
        bsiz = bsiz + 1;

      *sp = bsiz;
      deflateEnd(&zs);
      return buf;
    }
  }
}

// est_doc_add_attr
// file estraier.h line 100
void est_doc_add_attr(struct anonymous$0 *doc, const char *name, const char *value)
{
  char *rbuf;
  char *wp;
  signed int len;
  _Bool tmp_if_expr$1;
  if((signed int)*name == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)name[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    if(doc->attrs == ((struct anonymous$9 *)NULL))
      doc->attrs=cbmapopenex(31);

    if(!(value == ((const char *)NULL)))
    {
      rbuf=cbmemdup(value, -1);
      wp = rbuf;
      for( ; !((signed int)*wp == 0); wp = wp + 1l)
        if((signed int)*wp >= 1)
        {
          if(!((signed int)*wp >= 32))
            *wp = (char)32;

        }

      cbstrsqzspc(rbuf);
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(name);
      len = (signed int)return_value_strlen$2;
      if(len >= 1)
        cbmapput(doc->attrs, name, len, rbuf, -1, 1);

      free((void *)rbuf);
    }

    else
      cbmapout(doc->attrs, name, -1);
  }

}

// est_doc_add_hidden_text
// file estraier.h line 112
void est_doc_add_hidden_text(struct anonymous$0 *doc, const char *text)
{
  unsigned char *utext;
  char *rtext;
  char *wp;
  signed int size;
  for( ; (signed int)*text >= 1; text = text + 1l)
    if((signed int)*text >= 33)
      break;

  if(!((signed int)*text == 0))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(text);
    char *return_value_est_uconv_in$2;
    return_value_est_uconv_in$2=est_uconv_in(text, (signed int)return_value_strlen$1, &size);
    utext = (unsigned char *)return_value_est_uconv_in$2;
    est_normalize_text(utext, size, &size);
    rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
    wp = rtext;
    for( ; !((signed int)*wp == 0); wp = wp + 1l)
      if((signed int)*wp >= 1)
      {
        if(!((signed int)*wp >= 32))
          *wp = (char)32;

      }

    cbstrsqzspc(rtext);
    if(!((signed int)*rtext == 0))
    {
      if(doc->attrs == ((struct anonymous$9 *)NULL))
        doc->attrs=cbmapopenex(31);

      const char *return_value_cbmapget$3;
      return_value_cbmapget$3=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
      if(!(return_value_cbmapget$3 == ((const char *)NULL)))
        cbmapputcat(doc->attrs, "", 0, " ", 1);

      cbmapputcat(doc->attrs, "", 0, rtext, -1);
    }

    free((void *)rtext);
    free((void *)utext);
  }

}

// est_doc_add_text
// file estraier.h line 106
void est_doc_add_text(struct anonymous$0 *doc, const char *text)
{
  unsigned char *utext;
  char *rtext;
  char *wp;
  signed int size;
  for( ; (signed int)*text >= 1; text = text + 1l)
    if((signed int)*text >= 33)
      break;

  if(!((signed int)*text == 0))
  {
    if(doc->dtexts == ((struct anonymous$1 *)NULL))
      do
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
        doc->dtexts = (struct anonymous$1 *)return_value_malloc$1;
        if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
          doc->dtexts;

        else
          cbmyfatal("out of memory");
        doc->dtexts->anum = 64;
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
        doc->dtexts->array = (struct anonymous$28 *)return_value_malloc$2;
        if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
          doc->dtexts->array;

        else
          cbmyfatal("out of memory");
        doc->dtexts->start = 0;
        doc->dtexts->num = 0;
      }
      while((_Bool)0);

    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(text);
    char *return_value_est_uconv_in$4;
    return_value_est_uconv_in$4=est_uconv_in(text, (signed int)return_value_strlen$3, &size);
    utext = (unsigned char *)return_value_est_uconv_in$4;
    est_normalize_text(utext, size, &size);
    rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
    wp = rtext;
    for( ; !((signed int)*wp == 0); wp = wp + 1l)
      if((signed int)*wp >= 1)
      {
        if(!((signed int)*wp >= 32))
          *wp = (char)32;

      }

    cbstrsqzspc(rtext);
    if(!((signed int)*rtext == 0))
      do
      {
        signed int _CB_index = doc->dtexts->start + doc->dtexts->num;
        if(_CB_index >= doc->dtexts->anum)
        {
          doc->dtexts->anum = doc->dtexts->anum * 2;
          void *return_value_realloc$5;
          return_value_realloc$5=realloc((void *)doc->dtexts->array, (unsigned long int)doc->dtexts->anum * sizeof(struct anonymous$28) /*16ul*/ );
          doc->dtexts->array = (struct anonymous$28 *)return_value_realloc$5;
          if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
            doc->dtexts->array;

          else
            cbmyfatal("out of memory");
        }

        (doc->dtexts->array + (signed long int)_CB_index)->dptr = rtext;
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(rtext);
        (doc->dtexts->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen$6;
        doc->dtexts->num = doc->dtexts->num + 1;
      }
      while((_Bool)0);

    else
      free((void *)rtext);
    free((void *)utext);
  }

}

// est_doc_attr
// file estraier.c line 616
const char * est_doc_attr(struct anonymous$0 *doc, const char *name)
{
  _Bool tmp_if_expr$1;
  if(doc->attrs == ((struct anonymous$9 *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)name[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (const char *)(void *)0;

  else
  {
    const char *return_value_cbmapget$2;
    return_value_cbmapget$2=cbmapget(doc->attrs, name, -1, (signed int *)(void *)0);
    return return_value_cbmapget$2;
  }
}

// est_doc_attr_names
// file estraier.c line 596
struct anonymous$1 * est_doc_attr_names(struct anonymous$0 *doc)
{
  struct anonymous$1 *names;
  const char *kbuf;
  signed int ksiz;
  if(doc->attrs == ((struct anonymous$9 *)NULL))
  {
    do
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
      names = (struct anonymous$1 *)return_value_malloc$1;
      if(!(names == ((struct anonymous$1 *)NULL)))
        names;

      else
        cbmyfatal("out of memory");
      names->anum = 64;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)names->anum);
      names->array = (struct anonymous$28 *)return_value_malloc$2;
      if(!(names->array == ((struct anonymous$28 *)NULL)))
        names->array;

      else
        cbmyfatal("out of memory");
      names->start = 0;
      names->num = 0;
    }
    while((_Bool)0);
    return names;
  }

  else
  {
    do
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct anonymous$1) /*24ul*/ );
      names = (struct anonymous$1 *)return_value_malloc$3;
      if(!(names == ((struct anonymous$1 *)NULL)))
        names;

      else
        cbmyfatal("out of memory");
      names->anum = 64;
      void *return_value_malloc$4;
      return_value_malloc$4=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)names->anum);
      names->array = (struct anonymous$28 *)return_value_malloc$4;
      if(!(names->array == ((struct anonymous$28 *)NULL)))
        names->array;

      else
        cbmyfatal("out of memory");
      names->start = 0;
      names->num = 0;
    }
    while((_Bool)0);
    cbmapiterinit(doc->attrs);
    do
    {
      kbuf=cbmapiternext(doc->attrs, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      if(ksiz >= 1)
      {
        if(!((signed int)*kbuf == 9))
          do
          {
            signed int _CB_index = names->start + names->num;
            if(_CB_index >= names->anum)
            {
              names->anum = names->anum * 2;
              void *return_value_realloc$5;
              return_value_realloc$5=realloc((void *)names->array, (unsigned long int)names->anum * sizeof(struct anonymous$28) /*16ul*/ );
              names->array = (struct anonymous$28 *)return_value_realloc$5;
              if(!(names->array == ((struct anonymous$28 *)NULL)))
                names->array;

              else
                cbmyfatal("out of memory");
            }

            void *return_value_malloc$6;
            return_value_malloc$6=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
            (names->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$6;
            if(!((names->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
              (names->array + (signed long int)_CB_index)->dptr;

            else
              cbmyfatal("out of memory");
            memcpy((void *)(names->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
            (names->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
            (names->array + (signed long int)_CB_index)->dsize = ksiz;
            names->num = names->num + 1;
          }
          while((_Bool)0);

      }

    }
    while((_Bool)1);
    cblistsort(names);
    return names;
  }
}

// est_doc_cat_texts
// file estraier.c line 632
char * est_doc_cat_texts(struct anonymous$0 *doc)
{
  struct anonymous$2 *datum;
  const char *elem;
  signed int i;
  signed int size;
  char *return_value_cbmemdup$1;
  if(doc->dtexts == ((struct anonymous$1 *)NULL))
  {
    return_value_cbmemdup$1=cbmemdup("", 0);
    return return_value_cbmemdup$1;
  }

  else
  {
    do
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct anonymous$2) /*16ul*/ );
      datum = (struct anonymous$2 *)return_value_malloc$2;
      if(!(datum == ((struct anonymous$2 *)NULL)))
        datum;

      else
        cbmyfatal("out of memory");
      void *return_value_malloc$3;
      return_value_malloc$3=malloc((unsigned long int)12);
      datum->dptr = (char *)return_value_malloc$3;
      if(!(datum->dptr == ((char *)NULL)))
        datum->dptr;

      else
        cbmyfatal("out of memory");
      datum->dptr[(signed long int)0] = (char)0;
      datum->dsize = 0;
      datum->asize = 12;
    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      size = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
      elem = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      if(i >= 1)
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc$4;
            return_value_realloc$4=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$4;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" ", (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      do
      {
        if(datum->dsize + size >= datum->asize)
        {
          datum->asize = datum->asize * 2 + size + 1;
          void *return_value_realloc$5;
          return_value_realloc$5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$5;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)elem, (unsigned long int)size);
        datum->dsize = datum->dsize + size;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }
    char *return_value_cbdatumtomalloc$6;
    return_value_cbdatumtomalloc$6=cbdatumtomalloc(datum, (signed int *)(void *)0);
    return return_value_cbdatumtomalloc$6;
  }
}

// est_doc_delete
// file estraier.h line 93
void est_doc_delete(struct anonymous$0 *doc)
{
  if(!(doc->kwords == ((struct anonymous$9 *)NULL)))
    cbmapclose(doc->kwords);

  if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
    do
    {
      signed int _CB_i;
      signed int _CB_end = doc->dtexts->start + doc->dtexts->num;
      _CB_i = doc->dtexts->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(doc->dtexts->array + (signed long int)_CB_i)->dptr);
      free((void *)doc->dtexts->array);
      free((void *)doc->dtexts);
    }
    while((_Bool)0);

  if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
    cbmapclose(doc->attrs);

  free((void *)doc);
}

// est_doc_dump_draft
// file estraier.c line 664
char * est_doc_dump_draft(struct anonymous$0 *doc)
{
  struct anonymous$1 *list;
  struct anonymous$2 *datum;
  const char *kbuf;
  const char *vbuf;
  signed int i;
  signed int ksiz;
  signed int vsiz;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$1;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
  {
    list=est_doc_attr_names(doc);
    i = 0;
    for( ; !(i >= list->num); i = i + 1)
    {
      ksiz = (list->array + (signed long int)(list->start + i))->dsize;
      kbuf = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
      vbuf=cbmapget(doc->attrs, kbuf, ksiz, &vsiz);
      do
      {
        if(datum->dsize + ksiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + ksiz + 1;
          void *return_value_realloc$3;
          return_value_realloc$3=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$3;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)kbuf, (unsigned long int)ksiz);
        datum->dsize = datum->dsize + ksiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$4;
          return_value_realloc$4=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$4;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"=", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(datum->dsize + vsiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + vsiz + 1;
          void *return_value_realloc$5;
          return_value_realloc$5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$5;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
        datum->dsize = datum->dsize + vsiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$6;
          return_value_realloc$6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$6;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = list->start + list->num;
      _CB_i = list->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(list->array + (signed long int)_CB_i)->dptr);
      free((void *)list->array);
      free((void *)list);
    }
    while((_Bool)0);
  }

  signed int return_value_cbmaprnum$17;
  if(!(doc->kwords == ((struct anonymous$9 *)NULL)))
  {
    return_value_cbmaprnum$17=cbmaprnum(doc->kwords);
    if(return_value_cbmaprnum$17 >= 1)
    {
      do
      {
        unsigned long int return_value_strlen$9;
        return_value_strlen$9=strlen("%VECTOR");
        if(return_value_strlen$9 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
        {
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen("%VECTOR");
          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$7 + (unsigned long int)1);
          void *return_value_realloc$8;
          return_value_realloc$8=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$8;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        unsigned long int return_value_strlen$10;
        return_value_strlen$10=strlen("%VECTOR");
        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"%VECTOR", return_value_strlen$10);
        unsigned long int return_value_strlen$11;
        return_value_strlen$11=strlen("%VECTOR");
        datum->dsize = datum->dsize + (signed int)return_value_strlen$11;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      cbmapiterinit(doc->kwords);
      do
      {
        kbuf=cbmapiternext(doc->kwords, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        do
        {
          struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(kbuf - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
          vsiz = _CB_datum->vsiz;
          vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
        }
        while((_Bool)0);
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc$12;
            return_value_realloc$12=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$12;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        do
        {
          if(datum->dsize + ksiz >= datum->asize)
          {
            datum->asize = datum->asize * 2 + ksiz + 1;
            void *return_value_realloc$13;
            return_value_realloc$13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$13;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)kbuf, (unsigned long int)ksiz);
          datum->dsize = datum->dsize + ksiz;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc$14;
            return_value_realloc$14=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$14;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        do
        {
          if(datum->dsize + vsiz >= datum->asize)
          {
            datum->asize = datum->asize * 2 + vsiz + 1;
            void *return_value_realloc$15;
            return_value_realloc$15=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$15;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
          datum->dsize = datum->dsize + vsiz;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
      }
      while((_Bool)1);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$16;
          return_value_realloc$16=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$16;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }

  if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
  {
    vbuf=cbmapget(doc->attrs, "\t", 1, &vsiz);
    if(!(vbuf == ((const char *)NULL)))
    {
      do
      {
        unsigned long int return_value_strlen$20;
        return_value_strlen$20=strlen("%SCORE");
        if(return_value_strlen$20 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
        {
          unsigned long int return_value_strlen$18;
          return_value_strlen$18=strlen("%SCORE");
          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$18 + (unsigned long int)1);
          void *return_value_realloc$19;
          return_value_realloc$19=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$19;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        unsigned long int return_value_strlen$21;
        return_value_strlen$21=strlen("%SCORE");
        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"%SCORE", return_value_strlen$21);
        unsigned long int return_value_strlen$22;
        return_value_strlen$22=strlen("%SCORE");
        datum->dsize = datum->dsize + (signed int)return_value_strlen$22;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$23;
          return_value_realloc$23=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$23;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(datum->dsize + vsiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + vsiz + 1;
          void *return_value_realloc$24;
          return_value_realloc$24=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$24;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
        datum->dsize = datum->dsize + vsiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$25;
          return_value_realloc$25=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$25;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }

  do
  {
    if(1 + datum->dsize >= datum->asize)
    {
      datum->asize = datum->asize * 2 + 1 + 1;
      void *return_value_realloc$26;
      return_value_realloc$26=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
      datum->dptr = (char *)return_value_realloc$26;
      if(!(datum->dptr == ((char *)NULL)))
        datum->dptr;

      else
        cbmyfatal("out of memory");
    }

    memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
    datum->dsize = datum->dsize + 1;
    datum->dptr[(signed long int)datum->dsize] = (char)0;
  }
  while((_Bool)0);
  if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
  {
    i = 0;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      ksiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
      kbuf = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      do
      {
        if(datum->dsize + ksiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + ksiz + 1;
          void *return_value_realloc$27;
          return_value_realloc$27=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$27;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)kbuf, (unsigned long int)ksiz);
        datum->dsize = datum->dsize + ksiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$28;
          return_value_realloc$28=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$28;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }
  }

  if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
  {
    vbuf=cbmapget(doc->attrs, "", 0, &vsiz);
    if(!(vbuf == ((const char *)NULL)))
    {
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$29;
          return_value_realloc$29=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$29;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(datum->dsize + vsiz >= datum->asize)
        {
          datum->asize = datum->asize * 2 + vsiz + 1;
          void *return_value_realloc$30;
          return_value_realloc$30=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$30;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)vbuf, (unsigned long int)vsiz);
        datum->dsize = datum->dsize + vsiz;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      do
      {
        if(1 + datum->dsize >= datum->asize)
        {
          datum->asize = datum->asize * 2 + 1 + 1;
          void *return_value_realloc$31;
          return_value_realloc$31=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$31;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\n", (unsigned long int)1);
        datum->dsize = datum->dsize + 1;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }

  char *return_value_cbdatumtomalloc$32;
  return_value_cbdatumtomalloc$32=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc$32;
}

// est_doc_dup
// file estraier.c line 4209
struct anonymous$0 * est_doc_dup(struct anonymous$0 *doc)
{
  struct anonymous$0 *ndoc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$0) /*32ul*/ );
  ndoc = (struct anonymous$0 *)return_value_malloc$1;
  if(!(ndoc == ((struct anonymous$0 *)NULL)))
    ndoc;

  else
    cbmyfatal("out of memory");
  ndoc->id = doc->id;
  struct anonymous$9 *tmp_if_expr$3;
  struct anonymous$9 *return_value_cbmapdup$2;
  if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
  {
    return_value_cbmapdup$2=cbmapdup(doc->attrs);
    tmp_if_expr$3 = return_value_cbmapdup$2;
  }

  else
    tmp_if_expr$3 = (struct anonymous$9 *)(void *)0;
  ndoc->attrs = tmp_if_expr$3;
  struct anonymous$1 *tmp_if_expr$5;
  struct anonymous$1 *return_value_cblistdup$4;
  if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
  {
    return_value_cblistdup$4=cblistdup(doc->dtexts);
    tmp_if_expr$5 = return_value_cblistdup$4;
  }

  else
    tmp_if_expr$5 = (struct anonymous$1 *)(void *)0;
  ndoc->dtexts = tmp_if_expr$5;
  struct anonymous$9 *tmp_if_expr$7;
  struct anonymous$9 *return_value_cbmapdup$6;
  if(!(doc->kwords == ((struct anonymous$9 *)NULL)))
  {
    return_value_cbmapdup$6=cbmapdup(doc->kwords);
    tmp_if_expr$7 = return_value_cbmapdup$6;
  }

  else
    tmp_if_expr$7 = (struct anonymous$9 *)(void *)0;
  ndoc->kwords = tmp_if_expr$7;
  return ndoc;
}

// est_doc_hidden_texts
// file estraier.c line 4229
const char * est_doc_hidden_texts(struct anonymous$0 *doc)
{
  const char *rv;
  const char *tmp_if_expr$2;
  const char *return_value_cbmapget$1;
  if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
  {
    return_value_cbmapget$1=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
    tmp_if_expr$2 = return_value_cbmapget$1;
  }

  else
    tmp_if_expr$2 = (const char *)(void *)0;
  rv = tmp_if_expr$2;
  return rv != ((const char *)NULL) ? rv : "";
}

// est_doc_id
// file estraier.h line 134
signed int est_doc_id(struct anonymous$0 *doc)
{
  return doc->id;
}

// est_doc_is_empty
// file estraier.c line 4268
signed int est_doc_is_empty(struct anonymous$0 *doc)
{
  _Bool tmp_if_expr$3;
  if(doc->dtexts == ((struct anonymous$1 *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)doc->dtexts->num < 1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  const char *return_value_cbmapget$1;
  if(tmp_if_expr$3)
  {
    if(doc->attrs == ((struct anonymous$9 *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_cbmapget$1=cbmapget(doc->attrs, "", 0, (signed int *)(void *)0);
      tmp_if_expr$2 = !(return_value_cbmapget$1 != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$2)
      goto __CPROVER_DUMP_L5;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    return 0;
  }
}

// est_doc_keywords
// file estraier.c line 648
struct anonymous$9 * est_doc_keywords(struct anonymous$0 *doc)
{
  return doc->kwords;
}

// est_doc_make_snippet
// file estraier.c line 719
char * est_doc_make_snippet(struct anonymous$0 *doc, const struct anonymous$1 *words, signed int wwidth, signed int hwidth, signed int awidth)
{
  struct anonymous$2 *sbuf;
  const char *text;
  char *snippet;
  signed int i;
  signed int size;
  if(doc->dtexts == ((struct anonymous$1 *)NULL))
    do
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
      doc->dtexts = (struct anonymous$1 *)return_value_malloc$1;
      if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
        doc->dtexts;

      else
        cbmyfatal("out of memory");
      doc->dtexts->anum = 64;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
      doc->dtexts->array = (struct anonymous$28 *)return_value_malloc$2;
      if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
        doc->dtexts->array;

      else
        cbmyfatal("out of memory");
      doc->dtexts->start = 0;
      doc->dtexts->num = 0;
    }
    while((_Bool)0);

  do
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    sbuf = (struct anonymous$2 *)return_value_malloc$3;
    if(!(sbuf == ((struct anonymous$2 *)NULL)))
      sbuf;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$4;
    return_value_malloc$4=malloc((unsigned long int)12);
    sbuf->dptr = (char *)return_value_malloc$4;
    if(!(sbuf->dptr == ((char *)NULL)))
      sbuf->dptr;

    else
      cbmyfatal("out of memory");
    sbuf->dptr[(signed long int)0] = (char)0;
    sbuf->dsize = 0;
    sbuf->asize = 12;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= doc->dtexts->num); i = i + 1)
  {
    size = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
    text = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
    if(i >= 1)
      do
      {
        if(1 + sbuf->dsize >= sbuf->asize)
        {
          sbuf->asize = sbuf->asize * 2 + 1 + 1;
          void *return_value_realloc$5;
          return_value_realloc$5=realloc((void *)sbuf->dptr, (unsigned long int)sbuf->asize);
          sbuf->dptr = (char *)return_value_realloc$5;
          if(!(sbuf->dptr == ((char *)NULL)))
            sbuf->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(sbuf->dptr + (signed long int)sbuf->dsize), (const void *)" ", (unsigned long int)1);
        sbuf->dsize = sbuf->dsize + 1;
        sbuf->dptr[(signed long int)sbuf->dsize] = (char)0;
      }
      while((_Bool)0);

    do
    {
      if(sbuf->dsize + size >= sbuf->asize)
      {
        sbuf->asize = sbuf->asize * 2 + size + 1;
        void *return_value_realloc$6;
        return_value_realloc$6=realloc((void *)sbuf->dptr, (unsigned long int)sbuf->asize);
        sbuf->dptr = (char *)return_value_realloc$6;
        if(!(sbuf->dptr == ((char *)NULL)))
          sbuf->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(sbuf->dptr + (signed long int)sbuf->dsize), (const void *)text, (unsigned long int)size);
      sbuf->dsize = sbuf->dsize + size;
      sbuf->dptr[(signed long int)sbuf->dsize] = (char)0;
    }
    while((_Bool)0);
  }
  snippet=est_make_snippet((const char *)sbuf->dptr, (signed int)sbuf->dsize, words, wwidth, hwidth, awidth);
  do
  {
    free((void *)sbuf->dptr);
    free((void *)sbuf);
  }
  while((_Bool)0);
  return snippet;
}

// est_doc_new
// file estraier.h line 82
struct anonymous$0 * est_doc_new(void)
{
  struct anonymous$0 *doc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$0) /*32ul*/ );
  doc = (struct anonymous$0 *)return_value_malloc$1;
  if(!(doc == ((struct anonymous$0 *)NULL)))
    doc;

  else
    cbmyfatal("out of memory");
  doc->id = -1;
  doc->attrs = (struct anonymous$9 *)(void *)0;
  doc->dtexts = (struct anonymous$1 *)(void *)0;
  doc->kwords = (struct anonymous$9 *)(void *)0;
  return doc;
}

// est_doc_new_from_chaos
// file estmttest.c line 505
static struct anonymous$0 * est_doc_new_from_chaos(signed int cnum, signed int snum, signed int mode)
{
  struct anonymous$0 *doc;
  char *str;
  signed int i;
  doc=est_doc_new();
  double return_value_est_random_nd$1;
  return_value_est_random_nd$1=est_random_nd();
  double return_value_pow$2;
  return_value_pow$2=pow(return_value_est_random_nd$1 + 0.5, 3.0);
  snum = snum * (signed int)return_value_pow$2;
  if(mode == 6)
  {
    double return_value_est_random$3;
    return_value_est_random$3=est_random();
    mode = (signed int)(return_value_est_random$3 * (double)100);
    if(!(mode >= 20))
    {
      mode = 0;
      est_doc_add_attr(doc, "mode", "english");
    }

    else
      if(!(mode >= 40))
      {
        mode = 1;
        est_doc_add_attr(doc, "mode", "latin");
      }

      else
        if(!(mode >= 60))
        {
          mode = 2;
          est_doc_add_attr(doc, "mode", "euromix");
        }

        else
          if(!(mode >= 65))
          {
            mode = 3;
            est_doc_add_attr(doc, "mode", "oriental");
          }

          else
            if(!(mode >= 95))
            {
              mode = 4;
              est_doc_add_attr(doc, "mode", "japanese");
            }

            else
            {
              mode = 5;
              est_doc_add_attr(doc, "mode", "chaos");
            }
  }

  switch(mode)
  {
    case 0:
    {
      est_doc_add_attr(doc, "mode", "english");
      break;
    }
    case 1:
    {
      est_doc_add_attr(doc, "mode", "latin");
      break;
    }
    case 3:
    {
      est_doc_add_attr(doc, "mode", "oriental");
      break;
    }
    case 4:
    {
      est_doc_add_attr(doc, "mode", "japanese");
      break;
    }
    case 2:
    {
      est_doc_add_attr(doc, "mode", "euromix");
      break;
    }
    case 5:
      est_doc_add_attr(doc, "mode", "chaos");
  }
  i = 0;
  for( ; snum >= i; i = i + 1)
  {
    str=est_random_str(cnum, mode);
    double return_value_est_random$4;
    return_value_est_random$4=est_random();
    if(return_value_est_random$4 < 0.05)
      est_doc_add_hidden_text(doc, str);

    else
      est_doc_add_text(doc, str);
    free((void *)str);
  }
  return doc;
}

// est_doc_new_from_draft
// file estraier.c line 429
struct anonymous$0 * est_doc_new_from_draft(const char *draft)
{
  struct anonymous$0 *doc;
  struct anonymous$1 *lines;
  const char *line;
  char *pv;
  char *rp;
  char *ep;
  signed int i;
  doc=est_doc_new();
  lines=cbsplit(draft, -1, "\n");
  i = 0;
  signed int return_value_cbstrfwmatch$2;
  signed int return_value_atoi$1;
  char *tmp_post$4;
  for( ; !(i >= lines->num); i = i + 1)
  {
    line = (const char *)(lines->array + (signed long int)(lines->start + i))->dptr;
    for( ; (signed int)*line >= 1; line = line + 1l)
      if((signed int)*line >= 33)
        break;

    if((signed int)*line == 0)
    {
      i = i + 1;
      break;
    }

    if((signed int)*line == 37)
    {
      signed int return_value_cbstrfwmatch$3;
      return_value_cbstrfwmatch$3=cbstrfwmatch(line, "%VECTOR");
      if(!(return_value_cbstrfwmatch$3 == 0))
      {
        if(doc->kwords == ((struct anonymous$9 *)NULL))
          doc->kwords=cbmapopenex(31);

        rp=strchr(line, 9);
        if(!(rp == ((char *)NULL)))
          rp = rp + 1l;

        for( ; !(rp == ((char *)NULL)); rp = ep)
        {
          pv=strchr(rp, 9);
          if(pv == ((char *)NULL))
            break;

          pv = pv + 1l;
          ep=strchr(pv, 9);
          if(!(ep == ((char *)NULL)))
          {
            *ep = (char)0;
            ep = ep + 1l;
          }

          if(!((signed int)*rp == 0))
          {
            if(!((signed int)*pv == 0))
              cbmapput(doc->kwords, rp, (signed int)((pv - rp) - (signed long int)1), pv, -1, 1);

          }

        }
      }

      else
      {
        return_value_cbstrfwmatch$2=cbstrfwmatch(line, "%SCORE");
        if(!(return_value_cbstrfwmatch$2 == 0))
        {
          rp=strchr(line, 9);
          if(!(rp == ((char *)NULL)))
          {
            return_value_atoi$1=atoi(rp + (signed long int)1);
            est_doc_set_score(doc, return_value_atoi$1);
          }

        }

      }
    }

    else
    {
      pv=strchr(line, 61);
      if(!(pv == ((char *)NULL)))
      {
        tmp_post$4 = pv;
        pv = pv + 1l;
        *tmp_post$4 = (char)0;
        est_doc_add_attr(doc, line, pv);
      }

    }
  }
  for( ; !(i >= lines->num); i = i + 1)
  {
    line = (const char *)(lines->array + (signed long int)(lines->start + i))->dptr;
    if((signed int)*line == 9)
      est_doc_add_hidden_text(doc, line + (signed long int)1);

    else
      est_doc_add_text(doc, line);
  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = lines->start + lines->num;
    _CB_i = lines->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(lines->array + (signed long int)_CB_i)->dptr);
    free((void *)lines->array);
    free((void *)lines);
  }
  while((_Bool)0);
  return doc;
}

// est_doc_score
// file estraier.c line 655
signed int est_doc_score(struct anonymous$0 *doc)
{
  const char *vbuf;
  signed int return_value_atoi$1;
  if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
  {
    vbuf=cbmapget(doc->attrs, "\t", 1, (signed int *)(void *)0);
    if(vbuf == ((const char *)NULL))
      goto __CPROVER_DUMP_L1;

    return_value_atoi$1=atoi(vbuf);
    return return_value_atoi$1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return -1;
  }
}

// est_doc_set_id
// file estraier.c line 4222
void est_doc_set_id(struct anonymous$0 *doc, signed int id)
{
  doc->id = id;
}

// est_doc_set_keywords
// file estraier.c line 567
void est_doc_set_keywords(struct anonymous$0 *doc, struct anonymous$9 *kwords)
{
  if(!(doc->kwords == ((struct anonymous$9 *)NULL)))
    cbmapclose(doc->kwords);

  doc->kwords=cbmapdup(kwords);
}

// est_doc_set_score
// file estraier.c line 575
void est_doc_set_score(struct anonymous$0 *doc, signed int score)
{
  char numbuf[32l];
  if(doc->attrs == ((struct anonymous$9 *)NULL))
    doc->attrs=cbmapopenex(31);

  if(score >= 0)
  {
    sprintf(numbuf, "%d", score);
    cbmapput(doc->attrs, "\t", 1, numbuf, -1, 1);
  }

  else
    cbmapout(doc->attrs, "\t", 1);
}

// est_doc_slim
// file estraier.c line 4238
void est_doc_slim(struct anonymous$0 *doc, signed int len)
{
  const char *vbuf;
  unsigned char *tbuf;
  signed int i;
  signed int vsiz;
  signed int tsiz;
  const char *return_value_cbmapget$1;
  _Bool tmp_if_expr$3;
  if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
  {
    if(!(doc->attrs == ((struct anonymous$9 *)NULL)))
    {
      return_value_cbmapget$1=cbmapget(doc->attrs, "", 0, &vsiz);
      if(!(return_value_cbmapget$1 == ((const char *)NULL)))
        len = len - vsiz;

    }

    i = 0;
    for( ; !(i >= doc->dtexts->num); i = i + 1)
    {
      vsiz = (doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dsize;
      vbuf = (const char *)(doc->dtexts->array + (signed long int)(doc->dtexts->start + i))->dptr;
      len = len - vsiz;
      if(!(len >= 0))
      {
        char *return_value_cbmemdup$2;
        return_value_cbmemdup$2=cbmemdup(vbuf, vsiz);
        tbuf = (unsigned char *)return_value_cbmemdup$2;
        tsiz = vsiz > -len ? vsiz + len : 0;
        if(tsiz >= 1)
          for( ; !(tsiz >= vsiz); tsiz = tsiz + 1)
          {
            if(!((signed int)tbuf[(signed long int)tsiz] >= 33))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = ((signed int)tbuf[(signed long int)tsiz] & 0xf0) == 0xe0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
              break;

          }

        while(!(i >= doc->dtexts->num))
          do
            if(doc->dtexts->num >= 1)
            {
              free((void *)(doc->dtexts->array + (signed long int)((doc->dtexts->start + doc->dtexts->num) - 1))->dptr);
              doc->dtexts->num = doc->dtexts->num - 1;
            }

          while((_Bool)0);
        do
        {
          signed int _CB_index = doc->dtexts->start + doc->dtexts->num;
          if(_CB_index >= doc->dtexts->anum)
          {
            doc->dtexts->anum = doc->dtexts->anum * 2;
            void *return_value_realloc$4;
            return_value_realloc$4=realloc((void *)doc->dtexts->array, (unsigned long int)doc->dtexts->anum * sizeof(struct anonymous$28) /*16ul*/ );
            doc->dtexts->array = (struct anonymous$28 *)return_value_realloc$4;
            if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
              doc->dtexts->array;

            else
              cbmyfatal("out of memory");
          }

          (doc->dtexts->array + (signed long int)_CB_index)->dptr = (char *)tbuf;
          (doc->dtexts->array + (signed long int)_CB_index)->dsize = tsiz;
          doc->dtexts->num = doc->dtexts->num + 1;
        }
        while((_Bool)0);
        break;
      }

    }
  }

}

// est_doc_texts
// file estraier.c line 624
const struct anonymous$1 * est_doc_texts(struct anonymous$0 *doc)
{
  if(doc->dtexts == ((struct anonymous$1 *)NULL))
    do
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
      doc->dtexts = (struct anonymous$1 *)return_value_malloc$1;
      if(!(doc->dtexts == ((struct anonymous$1 *)NULL)))
        doc->dtexts;

      else
        cbmyfatal("out of memory");
      doc->dtexts->anum = 64;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)doc->dtexts->anum);
      doc->dtexts->array = (struct anonymous$28 *)return_value_malloc$2;
      if(!(doc->dtexts->array == ((struct anonymous$28 *)NULL)))
        doc->dtexts->array;

      else
        cbmyfatal("out of memory");
      doc->dtexts->start = 0;
      doc->dtexts->num = 0;
    }
    while((_Bool)0);

  return doc->dtexts;
}

// est_eclipse_scores
// file estraier.c line 9858
static signed int est_eclipse_scores(struct anonymous *db, struct anonymous$6 *scores, signed int snum, signed int num, signed int vnum, signed int tfidf, double limit, struct anonymous$9 *shadows)
{
  struct anonymous$9 *svmap;
  struct anonymous$9 *tvmap;
  const char *suri;
  const char *turi;
  char *tmp;
  signed int i;
  signed int j;
  signed int ubase;
  signed int simurl;
  signed int max;
  signed int *svec;
  signed int *tvec;
  signed int pair[2l];
  signed int nnum;
  double dval;
  ubase = 0;
  simurl = 0;
  if(IEEE_FLOAT_EQUAL(limit, 100.0) || IEEE_FLOAT_EQUAL(limit, 101.0) || IEEE_FLOAT_EQUAL(limit, 102.0))
    ubase = 1;

  else
    if(limit >= 10.0)
    {
      simurl = 1;
      limit = limit - 10.0;
      if(limit < 0.01)
        limit = 0.01;

      if(limit > 1.0)
        limit = 1.0;

    }

  nnum = 0;
  signed int tmp_post$2;
  signed int tmp_post$3;
  _Bool tmp_if_expr$7;
  signed int return_value_cbmaprnum$6;
  signed int tmp_post$8;
  _Bool tmp_if_expr$10;
  signed int return_value_cbmaprnum$9;
  double return_value_acos$12;
  double return_value_pow$13;
  double return_value_cos$14;
  signed int tmp_post$24;
  signed int tmp_post$25;
  if(!(ubase == 0))
  {
    if(IEEE_FLOAT_EQUAL(limit, 100.0))
      max = (signed int)((double)num * 14.8 + (double)8);

    else
      if(IEEE_FLOAT_EQUAL(limit, 101.0))
        max = (signed int)((double)num * 6.8 + (double)8);

      else
        max = (signed int)((double)num * 4.8 + (double)8);
    if(!(snum >= max))
      max = snum;

    i = 0;
    for( ; !(i >= max); i = i + 1)
      (scores + (signed long int)i)->value=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, "@uri");
    i = 0;
    for( ; !(i >= max); i = i + 1)
      if(!((scores + (signed long int)i)->value == ((char *)NULL)))
      {
        j = i + 1;
        for( ; !(j >= max); j = j + 1)
        {
          dval = 0.0;
          if(!((scores + (signed long int)j)->value == ((char *)NULL)))
          {
            signed int return_value_est_url_sameness$1;
            return_value_est_url_sameness$1=est_url_sameness((scores + (signed long int)i)->value, (scores + (signed long int)j)->value);
            switch(return_value_est_url_sameness$1)
            {
              case 1:
              {
                dval = 100.0;
                break;
              }
              case 2:
              {
                dval = 101.0;
                break;
              }
              case 3:
                dval = 102.0;
            }
          }

          if(dval >= limit)
          {
            free((void *)(scores + (signed long int)j)->value);
            (scores + (signed long int)j)->value = (char *)(void *)0;
            pair[(signed long int)0] = (scores + (signed long int)j)->id;
            pair[(signed long int)1] = 0;
            cbmapputcat(shadows, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , (char *)pair, (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2));
          }

        }
      }

    i = 0;
    for( ; !(i >= max); i = i + 1)
      if(!((scores + (signed long int)i)->value == ((char *)NULL)))
      {
        free((void *)(scores + (signed long int)i)->value);
        tmp_post$2 = nnum;
        nnum = nnum + 1;
        scores[(signed long int)tmp_post$2] = scores[(signed long int)i];
      }

    i = max;
    for( ; !(i >= snum); i = i + 1)
    {
      tmp_post$3 = nnum;
      nnum = nnum + 1;
      scores[(signed long int)tmp_post$3] = scores[(signed long int)i];
    }
  }

  else
  {
    max = (signed int)(limit < 0.1 ? (double)snum : (double)num * (2.4 / (limit - 0.05) + 0.8) + (double)8);
    if(!(simurl == 0))
      max = max * (signed int)1.4;

    if(!(snum >= max))
      max = snum;

    void *return_value_malloc$4;
    return_value_malloc$4=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
    svec = (signed int *)return_value_malloc$4;
    if(!(svec == ((signed int *)NULL)))
      svec;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
    tvec = (signed int *)return_value_malloc$5;
    if(!(tvec == ((signed int *)NULL)))
      tvec;

    else
      cbmyfatal("out of memory");
    i = 0;
    for( ; !(i >= max); i = i + 1)
    {
      svmap=est_get_tvmap(db, (scores + (signed long int)i)->id, vnum, tfidf);
      if(!(svmap == ((struct anonymous$9 *)NULL)))
      {
        (scores + (signed long int)i)->value = (char *)svmap;
        if(!(simurl == 0))
        {
          tmp=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, "@uri");
          if(!(tmp == ((char *)NULL)))
          {
            cbmapput(svmap, "", 0, tmp, -1, 1);
            free((void *)tmp);
          }

        }

      }

      else
        (scores + (signed long int)i)->value = (char *)(void *)0;
    }
    i = 0;
    for( ; !(i >= max); i = i + 1)
    {
      svmap = (struct anonymous$9 *)(scores + (signed long int)i)->value;
      if(svmap == ((struct anonymous$9 *)NULL))
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_cbmaprnum$6=cbmaprnum(svmap);
        tmp_if_expr$7 = return_value_cbmaprnum$6 < 1 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$7)
      {
        suri=cbmapget((struct anonymous$9 *)(scores + (signed long int)i)->value, "", -1, (signed int *)(void *)0);
        tmp_post$8 = num;
        num = num - 1;
        if(tmp_post$8 >= 1)
        {
          est_vector_set_seed(svmap, svec, vnum);
          j = i + 1;
          for( ; !(j >= max); j = j + 1)
          {
            tvmap = (struct anonymous$9 *)(scores + (signed long int)j)->value;
            if(tvmap == ((struct anonymous$9 *)NULL))
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              return_value_cbmaprnum$9=cbmaprnum(tvmap);
              tmp_if_expr$10 = return_value_cbmaprnum$9 < 1 ? (_Bool)1 : (_Bool)0;
            }
            if(!tmp_if_expr$10)
            {
              est_vector_set_target(svmap, tvmap, tvec, vnum);
              dval=est_vector_cosine(svec, tvec, vnum);
              if(dval > 0.01 && !(suri == ((const char *)NULL)))
              {
                turi=cbmapget((struct anonymous$9 *)(scores + (signed long int)j)->value, "", -1, (signed int *)(void *)0);
                if(!(turi == ((const char *)NULL)))
                {
                  signed int return_value_est_url_sameness$11;
                  return_value_est_url_sameness$11=est_url_sameness(suri, turi);
                  if(!(return_value_est_url_sameness$11 == 1))
                  {
                    if(return_value_est_url_sameness$11 == 2)
                      goto __CPROVER_DUMP_L45;

                    if(return_value_est_url_sameness$11 == 3)
                      goto __CPROVER_DUMP_L46;

                    return_value_acos$12=acos(dval);
                    return_value_pow$13=pow(dval, 9.9);
                    return_value_cos$14=cos(return_value_acos$12 * (1.0 - return_value_pow$13));
                    dval=pow(return_value_cos$14, 1.07);
                  }

                  else
                  {
                    double return_value_acos$15;
                    return_value_acos$15=acos(dval);
                    double return_value_pow$16;
                    return_value_pow$16=pow(dval, 4.1);
                    double return_value_cos$17;
                    return_value_cos$17=cos(return_value_acos$15 * (1.0 - return_value_pow$16));
                    dval=pow(return_value_cos$17, 1.05);
                    goto __CPROVER_DUMP_L47;

                  __CPROVER_DUMP_L45:
                    ;
                    double return_value_acos$18;
                    return_value_acos$18=acos(dval);
                    double return_value_pow$19;
                    return_value_pow$19=pow(dval, 2.9);
                    double return_value_cos$20;
                    return_value_cos$20=cos(return_value_acos$18 * (1.0 - return_value_pow$19));
                    dval=pow(return_value_cos$20, 1.03);
                    goto __CPROVER_DUMP_L47;

                  __CPROVER_DUMP_L46:
                    ;
                    double return_value_acos$21;
                    return_value_acos$21=acos(dval);
                    double return_value_pow$22;
                    return_value_pow$22=pow(dval, 2.1);
                    double return_value_cos$23;
                    return_value_cos$23=cos(return_value_acos$21 * (1.0 - return_value_pow$22));
                    dval=pow(return_value_cos$23, 1.01);
                  }
                }

              }


            __CPROVER_DUMP_L47:
              ;
              if(dval > limit)
              {
                cbmapclose(tvmap);
                (scores + (signed long int)j)->value = (char *)(void *)0;
                pair[(signed long int)0] = (scores + (signed long int)j)->id;
                pair[(signed long int)1] = (signed int)(dval * 10000.0);
                cbmapputcat(shadows, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , (char *)pair, (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2));
              }

            }

          }
        }

      }

    }
    i = 0;
    for( ; !(i >= max); i = i + 1)
      if(!((scores + (signed long int)i)->value == ((char *)NULL)))
      {
        cbmapclose((struct anonymous$9 *)(scores + (signed long int)i)->value);
        tmp_post$24 = nnum;
        nnum = nnum + 1;
        scores[(signed long int)tmp_post$24] = scores[(signed long int)i];
      }

    i = max;
    for( ; !(i >= snum); i = i + 1)
    {
      tmp_post$25 = nnum;
      nnum = nnum + 1;
      scores[(signed long int)tmp_post$25] = scores[(signed long int)i];
    }
    free((void *)tvec);
    free((void *)svec);
  }
  return nnum;
}

// est_enc_miss
// file estraier.c line 5917
static signed int est_enc_miss(const char *ptr, signed int size, const char *icode, const char *ocode)
{
  void *ic;
  char obuf[32768l];
  char *wp;
  char *rp;
  unsigned long int isiz;
  unsigned long int osiz;
  signed int miss;
  isiz = (unsigned long int)size;
  ic=iconv_open(ocode, icode);
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(ic == (void *)-1)
    return 256;

  else
  {
    miss = 0;
    rp = (char *)ptr;
    while(isiz >= 1ul)
    {
      osiz = (unsigned long int)32768;
      wp = obuf;
      unsigned long int return_value_iconv$4;
      return_value_iconv$4=iconv(ic, (char ** restrict )(void *)&rp, &isiz, &wp, &osiz);
      if(return_value_iconv$4 == 18446744073709551615ul)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 84)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value___errno_location$2=__errno_location();
          tmp_if_expr$3 = *return_value___errno_location$2 == 22 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
        {
          rp = rp + 1l;
          isiz = isiz - 1ul;
          miss = miss + 1;
          if(miss >= 256)
            break;

        }

        else
          break;
      }

    }
    signed int return_value_iconv_close$5;
    return_value_iconv_close$5=iconv_close(ic);
    if(return_value_iconv_close$5 == -1)
      return 256;

    else
      return miss;
  }
}

// est_enc_name
// file estraier.c line 3604
const char * est_enc_name(const char *ptr, signed int size, signed int plang)
{
  const char *hypo;
  signed int i;
  signed int lim;
  signed int miss;
  signed int ascii;
  signed int cr;
  unsigned long int return_value_strlen$1;
  if(!(size >= 0))
  {
    return_value_strlen$1=strlen(ptr);
    size = (signed int)return_value_strlen$1;
  }

  if(size >= 32769)
    size = 32768;

  signed int return_value_memcmp$2;
  _Bool tmp_if_expr$4;
  signed int return_value_memcmp$3;
  _Bool tmp_if_expr$5;
  signed int return_value_est_enc_miss$6;
  char *return_value_strchr$7;
  char *return_value_strchr$8;
  signed int return_value_est_enc_miss$9;
  signed int return_value_est_enc_miss$10;
  signed int return_value_est_enc_miss$11;
  signed int return_value_est_enc_miss$12;
  signed int return_value_est_enc_miss$13;
  signed int return_value_est_enc_miss$14;
  if(size >= 2)
  {
    return_value_memcmp$2=memcmp((const void *)ptr, (const void *)"", (unsigned long int)2);
    if(return_value_memcmp$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_memcmp$3=memcmp((const void *)ptr, (const void *)"", (unsigned long int)2);
      tmp_if_expr$4 = !(return_value_memcmp$3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$4)
      goto __CPROVER_DUMP_L5;

    return "UTF-16";
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    ascii = 1;
    cr = 0;
    lim = size - 1;
    i = 0;
    for( ; !(i >= lim); i = i + 2)
    {
      if((signed int)ptr[(signed long int)i] == 0x0)
        return "UTF-16BE";

      if((signed int)ptr[(signed long int)(1 + i)] == 0x0)
        return "UTF-16LE";

      if(!((signed int)ptr[(signed long int)i] >= 0x0))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)ptr[(signed long int)i] == 0x1b ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        ascii = 0;

      else
        if((signed int)ptr[(signed long int)i] == 0xd)
          cr = 1;

    }
    if(!(ascii == 0))
      return "US-ASCII";

    else
      switch(plang)
      {
        case 0:
        {
          return_value_est_enc_miss$6=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss$6 >= 1))
            return "UTF-8";

          return "ISO-8859-1";
        }
        case 1:
        {
          lim = size - 3;
          i = 0;
          for( ; !(i >= lim); i = i + 1)
            if((signed int)ptr[(signed long int)i] == 0x1b)
            {
              i = i + 1;
              if((signed int)ptr[(signed long int)i] == 40)
              {
                return_value_strchr$7=strchr("BJHI", (signed int)ptr[(signed long int)(i + 1)]);
                if(!(return_value_strchr$7 == ((char *)NULL)))
                  return "ISO-2022-JP";

              }

              if((signed int)ptr[(signed long int)i] == 36)
              {
                return_value_strchr$8=strchr("@B(", (signed int)ptr[(signed long int)(i + 1)]);
                if(!(return_value_strchr$8 == ((char *)NULL)))
                  return "ISO-2022-JP";

              }

            }

          return_value_est_enc_miss$9=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss$9 >= 1))
            return "UTF-8";

          hypo = (const char *)(void *)0;
          if(!(cr == 0))
          {
            miss=est_enc_miss(ptr, size, "Shift_JIS", "EUC-JP");
            if(!(miss >= 1))
              return "Shift_JIS";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "Shift_JIS";

            miss=est_enc_miss(ptr, size, "EUC-JP", "UTF-16BE");
            if(!(miss >= 1))
              return "EUC-JP";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "EUC-JP";

          }

          else
          {
            miss=est_enc_miss(ptr, size, "EUC-JP", "UTF-16BE");
            if(!(miss >= 1))
              return "EUC-JP";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "EUC-JP";

            miss=est_enc_miss(ptr, size, "Shift_JIS", "EUC-JP");
            if(!(miss >= 1))
              return "Shift_JIS";

            if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
              hypo = "Shift_JIS";

          }
          miss=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(miss >= 1))
            return "UTF-8";

          if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
            hypo = "UTF-8";

          miss=est_enc_miss(ptr, size, "CP932", "UTF-16BE");
          if(!(miss >= 1))
            return "CP932";

          if((double)miss / (double)size <= 0.001 && hypo == ((const char *)NULL))
            hypo = "CP932";

          return hypo != ((const char *)NULL) ? hypo : "ISO-8859-1";
        }
        case 2:
        {
          return_value_est_enc_miss$10=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss$10 >= 1))
            return "UTF-8";

          return_value_est_enc_miss$11=est_enc_miss(ptr, size, "EUC-CN", "UTF-16BE");
          if(!(return_value_est_enc_miss$11 >= 1))
            return "EUC-CN";

          return_value_est_enc_miss$12=est_enc_miss(ptr, size, "BIG5", "UTF-16BE");
          if(!(return_value_est_enc_miss$12 >= 1))
            return "BIG5";

          return "ISO-8859-1";
        }
        case 3:
        {
          return_value_est_enc_miss$13=est_enc_miss(ptr, size, "UTF-8", "UTF-16BE");
          if(!(return_value_est_enc_miss$13 >= 1))
            return "UTF-8";

          return_value_est_enc_miss$14=est_enc_miss(ptr, size, "EUC-KR", "UTF-16BE");
          if(!(return_value_est_enc_miss$14 >= 1))
            return "EUC-KR";

          return "ISO-8859-1";
        }
        default:
          return "ISO-8859-1";
      }
  }
}

// est_encode_idx_rec
// file estraier.c line 6912
static void est_encode_idx_rec(struct anonymous$2 *datum, const char *vbuf, signed int vsiz, signed int lid, signed int smode)
{
  const char *rp;
  const char *ep;
  const char *sp;
  char nbuf[32l];
  signed int cid;
  signed int vstep;
  rp = vbuf;
  ep = vbuf + (signed long int)vsiz;
  for( ; !(rp >= ep); lid = cid)
  {
    do
    {
      signed int _EST_i;
      signed int _EST_base;
      cid = 0;
      _EST_base = 1;
      _EST_i = 0;
      for( ; (_Bool)1; _EST_i = _EST_i + 1)
      {
        if((signed int)rp[(signed long int)_EST_i] >= 0)
        {
          cid = cid + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
          break;
        }

        cid = cid + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
        _EST_base = _EST_base * 128;
      }
      vstep = _EST_i + 1;
    }
    while((_Bool)0);
    rp = rp + (signed long int)vstep;
    sp = rp;
    if(!(smode == 1048576))
    {
      if(smode == 2097152 || smode == 4194304)
        goto __CPROVER_DUMP_L8;

    }

    else
      goto __CPROVER_DUMP_L9;
    rp = rp + 1l;
    goto __CPROVER_DUMP_L9;

  __CPROVER_DUMP_L8:
    ;
    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

  __CPROVER_DUMP_L9:
    ;
    for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
      ;
    rp = rp + 1l;
    do
    {
      signed int _EST_num = (cid - lid) - 1;
      struct anonymous$15 EST_d;
      if(_EST_num == 0)
      {
        ((signed char *)nbuf)[(signed long int)0] = (signed char)0;
        vstep = 1;
      }

      else
      {
        vstep = 0;
        for( ; _EST_num >= 1; vstep = vstep + 1)
        {
          EST_d=div(_EST_num, 128);
          _EST_num = EST_d.quot;
          if(_EST_num >= 1)
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)(-EST_d.rem - 1);

          else
            ((signed char *)nbuf)[(signed long int)vstep] = (signed char)EST_d.rem;
        }
      }
    }
    while((_Bool)0);
    do
    {
      if(datum->dsize + vstep >= datum->asize)
      {
        datum->asize = datum->asize * 2 + vstep + 1;
        void *return_value_realloc$1;
        return_value_realloc$1=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc$1;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)nbuf, (unsigned long int)vstep);
      datum->dsize = datum->dsize + vstep;
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
    do
    {
      if((rp - sp) + (signed long int)datum->dsize >= (signed long int)datum->asize)
      {
        datum->asize = (signed int)((signed long int)(datum->asize * 2) + (rp - sp) + (signed long int)1);
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc$2;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, (unsigned long int)(rp - sp));
      datum->dsize = datum->dsize + (signed int)(rp - sp);
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
  }
}

// est_err_msg
// file estraier.h line 511
const char * est_err_msg(signed int ecode)
{
  switch(ecode)
  {
    case 0:
      return "no error";
    case 1:
      return "invalid argument";
    case 2:
      return "access forbidden";
    case 3:
      return "lock failure";
    case 4:
      return "database problem";
    case 5:
      return "I/O problem";
    case 6:
      return "no such item";
    default:
      return "miscellaneous";
  }
}

// est_expand_keyword_bw
// file estraier.c line 8347
static void est_expand_keyword_bw(struct anonymous *db, const char *word, struct anonymous$1 *list)
{
  const char *kbuf;
  signed int num;
  signed int ksiz;
  num = 0;
  vlcurjump(db->xfmdb, word, -1, 0);
  do
  {
    kbuf=vlcurkeycache(db->xfmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    signed int return_value_cbstrfwmatch$1;
    return_value_cbstrfwmatch$1=cbstrfwmatch(kbuf, word);
    if(return_value_cbstrfwmatch$1 == 0)
      break;

    do
    {
      signed int _CB_index = list->start + list->num;
      if(_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
        list->array = (struct anonymous$28 *)return_value_realloc$2;
        if(!(list->array == ((struct anonymous$28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      void *return_value_malloc$3;
      return_value_malloc$3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
      (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$3;
      if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
        (list->array + (signed long int)_CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
      (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
      (list->array + (signed long int)_CB_index)->dsize = ksiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);
    num = num + 1;
    if(num >= db->wildmax)
      break;

    vlcurnext(db->xfmdb);
  }
  while((_Bool)1);
}

// est_expand_keyword_ew
// file estraier.c line 8366
static void est_expand_keyword_ew(struct anonymous *db, const char *word, struct anonymous$1 *list)
{
  const char *kbuf;
  signed int num;
  signed int wsiz;
  signed int ksiz;
  num = 0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(word);
  wsiz = (signed int)return_value_strlen$1;
  vlcurfirst(db->xfmdb);
  signed int return_value_memcmp$4;
  do
  {
    kbuf=vlcurkeycache(db->xfmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(ksiz >= wsiz)
    {
      return_value_memcmp$4=memcmp((const void *)((kbuf + (signed long int)ksiz) - (signed long int)wsiz), (const void *)word, (unsigned long int)wsiz);
      if(return_value_memcmp$4 == 0)
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc$2;
            return_value_realloc$2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
            list->array = (struct anonymous$28 *)return_value_realloc$2;
            if(!(list->array == ((struct anonymous$28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$3;
          return_value_malloc$3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$3;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

    }

    vlcurnext(db->xfmdb);
  }
  while((_Bool)1);
}

// est_expand_keyword_rx
// file estraier.c line 8387
static void est_expand_keyword_rx(struct anonymous *db, const char *word, struct anonymous$1 *list)
{
  void *regex;
  const char *kbuf;
  signed int num;
  signed int ksiz;
  regex=est_regex_new(word);
  if(!(regex == NULL))
  {
    num = 0;
    vlcurfirst(db->xfmdb);
    do
    {
      kbuf=vlcurkeycache(db->xfmdb, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      signed int return_value_est_regex_match$3;
      return_value_est_regex_match$3=est_regex_match(regex, kbuf);
      if(!(return_value_est_regex_match$3 == 0))
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc$1;
            return_value_realloc$1=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
            list->array = (struct anonymous$28 *)return_value_realloc$1;
            if(!(list->array == ((struct anonymous$28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$2;
          return_value_malloc$2=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$2;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

      vlcurnext(db->xfmdb);
    }
    while((_Bool)1);
    est_regex_delete(regex);
  }

}

// est_expand_word_bw
// file estraier.c line 8284
static void est_expand_word_bw(struct anonymous *db, const char *word, struct anonymous$1 *list)
{
  const char *kbuf;
  signed int num;
  signed int ksiz;
  num = 0;
  vlcurjump(db->fwmdb, word, -1, 0);
  do
  {
    kbuf=vlcurkeycache(db->fwmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    signed int return_value_cbstrfwmatch$1;
    return_value_cbstrfwmatch$1=cbstrfwmatch(kbuf, word);
    if(return_value_cbstrfwmatch$1 == 0)
      break;

    do
    {
      signed int _CB_index = list->start + list->num;
      if(_CB_index >= list->anum)
      {
        list->anum = list->anum * 2;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
        list->array = (struct anonymous$28 *)return_value_realloc$2;
        if(!(list->array == ((struct anonymous$28 *)NULL)))
          list->array;

        else
          cbmyfatal("out of memory");
      }

      void *return_value_malloc$3;
      return_value_malloc$3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
      (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$3;
      if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
        (list->array + (signed long int)_CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
      (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
      (list->array + (signed long int)_CB_index)->dsize = ksiz;
      list->num = list->num + 1;
    }
    while((_Bool)0);
    num = num + 1;
    if(num >= db->wildmax)
      break;

    vlcurnext(db->fwmdb);
  }
  while((_Bool)1);
}

// est_expand_word_ew
// file estraier.c line 8303
static void est_expand_word_ew(struct anonymous *db, const char *word, struct anonymous$1 *list)
{
  const char *kbuf;
  signed int num;
  signed int wsiz;
  signed int ksiz;
  num = 0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(word);
  wsiz = (signed int)return_value_strlen$1;
  vlcurfirst(db->fwmdb);
  signed int return_value_memcmp$4;
  do
  {
    kbuf=vlcurkeycache(db->fwmdb, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(ksiz >= wsiz)
    {
      return_value_memcmp$4=memcmp((const void *)((kbuf + (signed long int)ksiz) - (signed long int)wsiz), (const void *)word, (unsigned long int)wsiz);
      if(return_value_memcmp$4 == 0)
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc$2;
            return_value_realloc$2=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
            list->array = (struct anonymous$28 *)return_value_realloc$2;
            if(!(list->array == ((struct anonymous$28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$3;
          return_value_malloc$3=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$3;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

    }

    vlcurnext(db->fwmdb);
  }
  while((_Bool)1);
}

// est_expand_word_rx
// file estraier.c line 8324
static void est_expand_word_rx(struct anonymous *db, const char *word, struct anonymous$1 *list)
{
  void *regex;
  const char *kbuf;
  signed int num;
  signed int ksiz;
  regex=est_regex_new(word);
  if(!(regex == NULL))
  {
    num = 0;
    vlcurfirst(db->fwmdb);
    do
    {
      kbuf=vlcurkeycache(db->fwmdb, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      signed int return_value_est_regex_match$3;
      return_value_est_regex_match$3=est_regex_match(regex, kbuf);
      if(!(return_value_est_regex_match$3 == 0))
      {
        do
        {
          signed int _CB_index = list->start + list->num;
          if(_CB_index >= list->anum)
          {
            list->anum = list->anum * 2;
            void *return_value_realloc$1;
            return_value_realloc$1=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
            list->array = (struct anonymous$28 *)return_value_realloc$1;
            if(!(list->array == ((struct anonymous$28 *)NULL)))
              list->array;

            else
              cbmyfatal("out of memory");
          }

          void *return_value_malloc$2;
          return_value_malloc$2=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
          (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$2;
          if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
            (list->array + (signed long int)_CB_index)->dptr;

          else
            cbmyfatal("out of memory");
          memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
          (list->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
          (list->array + (signed long int)_CB_index)->dsize = ksiz;
          list->num = list->num + 1;
        }
        while((_Bool)0);
        num = num + 1;
        if(num >= db->wildmax)
          break;

      }

      vlcurnext(db->fwmdb);
    }
    while((_Bool)1);
    est_regex_delete(regex);
  }

}

// est_ext_type
// file estraier.c line 5738
const char * est_ext_type(const char *ext)
{
  signed int i = 0;
  static const char *list[169l] = { ".txt", "text/plain", ".txt.en", "text/plain", ".txt.ja", "text/plain", ".asc", "text/plain", ".in", "text/plain", ".c", "text/plain", ".h", "text/plain", ".cc", "text/plain", ".java", "text/plain", ".sh", "text/plain", ".pl", "text/plain", ".py", "text/plain", ".rb", "text/plain", ".idl", "text/plain", ".csv", "text/plain", ".log", "text/plain", ".conf", "text/plain", ".rc", "text/plain", ".ini", "text/plain", ".html", "text/html", ".htm", "text/html", ".xhtml", "text/html", ".xht", "text/html", ".css", "text/css", ".js", "text/javascript", ".tsv", "text/tab-separated-values", ".eml", "message/rfc822", ".mime", "message/rfc822", ".mht", "message/rfc822", ".mhtml", "message/rfc822", ".sgml", "application/sgml", ".sgm", "application/sgml", ".xml", "application/xml", ".xsl", "application/xml", ".xslt", "application/xslt+xml", ".xhtml", "application/xhtml+xml", ".xht", "application/xhtml+xml", ".rdf", "application/rdf+xml", ".rss", "application/rss+xml", ".dtd", "application/xml-dtd", ".rtf", "application/rtf", ".pdf", "application/pdf", ".ps", "application/postscript", ".eps", "application/postscript", ".doc", "application/msword", ".xls", "application/vnd.ms-excel", ".ppt", "application/vnd.ms-powerpoint", ".xdw", "application/vnd.fujixerox.docuworks", ".swf", "application/x-shockwave-flash", ".zip", "application/zip", ".tar", "application/x-tar", ".gz", "application/x-gzip", ".bz2", "application/octet-stream", ".z", "application/octet-stream", ".lha", "application/octet-stream", ".lzh", "application/octet-stream", ".cab", "application/octet-stream", ".rar", "application/octet-stream", ".sit", "application/octet-stream", ".bin", "application/octet-stream", ".o", "application/octet-stream", ".so", "application/octet-stream", ".exe", "application/octet-stream", ".dll", "application/octet-stream", ".class", "application/octet-stream", ".png", "image/png", ".gif", "image/gif", ".jpg", "image/jpeg", ".jpeg", "image/jpeg", ".tif", "image/tiff", ".tiff", "image/tiff", ".bmp", "image/bmp", ".au", "audio/basic", ".snd", "audio/basic", ".mid", "audio/midi", ".midi", "audio/midi", ".mp2", "audio/mpeg", ".mp3", "audio/mpeg", ".wav", "audio/x-wav", ".mpg", "video/mpeg", ".mpeg", "video/mpeg", ".qt", "video/quicktime", ".mov", "video/quicktime", ".avi", "video/x-msvideo", (const char *)(void *)0 };
  for( ; !(list[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_cbstricmp$1;
    return_value_cbstricmp$1=cbstricmp(ext, list[(signed long int)i]);
    if(return_value_cbstricmp$1 == 0)
      return list[(signed long int)(i + 1)];

  }
  return "application/octet-stream";
}

// est_free_cattr_list
// file estraier.c line 9831
static void est_free_cattr_list(struct anonymous$11 *list, signed int anum)
{
  signed int i = 0;
  for( ; !(i >= anum); i = i + 1)
  {
    if(!((list + (signed long int)i)->regex == NULL))
      est_regex_delete((list + (signed long int)i)->regex);

    free((void *)(list + (signed long int)i)->sval);
    free((void *)(list + (signed long int)i)->val);
    free((void *)(list + (signed long int)i)->oper);
    if(!((list + (signed long int)i)->nlist == ((struct anonymous$1 *)NULL)))
      do
      {
        signed int _CB_i;
        signed int _CB_end = (list + (signed long int)i)->nlist->start + (list + (signed long int)i)->nlist->num;
        _CB_i = (list + (signed long int)i)->nlist->start;
        for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
          free((void *)((list + (signed long int)i)->nlist->array + (signed long int)_CB_i)->dptr);
        free((void *)(list + (signed long int)i)->nlist->array);
        free((void *)(list + (signed long int)i)->nlist);
      }
      while((_Bool)0);

    free((void *)(list + (signed long int)i)->name);
  }
  free((void *)list);
}

// est_free_net_env
// file estnode.c line 110
void est_free_net_env(void)
{
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&est_host_addrs_mutex);
  if(return_value_pthread_mutex_lock$1 == 0)
  {
    if(!(est_host_attrs_cnt >= 1))
      pthread_mutex_unlock(&est_host_addrs_mutex);

    else
    {
      est_host_attrs_cnt = est_host_attrs_cnt - 1;
      if(!(est_host_attrs_cnt >= 1))
      {
        cbmapclose(est_host_addrs);
        est_host_addrs = (struct anonymous$9 *)(void *)0;
      }

      pthread_mutex_unlock(&est_host_addrs_mutex);
    }
  }

}

// est_get_client_sock
// file estnode.c line 1422
signed int est_get_client_sock(const char *addr, signed int port)
{
  struct sockaddr_in address;
  struct linger li;
  signed int ost;
  signed int sock;
  signed int return_value_pthread_setcancelstate$1;
  return_value_pthread_setcancelstate$1=pthread_setcancelstate(1, &ost);
  if(!(return_value_pthread_setcancelstate$1 == 0))
    return -1;

  else
  {
    memset((void *)&address, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    address.sin_family = (unsigned short int)2;
    signed int return_value_est_inet_aton$2;
    return_value_est_inet_aton$2=est_inet_aton(addr, &address.sin_addr);
    if(return_value_est_inet_aton$2 == 0)
    {
      pthread_setcancelstate(ost, (signed int *)(void *)0);
      return -1;
    }

    else
    {
      address.sin_port=htons((unsigned short int)port);
      sock=socket(2, 1, 6);
      if(sock == -1)
      {
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        return -1;
      }

      else
      {
        li.l_onoff = 1;
        li.l_linger = 100;
        signed int return_value_setsockopt$3;
        return_value_setsockopt$3=setsockopt(sock, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
        if(return_value_setsockopt$3 == -1)
        {
          est_sock_close(sock);
          pthread_setcancelstate(ost, (signed int *)(void *)0);
          return -1;
        }

        else
        {
          signed int return_value_connect$4;
          return_value_connect$4=connect(sock, (struct sockaddr *)&address, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
          if(return_value_connect$4 == -1)
          {
            est_sock_close(sock);
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return -1;
          }

          else
          {
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return sock;
          }
        }
      }
    }
  }
}

// est_get_host_addr
// file estnode.c line 1312
char * est_get_host_addr(const char *name)
{
  const char *addr;
  char *buf;
  char *pv;
  char vbuf[64l];
  signed int i;
  signed int ost;
  signed int nsiz;
  signed int asiz;
  signed int vsiz;
  signed int return_value_pthread_setcancelstate$1;
  return_value_pthread_setcancelstate$1=pthread_setcancelstate(1, &ost);
  _Bool tmp_if_expr$7;
  if(!(return_value_pthread_setcancelstate$1 == 0))
    return (char *)(void *)0;

  else
  {
    signed int return_value_pthread_mutex_lock$2;
    return_value_pthread_mutex_lock$2=pthread_mutex_lock(&est_host_addrs_mutex);
    if(!(return_value_pthread_mutex_lock$2 == 0))
    {
      pthread_setcancelstate(ost, (signed int *)(void *)0);
      return (char *)(void *)0;
    }

    else
      if(est_host_addrs == ((struct anonymous$9 *)NULL))
      {
        pthread_mutex_unlock(&est_host_addrs_mutex);
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        return (char *)(void *)0;
      }

      else
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(name);
        nsiz = (signed int)return_value_strlen$3;
        buf = (char *)(void *)0;
        addr=cbmapget(est_host_addrs, name, nsiz, &asiz);
        if(!(addr == ((const char *)NULL)))
        {
          buf=cbmemdup(addr, asiz);
          pv=strchr(buf, 9);
          if(!(pv == ((char *)NULL)))
          {
            *pv = (char)0;
            signed long int return_value_time$4;
            return_value_time$4=time((signed long int *)(void *)0);
            signed int return_value_atoi$5;
            return_value_atoi$5=atoi(pv + (signed long int)1);
            if((signed int)return_value_time$4 + -return_value_atoi$5 >= 301)
            {
              free((void *)buf);
              buf = (char *)(void *)0;
            }

          }

          cbmapmove(est_host_addrs, name, nsiz, 0);
        }

        pthread_mutex_unlock(&est_host_addrs_mutex);
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        if(!(buf == ((char *)NULL)))
        {
          if(!((signed int)*buf == 0))
            return buf;

          free((void *)buf);
          return (char *)(void *)0;
        }

        else
        {
          buf=est_gethostaddrbyname(name);
          signed int return_value_pthread_setcancelstate$10;
          return_value_pthread_setcancelstate$10=pthread_setcancelstate(1, &ost);
          if(return_value_pthread_setcancelstate$10 == 0)
          {
            signed int return_value_pthread_mutex_lock$9;
            return_value_pthread_mutex_lock$9=pthread_mutex_lock(&est_host_addrs_mutex);
            if(return_value_pthread_mutex_lock$9 == 0)
            {
              signed long int return_value_time$6;
              return_value_time$6=time((signed long int *)(void *)0);
              vsiz=sprintf(vbuf, "%s\t%d", buf != ((char *)NULL) ? buf : "", (signed int)return_value_time$6);
              cbmapput(est_host_addrs, name, nsiz, vbuf, vsiz, 1);
              signed int return_value_cbmaprnum$8;
              return_value_cbmaprnum$8=cbmaprnum(est_host_addrs);
              if(return_value_cbmaprnum$8 >= 4097)
              {
                cbmapiterinit(est_host_addrs);
                i = 0;
                do
                {
                  if(!(i >= 1024))
                  {
                    addr=cbmapiternext(est_host_addrs, &asiz);
                    tmp_if_expr$7 = addr != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$7 = (_Bool)0;
                  if(!tmp_if_expr$7)
                    break;

                  cbmapout(est_host_addrs, addr, asiz);
                  i = i + 1;
                }
                while((_Bool)1);
              }

              pthread_mutex_unlock(&est_host_addrs_mutex);
            }

            pthread_setcancelstate(ost, (signed int *)(void *)0);
          }

          return buf;
        }
      }
  }
}

// est_get_host_name
// file estnode.c line 1298
const char * est_get_host_name(void)
{
  if(est_host_addrs == ((struct anonymous$9 *)NULL))
    return "127.0.0.1";

  else
  {
    static char host[4096l];
    static signed int first = 1;
    if(!(first == 0))
    {
      first = 0;
      signed int return_value_gethostname$1;
      return_value_gethostname$1=gethostname(host, (unsigned long int)(4096 - 1));
      if(return_value_gethostname$1 == -1)
        return "127.0.0.1";

      return host;
    }

    return host;
  }
}

// est_get_server_sock
// file estnode.c line 1368
signed int est_get_server_sock(const char *addr, signed int port)
{
  struct sockaddr_in address;
  struct linger li;
  signed int ost;
  signed int sock;
  signed int optone;
  signed int return_value_pthread_setcancelstate$1;
  return_value_pthread_setcancelstate$1=pthread_setcancelstate(1, &ost);
  _Bool tmp_if_expr$5;
  signed int return_value_setsockopt$4;
  _Bool tmp_if_expr$8;
  signed int return_value_listen$7;
  if(!(return_value_pthread_setcancelstate$1 == 0))
    return -1;

  else
  {
    memset((void *)&address, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    address.sin_family = (unsigned short int)2;
    signed int return_value_est_inet_aton$2;
    return_value_est_inet_aton$2=est_inet_aton(addr != ((const char *)NULL) ? addr : "0.0.0.0", &address.sin_addr);
    if(return_value_est_inet_aton$2 == 0)
    {
      pthread_setcancelstate(ost, (signed int *)(void *)0);
      return -1;
    }

    else
    {
      address.sin_port=htons((unsigned short int)port);
      sock=socket(2, 1, 6);
      if(sock == -1)
      {
        pthread_setcancelstate(ost, (signed int *)(void *)0);
        return -1;
      }

      else
      {
        li.l_onoff = 1;
        li.l_linger = 100;
        optone = 1;
        signed int return_value_setsockopt$3;
        return_value_setsockopt$3=setsockopt(sock, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
        if(return_value_setsockopt$3 == -1)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_setsockopt$4=setsockopt(sock, 1, 2, (const void *)(char *)&optone, (unsigned int)sizeof(signed int) /*4ul*/ );
          tmp_if_expr$5 = return_value_setsockopt$4 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
        {
          est_sock_close(sock);
          pthread_setcancelstate(ost, (signed int *)(void *)0);
          return -1;
        }

        else
        {
          signed int return_value_bind$6;
          return_value_bind$6=bind(sock, (struct sockaddr *)&address, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
          if(return_value_bind$6 == -1)
            tmp_if_expr$8 = (_Bool)1;

          else
          {
            return_value_listen$7=listen(sock, 128);
            tmp_if_expr$8 = return_value_listen$7 == -1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$8)
          {
            est_sock_close(sock);
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return -1;
          }

          else
          {
            pthread_setcancelstate(ost, (signed int *)(void *)0);
            return sock;
          }
        }
      }
    }
  }
}

// est_get_tvmap
// file estraier.c line 10366
static struct anonymous$9 * est_get_tvmap(struct anonymous *db, signed int id, signed int vnum, signed int tfidf)
{
  struct anonymous$0 *doc;
  struct anonymous$9 *tvmap;
  tvmap=est_db_get_keywords(db, id);
  if(!(tvmap == ((struct anonymous$9 *)NULL)))
    return tvmap;

  else
  {
    doc=est_db_get_doc(db, id, 0);
    if(doc == ((struct anonymous$0 *)NULL))
      return (struct anonymous$9 *)(void *)0;

    else
    {
      tvmap=est_db_etch_doc(tfidf != 0 ? db : (struct anonymous *)(void *)0, doc, vnum);
      est_doc_delete(doc);
      signed int return_value_dpwritable$1;
      return_value_dpwritable$1=dpwritable(db->metadb);
      if(!(return_value_dpwritable$1 == 0))
        est_db_put_keywords(db, id, tvmap, 1.0);

      return tvmap;
    }
  }
}

// est_gethostaddrbyname
// file estnode.c line 1730
static char * est_gethostaddrbyname(const char *name)
{
  struct hostent infobuf;
  struct hostent *info;
  char buf[8192l];
  char *addr;
  signed int ecode;
  signed int return_value_gethostbyname_r$2;
  return_value_gethostbyname_r$2=gethostbyname_r(name, &infobuf, buf, (unsigned long int)8192, &info, &ecode);
  if(return_value_gethostbyname_r$2 == 0 && !(info == ((struct hostent *)NULL)))
  {
    char *return_value_inet_ntoa$1;
    return_value_inet_ntoa$1=inet_ntoa(*((struct in_addr *)info->h_addr_list[(signed long int)0]));
    addr=cbmemdup(return_value_inet_ntoa$1, -1);
  }

  else
    addr = (char *)(void *)0;
  return addr;
}

// est_gettimeofday
// file estraier.c line 5632
double est_gettimeofday(void)
{
  struct timeval tv;
  struct timezone tz;
  signed int return_value_gettimeofday$1;
  return_value_gettimeofday$1=gettimeofday(&tv, &tz);
  if(return_value_gettimeofday$1 == -1)
    return 0.0;

  else
    return (double)tv.tv_sec * (double)1000 + (double)tv.tv_usec / (double)1000;
}

// est_global_lock
// file estmtdb.c line 782
static signed int est_global_lock(void)
{
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&est_global_mutex);
  return (signed int)(return_value_pthread_mutex_lock$1 == 0);
}

// est_global_unlock
// file estmtdb.c line 788
static void est_global_unlock(void)
{
  pthread_mutex_unlock(&est_global_mutex);
}

// est_hex_decode
// file estraier.c line 5895
static char * est_hex_decode(const char *str)
{
  char *res;
  char *wp;
  signed int i;
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  len = (signed int)return_value_strlen$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(len + 1));
  res = (char *)return_value_malloc$2;
  if(!(res == ((char *)NULL)))
    res;

  else
    cbmyfatal("out of memory");
  wp = res;
  i = 0;
  char *tmp_post$3;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  for( ; !(i >= len); i = i + 2)
  {
    tmp_post$3 = wp;
    wp = wp + 1l;
    if((signed int)str[(signed long int)i] >= 65)
      tmp_if_expr$4 = ((signed int)str[(signed long int)i] - 65) + 10;

    else
      tmp_if_expr$4 = (signed int)str[(signed long int)i] - 48;
    if((signed int)str[(signed long int)(1 + i)] >= 65)
      tmp_if_expr$5 = ((signed int)str[(signed long int)(i + 1)] - 65) + 10;

    else
      tmp_if_expr$5 = (signed int)str[(signed long int)(i + 1)] - 48;
    *tmp_post$3 = (char)(tmp_if_expr$4 * 16 + tmp_if_expr$5);
  }
  *wp = (char)0;
  return res;
}

// est_hex_encode
// file estraier.c line 5878
static char * est_hex_encode(const char *str)
{
  char *res;
  char *wp;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(return_value_strlen$1 * (unsigned long int)2 + (unsigned long int)1);
  res = (char *)return_value_malloc$2;
  if(!(res == ((char *)NULL)))
    res;

  else
    cbmyfatal("out of memory");
  wp = res;
  while(!((signed int)*str == 0))
  {
    signed int return_value_sprintf$3;
    return_value_sprintf$3=sprintf(wp, "%02X", *((unsigned char *)str));
    wp = wp + (signed long int)return_value_sprintf$3;
    str = str + 1l;
  }
  *wp = (char)0;
  return res;
}

// est_hints_to_words
// file estraier.c line 5426
struct anonymous$1 * est_hints_to_words(struct anonymous$9 *hints)
{
  struct anonymous$1 *words;
  const char *kbuf;
  signed int ksiz;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    words = (struct anonymous$1 *)return_value_malloc$1;
    if(!(words == ((struct anonymous$1 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous$28 *)return_value_malloc$2;
    if(!(words->array == ((struct anonymous$28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  cbmapiterinit(hints);
  _Bool tmp_if_expr$5;
  const char *return_value_cbmapget$3;
  signed int return_value_atoi$4;
  do
  {
    kbuf=cbmapiternext(hints, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(!(ksiz >= 1))
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_cbmapget$3=cbmapget(hints, kbuf, ksiz, (signed int *)(void *)0);
      return_value_atoi$4=atoi(return_value_cbmapget$3);
      tmp_if_expr$5 = return_value_atoi$4 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$5)
      do
      {
        signed int _CB_index = words->start + words->num;
        if(_CB_index >= words->anum)
        {
          words->anum = words->anum * 2;
          void *return_value_realloc$6;
          return_value_realloc$6=realloc((void *)words->array, (unsigned long int)words->anum * sizeof(struct anonymous$28) /*16ul*/ );
          words->array = (struct anonymous$28 *)return_value_realloc$6;
          if(!(words->array == ((struct anonymous$28 *)NULL)))
            words->array;

          else
            cbmyfatal("out of memory");
        }

        void *return_value_malloc$7;
        return_value_malloc$7=malloc((unsigned long int)((ksiz < 12 ? 12 : ksiz) + 1));
        (words->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$7;
        if(!((words->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
          (words->array + (signed long int)_CB_index)->dptr;

        else
          cbmyfatal("out of memory");
        memcpy((void *)(words->array + (signed long int)_CB_index)->dptr, (const void *)kbuf, (unsigned long int)ksiz);
        (words->array + (signed long int)_CB_index)->dptr[(signed long int)ksiz] = (char)0;
        (words->array + (signed long int)_CB_index)->dsize = ksiz;
        words->num = words->num + 1;
      }
      while((_Bool)0);

  }
  while((_Bool)1);
  return words;
}

// est_iconv
// file estraier.h line 842
char * est_iconv(const char *ptr, signed int size, const char *icode, const char *ocode, signed int *sp, signed int *mp)
{
  void *ic;
  char *obuf;
  char *wp;
  char *rp;
  unsigned long int isiz;
  unsigned long int osiz;
  signed int miss;
  unsigned long int return_value_strlen$1;
  if(!(size >= 0))
  {
    return_value_strlen$1=strlen(ptr);
    size = (signed int)return_value_strlen$1;
  }

  _Bool tmp_if_expr$7;
  if((signed int)*icode == 120)
    tmp_if_expr$7 = (signed int)icode[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$7 = (_Bool)0;
  signed int return_value_cbstricmp$3;
  signed int return_value_cbstricmp$2;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$7)
  {
    signed int return_value_cbstricmp$4;
    return_value_cbstricmp$4=cbstricmp(icode, "x-sjis");
    if(return_value_cbstricmp$4 == 0)
      icode = "Shift_JIS";

    else
    {
      return_value_cbstricmp$3=cbstricmp(icode, "x-ujis");
      if(return_value_cbstricmp$3 == 0)
        icode = "EUC-JP";

      else
      {
        return_value_cbstricmp$2=cbstricmp(icode, "x-euc-jp");
        if(return_value_cbstricmp$2 == 0)
          icode = "EUC-JP";

      }
    }
  }

  else
  {
    if((signed int)*icode == 119)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed int)icode[(signed long int)0] == 87 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      signed int return_value_cbstricmp$5;
      return_value_cbstricmp$5=cbstricmp(icode, "windows-31j");
      if(return_value_cbstricmp$5 == 0)
        icode = "CP932";

    }

  }
  _Bool tmp_if_expr$13;
  if((signed int)*ocode == 120)
    tmp_if_expr$13 = (signed int)ocode[(signed long int)1] == 45 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$13 = (_Bool)0;
  signed int return_value_cbstricmp$9;
  signed int return_value_cbstricmp$8;
  _Bool tmp_if_expr$12;
  if(tmp_if_expr$13)
  {
    signed int return_value_cbstricmp$10;
    return_value_cbstricmp$10=cbstricmp(ocode, "x-sjis");
    if(return_value_cbstricmp$10 == 0)
      ocode = "Shift_JIS";

    else
    {
      return_value_cbstricmp$9=cbstricmp(ocode, "x-ujis");
      if(return_value_cbstricmp$9 == 0)
        ocode = "EUC-JP";

      else
      {
        return_value_cbstricmp$8=cbstricmp(ocode, "x-euc-jp");
        if(return_value_cbstricmp$8 == 0)
          ocode = "EUC-JP";

      }
    }
  }

  else
  {
    if((signed int)*ocode == 119)
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = (signed int)ocode[(signed long int)0] == 87 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
    {
      signed int return_value_cbstricmp$11;
      return_value_cbstricmp$11=cbstricmp(ocode, "windows-31j");
      if(return_value_cbstricmp$11 == 0)
        ocode = "CP932";

    }

  }
  ic=iconv_open(ocode, icode);
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$19;
  signed int *return_value___errno_location$15;
  _Bool tmp_if_expr$17;
  signed int *return_value___errno_location$16;
  if(ic == (void *)-1)
    return (char *)(void *)0;

  else
  {
    isiz = (unsigned long int)size;
    osiz = isiz * (unsigned long int)5;
    void *return_value_malloc$14;
    return_value_malloc$14=malloc(osiz + (unsigned long int)1);
    obuf = (char *)return_value_malloc$14;
    if(!(obuf == ((char *)NULL)))
      obuf;

    else
      cbmyfatal("out of memory");
    wp = obuf;
    rp = (char *)ptr;
    miss = 0;
    while(isiz >= 1ul)
    {
      unsigned long int return_value_iconv$21;
      return_value_iconv$21=iconv(ic, (char ** restrict )(void *)&rp, &isiz, &wp, &osiz);
      if(return_value_iconv$21 == 18446744073709551615ul)
      {
        signed int *return_value___errno_location$18;
        return_value___errno_location$18=__errno_location();
        if(*return_value___errno_location$18 == 84)
        {
          if((signed int)*rp == 0x5c)
            tmp_if_expr$19 = (_Bool)1;

          else
            tmp_if_expr$19 = (signed int)*rp == 0x7e ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$20 = tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$20 = (_Bool)0;
        if(tmp_if_expr$20)
        {
          *wp = *rp;
          wp = wp + 1l;
          rp = rp + 1l;
          isiz = isiz - 1ul;
        }

        else
        {
          return_value___errno_location$15=__errno_location();
          if(*return_value___errno_location$15 == 84)
            tmp_if_expr$17 = (_Bool)1;

          else
          {
            return_value___errno_location$16=__errno_location();
            tmp_if_expr$17 = *return_value___errno_location$16 == 22 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$17)
          {
            rp = rp + 1l;
            isiz = isiz - 1ul;
            miss = miss + 1;
          }

          else
            break;
        }
      }

    }
    *wp = (char)0;
    if(!(sp == ((signed int *)NULL)))
      *sp = (signed int)(wp - obuf);

    if(!(mp == ((signed int *)NULL)))
      *mp = miss;

    signed int return_value_iconv_close$22;
    return_value_iconv_close$22=iconv_close(ic);
    if(return_value_iconv_close$22 == -1)
    {
      free((void *)obuf);
      return (char *)(void *)0;
    }

    else
      return obuf;
  }
}

// est_idx_add
// file estraier.c line 7107
static signed int est_idx_add(struct anonymous$3 *idx, const char *word, signed int wsiz, const char *vbuf, signed int vsiz, signed int smode)
{
  struct anonymous$2 *datum;
  const char *obuf;
  signed int rv;
  signed int lid;
  signed int osiz;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$1;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  lid = 0;
  obuf=vlgetcache(idx->cdb, word, wsiz, &osiz);
  if(!(obuf == ((const char *)NULL)))
    lid=est_idx_rec_last_id(obuf, osiz, smode);

  est_encode_idx_rec(datum, vbuf, vsiz, lid, smode);
  rv=vlput(idx->cdb, word, wsiz, (const char *)datum->dptr, (signed int)datum->dsize, 2);
  do
  {
    free((void *)datum->dptr);
    free((void *)datum);
  }
  while((_Bool)0);
  return rv;
}

// est_idx_close
// file estraier.c line 7034
static signed int est_idx_close(struct anonymous$3 *idx)
{
  signed int i;
  signed int err = 0;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlclose$1;
    return_value_vlclose$1=vlclose(idx->dbs[(signed long int)i]);
    if(return_value_vlclose$1 == 0)
      err = 1;

  }
  free((void *)idx->name);
  free((void *)idx);
  return err != 0 ? 0 : 1;
}

// est_idx_dnum
// file estraier.c line 7094
static signed int est_idx_dnum(struct anonymous$3 *idx)
{
  return idx->dnum;
}

// est_idx_get_one
// file estraier.c line 7189
static const char * est_idx_get_one(struct anonymous$3 *idx, signed int inum, const char *word, signed int wsiz, signed int *sp)
{
  const char *return_value_vlgetcache$1;
  return_value_vlgetcache$1=vlgetcache(idx->dbs[(signed long int)inum], word, wsiz, sp);
  return return_value_vlgetcache$1;
}

// est_idx_increment
// file estraier.c line 7068
static void est_idx_increment(struct anonymous$3 *idx)
{
  char path[4096l];
  signed int i;
  signed int min;
  signed int size;
  signed int crdnum;
  min = 0x7fffffff;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    size=vlfsiz(idx->cdb);
    if(!(size >= min))
      min = size;

  }
  _Bool tmp_if_expr$1;
  if(idx->dnum >= 256)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (idx->dnum >= 16 ? (min < 1048576 * 1536 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    est_idx_set_current(idx);

  else
  {
    sprintf(path, "%s%c%04d", idx->name, 47, idx->dnum + 1);
    signed int *return_value_vlcrdnumptr$2;
    return_value_vlcrdnumptr$2=vlcrdnumptr();
    crdnum = *return_value_vlcrdnumptr$2;
    signed int *return_value_vlcrdnumptr$3;
    return_value_vlcrdnumptr$3=vlcrdnumptr();
    *return_value_vlcrdnumptr$3 = 2;
    idx->dbs[(signed long int)idx->dnum]=vlopen(path, idx->omode | 4 | 8, VL_CMPLEX);
    if(!(idx->dbs[(signed long int)idx->dnum] == ((struct anonymous$7 *)NULL)))
    {
      idx->cdb = idx->dbs[(signed long int)idx->dnum];
      idx->dnum = idx->dnum + 1;
    }

    signed int *return_value_vlcrdnumptr$4;
    return_value_vlcrdnumptr$4=vlcrdnumptr();
    *return_value_vlcrdnumptr$4 = crdnum;
  }
}

// est_idx_memflush
// file estraier.c line 7249
static signed int est_idx_memflush(struct anonymous$3 *idx)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlmemflush$1;
    return_value_vlmemflush$1=vlmemflush(idx->dbs[(signed long int)i]);
    if(return_value_vlmemflush$1 == 0)
      return 0;

  }
  return 1;
}

// est_idx_num
// file estraier.c line 7216
static signed int est_idx_num(struct anonymous$3 *idx)
{
  return idx->dnum;
}

// est_idx_open
// file estraier.c line 6991
static struct anonymous$3 * est_idx_open(const char *name, signed int omode, signed int dnum)
{
  struct anonymous$3 *idx;
  struct anonymous$1 *files;
  const char *file;
  char path[4096l];
  signed int i;
  signed int crdnum;
  if(dnum >= 257)
    dnum = 256;

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$3) /*2080ul*/ );
  idx = (struct anonymous$3 *)return_value_malloc$1;
  if(!(idx == ((struct anonymous$3 *)NULL)))
    idx;

  else
    cbmyfatal("out of memory");
  signed int return_value_est_mkdir$3;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$6;
  signed int return_value_strcmp$5;
  if(!((4 & omode) == 0))
  {
    return_value_est_mkdir$3=est_mkdir(name);
    if(!(return_value_est_mkdir$3 == 0))
      goto __CPROVER_DUMP_L4;

    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 17)
      goto __CPROVER_DUMP_L4;

    return (struct anonymous$3 *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(!((8 & omode) == 0))
    {
      files=cbdirlist(name);
      if(!(files == ((struct anonymous$1 *)NULL)))
      {
        i = 0;
        for( ; !(i >= files->num); i = i + 1)
        {
          file = (const char *)(files->array + (signed long int)(files->start + i))->dptr;
          signed int return_value_strcmp$4;
          return_value_strcmp$4=strcmp(file, ".");
          if(return_value_strcmp$4 == 0)
            tmp_if_expr$6 = (_Bool)1;

          else
          {
            return_value_strcmp$5=strcmp(file, "..");
            tmp_if_expr$6 = !(return_value_strcmp$5 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$6)
          {
            sprintf(path, "%s%c%s", name, 47, file);
            signed int return_value_unlink$7;
            return_value_unlink$7=unlink(path);
            if(return_value_unlink$7 == -1)
              est_rmdir_rec(path);

          }

        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = files->start + files->num;
          _CB_i = files->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(files->array + (signed long int)_CB_i)->dptr);
          free((void *)files->array);
          free((void *)files);
        }
        while((_Bool)0);
      }

    }

    i = 0;
    for( ; !(i >= dnum); i = i + 1)
    {
      sprintf(path, "%s%c%04d", name, 47, i + 1);
      signed int *return_value_vlcrdnumptr$8;
      return_value_vlcrdnumptr$8=vlcrdnumptr();
      crdnum = *return_value_vlcrdnumptr$8;
      signed int *return_value_vlcrdnumptr$9;
      return_value_vlcrdnumptr$9=vlcrdnumptr();
      *return_value_vlcrdnumptr$9 = 2;
      idx->dbs[(signed long int)i]=vlopen(path, omode, VL_CMPLEX);
      if(idx->dbs[(signed long int)i] == ((struct anonymous$7 *)NULL))
      {
        do
        {
          i = i - 1;
          if(!(i >= 0))
            break;

          vlclose(idx->dbs[(signed long int)i]);
        }
        while((_Bool)1);
        signed int *return_value_vlcrdnumptr$10;
        return_value_vlcrdnumptr$10=vlcrdnumptr();
        *return_value_vlcrdnumptr$10 = crdnum;
        return (struct anonymous$3 *)(void *)0;
      }

      signed int *return_value_vlcrdnumptr$11;
      return_value_vlcrdnumptr$11=vlcrdnumptr();
      *return_value_vlcrdnumptr$11 = crdnum;
    }
    idx->name=cbmemdup(name, -1);
    idx->omode = omode;
    idx->dnum = dnum;
    idx->cdb = idx->dbs[(signed long int)(dnum - 1)];
    return idx;
  }
}

// est_idx_optimize
// file estraier.c line 7275
static signed int est_idx_optimize(struct anonymous$3 *idx)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vloptimize$1;
    return_value_vloptimize$1=vloptimize(idx->dbs[(signed long int)i]);
    if(return_value_vloptimize$1 == 0)
      return 0;

  }
  return 1;
}

// est_idx_out
// file estraier.c line 7145
static signed int est_idx_out(struct anonymous$3 *idx, const char *word, signed int wsiz)
{
  signed int i;
  signed int err = 0;
  i = 0;
  signed int *return_value_dpecodeptr$1;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlout$2;
    return_value_vlout$2=vlout(idx->dbs[(signed long int)i], word, wsiz);
    if(return_value_vlout$2 == 0)
    {
      return_value_dpecodeptr$1=dpecodeptr();
      if(!(*return_value_dpecodeptr$1 == 5))
        err = 1;

    }

  }
  return err != 0 ? 0 : 1;
}

// est_idx_put_one
// file estraier.c line 7131
static signed int est_idx_put_one(struct anonymous$3 *idx, signed int inum, const char *word, signed int wsiz, const char *vbuf, signed int vsiz)
{
  signed int tmp_if_expr$5;
  signed int return_value_vlput$1;
  signed int return_value_vlout$2;
  _Bool tmp_if_expr$4;
  signed int *return_value_dpecodeptr$3;
  if(vsiz >= 1)
  {
    return_value_vlput$1=vlput(idx->dbs[(signed long int)inum], word, wsiz, vbuf, vsiz, 0);
    tmp_if_expr$5 = return_value_vlput$1;
  }

  else
  {
    return_value_vlout$2=vlout(idx->dbs[(signed long int)inum], word, wsiz);
    if(!(return_value_vlout$2 == 0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_dpecodeptr$3=dpecodeptr();
      tmp_if_expr$4 = *return_value_dpecodeptr$3 == 5 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr$5 = (signed int)tmp_if_expr$4;
  }
  return tmp_if_expr$5;
}

// est_idx_rec_last_id
// file estraier.c line 6874
static signed int est_idx_rec_last_id(const char *vbuf, signed int vsiz, signed int smode)
{
  const char *rp;
  const char *ep;
  const char *sp;
  signed int cid;
  signed int vnum;
  signed int vstep;
  cid = 0;
  rp = vbuf;
  ep = vbuf + (signed long int)vsiz;
  for( ; !(rp >= ep); rp = rp + 1l)
  {
    do
    {
      signed int _EST_i;
      signed int _EST_base;
      vnum = 0;
      _EST_base = 1;
      _EST_i = 0;
      for( ; (_Bool)1; _EST_i = _EST_i + 1)
      {
        if((signed int)rp[(signed long int)_EST_i] >= 0)
        {
          vnum = vnum + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
          break;
        }

        vnum = vnum + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
        _EST_base = _EST_base * 128;
      }
      vstep = _EST_i + 1;
    }
    while((_Bool)0);
    cid = cid + vnum + 1;
    rp = rp + (signed long int)vstep;
    sp = rp;
    if(!(smode == 1048576))
    {
      if(smode == 2097152 || smode == 4194304)
        goto __CPROVER_DUMP_L8;

    }

    else
      goto __CPROVER_DUMP_L9;
    rp = rp + 1l;
    goto __CPROVER_DUMP_L9;

  __CPROVER_DUMP_L8:
    ;
    rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

  __CPROVER_DUMP_L9:
    ;
    for( ; !((signed int)*rp == 0x00); rp = rp + (signed long int)2)
      ;
  }
  return cid;
}

// est_idx_scan
// file estraier.c line 7165
static char * est_idx_scan(struct anonymous$3 *idx, const char *word, signed int wsiz, signed int *sp, signed int smode)
{
  struct anonymous$2 *datum;
  const char *vbuf;
  signed int i;
  signed int vsiz;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$1;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    vbuf=vlgetcache(idx->dbs[(signed long int)i], word, wsiz, &vsiz);
    if(!(vbuf == ((const char *)NULL)))
      est_decode_idx_rec(datum, vbuf, vsiz, smode);

  }
  char *return_value_cbdatumtomalloc$3;
  return_value_cbdatumtomalloc$3=cbdatumtomalloc(datum, sp);
  return return_value_cbdatumtomalloc$3;
}

// est_idx_set_current
// file estraier.c line 7287
static void est_idx_set_current(struct anonymous$3 *idx)
{
  signed int i;
  signed int size;
  signed int min;
  min=vlfsiz(idx->cdb);
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    size=vlfsiz(idx->dbs[(signed long int)i]);
    if(!(size >= min))
    {
      idx->cdb = idx->dbs[(signed long int)i];
      min = size;
    }

  }
}

// est_idx_set_tuning
// file estraier.c line 7055
static void est_idx_set_tuning(struct anonymous$3 *idx, signed int lrecmax, signed int nidxmax, signed int lcnum, signed int ncnum, signed int fbpsiz)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    vlsettuning(idx->dbs[(signed long int)i], lrecmax, nidxmax, lcnum, ncnum);
    if(fbpsiz >= 1)
      vlsetfbpsiz(idx->dbs[(signed long int)i], fbpsiz);

  }
}

// est_idx_size
// file estraier.c line 7225
static double est_idx_size(struct anonymous$3 *idx)
{
  signed int i;
  double size = (double)0;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlfsiz$1;
    return_value_vlfsiz$1=vlfsiz(idx->dbs[(signed long int)i]);
    size = size + (double)return_value_vlfsiz$1;
  }
  return size;
}

// est_idx_size_current
// file estraier.c line 7240
static signed int est_idx_size_current(struct anonymous$3 *idx)
{
  signed int return_value_vlfsiz$1;
  return_value_vlfsiz$1=vlfsiz(idx->cdb);
  return return_value_vlfsiz$1;
}

// est_idx_sync
// file estraier.c line 7262
static signed int est_idx_sync(struct anonymous$3 *idx)
{
  signed int i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    signed int return_value_vlsync$1;
    return_value_vlsync$1=vlsync(idx->dbs[(signed long int)i]);
    if(return_value_vlsync$1 == 0)
      return 0;

  }
  return 1;
}

// est_idx_vsiz
// file estraier.c line 7201
static signed int est_idx_vsiz(struct anonymous$3 *idx, const char *word, signed int wsiz)
{
  signed int i;
  signed int sum;
  signed int vsiz;
  sum = 0;
  i = 0;
  for( ; !(i >= idx->dnum); i = i + 1)
  {
    vsiz=vlvsiz(idx->dbs[(signed long int)i], word, wsiz);
    if(vsiz >= 1)
      sum = sum + vsiz;

  }
  return sum;
}

// est_inet_aton
// file estnode.c line 1782
static signed int est_inet_aton(const char *cp, struct in_addr *inp)
{
  signed int return_value_inet_aton$1;
  return_value_inet_aton$1=inet_aton(cp, inp);
  return return_value_inet_aton$1;
}

// est_inflate
// file estraier.c line 3819
char * est_inflate(const char *ptr, signed int size, signed int *sp, signed int mode)
{
  struct z_stream_s zs;
  char *buf;
  unsigned char obuf[8192l];
  signed int rv;
  signed int asiz;
  signed int bsiz;
  signed int osiz;
  zs.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
  zs.zfree = ((void (*)(void *, void *))NULL);
  zs.opaque = NULL;
  signed int return_value_inflateInit2_$1;
  signed int return_value_inflateInit2_$2;
  if(!(mode == -1))
  {
    if(mode == 1)
      goto __CPROVER_DUMP_L3;

  }

  else
  {
    return_value_inflateInit2_$1=inflateInit2_(&zs, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_inflateInit2_$1 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L3:
    ;
    return_value_inflateInit2_$2=inflateInit2_(&zs, 15 + 16, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    if(!(return_value_inflateInit2_$2 == 0))
      return (char *)(void *)0;

    goto __CPROVER_DUMP_L7;
  }
  signed int return_value_inflateInit2_$3;
  return_value_inflateInit2_$3=inflateInit2_(&zs, 15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  if(!(return_value_inflateInit2_$3 == 0))
    return (char *)(void *)0;

  else
  {
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L7:
    ;
    asiz = size * 2 + 16;
    if(!(asiz >= 8192))
      asiz = 8192;

    void *return_value_malloc$4;
    return_value_malloc$4=malloc((unsigned long int)asiz);
    buf = (char *)return_value_malloc$4;
    if(!(buf == ((char *)NULL)))
      buf;

    else
      cbmyfatal("out of memory");
    bsiz = 0;
    zs.next_in = (unsigned char *)ptr;
    zs.avail_in = (unsigned int)size;
    zs.next_out = obuf;
    zs.avail_out = (unsigned int)8192;
    do
    {
      rv=inflate(&zs, 0);
      if(!(rv == 0))
        break;

      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(bsiz + osiz >= asiz)
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc$5;
        return_value_realloc$5=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc$5;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      zs.next_out = obuf;
      zs.avail_out = (unsigned int)8192;
    }
    while((_Bool)1);
    if(!(rv == 1))
    {
      free((void *)buf);
      inflateEnd(&zs);
      return (char *)(void *)0;
    }

    else
    {
      osiz = (signed int)((unsigned int)8192 - zs.avail_out);
      if(bsiz + osiz >= asiz)
      {
        asiz = asiz * 2 + osiz;
        void *return_value_realloc$6;
        return_value_realloc$6=realloc((void *)buf, (unsigned long int)asiz);
        buf = (char *)return_value_realloc$6;
        if(!(buf == ((char *)NULL)))
          buf;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(buf + (signed long int)bsiz), (const void *)obuf, (unsigned long int)osiz);
      bsiz = bsiz + osiz;
      buf[(signed long int)bsiz] = (char)0;
      if(!(sp == ((signed int *)NULL)))
        *sp = bsiz;

      inflateEnd(&zs);
      return buf;
    }
  }
}

// est_init_net_env
// file estnode.c line 87
signed int est_init_net_env(void)
{
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&est_host_addrs_mutex);
  if(!(return_value_pthread_mutex_lock$1 == 0))
    return 0;

  else
  {
    if(!(est_host_attrs_cnt >= 1))
      est_host_addrs=cbmapopenex(4096 + 1);

    est_host_attrs_cnt = est_host_attrs_cnt + 1;
    pthread_mutex_unlock(&est_host_addrs_mutex);
    return 1;
  }
}

// est_inode
// file estraier.c line 5595
signed int est_inode(const char *path)
{
  struct stat sbuf;
  signed int return_value_stat$1;
  return_value_stat$1=stat(path, &sbuf);
  if(return_value_stat$1 == -1)
    return -1;

  else
    return (signed int)(sbuf.st_ino & (unsigned long int)0x7fffffff);
}

// est_inodes_delete
// file estraier.c line 7727
static void est_inodes_delete(void *arg)
{
  struct anonymous *db;
  const char *kbuf;
  signed int ecode;
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(est_inodes);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(est_inodes);
    do
    {
      kbuf=cbmapiternext(est_inodes, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      db = *((struct anonymous **)return_value_cbmapiterval$1);
      est_db_set_informer(db, est_inodes_delete_informer, (void *)0);
      est_db_close(db, &ecode);
    }
    while((_Bool)1);
  }

  cbmapclose(est_inodes);
}

// est_inodes_delete_informer
// file estraier.c line 7764
static void est_inodes_delete_informer(const char *msg, void *opaque)
{
  ;
}

// est_int_compare
// file estraier.c line 7708
static signed int est_int_compare(const void *ap, const void *bp)
{
  return *((signed int *)ap) - *((signed int *)bp);
}

// est_keysc_compare
// file estraier.c line 10203
static signed int est_keysc_compare(const void *ap, const void *bp)
{
  return ((struct anonymous$31 *)bp)->pt - ((struct anonymous$31 *)ap)->pt;
}

// est_kill
// file estraier.c line 5715
signed int est_kill(signed int pid, signed int sig)
{
  signed int return_value_kill$1;
  return_value_kill$1=kill(pid, sig);
  return (signed int)(return_value_kill$1 == 0);
}

// est_lzodecode
// file estraier.c line 3905
char * est_lzodecode(const char *ptr, signed int size, signed int *sp)
{
  if(!(sp == ((signed int *)NULL)))
    *sp = size;

  char *return_value_cbmemdup$1;
  return_value_cbmemdup$1=cbmemdup(ptr, size);
  return return_value_cbmemdup$1;
}

// est_lzoencode
// file estraier.c line 3882
char * est_lzoencode(const char *ptr, signed int size, signed int *sp)
{
  unsigned long int return_value_strlen$1;
  if(!(size >= 0))
  {
    return_value_strlen$1=strlen(ptr);
    size = (signed int)return_value_strlen$1;
  }

  *sp = size;
  char *return_value_cbmemdup$2;
  return_value_cbmemdup$2=cbmemdup(ptr, size);
  return return_value_cbmemdup$2;
}

// est_make_cattr_list
// file estraier.c line 9703
static struct anonymous$11 * est_make_cattr_list(const struct anonymous$1 *attrs, signed int *nump)
{
  struct anonymous$11 *list;
  const char *rp;
  const char *pv;
  unsigned char *utmp;
  signed int i;
  signed int anum;
  signed int tsiz;
  anum = (signed int)attrs->num;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$11) /*96ul*/  * (unsigned long int)anum + (unsigned long int)1);
  list = (struct anonymous$11 *)return_value_malloc$1;
  if(!(list == ((struct anonymous$11 *)NULL)))
    list;

  else
    cbmyfatal("out of memory");
  i = 0;
  for( ; !(i >= anum); i = i + 1)
  {
    (list + (signed long int)i)->name = (char *)(void *)0;
    (list + (signed long int)i)->oper = (char *)(void *)0;
    (list + (signed long int)i)->val = (char *)(void *)0;
    rp = (const char *)(attrs->array + (signed long int)(attrs->start + i))->dptr;
    for( ; (signed int)*rp >= 1; rp = rp + 1l)
      if((signed int)*rp >= 33)
        break;

    pv=strchr(rp, 32);
    if(!(pv == ((const char *)NULL)))
    {
      (list + (signed long int)i)->nsiz = (signed int)(pv - rp);
      (list + (signed long int)i)->name=cbmemdup(rp, (list + (signed long int)i)->nsiz);
      rp = pv;
      for( ; (signed int)*rp >= 1; rp = rp + 1l)
        if((signed int)*rp >= 33)
          break;

      pv=strchr(rp, 32);
      if(!(pv == ((const char *)NULL)))
      {
        (list + (signed long int)i)->oper=cbmemdup(rp, (signed int)(pv - rp));
        rp = pv;
        for( ; (signed int)*rp >= 1; rp = rp + 1l)
          if((signed int)*rp >= 33)
            break;

        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(rp);
        (list + (signed long int)i)->vsiz = (signed int)return_value_strlen$2;
        (list + (signed long int)i)->val=cbmemdup(rp, (list + (signed long int)i)->vsiz);
      }

      else
        (list + (signed long int)i)->oper=cbmemdup(rp, -1);
    }

    else
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(rp);
      (list + (signed long int)i)->nsiz = (signed int)return_value_strlen$3;
      (list + (signed long int)i)->name=cbmemdup(rp, (list + (signed long int)i)->nsiz);
    }
    char *return_value_strchr$4;
    return_value_strchr$4=strchr((list + (signed long int)i)->name, 44);
    if(!(return_value_strchr$4 == ((char *)NULL)))
      (list + (signed long int)i)->nlist=cbsplit((list + (signed long int)i)->name, (list + (signed long int)i)->nsiz, ",");

    else
      (list + (signed long int)i)->nlist = (struct anonymous$1 *)(void *)0;
    if((list + (signed long int)i)->oper == ((char *)NULL))
      (list + (signed long int)i)->oper=cbmemdup("", 0);

    if((list + (signed long int)i)->val == ((char *)NULL))
    {
      (list + (signed long int)i)->vsiz = 0;
      (list + (signed long int)i)->val=cbmemdup("", 0);
    }

  }
  i = 0;
  _Bool tmp_if_expr$8;
  signed int return_value_cbstricmp$26;
  signed int return_value_cbstricmp$25;
  signed int return_value_cbstricmp$24;
  signed int return_value_cbstricmp$23;
  signed int return_value_cbstricmp$22;
  signed int return_value_cbstricmp$21;
  signed int return_value_cbstricmp$20;
  signed int return_value_cbstricmp$19;
  void *tmp_if_expr$11;
  void *return_value_est_regex_new$9;
  void *return_value_est_regex_new$10;
  signed int return_value_cbstricmp$18;
  signed int return_value_cbstricmp$17;
  signed int return_value_cbstricmp$16;
  signed int return_value_cbstricmp$15;
  signed int return_value_cbstricmp$14;
  signed int return_value_cbstricmp$13;
  signed int return_value_cbstricmp$12;
  for( ; !(i >= anum); i = i + 1)
  {
    rp = (list + (signed long int)i)->oper;
    if((signed int)*rp == 33)
    {
      (list + (signed long int)i)->sign = 0;
      rp = rp + 1l;
    }

    else
      (list + (signed long int)i)->sign = 1;
    if((signed int)*rp == 73)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = (signed int)*rp == 105 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
    {
      signed int return_value_est_check_cjk_only$7;
      return_value_est_check_cjk_only$7=est_check_cjk_only((list + (signed long int)i)->val);
      if(!(return_value_est_check_cjk_only$7 == 0))
      {
        (list + (signed long int)i)->sval = (char *)(void *)0;
        (list + (signed long int)i)->ssiz = 0;
      }

      else
      {
        char *return_value_est_uconv_in$5;
        return_value_est_uconv_in$5=est_uconv_in((list + (signed long int)i)->val, (list + (signed long int)i)->vsiz, &tsiz);
        utmp = (unsigned char *)return_value_est_uconv_in$5;
        est_normalize_text(utmp, tsiz, &tsiz);
        est_canonicalize_text(utmp, tsiz, 0);
        char *return_value_est_uconv_out$6;
        return_value_est_uconv_out$6=est_uconv_out((char *)utmp, tsiz, &(list + (signed long int)i)->ssiz);
        (list + (signed long int)i)->sval = (char *)return_value_est_uconv_out$6;
        free((void *)utmp);
      }
      rp = rp + 1l;
    }

    else
    {
      (list + (signed long int)i)->sval = (char *)(void *)0;
      (list + (signed long int)i)->ssiz = 0;
    }
    (list + (signed long int)i)->regex = (void *)0;
    (list + (signed long int)i)->num=cbstrmktime((list + (signed long int)i)->val);
    signed int return_value_cbstricmp$27;
    return_value_cbstricmp$27=cbstricmp(rp, "STREQ");
    if(return_value_cbstricmp$27 == 0)
      (list + (signed long int)i)->cop = "STREQ";

    else
    {
      return_value_cbstricmp$26=cbstricmp(rp, "STRNE");
      if(return_value_cbstricmp$26 == 0)
        (list + (signed long int)i)->cop = "STRNE";

      else
      {
        return_value_cbstricmp$25=cbstricmp(rp, "STRINC");
        if(return_value_cbstricmp$25 == 0)
          (list + (signed long int)i)->cop = "STRINC";

        else
        {
          return_value_cbstricmp$24=cbstricmp(rp, "STRBW");
          if(return_value_cbstricmp$24 == 0)
            (list + (signed long int)i)->cop = "STRBW";

          else
          {
            return_value_cbstricmp$23=cbstricmp(rp, "STREW");
            if(return_value_cbstricmp$23 == 0)
              (list + (signed long int)i)->cop = "STREW";

            else
            {
              return_value_cbstricmp$22=cbstricmp(rp, "STRAND");
              if(return_value_cbstricmp$22 == 0)
                (list + (signed long int)i)->cop = "STRAND";

              else
              {
                return_value_cbstricmp$21=cbstricmp(rp, "STROR");
                if(return_value_cbstricmp$21 == 0)
                  (list + (signed long int)i)->cop = "STROR";

                else
                {
                  return_value_cbstricmp$20=cbstricmp(rp, "STROREQ");
                  if(return_value_cbstricmp$20 == 0)
                    (list + (signed long int)i)->cop = "STROREQ";

                  else
                  {
                    return_value_cbstricmp$19=cbstricmp(rp, "STRRX");
                    if(return_value_cbstricmp$19 == 0)
                    {
                      (list + (signed long int)i)->cop = "STRRX";
                      if(!((list + (signed long int)i)->sval == ((char *)NULL)))
                      {
                        return_value_est_regex_new$9=est_regex_new((list + (signed long int)i)->sval);
                        tmp_if_expr$11 = return_value_est_regex_new$9;
                      }

                      else
                      {
                        return_value_est_regex_new$10=est_regex_new((list + (signed long int)i)->val);
                        tmp_if_expr$11 = return_value_est_regex_new$10;
                      }
                      (list + (signed long int)i)->regex = tmp_if_expr$11;
                    }

                    else
                    {
                      return_value_cbstricmp$18=cbstricmp(rp, "NUMEQ");
                      if(return_value_cbstricmp$18 == 0)
                        (list + (signed long int)i)->cop = "NUMEQ";

                      else
                      {
                        return_value_cbstricmp$17=cbstricmp(rp, "NUMNE");
                        if(return_value_cbstricmp$17 == 0)
                          (list + (signed long int)i)->cop = "NUMNE";

                        else
                        {
                          return_value_cbstricmp$16=cbstricmp(rp, "NUMGT");
                          if(return_value_cbstricmp$16 == 0)
                            (list + (signed long int)i)->cop = "NUMGT";

                          else
                          {
                            return_value_cbstricmp$15=cbstricmp(rp, "NUMGE");
                            if(return_value_cbstricmp$15 == 0)
                              (list + (signed long int)i)->cop = "NUMGE";

                            else
                            {
                              return_value_cbstricmp$14=cbstricmp(rp, "NUMLT");
                              if(return_value_cbstricmp$14 == 0)
                                (list + (signed long int)i)->cop = "NUMLT";

                              else
                              {
                                return_value_cbstricmp$13=cbstricmp(rp, "NUMLE");
                                if(return_value_cbstricmp$13 == 0)
                                  (list + (signed long int)i)->cop = "NUMLE";

                                else
                                {
                                  return_value_cbstricmp$12=cbstricmp(rp, "NUMBT");
                                  if(return_value_cbstricmp$12 == 0)
                                    (list + (signed long int)i)->cop = "NUMBT";

                                  else
                                  {
                                    (list + (signed long int)i)->cop = "STRINC";
                                    (list + (signed long int)i)->val[(signed long int)0] = (char)0;
                                    (list + (signed long int)i)->vsiz = 0;
                                    if(!((list + (signed long int)i)->sval == ((char *)NULL)))
                                    {
                                      (list + (signed long int)i)->sval[(signed long int)0] = (char)0;
                                      (list + (signed long int)i)->ssiz = 0;
                                    }

                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  *nump = anum;
  return list;
}

// est_make_crypt
// file estraier.c line 4088
char * est_make_crypt(const char *key)
{
  struct md5_state_s ms;
  char digest[32l];
  char str[64l];
  char *wp;
  signed int i;
  md5_init(&ms);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(key);
  md5_append(&ms, (unsigned char *)key, (signed int)return_value_strlen$1);
  md5_finish(&ms, (unsigned char *)digest);
  wp = str;
  i = 0;
  for( ; !(i >= 16); i = i + 1)
  {
    signed int return_value_sprintf$2;
    return_value_sprintf$2=sprintf(wp, "%02x", ((unsigned char *)digest)[(signed long int)i]);
    wp = wp + (signed long int)return_value_sprintf$2;
  }
  char *return_value_cbmemdup$3;
  return_value_cbmemdup$3=cbmemdup(str, -1);
  return return_value_cbmemdup$3;
}

// est_make_snippet
// file estraier.c line 6438
static char * est_make_snippet(const char *str, signed int len, const struct anonymous$1 *words, signed int wwidth, signed int hwidth, signed int awidth)
{
  struct anonymous$2 *res;
  struct anonymous$9 *counts;
  struct anonymous$1 *rwords;
  const char *word;
  const char *cval;
  const unsigned char *rword;
  unsigned char *rtext;
  unsigned char *ctext;
  signed int i;
  signed int j;
  signed int k;
  signed int bi;
  signed int size;
  signed int wsiz;
  signed int rwsiz;
  signed int mywidth;
  signed int awsiz;
  signed int csiz;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    res = (struct anonymous$2 *)return_value_malloc$1;
    if(!(res == ((struct anonymous$2 *)NULL)))
      res;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    res->dptr = (char *)return_value_malloc$2;
    if(!(res->dptr == ((char *)NULL)))
      res->dptr;

    else
      cbmyfatal("out of memory");
    res->dptr[(signed long int)0] = (char)0;
    res->dsize = 0;
    res->asize = 12;
  }
  while((_Bool)0);
  do
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    rwords = (struct anonymous$1 *)return_value_malloc$3;
    if(!(rwords == ((struct anonymous$1 *)NULL)))
      rwords;

    else
      cbmyfatal("out of memory");
    rwords->anum = 64;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)rwords->anum);
    rwords->array = (struct anonymous$28 *)return_value_malloc$4;
    if(!(rwords->array == ((struct anonymous$28 *)NULL)))
      rwords->array;

    else
      cbmyfatal("out of memory");
    rwords->start = 0;
    rwords->num = 0;
  }
  while((_Bool)0);
  i = 0;
  _Bool tmp_if_expr$6;
  signed int return_value_strcmp$5;
  for( ; !(i >= words->num); i = i + 1)
  {
    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(!(wsiz >= 1))
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_strcmp$5=strcmp(word, "[UVSET]");
      tmp_if_expr$6 = !(return_value_strcmp$5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$6)
    {
      char *return_value_est_uconv_in$7;
      return_value_est_uconv_in$7=est_uconv_in(word, wsiz, &size);
      rtext = (unsigned char *)return_value_est_uconv_in$7;
      est_canonicalize_text(rtext, size, 1);
      do
      {
        signed int _CB_index = rwords->start + rwords->num;
        if(_CB_index >= rwords->anum)
        {
          rwords->anum = rwords->anum * 2;
          void *return_value_realloc$8;
          return_value_realloc$8=realloc((void *)rwords->array, (unsigned long int)rwords->anum * sizeof(struct anonymous$28) /*16ul*/ );
          rwords->array = (struct anonymous$28 *)return_value_realloc$8;
          if(!(rwords->array == ((struct anonymous$28 *)NULL)))
            rwords->array;

          else
            cbmyfatal("out of memory");
        }

        (rwords->array + (signed long int)_CB_index)->dptr = (char *)rtext;
        (rwords->array + (signed long int)_CB_index)->dsize = size;
        rwords->num = rwords->num + 1;
      }
      while((_Bool)0);
    }

  }
  char *return_value_est_uconv_in$9;
  return_value_est_uconv_in$9=est_uconv_in(str, len, &size);
  rtext = (unsigned char *)return_value_est_uconv_in$9;
  char *return_value_cbmemdup$10;
  return_value_cbmemdup$10=cbmemdup((char *)rtext, size);
  ctext = (unsigned char *)return_value_cbmemdup$10;
  est_canonicalize_text(ctext, size, 0);
  mywidth = hwidth;
  if(!(rwords->num >= 1))
    mywidth = mywidth * 3;

  if(!(wwidth >= mywidth))
    mywidth = wwidth;

  i = 0;
  for( ; mywidth >= 1 && !(i >= size); i = i + 2)
  {
    signed int return_value_est_char_category$11;
    return_value_est_char_category$11=est_char_category((signed int)rtext[(signed long int)i] * 0x100 + (signed int)rtext[(signed long int)(i + 1)]);
    mywidth = mywidth - (return_value_est_char_category$11 == 3 ? 2 : 1);
  }
  awsiz = size - i;
  if(awsiz >= 49)
    awsiz = 48;

  est_snippet_add_text(rtext, ctext, i, awsiz, res, rwords);
  wwidth = wwidth - hwidth;
  bi = i + 2;
  do
  {
    if(1 + res->dsize >= res->asize)
    {
      res->asize = res->asize * 2 + 1 + 1;
      void *return_value_realloc$12;
      return_value_realloc$12=realloc((void *)res->dptr, (unsigned long int)res->asize);
      res->dptr = (char *)return_value_realloc$12;
      if(!(res->dptr == ((char *)NULL)))
        res->dptr;

      else
        cbmyfatal("out of memory");
    }

    memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
    res->dsize = res->dsize + 1;
    res->dptr[(signed long int)res->dsize] = (char)0;
  }
  while((_Bool)0);
  if(awidth >= 1)
  {
    counts=cbmapopenex(31);
    i = bi;
    for( ; wwidth >= 0 && !(i >= size); i = i + 2)
    {
      j = 0;
      for( ; !(j >= rwords->num); j = j + 1)
      {
        rwsiz = (rwords->array + (signed long int)(rwords->start + j))->dsize;
        rword = (unsigned char *)(const char *)(rwords->array + (signed long int)(rwords->start + j))->dptr;
        signed int return_value_est_str_fwmatch_wide$17;
        return_value_est_str_fwmatch_wide$17=est_str_fwmatch_wide(ctext + (signed long int)i, size - i, rword, rwsiz);
        if(return_value_est_str_fwmatch_wide$17 >= 1)
        {
          cval=cbmapget(counts, (char *)rword, rwsiz, &csiz);
          if(cval == ((const char *)NULL) || !(csiz >= ((double)wwidth > (double)awidth * 1.2 ? 2 : 1)))
          {
            cbmapputcat(counts, (char *)rword, rwsiz, "*", 1);
            signed int return_value_cbmaprnum$13;
            return_value_cbmaprnum$13=cbmaprnum(counts);
            if(return_value_cbmaprnum$13 >= rwords->num)
            {
              cbmapclose(counts);
              counts=cbmapopenex(31);
            }

            mywidth = awidth / 2 + 1;
            k = i - 2;
            for( ; k >= bi && mywidth >= 0; k = k - 2)
            {
              signed int return_value_est_char_category$14;
              return_value_est_char_category$14=est_char_category((signed int)rtext[(signed long int)k] * 0x100 + (signed int)rtext[(signed long int)(k + 1)]);
              mywidth = mywidth - (return_value_est_char_category$14 == 3 ? 2 : 1);
            }
            bi = k;
            mywidth = awidth / 2 + 1;
            k = i + rwsiz + 2;
            for( ; mywidth >= 0 && !(k >= size); k = k + 2)
            {
              signed int return_value_est_char_category$15;
              return_value_est_char_category$15=est_char_category((signed int)rtext[(signed long int)k] * 0x100 + (signed int)rtext[(signed long int)(k + 1)]);
              mywidth = mywidth - (return_value_est_char_category$15 == 3 ? 2 : 1);
            }
            if(!(size >= k))
              k = size;

            est_snippet_add_text(rtext + (signed long int)bi, ctext + (signed long int)bi, k - bi, 0, res, rwords);
            wwidth = wwidth - (awidth + rwsiz / 2);
            bi = k + 2;
            i = bi - 2;
            do
            {
              if(1 + res->dsize >= res->asize)
              {
                res->asize = res->asize * 2 + 1 + 1;
                void *return_value_realloc$16;
                return_value_realloc$16=realloc((void *)res->dptr, (unsigned long int)res->asize);
                res->dptr = (char *)return_value_realloc$16;
                if(!(res->dptr == ((char *)NULL)))
                  res->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
              res->dsize = res->dsize + 1;
              res->dptr[(signed long int)res->dsize] = (char)0;
            }
            while((_Bool)0);
            break;
          }

        }

      }
    }
    cbmapclose(counts);
  }

  free((void *)ctext);
  free((void *)rtext);
  do
  {
    signed int _CB_i;
    signed int _CB_end = rwords->start + rwords->num;
    _CB_i = rwords->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(rwords->array + (signed long int)_CB_i)->dptr);
    free((void *)rwords->array);
    free((void *)rwords);
  }
  while((_Bool)0);
  char *return_value_cbdatumtomalloc$18;
  return_value_cbdatumtomalloc$18=cbdatumtomalloc(res, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc$18;
}

// est_match_attr
// file estraier.c line 10008
static signed int est_match_attr(const char *tval, signed int tsiz, const char *cop, signed int sign, const char *oval, signed int osiz, const char *sval, signed int ssiz, const void *regex, signed int onum)
{
  unsigned char *eval;
  char *cval;
  signed int csiz;
  signed int esiz;
  signed int hit;
  cval = (char *)(void *)0;
  if(!(sval == ((const char *)NULL)))
  {
    char *return_value_est_uconv_in$1;
    return_value_est_uconv_in$1=est_uconv_in(tval, tsiz, &esiz);
    eval = (unsigned char *)return_value_est_uconv_in$1;
    est_normalize_text(eval, esiz, &esiz);
    est_canonicalize_text(eval, esiz, 0);
    char *return_value_est_uconv_out$2;
    return_value_est_uconv_out$2=est_uconv_out((char *)eval, esiz, &csiz);
    cval = (char *)return_value_est_uconv_out$2;
    free((void *)eval);
    tval = cval;
    tsiz = csiz;
    oval = sval;
    osiz = ssiz;
  }

  signed int tmp_if_expr$7;
  signed int return_value_est_regex_match$6;
  if(cop == "STREQ")
  {
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(tval, oval);
    hit = (signed int)!(return_value_strcmp$3 != 0);
  }

  else
    if(cop == "STRNE")
    {
      signed int return_value_strcmp$4;
      return_value_strcmp$4=strcmp(tval, oval);
      hit = (signed int)(return_value_strcmp$4 != 0);
    }

    else
      if(cop == "STRINC")
      {
        char *return_value_strstr$5;
        return_value_strstr$5=strstr(tval, oval);
        hit = (signed int)(return_value_strstr$5 != (char *)(void *)0);
      }

      else
        if(cop == "STRBW")
          hit=cbstrfwmatch(tval, oval);

        else
          if(cop == "STREW")
            hit=cbstrbwmatch(tval, oval);

          else
            if(cop == "STRAND")
              hit=est_check_strand(tval, oval);

            else
              if(cop == "STROR")
                hit=est_check_stror(tval, oval);

              else
                if(cop == "STROREQ")
                  hit=est_check_stroreq(tval, oval);

                else
                  if(cop == "STRRX")
                  {
                    if(!(regex == NULL))
                    {
                      return_value_est_regex_match$6=est_regex_match(regex, tval);
                      tmp_if_expr$7 = return_value_est_regex_match$6;
                    }

                    else
                      tmp_if_expr$7 = 0;
                    hit = tmp_if_expr$7;
                  }

                  else
                    if(cop == "NUMEQ")
                    {
                      signed long int return_value_cbstrmktime$8;
                      return_value_cbstrmktime$8=cbstrmktime(tval);
                      hit = (signed int)(return_value_cbstrmktime$8 == (signed long int)onum);
                    }

                    else
                      if(cop == "NUMNE")
                      {
                        signed long int return_value_cbstrmktime$9;
                        return_value_cbstrmktime$9=cbstrmktime(tval);
                        hit = (signed int)(return_value_cbstrmktime$9 != (signed long int)onum);
                      }

                      else
                        if(cop == "NUMGT")
                        {
                          signed long int return_value_cbstrmktime$10;
                          return_value_cbstrmktime$10=cbstrmktime(tval);
                          hit = (signed int)(return_value_cbstrmktime$10 > (signed long int)onum);
                        }

                        else
                          if(cop == "NUMGE")
                          {
                            signed long int return_value_cbstrmktime$11;
                            return_value_cbstrmktime$11=cbstrmktime(tval);
                            hit = (signed int)(return_value_cbstrmktime$11 >= (signed long int)onum);
                          }

                          else
                            if(cop == "NUMLT")
                            {
                              signed long int return_value_cbstrmktime$12;
                              return_value_cbstrmktime$12=cbstrmktime(tval);
                              hit = (signed int)(return_value_cbstrmktime$12 < (signed long int)onum);
                            }

                            else
                              if(cop == "NUMLE")
                              {
                                signed long int return_value_cbstrmktime$13;
                                return_value_cbstrmktime$13=cbstrmktime(tval);
                                hit = (signed int)(return_value_cbstrmktime$13 <= (signed long int)onum);
                              }

                              else
                                if(cop == "NUMBT")
                                  hit=est_check_numbt(tval, oval);

                                else
                                  if(cop == "[DUMMY]")
                                    hit = 1;

                                  else
                                    hit = 0;
  free((void *)cval);
  return sign != 0 ? hit : (signed int)!(hit != 0);
}

// est_match_crypt
// file estraier.c line 4105
signed int est_match_crypt(const char *key, const char *hash)
{
  char *khash;
  signed int rv;
  khash=est_make_crypt(key);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(khash, hash);
  rv = (signed int)!(return_value_strcmp$1 != 0);
  free((void *)khash);
  return rv;
}

// est_memory_usage
// file estraier.c line 5725
double est_memory_usage(void)
{
  return 0.0;
}

// est_metascore_compare_by_id_asc
// file estraier.c line 8168
static signed int est_metascore_compare_by_id_asc(const void *ap, const void *bp)
{
  return ((struct anonymous$32 *)ap)->id - ((struct anonymous$32 *)bp)->id;
}

// est_metascore_compare_by_id_desc
// file estraier.c line 8178
static signed int est_metascore_compare_by_id_desc(const void *ap, const void *bp)
{
  return ((struct anonymous$32 *)bp)->id - ((struct anonymous$32 *)ap)->id;
}

// est_metascore_compare_by_num_asc
// file estraier.c line 8228
static signed int est_metascore_compare_by_num_asc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous$32 *)ap)->value - (signed long int)((struct anonymous$32 *)bp)->value);
}

// est_metascore_compare_by_num_desc
// file estraier.c line 8238
static signed int est_metascore_compare_by_num_desc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous$32 *)bp)->value - (signed long int)((struct anonymous$32 *)ap)->value);
}

// est_metascore_compare_by_score_asc
// file estraier.c line 8188
static signed int est_metascore_compare_by_score_asc(const void *ap, const void *bp)
{
  return ((struct anonymous$32 *)ap)->score - ((struct anonymous$32 *)bp)->score;
}

// est_metascore_compare_by_score_desc
// file estraier.c line 8198
static signed int est_metascore_compare_by_score_desc(const void *ap, const void *bp)
{
  return ((struct anonymous$32 *)bp)->score - ((struct anonymous$32 *)ap)->score;
}

// est_metascore_compare_by_str_asc
// file estraier.c line 8208
static signed int est_metascore_compare_by_str_asc(const void *ap, const void *bp)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(((struct anonymous$32 *)ap)->value, ((struct anonymous$32 *)bp)->value);
  return return_value_strcmp$1;
}

// est_metascore_compare_by_str_desc
// file estraier.c line 8218
static signed int est_metascore_compare_by_str_desc(const void *ap, const void *bp)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(((struct anonymous$32 *)bp)->value, ((struct anonymous$32 *)ap)->value);
  return return_value_strcmp$1;
}

// est_mkdir
// file estraier.c line 5533
signed int est_mkdir(const char *path)
{
  signed int return_value_mkdir$1;
  return_value_mkdir$1=mkdir(path, (unsigned int)00755);
  return return_value_mkdir$1 == 0 ? 1 : 0;
}

// est_mtdb_add_attr_index
// file estmtdb.c line 123
signed int est_mtdb_add_attr_index(struct anonymous$14 *db, const char *name, signed int type)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_add_attr_index(db->db, name, type);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_add_meta
// file estmtdb.c line 449
void est_mtdb_add_meta(struct anonymous$14 *db, const char *name, const char *value)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_add_meta(db->db, name, value);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_add_pseudo_index
// file estmtdb.c line 370
signed int est_mtdb_add_pseudo_index(struct anonymous$14 *db, const char *path)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_add_pseudo_index(db->db, path);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_attr_index_exprs
// file estmtdb.c line 744
struct anonymous$1 * est_mtdb_attr_index_exprs(struct anonymous$14 *db)
{
  struct anonymous$1 *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return ((struct anonymous$1 *)NULL);

  else
  {
    rv=est_db_attr_index_exprs(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_cache_num
// file estmtdb.c line 646
signed int est_mtdb_cache_num(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_cache_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_cache_usage
// file estmtdb.c line 768
double est_mtdb_cache_usage(struct anonymous$14 *db)
{
  if(!(db->db->flsflag == 0))
    return 1.0;

  else
    return (double)db->db->icsiz / (double)db->db->icmax;
}

// est_mtdb_charge_rescc
// file estmtdb.c line 713
void est_mtdb_charge_rescc(struct anonymous$14 *db, signed int max)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_charge_rescc(db->db, max);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_check_option
// file estmtdb.c line 396
signed int est_mtdb_check_option(struct anonymous$14 *db, signed int option)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return -1;

  else
  {
    rv=est_db_check_option(db->db, option);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_close
// file estmtdb.h line 49
signed int est_mtdb_close(struct anonymous$14 *db, signed int *ecp)
{
  signed int err;
  signed int return_value_est_global_lock$1;
  return_value_est_global_lock$1=est_global_lock();
  if(return_value_est_global_lock$1 == 0)
  {
    *ecp = 3;
    return 0;
  }

  else
  {
    err = 0;
    cbmapout(est_global_db_names, db->path, -1);
    pthread_mutex_destroy(&db->mutex);
    free((void *)db->path);
    signed int return_value_est_db_close$2;
    return_value_est_db_close$2=est_db_close(db->db, ecp);
    if(return_value_est_db_close$2 == 0)
      err = 1;

    free((void *)db);
    est_global_unlock();
    return err != 0 ? 0 : 1;
  }
}

// est_mtdb_doc_num
// file estmtdb.h line 109
signed int est_mtdb_doc_num(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_doc_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_edit_doc
// file estmtdb.c line 200
signed int est_mtdb_edit_doc(struct anonymous$14 *db, struct anonymous$0 *doc)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_edit_doc(db->db, doc);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_error
// file estmtdb.h line 53
signed int est_mtdb_error(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 3;

  else
  {
    rv=est_db_error(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_etch_doc
// file estmtdb.c line 480
struct anonymous$9 * est_mtdb_etch_doc(struct anonymous$14 *db, struct anonymous$0 *doc, signed int max)
{
  struct anonymous$9 *rv;
  struct anonymous$9 *return_value_est_db_etch_doc$1;
  struct anonymous$9 *return_value_cbmapopenex$2;
  if(db == ((struct anonymous$14 *)NULL))
  {
    return_value_est_db_etch_doc$1=est_db_etch_doc((struct anonymous *)(void *)0, doc, max);
    return return_value_est_db_etch_doc$1;
  }

  else
  {
    signed int return_value_est_mtdb_lock$3;
    return_value_est_mtdb_lock$3=est_mtdb_lock(db);
    if(return_value_est_mtdb_lock$3 == 0)
    {
      return_value_cbmapopenex$2=cbmapopenex(1);
      return return_value_cbmapopenex$2;
    }

    else
    {
      rv=est_db_etch_doc(db->db, doc, max);
      est_mtdb_unlock(db);
      return rv;
    }
  }
}

// est_mtdb_fatal
// file estmtdb.c line 112
signed int est_mtdb_fatal(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_fatal(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_fill_key_cache
// file estmtdb.c line 686
void est_mtdb_fill_key_cache(struct anonymous$14 *db)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_fill_key_cache(db->db);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_flush
// file estmtdb.h line 65
signed int est_mtdb_flush(struct anonymous$14 *db, signed int max)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_flush(db->db, max);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_doc
// file estmtdb.h line 93
struct anonymous$0 * est_mtdb_get_doc(struct anonymous$14 *db, signed int id, signed int options)
{
  struct anonymous$0 *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return (struct anonymous$0 *)(void *)0;

  else
  {
    rv=est_db_get_doc(db->db, id, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_doc_attr
// file estmtdb.h line 97
char * est_mtdb_get_doc_attr(struct anonymous$14 *db, signed int id, const char *name)
{
  char *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_get_doc_attr(db->db, id, name);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_doc_entity
// file estmtdb.h line 163
char * est_mtdb_get_doc_entity(struct anonymous$14 *db, signed int id, signed int *sp)
{
  char *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return ((char *)NULL);

  else
  {
    rv=est_db_get_doc_entity(db->db, id, sp);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_get_keywords
// file estmtdb.c line 514
struct anonymous$9 * est_mtdb_get_keywords(struct anonymous$14 *db, signed int id)
{
  struct anonymous$9 *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return ((struct anonymous$9 *)NULL);

  else
  {
    rv=est_db_get_keywords(db->db, id);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_inode
// file estmtdb.c line 407
signed int est_mtdb_inode(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return -1;

  else
  {
    rv=est_db_inode(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_interrupt
// file estmtdb.h line 287
void est_mtdb_interrupt(struct anonymous$14 *db)
{
  est_db_interrupt(db->db);
}

// est_mtdb_iter_init
// file estmtdb.c line 536
signed int est_mtdb_iter_init(struct anonymous$14 *db, const char *prev)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_iter_init(db->db, prev);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_iter_next
// file estmtdb.c line 547
signed int est_mtdb_iter_next(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return -1;

  else
  {
    rv=est_db_iter_next(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_iter_init
// file estmtdb.c line 602
signed int est_mtdb_keyword_iter_init(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_keyword_iter_init(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_iter_next
// file estmtdb.c line 613
char * est_mtdb_keyword_iter_next(struct anonymous$14 *db)
{
  char *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_keyword_iter_next(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_num
// file estmtdb.c line 591
signed int est_mtdb_keyword_num(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_keyword_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_rec_size
// file estmtdb.c line 624
signed int est_mtdb_keyword_rec_size(struct anonymous$14 *db, const char *word)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_keyword_rec_size(db->db, word);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_keyword_search
// file estmtdb.c line 635
signed int * est_mtdb_keyword_search(struct anonymous$14 *db, const char *word, signed int *nump)
{
  signed int *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return (signed int *)(void *)0;

  else
  {
    rv=est_db_keyword_search(db->db, word, nump);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_list_rescc
// file estmtdb.c line 722
struct anonymous$1 * est_mtdb_list_rescc(struct anonymous$14 *db)
{
  struct anonymous$1 *rv;
  signed int return_value_est_mtdb_lock$2;
  return_value_est_mtdb_lock$2=est_mtdb_lock(db);
  struct anonymous$1 *return_value_cblistopen$1;
  if(return_value_est_mtdb_lock$2 == 0)
  {
    return_value_cblistopen$1=cblistopen();
    return return_value_cblistopen$1;
  }

  else
  {
    rv=est_db_list_rescc(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_lock
// file estmtdb.c line 796
static signed int est_mtdb_lock(struct anonymous$14 *db)
{
  if(!(dpisreentrant == 0))
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&db->mutex);
    if(!(return_value_pthread_mutex_lock$1 == 0))
    {
      est_db_set_ecode(db->db, 3);
      return 0;
    }

    return 1;
  }

  signed int return_value_pthread_mutex_lock$2;
  return_value_pthread_mutex_lock$2=pthread_mutex_lock(&est_global_mutex);
  if(!(return_value_pthread_mutex_lock$2 == 0))
  {
    est_db_set_ecode(db->db, 3);
    return 0;
  }

  else
    return 1;
}

// est_mtdb_measure_doc
// file estmtdb.c line 525
signed int est_mtdb_measure_doc(struct anonymous$14 *db, signed int id, signed int parts)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_measure_doc(db->db, id, parts);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_merge
// file estmtdb.c line 167
signed int est_mtdb_merge(struct anonymous$14 *db, const char *name, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_merge(db->db, name, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_meta
// file estmtdb.c line 469
char * est_mtdb_meta(struct anonymous$14 *db, const char *name)
{
  char *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_meta(db->db, name);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_meta_names
// file estmtdb.c line 458
struct anonymous$1 * est_mtdb_meta_names(struct anonymous$14 *db)
{
  struct anonymous$1 *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return (struct anonymous$1 *)(void *)0;

  else
  {
    rv=est_db_meta_names(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_name
// file estmtdb.h line 105
const char * est_mtdb_name(struct anonymous$14 *db)
{
  const char *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return "";

  else
  {
    rv=est_db_name(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_open
// file estmtdb.h line 45
struct anonymous$14 * est_mtdb_open(const char *name, signed int omode, signed int *ecp)
{
  struct anonymous$14 *mtdb;
  struct anonymous *db;
  char *path;
  signed int return_value_est_global_lock$1;
  return_value_est_global_lock$1=est_global_lock();
  if(return_value_est_global_lock$1 == 0)
  {
    *ecp = 3;
    return (struct anonymous$14 *)(void *)0;
  }

  else
  {
    if(est_global_db_names == ((struct anonymous$9 *)NULL))
    {
      est_global_db_names=cbmapopenex(31);
      cbglobalgc((void *)est_global_db_names, (void (*)(void *))cbmapclose);
    }

    path=est_realpath(name);
    const char *return_value_cbmapget$2;
    return_value_cbmapget$2=cbmapget(est_global_db_names, path, -1, (signed int *)(void *)0);
    if(!(return_value_cbmapget$2 == ((const char *)NULL)))
    {
      free((void *)path);
      *ecp = 2;
      est_global_unlock();
      return (struct anonymous$14 *)(void *)0;
    }

    else
    {
      void *return_value_cbmalloc$3;
      return_value_cbmalloc$3=cbmalloc(sizeof(struct anonymous$14) /*56ul*/ );
      mtdb = (struct anonymous$14 *)return_value_cbmalloc$3;
      db=est_db_open(name, omode, ecp);
      if(db == ((struct anonymous *)NULL))
      {
        free((void *)mtdb);
        free((void *)path);
        est_global_unlock();
        return (struct anonymous$14 *)(void *)0;
      }

      else
      {
        free((void *)path);
        path=est_realpath(name);
        cbmapput(est_global_db_names, path, -1, "", 0, 0);
        mtdb->db = db;
        mtdb->path = path;
        pthread_mutex_init(&mtdb->mutex, (const union anonymous$12 *)(void *)0);
        est_global_unlock();
        return mtdb;
      }
    }
  }
}

// est_mtdb_optimize
// file estmtdb.h line 73
signed int est_mtdb_optimize(struct anonymous$14 *db, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_optimize(db->db, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_out_doc
// file estmtdb.h line 85
signed int est_mtdb_out_doc(struct anonymous$14 *db, signed int id, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_out_doc(db->db, id, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_out_keywords
// file estmtdb.c line 503
signed int est_mtdb_out_keywords(struct anonymous$14 *db, signed int id)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_out_keywords(db->db, id);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_pseudo_doc_num
// file estmtdb.c line 733
signed int est_mtdb_pseudo_doc_num(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_pseudo_doc_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_put_doc
// file estmtdb.h line 81
signed int est_mtdb_put_doc(struct anonymous$14 *db, struct anonymous$0 *doc, signed int options)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_put_doc(db->db, doc, options);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_put_keywords
// file estmtdb.c line 492
signed int est_mtdb_put_keywords(struct anonymous$14 *db, signed int id, struct anonymous$9 *kwords, double weight)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_put_keywords(db->db, id, kwords, weight);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_refresh_rescc
// file estmtdb.c line 704
void est_mtdb_refresh_rescc(struct anonymous$14 *db)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_refresh_rescc(db->db);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_scan_doc
// file estmtdb.c line 350
signed int est_mtdb_scan_doc(struct anonymous$14 *db, struct anonymous$0 *doc, struct anonymous$8 *cond)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_scan_doc(db->db, doc, cond);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_search
// file estmtdb.h line 121
signed int * est_mtdb_search(struct anonymous$14 *db, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints)
{
  signed int *rv;
  signed int return_value_est_mtdb_lock$2;
  return_value_est_mtdb_lock$2=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$2 == 0)
  {
    est_db_set_ecode(db->db, 3);
    cbmapput(hints, "", 0, "0", -1, 1);
    *nump = 0;
    void *return_value_cbmalloc$1;
    return_value_cbmalloc$1=cbmalloc((unsigned long int)1);
    return (signed int *)return_value_cbmalloc$1;
  }

  rv=est_db_search(db->db, cond, nump, hints);
  est_mtdb_unlock(db);
  return rv;
}

// est_mtdb_search_meta
// file estmtdb.h line 125
signed int * est_mtdb_search_meta(struct anonymous$14 **dbs, signed int dbnum, struct anonymous$8 *cond, signed int *nump, struct anonymous$9 *hints)
{
  struct anonymous **cdbs;
  struct anonymous$9 *umap;
  const char *kbuf;
  signed int i;
  signed int *rv;
  void *return_value_cbmalloc$1;
  return_value_cbmalloc$1=cbmalloc((unsigned long int)dbnum * sizeof(struct anonymous *) /*8ul*/  + (unsigned long int)1);
  cdbs = (struct anonymous **)return_value_cbmalloc$1;
  signed int return_value_est_mtdb_lock$3;
  if(!(dpisreentrant == 0))
  {
    umap=cbmapopenex(dbnum + 1);
    i = 0;
    for( ; !(i >= dbnum); i = i + 1)
    {
      const char *return_value_cbmapget$4;
      return_value_cbmapget$4=cbmapget(umap, (char *)&dbs[(signed long int)i], (signed int)sizeof(struct anonymous *) /*8ul*/ , (signed int *)(void *)0);
      if(return_value_cbmapget$4 == ((const char *)NULL))
      {
        return_value_est_mtdb_lock$3=est_mtdb_lock(dbs[(signed long int)i]);
        if(return_value_est_mtdb_lock$3 == 0)
        {
          do
          {
            i = i - 1;
            if(!(i >= 0))
              break;

            est_mtdb_unlock(dbs[(signed long int)i]);
          }
          while((_Bool)1);
          free((void *)cdbs);
          est_db_set_ecode(cdbs[(signed long int)i], 3);
          cbmapput(hints, "", 0, "0", -1, 1);
          *nump = 0;
          void *return_value_cbmalloc$2;
          return_value_cbmalloc$2=cbmalloc((unsigned long int)1);
          return (signed int *)return_value_cbmalloc$2;
        }

      }

      cbmapput(umap, (char *)&dbs[(signed long int)i], (signed int)sizeof(struct anonymous *) /*8ul*/ , "", 0, 0);
      cdbs[(signed long int)i] = dbs[(signed long int)i]->db;
    }
    rv=est_db_search_meta(cdbs, dbnum, cond, nump, hints);
    cbmapiterinit(umap);
    do
    {
      kbuf=cbmapiternext(umap, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      est_mtdb_unlock(*((struct anonymous$14 **)kbuf));
    }
    while((_Bool)1);
    cbmapclose(umap);
  }

  else
  {
    signed int return_value_pthread_mutex_lock$6;
    return_value_pthread_mutex_lock$6=pthread_mutex_lock(&est_global_mutex);
    if(!(return_value_pthread_mutex_lock$6 == 0))
    {
      *nump = 0;
      void *return_value_cbmalloc$5;
      return_value_cbmalloc$5=cbmalloc((unsigned long int)1);
      return (signed int *)return_value_cbmalloc$5;
    }

    i = 0;
    for( ; !(i >= dbnum); i = i + 1)
      cdbs[(signed long int)i] = dbs[(signed long int)i]->db;
    rv=est_db_search_meta(cdbs, dbnum, cond, nump, hints);
    pthread_mutex_unlock(&est_global_mutex);
  }
  free((void *)cdbs);
  return rv;
}

// est_mtdb_set_cache_size
// file estmtdb.h line 133
void est_mtdb_set_cache_size(struct anonymous$14 *db, unsigned long int size, signed int anum, signed int tnum, signed int rnum)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_set_cache_size(db->db, size, anum, tnum, rnum);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_dfdb
// file estmtdb.c line 695
void est_mtdb_set_dfdb(struct anonymous$14 *db, struct anonymous$5 *dfdb)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_set_dfdb(db->db, dfdb);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_doc_entity
// file estmtdb.h line 159
signed int est_mtdb_set_doc_entity(struct anonymous$14 *db, signed int id, const char *ptr, signed int size)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_set_doc_entity(db->db, id, ptr, size);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_set_ecode
// file estmtdb.c line 387
void est_mtdb_set_ecode(struct anonymous$14 *db, signed int ecode)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_set_ecode(db->db, ecode);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_informer
// file estmtdb.h line 255
void est_mtdb_set_informer(struct anonymous$14 *db, void (*func)(const char *, void *), void *opaque)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_set_informer(db->db, func, opaque);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_special_cache
// file estmtdb.h line 251
void est_mtdb_set_special_cache(struct anonymous$14 *db, const char *name, signed int num)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_set_special_cache(db->db, name, num);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_set_wildmax
// file estmtdb.c line 440
void est_mtdb_set_wildmax(struct anonymous$14 *db, signed int num)
{
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(!(return_value_est_mtdb_lock$1 == 0))
  {
    est_db_set_wildmax(db->db, num);
    est_mtdb_unlock(db);
  }

}

// est_mtdb_size
// file estmtdb.c line 277
double est_mtdb_size(struct anonymous$14 *db)
{
  double rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0.0;

  else
  {
    rv=est_db_size(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_sync
// file estmtdb.h line 69
signed int est_mtdb_sync(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_sync(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_unlock
// file estmtdb.c line 815
static void est_mtdb_unlock(struct anonymous$14 *db)
{
  if(!(dpisreentrant == 0))
    pthread_mutex_unlock(&db->mutex);

  else
    pthread_mutex_unlock(&est_global_mutex);
}

// est_mtdb_uri_to_id
// file estmtdb.c line 233
signed int est_mtdb_uri_to_id(struct anonymous$14 *db, const char *uri)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return -1;

  else
  {
    rv=est_db_uri_to_id(db->db, uri);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_used_cache_size
// file estmtdb.c line 657
signed int est_mtdb_used_cache_size(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_used_cache_size(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_iter_init
// file estmtdb.c line 558
signed int est_mtdb_word_iter_init(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_word_iter_init(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_iter_next
// file estmtdb.c line 569
char * est_mtdb_word_iter_next(struct anonymous$14 *db)
{
  char *rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return (char *)(void *)0;

  else
  {
    rv=est_db_word_iter_next(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_num
// file estmtdb.c line 266
signed int est_mtdb_word_num(struct anonymous$14 *db)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_word_num(db->db);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_mtdb_word_rec_size
// file estmtdb.c line 580
signed int est_mtdb_word_rec_size(struct anonymous$14 *db, const char *word)
{
  signed int rv;
  signed int return_value_est_mtdb_lock$1;
  return_value_est_mtdb_lock$1=est_mtdb_lock(db);
  if(return_value_est_mtdb_lock$1 == 0)
    return 0;

  else
  {
    rv=est_db_word_rec_size(db->db, word);
    est_mtdb_unlock(db);
    return rv;
  }
}

// est_narrow_scores
// file estraier.c line 9386
static signed int est_narrow_scores(struct anonymous *db, const struct anonymous$1 *attrs, signed int ign, const char *order, const char *distinct, struct anonymous$6 *scores, signed int snum, signed int limit, signed int *restp, struct anonymous$9 *ordattrs)
{
  struct anonymous$11 *list;
  struct anonymous$16 *attridx;
  struct anonymous$9 *umap;
  const char *otype;
  const char *cbuf;
  const char *ibuf;
  const char *lbuf;
  char *oname;
  char *wp;
  char *mbuf;
  char *vbuf;
  signed int i;
  signed int j;
  signed int k;
  signed int ci;
  signed int oi;
  signed int anum;
  signed int done;
  signed int mixed;
  signed int nnum;
  signed int csiz;
  signed int msiz;
  signed int miss;
  signed int vsiz;
  signed int num;
  signed int isiz;
  signed int lsiz;
  signed int hit;
  signed int onlen;
  signed int dnlen;
  signed long int tval;
  *restp = 0;
  ci = -1;
  oi = -1;
  oname = (char *)(void *)0;
  otype = (const char *)(void *)0;
  char *tmp_post$1;
  if(!(order == ((const char *)NULL)))
  {
    oname=cbmemdup(order, -1);
    cbstrtrim(oname);
    otype = "STRA";
    wp=strchr(oname, 32);
    if(!(wp == ((char *)NULL)))
    {
      tmp_post$1 = wp;
      wp = wp + 1l;
      *tmp_post$1 = (char)0;
      for( ; (signed int)*wp == 32; wp = wp + 1l)
        ;
      otype = wp;
    }

  }

  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$11;
  signed int tmp_post$15;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$19;
  signed int tmp_post$21;
  if(!(attrs == ((const struct anonymous$1 *)NULL)))
  {
    list=est_make_cattr_list(attrs, &anum);
    signed int return_value_cbmaprnum$12;
    return_value_cbmaprnum$12=cbmaprnum(db->aidxs);
    if(return_value_cbmaprnum$12 >= 1)
    {
      done = 1;
      mixed = 0;
      i = 0;
      for( ; !(i >= anum); i = i + 1)
        if(!(i == ign))
        {
          const char *return_value_cbmapget$2;
          return_value_cbmapget$2=cbmapget(db->aidxs, (list + (signed long int)i)->name, (list + (signed long int)i)->nsiz, (signed int *)(void *)0);
          attridx = (struct anonymous$16 *)return_value_cbmapget$2;
          if(attridx == ((struct anonymous$16 *)NULL))
            tmp_if_expr$10 = (_Bool)1;

          else
          {
            if(attridx->type == 2)
              tmp_if_expr$3 = (list + (signed long int)i)->cop != "NUMEQ" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = (list + (signed long int)i)->cop != "NUMNE" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(tmp_if_expr$4)
              tmp_if_expr$5 = (list + (signed long int)i)->cop != "NUMGT" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = (list + (signed long int)i)->cop != "NUMGE" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$6 = (_Bool)0;
            if(tmp_if_expr$6)
              tmp_if_expr$7 = (list + (signed long int)i)->cop != "NUMLT" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$7 = (_Bool)0;
            if(tmp_if_expr$7)
              tmp_if_expr$8 = (list + (signed long int)i)->cop != "NUMLE" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$8 = (_Bool)0;
            if(tmp_if_expr$8)
              tmp_if_expr$9 = (list + (signed long int)i)->cop != "NUMBT" ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$9 = (_Bool)0;
            tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$10)
            tmp_if_expr$11 = (_Bool)1;

          else
            tmp_if_expr$11 = (attridx->type != 0 ? (snum < 256 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$11)
            done = 0;

          else
          {
            if(attridx->type == 1 || attridx->type == 2)
            {
              snum=est_aidx_attr_narrow((struct anonymous$7 *)attridx->db, db->pdocs, (list + (signed long int)i)->cop, (list + (signed long int)i)->sign, (list + (signed long int)i)->val, (list + (signed long int)i)->vsiz, (list + (signed long int)i)->sval, (list + (signed long int)i)->ssiz, (list + (signed long int)i)->regex, (signed int)(list + (signed long int)i)->num, scores, snum);
              mixed = 1;
              goto __CPROVER_DUMP_L27;
            }

            if(order == ((const char *)NULL) && i == anum + -1 && !(done == 0) && !(mixed == 0))
            {
              qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);
              mixed = 0;
            }

            snum=est_aidx_seq_narrow((struct anonymous$5 *)attridx->db, db->pdocs, (list + (signed long int)i)->cop, (list + (signed long int)i)->sign, (list + (signed long int)i)->val, (list + (signed long int)i)->vsiz, (list + (signed long int)i)->sval, (list + (signed long int)i)->ssiz, (list + (signed long int)i)->regex, (signed int)(list + (signed long int)i)->num, scores, snum, done != 0 && i == anum - 1 ? limit : 0x7fffffff, restp);

          __CPROVER_DUMP_L27:
            ;
            (list + (signed long int)i)->cop = "[DUMMY]";
          }
        }

      if(order == ((const char *)NULL) && !(mixed == 0))
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);

    }

    else
      done = 0;
    if(!(db->spacc == ((struct anonymous$9 *)NULL)))
    {
      i = 0;
      for( ; !(i >= anum); i = i + 1)
      {
        signed int return_value_strcmp$13;
        return_value_strcmp$13=strcmp((list + (signed long int)i)->name, db->scname);
        if(return_value_strcmp$13 == 0)
        {
          ci = i;
          break;
        }

      }
    }

    if(!(oname == ((char *)NULL)))
    {
      i = 0;
      for( ; !(i >= anum); i = i + 1)
      {
        signed int return_value_strcmp$14;
        return_value_strcmp$14=strcmp((list + (signed long int)i)->name, oname);
        if(return_value_strcmp$14 == 0)
        {
          oi = i;
          break;
        }

      }
    }

    if(done == 0)
    {
      nnum = 0;
      i = 0;
      for( ; !(i >= snum); i = i + 1)
      {
        if(nnum >= limit)
        {
          *restp = snum - i;
          break;
        }

        (scores + (signed long int)i)->value = (char *)(void *)0;
        if(ci >= 0)
        {
          cbuf=cbmapget(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
          if(!(cbuf == ((const char *)NULL)))
            cbmapmove(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , 0);

        }

        else
        {
          cbuf = (const char *)(void *)0;
          csiz = 0;
        }
        mbuf = (char *)(void *)0;
        if((scores + (signed long int)i)->id >= 2000000001)
        {
          tmp_post$15 = nnum;
          nnum = nnum + 1;
          scores[(signed long int)tmp_post$15] = scores[(signed long int)i];
        }

        else
        {
          if(anum == 1 && !(cbuf == ((const char *)NULL)))
            tmp_if_expr$22 = (_Bool)1;

          else
          {
            mbuf=est_crget(db->attrdb, db->zmode, (scores + (signed long int)i)->id, &msiz);
            tmp_if_expr$22 = mbuf != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$22)
          {
            miss = 0;
            j = 0;
            for( ; miss == 0 && !(j >= anum); j = j + 1)
              if((list + (signed long int)j)->nsiz >= 1)
              {
                if(!((list + (signed long int)j)->nlist == ((struct anonymous$1 *)NULL)))
                {
                  hit = 0;
                  k = 0;
                  for( ; !(k >= (list + (signed long int)j)->nlist->num); k = k + 1)
                  {
                    lsiz = ((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dsize;
                    lbuf = (const char *)((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dptr;
                    if(lsiz >= 1)
                    {
                      vbuf=cbmaploadone(mbuf, msiz, lbuf, lsiz, &vsiz);
                      if(!(vbuf == ((char *)NULL)))
                      {
                        signed int return_value_est_match_attr$16;
                        return_value_est_match_attr$16=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                        if(!(return_value_est_match_attr$16 == 0))
                        {
                          hit = 1;
                          free((void *)vbuf);
                          break;
                        }

                        free((void *)vbuf);
                      }

                    }

                  }
                  if(hit == 0)
                    miss = 1;

                  vbuf = (char *)(void *)0;
                }

                else
                {
                  if(!(mbuf == ((char *)NULL)))
                    vbuf=cbmaploadone(mbuf, msiz, (list + (signed long int)j)->name, (list + (signed long int)j)->nsiz, &vsiz);

                  else
                  {
                    if(!(csiz == 1))
                      tmp_if_expr$17 = (_Bool)1;

                    else
                      tmp_if_expr$17 = (signed int)cbuf[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$17)
                    {
                      vbuf=cbmemdup(cbuf, csiz);
                      vsiz = csiz;
                    }

                    else
                      vbuf = (char *)(void *)0;
                  }
                  if((signed int)*(list + (signed long int)j)->oper == 0)
                  {
                    if(vbuf == ((char *)NULL))
                      miss = 1;

                  }

                  else
                  {
                    if(vbuf == ((char *)NULL))
                    {
                      vbuf=cbmemdup("", 0);
                      vsiz = 0;
                    }

                    signed int return_value_est_match_attr$18;
                    return_value_est_match_attr$18=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                    if(return_value_est_match_attr$18 == 0)
                      miss = 1;

                  }
                }
                if(cbuf == ((const char *)NULL) && j == ci)
                {
                  if(!(vbuf == ((char *)NULL)))
                    cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

                  else
                    cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , "", 1, 0);
                  signed int return_value_cbmaprnum$20;
                  return_value_cbmaprnum$20=cbmaprnum(db->spacc);
                  if(!(db->scmnum >= return_value_cbmaprnum$20))
                  {
                    num = (signed int)((double)db->scmnum * 0.1 + (double)1);
                    cbmapiterinit(db->spacc);
                    k = 0;
                    do
                    {
                      if(!(k >= num))
                      {
                        ibuf=cbmapiternext(db->spacc, &isiz);
                        tmp_if_expr$19 = ibuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr$19 = (_Bool)0;
                      if(!tmp_if_expr$19)
                        break;

                      cbmapout(db->spacc, ibuf, isiz);
                      k = k + 1;
                    }
                    while((_Bool)1);
                  }

                }

                if(j == oi)
                  (scores + (signed long int)i)->value = vbuf;

                else
                  free((void *)vbuf);
              }

            if(!(miss == 0))
              free((void *)(scores + (signed long int)i)->value);

            else
            {
              tmp_post$21 = nnum;
              nnum = nnum + 1;
              scores[(signed long int)tmp_post$21] = scores[(signed long int)i];
            }
          }

        }
        free((void *)mbuf);
      }
      snum = nnum;
    }

    else
    {
      i = 0;
      for( ; !(i >= snum); i = i + 1)
        (scores + (signed long int)i)->value = (char *)(void *)0;
    }
    est_free_cattr_list(list, anum);
  }

  else
  {
    i = 0;
    for( ; !(i >= snum); i = i + 1)
      (scores + (signed long int)i)->value = (char *)(void *)0;
  }
  signed int return_value_cbstricmp$36;
  signed int return_value_cbstricmp$35;
  signed int return_value_cbstricmp$34;
  _Bool tmp_if_expr$24;
  signed int return_value_strcmp$23;
  _Bool tmp_if_expr$27;
  signed int return_value_cbmaprnum$29;
  _Bool tmp_if_expr$28;
  signed int return_value_cbstricmp$32;
  signed int return_value_cbstricmp$31;
  signed int return_value_cbstricmp$30;
  if(!(oname == ((char *)NULL)))
  {
    signed int return_value_cbstricmp$37;
    return_value_cbstricmp$37=cbstricmp(oname, "[IDA]");
    if(return_value_cbstricmp$37 == 0)
      qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);

    else
    {
      return_value_cbstricmp$36=cbstricmp(oname, "[IDD]");
      if(return_value_cbstricmp$36 == 0)
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_desc);

      else
      {
        return_value_cbstricmp$35=cbstricmp(oname, "[SCA]");
        if(return_value_cbstricmp$35 == 0)
          qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_asc);

        else
        {
          return_value_cbstricmp$34=cbstricmp(oname, "[SCD]");
          if(return_value_cbstricmp$34 == 0)
            qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);

          else
          {
            if(!(db->spacc == ((struct anonymous$9 *)NULL)))
            {
              return_value_strcmp$23=strcmp(oname, db->scname);
              tmp_if_expr$24 = !(return_value_strcmp$23 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$24 = (_Bool)0;
            ci = (signed int)tmp_if_expr$24;
            unsigned long int return_value_strlen$25;
            return_value_strlen$25=strlen(oname);
            onlen = (signed int)return_value_strlen$25;
            const char *return_value_cbmapget$26;
            return_value_cbmapget$26=cbmapget(db->aidxs, oname, onlen, (signed int *)(void *)0);
            attridx = (struct anonymous$16 *)return_value_cbmapget$26;
            if(!(attridx == ((struct anonymous$16 *)NULL)))
            {
              if(!(attridx->type == 0))
                attridx = (struct anonymous$16 *)(void *)0;

            }

            i = 0;
            for( ; !(i >= snum); i = i + 1)
              if((scores + (signed long int)i)->value == ((char *)NULL))
              {
                if(!(ci == 0))
                {
                  cbuf=cbmapget(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
                  if(cbuf == ((const char *)NULL))
                    goto __CPROVER_DUMP_L95;

                  cbmapmove(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , 0);
                  if(csiz == 1)
                    tmp_if_expr$27 = (signed int)cbuf[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$27 = (_Bool)0;
                  if(tmp_if_expr$27)
                    (scores + (signed long int)i)->value=cbmemdup("", 0);

                  else
                    (scores + (signed long int)i)->value=cbmemdup(cbuf, csiz);
                }

                else
                {

                __CPROVER_DUMP_L95:
                  ;
                  cbuf=cbmapget(ordattrs, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , &csiz);
                  if(!(cbuf == ((const char *)NULL)))
                    (scores + (signed long int)i)->value=cbmemdup(cbuf, csiz);

                  else
                    if(!(attridx == ((struct anonymous$16 *)NULL)))
                    {
                      vbuf=est_aidx_seq_get((struct anonymous$5 *)attridx->db, (scores + (signed long int)i)->id, &vsiz);
                      if(vbuf == ((char *)NULL))
                        vbuf=cbmemdup("", 0);

                      (scores + (signed long int)i)->value = vbuf;
                    }

                    else
                    {
                      mbuf=est_crget(db->attrdb, db->zmode, (scores + (signed long int)i)->id, &msiz);
                      if(!(mbuf == ((char *)NULL)))
                      {
                        vbuf=cbmaploadone(mbuf, msiz, oname, onlen, &vsiz);
                        if(!(vbuf == ((char *)NULL)))
                        {
                          if(!(ci == 0))
                            cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);

                          (scores + (signed long int)i)->value = vbuf;
                        }

                        else
                        {
                          if(!(ci == 0))
                            cbmapput(db->spacc, (char *)&(scores + (signed long int)i)->id, (signed int)sizeof(signed int) /*4ul*/ , "", 1, 0);

                          (scores + (signed long int)i)->value=cbmemdup("", 0);
                        }
                        if(!(ci == 0))
                        {
                          return_value_cbmaprnum$29=cbmaprnum(db->spacc);
                          if(!(db->scmnum >= return_value_cbmaprnum$29))
                          {
                            num = (signed int)((double)db->scmnum * 0.1 + (double)1);
                            cbmapiterinit(db->spacc);
                            j = 0;
                            do
                            {
                              if(!(j >= num))
                              {
                                ibuf=cbmapiternext(db->spacc, &isiz);
                                tmp_if_expr$28 = ibuf != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr$28 = (_Bool)0;
                              if(!tmp_if_expr$28)
                                break;

                              cbmapout(db->spacc, ibuf, isiz);
                              j = j + 1;
                            }
                            while((_Bool)1);
                          }

                        }

                        free((void *)mbuf);
                      }

                      else
                        (scores + (signed long int)i)->value=cbmemdup("", 0);
                    }
                }
              }

            signed int return_value_cbstricmp$33;
            return_value_cbstricmp$33=cbstricmp(otype, "STRA");
            if(return_value_cbstricmp$33 == 0)
              qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_str_asc);

            else
            {
              return_value_cbstricmp$32=cbstricmp(otype, "STRD");
              if(return_value_cbstricmp$32 == 0)
                qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_str_desc);

              else
              {
                return_value_cbstricmp$31=cbstricmp(otype, "NUMA");
                if(return_value_cbstricmp$31 == 0)
                {
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                  {
                    tval=cbstrmktime((scores + (signed long int)i)->value);
                    free((void *)(scores + (signed long int)i)->value);
                    (scores + (signed long int)i)->value = (char *)(void *)tval;
                  }
                  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_num_asc);
                  i = 0;
                  for( ; !(i >= snum); i = i + 1)
                    (scores + (signed long int)i)->value = (char *)(void *)0;
                }

                else
                {
                  return_value_cbstricmp$30=cbstricmp(otype, "NUMD");
                  if(return_value_cbstricmp$30 == 0)
                  {
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                    {
                      tval=cbstrmktime((scores + (signed long int)i)->value);
                      free((void *)(scores + (signed long int)i)->value);
                      (scores + (signed long int)i)->value = (char *)(void *)tval;
                    }
                    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_num_desc);
                    i = 0;
                    for( ; !(i >= snum); i = i + 1)
                      (scores + (signed long int)i)->value = (char *)(void *)0;
                  }

                }
              }
            }
            i = 0;
            for( ; !(i >= snum); i = i + 1)
              free((void *)(scores + (signed long int)i)->value);
          }
        }
      }
    }
    free((void *)oname);
  }

  signed int tmp_post$41;
  if(!(distinct == ((const char *)NULL)))
  {
    if(order == ((const char *)NULL))
    {
      if(!((signed int)*distinct == 126))
        qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);

    }

    if((signed int)*distinct == 126)
      distinct = distinct + 1l;

    unsigned long int return_value_strlen$38;
    return_value_strlen$38=strlen(distinct);
    dnlen = (signed int)return_value_strlen$38;
    umap=cbmapopenex(snum + 1);
    const char *return_value_cbmapget$39;
    return_value_cbmapget$39=cbmapget(db->aidxs, distinct, dnlen, (signed int *)(void *)0);
    attridx = (struct anonymous$16 *)return_value_cbmapget$39;
    if(!(attridx == ((struct anonymous$16 *)NULL)))
    {
      if(!(attridx->type == 0))
        attridx = (struct anonymous$16 *)(void *)0;

    }

    nnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      if((scores + (signed long int)i)->id >= 2000000001)
      {
        vbuf=est_db_get_doc_attr(db, (scores + (signed long int)i)->id, distinct);
        if(vbuf == ((char *)NULL))
          vbuf=cbmemdup("", 0);

        unsigned long int return_value_strlen$40;
        return_value_strlen$40=strlen(vbuf);
        vsiz = (signed int)return_value_strlen$40;
      }

      else
        if(!(attridx == ((struct anonymous$16 *)NULL)))
        {
          vbuf=est_aidx_seq_get((struct anonymous$5 *)attridx->db, (scores + (signed long int)i)->id, &vsiz);
          if(vbuf == ((char *)NULL))
          {
            vbuf=cbmemdup("", 0);
            vsiz = 0;
          }

        }

        else
        {
          mbuf=est_crget(db->attrdb, db->zmode, (scores + (signed long int)i)->id, &msiz);
          if(!(mbuf == ((char *)NULL)))
          {
            vbuf=cbmaploadone(mbuf, msiz, distinct, dnlen, &vsiz);
            if(vbuf == ((char *)NULL))
            {
              vbuf=cbmemdup("", 0);
              vsiz = 0;
            }

            free((void *)mbuf);
          }

          else
          {
            vbuf=cbmemdup("", 0);
            vsiz = 0;
          }
        }
      signed int return_value_cbmapput$42;
      return_value_cbmapput$42=cbmapput(umap, vbuf, vsiz, "", 0, 0);
      if(!(return_value_cbmapput$42 == 0))
      {
        tmp_post$41 = nnum;
        nnum = nnum + 1;
        scores[(signed long int)tmp_post$41] = scores[(signed long int)i];
      }

      free((void *)vbuf);
    }
    snum = nnum;
    cbmapclose(umap);
  }

  return snum;
}

// est_node_add_header
// file estnode.c line 1638
void est_node_add_header(struct anonymous$24 *node, const char *name, const char *value)
{
  const char *vbuf;
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  len = (signed int)return_value_strlen$1;
  if(!(value == ((const char *)NULL)))
  {
    vbuf=cbmapget(node->heads, name, len, (signed int *)(void *)0);
    if(!(vbuf == ((const char *)NULL)))
    {
      cbmapputcat(node->heads, name, len, ", ", 2);
      cbmapputcat(node->heads, name, len, value, -1);
    }

    else
      cbmapput(node->heads, name, len, value, -1, 0);
  }

  else
    cbmapout(node->heads, name, len);
}

// est_node_admins
// file estnode.c line 1046
const struct anonymous$1 * est_node_admins(struct anonymous$24 *node)
{
  if(!(node->admins == ((struct anonymous$1 *)NULL)))
    return node->admins;

  else
  {
    est_node_set_info(node);
    return node->admins;
  }
}

// est_node_cache_usage
// file estnode.c line 1009
double est_node_cache_usage(struct anonymous$24 *node)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err;
  double ratio;
  err = 0;
  sprintf(url, "%s/cacheusage", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  resbody=cbdatumopen((const char *)(void *)0, -1);
  signed int return_value_est_url_shuttle$3;
  return_value_est_url_shuttle$3=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, (const char *)(void *)0, -1, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$3 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  double tmp_if_expr$6;
  const char *return_value_cbdatumptr$4;
  double return_value_strtod$5;
  if(!(err == 0))
    tmp_if_expr$6 = -1.0;

  else
  {
    return_value_cbdatumptr$4=cbdatumptr(resbody);
    return_value_strtod$5=strtod(return_value_cbdatumptr$4, (char ** restrict )(void *)0);
    tmp_if_expr$6 = return_value_strtod$5;
  }
  ratio = tmp_if_expr$6;
  cbdatumclose(resbody);
  cblistclose(reqheads);
  return ratio;
}

// est_node_delete
// file estnode.c line 358
void est_node_delete(struct anonymous$24 *node)
{
  cbmapclose(node->heads);
  est_node_iter_delete(node);
  if(!(node->links == ((struct anonymous$1 *)NULL)))
    cblistclose(node->links);

  if(!(node->users == ((struct anonymous$1 *)NULL)))
    cblistclose(node->users);

  if(!(node->admins == ((struct anonymous$1 *)NULL)))
    cblistclose(node->admins);

  free((void *)node->label);
  free((void *)node->name);
  free((void *)node->auth);
  free((void *)node->pxhost);
  free((void *)node->url);
  free((void *)node);
}

// est_node_doc_num
// file estnode.c line 982
signed int est_node_doc_num(struct anonymous$24 *node)
{
  if(node->dnum >= 0)
    return node->dnum;

  else
  {
    est_node_set_info(node);
    return node->dnum;
  }
}

// est_node_edit_doc
// file estnode.c line 591
signed int est_node_edit_doc(struct anonymous$24 *node, struct anonymous$0 *doc)
{
  struct anonymous$1 *reqheads;
  struct anonymous$1 *names;
  struct anonymous$2 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err;
  signed int ksiz;
  err = 0;
  sprintf(url, "%s/edit_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: text/x-estraier-draft", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  names=est_doc_attr_names(doc);
  i = 0;
  signed int return_value_cblistnum$3;
  do
  {
    return_value_cblistnum$3=cblistnum(names);
    if(i >= return_value_cblistnum$3)
      break;

    kbuf=cblistval(names, i, &ksiz);
    cbdatumcat(reqbody, kbuf, ksiz);
    cbdatumcat(reqbody, "=", 1);
    const char *return_value_est_doc_attr$4;
    return_value_est_doc_attr$4=est_doc_attr(doc, kbuf);
    cbdatumcat(reqbody, return_value_est_doc_attr$4, -1);
    cbdatumcat(reqbody, "\n", 1);
    i = i + 1;
  }
  while((_Bool)1);
  cbdatumcat(reqbody, "\n", 1);
  const char *return_value_cbdatumptr$5;
  return_value_cbdatumptr$5=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$6;
  return_value_cbdatumsize$6=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$7;
  return_value_est_url_shuttle$7=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$5, return_value_cbdatumsize$6, &rescode, (struct anonymous$9 *)(void *)0, (struct anonymous$2 *)(void *)0);
  if(return_value_est_url_shuttle$7 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cblistclose(names);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_etch_doc
// file estnode.c line 814
struct anonymous$9 * est_node_etch_doc(struct anonymous$24 *node, signed int id)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  struct anonymous$9 *kwords;
  struct anonymous$1 *lines;
  const char *kbuf;
  const char *pv;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/etch_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d", id);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  signed int return_value_cblistnum$8;
  if(!(err == 0))
    kwords = (struct anonymous$9 *)(void *)0;

  else
  {
    kwords=cbmapopenex(31);
    const char *return_value_cbdatumptr$6;
    return_value_cbdatumptr$6=cbdatumptr(resbody);
    signed int return_value_cbdatumsize$7;
    return_value_cbdatumsize$7=cbdatumsize(resbody);
    lines=cbsplit(return_value_cbdatumptr$6, return_value_cbdatumsize$7, "\n");
    i = 0;
    do
    {
      return_value_cblistnum$8=cblistnum(lines);
      if(i >= return_value_cblistnum$8)
        break;

      kbuf=cblistval(lines, i, (signed int *)(void *)0);
      pv=strchr(kbuf, 9);
      if(!(pv == ((const char *)NULL)) && !(pv == kbuf))
        cbmapput(kwords, kbuf, (signed int)(pv - kbuf), pv + (signed long int)1, -1, 1);

      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(lines);
  }
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return kwords;
}

// est_node_etch_doc_by_uri
// file estnode.c line 868
struct anonymous$9 * est_node_etch_doc_by_uri(struct anonymous$24 *node, const char *uri)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  struct anonymous$9 *kwords;
  struct anonymous$1 *lines;
  const char *kbuf;
  const char *pv;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/etch_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  signed int return_value_cblistnum$8;
  if(!(err == 0))
    kwords = (struct anonymous$9 *)(void *)0;

  else
  {
    kwords=cbmapopenex(31);
    const char *return_value_cbdatumptr$6;
    return_value_cbdatumptr$6=cbdatumptr(resbody);
    signed int return_value_cbdatumsize$7;
    return_value_cbdatumsize$7=cbdatumsize(resbody);
    lines=cbsplit(return_value_cbdatumptr$6, return_value_cbdatumsize$7, "\n");
    i = 0;
    do
    {
      return_value_cblistnum$8=cblistnum(lines);
      if(i >= return_value_cblistnum$8)
        break;

      kbuf=cblistval(lines, i, (signed int *)(void *)0);
      pv=strchr(kbuf, 9);
      if(!(pv == ((const char *)NULL)) && !(pv == kbuf))
        cbmapput(kwords, kbuf, (signed int)(pv - kbuf), pv + (signed long int)1, -1, 1);

      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(lines);
  }
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return kwords;
}

// est_node_get_doc
// file estnode.c line 638
struct anonymous$0 * est_node_get_doc(struct anonymous$24 *node, signed int id)
{
  struct anonymous$0 *doc;
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d", id);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  struct anonymous$0 *tmp_if_expr$8;
  const char *return_value_cbdatumptr$6;
  struct anonymous$0 *return_value_est_doc_new_from_draft$7;
  if(!(err == 0))
    tmp_if_expr$8 = (struct anonymous$0 *)(void *)0;

  else
  {
    return_value_cbdatumptr$6=cbdatumptr(resbody);
    return_value_est_doc_new_from_draft$7=est_doc_new_from_draft(return_value_cbdatumptr$6);
    tmp_if_expr$8 = return_value_est_doc_new_from_draft$7;
  }
  doc = tmp_if_expr$8;
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return doc;
}

// est_node_get_doc_attr
// file estnode.c line 722
char * est_node_get_doc_attr(struct anonymous$24 *node, signed int id, const char *name)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc_attr", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d&attr=%?", id, name);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  if(!(err == 0))
  {
    cbdatumclose(resbody);
    vbuf = (char *)(void *)0;
  }

  else
  {
    vbuf=cbdatumtomalloc(resbody, (signed int *)(void *)0);
    cbstrtrim(vbuf);
  }
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return vbuf;
}

// est_node_get_doc_attr_by_uri
// file estnode.c line 768
char * est_node_get_doc_attr_by_uri(struct anonymous$24 *node, const char *uri, const char *name)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc_attr", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?&attr=%?", uri, name);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  if(!(err == 0))
  {
    cbdatumclose(resbody);
    vbuf = (char *)(void *)0;
  }

  else
  {
    vbuf=cbdatumtomalloc(resbody, (signed int *)(void *)0);
    cbstrtrim(vbuf);
  }
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return vbuf;
}

// est_node_get_doc_by_uri
// file estnode.c line 680
struct anonymous$0 * est_node_get_doc_by_uri(struct anonymous$24 *node, const char *uri)
{
  struct anonymous$0 *doc;
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/get_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  struct anonymous$0 *tmp_if_expr$8;
  const char *return_value_cbdatumptr$6;
  struct anonymous$0 *return_value_est_doc_new_from_draft$7;
  if(!(err == 0))
    tmp_if_expr$8 = (struct anonymous$0 *)(void *)0;

  else
  {
    return_value_cbdatumptr$6=cbdatumptr(resbody);
    return_value_est_doc_new_from_draft$7=est_doc_new_from_draft(return_value_cbdatumptr$6);
    tmp_if_expr$8 = return_value_est_doc_new_from_draft$7;
  }
  doc = tmp_if_expr$8;
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return doc;
}

// est_node_iter_delete
// file estnode.c line 2070
static void est_node_iter_delete(struct anonymous$24 *node)
{
  signed int i;
  signed int return_value_cblistnum$1;
  if(!(node->ilist == ((struct anonymous$1 *)NULL)))
  {
    i = 0;
    do
    {
      return_value_cblistnum$1=cblistnum(node->ilist);
      if(i >= return_value_cblistnum$1)
        break;

      const char *return_value_cblistval$2;
      return_value_cblistval$2=cblistval(node->ilist, i, (signed int *)(void *)0);
      est_doc_delete(*((struct anonymous$0 **)return_value_cblistval$2));
      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(node->ilist);
    node->ilist = (struct anonymous$1 *)(void *)0;
  }

  free((void *)node->iprev);
  node->iprev = (char *)(void *)0;
}

// est_node_iter_init
// file estnode.c line 1614
signed int est_node_iter_init(struct anonymous$24 *node)
{
  est_node_iter_delete(node);
  signed int return_value_est_node_read_list$1;
  return_value_est_node_read_list$1=est_node_read_list(node);
  return (signed int)(return_value_est_node_read_list$1 != -1);
}

// est_node_iter_next
// file estnode.c line 1621
struct anonymous$0 * est_node_iter_next(struct anonymous$24 *node)
{
  struct anonymous$0 *doc;
  char *vbuf;
  _Bool tmp_if_expr$3;
  signed int return_value_cblistnum$2;
  if(node->ilist == ((struct anonymous$1 *)NULL))
    return (struct anonymous$0 *)(void *)0;

  else
  {
    signed int return_value_cblistnum$4;
    return_value_cblistnum$4=cblistnum(node->ilist);
    if(!(return_value_cblistnum$4 >= 1))
    {
      cblistclose(node->ilist);
      node->ilist=cblistopen();
      signed int return_value_est_node_read_list$1;
      return_value_est_node_read_list$1=est_node_read_list(node);
      if(return_value_est_node_read_list$1 == -1)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_cblistnum$2=cblistnum(node->ilist);
        tmp_if_expr$3 = return_value_cblistnum$2 < 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        return (struct anonymous$0 *)(void *)0;

    }

    vbuf=cblistshift(node->ilist, (signed int *)(void *)0);
    doc = *((struct anonymous$0 **)vbuf);
    free((void *)vbuf);
    return doc;
  }
}

// est_node_label
// file estnode.c line 973
const char * est_node_label(struct anonymous$24 *node)
{
  if(!(node->label == ((char *)NULL)))
    return node->label;

  else
  {
    est_node_set_info(node);
    return node->label;
  }
}

// est_node_links
// file estnode.c line 1064
const struct anonymous$1 * est_node_links(struct anonymous$24 *node)
{
  if(!(node->links == ((struct anonymous$1 *)NULL)))
    return node->links;

  else
  {
    est_node_set_info(node);
    return node->links;
  }
}

// est_node_name
// file estnode.c line 964
const char * est_node_name(struct anonymous$24 *node)
{
  if(!(node->name == ((char *)NULL)))
    return node->name;

  else
  {
    est_node_set_info(node);
    return node->name;
  }
}

// est_node_new
// file estnode.c line 330
struct anonymous$24 * est_node_new(const char *url)
{
  struct anonymous$24 *node;
  void *return_value_cbmalloc$1;
  return_value_cbmalloc$1=cbmalloc(sizeof(struct anonymous$24) /*136ul*/ );
  node = (struct anonymous$24 *)return_value_cbmalloc$1;
  node->url=cbmemdup(url, -1);
  node->pxhost = (char *)(void *)0;
  node->pxport = 0;
  node->timeout = -1;
  node->auth = (char *)(void *)0;
  node->name = (char *)(void *)0;
  node->label = (char *)(void *)0;
  node->dnum = -1;
  node->wnum = -1;
  node->size = -1.0;
  node->admins = (struct anonymous$1 *)(void *)0;
  node->users = (struct anonymous$1 *)(void *)0;
  node->links = (struct anonymous$1 *)(void *)0;
  node->wwidth = 480;
  node->hwidth = 96;
  node->awidth = 96;
  node->ilist = (struct anonymous$1 *)(void *)0;
  node->iprev = (char *)(void *)0;
  node->status = 0;
  node->heads=cbmapopenex(31);
  return node;
}

// est_node_optimize
// file estnode.c line 443
signed int est_node_optimize(struct anonymous$24 *node)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/optimize", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, (struct anonymous$2 *)(void *)0);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_out_doc
// file estnode.c line 515
signed int est_node_out_doc(struct anonymous$24 *node, signed int id)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/out_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "id=%d", id);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, (struct anonymous$2 *)(void *)0);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_out_doc_by_uri
// file estnode.c line 553
signed int est_node_out_doc_by_uri(struct anonymous$24 *node, const char *uri)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/out_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, (struct anonymous$2 *)(void *)0);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_put_doc
// file estnode.c line 480
signed int est_node_put_doc(struct anonymous$24 *node, struct anonymous$0 *doc)
{
  struct anonymous$1 *reqheads;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  char *reqbody;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/put_doc", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: text/x-estraier-draft", -1);
  reqbody=est_doc_dump_draft(doc);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(reqbody);
  signed int return_value_est_url_shuttle$4;
  return_value_est_url_shuttle$4=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, reqbody, (signed int)return_value_strlen$3, &rescode, (struct anonymous$9 *)(void *)0, (struct anonymous$2 *)(void *)0);
  if(return_value_est_url_shuttle$4 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  free((void *)reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_read_list
// file estnode.c line 2088
static signed int est_node_read_list(struct anonymous$24 *node)
{
  struct anonymous$0 *doc;
  struct anonymous$1 *reqheads;
  struct anonymous$1 *lines;
  struct anonymous$1 *fields;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  const char *id;
  const char *uri;
  char url[4096l];
  char *vbuf;
  signed int i;
  signed int rescode;
  signed int err;
  signed int ksiz;
  signed int dnum;
  err = 0;
  sprintf(url, "%s/list", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "max=%d", 256);
  if(!(node->iprev == ((char *)NULL)))
    cbdatumprintf(reqbody, "&prev=%?", node->iprev);

  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  dnum = 0;
  signed int return_value_cblistnum$8;
  if(err == 0)
  {
    if(node->ilist == ((struct anonymous$1 *)NULL))
      node->ilist=cblistopen();

    const char *return_value_cbdatumptr$6;
    return_value_cbdatumptr$6=cbdatumptr(resbody);
    signed int return_value_cbdatumsize$7;
    return_value_cbdatumsize$7=cbdatumsize(resbody);
    lines=cbsplit(return_value_cbdatumptr$6, return_value_cbdatumsize$7, "\r\n");
    i = 0;
    do
    {
      return_value_cblistnum$8=cblistnum(lines);
      if(i >= return_value_cblistnum$8)
        break;

      kbuf=cblistval(lines, i, &ksiz);
      if(ksiz >= 1)
      {
        fields=cbsplit(kbuf, ksiz, "\t");
        signed int return_value_cblistnum$22;
        return_value_cblistnum$22=cblistnum(fields);
        if(return_value_cblistnum$22 == 14)
        {
          id=cblistval(fields, 0, (signed int *)(void *)0);
          uri=cblistval(fields, 1, (signed int *)(void *)0);
          doc=est_doc_new();
          signed int return_value_atoi$9;
          return_value_atoi$9=atoi(id);
          est_doc_set_id(doc, return_value_atoi$9);
          est_doc_add_attr(doc, "@id", id);
          est_doc_add_attr(doc, "@uri", uri);
          const char *return_value_cblistval$10;
          return_value_cblistval$10=cblistval(fields, 2, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@digest", return_value_cblistval$10);
          const char *return_value_cblistval$11;
          return_value_cblistval$11=cblistval(fields, 3, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@cdate", return_value_cblistval$11);
          const char *return_value_cblistval$12;
          return_value_cblistval$12=cblistval(fields, 4, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@mdate", return_value_cblistval$12);
          const char *return_value_cblistval$13;
          return_value_cblistval$13=cblistval(fields, 5, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@adate", return_value_cblistval$13);
          const char *return_value_cblistval$14;
          return_value_cblistval$14=cblistval(fields, 6, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@title", return_value_cblistval$14);
          const char *return_value_cblistval$15;
          return_value_cblistval$15=cblistval(fields, 7, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@author", return_value_cblistval$15);
          const char *return_value_cblistval$16;
          return_value_cblistval$16=cblistval(fields, 8, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@type", return_value_cblistval$16);
          const char *return_value_cblistval$17;
          return_value_cblistval$17=cblistval(fields, 9, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@lang", return_value_cblistval$17);
          const char *return_value_cblistval$18;
          return_value_cblistval$18=cblistval(fields, 10, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@genre", return_value_cblistval$18);
          const char *return_value_cblistval$19;
          return_value_cblistval$19=cblistval(fields, 11, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@size", return_value_cblistval$19);
          const char *return_value_cblistval$20;
          return_value_cblistval$20=cblistval(fields, 12, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@weight", return_value_cblistval$20);
          const char *return_value_cblistval$21;
          return_value_cblistval$21=cblistval(fields, 13, (signed int *)(void *)0);
          est_doc_add_attr(doc, "@misc", return_value_cblistval$21);
          cblistpush(node->ilist, (char *)&doc, (signed int)sizeof(struct anonymous$0 *) /*8ul*/ );
          dnum = dnum + 1;
          free((void *)node->iprev);
          node->iprev=cbmemdup(uri, -1);
        }

        cblistclose(fields);
      }

      i = i + 1;
    }
    while((_Bool)1);
    cblistclose(lines);
  }

  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? -1 : dnum;
}

// est_node_search
// file estnode.c line 1073
struct anonymous$17 * est_node_search(struct anonymous$24 *node, struct anonymous$8 *cond, signed int depth)
{
  struct anonymous$17 *nres;
  const struct anonymous$1 *attrs;
  struct anonymous$9 *resheads;
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  const char *phrase;
  const char *order;
  const char *distinct;
  const char *cbuf;
  char buf[4096l];
  char *vbuf;
  char *ptr;
  char *pv;
  char *ep;
  signed int i;
  signed int rescode;
  signed int err;
  signed int max;
  signed int plen;
  signed int part;
  signed int end;
  err = 0;
  sprintf(buf, "%s/search", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  phrase=est_cond_phrase(cond);
  if(!(phrase == ((const char *)NULL)))
    cbdatumprintf(reqbody, "phrase=%?", phrase);

  attrs=est_cond_attrs(cond);
  signed int return_value_cblistnum$3;
  if(!(attrs == ((const struct anonymous$1 *)NULL)))
  {
    i = 0;
    do
    {
      return_value_cblistnum$3=cblistnum(attrs);
      if(i >= return_value_cblistnum$3)
        break;

      signed int return_value_cbdatumsize$4;
      return_value_cbdatumsize$4=cbdatumsize(reqbody);
      if(return_value_cbdatumsize$4 >= 1)
        cbdatumcat(reqbody, "&", 1);

      const char *return_value_cblistval$5;
      return_value_cblistval$5=cblistval(attrs, i, (signed int *)(void *)0);
      cbdatumprintf(reqbody, "attr%d=%?", i + 1, return_value_cblistval$5);
      i = i + 1;
    }
    while((_Bool)1);
  }

  max=est_cond_max(cond);
  if(max >= 0)
  {
    signed int return_value_cbdatumsize$6;
    return_value_cbdatumsize$6=cbdatumsize(reqbody);
    if(return_value_cbdatumsize$6 >= 1)
      cbdatumcat(reqbody, "&", 1);

    cbdatumprintf(reqbody, "max=%d", max);
  }

  else
  {
    signed int return_value_cbdatumsize$7;
    return_value_cbdatumsize$7=cbdatumsize(reqbody);
    if(return_value_cbdatumsize$7 >= 1)
      cbdatumcat(reqbody, "&", 1);

    cbdatumprintf(reqbody, "max=%d", 0x7fffffff / 2);
  }
  order=est_cond_order(cond);
  if(!(order == ((const char *)NULL)))
  {
    signed int return_value_cbdatumsize$8;
    return_value_cbdatumsize$8=cbdatumsize(reqbody);
    if(return_value_cbdatumsize$8 >= 1)
      cbdatumcat(reqbody, "&", 1);

    cbdatumprintf(reqbody, "order=%?", order);
  }

  signed int return_value_cbdatumsize$9;
  return_value_cbdatumsize$9=cbdatumsize(reqbody);
  if(return_value_cbdatumsize$9 >= 1)
    cbdatumcat(reqbody, "&", 1);

  signed int return_value_est_cond_options$10;
  return_value_est_cond_options$10=est_cond_options(cond);
  cbdatumprintf(reqbody, "options=%d", return_value_est_cond_options$10);
  signed int return_value_est_cond_auxiliary$11;
  return_value_est_cond_auxiliary$11=est_cond_auxiliary(cond);
  cbdatumprintf(reqbody, "&auxiliary=%d", return_value_est_cond_auxiliary$11);
  distinct=est_cond_distinct(cond);
  if(!(distinct == ((const char *)NULL)))
    cbdatumprintf(reqbody, "&distinct=%?", distinct);

  cbdatumprintf(reqbody, "&depth=%d", depth);
  cbdatumprintf(reqbody, "&wwidth=%d", node->wwidth);
  cbdatumprintf(reqbody, "&hwidth=%d", node->hwidth);
  cbdatumprintf(reqbody, "&awidth=%d", node->awidth);
  signed int return_value_est_cond_skip$12;
  return_value_est_cond_skip$12=est_cond_skip(cond);
  cbdatumprintf(reqbody, "&skip=%d", return_value_est_cond_skip$12);
  signed int return_value_est_cond_mask$13;
  return_value_est_cond_mask$13=est_cond_mask(cond);
  cbdatumprintf(reqbody, "&mask=%d", return_value_est_cond_mask$13);
  resheads=cbmapopenex(31);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$14;
  return_value_cbdatumptr$14=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$15;
  return_value_cbdatumsize$15=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$16;
  return_value_est_url_shuttle$16=est_url_shuttle(buf, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$14, return_value_cbdatumsize$15, &rescode, resheads, resbody);
  if(return_value_est_url_shuttle$16 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  _Bool tmp_if_expr$20;
  signed int return_value_cbstrfwmatch$19;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$24;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  if(!(err == 0))
  {
    cbdatumclose(resbody);
    cbmapclose(resheads);
    cbdatumclose(reqbody);
    cblistclose(reqheads);
    return (struct anonymous$17 *)(void *)0;
  }

  else
  {
    ptr=cbdatumtomalloc(resbody, (signed int *)(void *)0);
    pv=strchr(ptr, 10);
    if(pv == ((char *)NULL) || ptr + 3l >= pv)
    {
      free((void *)ptr);
      cbdatumclose(reqbody);
      cblistclose(reqheads);
      return (struct anonymous$17 *)(void *)0;
    }

    else
    {
      *pv = (char)0;
      if((signed int)pv[-1l] == 13)
        pv[(signed long int)-1] = (char)0;

      unsigned long int return_value_strlen$17;
      return_value_strlen$17=strlen(ptr);
      plen = (signed int)return_value_strlen$17;
      pv = pv + 1l;
      ep = pv;
      nres=est_noderes_new();
      part = 0;
      end = 0;
      while(!((signed int)*ep == 0))
      {
        if(*ep == *ptr)
        {
          return_value_cbstrfwmatch$19=cbstrfwmatch(ep, ptr);
          tmp_if_expr$20 = return_value_cbstrfwmatch$19 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$20 = (_Bool)0;
        if(tmp_if_expr$20)
          tmp_if_expr$21 = (signed int)ep[(signed long int)-1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$21 = (_Bool)0;
        if(tmp_if_expr$21)
        {
          if((signed int)ep[(signed long int)plen] == 13)
            tmp_if_expr$22 = (_Bool)1;

          else
            tmp_if_expr$22 = (signed int)ep[(signed long int)plen] == 10 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$22)
            tmp_if_expr$23 = (_Bool)1;

          else
            tmp_if_expr$23 = (signed int)ep[(signed long int)plen] == 58 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$24 = tmp_if_expr$23 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$24 = (_Bool)0;
        if(tmp_if_expr$24)
        {
          *ep = (char)0;
          if(part == 0)
            est_parse_search_header(nres, pv);

          else
            est_parse_search_body(nres, pv);
          ep = ep + (signed long int)plen;
          signed int return_value_cbstrfwmatch$18;
          return_value_cbstrfwmatch$18=cbstrfwmatch(ep, ":END");
          if(!(return_value_cbstrfwmatch$18 == 0))
          {
            end = 1;
            break;
          }

          if((signed int)*ep == 13)
            ep = ep + 1l;

          if((signed int)*ep == 10)
            ep = ep + 1l;

          pv = ep;
          part = part + 1;
        }

        else
          ep = ep + 1l;
      }
      free((void *)ptr);
      cbuf=cbmapget(resheads, "last-modified", -1, (signed int *)(void *)0);
      if(!(cbuf == ((const char *)NULL)))
        nres->mdate=cbstrmktime(cbuf);

      else
        nres->mdate=time((signed long int *)(void *)0);
      cbmapclose(resheads);
      cbdatumclose(reqbody);
      cblistclose(reqheads);
      if(end == 0)
      {
        est_noderes_delete(nres);
        return (struct anonymous$17 *)(void *)0;
      }

      else
        return nres;
    }
  }
}

// est_node_set_auth
// file estnode.c line 391
void est_node_set_auth(struct anonymous$24 *node, const char *name, const char *passwd)
{
  free((void *)node->auth);
  node->auth=cbsprintf("%s:%s", name, passwd);
}

// est_node_set_info
// file estnode.c line 1951
static signed int est_node_set_info(struct anonymous$24 *node)
{
  struct anonymous$1 *reqheads;
  struct anonymous$1 *elems;
  struct anonymous$2 *resbody;
  const char *kbuf;
  const char *ptr;
  const char *pv;
  const char *tv;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err;
  signed int tc;
  err = 0;
  sprintf(url, "%s/inform", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  node->dnum = -1;
  node->wnum = -1;
  node->size = -1.0;
  if(!(node->admins == ((struct anonymous$1 *)NULL)))
  {
    cblistclose(node->admins);
    node->admins = (struct anonymous$1 *)(void *)0;
  }

  if(!(node->users == ((struct anonymous$1 *)NULL)))
  {
    cblistclose(node->users);
    node->users = (struct anonymous$1 *)(void *)0;
  }

  if(!(node->links == ((struct anonymous$1 *)NULL)))
  {
    cblistclose(node->links);
    node->links = (struct anonymous$1 *)(void *)0;
  }

  resbody=cbdatumopen((const char *)(void *)0, -1);
  signed int return_value_est_url_shuttle$3;
  return_value_est_url_shuttle$3=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, (const char *)(void *)0, -1, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$3 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  const char *return_value_cblistval$4;
  const char *return_value_cblistval$5;
  if(err == 0)
  {
    ptr=cbdatumptr(resbody);
    pv=strchr(ptr, 10);
    if(!(pv == ((const char *)NULL)))
    {
      elems=cbsplit(ptr, (signed int)(pv - ptr), "\t");
      signed int return_value_cblistnum$9;
      return_value_cblistnum$9=cblistnum(elems);
      if(return_value_cblistnum$9 == 5)
      {
        if(node->name == ((char *)NULL))
        {
          return_value_cblistval$4=cblistval(elems, 0, (signed int *)(void *)0);
          node->name=cbmemdup(return_value_cblistval$4, -1);
        }

        if(node->label == ((char *)NULL))
        {
          return_value_cblistval$5=cblistval(elems, 1, (signed int *)(void *)0);
          node->label=cbmemdup(return_value_cblistval$5, -1);
        }

        const char *return_value_cblistval$6;
        return_value_cblistval$6=cblistval(elems, 2, (signed int *)(void *)0);
        node->dnum=atoi(return_value_cblistval$6);
        const char *return_value_cblistval$7;
        return_value_cblistval$7=cblistval(elems, 3, (signed int *)(void *)0);
        node->wnum=atoi(return_value_cblistval$7);
        const char *return_value_cblistval$8;
        return_value_cblistval$8=cblistval(elems, 4, (signed int *)(void *)0);
        node->size=strtod(return_value_cblistval$8, (char ** restrict )(void *)0);
        if(!(node->dnum >= 0))
        {
          node->dnum = -1;
          err = 1;
        }

        if(!(node->wnum >= 0))
        {
          node->wnum = -1;
          err = 1;
        }

        if(node->size < 0.0)
        {
          node->size = -1.0;
          err = 1;
        }

        ptr = pv;
        ptr = ptr + 1l;
        if((signed int)*ptr == 10)
          ptr = ptr + 1l;

        node->admins=cblistopen();
        do
        {
          pv=strchr(ptr, 10);
          if(pv == ((const char *)NULL))
            break;

          if(ptr == pv)
          {
            ptr = pv + (signed long int)1;
            break;
          }

          cblistpush(node->admins, ptr, (signed int)(pv - ptr));
          ptr = pv + (signed long int)1;
        }
        while((_Bool)1);
        if((signed int)*pv == 10)
          pv = pv + 1l;

        node->users=cblistopen();
        do
        {
          pv=strchr(ptr, 10);
          if(pv == ((const char *)NULL))
            break;

          if(ptr == pv)
          {
            ptr = pv + (signed long int)1;
            break;
          }

          cblistpush(node->users, ptr, (signed int)(pv - ptr));
          ptr = pv + (signed long int)1;
        }
        while((_Bool)1);
        if((signed int)*pv == 10)
          pv = pv + 1l;

        node->links=cblistopen();
        do
        {
          pv=strchr(ptr, 10);
          if(pv == ((const char *)NULL))
            break;

          if(ptr == pv)
          {
            ptr = pv + (signed long int)1;
            break;
          }

          tc = 0;
          tv = ptr;
          for( ; !(tv >= pv); tv = tv + 1l)
            if((signed int)*tv == 9)
              tc = tc + 1;

          if(tc == 2)
            cblistpush(node->links, ptr, (signed int)(pv - ptr));

          ptr = pv + (signed long int)1;
        }
        while((_Bool)1);
      }

      else
        err = 1;
      cblistclose(elems);
    }

    else
      err = 1;
  }

  cbdatumclose(resbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_set_link
// file estnode.c line 1248
signed int est_node_set_link(struct anonymous$24 *node, const char *url, const char *label, signed int credit)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char myurl[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(myurl, "%s/_set_link", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  if(credit >= 0)
    cbdatumprintf(reqbody, "url=%?&label=%?&credit=%d", url, label, credit);

  else
    cbdatumprintf(reqbody, "url=%?&label=%?", url, label);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(myurl, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_set_proxy
// file estnode.c line 375
void est_node_set_proxy(struct anonymous$24 *node, const char *host, signed int port)
{
  free((void *)node->pxhost);
  node->pxhost=cbmemdup(host, -1);
  node->pxport = port;
}

// est_node_set_snippet_width
// file estnode.c line 1199
void est_node_set_snippet_width(struct anonymous$24 *node, signed int wwidth, signed int hwidth, signed int awidth)
{
  node->wwidth = wwidth;
  if(hwidth >= 0)
    node->hwidth = hwidth;

  if(awidth >= 0)
    node->awidth = awidth;

}

// est_node_set_timeout
// file estnode.c line 384
void est_node_set_timeout(struct anonymous$24 *node, signed int sec)
{
  node->timeout = sec;
}

// est_node_set_user
// file estnode.c line 1208
signed int est_node_set_user(struct anonymous$24 *node, const char *name, signed int mode)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/_set_user", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "name=%?&mode=%d", name, mode);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_size
// file estnode.c line 1000
double est_node_size(struct anonymous$24 *node)
{
  if(node->size >= 0.0)
    return node->size;

  else
  {
    est_node_set_info(node);
    return node->size;
  }
}

// est_node_status
// file estnode.c line 399
signed int est_node_status(struct anonymous$24 *node)
{
  return node->status;
}

// est_node_sync
// file estnode.c line 406
signed int est_node_sync(struct anonymous$24 *node)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err = 0;
  sprintf(url, "%s/sync", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, (struct anonymous$2 *)(void *)0);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return err != 0 ? 0 : 1;
}

// est_node_uri_to_id
// file estnode.c line 923
signed int est_node_uri_to_id(struct anonymous$24 *node, const char *uri)
{
  struct anonymous$1 *reqheads;
  struct anonymous$2 *reqbody;
  struct anonymous$2 *resbody;
  const char *kbuf;
  char url[4096l];
  char *vbuf;
  signed int rescode;
  signed int err;
  signed int id;
  err = 0;
  sprintf(url, "%s/uri_to_id", node->url);
  reqheads=cblistopen();
  signed int return_value_cbmaprnum$2;
  return_value_cbmaprnum$2=cbmaprnum(node->heads);
  if(return_value_cbmaprnum$2 >= 1)
  {
    cbmapiterinit(node->heads);
    do
    {
      kbuf=cbmapiternext(node->heads, (signed int *)(void *)0);
      if(kbuf == ((const char *)NULL))
        break;

      const char *return_value_cbmapiterval$1;
      return_value_cbmapiterval$1=cbmapiterval(kbuf, (signed int *)(void *)0);
      vbuf=cbsprintf("%s: %s", kbuf, return_value_cbmapiterval$1);
      cblistpush(reqheads, vbuf, -1);
      free((void *)vbuf);
    }
    while((_Bool)1);
  }

  cblistpush(reqheads, "Content-Type: application/x-www-form-urlencoded", -1);
  reqbody=cbdatumopen((const char *)(void *)0, -1);
  cbdatumprintf(reqbody, "uri=%?", uri);
  resbody=cbdatumopen((const char *)(void *)0, -1);
  const char *return_value_cbdatumptr$3;
  return_value_cbdatumptr$3=cbdatumptr(reqbody);
  signed int return_value_cbdatumsize$4;
  return_value_cbdatumsize$4=cbdatumsize(reqbody);
  signed int return_value_est_url_shuttle$5;
  return_value_est_url_shuttle$5=est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, 1048576 * 128, node->auth, reqheads, return_value_cbdatumptr$3, return_value_cbdatumsize$4, &rescode, (struct anonymous$9 *)(void *)0, resbody);
  if(return_value_est_url_shuttle$5 == 0)
  {
    node->status = -1;
    err = 1;
  }

  if(err == 0)
  {
    node->status = rescode;
    if(!(rescode == 200))
      err = 1;

  }

  signed int tmp_if_expr$8;
  const char *return_value_cbdatumptr$6;
  signed int return_value_atoi$7;
  if(!(err == 0))
    tmp_if_expr$8 = -1;

  else
  {
    return_value_cbdatumptr$6=cbdatumptr(resbody);
    return_value_atoi$7=atoi(return_value_cbdatumptr$6);
    tmp_if_expr$8 = return_value_atoi$7;
  }
  id = tmp_if_expr$8;
  cbdatumclose(resbody);
  cbdatumclose(reqbody);
  cblistclose(reqheads);
  return id;
}

// est_node_users
// file estnode.c line 1055
const struct anonymous$1 * est_node_users(struct anonymous$24 *node)
{
  if(!(node->users == ((struct anonymous$1 *)NULL)))
    return node->users;

  else
  {
    est_node_set_info(node);
    return node->users;
  }
}

// est_node_word_num
// file estnode.c line 991
signed int est_node_word_num(struct anonymous$24 *node)
{
  if(node->wnum >= 0)
    return node->wnum;

  else
  {
    est_node_set_info(node);
    return node->wnum;
  }
}

// est_noderes_add_doc
// file estnode.c line 1673
void est_noderes_add_doc(struct anonymous$17 *nres, struct anonymous$9 *attrs, char *snippet)
{
  const char *uri;
  signed int idx;
  uri=cbmapget(attrs, "@uri", -1, (signed int *)(void *)0);
  if(uri == ((const char *)NULL))
  {
    free((void *)snippet);
    cbmapclose(attrs);
  }

  else
  {
    if(nres->dnum + nres->top >= nres->max)
    {
      nres->max = nres->max * 2;
      void *return_value_cbrealloc$1;
      return_value_cbrealloc$1=cbrealloc((void *)nres->docs, (unsigned long int)nres->max * sizeof(struct _ESTRESDOC) /*56ul*/ );
      nres->docs = (struct _ESTRESDOC *)return_value_cbrealloc$1;
    }

    idx = nres->top + nres->dnum;
    (nres->docs + (signed long int)idx)->uri = uri;
    (nres->docs + (signed long int)idx)->attrs = attrs;
    (nres->docs + (signed long int)idx)->snippet = snippet;
    (nres->docs + (signed long int)idx)->kwords = (struct anonymous$9 *)(void *)0;
    (nres->docs + (signed long int)idx)->similarity = -1.0;
    (nres->docs + (signed long int)idx)->children = (struct _ESTRESDOC **)(void *)0;
    (nres->docs + (signed long int)idx)->cnum = 0;
    nres->dnum = nres->dnum + 1;
  }
}

// est_noderes_delete
// file estnode.c line 147
void est_noderes_delete(struct anonymous$17 *nres)
{
  struct _ESTRESDOC *docs;
  signed int i;
  signed int dnum;
  cbmapclose(nres->hints);
  free((void *)nres->survivors);
  docs = nres->docs + (signed long int)nres->top;
  dnum = nres->dnum;
  i = 0;
  for( ; !(i >= dnum); i = i + 1)
  {
    free((void *)(nres->docs + (signed long int)i)->children);
    if(!((docs + (signed long int)i)->kwords == ((struct anonymous$9 *)NULL)))
      cbmapclose((docs + (signed long int)i)->kwords);

    free((void *)(docs + (signed long int)i)->snippet);
    cbmapclose((docs + (signed long int)i)->attrs);
  }
  free((void *)nres->docs);
  free((void *)nres);
}

// est_noderes_doc_num
// file estnode.c line 240
signed int est_noderes_doc_num(struct anonymous$17 *nres)
{
  signed int tmp_if_expr$1;
  if(!(nres->survivors == ((struct _ESTRESDOC **)NULL)))
    tmp_if_expr$1 = nres->snum;

  else
    tmp_if_expr$1 = nres->dnum;
  return tmp_if_expr$1;
}

// est_noderes_eclipse
// file estnode.c line 174
void est_noderes_eclipse(struct anonymous$17 *nres, signed int num, double limit)
{
  struct _ESTRESDOC *docs;
  struct anonymous$1 *fields;
  struct anonymous$9 *kwords;
  const char *kbuf;
  const char *vbuf;
  signed int i;
  signed int j;
  signed int dnum;
  signed int ksiz;
  signed int vsiz;
  signed int snum;
  signed int vnum;
  signed int svec[256l];
  signed int tvec[256l];
  double dval;
  docs = nres->docs + (signed long int)nres->top;
  dnum = nres->dnum;
  signed int return_value_cblistnum$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  signed int return_value_cbmaprnum$3;
  void *return_value_cbmalloc$5;
  signed int tmp_post$6;
  signed int tmp_post$8;
  if(!(num >= 1))
  {
    i = 0;
    for( ; !(i >= dnum); i = i + 1)
    {
      (docs + (signed long int)i)->cnum = 0;
      (docs + (signed long int)i)->similarity = -1.0;
    }
    free((void *)nres->survivors);
    nres->survivors = (struct _ESTRESDOC **)(void *)0;
    nres->snum = 0;
  }

  else
  {
    i = 0;
    for( ; !(i >= dnum); i = i + 1)
      if((docs + (signed long int)i)->kwords == ((struct anonymous$9 *)NULL))
      {
        vbuf=cbmapget((docs + (signed long int)i)->attrs, "%VECTOR", -1, &vsiz);
        if(!(vbuf == ((const char *)NULL)) && vsiz >= 0)
        {
          kwords=cbmapopenex(31);
          fields=cbsplit(vbuf, vsiz, "\t");
          j = 0;
          do
          {
            return_value_cblistnum$1=cblistnum(fields);
            if(j >= return_value_cblistnum$1 + -1)
              break;

            kbuf=cblistval(fields, j, &ksiz);
            vbuf=cblistval(fields, j + 1, &vsiz);
            cbmapput(kwords, kbuf, ksiz, vbuf, vsiz, 0);
            j = j + 2;
          }
          while((_Bool)1);
          cblistclose(fields);
          (docs + (signed long int)i)->kwords = kwords;
          (docs + (signed long int)i)->cnum = 0;
          (docs + (signed long int)i)->similarity = -1.0;
        }

      }

    snum = 0;
    i = 0;
    for( ; !(i >= dnum) && !(snum >= num); i = i + 1)
      if(!((docs + (signed long int)i)->similarity >= 0.0))
      {
        if(!((docs + (signed long int)i)->kwords == ((struct anonymous$9 *)NULL)))
        {
          vnum=cbmaprnum((docs + (signed long int)i)->kwords);
          if(vnum >= 1)
          {
            vnum = vnum < 256 ? vnum : 256;
            est_vector_set_seed((docs + (signed long int)i)->kwords, svec, vnum);
            j = i + 1;
            for( ; !(j >= dnum); j = j + 1)
            {
              if((docs + (signed long int)j)->similarity >= 0.0)
                tmp_if_expr$2 = (_Bool)1;

              else
                tmp_if_expr$2 = !((docs + (signed long int)j)->kwords != ((struct anonymous$9 *)NULL)) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$2)
                tmp_if_expr$4 = (_Bool)1;

              else
              {
                return_value_cbmaprnum$3=cbmaprnum((docs + (signed long int)j)->kwords);
                tmp_if_expr$4 = return_value_cbmaprnum$3 < 1 ? (_Bool)1 : (_Bool)0;
              }
              if(!tmp_if_expr$4)
              {
                est_vector_set_target((docs + (signed long int)i)->kwords, (docs + (signed long int)j)->kwords, tvec, vnum);
                dval=est_vector_cosine(svec, tvec, vnum);
                if(dval > limit)
                {
                  if(!((docs + (signed long int)i)->cnum >= 64))
                  {
                    if((docs + (signed long int)i)->children == ((struct _ESTRESDOC **)NULL))
                    {
                      return_value_cbmalloc$5=cbmalloc((unsigned long int)64 * sizeof(struct _ESTRESDOC *) /*8ul*/ );
                      (docs + (signed long int)i)->children = (struct _ESTRESDOC **)return_value_cbmalloc$5;
                    }

                    tmp_post$6 = (docs + (signed long int)i)->cnum;
                    (docs + (signed long int)i)->cnum = (docs + (signed long int)i)->cnum + 1;
                    (docs + (signed long int)i)->children[(signed long int)tmp_post$6] = docs + (signed long int)j;
                    (docs + (signed long int)j)->similarity = dval;
                  }

                }

              }

            }
          }

        }

        snum = snum + 1;
      }

    free((void *)nres->survivors);
    void *return_value_cbmalloc$7;
    return_value_cbmalloc$7=cbmalloc((unsigned long int)dnum * sizeof(struct _ESTRESDOC *) /*8ul*/  + (unsigned long int)1);
    nres->survivors = (struct _ESTRESDOC **)return_value_cbmalloc$7;
    snum = 0;
    i = 0;
    for( ; !(i >= dnum); i = i + 1)
      if(!((docs + (signed long int)i)->similarity >= 0.0))
      {
        tmp_post$8 = snum;
        snum = snum + 1;
        nres->survivors[(signed long int)tmp_post$8] = docs + (signed long int)i;
      }

    nres->snum = snum;
  }
}

// est_noderes_get_doc
// file estnode.c line 247
struct _ESTRESDOC * est_noderes_get_doc(struct anonymous$17 *nres, signed int index)
{
  if(!(nres->survivors == ((struct _ESTRESDOC **)NULL)))
  {
    if(index >= nres->snum)
      return (struct _ESTRESDOC *)(void *)0;

    return nres->survivors[(signed long int)index];
  }

  else
    if(index >= nres->dnum)
      return (struct _ESTRESDOC *)(void *)0;

    else
      return nres->docs + (signed long int)(nres->top + index);
}

// est_noderes_hints
// file estnode.c line 167
struct anonymous$9 * est_noderes_hints(struct anonymous$17 *nres)
{
  return nres->hints;
}

// est_noderes_mdate
// file estnode.c line 1713
signed long int est_noderes_mdate(struct anonymous$17 *nres)
{
  return nres->mdate;
}

// est_noderes_new
// file estnode.c line 1657
struct anonymous$17 * est_noderes_new(void)
{
  struct anonymous$17 *nres;
  void *return_value_cbmalloc$1;
  return_value_cbmalloc$1=cbmalloc(sizeof(struct anonymous$17) /*56ul*/ );
  nres = (struct anonymous$17 *)return_value_cbmalloc$1;
  nres->top = 0;
  nres->max = 64;
  void *return_value_cbmalloc$2;
  return_value_cbmalloc$2=cbmalloc(sizeof(struct _ESTRESDOC) /*56ul*/  * (unsigned long int)nres->max);
  nres->docs = (struct _ESTRESDOC *)return_value_cbmalloc$2;
  nres->dnum = 0;
  nres->survivors = (struct _ESTRESDOC **)(void *)0;
  nres->snum = 0;
  nres->hints=cbmapopenex(31);
  nres->mdate = (signed long int)0;
  return nres;
}

// est_noderes_shift_doc
// file estnode.c line 1699
signed int est_noderes_shift_doc(struct anonymous$17 *nres, struct anonymous$9 **attrp, char **snippetp)
{
  if(!(nres->dnum >= 1))
    return 0;

  else
  {
    *attrp = (nres->docs + (signed long int)nres->top)->attrs;
    *snippetp = (nres->docs + (signed long int)nres->top)->snippet;
    if(!((nres->docs + (signed long int)nres->top)->kwords == ((struct anonymous$9 *)NULL)))
      cbmapclose((nres->docs + (signed long int)nres->top)->kwords);

    free((void *)(nres->docs + (signed long int)nres->top)->children);
    nres->top = nres->top + 1;
    nres->dnum = nres->dnum - 1;
    return 1;
  }
}

// est_normalize_text
// file estraier.c line 5950
static void est_normalize_text(unsigned char *utext, signed int size, signed int *sp)
{
  signed int i;
  signed int wi;
  signed int b1;
  signed int b2;
  wi = 0;
  i = 0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  signed int tmp_post$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  signed int tmp_post$13;
  signed int tmp_post$14;
  signed int tmp_post$15;
  signed int tmp_post$16;
  signed int tmp_post$17;
  signed int tmp_post$18;
  signed int tmp_post$19;
  signed int tmp_post$20;
  signed int tmp_post$21;
  signed int tmp_post$22;
  signed int tmp_post$23;
  signed int tmp_post$24;
  signed int tmp_post$25;
  signed int tmp_post$26;
  signed int tmp_post$27;
  signed int tmp_post$28;
  signed int tmp_post$29;
  signed int tmp_post$30;
  signed int tmp_post$31;
  signed int tmp_post$32;
  signed int tmp_post$33;
  signed int tmp_post$34;
  signed int tmp_post$35;
  signed int tmp_post$36;
  signed int tmp_post$37;
  signed int tmp_post$38;
  signed int tmp_post$39;
  signed int tmp_post$40;
  signed int tmp_post$41;
  signed int tmp_post$42;
  signed int tmp_post$43;
  signed int tmp_post$44;
  signed int tmp_post$45;
  signed int tmp_post$46;
  signed int tmp_post$47;
  signed int tmp_post$48;
  signed int tmp_post$49;
  signed int tmp_post$50;
  signed int tmp_post$51;
  signed int tmp_post$52;
  signed int tmp_post$53;
  signed int tmp_post$54;
  signed int tmp_post$55;
  signed int tmp_post$56;
  signed int tmp_post$57;
  signed int tmp_post$58;
  signed int tmp_post$59;
  signed int tmp_post$60;
  signed int tmp_post$61;
  signed int tmp_post$62;
  signed int tmp_post$63;
  signed int tmp_post$64;
  signed int tmp_post$65;
  signed int tmp_post$66;
  signed int tmp_post$67;
  signed int tmp_post$68;
  signed int tmp_post$69;
  signed int tmp_post$70;
  signed int tmp_post$71;
  signed int tmp_post$72;
  signed int tmp_post$73;
  signed int tmp_post$74;
  signed int tmp_post$75;
  signed int tmp_post$76;
  signed int tmp_post$77;
  signed int tmp_post$78;
  signed int tmp_post$79;
  signed int tmp_post$80;
  signed int tmp_post$81;
  signed int tmp_post$82;
  signed int tmp_post$83;
  signed int tmp_post$84;
  signed int tmp_post$85;
  signed int tmp_post$86;
  signed int tmp_post$87;
  signed int tmp_post$88;
  signed int tmp_post$89;
  signed int tmp_post$90;
  signed int tmp_post$91;
  signed int tmp_post$92;
  signed int tmp_post$93;
  signed int tmp_post$94;
  signed int tmp_post$95;
  signed int tmp_post$96;
  signed int tmp_post$97;
  signed int tmp_post$98;
  signed int tmp_post$99;
  signed int tmp_post$100;
  signed int tmp_post$101;
  signed int tmp_post$102;
  signed int tmp_post$103;
  signed int tmp_post$104;
  signed int tmp_post$105;
  signed int tmp_post$106;
  _Bool tmp_if_expr$107;
  signed int tmp_post$108;
  signed int tmp_post$109;
  signed int tmp_post$110;
  signed int tmp_post$111;
  signed int tmp_post$112;
  signed int tmp_post$113;
  signed int tmp_post$114;
  signed int tmp_post$115;
  signed int tmp_post$116;
  signed int tmp_post$117;
  signed int tmp_post$118;
  signed int tmp_post$119;
  signed int tmp_post$120;
  signed int tmp_post$121;
  for( ; !(i >= size + -1); i = i + 2)
  {
    b1 = (signed int)utext[(signed long int)i];
    b2 = (signed int)utext[(signed long int)(i + 1)];
    if(b1 == 0x0)
    {
      if(b2 >= 0x0e && !(b2 >= 32) || !(b2 >= 9))
      {
        tmp_post$1 = wi;
        wi = wi + 1;
        utext[(signed long int)tmp_post$1] = (unsigned char)0x0;
        tmp_post$2 = wi;
        wi = wi + 1;
        utext[(signed long int)tmp_post$2] = (unsigned char)0x20;
      }

      else
        if(b2 == 0xa0)
        {
          tmp_post$3 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post$3] = (unsigned char)0x0;
          tmp_post$4 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post$4] = (unsigned char)0x20;
        }

        else
        {
          tmp_post$5 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post$5] = (unsigned char)b1;
          tmp_post$6 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post$6] = (unsigned char)b2;
        }
    }

    else
      if(b1 == 0x20)
      {
        if(b2 == 0x2)
        {
          tmp_post$7 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post$7] = (unsigned char)0x0;
          tmp_post$8 = wi;
          wi = wi + 1;
          utext[(signed long int)tmp_post$8] = (unsigned char)0x20;
        }

        else
          if(b2 == 0x3)
          {
            tmp_post$9 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post$9] = (unsigned char)0x0;
            tmp_post$10 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post$10] = (unsigned char)0x20;
          }

          else
            if(b2 == 0x9)
            {
              tmp_post$11 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$11] = (unsigned char)0x0;
              tmp_post$12 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$12] = (unsigned char)0x20;
            }

            else
              if(b2 == 0x10)
              {
                tmp_post$13 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post$13] = (unsigned char)0x0;
                tmp_post$14 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post$14] = (unsigned char)0x2d;
              }

              else
                if(b2 == 0x15)
                {
                  tmp_post$15 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post$15] = (unsigned char)0x0;
                  tmp_post$16 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post$16] = (unsigned char)0x2d;
                }

                else
                  if(b2 == 0x19)
                  {
                    tmp_post$17 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post$17] = (unsigned char)0x0;
                    tmp_post$18 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post$18] = (unsigned char)0x27;
                  }

                  else
                    if(b2 == 0x33)
                    {
                      tmp_post$19 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post$19] = (unsigned char)0x0;
                      tmp_post$20 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post$20] = (unsigned char)0x22;
                    }

                    else
                    {
                      tmp_post$21 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post$21] = (unsigned char)b1;
                      tmp_post$22 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post$22] = (unsigned char)b2;
                    }
      }

      else
        if(b1 == 0x22)
        {
          if(b2 == 0x12)
          {
            tmp_post$23 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post$23] = (unsigned char)0x0;
            tmp_post$24 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post$24] = (unsigned char)0x2d;
          }

          else
          {
            tmp_post$25 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post$25] = (unsigned char)b1;
            tmp_post$26 = wi;
            wi = wi + 1;
            utext[(signed long int)tmp_post$26] = (unsigned char)b2;
          }
        }

        else
          if(b1 == 0x30)
          {
            if(b2 == 0x0)
            {
              tmp_post$27 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$27] = (unsigned char)0x0;
              tmp_post$28 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$28] = (unsigned char)0x20;
            }

            else
            {
              tmp_post$29 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$29] = (unsigned char)b1;
              tmp_post$30 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$30] = (unsigned char)b2;
            }
          }

          else
            if(b1 == 0xff)
            {
              if(b2 == 0x01)
              {
                tmp_post$31 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post$31] = (unsigned char)0x0;
                tmp_post$32 = wi;
                wi = wi + 1;
                utext[(signed long int)tmp_post$32] = (unsigned char)0x21;
              }

              else
                if(b2 == 0x03)
                {
                  tmp_post$33 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post$33] = (unsigned char)0x0;
                  tmp_post$34 = wi;
                  wi = wi + 1;
                  utext[(signed long int)tmp_post$34] = (unsigned char)0x23;
                }

                else
                  if(b2 == 0x04)
                  {
                    tmp_post$35 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post$35] = (unsigned char)0x0;
                    tmp_post$36 = wi;
                    wi = wi + 1;
                    utext[(signed long int)tmp_post$36] = (unsigned char)0x24;
                  }

                  else
                    if(b2 == 0x05)
                    {
                      tmp_post$37 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post$37] = (unsigned char)0x0;
                      tmp_post$38 = wi;
                      wi = wi + 1;
                      utext[(signed long int)tmp_post$38] = (unsigned char)0x25;
                    }

                    else
                      if(b2 == 0x06)
                      {
                        tmp_post$39 = wi;
                        wi = wi + 1;
                        utext[(signed long int)tmp_post$39] = (unsigned char)0x0;
                        tmp_post$40 = wi;
                        wi = wi + 1;
                        utext[(signed long int)tmp_post$40] = (unsigned char)0x26;
                      }

                      else
                        if(b2 == 0x0a)
                        {
                          tmp_post$41 = wi;
                          wi = wi + 1;
                          utext[(signed long int)tmp_post$41] = (unsigned char)0x0;
                          tmp_post$42 = wi;
                          wi = wi + 1;
                          utext[(signed long int)tmp_post$42] = (unsigned char)0x2a;
                        }

                        else
                          if(b2 == 0x0b)
                          {
                            tmp_post$43 = wi;
                            wi = wi + 1;
                            utext[(signed long int)tmp_post$43] = (unsigned char)0x0;
                            tmp_post$44 = wi;
                            wi = wi + 1;
                            utext[(signed long int)tmp_post$44] = (unsigned char)0x2b;
                          }

                          else
                            if(b2 == 0x0c)
                            {
                              tmp_post$45 = wi;
                              wi = wi + 1;
                              utext[(signed long int)tmp_post$45] = (unsigned char)0x0;
                              tmp_post$46 = wi;
                              wi = wi + 1;
                              utext[(signed long int)tmp_post$46] = (unsigned char)0x2c;
                            }

                            else
                              if(b2 == 0x0e)
                              {
                                tmp_post$47 = wi;
                                wi = wi + 1;
                                utext[(signed long int)tmp_post$47] = (unsigned char)0x0;
                                tmp_post$48 = wi;
                                wi = wi + 1;
                                utext[(signed long int)tmp_post$48] = (unsigned char)0x2e;
                              }

                              else
                                if(b2 == 0x0f)
                                {
                                  tmp_post$49 = wi;
                                  wi = wi + 1;
                                  utext[(signed long int)tmp_post$49] = (unsigned char)0x0;
                                  tmp_post$50 = wi;
                                  wi = wi + 1;
                                  utext[(signed long int)tmp_post$50] = (unsigned char)0x2f;
                                }

                                else
                                  if(b2 == 0x1a)
                                  {
                                    tmp_post$51 = wi;
                                    wi = wi + 1;
                                    utext[(signed long int)tmp_post$51] = (unsigned char)0x0;
                                    tmp_post$52 = wi;
                                    wi = wi + 1;
                                    utext[(signed long int)tmp_post$52] = (unsigned char)0x3a;
                                  }

                                  else
                                    if(b2 == 0x1b)
                                    {
                                      tmp_post$53 = wi;
                                      wi = wi + 1;
                                      utext[(signed long int)tmp_post$53] = (unsigned char)0x0;
                                      tmp_post$54 = wi;
                                      wi = wi + 1;
                                      utext[(signed long int)tmp_post$54] = (unsigned char)0x3b;
                                    }

                                    else
                                      if(b2 == 0x1d)
                                      {
                                        tmp_post$55 = wi;
                                        wi = wi + 1;
                                        utext[(signed long int)tmp_post$55] = (unsigned char)0x0;
                                        tmp_post$56 = wi;
                                        wi = wi + 1;
                                        utext[(signed long int)tmp_post$56] = (unsigned char)0x3d;
                                      }

                                      else
                                        if(b2 == 0x1f)
                                        {
                                          tmp_post$57 = wi;
                                          wi = wi + 1;
                                          utext[(signed long int)tmp_post$57] = (unsigned char)0x0;
                                          tmp_post$58 = wi;
                                          wi = wi + 1;
                                          utext[(signed long int)tmp_post$58] = (unsigned char)0x3f;
                                        }

                                        else
                                          if(b2 == 0x20)
                                          {
                                            tmp_post$59 = wi;
                                            wi = wi + 1;
                                            utext[(signed long int)tmp_post$59] = (unsigned char)0x0;
                                            tmp_post$60 = wi;
                                            wi = wi + 1;
                                            utext[(signed long int)tmp_post$60] = (unsigned char)0x40;
                                          }

                                          else
                                            if(b2 == 0x3c)
                                            {
                                              tmp_post$61 = wi;
                                              wi = wi + 1;
                                              utext[(signed long int)tmp_post$61] = (unsigned char)0x0;
                                              tmp_post$62 = wi;
                                              wi = wi + 1;
                                              utext[(signed long int)tmp_post$62] = (unsigned char)0x5c;
                                            }

                                            else
                                              if(b2 == 0x3e)
                                              {
                                                tmp_post$63 = wi;
                                                wi = wi + 1;
                                                utext[(signed long int)tmp_post$63] = (unsigned char)0x0;
                                                tmp_post$64 = wi;
                                                wi = wi + 1;
                                                utext[(signed long int)tmp_post$64] = (unsigned char)0x5e;
                                              }

                                              else
                                                if(b2 == 0x3f)
                                                {
                                                  tmp_post$65 = wi;
                                                  wi = wi + 1;
                                                  utext[(signed long int)tmp_post$65] = (unsigned char)0x0;
                                                  tmp_post$66 = wi;
                                                  wi = wi + 1;
                                                  utext[(signed long int)tmp_post$66] = (unsigned char)0x5f;
                                                }

                                                else
                                                  if(b2 == 0x5c)
                                                  {
                                                    tmp_post$67 = wi;
                                                    wi = wi + 1;
                                                    utext[(signed long int)tmp_post$67] = (unsigned char)0x0;
                                                    tmp_post$68 = wi;
                                                    wi = wi + 1;
                                                    utext[(signed long int)tmp_post$68] = (unsigned char)0x7c;
                                                  }

                                                  else
                                                    if(b2 >= 0x21 && !(b2 >= 59))
                                                    {
                                                      tmp_post$69 = wi;
                                                      wi = wi + 1;
                                                      utext[(signed long int)tmp_post$69] = (unsigned char)0x0;
                                                      tmp_post$70 = wi;
                                                      wi = wi + 1;
                                                      utext[(signed long int)tmp_post$70] = (unsigned char)((b2 - 0x21) + 0x41);
                                                    }

                                                    else
                                                      if(b2 >= 0x41 && !(b2 >= 91))
                                                      {
                                                        tmp_post$71 = wi;
                                                        wi = wi + 1;
                                                        utext[(signed long int)tmp_post$71] = (unsigned char)0x0;
                                                        tmp_post$72 = wi;
                                                        wi = wi + 1;
                                                        utext[(signed long int)tmp_post$72] = (unsigned char)((b2 - 0x41) + 0x61);
                                                      }

                                                      else
                                                        if(b2 >= 0x10 && !(b2 >= 26))
                                                        {
                                                          tmp_post$73 = wi;
                                                          wi = wi + 1;
                                                          utext[(signed long int)tmp_post$73] = (unsigned char)0x0;
                                                          tmp_post$74 = wi;
                                                          wi = wi + 1;
                                                          utext[(signed long int)tmp_post$74] = (unsigned char)((b2 - 0x10) + 0x30);
                                                        }

                                                        else
                                                          if(b2 == 0x61)
                                                          {
                                                            tmp_post$75 = wi;
                                                            wi = wi + 1;
                                                            utext[(signed long int)tmp_post$75] = (unsigned char)0x30;
                                                            tmp_post$76 = wi;
                                                            wi = wi + 1;
                                                            utext[(signed long int)tmp_post$76] = (unsigned char)0x2;
                                                          }

                                                          else
                                                            if(b2 == 0x62)
                                                            {
                                                              tmp_post$77 = wi;
                                                              wi = wi + 1;
                                                              utext[(signed long int)tmp_post$77] = (unsigned char)0x30;
                                                              tmp_post$78 = wi;
                                                              wi = wi + 1;
                                                              utext[(signed long int)tmp_post$78] = (unsigned char)0xc;
                                                            }

                                                            else
                                                              if(b2 == 0x63)
                                                              {
                                                                tmp_post$79 = wi;
                                                                wi = wi + 1;
                                                                utext[(signed long int)tmp_post$79] = (unsigned char)0x30;
                                                                tmp_post$80 = wi;
                                                                wi = wi + 1;
                                                                utext[(signed long int)tmp_post$80] = (unsigned char)0xd;
                                                              }

                                                              else
                                                                if(b2 == 0x64)
                                                                {
                                                                  tmp_post$81 = wi;
                                                                  wi = wi + 1;
                                                                  utext[(signed long int)tmp_post$81] = (unsigned char)0x30;
                                                                  tmp_post$82 = wi;
                                                                  wi = wi + 1;
                                                                  utext[(signed long int)tmp_post$82] = (unsigned char)0x1;
                                                                }

                                                                else
                                                                  if(b2 == 0x65)
                                                                  {
                                                                    tmp_post$83 = wi;
                                                                    wi = wi + 1;
                                                                    utext[(signed long int)tmp_post$83] = (unsigned char)0x30;
                                                                    tmp_post$84 = wi;
                                                                    wi = wi + 1;
                                                                    utext[(signed long int)tmp_post$84] = (unsigned char)0xfb;
                                                                  }

                                                                  else
                                                                    if(b2 == 0x66)
                                                                    {
                                                                      tmp_post$85 = wi;
                                                                      wi = wi + 1;
                                                                      utext[(signed long int)tmp_post$85] = (unsigned char)0x30;
                                                                      tmp_post$86 = wi;
                                                                      wi = wi + 1;
                                                                      utext[(signed long int)tmp_post$86] = (unsigned char)0xf2;
                                                                    }

                                                                    else
                                                                      if(b2 >= 0x67 && !(b2 >= 108))
                                                                      {
                                                                        tmp_post$87 = wi;
                                                                        wi = wi + 1;
                                                                        utext[(signed long int)tmp_post$87] = (unsigned char)0x30;
                                                                        tmp_post$88 = wi;
                                                                        wi = wi + 1;
                                                                        utext[(signed long int)tmp_post$88] = (unsigned char)((b2 - 0x67) * 2 + 0xa1);
                                                                      }

                                                                      else
                                                                        if(b2 >= 0x6c && !(b2 >= 111))
                                                                        {
                                                                          tmp_post$89 = wi;
                                                                          wi = wi + 1;
                                                                          utext[(signed long int)tmp_post$89] = (unsigned char)0x30;
                                                                          tmp_post$90 = wi;
                                                                          wi = wi + 1;
                                                                          utext[(signed long int)tmp_post$90] = (unsigned char)((b2 - 0x6c) * 2 + 0xe3);
                                                                        }

                                                                        else
                                                                          if(b2 == 0x6f)
                                                                          {
                                                                            tmp_post$91 = wi;
                                                                            wi = wi + 1;
                                                                            utext[(signed long int)tmp_post$91] = (unsigned char)0x30;
                                                                            tmp_post$92 = wi;
                                                                            wi = wi + 1;
                                                                            utext[(signed long int)tmp_post$92] = (unsigned char)0xc3;
                                                                          }

                                                                          else
                                                                            if(b2 == 0x70)
                                                                            {
                                                                              tmp_post$93 = wi;
                                                                              wi = wi + 1;
                                                                              utext[(signed long int)tmp_post$93] = (unsigned char)0x30;
                                                                              tmp_post$94 = wi;
                                                                              wi = wi + 1;
                                                                              utext[(signed long int)tmp_post$94] = (unsigned char)0xfc;
                                                                            }

                                                                            else
                                                                              if(b2 >= 0x71 && !(b2 >= 118))
                                                                              {
                                                                                tmp_post$95 = wi;
                                                                                wi = wi + 1;
                                                                                utext[(signed long int)tmp_post$95] = (unsigned char)0x30;
                                                                                tmp_post$96 = wi;
                                                                                wi = wi + 1;
                                                                                utext[(signed long int)tmp_post$96] = (unsigned char)((b2 - 0x71) * 2 + 0xa2);
                                                                                if(b2 == 0x73 && !(2 + i >= size + -1))
                                                                                {
                                                                                  if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                  {
                                                                                    if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                    {
                                                                                      utext[(signed long int)(wi - 1)] = (unsigned char)0xf4;
                                                                                      i = i + 2;
                                                                                    }

                                                                                  }

                                                                                }

                                                                              }

                                                                              else
                                                                                if(b2 >= 0x76 && !(b2 >= 123))
                                                                                {
                                                                                  tmp_post$97 = wi;
                                                                                  wi = wi + 1;
                                                                                  utext[(signed long int)tmp_post$97] = (unsigned char)0x30;
                                                                                  tmp_post$98 = wi;
                                                                                  wi = wi + 1;
                                                                                  utext[(signed long int)tmp_post$98] = (unsigned char)((b2 - 0x76) * 2 + 0xab);
                                                                                  if(!(2 + i >= size + -1))
                                                                                  {
                                                                                    if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                    {
                                                                                      if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                      {
                                                                                        utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                        i = i + 2;
                                                                                      }

                                                                                    }

                                                                                  }

                                                                                }

                                                                                else
                                                                                  if(b2 >= 0x7b && !(b2 >= 128))
                                                                                  {
                                                                                    tmp_post$99 = wi;
                                                                                    wi = wi + 1;
                                                                                    utext[(signed long int)tmp_post$99] = (unsigned char)0x30;
                                                                                    tmp_post$100 = wi;
                                                                                    wi = wi + 1;
                                                                                    utext[(signed long int)tmp_post$100] = (unsigned char)((b2 - 0x7b) * 2 + 0xb5);
                                                                                    if(!(2 + i >= size + -1))
                                                                                    {
                                                                                      if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                      {
                                                                                        if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                        {
                                                                                          utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                          i = i + 2;
                                                                                        }

                                                                                      }

                                                                                    }

                                                                                  }

                                                                                  else
                                                                                    if(b2 >= 0x80 && !(b2 >= 133))
                                                                                    {
                                                                                      tmp_post$101 = wi;
                                                                                      wi = wi + 1;
                                                                                      utext[(signed long int)tmp_post$101] = (unsigned char)0x30;
                                                                                      tmp_post$102 = wi;
                                                                                      wi = wi + 1;
                                                                                      utext[(signed long int)tmp_post$102] = (unsigned char)((b2 - 0x80) * 2 + 0xbf + (b2 >= 0x82 ? 1 : 0));
                                                                                      if(!(2 + i >= size + -1))
                                                                                      {
                                                                                        if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                        {
                                                                                          if((signed int)utext[(signed long int)(3 + i)] == 0x9e)
                                                                                          {
                                                                                            utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                            i = i + 2;
                                                                                          }

                                                                                        }

                                                                                      }

                                                                                    }

                                                                                    else
                                                                                      if(b2 >= 0x85 && !(b2 >= 138))
                                                                                      {
                                                                                        tmp_post$103 = wi;
                                                                                        wi = wi + 1;
                                                                                        utext[(signed long int)tmp_post$103] = (unsigned char)0x30;
                                                                                        tmp_post$104 = wi;
                                                                                        wi = wi + 1;
                                                                                        utext[(signed long int)tmp_post$104] = (unsigned char)((b2 - 0x85) + 0xca);
                                                                                      }

                                                                                      else
                                                                                        if(b2 >= 0x8a && !(b2 >= 143))
                                                                                        {
                                                                                          tmp_post$105 = wi;
                                                                                          wi = wi + 1;
                                                                                          utext[(signed long int)tmp_post$105] = (unsigned char)0x30;
                                                                                          tmp_post$106 = wi;
                                                                                          wi = wi + 1;
                                                                                          utext[(signed long int)tmp_post$106] = (unsigned char)((b2 - 0x8a) * 3 + 0xcf);
                                                                                          if(!(2 + i >= size + -1))
                                                                                          {
                                                                                            if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                              tmp_if_expr$107 = (signed int)utext[(signed long int)(i + 3)] == 0x9e ? (_Bool)1 : (_Bool)0;

                                                                                            else
                                                                                              tmp_if_expr$107 = (_Bool)0;
                                                                                            if(tmp_if_expr$107)
                                                                                            {
                                                                                              utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)1;
                                                                                              i = i + 2;
                                                                                            }

                                                                                            else
                                                                                              if((signed int)utext[(signed long int)(2 + i)] == 0xff)
                                                                                              {
                                                                                                if((signed int)utext[(signed long int)(3 + i)] == 0x9f)
                                                                                                {
                                                                                                  utext[(signed long int)(wi - 1)] = utext[(signed long int)(wi - 1)] + (unsigned char)2;
                                                                                                  i = i + 2;
                                                                                                }

                                                                                              }

                                                                                          }

                                                                                        }

                                                                                        else
                                                                                          if(b2 >= 0x8f && !(b2 >= 148))
                                                                                          {
                                                                                            tmp_post$108 = wi;
                                                                                            wi = wi + 1;
                                                                                            utext[(signed long int)tmp_post$108] = (unsigned char)0x30;
                                                                                            tmp_post$109 = wi;
                                                                                            wi = wi + 1;
                                                                                            utext[(signed long int)tmp_post$109] = (unsigned char)((b2 - 0x8f) + 0xde);
                                                                                          }

                                                                                          else
                                                                                            if(b2 >= 0x94 && !(b2 >= 151))
                                                                                            {
                                                                                              tmp_post$110 = wi;
                                                                                              wi = wi + 1;
                                                                                              utext[(signed long int)tmp_post$110] = (unsigned char)0x30;
                                                                                              tmp_post$111 = wi;
                                                                                              wi = wi + 1;
                                                                                              utext[(signed long int)tmp_post$111] = (unsigned char)((b2 - 0x94) * 2 + 0xe4);
                                                                                            }

                                                                                            else
                                                                                              if(b2 >= 0x97 && !(b2 >= 156))
                                                                                              {
                                                                                                tmp_post$112 = wi;
                                                                                                wi = wi + 1;
                                                                                                utext[(signed long int)tmp_post$112] = (unsigned char)0x30;
                                                                                                tmp_post$113 = wi;
                                                                                                wi = wi + 1;
                                                                                                utext[(signed long int)tmp_post$113] = (unsigned char)((b2 - 0x97) + 0xe9);
                                                                                              }

                                                                                              else
                                                                                                if(b2 == 0x9c)
                                                                                                {
                                                                                                  tmp_post$114 = wi;
                                                                                                  wi = wi + 1;
                                                                                                  utext[(signed long int)tmp_post$114] = (unsigned char)0x30;
                                                                                                  tmp_post$115 = wi;
                                                                                                  wi = wi + 1;
                                                                                                  utext[(signed long int)tmp_post$115] = (unsigned char)0xef;
                                                                                                }

                                                                                                else
                                                                                                  if(b2 == 0x9d)
                                                                                                  {
                                                                                                    tmp_post$116 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post$116] = (unsigned char)0x30;
                                                                                                    tmp_post$117 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post$117] = (unsigned char)0xf3;
                                                                                                  }

                                                                                                  else
                                                                                                  {
                                                                                                    tmp_post$118 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post$118] = (unsigned char)b1;
                                                                                                    tmp_post$119 = wi;
                                                                                                    wi = wi + 1;
                                                                                                    utext[(signed long int)tmp_post$119] = (unsigned char)b2;
                                                                                                  }
            }

            else
            {
              tmp_post$120 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$120] = (unsigned char)b1;
              tmp_post$121 = wi;
              wi = wi + 1;
              utext[(signed long int)tmp_post$121] = (unsigned char)b2;
            }
  }
  *sp = wi;
}

// est_parse_search_body
// file estnode.c line 2186
static void est_parse_search_body(struct anonymous$17 *nres, char *str)
{
  struct anonymous$9 *attrs;
  char *pv;
  char *ep;
  char *mp;
  pv = str;
  attrs=cbmapopenex(31);
  for( ; (_Bool)1; pv = ep + (signed long int)1)
  {
    ep=strchr(pv, 10);
    if(ep == ((char *)NULL) || ep == pv)
      break;

    *ep = (char)0;
    cbstrtrim(pv);
    if((signed int)*pv == 0)
      break;

    if((signed int)*pv == 37)
    {
      signed int return_value_cbstrfwmatch$1;
      return_value_cbstrfwmatch$1=cbstrfwmatch(pv, "%VECTOR");
      if(!(return_value_cbstrfwmatch$1 == 0))
      {
        pv=strchr(pv, 9);
        if(!(pv == ((char *)NULL)))
          cbmapput(attrs, "%VECTOR", -1, pv + (signed long int)1, -1, 0);

      }

    }

    else
    {
      mp=strchr(pv, 61);
      if(!(mp == ((char *)NULL)))
      {
        *mp = (char)0;
        cbmapput(attrs, pv, -1, mp + (signed long int)1, -1, 1);
      }

    }
  }
  for( ; (_Bool)1; pv = pv + 1l)
    if(!((signed int)*pv == 13))
    {
      if(!((signed int)*pv == 10))
        goto __CPROVER_DUMP_L7;

    }


__CPROVER_DUMP_L7:
  ;
  char *return_value_cbmemdup$2;
  return_value_cbmemdup$2=cbmemdup(pv, -1);
  est_noderes_add_doc(nres, attrs, return_value_cbmemdup$2);
}

// est_parse_search_header
// file estnode.c line 2168
static void est_parse_search_header(struct anonymous$17 *nres, const char *str)
{
  struct anonymous$1 *lines;
  const char *line;
  const char *pv;
  signed int i;
  lines=cbsplit(str, -1, "\r\n");
  i = 0;
  signed int return_value_cblistnum$1;
  _Bool tmp_if_expr$2;
  do
  {
    return_value_cblistnum$1=cblistnum(lines);
    if(i >= return_value_cblistnum$1)
      break;

    line=cblistval(lines, i, (signed int *)(void *)0);
    pv=strchr(line, 9);
    if(pv == ((const char *)NULL) || pv == line)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pv[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
      cbmapput(nres->hints, line, (signed int)(pv - line), pv + (signed long int)1, -1, 0);

    i = i + 1;
  }
  while((_Bool)1);
  cblistclose(lines);
}

// est_phrase_from_isect
// file estraier.c line 6730
static char * est_phrase_from_isect(const char *iphrase)
{
  struct anonymous$2 *datum;
  struct anonymous$1 *terms;
  const char *term;
  unsigned char *utext;
  char *rtext;
  signed int i;
  signed int size;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$1;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(iphrase);
  char *return_value_est_uconv_in$4;
  return_value_est_uconv_in$4=est_uconv_in(iphrase, (signed int)return_value_strlen$3, &size);
  utext = (unsigned char *)return_value_est_uconv_in$4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  terms=cbsplit(rtext, -1, " ");
  i = 0;
  for( ; !(i >= terms->num); i = i + 1)
  {
    size = (terms->array + (signed long int)(terms->start + i))->dsize;
    term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    if(size >= 1)
    {
      if(datum->dsize >= 1)
        do
        {
          if(5 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 5 + 1;
            void *return_value_realloc$5;
            return_value_realloc$5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$5;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" AND ", (unsigned long int)5);
          datum->dsize = datum->dsize + 5;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      do
      {
        if(datum->dsize + size >= datum->asize)
        {
          datum->asize = datum->asize * 2 + size + 1;
          void *return_value_realloc$6;
          return_value_realloc$6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$6;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)term, (unsigned long int)size);
        datum->dsize = datum->dsize + size;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = terms->start + terms->num;
    _CB_i = terms->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(terms->array + (signed long int)_CB_i)->dptr);
    free((void *)terms->array);
    free((void *)terms);
  }
  while((_Bool)0);
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc$7;
  return_value_cbdatumtomalloc$7=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc$7;
}

// est_phrase_from_rough
// file estraier.c line 6632
static char * est_phrase_from_rough(const char *rphrase)
{
  struct anonymous$2 *datum;
  const char *oper;
  const char *rp;
  unsigned char *utext;
  char *rtext;
  signed int size;
  signed int quote;
  signed int lw;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$1;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(rphrase);
  char *return_value_est_uconv_in$4;
  return_value_est_uconv_in$4=est_uconv_in(rphrase, (signed int)return_value_strlen$3, &size);
  utext = (unsigned char *)return_value_est_uconv_in$4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  quote = 0;
  oper = (const char *)(void *)0;
  lw = 0;
  rp = rtext;
  for( ; !((signed int)*rp == 0); rp = rp + 1l)
    if((signed int)*rp == 34)
    {
      if(!(oper == ((const char *)NULL)))
      {
        do
        {
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(oper);
          if(return_value_strlen$7 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
          {
            unsigned long int return_value_strlen$5;
            return_value_strlen$5=strlen(oper);
            datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$5 + (unsigned long int)1);
            void *return_value_realloc$6;
            return_value_realloc$6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$6;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          unsigned long int return_value_strlen$8;
          return_value_strlen$8=strlen(oper);
          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen$8);
          unsigned long int return_value_strlen$9;
          return_value_strlen$9=strlen(oper);
          datum->dsize = datum->dsize + (signed int)return_value_strlen$9;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        oper = (const char *)(void *)0;
      }

      quote = (signed int)!(quote != 0);
    }

    else
      if(!(quote == 0))
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc$10;
            return_value_realloc$10=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$10;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      else
        switch((signed int)*rp)
        {
          case 32:
          {
            if(oper == ((const char *)NULL))
              oper = " AND ";

            lw = 0;
            break;
          }
          case 38:
          {
            oper = " AND ";
            lw = 0;
            break;
          }
          case 124:
          {
            oper = " OR ";
            lw = 0;
            break;
          }
          case 45:
          {
            if(!(lw == 0))
              do
              {
                if(1 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 1 + 1;
                  void *return_value_realloc$11;
                  return_value_realloc$11=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc$11;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
                datum->dsize = datum->dsize + 1;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

            else
              oper = " ANDNOT ";
            break;
          }
          default:
          {
            if(!(oper == ((const char *)NULL)))
            {
              do
              {
                unsigned long int return_value_strlen$14;
                return_value_strlen$14=strlen(oper);
                if(return_value_strlen$14 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                {
                  unsigned long int return_value_strlen$12;
                  return_value_strlen$12=strlen(oper);
                  datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$12 + (unsigned long int)1);
                  void *return_value_realloc$13;
                  return_value_realloc$13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc$13;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                unsigned long int return_value_strlen$15;
                return_value_strlen$15=strlen(oper);
                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen$15);
                unsigned long int return_value_strlen$16;
                return_value_strlen$16=strlen(oper);
                datum->dsize = datum->dsize + (signed int)return_value_strlen$16;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);
              oper = (const char *)(void *)0;
            }

            do
            {
              if(1 + datum->dsize >= datum->asize)
              {
                datum->asize = datum->asize * 2 + 1 + 1;
                void *return_value_realloc$17;
                return_value_realloc$17=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc$17;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
              datum->dsize = datum->dsize + 1;
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);
            lw = 1;
          }
        }
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc$18;
  return_value_cbdatumtomalloc$18=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc$18;
}

// est_phrase_from_simple
// file estraier.c line 6549
static char * est_phrase_from_simple(const char *sphrase)
{
  struct anonymous$2 *datum;
  const char *oper;
  const char *rp;
  const char *pv;
  unsigned char *utext;
  char *rtext;
  signed int size;
  signed int quote;
  signed int lw;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$1;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(sphrase);
  char *return_value_est_uconv_in$4;
  return_value_est_uconv_in$4=est_uconv_in(sphrase, (signed int)return_value_strlen$3, &size);
  utext = (unsigned char *)return_value_est_uconv_in$4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  quote = 0;
  oper = (const char *)(void *)0;
  lw = 0;
  rp = rtext;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$40;
  _Bool tmp_if_expr$38;
  _Bool tmp_if_expr$39;
  for( ; !((signed int)*rp == 0); rp = rp + 1l)
    if((signed int)*rp == 34)
    {
      if(!(oper == ((const char *)NULL)))
      {
        do
        {
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(oper);
          if(return_value_strlen$7 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
          {
            unsigned long int return_value_strlen$5;
            return_value_strlen$5=strlen(oper);
            datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$5 + (unsigned long int)1);
            void *return_value_realloc$6;
            return_value_realloc$6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$6;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          unsigned long int return_value_strlen$8;
          return_value_strlen$8=strlen(oper);
          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen$8);
          unsigned long int return_value_strlen$9;
          return_value_strlen$9=strlen(oper);
          datum->dsize = datum->dsize + (signed int)return_value_strlen$9;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);
        oper = (const char *)(void *)0;
      }

      quote = (signed int)!(quote != 0);
    }

    else
      if(!(quote == 0))
        do
        {
          if(1 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 1 + 1;
            void *return_value_realloc$10;
            return_value_realloc$10=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$10;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
          datum->dsize = datum->dsize + 1;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      else
        switch((signed int)*rp)
        {
          case 32:
          {
            if(oper == ((const char *)NULL))
              oper = " AND ";

            lw = 0;
            break;
          }
          case 38:
          {
            oper = " AND ";
            lw = 0;
            break;
          }
          case 124:
          {
            oper = " OR ";
            lw = 0;
            break;
          }
          case 33:
          {
            oper = " ANDNOT ";
            lw = 0;
            break;
          }
          default:
          {
            if(!(oper == ((const char *)NULL)))
            {
              do
              {
                unsigned long int return_value_strlen$13;
                return_value_strlen$13=strlen(oper);
                if(return_value_strlen$13 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                {
                  unsigned long int return_value_strlen$11;
                  return_value_strlen$11=strlen(oper);
                  datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$11 + (unsigned long int)1);
                  void *return_value_realloc$12;
                  return_value_realloc$12=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc$12;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                unsigned long int return_value_strlen$14;
                return_value_strlen$14=strlen(oper);
                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)oper, return_value_strlen$14);
                unsigned long int return_value_strlen$15;
                return_value_strlen$15=strlen(oper);
                datum->dsize = datum->dsize + (signed int)return_value_strlen$15;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);
              oper = (const char *)(void *)0;
            }

            if(lw == 0)
            {
              pv = rp;
              for( ; !((signed int)*pv == 0); pv = pv + 1l)
                if((signed int)*pv == 32)
                  break;

              if(!(rp + 1l >= pv))
                tmp_if_expr$36 = (signed int)pv[(signed long int)-1] == 42 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$36 = (_Bool)0;
              if(tmp_if_expr$36)
              {
                if((signed int)*rp == 42)
                  do
                  {
                    unsigned long int return_value_strlen$18;
                    return_value_strlen$18=strlen("[RX]");
                    if(1ul + return_value_strlen$18 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                    {
                      unsigned long int return_value_strlen$16;
                      return_value_strlen$16=strlen("[RX]");
                      datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$16 + (unsigned long int)1 + (unsigned long int)1);
                      void *return_value_realloc$17;
                      return_value_realloc$17=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                      datum->dptr = (char *)return_value_realloc$17;
                      if(!(datum->dptr == ((char *)NULL)))
                        datum->dptr;

                      else
                        cbmyfatal("out of memory");
                    }

                    unsigned long int return_value_strlen$19;
                    return_value_strlen$19=strlen("[RX]");
                    memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[RX] ", return_value_strlen$19 + (unsigned long int)1);
                    unsigned long int return_value_strlen$20;
                    return_value_strlen$20=strlen("[RX]");
                    datum->dsize = datum->dsize + (signed int)(return_value_strlen$20 + (unsigned long int)1);
                    datum->dptr[(signed long int)datum->dsize] = (char)0;
                  }
                  while((_Bool)0);

                else
                  do
                  {
                    unsigned long int return_value_strlen$23;
                    return_value_strlen$23=strlen("[BW]");
                    if(1ul + return_value_strlen$23 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                    {
                      unsigned long int return_value_strlen$21;
                      return_value_strlen$21=strlen("[BW]");
                      datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$21 + (unsigned long int)1 + (unsigned long int)1);
                      void *return_value_realloc$22;
                      return_value_realloc$22=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                      datum->dptr = (char *)return_value_realloc$22;
                      if(!(datum->dptr == ((char *)NULL)))
                        datum->dptr;

                      else
                        cbmyfatal("out of memory");
                    }

                    unsigned long int return_value_strlen$24;
                    return_value_strlen$24=strlen("[BW]");
                    memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[BW] ", return_value_strlen$24 + (unsigned long int)1);
                    unsigned long int return_value_strlen$25;
                    return_value_strlen$25=strlen("[BW]");
                    datum->dsize = datum->dsize + (signed int)(return_value_strlen$25 + (unsigned long int)1);
                    datum->dptr[(signed long int)datum->dsize] = (char)0;
                  }
                  while((_Bool)0);
              }

              else
                if(!(rp + 1l >= pv))
                {
                  if((signed int)*rp == 42)
                  {
                    if((signed int)pv[-1l] == 42)
                      do
                      {
                        unsigned long int return_value_strlen$28;
                        return_value_strlen$28=strlen("[RX]");
                        if(1ul + return_value_strlen$28 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                        {
                          unsigned long int return_value_strlen$26;
                          return_value_strlen$26=strlen("[RX]");
                          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$26 + (unsigned long int)1 + (unsigned long int)1);
                          void *return_value_realloc$27;
                          return_value_realloc$27=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                          datum->dptr = (char *)return_value_realloc$27;
                          if(!(datum->dptr == ((char *)NULL)))
                            datum->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        unsigned long int return_value_strlen$29;
                        return_value_strlen$29=strlen("[RX]");
                        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[RX] ", return_value_strlen$29 + (unsigned long int)1);
                        unsigned long int return_value_strlen$30;
                        return_value_strlen$30=strlen("[RX]");
                        datum->dsize = datum->dsize + (signed int)(return_value_strlen$30 + (unsigned long int)1);
                        datum->dptr[(signed long int)datum->dsize] = (char)0;
                      }
                      while((_Bool)0);

                    else
                      do
                      {
                        unsigned long int return_value_strlen$33;
                        return_value_strlen$33=strlen("[EW]");
                        if(1ul + return_value_strlen$33 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                        {
                          unsigned long int return_value_strlen$31;
                          return_value_strlen$31=strlen("[EW]");
                          datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$31 + (unsigned long int)1 + (unsigned long int)1);
                          void *return_value_realloc$32;
                          return_value_realloc$32=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                          datum->dptr = (char *)return_value_realloc$32;
                          if(!(datum->dptr == ((char *)NULL)))
                            datum->dptr;

                          else
                            cbmyfatal("out of memory");
                        }

                        unsigned long int return_value_strlen$34;
                        return_value_strlen$34=strlen("[EW]");
                        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"[EW] ", return_value_strlen$34 + (unsigned long int)1);
                        unsigned long int return_value_strlen$35;
                        return_value_strlen$35=strlen("[EW]");
                        datum->dsize = datum->dsize + (signed int)(return_value_strlen$35 + (unsigned long int)1);
                        datum->dptr[(signed long int)datum->dsize] = (char)0;
                      }
                      while((_Bool)0);
                  }

                }

            }

            if(!((signed int)*rp == 42))
              tmp_if_expr$40 = (_Bool)1;

            else
            {
              if(!(lw == 0))
                tmp_if_expr$38 = (signed int)rp[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$38 = (_Bool)0;
              if(tmp_if_expr$38)
                tmp_if_expr$39 = (signed int)rp[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$39 = (_Bool)0;
              tmp_if_expr$40 = tmp_if_expr$39 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$40)
              do
              {
                if(1 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 1 + 1;
                  void *return_value_realloc$37;
                  return_value_realloc$37=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc$37;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
                datum->dsize = datum->dsize + 1;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

            lw = 1;
          }
        }
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc$41;
  return_value_cbdatumtomalloc$41=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc$41;
}

// est_phrase_from_union
// file estraier.c line 6699
static char * est_phrase_from_union(const char *uphrase)
{
  struct anonymous$2 *datum;
  struct anonymous$1 *terms;
  const char *term;
  unsigned char *utext;
  char *rtext;
  signed int i;
  signed int size;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$1;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$2;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(uphrase);
  char *return_value_est_uconv_in$4;
  return_value_est_uconv_in$4=est_uconv_in(uphrase, (signed int)return_value_strlen$3, &size);
  utext = (unsigned char *)return_value_est_uconv_in$4;
  est_normalize_text(utext, size, &size);
  est_canonicalize_text(utext, size, 0);
  rtext=est_uconv_out((char *)utext, size, (signed int *)(void *)0);
  cbstrsqzspc(rtext);
  terms=cbsplit(rtext, -1, " ");
  i = 0;
  for( ; !(i >= terms->num); i = i + 1)
  {
    size = (terms->array + (signed long int)(terms->start + i))->dsize;
    term = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    if(size >= 1)
    {
      if(datum->dsize >= 1)
        do
        {
          if(4 + datum->dsize >= datum->asize)
          {
            datum->asize = datum->asize * 2 + 4 + 1;
            void *return_value_realloc$5;
            return_value_realloc$5=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
            datum->dptr = (char *)return_value_realloc$5;
            if(!(datum->dptr == ((char *)NULL)))
              datum->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" OR ", (unsigned long int)4);
          datum->dsize = datum->dsize + 4;
          datum->dptr[(signed long int)datum->dsize] = (char)0;
        }
        while((_Bool)0);

      do
      {
        if(datum->dsize + size >= datum->asize)
        {
          datum->asize = datum->asize * 2 + size + 1;
          void *return_value_realloc$6;
          return_value_realloc$6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$6;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)term, (unsigned long int)size);
        datum->dsize = datum->dsize + size;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
    }

  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = terms->start + terms->num;
    _CB_i = terms->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(terms->array + (signed long int)_CB_i)->dptr);
    free((void *)terms->array);
    free((void *)terms);
  }
  while((_Bool)0);
  free((void *)rtext);
  free((void *)utext);
  char *return_value_cbdatumtomalloc$7;
  return_value_cbdatumtomalloc$7=cbdatumtomalloc(datum, (signed int *)(void *)0);
  return return_value_cbdatumtomalloc$7;
}

// est_phrase_terms
// file estraier.c line 8020
static struct anonymous$1 * est_phrase_terms(const char *phrase)
{
  struct anonymous$1 *terms;
  struct anonymous$1 *elems;
  struct anonymous$2 *datum;
  const char *elem;
  char *tbuf;
  char *pbuf;
  signed int i;
  signed int tsiz;
  signed int psiz;
  signed int lw;
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    terms = (struct anonymous$1 *)return_value_malloc$1;
    if(!(terms == ((struct anonymous$1 *)NULL)))
      terms;

    else
      cbmyfatal("out of memory");
    terms->anum = 64;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)terms->anum);
    terms->array = (struct anonymous$28 *)return_value_malloc$2;
    if(!(terms->array == ((struct anonymous$28 *)NULL)))
      terms->array;

    else
      cbmyfatal("out of memory");
    terms->start = 0;
    terms->num = 0;
  }
  while((_Bool)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(phrase);
  tbuf=est_uconv_in(phrase, (signed int)return_value_strlen$3, &tsiz);
  est_normalize_text((unsigned char *)tbuf, tsiz, &tsiz);
  pbuf=est_uconv_out(tbuf, tsiz, &psiz);
  elems=cbsplit(pbuf, psiz, "\a\b\t\n\v\f\r ");
  do
  {
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    datum = (struct anonymous$2 *)return_value_malloc$4;
    if(!(datum == ((struct anonymous$2 *)NULL)))
      datum;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)12);
    datum->dptr = (char *)return_value_malloc$5;
    if(!(datum->dptr == ((char *)NULL)))
      datum->dptr;

    else
      cbmyfatal("out of memory");
    datum->dptr[(signed long int)0] = (char)0;
    datum->dsize = 0;
    datum->asize = 12;
  }
  while((_Bool)0);
  lw = 0;
  i = 0;
  signed int return_value_strcmp$33;
  signed int return_value_strcmp$32;
  signed int return_value_strcmp$31;
  signed int return_value_strcmp$28;
  _Bool tmp_if_expr$30;
  signed int return_value_strcmp$29;
  signed int tmp_if_expr$11;
  unsigned long int tmp_if_expr$17;
  unsigned long int return_value_strlen$16;
  for( ; !(i >= elems->num); i = i + 1)
  {
    elem = (const char *)(elems->array + (signed long int)(elems->start + i))->dptr;
    if(!((signed int)*elem == 0))
    {
      signed int return_value_strcmp$34;
      return_value_strcmp$34=strcmp(elem, "OR");
      if(return_value_strcmp$34 == 0)
      {
        if(!(datum->dsize >= 1))
          goto __CPROVER_DUMP_L70;

        if(!(lw == 0))
          do
          {
            if(1 + datum->dsize >= datum->asize)
            {
              datum->asize = datum->asize * 2 + 1 + 1;
              void *return_value_realloc$6;
              return_value_realloc$6=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
              datum->dptr = (char *)return_value_realloc$6;
              if(!(datum->dptr == ((char *)NULL)))
                datum->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)"\t", (unsigned long int)1);
            datum->dsize = datum->dsize + 1;
            datum->dptr[(signed long int)datum->dsize] = (char)0;
          }
          while((_Bool)0);

        lw = 0;
      }

      else
      {
        return_value_strcmp$33=strcmp(elem, "[BW]");
        if(return_value_strcmp$33 == 0)
        {
          if(lw == 0)
            do
            {
              if(2 + datum->dsize >= datum->asize)
              {
                datum->asize = datum->asize * 2 + 2 + 1;
                void *return_value_realloc$7;
                return_value_realloc$7=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc$7;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" b", (unsigned long int)2);
              datum->dsize = datum->dsize + 2;
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);

        }

        else
        {
          return_value_strcmp$32=strcmp(elem, "[EW]");
          if(return_value_strcmp$32 == 0)
          {
            if(lw == 0)
              do
              {
                if(2 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 2 + 1;
                  void *return_value_realloc$8;
                  return_value_realloc$8=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc$8;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" e", (unsigned long int)2);
                datum->dsize = datum->dsize + 2;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

          }

          else
          {
            return_value_strcmp$31=strcmp(elem, "[RX]");
            if(return_value_strcmp$31 == 0)
            {
              if(lw == 0)
                do
                {
                  if(2 + datum->dsize >= datum->asize)
                  {
                    datum->asize = datum->asize * 2 + 2 + 1;
                    void *return_value_realloc$9;
                    return_value_realloc$9=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                    datum->dptr = (char *)return_value_realloc$9;
                    if(!(datum->dptr == ((char *)NULL)))
                      datum->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" r", (unsigned long int)2);
                  datum->dsize = datum->dsize + 2;
                  datum->dptr[(signed long int)datum->dsize] = (char)0;
                }
                while((_Bool)0);

            }

            else
            {
              return_value_strcmp$28=strcmp(elem, "AND");
              if(return_value_strcmp$28 == 0)
                tmp_if_expr$30 = (_Bool)1;

              else
              {
                return_value_strcmp$29=strcmp(elem, "ANDNOT");
                tmp_if_expr$30 = !(return_value_strcmp$29 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$30)
              {
                if(!(datum->dsize >= 1))
                  goto __CPROVER_DUMP_L70;

                do
                {
                  signed int _CB_index = terms->start + terms->num;
                  if(_CB_index >= terms->anum)
                  {
                    terms->anum = terms->anum * 2;
                    void *return_value_realloc$10;
                    return_value_realloc$10=realloc((void *)terms->array, (unsigned long int)terms->anum * sizeof(struct anonymous$28) /*16ul*/ );
                    terms->array = (struct anonymous$28 *)return_value_realloc$10;
                    if(!(terms->array == ((struct anonymous$28 *)NULL)))
                      terms->array;

                    else
                      cbmyfatal("out of memory");
                  }

                  if(!(datum->dsize >= 12))
                    tmp_if_expr$11 = 12;

                  else
                    tmp_if_expr$11 = (signed int)datum->dsize;
                  void *return_value_malloc$12;
                  return_value_malloc$12=malloc((unsigned long int)(tmp_if_expr$11 + 1));
                  (terms->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$12;
                  if(!((terms->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                    (terms->array + (signed long int)_CB_index)->dptr;

                  else
                    cbmyfatal("out of memory");
                  memcpy((void *)(terms->array + (signed long int)_CB_index)->dptr, (const void *)(const char *)datum->dptr, (unsigned long int)(signed int)datum->dsize);
                  (terms->array + (signed long int)_CB_index)->dptr[(signed long int)(signed int)datum->dsize] = (char)0;
                  (terms->array + (signed long int)_CB_index)->dsize = (signed int)datum->dsize;
                  terms->num = terms->num + 1;
                }
                while((_Bool)0);
                do
                  if(datum->dsize >= 0)
                  {
                    datum->dsize = 0;
                    datum->dptr[(signed long int)0] = (char)0;
                  }

                  else
                  {
                    if(!(datum->asize >= 1))
                    {
                      datum->asize = datum->asize * 2 + 0 + 1;
                      void *return_value_realloc$13;
                      return_value_realloc$13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                      datum->dptr = (char *)return_value_realloc$13;
                      if(!(datum->dptr == ((char *)NULL)))
                        datum->dptr;

                      else
                        cbmyfatal("out of memory");
                    }

                    memset((void *)(datum->dptr + (signed long int)datum->dsize), 0, (unsigned long int)((0 - datum->dsize) + 1));
                    datum->dsize = 0;
                  }
                while((_Bool)0);
                do
                {
                  signed int est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index = terms->start + terms->num;
                  if(est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index >= terms->anum)
                  {
                    terms->anum = terms->anum * 2;
                    void *return_value_realloc$14;
                    return_value_realloc$14=realloc((void *)terms->array, (unsigned long int)terms->anum * sizeof(struct anonymous$28) /*16ul*/ );
                    terms->array = (struct anonymous$28 *)return_value_realloc$14;
                    if(!(terms->array == ((struct anonymous$28 *)NULL)))
                      terms->array;

                    else
                      cbmyfatal("out of memory");
                  }

                  unsigned long int return_value_strlen$15;
                  return_value_strlen$15=strlen(elem);
                  if(!(return_value_strlen$15 >= 12ul))
                    tmp_if_expr$17 = (unsigned long int)12;

                  else
                  {
                    return_value_strlen$16=strlen(elem);
                    tmp_if_expr$17 = return_value_strlen$16;
                  }
                  void *return_value_malloc$18;
                  return_value_malloc$18=malloc(tmp_if_expr$17 + (unsigned long int)1);
                  (terms->array + (signed long int)est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index)->dptr = (char *)return_value_malloc$18;
                  if(!((terms->array + (signed long int)est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index)->dptr == ((char *)NULL)))
                    (terms->array + (signed long int)est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index)->dptr;

                  else
                    cbmyfatal("out of memory");
                  unsigned long int return_value_strlen$19;
                  return_value_strlen$19=strlen(elem);
                  memcpy((void *)(terms->array + (signed long int)est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index)->dptr, (const void *)elem, return_value_strlen$19);
                  unsigned long int return_value_strlen$20;
                  return_value_strlen$20=strlen(elem);
                  (terms->array + (signed long int)est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index)->dptr[(signed long int)return_value_strlen$20] = (char)0;
                  unsigned long int return_value_strlen$21;
                  return_value_strlen$21=strlen(elem);
                  (terms->array + (signed long int)est_phrase_terms$$1$$3$$1$$5$$3$$_CB_index)->dsize = (signed int)return_value_strlen$21;
                  terms->num = terms->num + 1;
                }
                while((_Bool)0);
                lw = 0;
              }

              else
              {
                if(datum->dsize >= 1)
                {
                  if(!(lw == 0))
                    do
                    {
                      if(1 + datum->dsize >= datum->asize)
                      {
                        datum->asize = datum->asize * 2 + 1 + 1;
                        void *return_value_realloc$22;
                        return_value_realloc$22=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                        datum->dptr = (char *)return_value_realloc$22;
                        if(!(datum->dptr == ((char *)NULL)))
                          datum->dptr;

                        else
                          cbmyfatal("out of memory");
                      }

                      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)" ", (unsigned long int)1);
                      datum->dsize = datum->dsize + 1;
                      datum->dptr[(signed long int)datum->dsize] = (char)0;
                    }
                    while((_Bool)0);

                }

                do
                {
                  unsigned long int return_value_strlen$25;
                  return_value_strlen$25=strlen(elem);
                  if(return_value_strlen$25 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
                  {
                    unsigned long int return_value_strlen$23;
                    return_value_strlen$23=strlen(elem);
                    datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$23 + (unsigned long int)1);
                    void *return_value_realloc$24;
                    return_value_realloc$24=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                    datum->dptr = (char *)return_value_realloc$24;
                    if(!(datum->dptr == ((char *)NULL)))
                      datum->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  unsigned long int return_value_strlen$26;
                  return_value_strlen$26=strlen(elem);
                  memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)elem, return_value_strlen$26);
                  unsigned long int return_value_strlen$27;
                  return_value_strlen$27=strlen(elem);
                  datum->dsize = datum->dsize + (signed int)return_value_strlen$27;
                  datum->dptr[(signed long int)datum->dsize] = (char)0;
                }
                while((_Bool)0);
                lw = 1;
              }
            }
          }
        }
      }
    }


  __CPROVER_DUMP_L70:
    ;
  }
  signed int tmp_if_expr$36;
  if(datum->dsize >= 1)
    do
    {
      signed int est_phrase_terms$$1$$4$$_CB_index = terms->start + terms->num;
      if(est_phrase_terms$$1$$4$$_CB_index >= terms->anum)
      {
        terms->anum = terms->anum * 2;
        void *return_value_realloc$35;
        return_value_realloc$35=realloc((void *)terms->array, (unsigned long int)terms->anum * sizeof(struct anonymous$28) /*16ul*/ );
        terms->array = (struct anonymous$28 *)return_value_realloc$35;
        if(!(terms->array == ((struct anonymous$28 *)NULL)))
          terms->array;

        else
          cbmyfatal("out of memory");
      }

      if(!(datum->dsize >= 12))
        tmp_if_expr$36 = 12;

      else
        tmp_if_expr$36 = (signed int)datum->dsize;
      void *return_value_malloc$37;
      return_value_malloc$37=malloc((unsigned long int)(tmp_if_expr$36 + 1));
      (terms->array + (signed long int)est_phrase_terms$$1$$4$$_CB_index)->dptr = (char *)return_value_malloc$37;
      if(!((terms->array + (signed long int)est_phrase_terms$$1$$4$$_CB_index)->dptr == ((char *)NULL)))
        (terms->array + (signed long int)est_phrase_terms$$1$$4$$_CB_index)->dptr;

      else
        cbmyfatal("out of memory");
      memcpy((void *)(terms->array + (signed long int)est_phrase_terms$$1$$4$$_CB_index)->dptr, (const void *)(const char *)datum->dptr, (unsigned long int)(signed int)datum->dsize);
      (terms->array + (signed long int)est_phrase_terms$$1$$4$$_CB_index)->dptr[(signed long int)(signed int)datum->dsize] = (char)0;
      (terms->array + (signed long int)est_phrase_terms$$1$$4$$_CB_index)->dsize = (signed int)datum->dsize;
      terms->num = terms->num + 1;
    }
    while((_Bool)0);

  do
  {
    free((void *)datum->dptr);
    free((void *)datum);
  }
  while((_Bool)0);
  do
  {
    signed int _CB_i;
    signed int _CB_end = elems->start + elems->num;
    _CB_i = elems->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(elems->array + (signed long int)_CB_i)->dptr);
    free((void *)elems->array);
    free((void *)elems);
  }
  while((_Bool)0);
  free((void *)pbuf);
  free((void *)tbuf);
  i = 0;
  _Bool tmp_if_expr$40;
  signed int return_value_strcmp$39;
  _Bool tmp_if_expr$42;
  signed int return_value_strcmp$41;
  for( ; !(i >= terms->num); i = i + 1)
  {
    elem = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    signed int return_value_strcmp$38;
    return_value_strcmp$38=strcmp(elem, "[UVSET]");
    if(return_value_strcmp$38 == 0)
      tmp_if_expr$40 = (_Bool)1;

    else
    {
      return_value_strcmp$39=strcmp(elem, "AND");
      tmp_if_expr$40 = !(return_value_strcmp$39 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$40)
      tmp_if_expr$42 = (_Bool)1;

    else
    {
      return_value_strcmp$41=strcmp(elem, "ANDNOT");
      tmp_if_expr$42 = !(return_value_strcmp$41 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$42)
    {
      unsigned long int return_value_strlen$43;
      return_value_strlen$43=strlen(elem);
      tbuf=est_uconv_in(elem, (signed int)return_value_strlen$43, &tsiz);
      est_canonicalize_text((unsigned char *)tbuf, tsiz, 1);
      pbuf=est_uconv_out(tbuf, tsiz, &psiz);
      cblistover(terms, i, pbuf, -1);
      free((void *)pbuf);
      free((void *)tbuf);
    }

  }
  i = (signed int)terms->num - 1;
  signed int return_value_strcmp$44;
  for( ; i >= 0; i = i - 1)
  {
    elem = (const char *)(terms->array + (signed long int)(terms->start + i))->dptr;
    signed int return_value_strcmp$45;
    return_value_strcmp$45=strcmp(elem, "AND");
    if(!(return_value_strcmp$45 == 0))
    {
      return_value_strcmp$44=strcmp(elem, "ANDNOT");
      if(!(return_value_strcmp$44 == 0))
        break;

    }

    do
      if(terms->num >= 1)
      {
        free((void *)(terms->array + (signed long int)((terms->start + terms->num) - 1))->dptr);
        terms->num = terms->num - 1;
      }

    while((_Bool)0);
  }
  return terms;
}

// est_phrase_vector
// file estraier.c line 10301
static struct anonymous$9 * est_phrase_vector(const char *phrase)
{
  struct anonymous$31 *scores;
  struct anonymous$9 *svmap;
  struct anonymous$1 *list;
  const char *pv;
  const char *rp;
  char *utext;
  char *rtext;
  signed int i;
  signed int num;
  signed int len;
  signed int size;
  svmap=cbmapopenex(31);
  do
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    list = (struct anonymous$1 *)return_value_malloc$1;
    if(!(list == ((struct anonymous$1 *)NULL)))
      list;

    else
      cbmyfatal("out of memory");
    list->anum = 64;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)list->anum);
    list->array = (struct anonymous$28 *)return_value_malloc$2;
    if(!(list->array == ((struct anonymous$28 *)NULL)))
      list->array;

    else
      cbmyfatal("out of memory");
    list->start = 0;
    list->num = 0;
  }
  while((_Bool)0);
  _Bool tmp_if_expr$8;
  signed int return_value_cbstrfwmatch$7;
  signed int return_value_cbstrfwmatch$4;
  while(!((signed int)*phrase == 0))
  {
    if(*phrase == 'W')
    {
      return_value_cbstrfwmatch$7=cbstrfwmatch(phrase, "WITH");
      tmp_if_expr$8 = return_value_cbstrfwmatch$7 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen("WITH");
      phrase = phrase + (signed long int)return_value_strlen$3;
      pv = phrase;
      while(!((signed int)*phrase == 0))
      {
        if(!((signed int)*phrase >= 33))
        {
          return_value_cbstrfwmatch$4=cbstrfwmatch(phrase + (signed long int)1, "WITH");
          if(!(return_value_cbstrfwmatch$4 == 0))
          {
            phrase = phrase + 1l;
            break;
          }

        }

        phrase = phrase + 1l;
      }
      do
      {
        signed int _CB_index = list->start + list->num;
        if(_CB_index >= list->anum)
        {
          list->anum = list->anum * 2;
          void *return_value_realloc$5;
          return_value_realloc$5=realloc((void *)list->array, (unsigned long int)list->anum * sizeof(struct anonymous$28) /*16ul*/ );
          list->array = (struct anonymous$28 *)return_value_realloc$5;
          if(!(list->array == ((struct anonymous$28 *)NULL)))
            list->array;

          else
            cbmyfatal("out of memory");
        }

        void *return_value_malloc$6;
        return_value_malloc$6=malloc((unsigned long int)((phrase - pv < (signed long int)12 ? (signed long int)12 : phrase - pv) + (signed long int)1));
        (list->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$6;
        if(!((list->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
          (list->array + (signed long int)_CB_index)->dptr;

        else
          cbmyfatal("out of memory");
        memcpy((void *)(list->array + (signed long int)_CB_index)->dptr, (const void *)pv, (unsigned long int)(phrase - pv));
        (list->array + (signed long int)_CB_index)->dptr[phrase - pv] = (char)0;
        (list->array + (signed long int)_CB_index)->dsize = (signed int)(phrase - pv);
        list->num = list->num + 1;
      }
      while((_Bool)0);
    }

    else
      phrase = phrase + 1l;
  }
  i = 0;
  for( ; !(i >= list->num); i = i + 1)
  {
    pv = (const char *)(list->array + (signed long int)(list->start + i))->dptr;
    for( ; (signed int)*pv >= 1; pv = pv + 1l)
      if((signed int)*pv >= 33)
        break;

    signed long int return_value_strtol$9;
    return_value_strtol$9=strtol(pv, (char **)&rp, 10);
    num = (signed int)return_value_strtol$9;
    if(!(rp == ((const char *)NULL)))
    {
      len = (signed int)(rp - pv);
      if(len >= 1)
      {
        if(num >= 0)
        {
          unsigned long int return_value_strlen$10;
          return_value_strlen$10=strlen(rp);
          utext=est_uconv_in(rp, (signed int)return_value_strlen$10, &size);
          est_normalize_text((unsigned char *)utext, size, &size);
          est_canonicalize_text((unsigned char *)utext, size, 0);
          rtext=est_uconv_out(utext, size, (signed int *)(void *)0);
          cbstrsqzspc(rtext);
          if(!((signed int)*rtext == 0))
            cbmapput(svmap, rtext, -1, pv, len, 0);

          free((void *)rtext);
          free((void *)utext);
        }

      }

    }

  }
  do
  {
    signed int _CB_i;
    signed int _CB_end = list->start + list->num;
    _CB_i = list->start;
    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
      free((void *)(list->array + (signed long int)_CB_i)->dptr);
    free((void *)list->array);
    free((void *)list);
  }
  while((_Bool)0);
  signed int return_value_cbmaprnum$11;
  return_value_cbmaprnum$11=cbmaprnum(svmap);
  void *return_value_malloc$12;
  return_value_malloc$12=malloc((unsigned long int)return_value_cbmaprnum$11 * sizeof(struct anonymous$31) /*16ul*/  + (unsigned long int)1);
  scores = (struct anonymous$31 *)return_value_malloc$12;
  if(!(scores == ((struct anonymous$31 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  cbmapiterinit(svmap);
  i = 0;
  do
  {
    rp=cbmapiternext(svmap, &len);
    if(rp == ((const char *)NULL))
      break;

    (scores + (signed long int)i)->word = rp;
    (scores + (signed long int)i)->wsiz = len;
    const char *return_value_cbmapiterval$13;
    return_value_cbmapiterval$13=cbmapiterval(rp, (signed int *)(void *)0);
    (scores + (signed long int)i)->pt=atoi(return_value_cbmapiterval$13);
    i = i + 1;
  }
  while((_Bool)1);
  qsort((void *)scores, (unsigned long int)i, sizeof(struct anonymous$31) /*16ul*/ , est_keysc_compare);
  i = i - 1;
  for( ; i >= 0; i = i - 1)
    cbmapmove(svmap, (scores + (signed long int)i)->word, (scores + (signed long int)i)->wsiz, 1);
  free((void *)scores);
  return svmap;
}

// est_pidx_uri_to_id
// file estraier.c line 7997
static signed int est_pidx_uri_to_id(struct anonymous *db, const char *uri)
{
  struct anonymous$0 *doc;
  const char *vbuf;
  signed int i;
  signed int vsiz;
  if(db->puris == ((struct anonymous$9 *)NULL))
  {
    db->puris=cbmapopenex((signed int)db->pdocs->num + 1);
    i = 0;
    for( ; !(i >= db->pdocs->num); i = i + 1)
    {
      doc=est_db_get_doc(db, 2000000001 + i, 0);
      if(!(doc == ((struct anonymous$0 *)NULL)))
      {
        vbuf=cbmapget(doc->attrs, "@uri", -1, &vsiz);
        if(!(vbuf == ((const char *)NULL)))
          cbmapput(db->puris, vbuf, vsiz, (char *)&doc->id, (signed int)sizeof(signed int) /*4ul*/ , 0);

        est_doc_delete(doc);
      }

    }
  }

  vbuf=cbmapget(db->puris, uri, -1, (signed int *)(void *)0);
  if(!(vbuf == ((const char *)NULL)))
    return *((signed int *)vbuf);

  else
    return -1;
}

// est_proc_env_reset
// file estraier.h line 1485
void est_proc_env_reset(void)
{
  char *value;
  char *pbuf;
  cbstdiobin();
  putenv("LANG=C");
  putenv("LANGUAGE=C");
  putenv("LC_CTYPE=C");
  putenv("LC_COLLATE=C");
  putenv("LC_TIME=C");
  putenv("LC_NUMERIC=C");
  putenv("LC_MONETARY=C");
  putenv("LC_ALL=C");
  putenv("EST_VERSION=1.4.13");
  value=getenv("PATH");
  if(!(value == ((char *)NULL)))
  {
    pbuf=cbsprintf("PATH=%s:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin", value);
    putenv(pbuf);
    cbglobalgc((void *)pbuf, free);
  }

}

// est_random
// file estraier.h line 966
double est_random(void)
{
  signed int num;
  static signed int first = 1;
  if(est_random_ifp == ((struct _IO_FILE *)NULL) && !(first == 0))
  {
    est_random_ifp=fopen("/dev/urandom", "rb");
    if(!(est_random_ifp == ((struct _IO_FILE *)NULL)))
      atexit(est_random_fclose);

    else
    {
      signed int return_value_getpid$1;
      return_value_getpid$1=getpid();
      srand((unsigned int)return_value_getpid$1);
    }
    first = 0;
  }

  if(!(est_random_ifp == ((struct _IO_FILE *)NULL)))
  {
    fread((void *)&num, sizeof(signed int) /*4ul*/ , (unsigned long int)1, est_random_ifp);
    return (double)(num & 0x7fffffff) / (double)0x7fffffff;
  }

  else
  {
    signed int return_value_rand$2;
    return_value_rand$2=rand();
    return (double)return_value_rand$2 / (double)2147483647;
  }
}

// est_random_fclose
// file estraier.c line 10424
static void est_random_fclose(void)
{
  if(!(est_random_ifp == ((struct _IO_FILE *)NULL)))
    fclose(est_random_ifp);

}

// est_random_nd
// file estraier.h line 971
double est_random_nd(void)
{
  double d;
  double return_value_est_random$1;
  return_value_est_random$1=est_random();
  double return_value_log$2;
  return_value_log$2=log(1.0 - return_value_est_random$1);
  double return_value_sqrt$3;
  return_value_sqrt$3=sqrt((double)-2 * return_value_log$2);
  double return_value_est_random$4;
  return_value_est_random$4=est_random();
  double return_value_cos$5;
  return_value_cos$5=cos(3.1415926535 * (double)2 * return_value_est_random$4);
  d = (return_value_sqrt$3 * return_value_cos$5 + 6.0) / 12.0;
  if(d > 1.0)
    d = 1.0;

  if(d < 0.0)
    d = 0.0;

  return d;
}

// est_random_str
// file estmttest.c line 555
static char * est_random_str(signed int cnum, signed int mode)
{
  const char echrs[63l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 0 };
  struct anonymous$2 *buf;
  char wc[2l];
  char *str;
  signed int i;
  signed int c;
  signed int wlen;
  signed int dec;
  signed int mm;
  signed int big;
  signed int n;
  buf=cbdatumopen("", 0);
  double return_value_est_random_nd$1;
  return_value_est_random_nd$1=est_random_nd();
  double return_value_pow$2;
  return_value_pow$2=pow(return_value_est_random_nd$1 + 0.5, 3.0);
  cnum = cnum * (signed int)return_value_pow$2;
  double return_value_est_random_nd$3;
  return_value_est_random_nd$3=est_random_nd();
  wlen = (signed int)(return_value_est_random_nd$3 * (double)8 + (double)4);
  double return_value_est_random$4;
  return_value_est_random$4=est_random();
  dec = (signed int)(return_value_est_random$4 * (double)0x7fffffff) % 10;
  double return_value_est_random$5;
  return_value_est_random$5=est_random();
  big = ((signed int)(return_value_est_random$5 * (double)0x7fffffff) % 0x29) * 0x100;
  i = 0;
  double return_value_est_random$6;
  double return_value_est_random_nd$18;
  double return_value_est_random$37;
  for( ; !(i >= cnum); i = i + 1)
  {
    switch(mode)
    {
      case 0:

      case 1:

      case 2:
      {
        return_value_est_random$6=est_random();
        mm = (signed int)(return_value_est_random$6 * (double)0x7fffffff) % 100;
        if(!(mm >= 5) && (mode == 1 || mode == 2))
        {
          double return_value_est_random_nd$7;
          return_value_est_random_nd$7=est_random_nd();
          double return_value_pow$8;
          return_value_pow$8=pow(return_value_est_random_nd$7, 2.0);
          c = 0x00a1 + (signed int)(return_value_pow$8 * (double)(0x00ff - 0x00a0));
        }

        else
          if(mode == 2 && (dec >= 9 || !(mm >= 30)))
          {
            if(dec % 2 == 0)
            {
              double return_value_est_random_nd$9;
              return_value_est_random_nd$9=est_random_nd();
              double return_value_pow$10;
              return_value_pow$10=pow(return_value_est_random_nd$9, 2.0);
              c = 0x0391 + (signed int)(return_value_pow$10 * (double)(0x03d6 - 0x0391));
            }

            else
            {
              double return_value_est_random_nd$11;
              return_value_est_random_nd$11=est_random_nd();
              double return_value_pow$12;
              return_value_pow$12=pow(return_value_est_random_nd$11, 2.0);
              c = 0x0400 + (signed int)(return_value_pow$12 * (double)(0x045f - 0x0400));
            }
          }

          else
            if(!(mm >= 95))
            {
              double return_value_est_random_nd$13;
              return_value_est_random_nd$13=est_random_nd();
              n = (signed int)(return_value_est_random_nd$13 * (double)(sizeof(const char [63l]) /*63ul*/  - (unsigned long int)1));
              if((unsigned long int)n == 62ul)
                n = 0;

              c = (signed int)echrs[(signed long int)n];
            }

            else
            {
              double return_value_est_random$14;
              return_value_est_random$14=est_random();
              c = (signed int)(return_value_est_random$14 * (double)(64 - 32)) + 32;
            }
        wlen = wlen - 1;
        if(!(wlen >= 1))
        {
          c = 32;
          double return_value_est_random_nd$15;
          return_value_est_random_nd$15=est_random_nd();
          double return_value_pow$16;
          return_value_pow$16=pow(return_value_est_random_nd$15, 3.0);
          wlen = (signed int)(return_value_pow$16 * (double)8 + (double)4);
          double return_value_est_random$17;
          return_value_est_random$17=est_random();
          dec = (signed int)(return_value_est_random$17 * (double)0x7fffffff) % 10;
        }

        break;
      }
      case 3:
      {
        return_value_est_random_nd$18=est_random_nd();
        c = (signed int)((double)big + return_value_est_random_nd$18 * (double)0x100);
        wlen = wlen - 1;
        if(!(wlen >= 1))
        {
          double return_value_est_random_nd$19;
          return_value_est_random_nd$19=est_random_nd();
          double return_value_pow$20;
          return_value_pow$20=pow(return_value_est_random_nd$19, 3.0);
          wlen = (signed int)(return_value_pow$20 * (double)12 + (double)6);
          double return_value_est_random$21;
          return_value_est_random$21=est_random();
          big = ((signed int)(return_value_est_random$21 * (double)0x7fffffff) % 0x29) * 0x100;
        }

        break;
      }
      case 4:
      {
        if(!(dec >= 4))
        {
          double return_value_est_random_nd$22;
          return_value_est_random_nd$22=est_random_nd();
          double return_value_pow$23;
          return_value_pow$23=pow(return_value_est_random_nd$22, 3.0);
          c = (signed int)((double)0x3041 + return_value_pow$23 * (double)(0x3094 - 0x3041));
        }

        else
          if(!(dec >= 7))
          {
            double return_value_est_random_nd$24;
            return_value_est_random_nd$24=est_random_nd();
            double return_value_pow$25;
            return_value_pow$25=pow(return_value_est_random_nd$24, 3.0);
            c = (signed int)((double)0x30a1 + return_value_pow$25 * (double)(0x30fe - 0x30a1));
          }

          else
            if(!(dec >= 9))
            {
              double return_value_est_random_nd$26;
              return_value_est_random_nd$26=est_random_nd();
              double return_value_pow$27;
              return_value_pow$27=pow(return_value_est_random_nd$26, 3.0);
              c = (signed int)((double)0x4e00 + return_value_pow$27 * (double)(0x9faf - 0x4e00));
            }

            else
            {
              double return_value_est_random$31;
              return_value_est_random$31=est_random();
              if(return_value_est_random$31 < 0.7)
              {
                double return_value_est_random_nd$28;
                return_value_est_random_nd$28=est_random_nd();
                double return_value_pow$29;
                return_value_pow$29=pow(return_value_est_random_nd$28, 2.0);
                c = 0x00a1 + (signed int)(return_value_pow$29 * (double)(0x00ff - 0x00a0));
              }

              else
              {
                double return_value_est_random$30;
                return_value_est_random$30=est_random();
                c = (signed int)((double)0x3041 + return_value_est_random$30 * (double)(0xffef - 0x3041));
              }
            }
        wlen = wlen - 1;
        if(!(wlen >= 1))
        {
          double return_value_est_random_nd$32;
          return_value_est_random_nd$32=est_random_nd();
          double return_value_pow$33;
          return_value_pow$33=pow(return_value_est_random_nd$32, 3.0);
          wlen = (signed int)(return_value_pow$33 * (double)12 + (double)6);
          double return_value_est_random$34;
          return_value_est_random$34=est_random();
          dec = (signed int)(return_value_est_random$34 * (double)0x7fffffff) % 10;
        }

        break;
      }
      default:
      {
        return_value_est_random$37=est_random();
        if(return_value_est_random$37 < 0.2)
        {
          double return_value_est_random$35;
          return_value_est_random$35=est_random();
          c = 0x00a1 + (signed int)return_value_est_random$35 * (0x00ff - 0x00a0);
        }

        else
        {
          double return_value_est_random$36;
          return_value_est_random$36=est_random();
          c = (signed int)(return_value_est_random$36 * (double)0x10000);
        }
      }
    }
    if(c >= 0x10000 || !(c >= 1))
      c = 0x0020;

    wc[(signed long int)0] = (char)(c / 0x100);
    wc[(signed long int)1] = (char)(c % 0x100);
    cbdatumcat(buf, wc, 2);
  }
  str=est_iconv((const char *)buf->dptr, (signed int)buf->dsize, "UTF-16BE", "UTF-8", (signed int *)(void *)0, (signed int *)(void *)0);
  cbdatumclose(buf);
  return str;
}

// est_realpath
// file estraier.c line 5565
char * est_realpath(const char *path)
{
  char pbuf[8192l];
  char *return_value_realpath$4;
  return_value_realpath$4=realpath(path, pbuf);
  _Bool tmp_if_expr$3;
  char *return_value_realpath$2;
  if(return_value_realpath$4 == ((char *)NULL))
  {
    if((signed int)*path == 47)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_realpath$2=realpath(".", pbuf);
      tmp_if_expr$3 = !(return_value_realpath$2 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      sprintf(pbuf, "%s", path);

    else
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(pbuf);
      sprintf(pbuf + (signed long int)return_value_strlen$1, "%c%s", 47, path);
    }
  }

  char *return_value_cbmemdup$5;
  return_value_cbmemdup$5=cbmemdup(pbuf, -1);
  return return_value_cbmemdup$5;
}

// est_regex_delete
// file estraier.c line 4132
void est_regex_delete(void *regex)
{
  regfree((struct re_pattern_buffer *)regex);
  free(regex);
}

// est_regex_match
// file estraier.c line 4140
signed int est_regex_match(const void *regex, const char *str)
{
  signed int return_value_regexec$1;
  return_value_regexec$1=regexec((const struct re_pattern_buffer *)regex, str, (unsigned long int)0, (struct anonymous$44 *)(void *)0, 0);
  return (signed int)(return_value_regexec$1 == 0);
}

// est_regex_match_str
// file estraier.c line 4147
signed int est_regex_match_str(const char *rstr, const char *tstr)
{
  void *regex;
  signed int rv;
  regex=est_regex_new(rstr);
  if(regex == NULL)
    return 0;

  else
  {
    rv=est_regex_match(regex, tstr);
    est_regex_delete(regex);
    return rv;
  }
}

// est_regex_new
// file estraier.c line 4117
void * est_regex_new(const char *str)
{
  struct re_pattern_buffer regex;
  signed int options = 1 | ((1 << 1) << 1) << 1;
  if((signed int)*str == 42)
  {
    if((signed int)str[1l] == 73)
    {
      if((signed int)str[2l] == 58)
      {
        options = options | 1 << 1;
        str = str + (signed long int)3;
      }

    }

  }

  signed int return_value_regcomp$1;
  return_value_regcomp$1=regcomp(&regex, str, options);
  if(!(return_value_regcomp$1 == 0))
    return (void *)0;

  else
  {
    char *return_value_cbmemdup$2;
    return_value_cbmemdup$2=cbmemdup((char *)&regex, (signed int)sizeof(struct re_pattern_buffer) /*64ul*/ );
    return (void *)return_value_cbmemdup$2;
  }
}

// est_regex_replace
// file estraier.c line 4159
char * est_regex_replace(const char *str, const char *bef, const char *aft)
{
  struct re_pattern_buffer regex;
  struct anonymous$44 subs[256l];
  struct anonymous$2 *datum;
  const char *sp;
  const char *rp;
  signed int options;
  signed int first;
  signed int num;
  options = 1;
  if((signed int)*bef == 42)
  {
    if((signed int)bef[1l] == 73)
    {
      if((signed int)bef[2l] == 58)
      {
        options = options | 1 << 1;
        bef = bef + (signed long int)3;
      }

    }

  }

  _Bool tmp_if_expr$3;
  signed int return_value_regcomp$2;
  if((signed int)*bef == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_regcomp$2=regcomp(&regex, bef, options);
    tmp_if_expr$3 = return_value_regcomp$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_cbmemdup$1;
  signed int return_value_regexec$8;
  _Bool tmp_if_expr$12;
  if(tmp_if_expr$3)
  {
    return_value_cbmemdup$1=cbmemdup(str, -1);
    return return_value_cbmemdup$1;
  }

  else
  {
    signed int return_value_regexec$5;
    return_value_regexec$5=regexec(&regex, str, (unsigned long int)32, subs, 0);
    if(!(return_value_regexec$5 == 0))
    {
      regfree(&regex);
      char *return_value_cbmemdup$4;
      return_value_cbmemdup$4=cbmemdup(str, -1);
      return return_value_cbmemdup$4;
    }

    sp = str;
    do
    {
      void *return_value_malloc$6;
      return_value_malloc$6=malloc(sizeof(struct anonymous$2) /*16ul*/ );
      datum = (struct anonymous$2 *)return_value_malloc$6;
      if(!(datum == ((struct anonymous$2 *)NULL)))
        datum;

      else
        cbmyfatal("out of memory");
      void *return_value_malloc$7;
      return_value_malloc$7=malloc((unsigned long int)12);
      datum->dptr = (char *)return_value_malloc$7;
      if(!(datum->dptr == ((char *)NULL)))
        datum->dptr;

      else
        cbmyfatal("out of memory");
      datum->dptr[(signed long int)0] = (char)0;
      datum->dsize = 0;
      datum->asize = 12;
    }
    while((_Bool)0);
    first = 1;
    while(!((signed int)*sp == 0))
    {
      return_value_regexec$8=regexec(&regex, sp, (unsigned long int)10, subs, first != 0 ? 0 : 1);
      if(!(return_value_regexec$8 == 0))
        break;

      first = 0;
      if(subs[0l].rm_so == -1)
        break;

      do
      {
        if(datum->dsize + subs[0l].rm_so >= datum->asize)
        {
          datum->asize = datum->asize * 2 + subs[(signed long int)0].rm_so + 1;
          void *return_value_realloc$9;
          return_value_realloc$9=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
          datum->dptr = (char *)return_value_realloc$9;
          if(!(datum->dptr == ((char *)NULL)))
            datum->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, (unsigned long int)subs[(signed long int)0].rm_so);
        datum->dsize = datum->dsize + subs[(signed long int)0].rm_so;
        datum->dptr[(signed long int)datum->dsize] = (char)0;
      }
      while((_Bool)0);
      rp = aft;
      for( ; !((signed int)*rp == 0); rp = rp + 1l)
        if((signed int)*rp == 92)
        {
          if((signed int)rp[1l] >= 48)
            tmp_if_expr$12 = (signed int)rp[(signed long int)1] <= 57 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$12 = (_Bool)0;
          if(tmp_if_expr$12)
          {
            num = (signed int)rp[(signed long int)1] - 48;
            if(!(subs[(signed long int)num].rm_so == -1))
            {
              if(!(subs[(signed long int)num].rm_eo == -1))
                do
                {
                  if(datum->dsize + subs[(signed long int)num].rm_eo + -subs[(signed long int)num].rm_so >= datum->asize)
                  {
                    datum->asize = datum->asize * 2 + (subs[(signed long int)num].rm_eo - subs[(signed long int)num].rm_so) + 1;
                    void *return_value_realloc$10;
                    return_value_realloc$10=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                    datum->dptr = (char *)return_value_realloc$10;
                    if(!(datum->dptr == ((char *)NULL)))
                      datum->dptr;

                    else
                      cbmyfatal("out of memory");
                  }

                  memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)(sp + (signed long int)subs[(signed long int)num].rm_so), (unsigned long int)(subs[(signed long int)num].rm_eo - subs[(signed long int)num].rm_so));
                  datum->dsize = datum->dsize + (subs[(signed long int)num].rm_eo - subs[(signed long int)num].rm_so);
                  datum->dptr[(signed long int)datum->dsize] = (char)0;
                }
                while((_Bool)0);

            }

            rp = rp + 1l;
          }

          else
            if(!((signed int)rp[1l] == 0))
              do
              {
                if(1 + datum->dsize >= datum->asize)
                {
                  datum->asize = datum->asize * 2 + 1 + 1;
                  void *return_value_realloc$11;
                  return_value_realloc$11=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                  datum->dptr = (char *)return_value_realloc$11;
                  if(!(datum->dptr == ((char *)NULL)))
                    datum->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                rp = rp + 1l;
                memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
                datum->dsize = datum->dsize + 1;
                datum->dptr[(signed long int)datum->dsize] = (char)0;
              }
              while((_Bool)0);

        }

        else
          if((signed int)*rp == 38)
            do
            {
              if(datum->dsize + subs[0l].rm_eo + -subs[0l].rm_so >= datum->asize)
              {
                datum->asize = datum->asize * 2 + (subs[(signed long int)0].rm_eo - subs[(signed long int)0].rm_so) + 1;
                void *return_value_realloc$13;
                return_value_realloc$13=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc$13;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)(sp + (signed long int)subs[(signed long int)0].rm_so), (unsigned long int)(subs[(signed long int)0].rm_eo - subs[(signed long int)0].rm_so));
              datum->dsize = datum->dsize + (subs[(signed long int)0].rm_eo - subs[(signed long int)0].rm_so);
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);

          else
            do
            {
              if(1 + datum->dsize >= datum->asize)
              {
                datum->asize = datum->asize * 2 + 1 + 1;
                void *return_value_realloc$14;
                return_value_realloc$14=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
                datum->dptr = (char *)return_value_realloc$14;
                if(!(datum->dptr == ((char *)NULL)))
                  datum->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)rp, (unsigned long int)1);
              datum->dsize = datum->dsize + 1;
              datum->dptr[(signed long int)datum->dsize] = (char)0;
            }
            while((_Bool)0);
      sp = sp + (signed long int)subs[(signed long int)0].rm_eo;
      if(!(subs[0l].rm_eo >= 1))
        break;

    }
    do
    {
      unsigned long int return_value_strlen$17;
      return_value_strlen$17=strlen(sp);
      if(return_value_strlen$17 + (unsigned long int)datum->dsize >= (unsigned long int)datum->asize)
      {
        unsigned long int return_value_strlen$15;
        return_value_strlen$15=strlen(sp);
        datum->asize = (signed int)((unsigned long int)(datum->asize * 2) + return_value_strlen$15 + (unsigned long int)1);
        void *return_value_realloc$16;
        return_value_realloc$16=realloc((void *)datum->dptr, (unsigned long int)datum->asize);
        datum->dptr = (char *)return_value_realloc$16;
        if(!(datum->dptr == ((char *)NULL)))
          datum->dptr;

        else
          cbmyfatal("out of memory");
      }

      unsigned long int return_value_strlen$18;
      return_value_strlen$18=strlen(sp);
      memcpy((void *)(datum->dptr + (signed long int)datum->dsize), (const void *)sp, return_value_strlen$18);
      unsigned long int return_value_strlen$19;
      return_value_strlen$19=strlen(sp);
      datum->dsize = datum->dsize + (signed int)return_value_strlen$19;
      datum->dptr[(signed long int)datum->dsize] = (char)0;
    }
    while((_Bool)0);
    regfree(&regex);
    char *return_value_cbdatumtomalloc$20;
    return_value_cbdatumtomalloc$20=cbdatumtomalloc(datum, (signed int *)(void *)0);
    return return_value_cbdatumtomalloc$20;
  }
}

// est_rescc_get
// file estraier.c line 8759
static const struct anonymous$6 * est_rescc_get(struct anonymous *db, const char *word, signed int size, signed int *nump)
{
  const char *vbuf;
  signed int vsiz;
  vbuf=cbmapget(db->rescc, word, size, &vsiz);
  if(vbuf == ((const char *)NULL))
    return (const struct anonymous$6 *)(void *)0;

  else
    if((unsigned long int)vsiz == sizeof(struct anonymous$6) /*16ul*/ )
    {
      if(!(((struct anonymous$6 *)vbuf)->id == -1))
        goto __CPROVER_DUMP_L2;

      return (const struct anonymous$6 *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      cbmapmove(db->rescc, word, size, 0);
      *nump = (signed int)((unsigned long int)vsiz / sizeof(struct anonymous$6) /*16ul*/ );
      return (struct anonymous$6 *)vbuf;
    }
}

// est_rescc_put
// file estraier.c line 8777
static void est_rescc_put(struct anonymous *db, const char *word, signed int size, struct anonymous$6 *scores, signed int num)
{
  signed int i;
  _Bool tmp_if_expr$1;
  if(!(db->rcmnum >= 1))
    free((void *)scores);

  else
  {
    cbmapput(db->rescc, word, size, (char *)scores, (signed int)((unsigned long int)num * sizeof(struct anonymous$6) /*16ul*/ ), 1);
    free((void *)scores);
    signed int return_value_cbmaprnum$2;
    return_value_cbmaprnum$2=cbmaprnum(db->rescc);
    if(!(db->rcmnum >= return_value_cbmaprnum$2))
    {
      num = (signed int)((double)db->rcmnum * 0.1 + (double)1);
      cbmapiterinit(db->rescc);
      i = 0;
      do
      {
        if(!(i >= num))
        {
          word=cbmapiternext(db->rescc, &size);
          tmp_if_expr$1 = word != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        cbmapout(db->rescc, word, size);
        i = i + 1;
      }
      while((_Bool)1);
    }

  }
}

// est_resdoc_attr
// file estnode.c line 282
const char * est_resdoc_attr(struct _ESTRESDOC *rdoc, const char *name)
{
  const char *return_value_cbmapget$1;
  return_value_cbmapget$1=cbmapget(rdoc->attrs, name, -1, (signed int *)(void *)0);
  return return_value_cbmapget$1;
}

// est_resdoc_attr_names
// file estnode.c line 266
struct anonymous$1 * est_resdoc_attr_names(struct _ESTRESDOC *rdoc)
{
  struct anonymous$1 *names;
  const char *kbuf;
  signed int ksiz;
  names=cblistopen();
  cbmapiterinit(rdoc->attrs);
  do
  {
    kbuf=cbmapiternext(rdoc->attrs, &ksiz);
    if(kbuf == ((const char *)NULL))
      break;

    if(!((signed int)*kbuf == 37))
      cblistpush(names, kbuf, ksiz);

  }
  while((_Bool)1);
  cblistsort(names);
  return names;
}

// est_resdoc_keywords
// file estnode.c line 296
const char * est_resdoc_keywords(struct _ESTRESDOC *rdoc)
{
  const char *vbuf;
  vbuf=cbmapget(rdoc->attrs, "%VECTOR", -1, (signed int *)(void *)0);
  return vbuf != ((const char *)NULL) ? vbuf : "";
}

// est_resdoc_shadows
// file estnode.c line 305
struct _ESTRESDOC ** est_resdoc_shadows(struct _ESTRESDOC *rdoc, signed int *np)
{
  if(rdoc->children == ((struct _ESTRESDOC **)NULL))
  {
    *np = 0;
    return (struct _ESTRESDOC **)"";
  }

  else
  {
    *np = rdoc->cnum;
    return rdoc->children;
  }
}

// est_resdoc_similarity
// file estnode.c line 317
double est_resdoc_similarity(struct _ESTRESDOC *rdoc)
{
  return rdoc->similarity;
}

// est_resdoc_snippet
// file estnode.c line 289
const char * est_resdoc_snippet(struct _ESTRESDOC *rdoc)
{
  return rdoc->snippet;
}

// est_resdoc_uri
// file estnode.c line 259
const char * est_resdoc_uri(struct _ESTRESDOC *rdoc)
{
  return rdoc->uri;
}

// est_resmap_add
// file estraier.c line 5442
void est_resmap_add(struct anonymous$9 *map, const char *key, signed int score, signed int method)
{
  signed int elem[2l];
  signed int *ep;
  signed int size;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(key);
  size = (signed int)return_value_strlen$1;
  const char *return_value_cbmapget$4;
  return_value_cbmapget$4=cbmapget(map, key, size, (signed int *)(void *)0);
  ep = (signed int *)return_value_cbmapget$4;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$3;
  if(!(ep == ((signed int *)NULL)))
  {
    elem[(signed long int)0] = ep[(signed long int)0] + 1;
    switch(method)
    {
      case 0:
      {
        elem[(signed long int)1] = ep[(signed long int)1] + score;
        break;
      }
      case 1:
      {
        if(!(ep[1l] >= score))
          tmp_if_expr$2 = score;

        else
          tmp_if_expr$2 = ep[(signed long int)1];
        elem[(signed long int)1] = tmp_if_expr$2;
        break;
      }
      case 2:
      {
        if(!(score >= ep[1l]))
          tmp_if_expr$3 = score;

        else
          tmp_if_expr$3 = ep[(signed long int)1];
        elem[(signed long int)1] = tmp_if_expr$3;
        break;
      }
      case 3:
      {
        elem[(signed long int)1] = (ep[(signed long int)1] * (ep[(signed long int)0] - 1) + score) / ep[(signed long int)0];
        break;
      }
      default:
        elem[(signed long int)1] = score;
    }
  }

  else
  {
    elem[(signed long int)0] = 1;
    elem[(signed long int)1] = score;
  }
  cbmapput(map, key, size, (char *)&elem, (signed int)(sizeof(signed int) /*4ul*/  * (unsigned long int)2), 1);
}

// est_resmap_dump
// file estraier.c line 5485
struct anonymous$10 * est_resmap_dump(struct anonymous$9 *map, signed int min, signed int *nump)
{
  struct anonymous$10 *elems;
  const char *key;
  const char *vbuf;
  signed int num;
  signed int vsiz;
  signed int return_value_cbmaprnum$1;
  return_value_cbmaprnum$1=cbmaprnum(map);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)return_value_cbmaprnum$1 * sizeof(struct anonymous$10) /*16ul*/  + (unsigned long int)1);
  elems = (struct anonymous$10 *)return_value_malloc$2;
  if(!(elems == ((struct anonymous$10 *)NULL)))
    elems;

  else
    cbmyfatal("out of memory");
  num = 0;
  cbmapiterinit(map);
  do
  {
    key=cbmapiternext(map, (signed int *)(void *)0);
    if(key == ((const char *)NULL))
      break;

    do
    {
      struct _CBMAPDATUM *_CB_datum = (struct _CBMAPDATUM *)(key - (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/ );
      vsiz = _CB_datum->vsiz;
      vbuf = (char *)_CB_datum + (signed long int)sizeof(struct _CBMAPDATUM) /*48ul*/  + (signed long int)_CB_datum->ksiz + (signed long int)(((_CB_datum->ksiz | ~(-((signed int)sizeof(void *) /*8ul*/ ))) + 1) - _CB_datum->ksiz);
    }
    while((_Bool)0);
    if(*((signed int *)vbuf) >= min)
    {
      (elems + (signed long int)num)->key = key;
      (elems + (signed long int)num)->score = ((signed int *)vbuf)[(signed long int)1];
      num = num + 1;
    }

  }
  while((_Bool)1);
  qsort((void *)elems, (unsigned long int)num, sizeof(struct anonymous$10) /*16ul*/ , est_resmapelem_compare);
  *nump = num;
  return elems;
}

// est_resmapelem_compare
// file estraier.c line 5478
static signed int est_resmapelem_compare(const void *ap, const void *bp)
{
  return ((struct anonymous$10 *)bp)->score - ((struct anonymous$10 *)ap)->score;
}

// est_rmdir_rec
// file estraier.c line 5545
signed int est_rmdir_rec(const char *path)
{
  struct anonymous$1 *files;
  const char *file;
  char pbuf[4096l];
  signed int i;
  files=cbdirlist(path);
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(!(files == ((struct anonymous$1 *)NULL)))
  {
    i = 0;
    for( ; !(i >= files->num); i = i + 1)
    {
      file = (const char *)(files->array + (signed long int)(files->start + i))->dptr;
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(file, ".");
      if(return_value_strcmp$1 == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strcmp$2=strcmp(file, "..");
        tmp_if_expr$3 = !(return_value_strcmp$2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$3)
      {
        sprintf(pbuf, "%s%c%s", path, 47, file);
        signed int return_value_unlink$4;
        return_value_unlink$4=unlink(pbuf);
        if(return_value_unlink$4 == -1)
          est_rmdir_rec(pbuf);

      }

    }
    do
    {
      signed int _CB_i;
      signed int _CB_end = files->start + files->num;
      _CB_i = files->start;
      for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
        free((void *)(files->array + (signed long int)_CB_i)->dptr);
      free((void *)files->array);
      free((void *)files);
    }
    while((_Bool)0);
  }

  signed int return_value_rmdir$5;
  return_value_rmdir$5=rmdir(path);
  return (signed int)(return_value_rmdir$5 == 0);
}

// est_score_compare_by_id_asc
// file estraier.c line 8088
static signed int est_score_compare_by_id_asc(const void *ap, const void *bp)
{
  return ((struct anonymous$6 *)ap)->id - ((struct anonymous$6 *)bp)->id;
}

// est_score_compare_by_id_desc
// file estraier.c line 8098
static signed int est_score_compare_by_id_desc(const void *ap, const void *bp)
{
  return ((struct anonymous$6 *)bp)->id - ((struct anonymous$6 *)ap)->id;
}

// est_score_compare_by_num_asc
// file estraier.c line 8148
static signed int est_score_compare_by_num_asc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous$6 *)ap)->value - (signed long int)((struct anonymous$6 *)bp)->value);
}

// est_score_compare_by_num_desc
// file estraier.c line 8158
static signed int est_score_compare_by_num_desc(const void *ap, const void *bp)
{
  return (signed int)((signed long int)((struct anonymous$6 *)bp)->value - (signed long int)((struct anonymous$6 *)ap)->value);
}

// est_score_compare_by_score_asc
// file estraier.c line 8108
static signed int est_score_compare_by_score_asc(const void *ap, const void *bp)
{
  return ((struct anonymous$6 *)ap)->score - ((struct anonymous$6 *)bp)->score;
}

// est_score_compare_by_score_desc
// file estraier.c line 8118
static signed int est_score_compare_by_score_desc(const void *ap, const void *bp)
{
  return ((struct anonymous$6 *)bp)->score - ((struct anonymous$6 *)ap)->score;
}

// est_score_compare_by_str_asc
// file estraier.c line 8128
static signed int est_score_compare_by_str_asc(const void *ap, const void *bp)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(((struct anonymous$6 *)ap)->value, ((struct anonymous$6 *)bp)->value);
  return return_value_strcmp$1;
}

// est_score_compare_by_str_desc
// file estraier.c line 8138
static signed int est_score_compare_by_str_desc(const void *ap, const void *bp)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(((struct anonymous$6 *)bp)->value, ((struct anonymous$6 *)ap)->value);
  return return_value_strcmp$1;
}

// est_search_aidx_attr
// file estraier.c line 8980
static struct anonymous$6 * est_search_aidx_attr(struct anonymous *db, const char *expr, signed int *nump)
{
  struct anonymous$16 *attridx;
  struct anonymous$6 *scores;
  struct anonymous$2 *abuf;
  struct anonymous$1 *tokens;
  void *regex;
  const char *cop;
  const char *pv;
  const char *kbuf;
  const char *tbuf;
  unsigned char *utmp;
  char *name;
  char *oper;
  char *val;
  char *sval;
  char *wp;
  char numbuf[32l];
  signed int i;
  signed int nsiz;
  signed int vsiz;
  signed int ksiz;
  signed int tsiz;
  signed int sign;
  signed int ic;
  signed int ssiz;
  signed int esc;
  signed int jmp;
  signed int len;
  signed int *ary;
  signed int anum;
  signed long int num;
  signed long int lower;
  signed long int upper;
  name = (char *)(void *)0;
  oper = (char *)(void *)0;
  val = (char *)(void *)0;
  nsiz = 0;
  vsiz = 0;
  for( ; (signed int)*expr >= 1; expr = expr + 1l)
    if((signed int)*expr >= 33)
      break;

  pv=strchr(expr, 32);
  if(!(pv == ((const char *)NULL)))
  {
    nsiz = (signed int)(pv - expr);
    name=cbmemdup(expr, nsiz);
    expr = pv;
    for( ; (signed int)*expr >= 1; expr = expr + 1l)
      if((signed int)*expr >= 33)
        break;

    pv=strchr(expr, 32);
    if(!(pv == ((const char *)NULL)))
    {
      oper=cbmemdup(expr, (signed int)(pv - expr));
      expr = pv;
      for( ; (signed int)*expr >= 1; expr = expr + 1l)
        if((signed int)*expr >= 33)
          break;

      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(expr);
      vsiz = (signed int)return_value_strlen$1;
      val=cbmemdup(expr, vsiz);
    }

    else
      oper=cbmemdup(expr, -1);
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(expr);
    nsiz = (signed int)return_value_strlen$2;
    name=cbmemdup(expr, nsiz);
  }
  if(oper == ((char *)NULL))
    oper=cbmemdup("", 0);

  if(val == ((char *)NULL))
  {
    vsiz = 0;
    val=cbmemdup("", 0);
  }

  cop = oper;
  if((signed int)*cop == 33)
  {
    sign = 0;
    cop = cop + 1l;
  }

  else
    sign = 1;
  _Bool tmp_if_expr$4;
  if((signed int)*cop == 73)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed int)*cop == 105 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    signed int return_value_est_check_cjk_only$3;
    return_value_est_check_cjk_only$3=est_check_cjk_only(val);
    ic = (signed int)!(return_value_est_check_cjk_only$3 != 0);
    cop = cop + 1l;
  }

  else
    ic = 0;
  regex = (void *)0;
  signed int return_value_cbstricmp$20;
  return_value_cbstricmp$20=cbstricmp(cop, "STREQ");
  signed int return_value_cbstricmp$19;
  signed int return_value_cbstricmp$18;
  signed int return_value_cbstricmp$17;
  signed int return_value_cbstricmp$16;
  signed int return_value_cbstricmp$15;
  signed int return_value_cbstricmp$14;
  signed int return_value_cbstricmp$13;
  signed int return_value_cbstricmp$12;
  signed int return_value_cbstricmp$11;
  signed int return_value_cbstricmp$10;
  signed int return_value_cbstricmp$9;
  signed int return_value_cbstricmp$8;
  signed int return_value_cbstricmp$7;
  signed int return_value_cbstricmp$6;
  signed int return_value_cbstricmp$5;
  if(return_value_cbstricmp$20 == 0)
    cop = "STREQ";

  else
  {
    return_value_cbstricmp$19=cbstricmp(cop, "STRNE");
    if(return_value_cbstricmp$19 == 0)
      cop = "STRNE";

    else
    {
      return_value_cbstricmp$18=cbstricmp(cop, "STRINC");
      if(return_value_cbstricmp$18 == 0)
        cop = "STRINC";

      else
      {
        return_value_cbstricmp$17=cbstricmp(cop, "STRBW");
        if(return_value_cbstricmp$17 == 0)
          cop = "STRBW";

        else
        {
          return_value_cbstricmp$16=cbstricmp(cop, "STREW");
          if(return_value_cbstricmp$16 == 0)
            cop = "STREW";

          else
          {
            return_value_cbstricmp$15=cbstricmp(cop, "STRAND");
            if(return_value_cbstricmp$15 == 0)
              cop = "STRAND";

            else
            {
              return_value_cbstricmp$14=cbstricmp(cop, "STROR");
              if(return_value_cbstricmp$14 == 0)
                cop = "STROR";

              else
              {
                return_value_cbstricmp$13=cbstricmp(cop, "STROREQ");
                if(return_value_cbstricmp$13 == 0)
                  cop = "STROREQ";

                else
                {
                  return_value_cbstricmp$12=cbstricmp(cop, "STRRX");
                  if(return_value_cbstricmp$12 == 0)
                  {
                    cop = "STRRX";
                    regex=est_regex_new(val);
                  }

                  else
                  {
                    return_value_cbstricmp$11=cbstricmp(cop, "NUMEQ");
                    if(return_value_cbstricmp$11 == 0)
                      cop = "NUMEQ";

                    else
                    {
                      return_value_cbstricmp$10=cbstricmp(cop, "NUMNE");
                      if(return_value_cbstricmp$10 == 0)
                        cop = "NUMNE";

                      else
                      {
                        return_value_cbstricmp$9=cbstricmp(cop, "NUMGT");
                        if(return_value_cbstricmp$9 == 0)
                          cop = "NUMGT";

                        else
                        {
                          return_value_cbstricmp$8=cbstricmp(cop, "NUMGE");
                          if(return_value_cbstricmp$8 == 0)
                            cop = "NUMGE";

                          else
                          {
                            return_value_cbstricmp$7=cbstricmp(cop, "NUMLT");
                            if(return_value_cbstricmp$7 == 0)
                              cop = "NUMLT";

                            else
                            {
                              return_value_cbstricmp$6=cbstricmp(cop, "NUMLE");
                              if(return_value_cbstricmp$6 == 0)
                                cop = "NUMLE";

                              else
                              {
                                return_value_cbstricmp$5=cbstricmp(cop, "NUMBT");
                                if(return_value_cbstricmp$5 == 0)
                                  cop = "NUMBT";

                                else
                                {
                                  cop = "STRINC";
                                  val[(signed long int)0] = (char)0;
                                  vsiz = 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  num=cbstrmktime(val);
  const char *return_value_cbmapget$21;
  return_value_cbmapget$21=cbmapget(db->aidxs, name, nsiz, (signed int *)(void *)0);
  attridx = (struct anonymous$16 *)return_value_cbmapget$21;
  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$22;
  if(attridx == ((struct anonymous$16 *)NULL))
    tmp_if_expr$23 = (_Bool)1;

  else
  {
    if(!(attridx->type == 1))
      tmp_if_expr$22 = attridx->type != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$22 = (_Bool)0;
    tmp_if_expr$23 = tmp_if_expr$22 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$24;
  if(tmp_if_expr$23)
    tmp_if_expr$24 = (_Bool)1;

  else
    tmp_if_expr$24 = (((((((attridx->type == 2 ? (cop != "NUMEQ" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMNE" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMGT" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMGE" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMLT" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMLE" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (cop != "NUMBT" ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$32;
  signed int return_value_strcmp$33;
  _Bool tmp_if_expr$36;
  char *tmp_post$35;
  signed long int return_value_cbstrmktime$37;
  signed long int return_value_cbstrmktime$39;
  signed long int return_value_cbstrmktime$41;
  if(tmp_if_expr$24)
  {
    if(!(regex == NULL))
      est_regex_delete(regex);

    free((void *)val);
    free((void *)oper);
    free((void *)name);
    return (struct anonymous$6 *)(void *)0;
  }

  else
  {
    do
    {
      void *return_value_malloc$25;
      return_value_malloc$25=malloc(sizeof(struct anonymous$2) /*16ul*/ );
      abuf = (struct anonymous$2 *)return_value_malloc$25;
      if(!(abuf == ((struct anonymous$2 *)NULL)))
        abuf;

      else
        cbmyfatal("out of memory");
      void *return_value_malloc$26;
      return_value_malloc$26=malloc((unsigned long int)12);
      abuf->dptr = (char *)return_value_malloc$26;
      if(!(abuf->dptr == ((char *)NULL)))
        abuf->dptr;

      else
        cbmyfatal("out of memory");
      abuf->dptr[(signed long int)0] = (char)0;
      abuf->dsize = 0;
      abuf->asize = 12;
    }
    while((_Bool)0);
    if(sign == 0 || !(ic == 0))
    {
      if(!(ic == 0))
      {
        char *return_value_est_uconv_in$27;
        return_value_est_uconv_in$27=est_uconv_in(val, vsiz, &tsiz);
        utmp = (unsigned char *)return_value_est_uconv_in$27;
        est_normalize_text(utmp, tsiz, &tsiz);
        est_canonicalize_text(utmp, tsiz, 0);
        char *return_value_est_uconv_out$28;
        return_value_est_uconv_out$28=est_uconv_out((char *)utmp, tsiz, &ssiz);
        sval = (char *)return_value_est_uconv_out$28;
        free((void *)utmp);
      }

      else
      {
        sval = (char *)(void *)0;
        ssiz = 0;
      }
      esc = 0x7fffffff;
      jmp = 0x7fffffff;
      if(vsiz >= 1 && !(sign == 0) && (cop == "STRBW" || cop == "STREQ"))
      {
        if((signed int)*sval >= 1)
          tmp_if_expr$29 = (signed int)*sval < 0x7f ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$29 = (_Bool)0;
        if(tmp_if_expr$29)
        {
          numbuf[(signed long int)0] = *sval;
          numbuf[(signed long int)1] = (char)0;
          esc = (signed int)*((unsigned char *)sval);
          if((signed int)*sval >= 97)
          {
            if(!((signed int)*sval >= 123))
            {
              numbuf[(signed long int)0] = numbuf[(signed long int)0] - (char)(97 - 65);
              jmp = ((signed int)*sval - 97) + 65;
            }

          }

          vlcurjump((struct anonymous$7 *)attridx->db, numbuf, 1, 0);
        }

        else
          if((signed int)*((unsigned char *)sval) >= 0xc0)
          {
            numbuf[(signed long int)0] = *sval;
            numbuf[(signed long int)1] = (char)0;
            esc = (signed int)*((unsigned char *)sval);
            vlcurjump((struct anonymous$7 *)attridx->db, numbuf, 1, 0);
          }

          else
            vlcurfirst((struct anonymous$7 *)attridx->db);
      }

      else
        vlcurfirst((struct anonymous$7 *)attridx->db);
      do
      {
        kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, &ksiz);
        if(kbuf == ((const char *)NULL))
          break;

        signed int return_value_est_match_attr$31;
        return_value_est_match_attr$31=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, sign, val, vsiz, sval, ssiz, regex, (signed int)num);
        if(!(return_value_est_match_attr$31 == 0))
          do
          {
            if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
            {
              abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
              void *return_value_realloc$30;
              return_value_realloc$30=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
              abuf->dptr = (char *)return_value_realloc$30;
              if(!(abuf->dptr == ((char *)NULL)))
                abuf->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
            abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
            abuf->dptr[(signed long int)abuf->dsize] = (char)0;
          }
          while((_Bool)0);

        if(!(jmp >= (signed int)*((unsigned char *)kbuf)))
          tmp_if_expr$32 = (signed int)*((unsigned char *)kbuf) < (signed int)*((unsigned char *)sval) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$32 = (_Bool)0;
        if(tmp_if_expr$32)
        {
          numbuf[(signed long int)0] = *sval;
          numbuf[(signed long int)1] = (char)0;
          vlcurjump((struct anonymous$7 *)attridx->db, numbuf, 1, 0);
          jmp = 0x7fffffff;
        }

        else
          if(!(esc >= (signed int)*((unsigned char *)kbuf)))
            break;

          else
            vlcurnext((struct anonymous$7 *)attridx->db);
      }
      while((_Bool)1);
      if(!(sval == ((char *)NULL)))
        free((void *)sval);

    }

    else
      if(cop == "STROREQ")
      {
        tokens=cbsplit(val, vsiz, " ,");
        cblistsort(tokens);
        i = 0;
        for( ; !(i >= tokens->num); i = i + 1)
        {
          tsiz = (tokens->array + (signed long int)(tokens->start + i))->dsize;
          tbuf = (const char *)(tokens->array + (signed long int)(tokens->start + i))->dptr;
          vlcurjump((struct anonymous$7 *)attridx->db, tbuf, tsiz, 0);
          do
          {
            kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            return_value_strcmp$33=strcmp(kbuf, tbuf);
            if(!(return_value_strcmp$33 == 0))
              break;

            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc$34;
                return_value_realloc$34=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc$34;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);
            vlcurnext((struct anonymous$7 *)attridx->db);
          }
          while((_Bool)1);
        }
        do
        {
          signed int _CB_i;
          signed int _CB_end = tokens->start + tokens->num;
          _CB_i = tokens->start;
          for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
            free((void *)(tokens->array + (signed long int)_CB_i)->dptr);
          free((void *)tokens->array);
          free((void *)tokens);
        }
        while((_Bool)0);
      }

      else
        if(cop == "NUMBT")
        {
          wp=strchr(val, 32);
          if(!(wp == ((char *)NULL)))
            tmp_if_expr$36 = (_Bool)1;

          else
          {
            wp=strchr(val, 9);
            tmp_if_expr$36 = wp != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$36)
          {
            tmp_post$35 = wp;
            wp = wp + 1l;
            *tmp_post$35 = (char)0;
            for( ; (_Bool)1; wp = wp + 1l)
              if(!((signed int)*wp == 32))
              {
                if(!((signed int)*wp == 9))
                  goto __CPROVER_DUMP_L86;

              }


          __CPROVER_DUMP_L86:
            ;
            lower=cbstrmktime(val);
            upper=cbstrmktime(wp);
          }

          else
          {
            lower=cbstrmktime(val);
            upper = (signed long int)0x7fffffff;
          }
          len=sprintf(numbuf, "%.0f", (double)lower);
          vlcurjump((struct anonymous$7 *)attridx->db, numbuf, len, 0);
          do
          {
            kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            return_value_cbstrmktime$37=cbstrmktime(kbuf);
            if(!(upper >= return_value_cbstrmktime$37))
              break;

            do
            {
              if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
              {
                abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                void *return_value_realloc$38;
                return_value_realloc$38=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                abuf->dptr = (char *)return_value_realloc$38;
                if(!(abuf->dptr == ((char *)NULL)))
                  abuf->dptr;

                else
                  cbmyfatal("out of memory");
              }

              memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
              abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
              abuf->dptr[(signed long int)abuf->dsize] = (char)0;
            }
            while((_Bool)0);
            vlcurnext((struct anonymous$7 *)attridx->db);
          }
          while((_Bool)1);
        }

        else
        {
          if(cop == "NUMEQ" || cop == "NUMGE" || cop == "NUMGT" || cop == "STRBW" || cop == "STREQ")
          {
            vlcurjump((struct anonymous$7 *)attridx->db, val, vsiz, 0);
            if(cop == "NUMGT")
              do
              {
                kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, (signed int *)(void *)0);
                if(kbuf == ((const char *)NULL))
                  break;

                return_value_cbstrmktime$39=cbstrmktime(kbuf);
                if(!(num >= return_value_cbstrmktime$39))
                  break;

                vlcurnext((struct anonymous$7 *)attridx->db);
              }
              while((_Bool)1);

          }

          else
            if(cop == "NUMLE" || cop == "NUMLT")
            {
              signed long int return_value_cbstrmktime$40;
              return_value_cbstrmktime$40=cbstrmktime(val);
              len=sprintf(numbuf, "%.0f", (double)return_value_cbstrmktime$40 + (double)1);
              vlcurjump((struct anonymous$7 *)attridx->db, numbuf, len, 1);
              if(cop == "NUMLT")
                do
                {
                  kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, (signed int *)(void *)0);
                  if(kbuf == ((const char *)NULL))
                    break;

                  return_value_cbstrmktime$41=cbstrmktime(kbuf);
                  if(!(return_value_cbstrmktime$41 >= num))
                    break;

                  vlcurprev((struct anonymous$7 *)attridx->db);
                }
                while((_Bool)1);

            }

            else
              vlcurfirst((struct anonymous$7 *)attridx->db);
          do
          {
            kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, &ksiz);
            if(kbuf == ((const char *)NULL))
              break;

            signed int return_value_est_match_attr$43;
            return_value_est_match_attr$43=est_match_attr(kbuf, (signed int)(((unsigned long int)ksiz - sizeof(signed int) /*4ul*/ ) - (unsigned long int)1), cop, 1, val, vsiz, (const char *)(void *)0, 0, regex, (signed int)num);
            if(!(return_value_est_match_attr$43 == 0))
              do
              {
                if(sizeof(signed int) /*4ul*/  + (unsigned long int)abuf->dsize >= (unsigned long int)abuf->asize)
                {
                  abuf->asize = (signed int)((unsigned long int)(abuf->asize * 2) + sizeof(signed int) /*4ul*/  + (unsigned long int)1);
                  void *return_value_realloc$42;
                  return_value_realloc$42=realloc((void *)abuf->dptr, (unsigned long int)abuf->asize);
                  abuf->dptr = (char *)return_value_realloc$42;
                  if(!(abuf->dptr == ((char *)NULL)))
                    abuf->dptr;

                  else
                    cbmyfatal("out of memory");
                }

                memcpy((void *)(abuf->dptr + (signed long int)abuf->dsize), (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
                abuf->dsize = abuf->dsize + (signed int)sizeof(signed int) /*4ul*/ ;
                abuf->dptr[(signed long int)abuf->dsize] = (char)0;
              }
              while((_Bool)0);

            else
              if(cop == "NUMEQ" || cop == "STRBW" || cop == "STREQ")
                break;

            if(cop == "NUMLE" || cop == "NUMLT")
              vlcurprev((struct anonymous$7 *)attridx->db);

            else
              vlcurnext((struct anonymous$7 *)attridx->db);
          }
          while((_Bool)1);
        }
    ary = (signed int *)(const char *)abuf->dptr;
    anum = (signed int)((unsigned long int)(signed int)abuf->dsize / sizeof(signed int) /*4ul*/ );
    void *return_value_malloc$44;
    return_value_malloc$44=malloc((unsigned long int)anum * sizeof(struct anonymous$6) /*16ul*/  + (unsigned long int)1);
    scores = (struct anonymous$6 *)return_value_malloc$44;
    if(!(scores == ((struct anonymous$6 *)NULL)))
      scores;

    else
      cbmyfatal("out of memory");
    i = 0;
    for( ; !(i >= anum); i = i + 1)
    {
      (scores + (signed long int)i)->id = ary[(signed long int)i];
      (scores + (signed long int)i)->score = 0;
      (scores + (signed long int)i)->value = (char *)(void *)0;
    }
    *nump = anum;
    do
    {
      free((void *)abuf->dptr);
      free((void *)abuf);
    }
    while((_Bool)0);
    if(!(regex == NULL))
      est_regex_delete(regex);

    free((void *)val);
    free((void *)oper);
    free((void *)name);
    return scores;
  }
}

// est_search_keywords
// file estraier.c line 8802
static struct anonymous$6 * est_search_keywords(struct anonymous *db, const char *word, signed int min, signed int *nump)
{
  struct anonymous$6 *scores;
  struct anonymous$1 *words;
  struct anonymous$2 *rbuf;
  const signed int *res;
  signed int i;
  signed int rnum;
  signed int snum;
  signed int wsiz;
  signed int nnum;
  signed int lid;
  const char *return_value_vlgetcache$2;
  if(!((signed int)*word == 32))
  {
    return_value_vlgetcache$2=vlgetcache(db->auxdb, word, -1, &rnum);
    res = (signed int *)return_value_vlgetcache$2;
    if(!(res == ((const signed int *)NULL)))
    {
      rnum = rnum / (signed int)sizeof(signed int) /*4ul*/ ;
      if(rnum / 2 >= min)
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc((unsigned long int)(rnum / 2) * sizeof(struct anonymous$6) /*16ul*/  + (unsigned long int)1);
        scores = (struct anonymous$6 *)return_value_malloc$1;
        if(!(scores == ((struct anonymous$6 *)NULL)))
          scores;

        else
          cbmyfatal("out of memory");
        snum = 0;
        i = 0;
        for( ; !(i >= rnum); i = i + 2)
        {
          (scores + (signed long int)snum)->id = res[(signed long int)i];
          (scores + (signed long int)snum)->score = res[(signed long int)(i + 1)];
          snum = snum + 1;
        }
        *nump = snum;
        return scores;
      }

    }

  }

  do
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct anonymous$1) /*24ul*/ );
    words = (struct anonymous$1 *)return_value_malloc$3;
    if(!(words == ((struct anonymous$1 *)NULL)))
      words;

    else
      cbmyfatal("out of memory");
    words->anum = 64;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)words->anum);
    words->array = (struct anonymous$28 *)return_value_malloc$4;
    if(!(words->array == ((struct anonymous$28 *)NULL)))
      words->array;

    else
      cbmyfatal("out of memory");
    words->start = 0;
    words->num = 0;
  }
  while((_Bool)0);
  if((signed int)*word == 32)
  {
    word = word + 1l;
    if((signed int)*word == 98)
      est_expand_keyword_bw(db, word + (signed long int)1, words);

    else
      if((signed int)*word == 101)
        est_expand_keyword_ew(db, word + (signed long int)1, words);

      else
        if((signed int)*word == 114)
          est_expand_keyword_rx(db, word + (signed long int)1, words);

  }

  else
    if((signed int)*((unsigned char *)word) >= 0xe3)
      est_expand_keyword_bw(db, word, words);

  do
  {
    void *return_value_malloc$5;
    return_value_malloc$5=malloc(sizeof(struct anonymous$2) /*16ul*/ );
    rbuf = (struct anonymous$2 *)return_value_malloc$5;
    if(!(rbuf == ((struct anonymous$2 *)NULL)))
      rbuf;

    else
      cbmyfatal("out of memory");
    void *return_value_malloc$6;
    return_value_malloc$6=malloc((unsigned long int)12);
    rbuf->dptr = (char *)return_value_malloc$6;
    if(!(rbuf->dptr == ((char *)NULL)))
      rbuf->dptr;

    else
      cbmyfatal("out of memory");
    rbuf->dptr[(signed long int)0] = (char)0;
    rbuf->dsize = 0;
    rbuf->asize = 12;
  }
  while((_Bool)0);
  i = 0;
  _Bool tmp_if_expr$7;
  do
  {
    if(!(i >= words->num))
      tmp_if_expr$7 = (unsigned long int)(signed int)rbuf->dsize <= sizeof(signed int) /*4ul*/  * (unsigned long int)2 * (unsigned long int)min * (unsigned long int)16 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(!tmp_if_expr$7)
      break;

    wsiz = (words->array + (signed long int)(words->start + i))->dsize;
    word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
    const char *return_value_vlgetcache$8;
    return_value_vlgetcache$8=vlgetcache(db->auxdb, word, wsiz, &rnum);
    res = (signed int *)return_value_vlgetcache$8;
    if(!(res == ((const signed int *)NULL)))
      do
      {
        if(rbuf->dsize + rnum >= rbuf->asize)
        {
          rbuf->asize = rbuf->asize * 2 + rnum + 1;
          void *return_value_realloc$9;
          return_value_realloc$9=realloc((void *)rbuf->dptr, (unsigned long int)rbuf->asize);
          rbuf->dptr = (char *)return_value_realloc$9;
          if(!(rbuf->dptr == ((char *)NULL)))
            rbuf->dptr;

          else
            cbmyfatal("out of memory");
        }

        memcpy((void *)(rbuf->dptr + (signed long int)rbuf->dsize), (const void *)(char *)res, (unsigned long int)rnum);
        rbuf->dsize = rbuf->dsize + rnum;
        rbuf->dptr[(signed long int)rbuf->dsize] = (char)0;
      }
      while((_Bool)0);

    i = i + 1;
  }
  while((_Bool)1);
  res = (signed int *)(const char *)rbuf->dptr;
  rnum = (signed int)rbuf->dsize;
  rnum = rnum / (signed int)sizeof(signed int) /*4ul*/ ;
  if(!(rnum / 2 >= min))
  {
    do
    {
      free((void *)rbuf->dptr);
      free((void *)rbuf);
    }
    while((_Bool)0);
    do
    {
      signed int est_search_keywords$$1$$7$$2$$_CB_i;
      signed int _CB_end = words->start + words->num;
      est_search_keywords$$1$$7$$2$$_CB_i = words->start;
      for( ; !(est_search_keywords$$1$$7$$2$$_CB_i >= _CB_end); est_search_keywords$$1$$7$$2$$_CB_i = est_search_keywords$$1$$7$$2$$_CB_i + 1)
        free((void *)(words->array + (signed long int)est_search_keywords$$1$$7$$2$$_CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    return (struct anonymous$6 *)(void *)0;
  }

  else
  {
    void *return_value_malloc$10;
    return_value_malloc$10=malloc((unsigned long int)(rnum / 2) * sizeof(struct anonymous$6) /*16ul*/  + (unsigned long int)1);
    scores = (struct anonymous$6 *)return_value_malloc$10;
    if(!(scores == ((struct anonymous$6 *)NULL)))
      scores;

    else
      cbmyfatal("out of memory");
    snum = 0;
    i = 0;
    for( ; !(i >= rnum); i = i + 2)
    {
      (scores + (signed long int)snum)->id = res[(signed long int)i];
      (scores + (signed long int)snum)->score = res[(signed long int)(i + 1)];
      snum = snum + 1;
    }
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
    nnum = 0;
    lid = -1;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
      if(nnum >= 1)
      {
        if(!((scores + (signed long int)i)->id == lid))
          goto __CPROVER_DUMP_L38;

        (scores + (signed long int)(nnum - 1))->score = (scores + (signed long int)(nnum - 1))->score + (scores + (signed long int)i)->score;
      }

      else
      {

      __CPROVER_DUMP_L38:
        ;
        (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
        (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
        nnum = nnum + 1;
        lid = (scores + (signed long int)i)->id;
      }
    do
    {
      free((void *)rbuf->dptr);
      free((void *)rbuf);
    }
    while((_Bool)0);
    do
    {
      signed int _CB_i;
      signed int est_search_keywords$$1$$11$$_CB_end = words->start + words->num;
      _CB_i = words->start;
      for( ; !(_CB_i >= est_search_keywords$$1$$11$$_CB_end); _CB_i = _CB_i + 1)
        free((void *)(words->array + (signed long int)_CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    *nump = nnum;
    return scores;
  }
}

// est_search_pidxs
// file estraier.c line 9234
static struct anonymous$6 * est_search_pidxs(struct anonymous *db, struct anonymous$8 *cond, struct anonymous$6 *scores, signed int *nump, struct anonymous$9 *ordattrs)
{
  struct anonymous$11 *list;
  struct anonymous$0 *doc;
  const char *otype;
  const char *lbuf;
  const char *vbuf;
  char *oname;
  char *wp;
  signed int i;
  signed int j;
  signed int k;
  signed int snum;
  signed int anum;
  signed int id;
  signed int hit;
  signed int sc;
  signed int miss;
  signed int lsiz;
  signed int vsiz;
  double avg;
  double sd;
  double dif;
  double tune;
  snum = *nump;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)scores, (unsigned long int)(snum + (signed int)db->pdocs->num) * sizeof(struct anonymous$6) /*16ul*/  + (unsigned long int)1);
  scores = (struct anonymous$6 *)return_value_realloc$1;
  if(!(scores == ((struct anonymous$6 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  signed int return_value_cbstrfwmatch$3;
  signed int return_value_cbstrfwmatch$2;
  if(!(cond->phrase == ((char *)NULL)))
  {
    signed int return_value_cbstrfwmatch$4;
    return_value_cbstrfwmatch$4=cbstrfwmatch(cond->phrase, "[ID]");
    if(!(return_value_cbstrfwmatch$4 == 0))
      return scores;

    else
    {
      return_value_cbstrfwmatch$3=cbstrfwmatch(cond->phrase, "[URI]");
      if(!(return_value_cbstrfwmatch$3 == 0))
        return scores;

      else
      {
        return_value_cbstrfwmatch$2=cbstrfwmatch(cond->phrase, "[SIMILAR]");
        if(!(return_value_cbstrfwmatch$2 == 0))
          return scores;

      }
    }
  }

  oname = (char *)(void *)0;
  otype = (const char *)(void *)0;
  char *tmp_post$5;
  if(!(cond->order == ((char *)NULL)))
  {
    oname=cbmemdup(cond->order, -1);
    cbstrtrim(oname);
    otype = "STRA";
    wp=strchr(oname, 32);
    if(!(wp == ((char *)NULL)))
    {
      tmp_post$5 = wp;
      wp = wp + 1l;
      *tmp_post$5 = (char)0;
      for( ; (signed int)*wp == 32; wp = wp + 1l)
        ;
      otype = wp;
    }

  }

  list = (struct anonymous$11 *)(void *)0;
  anum = -1;
  if(!(cond->attrs == ((struct anonymous$1 *)NULL)))
    list=est_make_cattr_list(cond->attrs, &anum);

  i = 0;
  _Bool tmp_if_expr$7;
  signed int return_value_cbstrfwmatch$6;
  _Bool tmp_if_expr$10;
  signed int return_value_est_match_attr$9;
  _Bool tmp_if_expr$11;
  for( ; !(i >= db->pdocs->num); i = i + 1)
  {
    id = 2000000001 + i;
    hit = 0;
    sc = 0;
    doc = (struct anonymous$0 *)(void *)0;
    if(cond->phrase == ((char *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)cond->phrase[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      hit = cond->attrs != ((struct anonymous$1 *)NULL) ? 1 : 0;

    else
    {
      return_value_cbstrfwmatch$6=cbstrfwmatch(cond->phrase, "[UVSET]");
      if(!(return_value_cbstrfwmatch$6 == 0))
        hit = 1;

      else
      {
        doc=est_db_get_doc(db, id, 0);
        if(!(doc == ((struct anonymous$0 *)NULL)))
          hit=est_db_score_doc(db, doc, cond, &sc);

        else
          hit = 0;
      }
    }
    if(!(list == ((struct anonymous$11 *)NULL)) && !(hit == 0))
    {
      if(doc == ((struct anonymous$0 *)NULL))
      {
        doc=est_db_get_doc(db, id, 0);
        tmp_if_expr$10 = !(doc != ((struct anonymous$0 *)NULL)) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
        hit = 0;

      else
      {
        miss = 0;
        j = 0;
        for( ; miss == 0 && !(j >= anum); j = j + 1)
          if((list + (signed long int)j)->nsiz >= 1)
          {
            if(!((list + (signed long int)j)->nlist == ((struct anonymous$1 *)NULL)))
            {
              hit = 0;
              k = 0;
              for( ; !(k >= (list + (signed long int)j)->nlist->num); k = k + 1)
              {
                lsiz = ((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dsize;
                lbuf = (const char *)((list + (signed long int)j)->nlist->array + (signed long int)((list + (signed long int)j)->nlist->start + k))->dptr;
                if(lsiz >= 1)
                {
                  vbuf=cbmapget(doc->attrs, lbuf, lsiz, &vsiz);
                  if(!(vbuf == ((const char *)NULL)))
                  {
                    signed int return_value_est_match_attr$8;
                    return_value_est_match_attr$8=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                    if(!(return_value_est_match_attr$8 == 0))
                    {
                      hit = 1;
                      break;
                    }

                  }

                }

              }
              if(hit == 0)
                miss = 1;

            }

            else
            {
              vbuf=cbmapget(doc->attrs, (list + (signed long int)j)->name, (list + (signed long int)j)->nsiz, &vsiz);
              if(vbuf == ((const char *)NULL))
                miss = 1;

              else
              {
                return_value_est_match_attr$9=est_match_attr(vbuf, vsiz, (list + (signed long int)j)->cop, (list + (signed long int)j)->sign, (list + (signed long int)j)->val, (list + (signed long int)j)->vsiz, (list + (signed long int)j)->sval, (list + (signed long int)j)->ssiz, (list + (signed long int)j)->regex, (signed int)(list + (signed long int)j)->num);
                if(return_value_est_match_attr$9 == 0)
                  miss = 1;

              }
            }
          }

        hit = (signed int)!(miss != 0);
      }
    }

    if(!(hit == 0))
    {
      (scores + (signed long int)snum)->id = id;
      (scores + (signed long int)snum)->score = sc;
      (scores + (signed long int)snum)->value = (char *)(void *)0;
      snum = snum + 1;
      if(!(oname == ((char *)NULL)))
      {
        if(!(doc == ((struct anonymous$0 *)NULL)))
          tmp_if_expr$11 = (_Bool)1;

        else
        {
          doc=est_db_get_doc(db, id, 0);
          tmp_if_expr$11 = doc != (struct anonymous$0 *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$11)
        {
          vbuf=cbmapget(doc->attrs, oname, -1, &vsiz);
          if(vbuf == ((const char *)NULL))
          {
            vbuf = "";
            vsiz = 0;
          }

          cbmapput(ordattrs, (char *)&id, (signed int)sizeof(signed int) /*4ul*/ , vbuf, vsiz, 0);
        }

      }

    }

    if(!(doc == ((struct anonymous$0 *)NULL)))
      est_doc_delete(doc);

  }
  if(!(list == ((struct anonymous$11 *)NULL)))
    est_free_cattr_list(list, anum);

  if(!(oname == ((char *)NULL)))
    free((void *)oname);

  if(!(db->smode == 4194304))
  {
    if(!(*nump >= snum))
    {
      avg = 0.0;
      i = *nump;
      for( ; !(i >= snum); i = i + 1)
        avg = avg + (double)(scores + (signed long int)i)->score;
      avg = avg / (double)(snum - *nump);
      sd = 0.0;
      i = *nump;
      for( ; !(i >= snum); i = i + 1)
      {
        dif = avg - (double)(scores + (signed long int)i)->score;
        sd = sd + dif * dif;
      }
      sd = sd / (double)(snum - *nump);
      sd=sqrt(sd);
      if(sd < 0.1)
      {
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = 1000 / 2;
      }

      else
      {
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = (signed int)((((double)(scores + (signed long int)i)->score - avg) * ((double)1000 / 10.0)) / sd + (double)1000 / 2.0);
      }
      if(!(cond->tfidf == 0))
      {
        tune=pow((double)((snum - *nump) + 64), 0.4);
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = (scores + (signed long int)i)->score * (signed int)(100.0 / tune);
      }

      else
      {
        i = *nump;
        for( ; !(i >= snum); i = i + 1)
          (scores + (signed long int)i)->score = (scores + (signed long int)i)->score * 10;
      }
    }

  }

  *nump = snum;
  return scores;
}

// est_search_rank
// file estraier.c line 8916
static struct anonymous$6 * est_search_rank(struct anonymous *db, const char *name, signed int top, signed int *nump)
{
  struct anonymous$16 *attridx;
  struct anonymous$6 *scores;
  const char *kbuf;
  signed int snum;
  signed int ksiz;
  signed int id;
  _Bool tmp_if_expr$3;
  const char *return_value_cbmapget$2;
  if(top == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_cbmapget$2=cbmapget(db->aidxs, name, -1, (signed int *)(void *)0);
    attridx = (struct anonymous$16 *)return_value_cbmapget$2;
    tmp_if_expr$3 = !(attridx != ((struct anonymous$16 *)NULL)) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(!(attridx->type == 1))
      tmp_if_expr$4 = attridx->type != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    *nump = 0;
    void *return_value_cbmalloc$1;
    return_value_cbmalloc$1=cbmalloc((unsigned long int)1);
    return (struct anonymous$6 *)return_value_cbmalloc$1;
  }

  snum=abs(top);
  if(!(db->dnum >= snum))
    snum = db->dnum;

  void *return_value_malloc$6;
  return_value_malloc$6=malloc((unsigned long int)snum * sizeof(struct anonymous$6) /*16ul*/  + (unsigned long int)1);
  scores = (struct anonymous$6 *)return_value_malloc$6;
  if(!(scores == ((struct anonymous$6 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  if(top >= 1)
  {
    vlcurfirst((struct anonymous$7 *)attridx->db);
    while(!(snum >= top))
    {
      kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      if(!((unsigned long int)ksiz >= sizeof(signed int) /*4ul*/ ))
        vlcurnext((struct anonymous$7 *)attridx->db);

      else
      {
        memcpy((void *)&id, (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
        if(!(id >= 1))
          vlcurnext((struct anonymous$7 *)attridx->db);

        else
        {
          (scores + (signed long int)snum)->id = id;
          (scores + (signed long int)snum)->score = 0;
          (scores + (signed long int)snum)->value = (char *)(void *)0;
          snum = snum + 1;
          vlcurnext((struct anonymous$7 *)attridx->db);
        }
      }
    }
  }

  else
  {
    top = top * -1;
    vlcurlast((struct anonymous$7 *)attridx->db);
    while(!(snum >= top))
    {
      kbuf=vlcurkeycache((struct anonymous$7 *)attridx->db, &ksiz);
      if(kbuf == ((const char *)NULL))
        break;

      if(!((unsigned long int)ksiz >= sizeof(signed int) /*4ul*/ ))
        vlcurprev((struct anonymous$7 *)attridx->db);

      else
      {
        memcpy((void *)&id, (const void *)((kbuf + (signed long int)ksiz) - (signed long int)sizeof(signed int) /*4ul*/ ), sizeof(signed int) /*4ul*/ );
        if(!(id >= 1))
          vlcurprev((struct anonymous$7 *)attridx->db);

        else
        {
          (scores + (signed long int)snum)->id = id;
          (scores + (signed long int)snum)->score = 0;
          (scores + (signed long int)snum)->value = (char *)(void *)0;
          snum = snum + 1;
          vlcurprev((struct anonymous$7 *)attridx->db);
        }
      }
    }
  }
  *nump = snum;
  return scores;
}

// est_search_similar
// file estraier.c line 10222
static struct anonymous$6 * est_search_similar(struct anonymous *db, struct anonymous$9 *svmap, signed int *nump, signed int knum, signed int unum, signed int mnum, signed int tfidf, double nmin, signed int auxmin, struct anonymous$9 *auxwords)
{
  struct anonymous$6 *scores;
  struct anonymous$6 *tscores;
  struct anonymous$9 *tvmap;
  const char *word;
  signed int i;
  signed int j;
  signed int vnum;
  signed int snum;
  signed int tmax;
  signed int tsnum;
  signed int nnum;
  signed int lid;
  signed int *svec;
  signed int *tvec;
  double dval;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$6) /*16ul*/  * (unsigned long int)(unum * knum + (signed int)db->pdocs->num) + (unsigned long int)1);
  scores = (struct anonymous$6 *)return_value_malloc$1;
  if(!(scores == ((struct anonymous$6 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  vnum=cbmaprnum(svmap);
  if(!(vnum >= 1))
    vnum = 1;

  cbmapiterinit(svmap);
  tmax = unum;
  i = 0;
  _Bool tmp_if_expr$2;
  do
  {
    if(!(i >= 2 * knum) && !(snum >= 2 * unum) || !(i >= knum))
    {
      word=cbmapiternext(svmap, (signed int *)(void *)0);
      tmp_if_expr$2 = word != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    for( ; (signed int)*word >= 1; word = word + 1l)
      if((signed int)*word >= 33)
        break;

    tscores=est_search_union(db, word, 1, (void (*)(const char *, struct anonymous$1 *))(void *)0, &tsnum, (struct anonymous$9 *)(void *)0, 1, auxmin, auxwords);
    qsort((void *)tscores, (unsigned long int)tsnum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);
    j = 0;
    for( ; !(j >= tmax) && !(j >= tsnum); j = j + 1)
    {
      (scores + (signed long int)snum)->id = (tscores + (signed long int)j)->id;
      (scores + (signed long int)snum)->score = (signed int)((double)(tscores + (signed long int)j)->score * ((double)knum * 2.2 - (double)i));
      snum = snum + 1;
    }
    free((void *)tscores);
    tmax = tmax - (signed int)((double)(unum / knum) / 1.25);
    if(!(tmax >= unum / 4))
      tmax = unum / 4;

    i = i + 1;
  }
  while((_Bool)1);
  i = 0;
  for( ; !(i >= db->pdocs->num); i = i + 1)
  {
    (scores + (signed long int)snum)->id = 2000000001 + i;
    (scores + (signed long int)snum)->score = 1;
    snum = snum + 1;
  }
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
  nnum = 0;
  lid = -1;
  i = 0;
  for( ; !(i >= snum); i = i + 1)
    if(nnum >= 1)
    {
      if(!((scores + (signed long int)i)->id == lid))
        goto __CPROVER_DUMP_L16;

      (scores + (signed long int)(nnum - 1))->score = (scores + (signed long int)(nnum - 1))->score + (scores + (signed long int)i)->score;
    }

    else
    {

    __CPROVER_DUMP_L16:
      ;
      (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
      (scores + (signed long int)nnum)->score = (scores + (signed long int)i)->score;
      nnum = nnum + 1;
      lid = (scores + (signed long int)i)->id;
    }
  snum = nnum;
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_score_desc);
  nnum = 0;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
  svec = (signed int *)return_value_malloc$3;
  if(!(svec == ((signed int *)NULL)))
    svec;

  else
    cbmyfatal("out of memory");
  void *return_value_malloc$4;
  return_value_malloc$4=malloc((unsigned long int)vnum * sizeof(signed int) /*4ul*/ );
  tvec = (signed int *)return_value_malloc$4;
  if(!(tvec == ((signed int *)NULL)))
    tvec;

  else
    cbmyfatal("out of memory");
  est_vector_set_seed(svmap, svec, vnum);
  i = 0;
  for( ; !(i >= snum) && !(nnum >= mnum); i = i + 1)
  {
    tvmap=est_get_tvmap(db, (scores + (signed long int)i)->id, vnum, tfidf);
    if(!(tvmap == ((struct anonymous$9 *)NULL)))
    {
      est_vector_set_target(svmap, tvmap, tvec, vnum);
      dval=est_vector_cosine(svec, tvec, vnum);
      if(dval >= nmin)
      {
        (scores + (signed long int)nnum)->id = (scores + (signed long int)i)->id;
        (scores + (signed long int)nnum)->score = (signed int)(dval * (double)10000);
        if((scores + (signed long int)nnum)->score == 9999)
          (scores + (signed long int)nnum)->score = 10000;

        (scores + (signed long int)nnum)->value = (char *)(void *)0;
        nnum = nnum + 1;
      }

      cbmapclose(tvmap);
    }

  }
  free((void *)tvec);
  free((void *)svec);
  snum = nnum;
  *nump = snum;
  return scores;
}

// est_search_union
// file estraier.c line 8420
static struct anonymous$6 * est_search_union(struct anonymous *db, const char *term, signed int gstep, void (*xpn)(const char *, struct anonymous$1 *), signed int *nump, struct anonymous$9 *hints, signed int add, signed int auxmin, struct anonymous$9 *auxwords)
{
  const struct anonymous$6 *cscores;
  struct anonymous$6 *scores;
  struct anonymous$6 *tscores;
  struct anonymous$6 *nscores;
  struct anonymous$9 *umap;
  struct anonymous$1 *words;
  struct anonymous$1 *grams;
  struct anonymous$1 *tgrams;
  const char *ckey;
  const char *word;
  const char *gram;
  const char *rp;
  const char *fnext;
  const char *snext;
  const char *cbuf;
  char *vbuf;
  char *wbuf;
  char numbuf[32l];
  signed int i;
  signed int j;
  signed int k;
  signed int snum;
  signed int smax;
  signed int cksiz;
  signed int single;
  signed int tsmax;
  signed int tsnum;
  signed int nsnum;
  signed int vsiz;
  signed int gcnum;
  signed int gsiz;
  signed int csiz;
  signed int wgstep;
  signed int nnum;
  signed int west;
  signed int wild;
  signed int mfsiz;
  signed int mssiz;
  signed int mfhash;
  signed int mshash;
  signed int tfhash;
  signed int tshash;
  signed int id;
  signed int vstep;
  signed int score;
  signed int hit;
  signed int hnum;
  double avg;
  double sd;
  double dif;
  smax = 1024;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)smax * sizeof(struct anonymous$6) /*16ul*/ );
  scores = (struct anonymous$6 *)return_value_malloc$1;
  if(!(scores == ((struct anonymous$6 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  words=cbsplit(term, -1, "\t");
  _Bool tmp_if_expr$2;
  if(!(xpn == ((void (*)(const char *, struct anonymous$1 *))NULL)))
  {
    umap=cbmapopenex(31);
    i = 0;
    for( ; !(i >= words->num); i = i + 1)
    {
      word = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
      if((signed int)*word == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)word[(signed long int)0] == 32 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$2)
      {
        do
        {
          void *return_value_malloc$3;
          return_value_malloc$3=malloc(sizeof(struct anonymous$1) /*24ul*/ );
          grams = (struct anonymous$1 *)return_value_malloc$3;
          if(!(grams == ((struct anonymous$1 *)NULL)))
            grams;

          else
            cbmyfatal("out of memory");
          grams->anum = 64;
          void *return_value_malloc$4;
          return_value_malloc$4=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)grams->anum);
          grams->array = (struct anonymous$28 *)return_value_malloc$4;
          if(!(grams->array == ((struct anonymous$28 *)NULL)))
            grams->array;

          else
            cbmyfatal("out of memory");
          grams->start = 0;
          grams->num = 0;
        }
        while((_Bool)0);
        xpn(word, grams);
        j = 0;
        if(!(j >= grams->num))
        {
          word = (const char *)(grams->array + (signed long int)(grams->start + j))->dptr;
          cbmapput(umap, word, -1, "", 0, 0);
          j = j + 1;
        }

        signed int est_search_union$$1$$1$$1$$1$$3$$_CB_i;
        signed int est_search_union$$1$$1$$1$$1$$3$$_CB_end = grams->start + grams->num;
        est_search_union$$1$$1$$1$$1$$3$$_CB_i = grams->start;
        if(!(est_search_union$$1$$1$$1$$1$$3$$_CB_i >= est_search_union$$1$$1$$1$$1$$3$$_CB_end))
        {
          free((void *)(grams->array + (signed long int)est_search_union$$1$$1$$1$$1$$3$$_CB_i)->dptr);
          est_search_union$$1$$1$$1$$1$$3$$_CB_i = est_search_union$$1$$1$$1$$1$$3$$_CB_i + 1;
        }

        free((void *)grams->array);
        free((void *)grams);
      }

    }
    do
    {
      signed int est_search_union$$1$$1$$2$$_CB_i;
      signed int est_search_union$$1$$1$$2$$_CB_end = words->start + words->num;
      est_search_union$$1$$1$$2$$_CB_i = words->start;
      for( ; !(est_search_union$$1$$1$$2$$_CB_i >= est_search_union$$1$$1$$2$$_CB_end); est_search_union$$1$$1$$2$$_CB_i = est_search_union$$1$$1$$2$$_CB_i + 1)
        free((void *)(words->array + (signed long int)est_search_union$$1$$1$$2$$_CB_i)->dptr);
      free((void *)words->array);
      free((void *)words);
    }
    while((_Bool)0);
    words=cbmapkeys(umap);
    cbmapclose(umap);
  }

  i = 0;
  char *return_value_strchr$35;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$7;
  unsigned long int tmp_if_expr$13;
  unsigned long int return_value_strlen$12;
  _Bool tmp_if_expr$21;
  signed int tmp_if_expr$23;
  signed int return_value_dpinnerhash$22;
  signed int tmp_if_expr$25;
  signed int return_value_dpouterhash$24;
  _Bool tmp_if_expr$31;
  _Bool tmp_if_expr$32;
  char *return_value_strchr$33;
  for( ; !(i >= words->num); i = i + 1)
  {
    cksiz = (words->array + (signed long int)(words->start + i))->dsize;
    ckey = (const char *)(words->array + (signed long int)(words->start + i))->dptr;
    if(cksiz >= 1)
    {
      word = ckey;
      wbuf = (char *)(void *)0;
      cscores=est_rescc_get(db, ckey, cksiz, &tsnum);
      if(!(cscores == ((const struct anonymous$6 *)NULL)))
      {
        if((signed int)*word == 32)
        {
          word = word + 1l;
          if(!((signed int)*word == 0))
            word = word + 1l;

        }

        if(!(hints == ((struct anonymous$9 *)NULL)))
        {
          sprintf(numbuf, "%d", tsnum * (add != 0 ? 1 : -1));
          cbmapput(hints, word, -1, numbuf, -1, 1);
        }

        j = 0;
        for( ; !(j >= tsnum); j = j + 1)
        {
          if(snum >= smax)
          {
            smax = smax * 2;
            void *return_value_realloc$5;
            return_value_realloc$5=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous$6) /*16ul*/ );
            scores = (struct anonymous$6 *)return_value_realloc$5;
            if(!(scores == ((struct anonymous$6 *)NULL)))
              scores;

            else
              cbmyfatal("out of memory");
          }

          (scores + (signed long int)snum)->id = (cscores + (signed long int)j)->id;
          (scores + (signed long int)snum)->score = (cscores + (signed long int)j)->score;
          snum = snum + 1;
        }
      }

      else
      {
        return_value_strchr$35=strchr(word + (signed long int)1, 32);
        if(return_value_strchr$35 == ((char *)NULL) && auxmin >= 1)
        {
          tscores=est_search_keywords(db, word, auxmin, &tsnum);
          tmp_if_expr$36 = tscores != (struct anonymous$6 *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$36 = (_Bool)0;
        if(tmp_if_expr$36)
        {
          if((signed int)*word == 32)
          {
            word = word + 1l;
            if(!((signed int)*word == 0))
              word = word + 1l;

          }

          if(!(hints == ((struct anonymous$9 *)NULL)))
          {
            sprintf(numbuf, "%d", tsnum * (add != 0 ? 1 : -1));
            cbmapput(hints, word, -1, numbuf, -1, 1);
          }

          if(!(auxwords == ((struct anonymous$9 *)NULL)))
            cbmapput(auxwords, word, -1, "", 0, 0);

          j = 0;
          for( ; !(j >= tsnum); j = j + 1)
          {
            if(snum >= smax)
            {
              smax = smax * 2;
              void *return_value_realloc$6;
              return_value_realloc$6=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous$6) /*16ul*/ );
              scores = (struct anonymous$6 *)return_value_realloc$6;
              if(!(scores == ((struct anonymous$6 *)NULL)))
                scores;

              else
                cbmyfatal("out of memory");
            }

            (scores + (signed long int)snum)->id = (tscores + (signed long int)j)->id;
            (scores + (signed long int)snum)->score = (tscores + (signed long int)j)->score;
            snum = snum + 1;
          }
          free((void *)tscores);
        }

        else
        {
          wild = 0;
          if((signed int)*word == 32)
          {
            word = word + 1l;
            if((signed int)*word == 98)
            {
              wild = 98;
              word = word + 1l;
            }

            else
              if((signed int)*word == 101)
              {
                wild = 101;
                word = word + 1l;
              }

              else
                if((signed int)*word == 114)
                {
                  wild = 114;
                  word = word + 1l;
                }

          }

          west = (signed int)((signed int)((unsigned char *)word)[(signed long int)0] <= 0xdf);
          if(west == 0)
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = db->amode != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
            wild = 0;

          single = 0;
          do
          {
            void *return_value_malloc$8;
            return_value_malloc$8=malloc(sizeof(struct anonymous$1) /*24ul*/ );
            grams = (struct anonymous$1 *)return_value_malloc$8;
            if(!(grams == ((struct anonymous$1 *)NULL)))
              grams;

            else
              cbmyfatal("out of memory");
            grams->anum = 64;
            void *return_value_malloc$9;
            return_value_malloc$9=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)grams->anum);
            grams->array = (struct anonymous$28 *)return_value_malloc$9;
            if(!(grams->array == ((struct anonymous$28 *)NULL)))
              grams->array;

            else
              cbmyfatal("out of memory");
            grams->start = 0;
            grams->num = 0;
          }
          while((_Bool)0);
          switch(wild)
          {
            case 98:
            {
              est_break_text(word, grams, 1, 0);
              do
              {
                signed int _CB_index = grams->start + grams->num;
                if(_CB_index >= grams->anum)
                {
                  grams->anum = grams->anum * 2;
                  void *return_value_realloc$10;
                  return_value_realloc$10=realloc((void *)grams->array, (unsigned long int)grams->anum * sizeof(struct anonymous$28) /*16ul*/ );
                  grams->array = (struct anonymous$28 *)return_value_realloc$10;
                  if(!(grams->array == ((struct anonymous$28 *)NULL)))
                    grams->array;

                  else
                    cbmyfatal("out of memory");
                }

                unsigned long int return_value_strlen$11;
                return_value_strlen$11=strlen(word);
                if(!(return_value_strlen$11 >= 12ul))
                  tmp_if_expr$13 = (unsigned long int)12;

                else
                {
                  return_value_strlen$12=strlen(word);
                  tmp_if_expr$13 = return_value_strlen$12;
                }
                void *return_value_malloc$14;
                return_value_malloc$14=malloc(tmp_if_expr$13 + (unsigned long int)1);
                (grams->array + (signed long int)_CB_index)->dptr = (char *)return_value_malloc$14;
                if(!((grams->array + (signed long int)_CB_index)->dptr == ((char *)NULL)))
                  (grams->array + (signed long int)_CB_index)->dptr;

                else
                  cbmyfatal("out of memory");
                unsigned long int return_value_strlen$15;
                return_value_strlen$15=strlen(word);
                memcpy((void *)(grams->array + (signed long int)_CB_index)->dptr, (const void *)word, return_value_strlen$15);
                unsigned long int return_value_strlen$16;
                return_value_strlen$16=strlen(word);
                (grams->array + (signed long int)_CB_index)->dptr[(signed long int)return_value_strlen$16] = (char)0;
                unsigned long int return_value_strlen$17;
                return_value_strlen$17=strlen(word);
                (grams->array + (signed long int)_CB_index)->dsize = (signed int)return_value_strlen$17;
                grams->num = grams->num + 1;
              }
              while((_Bool)0);
              while(grams->num >= 2)
                do
                  if(grams->num >= 1)
                  {
                    free((void *)(grams->array + (signed long int)((grams->start + grams->num) - 1))->dptr);
                    grams->num = grams->num - 1;
                  }

                while((_Bool)0);
              wbuf=cbmemdup((const char *)(grams->array + (signed long int)(grams->start + 0))->dptr, -1);
              word = wbuf;
              est_expand_word_bw(db, word, grams);
              single = 1;
              break;
            }
            case 101:
            {
              est_break_text(word, grams, 1, 0);
              cblistunshift(grams, word, -1);
              while(grams->num >= 2)
              {
                char *return_value_cblistshift$18;
                return_value_cblistshift$18=cblistshift(grams, (signed int *)(void *)0);
                free((void *)return_value_cblistshift$18);
              }
              wbuf=cbmemdup((const char *)(grams->array + (signed long int)(grams->start + 0))->dptr, -1);
              word = wbuf;
              est_expand_word_ew(db, word, grams);
              single = 1;
              break;
            }
            case 114:
            {
              est_break_text(word, grams, 1, 0);
              while(grams->num >= 1)
              {
                char *return_value_cblistshift$19;
                return_value_cblistshift$19=cblistshift(grams, (signed int *)(void *)0);
                free((void *)return_value_cblistshift$19);
              }
              est_expand_word_rx(db, word, grams);
              single = 1;
              break;
            }
            default:
            {
              switch(db->amode)
              {
                case 1024:
                {
                  est_break_text_perfng(word, grams, 1, 0);
                  break;
                }
                case 2048:
                {
                  est_break_text_chrcat(word, grams, 1);
                  break;
                }
                default:
                  est_break_text(word, grams, 1, 0);
              }
              if(!(grams->num >= 1))
              {
                est_expand_word_bw(db, word, grams);
                single = 1;
              }

            }
          }
          tsmax = 1024;
          void *return_value_malloc$20;
          return_value_malloc$20=malloc((unsigned long int)tsmax * sizeof(struct anonymous$6) /*16ul*/ );
          tscores = (struct anonymous$6 *)return_value_malloc$20;
          if(!(tscores == ((struct anonymous$6 *)NULL)))
            tscores;

          else
            cbmyfatal("out of memory");
          tsnum = 0;
          gcnum = 0;
          if(single == 0)
            tmp_if_expr$21 = ((signed int)grams->num > 2 ? (_Bool)1 : (gstep > 2 ? (_Bool)1 : (_Bool)0)) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$21 = (_Bool)0;
          wgstep = tmp_if_expr$21 ? gstep : 1;
          if(!(west == 0) && !(gstep >= 3))
            wgstep = 1;

          j = 0;
          for( ; !(j >= grams->num); j = j + wgstep)
          {
            gcnum = gcnum + 1;
            gsiz = (grams->array + (signed long int)(grams->start + j))->dsize;
            gram = (const char *)(grams->array + (signed long int)(grams->start + j))->dptr;
            fnext=cblistval(grams, j + 1, &mfsiz);
            snext=cblistval(grams, j + 2, &mssiz);
            if(!(fnext == ((const char *)NULL)))
            {
              return_value_dpinnerhash$22=dpinnerhash(fnext, mfsiz);
              tmp_if_expr$23 = return_value_dpinnerhash$22 % 251 + 1;
            }

            else
              tmp_if_expr$23 = 0xff;
            mfhash = tmp_if_expr$23;
            if(!(snext == ((const char *)NULL)))
            {
              return_value_dpouterhash$24=dpouterhash(snext, mssiz);
              tmp_if_expr$25 = return_value_dpouterhash$24 % 251 + 1;
            }

            else
              tmp_if_expr$25 = 0xff;
            mshash = tmp_if_expr$25;
            vbuf=est_idx_scan(db->idxdb, gram, gsiz, &vsiz, db->smode);
            cbuf=cbmapget(db->idxcc, gram, gsiz, &csiz);
            if(!(cbuf == ((const char *)NULL)))
            {
              void *return_value_realloc$26;
              return_value_realloc$26=realloc((void *)vbuf, (unsigned long int)(vsiz + csiz + 1));
              vbuf = (char *)return_value_realloc$26;
              if(!(vbuf == ((char *)NULL)))
                vbuf;

              else
                cbmyfatal("out of memory");
              memcpy((void *)(vbuf + (signed long int)vsiz), (const void *)cbuf, (unsigned long int)csiz);
              vsiz = vsiz + csiz;
            }

            rp = vbuf;
            while(!(rp >= vbuf + (signed long int)vsiz))
            {
              do
              {
                signed int _EST_i;
                signed int _EST_base;
                id = 0;
                _EST_base = 1;
                _EST_i = 0;
                for( ; (_Bool)1; _EST_i = _EST_i + 1)
                {
                  if((signed int)rp[(signed long int)_EST_i] >= 0)
                  {
                    id = id + (signed int)((signed char *)rp)[(signed long int)_EST_i] * _EST_base;
                    break;
                  }

                  id = id + _EST_base * ((signed int)((signed char *)rp)[(signed long int)_EST_i] + 1) * -1;
                  _EST_base = _EST_base * 128;
                }
                vstep = _EST_i + 1;
              }
              while((_Bool)0);
              rp = rp + (signed long int)vstep;
              if(!(db->smode == 1048576))
              {
                if(db->smode == 2097152 || db->smode == 4194304)
                  goto __CPROVER_DUMP_L96;

              }

              else
              {
                score = 0;
                goto __CPROVER_DUMP_L97;
              }
              score = (signed int)*((unsigned char *)rp);
              rp = rp + 1l;
              goto __CPROVER_DUMP_L97;

            __CPROVER_DUMP_L96:
              ;
              memcpy((void *)&score, (const void *)rp, sizeof(signed int) /*4ul*/ );
              rp = rp + (signed long int)sizeof(signed int) /*4ul*/ ;

            __CPROVER_DUMP_L97:
              ;
              hit = (signed int)(mfhash == 0xff && mshash == 0xff);
              while(!(rp >= vbuf + (signed long int)vsiz))
              {
                if((signed int)*((unsigned char *)rp) == 0x00)
                  break;

                tfhash = (signed int)*((unsigned char *)rp);
                rp = rp + 1l;
                tshash = (signed int)*((unsigned char *)rp);
                rp = rp + 1l;
                if((mfhash == 0xff || mfhash == tfhash) && (mshash == 0xff || mshash == tshash))
                  hit = 1;

              }
              rp = rp + 1l;
              if(!(hit == 0) || !(single == 0))
              {
                if(tsnum >= tsmax)
                {
                  tsmax = tsmax * 2;
                  void *return_value_realloc$27;
                  return_value_realloc$27=realloc((void *)tscores, (unsigned long int)tsmax * sizeof(struct anonymous$6) /*16ul*/ );
                  tscores = (struct anonymous$6 *)return_value_realloc$27;
                  if(!(tscores == ((struct anonymous$6 *)NULL)))
                    tscores;

                  else
                    cbmyfatal("out of memory");
                }

                (tscores + (signed long int)tsnum)->id = id;
                if(!(db->smode == 1048576))
                {
                  if(db->smode == 4194304)
                    goto __CPROVER_DUMP_L106;

                }

                else
                {
                  (tscores + (signed long int)tsnum)->score = (signed int)(rp - vbuf);
                  goto __CPROVER_DUMP_L107;
                }
                (tscores + (signed long int)tsnum)->score = score * 100 + 10;
                goto __CPROVER_DUMP_L107;

              __CPROVER_DUMP_L106:
                ;
                (tscores + (signed long int)tsnum)->score = score;

              __CPROVER_DUMP_L107:
                ;
                tsnum = tsnum + 1;
              }

            }
            free((void *)vbuf);
          }
          if(grams->num == 1)
          {
            if(single == 0)
            {
              if(db->amode == 0)
              {
                if(!((signed int)*((unsigned char *)word) >= 0xe0))
                {
                  do
                  {
                    void *return_value_malloc$28;
                    return_value_malloc$28=malloc(sizeof(struct anonymous$1) /*24ul*/ );
                    tgrams = (struct anonymous$1 *)return_value_malloc$28;
                    if(!(tgrams == ((struct anonymous$1 *)NULL)))
                      tgrams;

                    else
                      cbmyfatal("out of memory");
                    tgrams->anum = 64;
                    void *return_value_malloc$29;
                    return_value_malloc$29=malloc(sizeof(struct anonymous$28) /*16ul*/  * (unsigned long int)tgrams->anum);
                    tgrams->array = (struct anonymous$28 *)return_value_malloc$29;
                    if(!(tgrams->array == ((struct anonymous$28 *)NULL)))
                      tgrams->array;

                    else
                      cbmyfatal("out of memory");
                    tgrams->start = 0;
                    tgrams->num = 0;
                  }
                  while((_Bool)0);
                  est_break_text(word, tgrams, 1, 1);
                  if(tgrams->num == 2)
                  {
                    gram = (const char *)(tgrams->array + (signed long int)(tgrams->start + 1))->dptr;
                    nscores=est_search_union(db, gram, 1, (void (*)(const char *, struct anonymous$1 *))(void *)0, &nsnum, (struct anonymous$9 *)(void *)0, 1, -1, (struct anonymous$9 *)(void *)0);
                    j = 0;
                    for( ; !(j >= nsnum); j = j + 1)
                    {
                      if(tsnum >= tsmax)
                      {
                        tsmax = tsmax * 2;
                        void *return_value_realloc$30;
                        return_value_realloc$30=realloc((void *)tscores, (unsigned long int)tsmax * sizeof(struct anonymous$6) /*16ul*/ );
                        tscores = (struct anonymous$6 *)return_value_realloc$30;
                        if(!(tscores == ((struct anonymous$6 *)NULL)))
                          tscores;

                        else
                          cbmyfatal("out of memory");
                      }

                      (tscores + (signed long int)tsnum)->id = (nscores + (signed long int)j)->id;
                      (tscores + (signed long int)tsnum)->score = (nscores + (signed long int)j)->score;
                      tsnum = tsnum + 1;
                    }
                    free((void *)nscores);
                    gcnum = gcnum + 1;
                  }

                  do
                  {
                    signed int _CB_i;
                    signed int _CB_end = tgrams->start + tgrams->num;
                    _CB_i = tgrams->start;
                    for( ; !(_CB_i >= _CB_end); _CB_i = _CB_i + 1)
                      free((void *)(tgrams->array + (signed long int)_CB_i)->dptr);
                    free((void *)tgrams->array);
                    free((void *)tgrams);
                  }
                  while((_Bool)0);
                }

              }

            }

          }

          if(gcnum >= 2)
          {
            qsort((void *)tscores, (unsigned long int)tsnum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
            nnum = 0;
            j = 0;
            for( ; !(j >= tsnum); j = j + 1)
            {
              id = (tscores + (signed long int)j)->id;
              score = (tscores + (signed long int)j)->score;
              hnum = 1;
              if(db->smode == 4194304)
              {
                k = j + 1;
                do
                {
                  if(!(k >= tsnum))
                    tmp_if_expr$31 = (tscores + (signed long int)k)->id == id ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$31 = (_Bool)0;
                  if(!tmp_if_expr$31)
                    break;

                  hnum = hnum + 1;
                  k = k + 1;
                }
                while((_Bool)1);
                if(hnum >= gcnum || !(single == 0))
                {
                  (tscores + (signed long int)nnum)->id = id;
                  (tscores + (signed long int)nnum)->score = score;
                  nnum = nnum + 1;
                }

              }

              else
              {
                k = j + 1;
                do
                {
                  if(!(k >= tsnum))
                    tmp_if_expr$32 = (tscores + (signed long int)k)->id == id ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$32 = (_Bool)0;
                  if(!tmp_if_expr$32)
                    break;

                  score = score + (tscores + (signed long int)k)->score;
                  hnum = hnum + 1;
                  k = k + 1;
                }
                while((_Bool)1);
                if(hnum >= gcnum || !(single == 0))
                {
                  (tscores + (signed long int)nnum)->id = id;
                  (tscores + (signed long int)nnum)->score = score / hnum;
                  nnum = nnum + 1;
                }

              }
              j = k - 1;
            }
            tsnum = nnum;
          }

          if(!(hints == ((struct anonymous$9 *)NULL)))
          {
            sprintf(numbuf, "%d", tsnum * (add != 0 ? 1 : -1));
            cbmapput(hints, word, -1, numbuf, -1, 1);
          }

          do
          {
            signed int est_search_union$$1$$2$$1$$3$$8$$_CB_i;
            signed int est_search_union$$1$$2$$1$$3$$8$$_CB_end = grams->start + grams->num;
            est_search_union$$1$$2$$1$$3$$8$$_CB_i = grams->start;
            for( ; !(est_search_union$$1$$2$$1$$3$$8$$_CB_i >= est_search_union$$1$$2$$1$$3$$8$$_CB_end); est_search_union$$1$$2$$1$$3$$8$$_CB_i = est_search_union$$1$$2$$1$$3$$8$$_CB_i + 1)
              free((void *)(grams->array + (signed long int)est_search_union$$1$$2$$1$$3$$8$$_CB_i)->dptr);
            free((void *)grams->array);
            free((void *)grams);
          }
          while((_Bool)0);
          if(!(db->smode == 4194304))
          {
            return_value_strchr$33=strchr(word, 32);
            if(return_value_strchr$33 == ((char *)NULL))
            {
              if(auxmin >= 1)
                est_weight_keywords(db, word, tscores, tsnum);

            }

          }

          j = 0;
          for( ; !(j >= tsnum); j = j + 1)
          {
            if(snum >= smax)
            {
              smax = smax * 2;
              void *return_value_realloc$34;
              return_value_realloc$34=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous$6) /*16ul*/ );
              scores = (struct anonymous$6 *)return_value_realloc$34;
              if(!(scores == ((struct anonymous$6 *)NULL)))
                scores;

              else
                cbmyfatal("out of memory");
            }

            (scores + (signed long int)snum)->id = (tscores + (signed long int)j)->id;
            (scores + (signed long int)snum)->score = (tscores + (signed long int)j)->score;
            snum = snum + 1;
          }
          est_rescc_put(db, ckey, cksiz, tscores, tsnum);
        }
      }
      free((void *)wbuf);
    }

  }
  do
  {
    signed int est_search_union$$1$$3$$_CB_i;
    signed int est_search_union$$1$$3$$_CB_end = words->start + words->num;
    est_search_union$$1$$3$$_CB_i = words->start;
    for( ; !(est_search_union$$1$$3$$_CB_i >= est_search_union$$1$$3$$_CB_end); est_search_union$$1$$3$$_CB_i = est_search_union$$1$$3$$_CB_i + 1)
      free((void *)(words->array + (signed long int)est_search_union$$1$$3$$_CB_i)->dptr);
    free((void *)words->array);
    free((void *)words);
  }
  while((_Bool)0);
  qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
  nnum = 0;
  i = 0;
  _Bool tmp_if_expr$37;
  for( ; !(i >= snum); i = i + 1)
  {
    id = (scores + (signed long int)i)->id;
    score = (scores + (signed long int)i)->score;
    hnum = 1;
    j = i + 1;
    do
    {
      if(!(j >= snum))
        tmp_if_expr$37 = (scores + (signed long int)j)->id == id ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$37 = (_Bool)0;
      if(!tmp_if_expr$37)
        break;

      score = score + (scores + (signed long int)j)->score;
      hnum = hnum + 1;
      j = j + 1;
    }
    while((_Bool)1);
    (scores + (signed long int)nnum)->id = id;
    (scores + (signed long int)nnum)->score = score / hnum;
    (scores + (signed long int)nnum)->value = (char *)(void *)0;
    nnum = nnum + 1;
    i = j - 1;
  }
  *nump = nnum;
  if(!(db->smode == 4194304))
  {
    if(nnum >= 1)
    {
      avg = 0.0;
      i = 0;
      for( ; !(i >= nnum); i = i + 1)
        avg = avg + (double)(scores + (signed long int)i)->score;
      avg = avg / (double)nnum;
      sd = 0.0;
      i = 0;
      for( ; !(i >= nnum); i = i + 1)
      {
        dif = avg - (double)(scores + (signed long int)i)->score;
        sd = sd + dif * dif;
      }
      sd = sd / (double)nnum;
      sd=sqrt(sd);
      if(sd < 0.1)
      {
        i = 0;
        for( ; !(i >= nnum); i = i + 1)
          (scores + (signed long int)i)->score = 1000 / 2;
      }

      else
      {
        i = 0;
        for( ; !(i >= nnum); i = i + 1)
          (scores + (signed long int)i)->score = (signed int)((((double)(scores + (signed long int)i)->score - avg) * ((double)1000 / 10.0)) / sd + (double)1000 / 2.0);
      }
    }

  }

  return scores;
}

// est_search_uvset
// file estraier.c line 8250
static struct anonymous$6 * est_search_uvset(struct anonymous *db, signed int *nump, struct anonymous$9 *hints, signed int add)
{
  struct anonymous$6 *scores;
  char *vbuf;
  char numbuf[32l];
  signed int snum;
  signed int smax = 1024;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)smax * sizeof(struct anonymous$6) /*16ul*/ );
  scores = (struct anonymous$6 *)return_value_malloc$1;
  if(!(scores == ((struct anonymous$6 *)NULL)))
    scores;

  else
    cbmyfatal("out of memory");
  snum = 0;
  vlcurfirst(db->listdb);
  do
  {
    vbuf=vlcurval(db->listdb, (signed int *)(void *)0);
    if(vbuf == ((char *)NULL))
      break;

    if(snum >= smax)
    {
      smax = smax * 2;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)scores, (unsigned long int)smax * sizeof(struct anonymous$6) /*16ul*/ );
      scores = (struct anonymous$6 *)return_value_realloc$2;
      if(!(scores == ((struct anonymous$6 *)NULL)))
        scores;

      else
        cbmyfatal("out of memory");
    }

    (scores + (signed long int)snum)->id=atoi(vbuf);
    (scores + (signed long int)snum)->score = 0;
    (scores + (signed long int)snum)->value = (char *)(void *)0;
    snum = snum + 1;
    free((void *)vbuf);
    vlcurnext(db->listdb);
  }
  while((_Bool)1);
  *nump = snum;
  if(!(hints == ((struct anonymous$9 *)NULL)))
  {
    sprintf(numbuf, "%d", snum * (add != 0 ? 1 : -1));
    cbmapput(hints, "[UVSET]", -1, numbuf, -1, 1);
  }

  return scores;
}

// est_set_ecode
// file estraier.c line 5862
static void est_set_ecode(signed int *ecp, signed int value, signed int line)
{
  char buf[4096l];
  *ecp = value;
  if(dpdbgfd >= 0)
  {
    fflush(stdout);
    fflush(stderr);
    const char *return_value_est_err_msg$1;
    return_value_est_err_msg$1=est_err_msg(value);
    sprintf(buf, "* est_set_ecode: %d: [%d] %s\n", line, value, return_value_est_err_msg$1);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    write(dpdbgfd, (const void *)buf, return_value_strlen$2);
  }

}

// est_short_compare
// file estraier.c line 7718
static signed int est_short_compare(const void *ap, const void *bp)
{
  return (((signed int)((unsigned char *)ap)[(signed long int)0] << 8) + (signed int)((unsigned char *)ap)[(signed long int)1]) - (((signed int)((unsigned char *)bp)[(signed long int)0] << 8) + (signed int)((unsigned char *)bp)[(signed long int)1]);
}

// est_signal
// file estraier.c line 5665
void est_signal(signed int signum, void (*sighandler)(signed int))
{
  struct sigaction act;
  signed int i;
  static signed int first = 1;
  if(!(first == 0))
  {
    i = 1;
    for( ; !(i >= 64); i = i + 1)
      est_signal_handlers[(signed long int)i] = (void (*)(signed int))(void *)0;
    first = 0;
  }

  if(!(signum >= 64))
  {
    memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
    if(sighandler == (void (*)(signed int))1)
      act.__sigaction_handler.sa_handler = (void (*)(signed int))1;

    else
      if(sighandler == ((void (*)(signed int))NULL))
        act.__sigaction_handler.sa_handler = (void (*)(signed int))0;

      else
      {
        act.__sigaction_handler.sa_handler = (void (*)(signed int))est_signal_dispatch;
        est_signal_handlers[(signed long int)signum] = sighandler;
      }
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(signum, &act, (struct sigaction *)(void *)0);
  }

}

// est_signal_dispatch
// file estraier.c line 10431
static signed int est_signal_dispatch(signed int signum)
{
  if(!(est_signal_handlers[(signed long int)signum] == ((void (*)(signed int))NULL)))
    est_signal_handlers[(signed long int)signum](signum);

  return 1;
}

// est_snippet_add_text
// file estraier.c line 6765
static void est_snippet_add_text(const unsigned char *rtext, const unsigned char *ctext, signed int size, signed int awsiz, struct anonymous$2 *res, const struct anonymous$1 *rwords)
{
  const unsigned char *rword;
  char *orig;
  signed int i;
  signed int j;
  signed int bi;
  signed int rwsiz;
  signed int step;
  signed int osiz;
  bi = 0;
  i = 0;
  for( ; !(i >= size); i = i + 2)
  {
    j = 0;
    for( ; !(j >= rwords->num); j = j + 1)
    {
      rwsiz = (rwords->array + (signed long int)(rwords->start + j))->dsize;
      rword = (unsigned char *)(const char *)(rwords->array + (signed long int)(rwords->start + j))->dptr;
      step=est_str_fwmatch_wide(ctext + (signed long int)i, (size + awsiz) - i, rword, rwsiz);
      if(step >= 1)
      {
        if(i + -bi >= 1)
        {
          orig=est_uconv_out((char *)rtext + (signed long int)bi, i - bi, &osiz);
          do
          {
            if(res->dsize + osiz >= res->asize)
            {
              res->asize = res->asize * 2 + osiz + 1;
              void *return_value_realloc$1;
              return_value_realloc$1=realloc((void *)res->dptr, (unsigned long int)res->asize);
              res->dptr = (char *)return_value_realloc$1;
              if(!(res->dptr == ((char *)NULL)))
                res->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
            res->dsize = res->dsize + osiz;
            res->dptr[(signed long int)res->dsize] = (char)0;
          }
          while((_Bool)0);
          do
          {
            if(1 + res->dsize >= res->asize)
            {
              res->asize = res->asize * 2 + 1 + 1;
              void *return_value_realloc$2;
              return_value_realloc$2=realloc((void *)res->dptr, (unsigned long int)res->asize);
              res->dptr = (char *)return_value_realloc$2;
              if(!(res->dptr == ((char *)NULL)))
                res->dptr;

              else
                cbmyfatal("out of memory");
            }

            memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
            res->dsize = res->dsize + 1;
            res->dptr[(signed long int)res->dsize] = (char)0;
          }
          while((_Bool)0);
          free((void *)orig);
        }

        orig=est_uconv_out((char *)rtext + (signed long int)i, step, &osiz);
        do
        {
          if(res->dsize + osiz >= res->asize)
          {
            res->asize = res->asize * 2 + osiz + 1;
            void *return_value_realloc$3;
            return_value_realloc$3=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc$3;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
          res->dsize = res->dsize + osiz;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        free((void *)orig);
        do
        {
          if(1 + res->dsize >= res->asize)
          {
            res->asize = res->asize * 2 + 1 + 1;
            void *return_value_realloc$4;
            return_value_realloc$4=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc$4;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\t", (unsigned long int)1);
          res->dsize = res->dsize + 1;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        orig=est_uconv_out((char *)rword, rwsiz, &osiz);
        do
        {
          if(res->dsize + osiz >= res->asize)
          {
            res->asize = res->asize * 2 + osiz + 1;
            void *return_value_realloc$5;
            return_value_realloc$5=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc$5;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
          res->dsize = res->dsize + osiz;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        free((void *)orig);
        do
        {
          if(1 + res->dsize >= res->asize)
          {
            res->asize = res->asize * 2 + 1 + 1;
            void *return_value_realloc$6;
            return_value_realloc$6=realloc((void *)res->dptr, (unsigned long int)res->asize);
            res->dptr = (char *)return_value_realloc$6;
            if(!(res->dptr == ((char *)NULL)))
              res->dptr;

            else
              cbmyfatal("out of memory");
          }

          memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
          res->dsize = res->dsize + 1;
          res->dptr[(signed long int)res->dsize] = (char)0;
        }
        while((_Bool)0);
        bi = i + step;
        i = bi - 2;
        break;
      }

    }
  }
  if(i + -bi >= 1)
  {
    orig=est_uconv_out((char *)rtext + (signed long int)bi, i - bi, &osiz);
    do
    {
      if(res->dsize + osiz >= res->asize)
      {
        res->asize = res->asize * 2 + osiz + 1;
        void *return_value_realloc$7;
        return_value_realloc$7=realloc((void *)res->dptr, (unsigned long int)res->asize);
        res->dptr = (char *)return_value_realloc$7;
        if(!(res->dptr == ((char *)NULL)))
          res->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)orig, (unsigned long int)osiz);
      res->dsize = res->dsize + osiz;
      res->dptr[(signed long int)res->dsize] = (char)0;
    }
    while((_Bool)0);
    do
    {
      if(1 + res->dsize >= res->asize)
      {
        res->asize = res->asize * 2 + 1 + 1;
        void *return_value_realloc$8;
        return_value_realloc$8=realloc((void *)res->dptr, (unsigned long int)res->asize);
        res->dptr = (char *)return_value_realloc$8;
        if(!(res->dptr == ((char *)NULL)))
          res->dptr;

        else
          cbmyfatal("out of memory");
      }

      memcpy((void *)(res->dptr + (signed long int)res->dsize), (const void *)"\n", (unsigned long int)1);
      res->dsize = res->dsize + 1;
      res->dptr[(signed long int)res->dsize] = (char)0;
    }
    while((_Bool)0);
    free((void *)orig);
  }

}

// est_sock_close
// file estnode.c line 1767
static signed int est_sock_close(signed int sock)
{
  signed int return_value_close$1;
  return_value_close$1=close(sock);
  return return_value_close$1;
}

// est_sock_down
// file estnode.c line 1457
void est_sock_down(signed int sock)
{
  shutdown(sock, 2);
  est_sock_close(sock);
}

// est_sock_recv_all
// file estnode.c line 1465
char * est_sock_recv_all(signed int sock, signed int len)
{
  char *buf;
  signed int i;
  signed int bs;
  void *return_value_cbmalloc$1;
  return_value_cbmalloc$1=cbmalloc((unsigned long int)(len + 1));
  buf = (char *)return_value_cbmalloc$1;
  i = 0;
  _Bool tmp_if_expr$3;
  signed long int return_value_recv$2;
  signed int *return_value___errno_location$4;
  do
  {
    if(!(i >= len))
    {
      return_value_recv$2=recv(sock, (void *)(buf + (signed long int)i), (unsigned long int)(len - i), 0);
      bs = (signed int)return_value_recv$2;
      tmp_if_expr$3 = bs != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    if(bs == -1)
    {
      return_value___errno_location$4=__errno_location();
      if(!(*return_value___errno_location$4 == 4))
      {
        free((void *)buf);
        return (char *)(void *)0;
      }

    }

    i = i + bs;
  }
  while((_Bool)1);
  buf[(signed long int)i] = (char)0;
  return buf;
}

// est_sock_recv_line
// file estnode.c line 1482
signed int est_sock_recv_line(signed int sock, char *buf, signed int max)
{
  char *wp;
  max = max - 1;
  wp = buf;
  signed int *return_value___errno_location$2;
  while(!(wp >= buf + (signed long int)max))
  {
    signed long int return_value_recv$1;
    return_value_recv$1=recv(sock, (void *)wp, (unsigned long int)1, 0);
    if(!(return_value_recv$1 == -1l))
    {
      if(return_value_recv$1 == 0l)
        goto __CPROVER_DUMP_L4;

    }

    else
    {
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 4))
      {
        *wp = (char)0;
        return (signed int)(wp - buf);
      }

      goto __CPROVER_DUMP_L10;

    __CPROVER_DUMP_L4:
      ;
      *wp = (char)0;
      return (signed int)(wp - buf);
    }
    switch((signed int)*wp)
    {
      case 13:
        break;
      case 10:
      {
        *wp = (char)0;
        return (signed int)(wp - buf);
      }
      default:
        wp = wp + 1l;
    }

  __CPROVER_DUMP_L10:
    ;
  }
  *wp = (char)0;
  return (signed int)(wp - buf);
}

// est_sock_recv_void
// file estnode.c line 1518
void est_sock_recv_void(signed int sock)
{
  struct anonymous$18 rfds;
  struct timeval tv;
  char ibuf[8192l];
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$18) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&rfds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  tv.tv_sec = (signed long int)0;
  tv.tv_usec = (signed long int)0;
  signed int return_value_select$1;
  return_value_select$1=select(sock + 1, &rfds, (struct anonymous$18 *)(void *)0, (struct anonymous$18 *)(void *)0, &tv);
  if(return_value_select$1 >= 1)
  {
    if(!((rfds.fds_bits[(signed long int)(sock / 8)] & (signed long int)(1UL << sock % 8)) == 0l))
      recv(sock, (void *)ibuf, (unsigned long int)8192, 0);

  }

}

// est_sock_send_all
// file estnode.c line 1533
void est_sock_send_all(signed int sock, const char *buf, signed int len)
{
  const char *rp;
  signed int rv;
  signed int wb;
  rp = buf;
  rv = 0;
  signed int *return_value___errno_location$2;
  do
  {
    signed long int return_value_send$1;
    return_value_send$1=send(sock, (const void *)rp, (unsigned long int)len, 0);
    wb = (signed int)return_value_send$1;
    if(!(wb == -1))
    {
      if(wb == 0)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 4))
        goto __CPROVER_DUMP_L6;


    __CPROVER_DUMP_L3:
      ;
      goto __CPROVER_DUMP_L5;
    }
    rp = rp + (signed long int)wb;
    len = len - wb;
    rv = rv + wb;

  __CPROVER_DUMP_L5:
    ;
  }
  while(len >= 1);

__CPROVER_DUMP_L6:
  ;
}

// est_sockpt_down
// file estnode.c line 1942
static void est_sockpt_down(void *sp)
{
  est_sock_down(*((signed int *)sp));
  free(sp);
}

// est_str_fwmatch_wide
// file estraier.c line 6812
static signed int est_str_fwmatch_wide(const unsigned char *str, signed int size, const unsigned char *key, signed int ksiz)
{
  signed int si;
  signed int ki;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(ksiz >= 2) || !(size >= 2))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if((signed int)*str == 0x0)
      tmp_if_expr$1 = (signed int)str[(signed long int)1] <= 0x20 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    si = 0;
    ki = 0;
    while(!(ki >= ksiz))
    {
      if(si >= size)
        return 0;

      if((signed int)str[(signed long int)si] == 0x0)
      {
        if((signed int)str[(signed long int)(1 + si)] >= 33)
          goto __CPROVER_DUMP_L8;

        si = si + 2;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if((signed int)key[(signed long int)ki] == 0x0)
        {
          if((signed int)key[(signed long int)(1 + ki)] >= 33)
            goto __CPROVER_DUMP_L9;

          ki = ki + 2;
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          if(!(str[(signed long int)si] == key[(signed long int)ki]))
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = str[(signed long int)(si + 1)] != key[(signed long int)(ki + 1)] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
            return 0;

          si = si + 2;
          ki = ki + 2;
        }
      }
    }
    return si;
  }
}

// est_str_make_snippet
// file estraier.c line 3498
char * est_str_make_snippet(const char *str, const struct anonymous$1 *words, signed int wwidth, signed int hwidth, signed int awidth)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  char *return_value_est_make_snippet$2;
  return_value_est_make_snippet$2=est_make_snippet(str, (signed int)return_value_strlen$1, words, wwidth, hwidth, awidth);
  return return_value_est_make_snippet$2;
}

// est_strstr_sparse
// file estraier.c line 6841
static char * est_strstr_sparse(const char *haystack, const char *needle)
{
  const char *hp;
  const char *np;
  for( ; (signed int)*needle >= 1; needle = needle + 1l)
    if((signed int)*needle >= 33)
      break;

  _Bool tmp_if_expr$1;
  if((signed int)*needle == 0)
    return (char *)haystack;

  else
  {
    do
    {
      haystack=strchr(haystack, (signed int)*needle);
      if(haystack == ((const char *)NULL))
        break;

      hp = haystack;
      np = needle;
      for( ; (_Bool)1; np = np + 1l)
      {
        for( ; (signed int)*hp >= 1; hp = hp + 1l)
          if((signed int)*hp >= 33)
            break;

        for( ; (signed int)*np >= 1; np = np + 1l)
          if((signed int)*np >= 33)
            break;

        if((signed int)*np == 0)
          return (char *)haystack;

        if(!(*hp == *np))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)*hp == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          break;

        hp = hp + 1l;
      }
      haystack = haystack + 1l;
    }
    while((_Bool)1);
    return (char *)(void *)0;
  }
}

// est_uconv_in
// file estraier.c line 3672
char * est_uconv_in(const char *ptr, signed int size, signed int *sp)
{
  const unsigned char *rp;
  char *rbuf;
  char *wp;
  rp = (unsigned char *)ptr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(size * 2 + 1));
  rbuf = (char *)return_value_malloc$1;
  if(!(rbuf == ((char *)NULL)))
    rbuf;

  else
    cbmyfatal("out of memory");
  wp = rbuf;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  char *tmp_post$9;
  char *tmp_post$10;
  char *tmp_post$11;
  char *tmp_post$12;
  char *tmp_post$13;
  while(!(rp >= (unsigned char *)ptr + (signed long int)size))
    if(!((signed int)*rp >= 0x7f))
    {
      tmp_post$2 = wp;
      wp = wp + 1l;
      *tmp_post$2 = (char)0x00;
      tmp_post$3 = wp;
      wp = wp + 1l;
      *tmp_post$3 = (char)*rp;
      rp = rp + (signed long int)1;
    }

    else
      if(!((signed int)*rp >= 0xdf))
      {
        if(rp >= (unsigned char *)ptr + (signed long int)size + -1l)
          break;

        tmp_post$4 = wp;
        wp = wp + 1l;
        *tmp_post$4 = (char)(((signed int)rp[(signed long int)0] & 0x1f) >> 2);
        tmp_post$5 = wp;
        wp = wp + 1l;
        *tmp_post$5 = (char)((signed int)rp[(signed long int)0] << 6 | (signed int)rp[(signed long int)1] & 0x3f);
        rp = rp + (signed long int)2;
      }

      else
        if(!((signed int)*rp >= 0xf0))
        {
          if(rp >= (unsigned char *)ptr + (signed long int)size + -2l)
            break;

          tmp_post$6 = wp;
          wp = wp + 1l;
          *tmp_post$6 = (char)((signed int)rp[(signed long int)0] << 4 | ((signed int)rp[(signed long int)1] & 0x3f) >> 2);
          tmp_post$7 = wp;
          wp = wp + 1l;
          *tmp_post$7 = (char)((signed int)rp[(signed long int)1] << 6 | (signed int)rp[(signed long int)2] & 0x3f);
          rp = rp + (signed long int)3;
        }

        else
          if(!((signed int)*rp >= 0xf8))
          {
            if(rp >= (unsigned char *)ptr + (signed long int)size + -3l)
              break;

            tmp_post$8 = wp;
            wp = wp + 1l;
            *tmp_post$8 = (char)0x00;
            tmp_post$9 = wp;
            wp = wp + 1l;
            *tmp_post$9 = (char)63;
            rp = rp + (signed long int)4;
          }

          else
            if(!((signed int)*rp >= 0xfb))
            {
              if(rp >= (unsigned char *)ptr + (signed long int)size + -4l)
                break;

              tmp_post$10 = wp;
              wp = wp + 1l;
              *tmp_post$10 = (char)0x00;
              tmp_post$11 = wp;
              wp = wp + 1l;
              *tmp_post$11 = (char)63;
              rp = rp + (signed long int)5;
            }

            else
              if(!((signed int)*rp >= 0xfd))
              {
                if(rp >= (unsigned char *)ptr + (signed long int)size + -5l)
                  break;

                tmp_post$12 = wp;
                wp = wp + 1l;
                *tmp_post$12 = (char)0x00;
                tmp_post$13 = wp;
                wp = wp + 1l;
                *tmp_post$13 = (char)63;
                rp = rp + (signed long int)6;
              }

              else
                break;
  *wp = (char)0;
  *sp = (signed int)(wp - rbuf);
  return rbuf;
}

// est_uconv_out
// file estraier.c line 3720
char * est_uconv_out(const char *ptr, signed int size, signed int *sp)
{
  const unsigned char *rp;
  char *rbuf;
  char *wp;
  signed int c;
  if(!(size % 2 == 0))
    size = size - 1;

  rp = (unsigned char *)ptr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(size * 2 + 1));
  rbuf = (char *)return_value_malloc$1;
  if(!(rbuf == ((char *)NULL)))
    rbuf;

  else
    cbmyfatal("out of memory");
  wp = rbuf;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  for( ; !(rp >= (unsigned char *)ptr + (signed long int)size); rp = rp + (signed long int)2)
  {
    c = (signed int)rp[(signed long int)0] * 0x100 + (signed int)rp[(signed long int)1];
    if(!(c >= 0x0080))
    {
      tmp_post$2 = wp;
      wp = wp + 1l;
      *tmp_post$2 = (char)rp[(signed long int)1];
    }

    else
      if(!(c >= 0x0900))
      {
        tmp_post$3 = wp;
        wp = wp + 1l;
        *tmp_post$3 = (char)(0xc0 | (signed int)rp[(signed long int)0] << 2 | (signed int)rp[(signed long int)1] >> 6 & 0x03);
        tmp_post$4 = wp;
        wp = wp + 1l;
        *tmp_post$4 = (char)(0x80 | (signed int)rp[(signed long int)1] & 0x3f);
      }

      else
      {
        tmp_post$5 = wp;
        wp = wp + 1l;
        *tmp_post$5 = (char)(0xe0 | (signed int)rp[(signed long int)0] >> 4 & 0x0f);
        tmp_post$6 = wp;
        wp = wp + 1l;
        *tmp_post$6 = (char)(0x80 | ((signed int)rp[(signed long int)0] & 0x0f) << 2 | (signed int)rp[(signed long int)1] >> 6 & 0x03);
        tmp_post$7 = wp;
        wp = wp + 1l;
        *tmp_post$7 = (char)(0x80 | (signed int)rp[(signed long int)1] & 0x3f);
      }
  }
  *wp = (char)0;
  if(!(sp == ((signed int *)NULL)))
    *sp = (signed int)(wp - rbuf);

  return rbuf;
}

// est_url_sameness
// file estraier.c line 10382
static signed int est_url_sameness(const char *aurl, const char *burl)
{
  const char *apv;
  const char *bpv;
  signed int i;
  signed int alen;
  signed int blen;
  apv=strstr(aurl, "://");
  if(!(apv == ((const char *)NULL)))
    aurl = apv + (signed long int)3;

  else
    return 0;
  bpv=strstr(burl, "://");
  if(!(bpv == ((const char *)NULL)))
    burl = bpv + (signed long int)3;

  else
    return 0;
  apv=strchr(aurl, 47);
  unsigned long int return_value_strlen$1;
  if(apv == ((const char *)NULL))
  {
    return_value_strlen$1=strlen(aurl);
    apv = aurl + (signed long int)return_value_strlen$1;
  }

  bpv=strchr(burl, 47);
  unsigned long int return_value_strlen$2;
  if(bpv == ((const char *)NULL))
  {
    return_value_strlen$2=strlen(burl);
    bpv = burl + (signed long int)return_value_strlen$2;
  }

  alen = (signed int)(apv - aurl);
  blen = (signed int)(bpv - burl);
  _Bool tmp_if_expr$4;
  signed int return_value_memcmp$3;
  if(!(alen == blen))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_memcmp$3=memcmp((const void *)aurl, (const void *)burl, (unsigned long int)alen);
    tmp_if_expr$4 = return_value_memcmp$3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int return_value_strlen$5;
  unsigned long int return_value_strlen$6;
  signed int return_value_memcmp$7;
  signed int return_value_memcmp$8;
  if(tmp_if_expr$4)
    return 0;

  else
  {
    aurl = (signed int)*apv == 0 ? "/" : apv;
    burl = (signed int)*bpv == 0 ? "/" : bpv;
    apv=strchr(aurl, 63);
    if(apv == ((const char *)NULL))
    {
      return_value_strlen$5=strlen(aurl);
      apv = aurl + (signed long int)return_value_strlen$5;
    }

    bpv=strchr(burl, 63);
    if(bpv == ((const char *)NULL))
    {
      return_value_strlen$6=strlen(burl);
      bpv = burl + (signed long int)return_value_strlen$6;
    }

    alen = (signed int)(apv - aurl);
    blen = (signed int)(bpv - burl);
    if(alen == blen)
    {
      return_value_memcmp$7=memcmp((const void *)aurl, (const void *)burl, (unsigned long int)alen);
      if(!(return_value_memcmp$7 == 0))
        goto __CPROVER_DUMP_L12;

      return 3;
    }

    else
    {

    __CPROVER_DUMP_L12:
      ;
      apv = aurl;
      i = 0;
      for( ; !(i >= alen); i = i + 1)
        if((signed int)aurl[(signed long int)i] == 47)
          apv = aurl + (signed long int)i;

      bpv = burl;
      i = 0;
      for( ; !(i >= blen); i = i + 1)
        if((signed int)burl[(signed long int)i] == 47)
          bpv = burl + (signed long int)i;

      alen = (signed int)(apv - aurl);
      blen = (signed int)(bpv - burl);
      if(alen == blen)
      {
        return_value_memcmp$8=memcmp((const void *)aurl, (const void *)burl, (unsigned long int)alen);
        if(!(return_value_memcmp$8 == 0))
          goto __CPROVER_DUMP_L19;

        return 2;
      }

      else
      {

      __CPROVER_DUMP_L19:
        ;
        return 1;
      }
    }
  }
}

// est_url_shuttle
// file estnode.c line 1555
signed int est_url_shuttle(const char *url, const char *pxhost, signed int pxport, signed int outsec, signed int limsize, const char *auth, const struct anonymous$1 *reqheads, const char *reqbody, signed int rbsiz, signed int *rescodep, struct anonymous$9 *resheads, struct anonymous$2 *resbody)
{
  unsigned long int th;
  union anonymous$13 mutex;
  union anonymous$20 cond;
  struct timespec timeout;
  struct anonymous$27 targ;
  signed int err;
  signed int rv;
  void *rvp;
  pthread_mutex_init(&mutex, (const union anonymous$12 *)(void *)0);
  pthread_cond_init(&cond, (const union anonymous$12 *)(void *)0);
  targ.alive = 1;
  targ.cond = &cond;
  targ.url = url;
  targ.pxhost = pxhost;
  targ.pxport = pxport;
  targ.limsize = limsize;
  targ.auth = auth;
  targ.reqheads = reqheads;
  targ.reqbody = reqbody;
  targ.rbsiz = rbsiz;
  targ.rescodep = rescodep;
  targ.resheads = resheads;
  targ.resbody = resbody;
  err = 0;
  signed int return_value_pthread_join$2;
  if(outsec >= 0)
  {
    signed int return_value_pthread_mutex_lock$4;
    return_value_pthread_mutex_lock$4=pthread_mutex_lock(&mutex);
    if(return_value_pthread_mutex_lock$4 == 0)
    {
      signed int return_value_pthread_create$3;
      return_value_pthread_create$3=pthread_create(&th, (const union pthread_attr_t *)(void *)0, est_url_shuttle_impl, (void *)&targ);
      if(return_value_pthread_create$3 == 0)
      {
        signed long int return_value_time$1;
        return_value_time$1=time((signed long int *)(void *)0);
        timeout.tv_sec = return_value_time$1 + (signed long int)outsec;
        timeout.tv_nsec = (signed long int)(1000 * 1000 * 500);
        rv = 0;
        while(!(targ.alive == 0) && !(rv == 110))
          rv=pthread_cond_timedwait(&cond, &mutex, &timeout);
        if(rv == 110)
        {
          pthread_cancel(th);
          pthread_join(th, (void **)(void *)0);
          err = 1;
        }

        else
        {
          return_value_pthread_join$2=pthread_join(th, &rvp);
          if(!(rvp == NULL) || !(return_value_pthread_join$2 == 0))
            err = 1;

        }
      }

      else
        err = 1;
      pthread_mutex_unlock(&mutex);
    }

    else
      err = 1;
  }

  else
  {
    void *return_value_est_url_shuttle_impl$5;
    return_value_est_url_shuttle_impl$5=est_url_shuttle_impl((void *)&targ);
    if(!(return_value_est_url_shuttle_impl$5 == NULL))
      err = 1;

  }
  signed int return_value_pthread_mutex_destroy$6;
  return_value_pthread_mutex_destroy$6=pthread_mutex_destroy(&mutex);
  if(!(return_value_pthread_mutex_destroy$6 == 0))
    err = 1;

  signed int return_value_pthread_cond_destroy$7;
  return_value_pthread_cond_destroy$7=pthread_cond_destroy(&cond);
  if(!(return_value_pthread_cond_destroy$7 == 0))
    err = 1;

  return err != 0 ? 0 : 1;
}

// est_url_shuttle_impl
// file estnode.c line 1805
static void * est_url_shuttle_impl(void *targ)
{
  const struct anonymous$1 *reqheads;
  struct anonymous$9 *resheads;
  struct anonymous$9 *elems;
  struct anonymous$2 *resbody;
  struct anonymous$2 *datum;
  const char *url;
  const char *pxhost;
  const char *auth;
  const char *reqbody;
  const char *tmp;
  const char *scheme;
  const char *host;
  const char *path;
  const char *query;
  const char *rp;
  char *addr;
  char *enc;
  char iobuf[8192l];
  char name[8192l];
  char *pv;
  char *zbuf;
  signed int i;
  signed int pxport;
  signed int limsize;
  signed int rbsiz;
  signed int *rescodep;
  signed int port;
  signed int sock;
  signed int *sp;
  signed int size;
  signed int nsiz;
  signed int defl;
  signed int zsiz;
  url = ((struct anonymous$27 *)targ)->url;
  pxhost = ((struct anonymous$27 *)targ)->pxhost;
  pxport = ((struct anonymous$27 *)targ)->pxport;
  limsize = ((struct anonymous$27 *)targ)->limsize;
  auth = ((struct anonymous$27 *)targ)->auth;
  reqheads = ((struct anonymous$27 *)targ)->reqheads;
  reqbody = ((struct anonymous$27 *)targ)->reqbody;
  rbsiz = ((struct anonymous$27 *)targ)->rbsiz;
  rescodep = ((struct anonymous$27 *)targ)->rescodep;
  resheads = ((struct anonymous$27 *)targ)->resheads;
  resbody = ((struct anonymous$27 *)targ)->resbody;
  elems=cburlbreak(url);
  signed int tmp_if_expr$2;
  signed int return_value_atoi$1;
  _Bool tmp_if_expr$4;
  signed int return_value_cbstricmp$3;
  _Bool tmp_if_expr$5;
  signed int return_value_cblistnum$7;
  _Bool tmp_if_expr$11;
  signed int return_value_cbstrfwmatch$10;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$13;
  char *return_value_strstr$16;
  signed long int return_value_recv$18;
  signed int return_value_cbdatumsize$19;
  const char *return_value_cbdatumptr$20;
  signed int return_value_cbdatumsize$21;
  do
  {
    struct anonymous$22 __cancel_buf;
    void (*__cancel_routine)(void *) = (void (*)(void *))cbmapclose;
    void *__cancel_arg = (void *)elems;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      scheme=cbmapget(elems, "scheme", -1, (signed int *)(void *)0);
      host=cbmapget(elems, "host", -1, (signed int *)(void *)0);
      tmp=cbmapget(elems, "port", -1, (signed int *)(void *)0);
      if(!(tmp == ((const char *)NULL)))
      {
        return_value_atoi$1=atoi(tmp);
        tmp_if_expr$2 = return_value_atoi$1;
      }

      else
        tmp_if_expr$2 = 80;
      port = tmp_if_expr$2;
      if(auth == ((const char *)NULL))
        auth=cbmapget(elems, "authority", -1, (signed int *)(void *)0);

      path=cbmapget(elems, "path", -1, (signed int *)(void *)0);
      if(path == ((const char *)NULL))
        path = "/";

      query=cbmapget(elems, "query", -1, (signed int *)(void *)0);
      if(query == ((const char *)NULL))
        query = "";

      if(scheme == ((const char *)NULL))
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_cbstricmp$3=cbstricmp(scheme, "http");
        tmp_if_expr$4 = return_value_cbstricmp$3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(host == ((const char *)NULL) || !(port >= 1) || tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        addr=est_get_host_addr(pxhost != ((const char *)NULL) ? pxhost : host);
        tmp_if_expr$5 = !(addr != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
      {
        ((struct anonymous$27 *)targ)->alive = 0;
        pthread_cond_signal(((struct anonymous$27 *)targ)->cond);
        cbmapclose(elems);
        return (void *)"error";
      }

      do
      {
        struct anonymous$22 est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_buf;
        void (*est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_routine)(void *) = (void (*)(void *))free;
        void *est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_arg = (void *)addr;
        signed int est_url_shuttle_impl$$1$$1$$2$$2$$__not_first_call;
        est_url_shuttle_impl$$1$$1$$2$$2$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)est_url_shuttle_impl$$1$$1$$2$$2$$__not_first_call == 0l))
        {
          est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_routine(est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_arg);
          __pthread_unwind_next(&est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_buf);
        }

        __pthread_register_cancel(&est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_buf);
        do
        {
          sock=est_get_client_sock(addr, pxhost != ((const char *)NULL) ? pxport : port);
          if(sock == -1)
          {
            ((struct anonymous$27 *)targ)->alive = 0;
            pthread_cond_signal(((struct anonymous$27 *)targ)->cond);
            free((void *)addr);
            cbmapclose(elems);
            return (void *)"error";
          }

          void *return_value_cbmalloc$6;
          return_value_cbmalloc$6=cbmalloc(sizeof(signed int) /*4ul*/ );
          sp = (signed int *)return_value_cbmalloc$6;
          *sp = sock;
          do
          {
            struct anonymous$22 est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_buf;
            void (*est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_routine)(void *) = (void (*)(void *))est_sockpt_down;
            void *est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_arg = (void *)sp;
            signed int est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__not_first_call;
            est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_buf.__cancel_jmp_buf, 0);
            if(!((signed long int)est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__not_first_call == 0l))
            {
              est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_routine(est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_arg);
              __pthread_unwind_next(&est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_buf);
            }

            __pthread_register_cancel(&est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_buf);
            do
            {
              datum=cbdatumopen((const char *)(void *)0, -1);
              do
              {
                struct anonymous$22 est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_buf;
                void (*est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_routine)(void *) = (void (*)(void *))cbdatumclose;
                void *est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_arg = (void *)datum;
                signed int est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__not_first_call;
                est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_buf.__cancel_jmp_buf, 0);
                if(!((signed long int)est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__not_first_call == 0l))
                {
                  est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_routine(est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_arg);
                  __pthread_unwind_next(&est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_buf);
                }

                __pthread_register_cancel(&est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_buf);
                do
                {
                  if(!(pxhost == ((const char *)NULL)))
                    cbdatumprintf(datum, "%s %s HTTP/1.0\r\n", reqbody != ((const char *)NULL) ? "POST" : "GET", url);

                  else
                    if(!(reqbody == ((const char *)NULL)))
                      cbdatumprintf(datum, "POST %s HTTP/1.0\r\n", path);

                    else
                      if(!((signed int)*query == 0))
                        cbdatumprintf(datum, "GET %s?%s HTTP/1.0\r\n", path, query);

                      else
                        cbdatumprintf(datum, "GET %s HTTP/1.0\r\n", path);
                  cbdatumprintf(datum, "Host: %s:%d\r\n", host, port);
                  cbdatumprintf(datum, "Connection: close\r\n", path);
                  cbdatumprintf(datum, "User-Agent: %s/%s\r\n", (const void *)"HyperEstraier", est_version);
                  if(!(auth == ((const char *)NULL)))
                  {
                    enc=cbbaseencode(auth, -1);
                    cbdatumprintf(datum, "Authorization: Basic %s\r\n", enc);
                    free((void *)enc);
                  }

                  cbdatumprintf(datum, "Accept-Encoding: deflate\r\n");
                  if(!(reqbody == ((const char *)NULL)))
                    cbdatumprintf(datum, "Content-Length: %d\r\n", rbsiz);

                  if(!(reqheads == ((const struct anonymous$1 *)NULL)))
                  {
                    i = 0;
                    do
                    {
                      return_value_cblistnum$7=cblistnum(reqheads);
                      if(i >= return_value_cblistnum$7)
                        break;

                      rp=cblistval(reqheads, i, &size);
                      cbdatumprintf(datum, rp, size);
                      cbdatumprintf(datum, "\r\n", 2);
                      i = i + 1;
                    }
                    while((_Bool)1);
                  }

                  cbdatumprintf(datum, "\r\n");
                  const char *return_value_cbdatumptr$8;
                  return_value_cbdatumptr$8=cbdatumptr(datum);
                  signed int return_value_cbdatumsize$9;
                  return_value_cbdatumsize$9=cbdatumsize(datum);
                  est_sock_send_all(sock, return_value_cbdatumptr$8, return_value_cbdatumsize$9);
                  if(!(reqbody == ((const char *)NULL)))
                    est_sock_send_all(sock, reqbody, rbsiz);

                  size=est_sock_recv_line(sock, iobuf, 8192 - 1);
                  if(!(size >= 1))
                    tmp_if_expr$11 = (_Bool)1;

                  else
                  {
                    return_value_cbstrfwmatch$10=cbstrfwmatch(iobuf, "HTTP/");
                    tmp_if_expr$11 = !(return_value_cbstrfwmatch$10 != 0) ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$11)
                    tmp_if_expr$12 = (_Bool)1;

                  else
                  {
                    rp=strchr(iobuf, 32);
                    tmp_if_expr$12 = !(rp != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$12)
                  {
                    ((struct anonymous$27 *)targ)->alive = 0;
                    pthread_cond_signal(((struct anonymous$27 *)targ)->cond);
                    cbdatumclose(datum);
                    est_sockpt_down((void *)sp);
                    free((void *)addr);
                    cbmapclose(elems);
                    return (void *)"error";
                  }

                  rp = rp + 1l;
                  if(!(rescodep == ((signed int *)NULL)))
                    *rescodep=atoi(rp);

                  if(!(resheads == ((struct anonymous$9 *)NULL)))
                    cbmapput(resheads, "", 0, iobuf, size, 1);

                  name[(signed long int)0] = (char)0;
                  nsiz = 0;
                  defl = 0;
                  do
                  {
                    size=est_sock_recv_line(sock, iobuf, 8192 - 1);
                    if(!(size >= 1))
                      break;

                    if(!(resheads == ((struct anonymous$9 *)NULL)))
                    {
                      if((signed int)iobuf[0l] == 32)
                        tmp_if_expr$15 = (_Bool)1;

                      else
                        tmp_if_expr$15 = (signed int)iobuf[(signed long int)0] == 9 ? (_Bool)1 : (_Bool)0;
                      if(tmp_if_expr$15)
                      {
                        if(!((signed int)name[0l] == 0))
                        {
                          iobuf[(signed long int)0] = (char)32;
                          cbmapputcat(resheads, name, nsiz, iobuf, size);
                        }

                      }

                      else
                      {
                        rp=strchr(iobuf, 58);
                        if(!(iobuf >= rp))
                        {
                          nsiz = (signed int)(rp - iobuf);
                          memcpy((void *)name, (const void *)iobuf, (unsigned long int)nsiz);
                          name[(signed long int)nsiz] = (char)0;
                          pv = name;
                          for( ; !((signed int)*pv == 0); pv = pv + 1l)
                            if((signed int)*pv >= 65)
                            {
                              if(!((signed int)*pv >= 91))
                                *pv = (char)((signed int)*pv + (97 - 65));

                            }

                          rp = rp + 1l;
                          if((signed int)*rp == 32)
                            tmp_if_expr$13 = (_Bool)1;

                          else
                            tmp_if_expr$13 = (signed int)*rp == 9 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$13)
                            rp = rp + 1l;

                          const char *return_value_cbmapget$14;
                          return_value_cbmapget$14=cbmapget(resheads, name, nsiz, (signed int *)(void *)0);
                          if(!(return_value_cbmapget$14 == ((const char *)NULL)))
                          {
                            cbmapputcat(resheads, name, nsiz, ", ", 2);
                            cbmapputcat(resheads, name, nsiz, pv, -1);
                          }

                          else
                            cbmapput(resheads, name, nsiz, rp, -1, 1);
                        }

                      }
                    }

                    signed int return_value_cbstrfwimatch$17;
                    return_value_cbstrfwimatch$17=cbstrfwimatch(iobuf, "content-encoding:");
                    if(!(return_value_cbstrfwimatch$17 == 0))
                    {
                      return_value_strstr$16=strstr(iobuf + (signed long int)17, "deflate");
                      if(!(return_value_strstr$16 == ((char *)NULL)))
                        defl = 1;

                    }

                  }
                  while((_Bool)1);
                  if(!(limsize >= 0))
                    limsize = 0x7fffffff;

                  do
                  {
                    return_value_recv$18=recv(sock, (void *)iobuf, (unsigned long int)8192, 0);
                    size = (signed int)return_value_recv$18;
                    if(!(size >= 1))
                      break;

                    if(!(resbody == ((struct anonymous$2 *)NULL)))
                    {
                      return_value_cbdatumsize$19=cbdatumsize(resbody);
                      if(limsize >= return_value_cbdatumsize$19)
                        cbdatumcat(resbody, iobuf, size);

                    }

                  }
                  while((_Bool)1);
                  if(!(defl == 0))
                  {
                    return_value_cbdatumptr$20=cbdatumptr(resbody);
                    return_value_cbdatumsize$21=cbdatumsize(resbody);
                    zbuf=est_inflate(return_value_cbdatumptr$20, return_value_cbdatumsize$21, &zsiz, 0);
                    if(!(zbuf == ((char *)NULL)))
                      cbdatumsetbuf(resbody, zbuf, zsiz);

                  }


                __CPROVER_DUMP_L60:
                  ;
                }
                while((_Bool)0);
                __pthread_unregister_cancel(&est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_buf);
                est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_routine(est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$2$$1$$__cancel_arg);
              }
              while((_Bool)0);

            __CPROVER_DUMP_L62:
              ;
            }
            while((_Bool)0);
            __pthread_unregister_cancel(&est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_buf);
            est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_routine(est_url_shuttle_impl$$1$$1$$2$$2$$2$$2$$__cancel_arg);
          }
          while((_Bool)0);

        __CPROVER_DUMP_L64:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_buf);
        est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_routine(est_url_shuttle_impl$$1$$1$$2$$2$$__cancel_arg);
      }
      while((_Bool)0);

    __CPROVER_DUMP_L66:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  ((struct anonymous$27 *)targ)->alive = 0;
  pthread_cond_signal(((struct anonymous$27 *)targ)->cond);
  return (void *)0;
}

// est_usleep
// file estraier.h line 1528
void est_usleep(unsigned long int usec)
{
  usleep((unsigned int)usec);
}

// est_utime
// file estraier.c line 5620
signed int est_utime(const char *path, signed long int mtime)
{
  struct utimbuf buf;
  signed int return_value_utime$1;
  if(!(mtime >= 0l))
  {
    return_value_utime$1=utime(path, (struct utimbuf *)(void *)0);
    return (signed int)(return_value_utime$1 == 0);
  }

  else
  {
    buf.actime = mtime;
    buf.modtime = mtime;
    signed int return_value_utime$2;
    return_value_utime$2=utime(path, &buf);
    return (signed int)(return_value_utime$2 == 0);
  }
}

// est_vector_cosine
// file estraier.c line 5829
double est_vector_cosine(const signed int *avec, const signed int *bvec, signed int vnum)
{
  signed int i;
  double iprod;
  double aabs;
  double babs;
  iprod = 0.0;
  i = 0;
  for( ; !(i >= vnum); i = i + 1)
    iprod = iprod + (double)avec[(signed long int)i] * (double)bvec[(signed long int)i];
  aabs = 0.0;
  i = 0;
  for( ; !(i >= vnum); i = i + 1)
    aabs = aabs + (double)avec[(signed long int)i] * (double)avec[(signed long int)i];
  aabs=sqrt(aabs);
  babs = 0.0;
  i = 0;
  for( ; !(i >= vnum); i = i + 1)
    babs = babs + (double)bvec[(signed long int)i] * (double)bvec[(signed long int)i];
  babs=sqrt(babs);
  if(aabs < 1.0 || babs < 1.0 || iprod <= 0.0)
    return 0.0;

  else
    return iprod / (aabs * babs);
}

// est_vector_set_seed
// file estraier.c line 5794
void est_vector_set_seed(struct anonymous$9 *svmap, signed int *svec, signed int vnum)
{
  const char *kbuf;
  signed int nnum;
  signed int ksiz;
  cbmapiterinit(svmap);
  nnum = 0;
  signed int tmp_post$1;
  signed int tmp_post$3;
  while(!(nnum >= vnum))
  {
    kbuf=cbmapiternext(svmap, &ksiz);
    if(!(kbuf == ((const char *)NULL)))
    {
      if(!(ksiz >= 1))
        continue;

      tmp_post$1 = nnum;
      nnum = nnum + 1;
      const char *return_value_cbmapiterval$2;
      return_value_cbmapiterval$2=cbmapiterval(kbuf, (signed int *)(void *)0);
      svec[(signed long int)tmp_post$1]=atoi(return_value_cbmapiterval$2);
    }

    else
    {
      tmp_post$3 = nnum;
      nnum = nnum + 1;
      svec[(signed long int)tmp_post$3] = 0;
    }
  }
}

// est_vector_set_target
// file estraier.c line 5812
void est_vector_set_target(struct anonymous$9 *svmap, struct anonymous$9 *tvmap, signed int *tvec, signed int vnum)
{
  const char *kbuf;
  const char *vbuf;
  signed int i;
  signed int ksiz;
  cbmapiterinit(svmap);
  i = 0;
  signed int tmp_if_expr$2;
  signed int return_value_atoi$1;
  for( ; !(i >= vnum); i = i + 1)
  {
    kbuf=cbmapiternext(svmap, &ksiz);
    if(!(kbuf == ((const char *)NULL)))
    {
      vbuf=cbmapget(tvmap, kbuf, ksiz, (signed int *)(void *)0);
      if(!(vbuf == ((const char *)NULL)))
      {
        return_value_atoi$1=atoi(vbuf);
        tmp_if_expr$2 = return_value_atoi$1;
      }

      else
        tmp_if_expr$2 = 0;
      tvec[(signed long int)i] = tmp_if_expr$2;
    }

    else
      tvec[(signed long int)i] = 0;
  }
}

// est_weight_keywords
// file estraier.c line 8880
static void est_weight_keywords(struct anonymous *db, const char *word, struct anonymous$6 *scores, signed int snum)
{
  struct anonymous$6 *kscores;
  const signed int *res;
  signed int i;
  signed int knum;
  signed int nnum;
  double rank;
  const char *return_value_vlgetcache$1;
  return_value_vlgetcache$1=vlgetcache(db->auxdb, word, -1, &knum);
  res = (signed int *)return_value_vlgetcache$1;
  if(!(res == ((const signed int *)NULL)) && knum >= 2)
  {
    knum = knum / (signed int)sizeof(signed int) /*4ul*/ ;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)(knum / 2) * sizeof(struct anonymous$6) /*16ul*/ );
    kscores = (struct anonymous$6 *)return_value_malloc$2;
    if(!(kscores == ((struct anonymous$6 *)NULL)))
      kscores;

    else
      cbmyfatal("out of memory");
    rank = (double)(knum / 2 + 1);
    nnum = 0;
    i = 0;
    for( ; !(i >= knum); i = i + 2)
    {
      (kscores + (signed long int)nnum)->id = res[(signed long int)i];
      double return_value_pow$3;
      return_value_pow$3=pow(rank, 0.7);
      (kscores + (signed long int)nnum)->score = (signed int)((return_value_pow$3 / 8.0 + 1.0) * 10000.0);
      nnum = nnum + 1;
      rank = rank - 1.0;
    }
    knum = nnum;
    qsort((void *)scores, (unsigned long int)snum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
    qsort((void *)kscores, (unsigned long int)knum, sizeof(struct anonymous$6) /*16ul*/ , est_score_compare_by_id_asc);
    nnum = 0;
    i = 0;
    for( ; !(i >= snum); i = i + 1)
    {
      for( ; !(nnum >= knum); nnum = nnum + 1)
        if((kscores + (signed long int)nnum)->id >= (scores + (signed long int)i)->id)
          break;

      if(!(nnum >= knum))
      {
        if((kscores + (signed long int)nnum)->id == (scores + (signed long int)i)->id)
          (scores + (signed long int)i)->score = (scores + (signed long int)i)->score * (signed int)((double)(kscores + (signed long int)nnum)->score / 10000.0);

      }

    }
    free((void *)kscores);
  }

}

// main
// file estmttest.c line 65
signed int main(signed int argc, char **argv)
{
  const char *tmp;
  signed int rv;
  tmp=getenv("ESTDBGFD");
  if(!(tmp == ((const char *)NULL)))
    dpdbgfd=atoi(tmp);

  est_proc_env_reset();
  g_progname = argv[(signed long int)0];
  g_sigterm = 0;
  if(!(argc >= 2))
    usage();

  rv = 0;
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(argv[(signed long int)1], "wicked");
  signed int return_value_strcmp$1;
  if(return_value_strcmp$2 == 0)
  {
    setsignals();
    rv=runwicked(argc, argv);
  }

  else
  {
    return_value_strcmp$1=strcmp(argv[(signed long int)1], "regression");
    if(return_value_strcmp$1 == 0)
    {
      setsignals();
      rv=runregression(argc, argv);
    }

    else
      usage();
  }
  return rv;
}

// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes)
{
  const unsigned char *p = data;
  signed int left = nbytes;
  signed int offset = (signed int)(pms->count[(signed long int)0] >> 3 & (unsigned int)63);
  unsigned int nbits = (unsigned int)(nbytes << 3);
  if(nbytes >= 1)
  {
    pms->count[(signed long int)1] = pms->count[(signed long int)1] + (unsigned int)(nbytes >> 29);
    pms->count[(signed long int)0] = pms->count[(signed long int)0] + nbits;
    if(!(pms->count[0l] >= nbits))
      pms->count[(signed long int)1] = pms->count[(signed long int)1] + 1u;

    if(!(offset == 0))
    {
      signed int copy = offset + nbytes > 64 ? 64 - offset : nbytes;
      memcpy((void *)(pms->buf + (signed long int)offset), (const void *)p, (unsigned long int)copy);
      if(!(copy + offset >= 64))
        goto __CPROVER_DUMP_L7;

      p = p + (signed long int)copy;
      left = left - copy;
      md5_process(pms, pms->buf);
    }

    for( ; left >= 64; left = left - 64)
    {
      md5_process(pms, p);
      p = p + (signed long int)64;
    }
    if(!(left == 0))
      memcpy((void *)pms->buf, (const void *)p, (unsigned long int)left);

  }


__CPROVER_DUMP_L7:
  ;
}

// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest)
{
  unsigned char data[8l];
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    data[(signed long int)i] = (unsigned char)(pms->count[(signed long int)(i >> 2)] >> ((i & 3) << 3));
  static const unsigned char pad[64l] = { (const unsigned char)0x80, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  md5_append(pms, pad, (signed int)(((unsigned int)55 - (pms->count[(signed long int)0] >> 3) & (unsigned int)63) + (unsigned int)1));
  md5_append(pms, data, 8);
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    digest[(signed long int)i] = (unsigned char)(pms->abcd[(signed long int)(i >> 2)] >> ((i & 3) << 3));
}

// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms)
{
  pms->count[(signed long int)1] = (unsigned int)0;
  pms->count[(signed long int)0] = pms->count[(signed long int)1];
  pms->abcd[(signed long int)0] = (unsigned int)0x67452301;
  pms->abcd[(signed long int)1] = (unsigned int)~0 ^ (unsigned int)0x10325476;
  pms->abcd[(signed long int)2] = (unsigned int)~0 ^ (unsigned int)0x67452301;
  pms->abcd[(signed long int)3] = (unsigned int)0x10325476;
}

// md5_process
// file md5.c line 132
static void md5_process(struct md5_state_s *pms, const unsigned char *data)
{
  unsigned int a = pms->abcd[(signed long int)0];
  unsigned int b = pms->abcd[(signed long int)1];
  unsigned int c = pms->abcd[(signed long int)2];
  unsigned int d = pms->abcd[(signed long int)3];
  unsigned int t;
  unsigned int xbuf[16l];
  const unsigned int *X;
  static const signed int w = 1;
  if(!(*((const unsigned char *)&w) == 0))
  {
    if((data - ((const unsigned char *)NULL) & 3l) == 0l)
      X = (const unsigned int *)data;

    else
    {
      memcpy((void *)xbuf, (const void *)data, (unsigned long int)64);
      X = xbuf;
    }
  }

  else
  {
    const unsigned char *xp = data;
    signed int i;
    X = xbuf;
    i = 0;
    for( ; !(i >= 16); xp = xp + (signed long int)4)
    {
      xbuf[(signed long int)i] = (unsigned int)((signed int)xp[(signed long int)0] + ((signed int)xp[(signed long int)1] << 8) + ((signed int)xp[(signed long int)2] << 16) + ((signed int)xp[(signed long int)3] << 24));
      i = i + 1;
    }
  }
  t = a + (b & c | ~b & d) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x28955b87);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x173848a9);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)2] + (unsigned int)0x242070db;
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x3e423111);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x0a83f050);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)5] + (unsigned int)0x4787c62a;
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x57cfb9ec);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x02b96afe);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)8] + (unsigned int)0x698098d8;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x74bb0850);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x0000a44e);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x76a32841);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)12] + (unsigned int)0x6b901122;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x02678e6c);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x5986bc71);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)15] + (unsigned int)0x49b40821;
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x09e1da9d);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x3fbf4cbf);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)11] + (unsigned int)0x265e5a51;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x16493855);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x29d0efa2);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)10] + (unsigned int)0x02441453;
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x275e197e);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x182c0437);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x3cc8f829);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x0b2af278);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)8] + (unsigned int)0x455a14ed;
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x561c16fa);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x03105c07);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)7] + (unsigned int)0x676f02d9;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x72d5b375);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x0005c6bd);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)8] + ((unsigned int)~0 ^ (unsigned int)0x788e097e);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x021ac7f3);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x5b4115bb);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x0944b49f);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x4140438f);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x155ed805);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x2b10cf7a);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)6] + (unsigned int)0x04881d05;
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x262b2fc6);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x1924661a);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x3b53a99a);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x0bd6ddbb);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)7] + (unsigned int)0x432aff97;
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x546bdc58);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x036c5fc6);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)12] + (unsigned int)0x655b59c3;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x70f3336d);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x00100b82);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x7a7ba22e);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x01d3191f);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x5cfebceb);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x08ac817d);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x42c50dca);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x14792c6e);
  b = (t << 21 | t >> 32 - 21) + c;
  pms->abcd[(signed long int)0] = pms->abcd[(signed long int)0] + a;
  pms->abcd[(signed long int)1] = pms->abcd[(signed long int)1] + b;
  pms->abcd[(signed long int)2] = pms->abcd[(signed long int)2] + c;
  pms->abcd[(signed long int)3] = pms->abcd[(signed long int)3] + d;
}

// mtwkfunc
// file estmttest.c line 396
static void * mtwkfunc(void *mission)
{
  struct anonymous$14 *db;
  struct anonymous$14 **others;
  struct anonymous$0 *doc;
  struct anonymous$8 *cond;
  char uri[8192l];
  char *oper;
  char *value;
  char *first;
  char *second;
  char *phrase;
  signed int i;
  signed int j;
  signed int err;
  signed int id;
  signed int dnum;
  signed int *res;
  signed int rnum;
  signed int size;
  double rnd;
  id = ((struct anonymous$29 *)mission)->id;
  db = ((struct anonymous$29 *)mission)->db;
  others = ((struct anonymous$29 *)mission)->others;
  dnum = ((struct anonymous$29 *)mission)->dnum;
  printfinfo("%d: started", id);
  err = 0;
  i = 0;
  signed int return_value_est_mtdb_error$8;
  signed int return_value_est_mtdb_error$19;
  _Bool tmp_if_expr$33;
  signed int return_value_strcmp$32;
  for( ; !(i >= dnum); i = i + 1)
  {
    rnd=est_random();
    if(!((signed int)(rnd * 2.147484e+9) % dnum >= 1))
    {
      rnd=est_random();
      if(rnd < 0.3)
      {
        double return_value_est_random$1;
        return_value_est_random$1=est_random();
        signed int return_value_est_mtdb_optimize$2;
        return_value_est_mtdb_optimize$2=est_mtdb_optimize(db, (signed int)((signed int)(return_value_est_random$1 * (double)0x7fffffff) % 2 == 0));
        if(return_value_est_mtdb_optimize$2 == 0)
          err = 1;

      }

      else
        if(rnd < 0.8)
        {
          signed int return_value_est_mtdb_flush$3;
          return_value_est_mtdb_flush$3=est_mtdb_flush(db, 1024);
          if(return_value_est_mtdb_flush$3 == 0)
            err = 1;

        }

        else
        {
          signed int return_value_est_mtdb_sync$4;
          return_value_est_mtdb_sync$4=est_mtdb_sync(db);
          if(return_value_est_mtdb_sync$4 == 0)
            err = 1;

        }
    }

    else
      if(rnd < 0.001)
      {
        est_usleep((unsigned long int)(1000 * 100));
        signed int return_value_est_mtdb_doc_num$5;
        return_value_est_mtdb_doc_num$5=est_mtdb_doc_num(db);
        printfinfo("%d: [%d:%d]: sleep", id, i + 1, return_value_est_mtdb_doc_num$5);
      }

      else
        if(rnd < 0.005)
        {
          j = 0;
          for( ; !(j >= 4); j = j + 1)
            est_mtdb_interrupt(others[(signed long int)j]);
          signed int return_value_est_mtdb_doc_num$6;
          return_value_est_mtdb_doc_num$6=est_mtdb_doc_num(db);
          printfinfo("%d: [%d:%d]: interrupt", id, i + 1, return_value_est_mtdb_doc_num$6);
        }

        else
          if(rnd < 0.05)
          {
            double return_value_est_random$9;
            return_value_est_random$9=est_random();
            double return_value_est_random$10;
            return_value_est_random$10=est_random();
            signed int return_value_est_mtdb_out_doc$11;
            return_value_est_mtdb_out_doc$11=est_mtdb_out_doc(db, (signed int)(return_value_est_random$9 * (double)0x7fffffff) % (i + 1) + 1, (signed int)(return_value_est_random$10 * (double)0x7fffffff) % 2 == 0 ? 1 : 0);
            if(!(return_value_est_mtdb_out_doc$11 == 0))
            {
              signed int return_value_est_mtdb_doc_num$7;
              return_value_est_mtdb_doc_num$7=est_mtdb_doc_num(db);
              printfinfo("%d: [%d:%d]: out", id, i + 1, return_value_est_mtdb_doc_num$7);
            }

            else
            {
              return_value_est_mtdb_error$8=est_mtdb_error(db);
              if(!(return_value_est_mtdb_error$8 == 6))
                err = 1;

            }
          }

          else
            if(rnd < 0.1)
            {
              double return_value_est_random$13;
              return_value_est_random$13=est_random();
              value=est_mtdb_get_doc_attr(db, (signed int)(return_value_est_random$13 * (double)0x7fffffff) % (i + 1) + 1, "@uri");
              if(!(value == ((char *)NULL)))
              {
                signed int return_value_est_mtdb_doc_num$12;
                return_value_est_mtdb_doc_num$12=est_mtdb_doc_num(db);
                printfinfo("[%d:%d]: attr: %s", i + 1, return_value_est_mtdb_doc_num$12, value);
                free((void *)value);
              }

            }

            else
              if(rnd < 0.25)
              {
                rnd=est_random();
                if(rnd < 0.5)
                  oper = " OR ";

                else
                  if(rnd < 0.7)
                    oper = " AND ";

                  else
                    if(rnd < 0.8)
                      oper = " NOTAND ";

                    else
                      if(rnd < 0.9)
                        oper = " ";

                      else
                        oper = "";
                double return_value_est_random$14;
                return_value_est_random$14=est_random();
                first=est_random_str(5, (signed int)(return_value_est_random$14 * (double)0x7fffffff) % 6);
                double return_value_est_random$15;
                return_value_est_random$15=est_random();
                second=est_random_str(2, (signed int)(return_value_est_random$15 * (double)0x7fffffff) % 6);
                phrase=cbsprintf("%s%s%s", first, oper, second);
                cond=est_cond_new();
                est_cond_set_phrase(cond, phrase);
                double return_value_est_random$16;
                return_value_est_random$16=est_random();
                if(return_value_est_random$16 < 0.05)
                  est_cond_add_attr(cond, "@uri STREW 0.est");

                double return_value_est_random$17;
                return_value_est_random$17=est_random();
                if(return_value_est_random$17 < 0.05)
                  est_cond_set_order(cond, "@uri STRD");

                res=est_mtdb_search(db, cond, &rnum, (struct anonymous$9 *)(void *)0);
                signed int return_value_est_mtdb_doc_num$18;
                return_value_est_mtdb_doc_num$18=est_mtdb_doc_num(db);
                printfinfo("%d: [%d:%d]: search: %d hits", id, i + 1, return_value_est_mtdb_doc_num$18, rnum);
                double return_value_est_random$20;
                return_value_est_random$20=est_random();
                if(return_value_est_random$20 < 0.01)
                {
                  j = 0;
                  for( ; !(j >= 100) && !(j >= rnum); j = j + 1)
                  {
                    doc=est_mtdb_get_doc(db, res[(signed long int)j], 0);
                    if(!(doc == ((struct anonymous$0 *)NULL)))
                      est_doc_delete(doc);

                    else
                    {
                      return_value_est_mtdb_error$19=est_mtdb_error(db);
                      if(!(return_value_est_mtdb_error$19 == 6))
                        err = 1;

                    }
                  }
                }

                free((void *)res);
                est_cond_delete(cond);
                free((void *)phrase);
                free((void *)first);
                free((void *)second);
              }

              else
              {
                double return_value_est_random$21;
                return_value_est_random$21=est_random();
                doc=est_doc_new_from_chaos(100, 3, return_value_est_random$21 < 0.5 ? 2 : 6);
                double return_value_est_random$25;
                return_value_est_random$25=est_random();
                if(return_value_est_random$25 < 0.2)
                {
                  double return_value_est_random$22;
                  return_value_est_random$22=est_random();
                  signed int return_value_getpid$23;
                  return_value_getpid$23=getpid();
                  sprintf(uri, "file:///tmp/wicked-%08d-%05d.est", (signed int)(return_value_est_random$22 * (double)0x7fffffff) % (i + 1) + 1, (signed int)return_value_getpid$23);
                }

                else
                {
                  signed int return_value_getpid$24;
                  return_value_getpid$24=getpid();
                  sprintf(uri, "file:///tmp/wicked-%08d-%05d.est", i + 1, (signed int)return_value_getpid$24);
                }
                est_doc_add_attr(doc, "@uri", uri);
                double return_value_est_random$26;
                return_value_est_random$26=est_random();
                signed int return_value_est_mtdb_put_doc$27;
                return_value_est_mtdb_put_doc$27=est_mtdb_put_doc(db, doc, return_value_est_random$26 < 0.5 ? 1 : 0);
                if(return_value_est_mtdb_put_doc$27 == 0)
                  err = 1;

                double return_value_est_random$34;
                return_value_est_random$34=est_random();
                if(return_value_est_random$34 < 0.1)
                {
                  signed int return_value_est_doc_id$28;
                  return_value_est_doc_id$28=est_doc_id(doc);
                  unsigned long int return_value_strlen$29;
                  return_value_strlen$29=strlen(uri);
                  signed int return_value_est_mtdb_set_doc_entity$30;
                  return_value_est_mtdb_set_doc_entity$30=est_mtdb_set_doc_entity(db, return_value_est_doc_id$28, uri, (signed int)return_value_strlen$29);
                  if(return_value_est_mtdb_set_doc_entity$30 == 0)
                    err = 1;

                  signed int return_value_est_doc_id$31;
                  return_value_est_doc_id$31=est_doc_id(doc);
                  value=est_mtdb_get_doc_entity(db, return_value_est_doc_id$31, &size);
                  if(value == ((char *)NULL))
                    tmp_if_expr$33 = (_Bool)1;

                  else
                  {
                    return_value_strcmp$32=strcmp(value, uri);
                    tmp_if_expr$33 = return_value_strcmp$32 != 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$33)
                    err = 1;

                  free((void *)value);
                }

                est_doc_delete(doc);
              }
    if(!(g_sigterm == 0) || !(err == 0))
      break;

  }
  const char *return_value_est_mtdb_name$35;
  signed int return_value_est_mtdb_error$36;
  const char *return_value_est_err_msg$37;
  if(!(err == 0))
  {
    return_value_est_mtdb_name$35=est_mtdb_name(db);
    return_value_est_mtdb_error$36=est_mtdb_error(db);
    return_value_est_err_msg$37=est_err_msg(return_value_est_mtdb_error$36);
    printferror("%s: %s", return_value_est_mtdb_name$35, return_value_est_err_msg$37);
  }

  printfinfo("%d: finished", id);
  return (void *)(err != 0 ? "error" : (char *)(void *)0);
}

// printferror
// file estmttest.c line 88
static void printferror(const char *format, ...)
{
  void **ap = (void **)&format;
  fprintf(stderr, "%s: ERROR: ", g_progname);
  vfprintf(stderr, format, ap);
  fputc(10, stderr);
  fflush(stderr);
  ap = ((void **)NULL);
}

// printfinfo
// file estmttest.c line 100
static void printfinfo(const char *format, ...)
{
  void **ap = (void **)&format;
  signed int return_value_pthread_mutex_lock$1;
  static union anonymous$13 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&mutex);
  if(return_value_pthread_mutex_lock$1 == 0)
  {
    printf("%s: INFO: ", g_progname);
    vprintf(format, ap);
    putchar(10);
    fflush(stdout);
    pthread_mutex_unlock(&mutex);
    ap = ((void **)NULL);
  }

}

// procregression
// file estmttest.c line 276
static signed int procregression(const char *dbname)
{
  struct anonymous$14 *dbs[10l];
  struct anonymous$14 *db;
  struct anonymous$14 *tdbs[5l];
  struct anonymous$0 *doc;
  struct anonymous$8 *cond;
  struct anonymous$9 *hints;
  char wbuf[8192l];
  signed int i;
  signed int j;
  signed int ecode;
  signed int err;
  signed int *res;
  signed int rnum;
  signed long int curtime;
  curtime=time((signed long int *)(void *)0);
  printfinfo("# opening databases");
  i = 0;
  for( ; !(i >= 10); i = i + 1)
  {
    sprintf(wbuf, "%s-%08d", dbname, i + 1);
    dbs[(signed long int)i]=est_mtdb_open(wbuf, 2 | 4 | 8, &ecode);
    if(dbs[(signed long int)i] == ((struct anonymous$14 *)NULL))
    {
      signed int return_value_est_mtdb_error$1;
      return_value_est_mtdb_error$1=est_mtdb_error(dbs[(signed long int)i]);
      const char *return_value_est_err_msg$2;
      return_value_est_err_msg$2=est_err_msg(return_value_est_mtdb_error$1);
      printferror("%s: %s", (const void *)wbuf, return_value_est_err_msg$2);
      return 1;
    }

    est_mtdb_set_informer(dbs[(signed long int)i], dbinform, (void *)0);
  }
  err = 0;
  printfinfo("# registering documents");
  i = 0;
  for( ; g_sigterm == 0 && !(i >= 1000); i = i + 1)
  {
    doc=est_doc_new();
    signed int return_value_rand$3;
    return_value_rand$3=rand();
    sprintf(wbuf, "%d", return_value_rand$3 % (i + 100));
    est_doc_add_attr(doc, "@uri", wbuf);
    j = 0;
    for( ; !(j >= 100); j = j + 1)
    {
      signed int return_value_rand$4;
      return_value_rand$4=rand();
      signed int return_value_rand$5;
      return_value_rand$5=rand();
      sprintf(wbuf, "%c%c", 97 + return_value_rand$4 % 6, 97 + return_value_rand$5 % 6);
      est_doc_add_text(doc, wbuf);
    }
    signed int return_value_rand$6;
    return_value_rand$6=rand();
    db = dbs[(signed long int)(return_value_rand$6 % 10)];
    signed int return_value_est_mtdb_put_doc$9;
    return_value_est_mtdb_put_doc$9=est_mtdb_put_doc(db, doc, 1);
    if(return_value_est_mtdb_put_doc$9 == 0)
    {
      const char *return_value_est_mtdb_name$7;
      return_value_est_mtdb_name$7=est_mtdb_name(db);
      const char *return_value_est_err_msg$8;
      return_value_est_err_msg$8=est_err_msg(ecode);
      printferror("%s: %s", return_value_est_mtdb_name$7, return_value_est_err_msg$8);
      err = 1;
    }

    est_doc_delete(doc);
  }
  printfinfo("# flushing half of databases");
  i = 0;
  for( ; !(i >= 10); i = i + 2)
  {
    signed int return_value_est_mtdb_flush$12;
    return_value_est_mtdb_flush$12=est_mtdb_flush(dbs[(signed long int)i], -1);
    if(return_value_est_mtdb_flush$12 == 0)
    {
      const char *return_value_est_mtdb_name$10;
      return_value_est_mtdb_name$10=est_mtdb_name(dbs[(signed long int)i]);
      const char *return_value_est_err_msg$11;
      return_value_est_err_msg$11=est_err_msg(ecode);
      printferror("%s: %s", return_value_est_mtdb_name$10, return_value_est_err_msg$11);
      err = 1;
    }

  }
  printfinfo("# searching databases");
  i = 0;
  _Bool tmp_if_expr$16;
  for( ; g_sigterm == 0 && !(i >= 1000); i = i + 1)
  {
    cond=est_cond_new();
    signed int return_value_rand$13;
    return_value_rand$13=rand();
    signed int return_value_rand$14;
    return_value_rand$14=rand();
    sprintf(wbuf, "%c%c", 97 + return_value_rand$13 % 6, 97 + return_value_rand$14 % 6);
    est_cond_set_phrase(cond, wbuf);
    signed int return_value_rand$15;
    return_value_rand$15=rand();
    switch(return_value_rand$15 % 5)
    {
      case 0:
      {
        est_cond_set_order(cond, "[IDA]");
        break;
      }
      case 1:
      {
        est_cond_set_order(cond, "[SCA]");
        break;
      }
      case 2:
        est_cond_set_order(cond, "@uri STRA");
    }
    hints=cbmapopen();
    res=est_mtdb_search_meta(dbs, 10, cond, &rnum, hints);
    j = 0;
    for( ; !(j >= rnum); j = j + 2)
    {
      if(!(res[(signed long int)j] >= 0))
        tmp_if_expr$16 = (_Bool)1;

      else
        tmp_if_expr$16 = res[(signed long int)j] >= 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$16)
      {
        printferror("%s: search result is invalid", dbname);
        err = 1;
        break;
      }

    }
    free((void *)res);
    cbmapclose(hints);
    est_cond_delete(cond);
  }
  printfinfo("# searching certainly same databases");
  tdbs[(signed long int)0] = dbs[(signed long int)0];
  tdbs[(signed long int)1] = dbs[(signed long int)1];
  tdbs[(signed long int)2] = dbs[(signed long int)2];
  tdbs[(signed long int)3] = dbs[(signed long int)0];
  tdbs[(signed long int)4] = dbs[(signed long int)1];
  i = 0;
  _Bool tmp_if_expr$20;
  for( ; g_sigterm == 0 && !(i >= 100); i = i + 1)
  {
    cond=est_cond_new();
    signed int return_value_rand$17;
    return_value_rand$17=rand();
    signed int return_value_rand$18;
    return_value_rand$18=rand();
    sprintf(wbuf, "%c%c", 97 + return_value_rand$17 % 6, 97 + return_value_rand$18 % 6);
    est_cond_set_phrase(cond, wbuf);
    signed int return_value_rand$19;
    return_value_rand$19=rand();
    switch(return_value_rand$19 % 5)
    {
      case 0:
      {
        est_cond_set_order(cond, "[IDA]");
        break;
      }
      case 1:
      {
        est_cond_set_order(cond, "[SCA]");
        break;
      }
      case 2:
        est_cond_set_order(cond, "@uri STRA");
    }
    hints=cbmapopen();
    res=est_mtdb_search_meta(tdbs, 5, cond, &rnum, hints);
    j = 0;
    for( ; !(j >= rnum); j = j + 2)
    {
      if(!(res[(signed long int)j] >= 0))
        tmp_if_expr$20 = (_Bool)1;

      else
        tmp_if_expr$20 = res[(signed long int)j] >= 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$20)
      {
        printferror("%s: search result is invalid", dbname);
        err = 1;
        break;
      }

    }
    free((void *)res);
    cbmapclose(hints);
    est_cond_delete(cond);
  }
  printfinfo("# closing databases");
  i = 0;
  for( ; !(i >= 10); i = i + 1)
  {
    signed int return_value_est_mtdb_close$23;
    return_value_est_mtdb_close$23=est_mtdb_close(dbs[(signed long int)i], &ecode);
    if(return_value_est_mtdb_close$23 == 0)
    {
      const char *return_value_est_mtdb_name$21;
      return_value_est_mtdb_name$21=est_mtdb_name(dbs[(signed long int)i]);
      const char *return_value_est_err_msg$22;
      return_value_est_err_msg$22=est_err_msg(ecode);
      printferror("%s: %s", return_value_est_mtdb_name$21, return_value_est_err_msg$22);
      err = 1;
    }

  }
  signed long int return_value_time$24;
  return_value_time$24=time((signed long int *)(void *)0);
  curtime = return_value_time$24 - curtime;
  if(err == 0)
    printfinfo("# finished successfully: elapsed time: %dh %dm %ds", (signed int)(curtime / (signed long int)3600), (signed int)((curtime / (signed long int)60) % (signed long int)60), (signed int)(curtime % (signed long int)60));

  return err != 0 ? 1 : 0;
}

// procwicked
// file estmttest.c line 204
static signed int procwicked(const char *dbname, signed int dnum, signed int tnum)
{
  struct anonymous$14 *dbs[4l];
  struct anonymous$29 *missions;
  unsigned long int *threads;
  void *rv;
  char *name;
  signed int i;
  signed int ecode;
  signed int err;
  signed long int curtime;
  curtime=time((signed long int *)(void *)0);
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    name=cbsprintf("%s-%08d", dbname, i + 1);
    dbs[(signed long int)i]=est_mtdb_open(name, 2 | 4 | 8, &ecode);
    if(dbs[(signed long int)i] == ((struct anonymous$14 *)NULL))
    {
      const char *return_value_est_err_msg$1;
      return_value_est_err_msg$1=est_err_msg(ecode);
      printferror("%s: %s", name, return_value_est_err_msg$1);
      for( ; i >= 0; i = i - 1)
        est_mtdb_close(dbs[(signed long int)i], &ecode);
      free((void *)name);
      return -1;
    }

    est_mtdb_set_informer(dbs[(signed long int)i], dbinform, (void *)0);
    est_mtdb_set_cache_size(dbs[(signed long int)i], (unsigned long int)(1024 * 1024 * 32), 1024, 256, 64);
    est_mtdb_set_special_cache(dbs[(signed long int)i], "@uri", 128);
    free((void *)name);
  }
  void *return_value_cbmalloc$2;
  return_value_cbmalloc$2=cbmalloc(sizeof(struct anonymous$29) /*32ul*/  * (unsigned long int)tnum);
  missions = (struct anonymous$29 *)return_value_cbmalloc$2;
  void *return_value_cbmalloc$3;
  return_value_cbmalloc$3=cbmalloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)tnum);
  threads = (unsigned long int *)return_value_cbmalloc$3;
  err = 0;
  if(tnum == 1)
  {
    (missions + (signed long int)0)->id = 1;
    (missions + (signed long int)0)->db = dbs[(signed long int)0];
    (missions + (signed long int)0)->others = dbs;
    (missions + (signed long int)0)->dnum = dnum;
    void *return_value_mtwkfunc$4;
    return_value_mtwkfunc$4=mtwkfunc((void *)missions);
    if(!(return_value_mtwkfunc$4 == NULL))
      err = 1;

  }

  else
  {
    i = 0;
    for( ; !(i >= tnum); i = i + 1)
    {
      (missions + (signed long int)i)->id = i + 1;
      (missions + (signed long int)i)->db = dbs[(signed long int)(i % 4)];
      (missions + (signed long int)i)->others = dbs;
      (missions + (signed long int)i)->dnum = dnum;
      signed int return_value_pthread_create$5;
      return_value_pthread_create$5=pthread_create(threads + (signed long int)i, (const union pthread_attr_t *)(void *)0, mtwkfunc, (void *)(missions + (signed long int)i));
      if(!(return_value_pthread_create$5 == 0))
      {
        printferror("%d: pthread_create failed", i + 1);
        (missions + (signed long int)i)->id = -1;
        err = 1;
      }

    }
    i = 0;
    for( ; !(i >= tnum); i = i + 1)
      if(!((missions + (signed long int)i)->id == -1))
      {
        signed int return_value_pthread_join$6;
        return_value_pthread_join$6=pthread_join(threads[(signed long int)i], &rv);
        if(!(return_value_pthread_join$6 == 0))
        {
          printferror("%s: pthread_join failed", (missions + (signed long int)i)->id);
          err = 1;
        }

        else
          if(!(rv == NULL))
            err = 1;

      }

  }
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    signed int return_value_est_mtdb_close$8;
    return_value_est_mtdb_close$8=est_mtdb_close(dbs[(signed long int)i], &ecode);
    if(return_value_est_mtdb_close$8 == 0)
    {
      const char *return_value_est_err_msg$7;
      return_value_est_err_msg$7=est_err_msg(ecode);
      printferror("%s: %s", dbname, return_value_est_err_msg$7);
      err = 1;
    }

  }
  free((void *)threads);
  free((void *)missions);
  signed long int return_value_time$9;
  return_value_time$9=time((signed long int *)(void *)0);
  curtime = return_value_time$9 - curtime;
  if(err == 0)
    printfinfo("finished successfully: elapsed time: %dh %dm %ds", (signed int)(curtime / (signed long int)3600), (signed int)((curtime / (signed long int)60) % (signed long int)60), (signed int)(curtime % (signed long int)60));

  return err != 0 ? 1 : 0;
}

// runregression
// file estmttest.c line 184
static signed int runregression(signed int argc, char **argv)
{
  char *dbname;
  signed int i;
  signed int rv;
  dbname = (char *)(void *)0;
  i = 2;
  _Bool tmp_if_expr$1;
  for( ; !(i >= argc); i = i + 1)
  {
    if(dbname == ((char *)NULL))
      tmp_if_expr$1 = (signed int)argv[(signed long int)i][(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      usage();

    else
      if(dbname == ((char *)NULL))
        dbname = argv[(signed long int)i];

      else
        usage();
  }
  if(dbname == ((char *)NULL))
    usage();

  rv=procregression(dbname);
  return rv;
}

// runwicked
// file estmttest.c line 156
static signed int runwicked(signed int argc, char **argv)
{
  char *dbname;
  char *dnstr;
  char *tnstr;
  signed int i;
  signed int dnum;
  signed int tnum;
  signed int rv;
  dbname = (char *)(void *)0;
  dnstr = (char *)(void *)0;
  tnstr = (char *)(void *)0;
  i = 2;
  _Bool tmp_if_expr$1;
  for( ; !(i >= argc); i = i + 1)
  {
    if(dbname == ((char *)NULL))
      tmp_if_expr$1 = (signed int)argv[(signed long int)i][(signed long int)0] == 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      usage();

    else
      if(dbname == ((char *)NULL))
        dbname = argv[(signed long int)i];

      else
        if(dnstr == ((char *)NULL))
          dnstr = argv[(signed long int)i];

        else
          if(tnstr == ((char *)NULL))
            tnstr = argv[(signed long int)i];

          else
            usage();
  }
  if(dbname == ((char *)NULL) || dnstr == ((char *)NULL) || tnstr == ((char *)NULL))
    usage();

  dnum=atoi(dnstr);
  if(!(dnum >= 1))
    usage();

  tnum=atoi(tnstr);
  if(!(tnum >= 1))
    usage();

  rv=procwicked(dbname, dnum, tnum);
  return rv;
}

// setsignals
// file estmttest.c line 121
static void setsignals(void)
{
  signal(1, sigtermhandler);
  signal(2, sigtermhandler);
  signal(3, sigtermhandler);
  signal(13, sigtermhandler);
  signal(15, sigtermhandler);
}

// sigtermhandler
// file estmttest.c line 131
static void sigtermhandler(signed int num)
{
  static signed int tries = 0;
  signed int tmp_post$1 = tries;
  tries = tries + 1;
  if(!(tmp_post$1 >= 5))
    signal(num, sigtermhandler);

  else
    signal(num, (void (*)(signed int))0);
  g_sigterm = 1;
  printfinfo("the termination signal %d catched", num);
}

// usage
// file estmttest.c line 144
static void usage(void)
{
  fprintf(stderr, "%s: command line utility of Hyper Estraier\n", g_progname);
  fprintf(stderr, "\n");
  fprintf(stderr, "usage:\n");
  fprintf(stderr, "  %s wicked db dnum tnum\n", g_progname);
  fprintf(stderr, "  %s regression db\n", g_progname);
  fprintf(stderr, "\n");
  exit(1);
}

