// tag-#anon#ST[*{ARR4{U16}$U16$}$ARR4{U16}$U16$$'image'||SYM#tag-#anon#ST[U16'raw_height'||U16'raw_width'||U16'height'||U16'width'||U16'top_margin'||U16'left_margin'||U16'iheight'||U16'iwidth'||U32'raw_pitch'||U32'$pad0'||F64'pixel_aspect'||S32'flip'||ARR8{ARR4{S32}$S32$}$ARR4{S32}$S32$$'mask'||U32'$pad1'|]#'sizes'||SYM#tag-#anon#ST[ARR64{S8}$S8$'make'||ARR64{S8}$S8$'model'||ARR64{S8}$S8$'software'||U32'raw_count'||U32'dng_version'||U32'is_foveon'||S32'colors'||U32'filters'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans_abs'||ARR5{S8}$S8$'cdesc'||U24'$pad0'||U32'xmplen'||*{S8}$S8$'xmpdata'|]#'idata'||SYM#tag-#anon#ST[F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'||F32'EXIF_MaxAp'||ARR128{S8}$S8$'LensMake'||ARR128{S8}$S8$'Lens'||U16'FocalLengthIn35mmFormat'||U16'$pad0'||SYM#tag-#anon#ST[F32'NikonEffectiveMaxAp'||U8'NikonLensIDNumber'||U8'NikonLensFStops'||U8'NikonMCUVersion'||U8'NikonLensType'|]#'nikon'||SYM#tag-#anon#ST[F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'|]#'dng'||SYM#tag-#anon#ST[U64'LensID'||ARR128{S8}$S8$'Lens'||U16'LensFormat'||U16'LensMount'||U32'$pad0'||U64'CamID'||U16'CameraFormat'||U16'CameraMount'||ARR64{S8}$S8$'body'||S16'FocalType'||ARR16{S8}$S8$'LensFeatures_pre'||ARR16{S8}$S8$'LensFeatures_suf'||U16'$pad1'||F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'||F32'MinAp4MinFocal'||F32'MinAp4MaxFocal'||F32'MaxAp'||F32'MinAp'||F32'CurFocal'||F32'CurAp'||F32'MaxAp4CurFocal'||F32'MinAp4CurFocal'||F32'LensFStops'||U32'$pad2'||U64'TeleconverterID'||ARR128{S8}$S8$'Teleconverter'||U64'AdapterID'||ARR128{S8}$S8$'Adapter'||U64'AttachmentID'||ARR128{S8}$S8$'Attachment'||S16'CanonFocalUnits'||U16'$pad3'||F32'FocalLengthIn35mmFormat'|]#'makernotes'|]#'lens'||SYM#tag-#anon#ST[ARR4{U32}$U32$'greybox'||ARR4{U32}$U32$'cropbox'||ARR4{F64}$F64$'aber'||ARR6{F64}$F64$'gamm'||ARR4{F32}$F32$'user_mul'||U32'shot_select'||F32'bright'||F32'threshold'||S32'half_size'||S32'four_color_rgb'||S32'highlight'||S32'use_auto_wb'||S32'use_camera_wb'||S32'use_camera_matrix'||S32'output_color'||*{S8}$S8$'output_profile'||*{S8}$S8$'camera_profile'||*{S8}$S8$'bad_pixels'||*{S8}$S8$'dark_frame'||S32'output_bps'||S32'output_tiff'||S32'user_flip'||S32'user_qual'||S32'user_black'||ARR4{S32}$S32$'user_cblack'||S32'user_sat'||S32'med_passes'||F32'auto_bright_thr'||F32'adjust_maximum_thr'||S32'no_auto_bright'||S32'use_fuji_rotate'||S32'green_matching'||S32'dcb_iterations'||S32'dcb_enhance_fl'||S32'fbdd_noiserd'||S32'eeci_refine'||S32'es_med_passes'||S32'ca_correc'||F32'cared'||F32'cablue'||S32'cfaline'||F32'linenoise'||S32'cfa_clean'||F32'lclean'||F32'cclean'||S32'cfa_green'||F32'green_thresh'||S32'exp_correc'||F32'exp_shift'||F32'exp_preser'||S32'wf_debanding'||ARR4{F32}$F32$'wf_deband_treshold'||S32'use_rawspeed'||S32'no_auto_scale'||S32'no_interpolation'||S32'sraw_ycc'||S32'force_foveon_x3f'||S32'x3f_flags'||S32'sony_arw2_options'||S32'sony_arw2_posterization_thr'||F32'coolscan_nef_gamma'|]#'params'||U32'progress_flags'||U32'process_warnings'||SYM#tag-#anon#ST[ARR65536{U16}$U16$'curve'||ARR4102{U32}$U32$'cblack'||U32'black'||U32'data_maximum'||U32'maximum'||ARR8{ARR8{U16}$U16$}$ARR8{U16}$U16$$'white'||ARR4{F32}$F32$'cam_mul'||ARR4{F32}$F32$'pre_mul'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'cmatrix'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'rgb_cam'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'cam_xyz'||SYM#tag-ph1_t#'phase_one_data'||F32'flash_used'||F32'canon_ev'||ARR64{S8}$S8$'model2'||*{V}$V$'profile'||U32'profile_length'||ARR8{U32}$U32$'black_stat'||ARR2{SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#}$SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#$'dng_color'||SYM#tag-#anon#ST[S32'CanonColorDataVer'||S32'CanonColorDataSubVer'||S32'SpecularWhiteLevel'||S32'AverageBlackLevel'|]#'canon_makernotes'||F32'baseline_exposure'||ARR2{S32}$S32$'OlympusSensorCalibration'||F32'FujiExpoMidPointShift'||S32'digitalBack_color'|]#'color'||SYM#tag-#anon#ST[F32'iso_speed'||F32'shutter'||F32'aperture'||F32'focal_len'||S64'timestamp'||U32'shot_order'||ARR32{U32}$U32$'gpsdata'||SYM#tag-#anon#ST[ARR3{F32}$F32$'latitude'||ARR3{F32}$F32$'longtitude'||ARR3{F32}$F32$'gpstimestamp'||F32'altitude'||S8'altref'||S8'latref'||S8'longref'||S8'gpsstatus'||S8'gpsparsed'||U24'$pad0'|]#'parsed_gps'||ARR512{S8}$S8$'desc'||ARR64{S8}$S8$'artist'||U32'$pad0'|]#'other'||SYM#tag-#anon#ST[ENtag-LibRaw_thumbnail_formats#{U32}$U32$'tformat'||U16'twidth'||U16'theight'||U32'tlength'||S32'tcolors'||*{S8}$S8$'thumb'|]#'thumbnail'||SYM#tag-#anon#ST[*{V}$V$'raw_alloc'||*{U16}$U16$'raw_image'||*{ARR4{U16}$U16$}$ARR4{U16}$U16$$'color4_image'||*{ARR3{U16}$U16$}$ARR3{U16}$U16$$'color3_image'||*{ARR2{S16}$S16$}$ARR2{S16}$S16$$'ph1_cblack'||*{ARR2{S16}$S16$}$ARR2{S16}$S16$$'ph1_rblack'||SYM#tag-#anon#ST[ARR64{S8}$S8$'make'||ARR64{S8}$S8$'model'||ARR64{S8}$S8$'software'||U32'raw_count'||U32'dng_version'||U32'is_foveon'||S32'colors'||U32'filters'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans_abs'||ARR5{S8}$S8$'cdesc'||U24'$pad0'||U32'xmplen'||*{S8}$S8$'xmpdata'|]#'iparams'||SYM#tag-#anon#ST[U16'raw_height'||U16'raw_width'||U16'height'||U16'width'||U16'top_margin'||U16'left_margin'||U16'iheight'||U16'iwidth'||U32'raw_pitch'||U32'$pad0'||F64'pixel_aspect'||S32'flip'||ARR8{ARR4{S32}$S32$}$ARR4{S32}$S32$$'mask'||U32'$pad1'|]#'sizes'||SYM#tag-#anon#ST[U32'mix_green'||U32'raw_color'||U32'zero_is_bad'||U16'shrink'||U16'fuji_width'|]#'ioparams'||SYM#tag-#anon#ST[ARR65536{U16}$U16$'curve'||ARR4102{U32}$U32$'cblack'||U32'black'||U32'data_maximum'||U32'maximum'||ARR8{ARR8{U16}$U16$}$ARR8{U16}$U16$$'white'||ARR4{F32}$F32$'cam_mul'||ARR4{F32}$F32$'pre_mul'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'cmatrix'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'rgb_cam'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'cam_xyz'||SYM#tag-ph1_t#'phase_one_data'||F32'flash_used'||F32'canon_ev'||ARR64{S8}$S8$'model2'||*{V}$V$'profile'||U32'profile_length'||ARR8{U32}$U32$'black_stat'||ARR2{SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#}$SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#$'dng_color'||SYM#tag-#anon#ST[S32'CanonColorDataVer'||S32'CanonColorDataSubVer'||S32'SpecularWhiteLevel'||S32'AverageBlackLevel'|]#'canon_makernotes'||F32'baseline_exposure'||ARR2{S32}$S32$'OlympusSensorCalibration'||F32'FujiExpoMidPointShift'||S32'digitalBack_color'|]#'color'|]#'rawdata'||*{V}$V$'parent_class'|]
// file ./libraw/libraw_types.h line 421
struct anonymous$7;

// tag-#anon#ST[*{V}$V$'raw_alloc'||*{U16}$U16$'raw_image'||*{ARR4{U16}$U16$}$ARR4{U16}$U16$$'color4_image'||*{ARR3{U16}$U16$}$ARR3{U16}$U16$$'color3_image'||*{ARR2{S16}$S16$}$ARR2{S16}$S16$$'ph1_cblack'||*{ARR2{S16}$S16$}$ARR2{S16}$S16$$'ph1_rblack'||SYM#tag-#anon#ST[ARR64{S8}$S8$'make'||ARR64{S8}$S8$'model'||ARR64{S8}$S8$'software'||U32'raw_count'||U32'dng_version'||U32'is_foveon'||S32'colors'||U32'filters'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans_abs'||ARR5{S8}$S8$'cdesc'||U24'$pad0'||U32'xmplen'||*{S8}$S8$'xmpdata'|]#'iparams'||SYM#tag-#anon#ST[U16'raw_height'||U16'raw_width'||U16'height'||U16'width'||U16'top_margin'||U16'left_margin'||U16'iheight'||U16'iwidth'||U32'raw_pitch'||U32'$pad0'||F64'pixel_aspect'||S32'flip'||ARR8{ARR4{S32}$S32$}$ARR4{S32}$S32$$'mask'||U32'$pad1'|]#'sizes'||SYM#tag-#anon#ST[U32'mix_green'||U32'raw_color'||U32'zero_is_bad'||U16'shrink'||U16'fuji_width'|]#'ioparams'||SYM#tag-#anon#ST[ARR65536{U16}$U16$'curve'||ARR4102{U32}$U32$'cblack'||U32'black'||U32'data_maximum'||U32'maximum'||ARR8{ARR8{U16}$U16$}$ARR8{U16}$U16$$'white'||ARR4{F32}$F32$'cam_mul'||ARR4{F32}$F32$'pre_mul'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'cmatrix'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'rgb_cam'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'cam_xyz'||SYM#tag-ph1_t#'phase_one_data'||F32'flash_used'||F32'canon_ev'||ARR64{S8}$S8$'model2'||*{V}$V$'profile'||U32'profile_length'||ARR8{U32}$U32$'black_stat'||ARR2{SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#}$SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#$'dng_color'||SYM#tag-#anon#ST[S32'CanonColorDataVer'||S32'CanonColorDataSubVer'||S32'SpecularWhiteLevel'||S32'AverageBlackLevel'|]#'canon_makernotes'||F32'baseline_exposure'||ARR2{S32}$S32$'OlympusSensorCalibration'||F32'FujiExpoMidPointShift'||S32'digitalBack_color'|]#'color'|]
// file ./libraw/libraw_types.h line 350
struct anonymous$6;

// tag-#anon#ST[ARR3{F32}$F32$'latitude'||ARR3{F32}$F32$'longtitude'||ARR3{F32}$F32$'gpstimestamp'||F32'altitude'||S8'altref'||S8'latref'||S8'longref'||S8'gpsstatus'||S8'gpsparsed'||U24'$pad0'|]
// file ./libraw/libraw_types.h line 248
struct anonymous$12;

// tag-#anon#ST[ARR4{U32}$U32$'greybox'||ARR4{U32}$U32$'cropbox'||ARR4{F64}$F64$'aber'||ARR6{F64}$F64$'gamm'||ARR4{F32}$F32$'user_mul'||U32'shot_select'||F32'bright'||F32'threshold'||S32'half_size'||S32'four_color_rgb'||S32'highlight'||S32'use_auto_wb'||S32'use_camera_wb'||S32'use_camera_matrix'||S32'output_color'||*{S8}$S8$'output_profile'||*{S8}$S8$'camera_profile'||*{S8}$S8$'bad_pixels'||*{S8}$S8$'dark_frame'||S32'output_bps'||S32'output_tiff'||S32'user_flip'||S32'user_qual'||S32'user_black'||ARR4{S32}$S32$'user_cblack'||S32'user_sat'||S32'med_passes'||F32'auto_bright_thr'||F32'adjust_maximum_thr'||S32'no_auto_bright'||S32'use_fuji_rotate'||S32'green_matching'||S32'dcb_iterations'||S32'dcb_enhance_fl'||S32'fbdd_noiserd'||S32'eeci_refine'||S32'es_med_passes'||S32'ca_correc'||F32'cared'||F32'cablue'||S32'cfaline'||F32'linenoise'||S32'cfa_clean'||F32'lclean'||F32'cclean'||S32'cfa_green'||F32'green_thresh'||S32'exp_correc'||F32'exp_shift'||F32'exp_preser'||S32'wf_debanding'||ARR4{F32}$F32$'wf_deband_treshold'||S32'use_rawspeed'||S32'no_auto_scale'||S32'no_interpolation'||S32'sraw_ycc'||S32'force_foveon_x3f'||S32'x3f_flags'||S32'sony_arw2_options'||S32'sony_arw2_posterization_thr'||F32'coolscan_nef_gamma'|]
// file ./libraw/libraw_types.h line 273
struct anonymous$3;

// tag-#anon#ST[ARR64{S8}$S8$'make'||ARR64{S8}$S8$'model'||ARR64{S8}$S8$'software'||U32'raw_count'||U32'dng_version'||U32'is_foveon'||S32'colors'||U32'filters'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans'||ARR6{ARR6{S8}$S8$}$ARR6{S8}$S8$$'xtrans_abs'||ARR5{S8}$S8$'cdesc'||U24'$pad0'||U32'xmplen'||*{S8}$S8$'xmpdata'|]
// file ./libraw/libraw_types.h line 152
struct anonymous$1;

// tag-#anon#ST[ARR65536{U16}$U16$'curve'||ARR4102{U32}$U32$'cblack'||U32'black'||U32'data_maximum'||U32'maximum'||ARR8{ARR8{U16}$U16$}$ARR8{U16}$U16$$'white'||ARR4{F32}$F32$'cam_mul'||ARR4{F32}$F32$'pre_mul'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'cmatrix'||ARR3{ARR4{F32}$F32$}$ARR4{F32}$F32$$'rgb_cam'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'cam_xyz'||SYM#tag-ph1_t#'phase_one_data'||F32'flash_used'||F32'canon_ev'||ARR64{S8}$S8$'model2'||*{V}$V$'profile'||U32'profile_length'||ARR8{U32}$U32$'black_stat'||ARR2{SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#}$SYM#tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]#$'dng_color'||SYM#tag-#anon#ST[S32'CanonColorDataVer'||S32'CanonColorDataSubVer'||S32'SpecularWhiteLevel'||S32'AverageBlackLevel'|]#'canon_makernotes'||F32'baseline_exposure'||ARR2{S32}$S32$'OlympusSensorCalibration'||F32'FujiExpoMidPointShift'||S32'digitalBack_color'|]
// file ./libraw/libraw_types.h line 209
struct anonymous$4;

// tag-#anon#ST[ENtag-LibRaw_thumbnail_formats#{U32}$U32$'tformat'||U16'twidth'||U16'theight'||U32'tlength'||S32'tcolors'||*{S8}$S8$'thumb'|]
// file ./libraw/libraw_types.h line 237
struct anonymous$5;

// tag-#anon#ST[F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'|]
// file ./libraw/libraw_types.h line 405
struct anonymous$8;

// tag-#anon#ST[F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'||F32'EXIF_MaxAp'||ARR128{S8}$S8$'LensMake'||ARR128{S8}$S8$'Lens'||U16'FocalLengthIn35mmFormat'||U16'$pad0'||SYM#tag-#anon#ST[F32'NikonEffectiveMaxAp'||U8'NikonLensIDNumber'||U8'NikonLensFStops'||U8'NikonMCUVersion'||U8'NikonLensType'|]#'nikon'||SYM#tag-#anon#ST[F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'|]#'dng'||SYM#tag-#anon#ST[U64'LensID'||ARR128{S8}$S8$'Lens'||U16'LensFormat'||U16'LensMount'||U32'$pad0'||U64'CamID'||U16'CameraFormat'||U16'CameraMount'||ARR64{S8}$S8$'body'||S16'FocalType'||ARR16{S8}$S8$'LensFeatures_pre'||ARR16{S8}$S8$'LensFeatures_suf'||U16'$pad1'||F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'||F32'MinAp4MinFocal'||F32'MinAp4MaxFocal'||F32'MaxAp'||F32'MinAp'||F32'CurFocal'||F32'CurAp'||F32'MaxAp4CurFocal'||F32'MinAp4CurFocal'||F32'LensFStops'||U32'$pad2'||U64'TeleconverterID'||ARR128{S8}$S8$'Teleconverter'||U64'AdapterID'||ARR128{S8}$S8$'Adapter'||U64'AttachmentID'||ARR128{S8}$S8$'Attachment'||S16'CanonFocalUnits'||U16'$pad3'||F32'FocalLengthIn35mmFormat'|]#'makernotes'|]
// file ./libraw/libraw_types.h line 410
struct anonymous$2;

// tag-#anon#ST[F32'NikonEffectiveMaxAp'||U8'NikonLensIDNumber'||U8'NikonLensFStops'||U8'NikonMCUVersion'||U8'NikonLensType'|]
// file ./libraw/libraw_types.h line 399
struct anonymous;

// tag-#anon#ST[F32'iso_speed'||F32'shutter'||F32'aperture'||F32'focal_len'||S64'timestamp'||U32'shot_order'||ARR32{U32}$U32$'gpsdata'||SYM#tag-#anon#ST[ARR3{F32}$F32$'latitude'||ARR3{F32}$F32$'longtitude'||ARR3{F32}$F32$'gpstimestamp'||F32'altitude'||S8'altref'||S8'latref'||S8'longref'||S8'gpsstatus'||S8'gpsparsed'||U24'$pad0'|]#'parsed_gps'||ARR512{S8}$S8$'desc'||ARR64{S8}$S8$'artist'||U32'$pad0'|]
// file ./libraw/libraw_types.h line 259
struct anonymous$10;

// tag-#anon#ST[S32'CanonColorDataVer'||S32'CanonColorDataSubVer'||S32'SpecularWhiteLevel'||S32'AverageBlackLevel'|]
// file ./libraw/libraw_types.h line 201
struct anonymous$13;

// tag-#anon#ST[U16'illuminant'||U16'$pad0'||ARR4{ARR4{F32}$F32$}$ARR4{F32}$F32$$'calibration'||ARR4{ARR3{F32}$F32$}$ARR3{F32}$F32$$'colormatrix'|]
// file ./libraw/libraw_types.h line 194
struct anonymous$11;

// tag-#anon#ST[U16'raw_height'||U16'raw_width'||U16'height'||U16'width'||U16'top_margin'||U16'left_margin'||U16'iheight'||U16'iwidth'||U32'raw_pitch'||U32'$pad0'||F64'pixel_aspect'||S32'flip'||ARR8{ARR4{S32}$S32$}$ARR4{S32}$S32$$'mask'||U32'$pad1'|]
// file ./libraw/libraw_types.h line 170
struct anonymous$0;

// tag-#anon#ST[U32'mix_green'||U32'raw_color'||U32'zero_is_bad'||U16'shrink'||U16'fuji_width'|]
// file ./libraw/libraw_types.h line 103
struct anonymous$16;

// tag-#anon#ST[U64'LensID'||ARR128{S8}$S8$'Lens'||U16'LensFormat'||U16'LensMount'||U32'$pad0'||U64'CamID'||U16'CameraFormat'||U16'CameraMount'||ARR64{S8}$S8$'body'||S16'FocalType'||ARR16{S8}$S8$'LensFeatures_pre'||ARR16{S8}$S8$'LensFeatures_suf'||U16'$pad1'||F32'MinFocal'||F32'MaxFocal'||F32'MaxAp4MinFocal'||F32'MaxAp4MaxFocal'||F32'MinAp4MinFocal'||F32'MinAp4MaxFocal'||F32'MaxAp'||F32'MinAp'||F32'CurFocal'||F32'CurAp'||F32'MaxAp4CurFocal'||F32'MinAp4CurFocal'||F32'LensFStops'||U32'$pad2'||U64'TeleconverterID'||ARR128{S8}$S8$'Teleconverter'||U64'AdapterID'||ARR128{S8}$S8$'Adapter'||U64'AttachmentID'||ARR128{S8}$S8$'Attachment'||S16'CanonFocalUnits'||U16'$pad3'||F32'FocalLengthIn35mmFormat'|]
// file ./libraw/libraw_types.h line 371
struct anonymous$9;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$15;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$14;

// tag-LibRaw_thumbnail_formats
// file ./libraw/libraw_const.h line 218
enum LibRaw_thumbnail_formats { LIBRAW_THUMBNAIL_UNKNOWN=0, LIBRAW_THUMBNAIL_JPEG=1, LIBRAW_THUMBNAIL_BITMAP=2, LIBRAW_THUMBNAIL_LAYER=4, LIBRAW_THUMBNAIL_ROLLEI=5 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-ph1_t
// file ./libraw/libraw_types.h line 187
struct ph1_t;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

#ifndef NULL
#define NULL ((void*)0)
#endif

// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// get_next_file
// file samples/half_mt.c line 50
char * get_next_file();
// libraw_close
// file ./libraw/libraw.h line 65
void libraw_close(struct anonymous$7 *);
// libraw_dcraw_ppm_tiff_writer
// file ./libraw/libraw.h line 87
signed int libraw_dcraw_ppm_tiff_writer(struct anonymous$7 *, const char *);
// libraw_dcraw_process
// file ./libraw/libraw.h line 89
signed int libraw_dcraw_process(struct anonymous$7 *);
// libraw_init
// file ./libraw/libraw.h line 53
struct anonymous$7 * libraw_init(unsigned int);
// libraw_open_file
// file ./libraw/libraw.h line 54
signed int libraw_open_file(struct anonymous$7 *, const char *);
// libraw_strerror
// file ./libraw/libraw.h line 50
const char * libraw_strerror(signed int);
// libraw_unpack
// file ./libraw/libraw.h line 61
signed int libraw_unpack(struct anonymous$7 *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_files
// file samples/half_mt.c line 62
void * process_files(void *q);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$14 *, const union anonymous$15 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$14 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$14 *);
// show_files
// file samples/half_mt.c line 116
signed int show_files(void *q);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// usage
// file samples/half_mt.c line 104
void usage(const char *p);

struct anonymous$0
{
  // raw_height
  unsigned short int raw_height;
  // raw_width
  unsigned short int raw_width;
  // height
  unsigned short int height;
  // width
  unsigned short int width;
  // top_margin
  unsigned short int top_margin;
  // left_margin
  unsigned short int left_margin;
  // iheight
  unsigned short int iheight;
  // iwidth
  unsigned short int iwidth;
  // raw_pitch
  unsigned int raw_pitch;
  // pixel_aspect
  double pixel_aspect;
  // flip
  signed int flip;
  // mask
  signed int mask[8l][4l];
};

struct anonymous$1
{
  // make
  char make[64l];
  // model
  char model[64l];
  // software
  char software[64l];
  // raw_count
  unsigned int raw_count;
  // dng_version
  unsigned int dng_version;
  // is_foveon
  unsigned int is_foveon;
  // colors
  signed int colors;
  // filters
  unsigned int filters;
  // xtrans
  char xtrans[6l][6l];
  // xtrans_abs
  char xtrans_abs[6l][6l];
  // cdesc
  char cdesc[5l];
  // xmplen
  unsigned int xmplen;
  // xmpdata
  char *xmpdata;
};

struct anonymous
{
  // NikonEffectiveMaxAp
  float NikonEffectiveMaxAp;
  // NikonLensIDNumber
  unsigned char NikonLensIDNumber;
  // NikonLensFStops
  unsigned char NikonLensFStops;
  // NikonMCUVersion
  unsigned char NikonMCUVersion;
  // NikonLensType
  unsigned char NikonLensType;
};

struct anonymous$8
{
  // MinFocal
  float MinFocal;
  // MaxFocal
  float MaxFocal;
  // MaxAp4MinFocal
  float MaxAp4MinFocal;
  // MaxAp4MaxFocal
  float MaxAp4MaxFocal;
};

struct anonymous$9
{
  // LensID
  unsigned long long int LensID;
  // Lens
  char Lens[128l];
  // LensFormat
  unsigned short int LensFormat;
  // LensMount
  unsigned short int LensMount;
  // CamID
  unsigned long long int CamID;
  // CameraFormat
  unsigned short int CameraFormat;
  // CameraMount
  unsigned short int CameraMount;
  // body
  char body[64l];
  // FocalType
  signed short int FocalType;
  // LensFeatures_pre
  char LensFeatures_pre[16l];
  // LensFeatures_suf
  char LensFeatures_suf[16l];
  // MinFocal
  float MinFocal;
  // MaxFocal
  float MaxFocal;
  // MaxAp4MinFocal
  float MaxAp4MinFocal;
  // MaxAp4MaxFocal
  float MaxAp4MaxFocal;
  // MinAp4MinFocal
  float MinAp4MinFocal;
  // MinAp4MaxFocal
  float MinAp4MaxFocal;
  // MaxAp
  float MaxAp;
  // MinAp
  float MinAp;
  // CurFocal
  float CurFocal;
  // CurAp
  float CurAp;
  // MaxAp4CurFocal
  float MaxAp4CurFocal;
  // MinAp4CurFocal
  float MinAp4CurFocal;
  // LensFStops
  float LensFStops;
  // TeleconverterID
  unsigned long long int TeleconverterID;
  // Teleconverter
  char Teleconverter[128l];
  // AdapterID
  unsigned long long int AdapterID;
  // Adapter
  char Adapter[128l];
  // AttachmentID
  unsigned long long int AttachmentID;
  // Attachment
  char Attachment[128l];
  // CanonFocalUnits
  signed short int CanonFocalUnits;
  // FocalLengthIn35mmFormat
  float FocalLengthIn35mmFormat;
};

struct anonymous$2
{
  // MinFocal
  float MinFocal;
  // MaxFocal
  float MaxFocal;
  // MaxAp4MinFocal
  float MaxAp4MinFocal;
  // MaxAp4MaxFocal
  float MaxAp4MaxFocal;
  // EXIF_MaxAp
  float EXIF_MaxAp;
  // LensMake
  char LensMake[128l];
  // Lens
  char Lens[128l];
  // FocalLengthIn35mmFormat
  unsigned short int FocalLengthIn35mmFormat;
  // nikon
  struct anonymous nikon;
  // dng
  struct anonymous$8 dng;
  // makernotes
  struct anonymous$9 makernotes;
};

struct anonymous$3
{
  // greybox
  unsigned int greybox[4l];
  // cropbox
  unsigned int cropbox[4l];
  // aber
  double aber[4l];
  // gamm
  double gamm[6l];
  // user_mul
  float user_mul[4l];
  // shot_select
  unsigned int shot_select;
  // bright
  float bright;
  // threshold
  float threshold;
  // half_size
  signed int half_size;
  // four_color_rgb
  signed int four_color_rgb;
  // highlight
  signed int highlight;
  // use_auto_wb
  signed int use_auto_wb;
  // use_camera_wb
  signed int use_camera_wb;
  // use_camera_matrix
  signed int use_camera_matrix;
  // output_color
  signed int output_color;
  // output_profile
  char *output_profile;
  // camera_profile
  char *camera_profile;
  // bad_pixels
  char *bad_pixels;
  // dark_frame
  char *dark_frame;
  // output_bps
  signed int output_bps;
  // output_tiff
  signed int output_tiff;
  // user_flip
  signed int user_flip;
  // user_qual
  signed int user_qual;
  // user_black
  signed int user_black;
  // user_cblack
  signed int user_cblack[4l];
  // user_sat
  signed int user_sat;
  // med_passes
  signed int med_passes;
  // auto_bright_thr
  float auto_bright_thr;
  // adjust_maximum_thr
  float adjust_maximum_thr;
  // no_auto_bright
  signed int no_auto_bright;
  // use_fuji_rotate
  signed int use_fuji_rotate;
  // green_matching
  signed int green_matching;
  // dcb_iterations
  signed int dcb_iterations;
  // dcb_enhance_fl
  signed int dcb_enhance_fl;
  // fbdd_noiserd
  signed int fbdd_noiserd;
  // eeci_refine
  signed int eeci_refine;
  // es_med_passes
  signed int es_med_passes;
  // ca_correc
  signed int ca_correc;
  // cared
  float cared;
  // cablue
  float cablue;
  // cfaline
  signed int cfaline;
  // linenoise
  float linenoise;
  // cfa_clean
  signed int cfa_clean;
  // lclean
  float lclean;
  // cclean
  float cclean;
  // cfa_green
  signed int cfa_green;
  // green_thresh
  float green_thresh;
  // exp_correc
  signed int exp_correc;
  // exp_shift
  float exp_shift;
  // exp_preser
  float exp_preser;
  // wf_debanding
  signed int wf_debanding;
  // wf_deband_treshold
  float wf_deband_treshold[4l];
  // use_rawspeed
  signed int use_rawspeed;
  // no_auto_scale
  signed int no_auto_scale;
  // no_interpolation
  signed int no_interpolation;
  // sraw_ycc
  signed int sraw_ycc;
  // force_foveon_x3f
  signed int force_foveon_x3f;
  // x3f_flags
  signed int x3f_flags;
  // sony_arw2_options
  signed int sony_arw2_options;
  // sony_arw2_posterization_thr
  signed int sony_arw2_posterization_thr;
  // coolscan_nef_gamma
  float coolscan_nef_gamma;
};

struct ph1_t
{
  // format
  signed int format;
  // key_off
  signed int key_off;
  // tag_21a
  signed int tag_21a;
  // t_black
  signed int t_black;
  // split_col
  signed int split_col;
  // black_col
  signed int black_col;
  // split_row
  signed int split_row;
  // black_row
  signed int black_row;
  // tag_210
  float tag_210;
};

struct anonymous$11
{
  // illuminant
  unsigned short int illuminant;
  // calibration
  float calibration[4l][4l];
  // colormatrix
  float colormatrix[4l][3l];
};

struct anonymous$13
{
  // CanonColorDataVer
  signed int CanonColorDataVer;
  // CanonColorDataSubVer
  signed int CanonColorDataSubVer;
  // SpecularWhiteLevel
  signed int SpecularWhiteLevel;
  // AverageBlackLevel
  signed int AverageBlackLevel;
};

struct anonymous$4
{
  // curve
  unsigned short int curve[65536l];
  // cblack
  unsigned int cblack[4102l];
  // black
  unsigned int black;
  // data_maximum
  unsigned int data_maximum;
  // maximum
  unsigned int maximum;
  // white
  unsigned short int white[8l][8l];
  // cam_mul
  float cam_mul[4l];
  // pre_mul
  float pre_mul[4l];
  // cmatrix
  float cmatrix[3l][4l];
  // rgb_cam
  float rgb_cam[3l][4l];
  // cam_xyz
  float cam_xyz[4l][3l];
  // phase_one_data
  struct ph1_t phase_one_data;
  // flash_used
  float flash_used;
  // canon_ev
  float canon_ev;
  // model2
  char model2[64l];
  // profile
  void *profile;
  // profile_length
  unsigned int profile_length;
  // black_stat
  unsigned int black_stat[8l];
  // dng_color
  struct anonymous$11 dng_color[2l];
  // canon_makernotes
  struct anonymous$13 canon_makernotes;
  // baseline_exposure
  float baseline_exposure;
  // OlympusSensorCalibration
  signed int OlympusSensorCalibration[2l];
  // FujiExpoMidPointShift
  float FujiExpoMidPointShift;
  // digitalBack_color
  signed int digitalBack_color;
};

struct anonymous$12
{
  // latitude
  float latitude[3l];
  // longtitude
  float longtitude[3l];
  // gpstimestamp
  float gpstimestamp[3l];
  // altitude
  float altitude;
  // altref
  char altref;
  // latref
  char latref;
  // longref
  char longref;
  // gpsstatus
  char gpsstatus;
  // gpsparsed
  char gpsparsed;
};

struct anonymous$10
{
  // iso_speed
  float iso_speed;
  // shutter
  float shutter;
  // aperture
  float aperture;
  // focal_len
  float focal_len;
  // timestamp
  signed long int timestamp;
  // shot_order
  unsigned int shot_order;
  // gpsdata
  unsigned int gpsdata[32l];
  // parsed_gps
  struct anonymous$12 parsed_gps;
  // desc
  char desc[512l];
  // artist
  char artist[64l];
};

struct anonymous$5
{
  // tformat
  enum LibRaw_thumbnail_formats tformat;
  // twidth
  unsigned short int twidth;
  // theight
  unsigned short int theight;
  // tlength
  unsigned int tlength;
  // tcolors
  signed int tcolors;
  // thumb
  char *thumb;
};

struct anonymous$16
{
  // mix_green
  unsigned int mix_green;
  // raw_color
  unsigned int raw_color;
  // zero_is_bad
  unsigned int zero_is_bad;
  // shrink
  unsigned short int shrink;
  // fuji_width
  unsigned short int fuji_width;
};

struct anonymous$6
{
  // raw_alloc
  void *raw_alloc;
  // raw_image
  unsigned short int *raw_image;
  // color4_image
  unsigned short int (*color4_image)[4l];
  // color3_image
  unsigned short int (*color3_image)[3l];
  // ph1_cblack
  signed short int (*ph1_cblack)[2l];
  // ph1_rblack
  signed short int (*ph1_rblack)[2l];
  // iparams
  struct anonymous$1 iparams;
  // sizes
  struct anonymous$0 sizes;
  // ioparams
  struct anonymous$16 ioparams;
  // color
  struct anonymous$4 color;
};

struct anonymous$7
{
  // image
  unsigned short int (*image)[4l];
  // sizes
  struct anonymous$0 sizes;
  // idata
  struct anonymous$1 idata;
  // lens
  struct anonymous$2 lens;
  // params
  struct anonymous$3 params;
  // progress_flags
  unsigned int progress_flags;
  // process_warnings
  unsigned int process_warnings;
  // color
  struct anonymous$4 color;
  // other
  struct anonymous$10 other;
  // thumbnail
  struct anonymous$5 thumbnail;
  // rawdata
  struct anonymous$6 rawdata;
  // parent_class
  void *parent_class;
};

union anonymous$15
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$14
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};


// qm
// file samples/half_mt.c line 46
union anonymous$14 qm;
// qptr
// file samples/half_mt.c line 48
unsigned long int qptr = (unsigned long int)0;
// qsize
// file samples/half_mt.c line 48
unsigned long int qsize = (unsigned long int)0;
// queue
// file samples/half_mt.c line 47
char **queue = (char **)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// tiff_mode
// file samples/half_mt.c line 44
signed int tiff_mode = 0;
// use_auto_wb
// file samples/half_mt.c line 44
signed int use_auto_wb = 0;
// use_camera_wb
// file samples/half_mt.c line 44
signed int use_camera_wb = 0;
// verbose
// file samples/half_mt.c line 44
signed int verbose = 0;

// get_next_file
// file samples/half_mt.c line 50
char * get_next_file()
{
  char *ret;
  unsigned long int tmp_post$1;
  if(queue == ((char **)NULL))
    return (char *)(void *)0;

  else
    if(qptr >= qsize)
      return (char *)(void *)0;

    else
    {
      pthread_mutex_lock(&qm);
      tmp_post$1 = qptr;
      qptr = qptr + 1ul;
      ret = queue[(signed long int)tmp_post$1];
      pthread_mutex_unlock(&qm);
      return ret;
    }
}

// main
// file samples/half_mt.c line 129
signed int main(signed int ac, char **av)
{
  signed int i;
  signed int max_threads = 2;
  unsigned long int *threads;
  if(!(ac >= 2))
    usage(av[(signed long int)0]);

  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)(ac - 1), sizeof(char *) /*8ul*/ );
  queue = (char **)return_value_calloc$1;
  i = 1;
  unsigned long int tmp_post$2;
  for( ; !(i >= ac); i = i + 1)
    if((signed int)*av[(signed long int)i] == 45)
    {
      if((signed int)av[(signed long int)i][1l] == 119)
        use_camera_wb = 1;

      if((signed int)av[(signed long int)i][1l] == 97)
        use_auto_wb = 1;

      if((signed int)av[(signed long int)i][1l] == 118)
        verbose = 1;

      if((signed int)av[(signed long int)i][1l] == 84)
        tiff_mode = 1;

      if((signed int)av[(signed long int)i][1l] == 74)
      {
        i = i + 1;
        max_threads=atoi(av[(signed long int)i]);
        if(!(max_threads >= 1))
        {
          fprintf(stderr, "Job count should be at least 1\n");
          exit(1);
        }

      }

    }

    else
    {
      tmp_post$2 = qsize;
      qsize = qsize + 1ul;
      queue[(signed long int)tmp_post$2] = av[(signed long int)i];
    }
  pthread_mutex_init(&qm, (const union anonymous$15 *)(void *)0);
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)max_threads, sizeof(unsigned long int) /*8ul*/ );
  threads = (unsigned long int *)return_value_calloc$3;
  i = 0;
  for( ; !(i >= max_threads); i = i + 1)
    pthread_create(&threads[(signed long int)i], (const union pthread_attr_t *)(void *)0, process_files, (void *)0);
  i = 0;
  for( ; !(i >= max_threads); i = i + 1)
  {
    signed int *iptr;
    if(!(threads[(signed long int)i] == 0ul))
      pthread_join(threads[(signed long int)i], (void **)(void *)&iptr);

  }
  return 0;
}

// process_files
// file samples/half_mt.c line 62
void * process_files(void *q)
{
  signed int ret;
  signed int count = 0;
  char outfn[1024l];
  char *fn;
  struct anonymous$7 *iprc;
  iprc=libraw_init((unsigned int)0);
  if(iprc == ((struct anonymous$7 *)NULL))
  {
    fprintf(stderr, "Cannot create libraw handle\n");
    return (void *)0;
  }

  else
  {
    do
    {
      fn=get_next_file();
      if(fn == ((char *)NULL))
        break;

      iprc->params.half_size = 1;
      iprc->params.use_camera_wb = use_camera_wb;
      iprc->params.use_auto_wb = use_auto_wb;
      iprc->params.output_tiff = tiff_mode;
      ret=libraw_open_file(iprc, fn);
      if(!(verbose == 0))
        fprintf(stderr, "%s: %s/%s\n", fn, (const void *)iprc->idata.make, (const void *)iprc->idata.model);

      do
        if(!(ret == 0))
        {
          const char *return_value_libraw_strerror$1;
          return_value_libraw_strerror$1=libraw_strerror(ret);
          fprintf(stderr, "%s: %s\n", fn, return_value_libraw_strerror$1);
          if(!(ret >= -100000))
          {
            libraw_close(iprc);
            return (void *)0;
          }

        }

      while((_Bool)0);
      ret=libraw_unpack(iprc);
      do
        if(!(ret == 0))
        {
          const char *return_value_libraw_strerror$2;
          return_value_libraw_strerror$2=libraw_strerror(ret);
          fprintf(stderr, "%s: %s\n", fn, return_value_libraw_strerror$2);
          if(!(ret >= -100000))
          {
            libraw_close(iprc);
            return (void *)0;
          }

        }

      while((_Bool)0);
      ret=libraw_dcraw_process(iprc);
      do
        if(!(ret == 0))
        {
          const char *return_value_libraw_strerror$3;
          return_value_libraw_strerror$3=libraw_strerror(ret);
          fprintf(stderr, "%s: %s\n", fn, return_value_libraw_strerror$3);
          if(!(ret >= -100000))
          {
            libraw_close(iprc);
            return (void *)0;
          }

        }

      while((_Bool)0);
      snprintf(outfn, (unsigned long int)1023, "%s.%s", fn, tiff_mode != 0 ? "tiff" : "ppm");
      if(!(verbose == 0))
        fprintf(stderr, "Writing file %s\n", (const void *)outfn);

      ret=libraw_dcraw_ppm_tiff_writer(iprc, outfn);
      do
        if(!(ret == 0))
        {
          const char *return_value_libraw_strerror$4;
          return_value_libraw_strerror$4=libraw_strerror(ret);
          fprintf(stderr, "%s: %s\n", fn, return_value_libraw_strerror$4);
          if(!(ret >= -100000))
          {
            libraw_close(iprc);
            return (void *)0;
          }

        }

      while((_Bool)0);
      count = count + 1;
    }
    while((_Bool)1);
    libraw_close(iprc);
    return (void *)0;
  }
}

// show_files
// file samples/half_mt.c line 116
signed int show_files(void *q)
{
  char *p;
  signed int cnt = 0;
  do
  {
    p=get_next_file();
    if(p == ((char *)NULL))
      break;

    printf("%s\n", p);
    cnt = cnt + 1;
  }
  while((_Bool)1);
  return cnt;
}

// usage
// file samples/half_mt.c line 104
void usage(const char *p)
{
  printf("%s: Multi-threaded LibRaw sample app. Emulates dcraw -h [-w] [-a]\n", p);
  printf("Options:\n-J n  - set parrallel job coun (default 2)\n-v    - verbose\n-w    - use camera white balance\n-a    - average image for white balance\n");
  exit(1);
}

