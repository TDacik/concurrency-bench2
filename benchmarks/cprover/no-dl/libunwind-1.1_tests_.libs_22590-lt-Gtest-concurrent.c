// #anon_enum_DWARF_WHERE_UNDEF=0_DWARF_WHERE_SAME=1_DWARF_WHERE_CFAREL=2_DWARF_WHERE_REG=3_DWARF_WHERE_EXPR=4
// file ../include/dwarf.h line 208
enum anonymous_13 { DWARF_WHERE_UNDEF=0, DWARF_WHERE_SAME=1, DWARF_WHERE_CFAREL=2, DWARF_WHERE_REG=3, DWARF_WHERE_EXPR=4 };

// #anon_enum_DW_CFA_advance_loc=64_DW_CFA_offset=128_DW_CFA_restore=192_DW_CFA_nop=0_DW_CFA_set_loc=1_DW_CFA_advance_loc1=2_DW_CFA_advance_loc2=3_DW_CFA_advance_loc4=4_DW_CFA_offset_extended=5_DW_CFA_restore_extended=6_DW_CFA_undefined=7_DW_CFA_same_value=8_DW_CFA_register=9_DW_CFA_remember_state=10_DW_CFA_restore_state=11_DW_CFA_def_cfa=12_DW_CFA_def_cfa_register=13_DW_CFA_def_cfa_offset=14_DW_CFA_def_cfa_expression=15_DW_CFA_expression=16_DW_CFA_offset_extended_sf=17_DW_CFA_def_cfa_sf=18_DW_CFA_def_cfa_offset_sf=19_DW_CFA_lo_user=28_DW_CFA_MIPS_advance_loc8=29_DW_CFA_GNU_window_save=45_DW_CFA_GNU_args_size=46_DW_CFA_GNU_negative_offset_extended=47_DW_CFA_hi_user=60
// file ../include/dwarf.h line 131
enum anonymous_15 { DW_CFA_advance_loc=64, DW_CFA_offset=128, DW_CFA_restore=192, DW_CFA_nop=0, DW_CFA_set_loc=1, DW_CFA_advance_loc1=2, DW_CFA_advance_loc2=3, DW_CFA_advance_loc4=4, DW_CFA_offset_extended=5, DW_CFA_restore_extended=6, DW_CFA_undefined=7, DW_CFA_same_value=8, DW_CFA_register=9, DW_CFA_remember_state=10, DW_CFA_restore_state=11, DW_CFA_def_cfa=12, DW_CFA_def_cfa_register=13, DW_CFA_def_cfa_offset=14, DW_CFA_def_cfa_expression=15, DW_CFA_expression=16, DW_CFA_offset_extended_sf=17, DW_CFA_def_cfa_sf=18, DW_CFA_def_cfa_offset_sf=19, DW_CFA_lo_user=28, DW_CFA_MIPS_advance_loc8=29, DW_CFA_GNU_window_save=45, DW_CFA_GNU_args_size=46, DW_CFA_GNU_negative_offset_extended=47, DW_CFA_hi_user=60 };

// #anon_enum_DW_OP_addr=3_DW_OP_deref=6_DW_OP_const1u=8_DW_OP_const1s=9_DW_OP_const2u=10_DW_OP_const2s=11_DW_OP_const4u=12_DW_OP_const4s=13_DW_OP_const8u=14_DW_OP_const8s=15_DW_OP_constu=16_DW_OP_consts=17_DW_OP_dup=18_DW_OP_drop=19_DW_OP_over=20_DW_OP_pick=21_DW_OP_swap=22_DW_OP_rot=23_DW_OP_xderef=24_DW_OP_abs=25_DW_OP_and=26_DW_OP_div=27_DW_OP_minus=28_DW_OP_mod=29_DW_OP_mul=30_DW_OP_neg=31_DW_OP_not=32_DW_OP_or=33_DW_OP_plus=34_DW_OP_plus_uconst=35_DW_OP_shl=36_DW_OP_shr=37_DW_OP_shra=38_DW_OP_xor=39_DW_OP_skip=47_DW_OP_bra=40_DW_OP_eq=41_DW_OP_ge=42_DW_OP_gt=43_DW_OP_le=44_DW_OP_lt=45_DW_OP_ne=46_DW_OP_lit0=48_DW_OP_lit1=49_DW_OP_lit2=50_DW_OP_lit3=51_DW_OP_lit4=52_DW_OP_lit5=53_DW_OP_lit6=54_DW_OP_lit7=55_DW_OP_lit8=56_DW_OP_lit9=57_DW_OP_lit10=58_DW_OP_lit11=59_DW_OP_lit12=60_DW_OP_lit13=61_DW_OP_lit14=62_DW_OP_lit15=63_DW_OP_lit16=64_DW_OP_lit17=65_DW_OP_lit18=66_DW_OP_lit19=67_DW_OP_lit20=68_DW_OP_lit21=69_DW_OP_lit22=70_DW_OP_lit23=71_DW_OP_lit24=72_DW_OP_lit25=73_DW_OP_lit26=74_DW_OP_lit27=75_DW_OP_lit28=76_DW_OP_lit29=77_DW_OP_lit30=78_DW_OP_lit31=79_DW_OP_reg0=80_DW_OP_reg1=81_DW_OP_reg2=82_DW_OP_reg3=83_DW_OP_reg4=84_DW_OP_reg5=85_DW_OP_reg6=86_DW_OP_reg7=87_DW_OP_reg8=88_DW_OP_reg9=89_DW_OP_reg10=90_DW_OP_reg11=91_DW_OP_reg12=92_DW_OP_reg13=93_DW_OP_reg14=94_DW_OP_reg15=95_DW_OP_reg16=96_DW_OP_reg17=97_DW_OP_reg18=98_DW_OP_reg19=99_DW_OP_reg20=100_DW_OP_reg21=101_DW_OP_reg22=102_DW_OP_reg23=103_DW_OP_reg24=104_DW_OP_reg25=105_DW_OP_reg26=106_DW_OP_reg27=107_DW_OP_reg28=108_DW_OP_reg29=109_DW_OP_reg30=110_DW_OP_reg31=111_DW_OP_breg0=112_DW_OP_breg1=113_DW_OP_breg2=114_DW_OP_breg3=115_DW_OP_breg4=116_DW_OP_breg5=117_DW_OP_breg6=118_DW_OP_breg7=119_DW_OP_breg8=120_DW_OP_breg9=121_DW_OP_breg10=122_DW_OP_breg11=123_DW_OP_breg12=124_DW_OP_breg13=125_DW_OP_breg14=126_DW_OP_breg15=127_DW_OP_breg16=128_DW_OP_breg17=129_DW_OP_breg18=130_DW_OP_breg19=131_DW_OP_breg20=132_DW_OP_breg21=133_DW_OP_breg22=134_DW_OP_breg23=135_DW_OP_breg24=136_DW_OP_breg25=137_DW_OP_breg26=138_DW_OP_breg27=139_DW_OP_breg28=140_DW_OP_breg29=141_DW_OP_breg30=142_DW_OP_breg31=143_DW_OP_regx=144_DW_OP_fbreg=145_DW_OP_bregx=146_DW_OP_piece=147_DW_OP_deref_size=148_DW_OP_xderef_size=149_DW_OP_nop=150_DW_OP_push_object_address=151_DW_OP_call2=152_DW_OP_call4=153_DW_OP_call_ref=154_DW_OP_lo_user=224_DW_OP_hi_user=255
// file ../include/dwarf.h line 42
enum anonymous_9 { DW_OP_addr=3, DW_OP_deref=6, DW_OP_const1u=8, DW_OP_const1s=9, DW_OP_const2u=10, DW_OP_const2s=11, DW_OP_const4u=12, DW_OP_const4s=13, DW_OP_const8u=14, DW_OP_const8s=15, DW_OP_constu=16, DW_OP_consts=17, DW_OP_dup=18, DW_OP_drop=19, DW_OP_over=20, DW_OP_pick=21, DW_OP_swap=22, DW_OP_rot=23, DW_OP_xderef=24, DW_OP_abs=25, DW_OP_and=26, DW_OP_div=27, DW_OP_minus=28, DW_OP_mod=29, DW_OP_mul=30, DW_OP_neg=31, DW_OP_not=32, DW_OP_or=33, DW_OP_plus=34, DW_OP_plus_uconst=35, DW_OP_shl=36, DW_OP_shr=37, DW_OP_shra=38, DW_OP_xor=39, DW_OP_skip=47, DW_OP_bra=40, DW_OP_eq=41, DW_OP_ge=42, DW_OP_gt=43, DW_OP_le=44, DW_OP_lt=45, DW_OP_ne=46, DW_OP_lit0=48, DW_OP_lit1=49, DW_OP_lit2=50, DW_OP_lit3=51, DW_OP_lit4=52, DW_OP_lit5=53, DW_OP_lit6=54, DW_OP_lit7=55, DW_OP_lit8=56, DW_OP_lit9=57, DW_OP_lit10=58, DW_OP_lit11=59, DW_OP_lit12=60, DW_OP_lit13=61, DW_OP_lit14=62, DW_OP_lit15=63, DW_OP_lit16=64, DW_OP_lit17=65, DW_OP_lit18=66, DW_OP_lit19=67, DW_OP_lit20=68, DW_OP_lit21=69, DW_OP_lit22=70, DW_OP_lit23=71, DW_OP_lit24=72, DW_OP_lit25=73, DW_OP_lit26=74, DW_OP_lit27=75, DW_OP_lit28=76, DW_OP_lit29=77, DW_OP_lit30=78, DW_OP_lit31=79, DW_OP_reg0=80, DW_OP_reg1=81, DW_OP_reg2=82, DW_OP_reg3=83, DW_OP_reg4=84, DW_OP_reg5=85, DW_OP_reg6=86, DW_OP_reg7=87, DW_OP_reg8=88, DW_OP_reg9=89, DW_OP_reg10=90, DW_OP_reg11=91, DW_OP_reg12=92, DW_OP_reg13=93, DW_OP_reg14=94, DW_OP_reg15=95, DW_OP_reg16=96, DW_OP_reg17=97, DW_OP_reg18=98, DW_OP_reg19=99, DW_OP_reg20=100, DW_OP_reg21=101, DW_OP_reg22=102, DW_OP_reg23=103, DW_OP_reg24=104, DW_OP_reg25=105, DW_OP_reg26=106, DW_OP_reg27=107, DW_OP_reg28=108, DW_OP_reg29=109, DW_OP_reg30=110, DW_OP_reg31=111, DW_OP_breg0=112, DW_OP_breg1=113, DW_OP_breg2=114, DW_OP_breg3=115, DW_OP_breg4=116, DW_OP_breg5=117, DW_OP_breg6=118, DW_OP_breg7=119, DW_OP_breg8=120, DW_OP_breg9=121, DW_OP_breg10=122, DW_OP_breg11=123, DW_OP_breg12=124, DW_OP_breg13=125, DW_OP_breg14=126, DW_OP_breg15=127, DW_OP_breg16=128, DW_OP_breg17=129, DW_OP_breg18=130, DW_OP_breg19=131, DW_OP_breg20=132, DW_OP_breg21=133, DW_OP_breg22=134, DW_OP_breg23=135, DW_OP_breg24=136, DW_OP_breg25=137, DW_OP_breg26=138, DW_OP_breg27=139, DW_OP_breg28=140, DW_OP_breg29=141, DW_OP_breg30=142, DW_OP_breg31=143, DW_OP_regx=144, DW_OP_fbreg=145, DW_OP_bregx=146, DW_OP_piece=147, DW_OP_deref_size=148, DW_OP_xderef_size=149, DW_OP_nop=150, DW_OP_push_object_address=151, DW_OP_call2=152, DW_OP_call4=153, DW_OP_call_ref=154, DW_OP_lo_user=224, DW_OP_hi_user=255 };

// #anon_enum_LZMA_CHECK_NONE=0_LZMA_CHECK_CRC32=1_LZMA_CHECK_CRC64=4_LZMA_CHECK_SHA256=10
// file /usr/include/lzma/check.h line 27
enum anonymous_23 { LZMA_CHECK_NONE=0, LZMA_CHECK_CRC32=1, LZMA_CHECK_CRC64=4, LZMA_CHECK_SHA256=10 };

// #anon_enum_LZMA_OK=0_LZMA_STREAM_END=1_LZMA_NO_CHECK=2_LZMA_UNSUPPORTED_CHECK=3_LZMA_GET_CHECK=4_LZMA_MEM_ERROR=5_LZMA_MEMLIMIT_ERROR=6_LZMA_FORMAT_ERROR=7_LZMA_OPTIONS_ERROR=8_LZMA_DATA_ERROR=9_LZMA_BUF_ERROR=10_LZMA_PROG_ERROR=11
// file /usr/include/lzma/base.h line 57
enum anonymous_21 { LZMA_OK=0, LZMA_STREAM_END=1, LZMA_NO_CHECK=2, LZMA_UNSUPPORTED_CHECK=3, LZMA_GET_CHECK=4, LZMA_MEM_ERROR=5, LZMA_MEMLIMIT_ERROR=6, LZMA_FORMAT_ERROR=7, LZMA_OPTIONS_ERROR=8, LZMA_DATA_ERROR=9, LZMA_BUF_ERROR=10, LZMA_PROG_ERROR=11 };

// #anon_enum_LZMA_RESERVED_ENUM=0
// file /usr/include/lzma/base.h line 44
enum anonymous_24 { LZMA_RESERVED_ENUM=0 };

// #anon_enum_UNW_CACHE_NONE=0_UNW_CACHE_GLOBAL=1_UNW_CACHE_PER_THREAD=2
// file ../include/libunwind-common.h line 81
enum anonymous_10 { UNW_CACHE_NONE=0, UNW_CACHE_GLOBAL=1, UNW_CACHE_PER_THREAD=2 };

// #anon_enum_UNW_ESUCCESS=0_UNW_EUNSPEC=1_UNW_ENOMEM=2_UNW_EBADREG=3_UNW_EREADONLYREG=4_UNW_ESTOPUNWIND=5_UNW_EINVALIDIP=6_UNW_EBADFRAME=7_UNW_EINVAL=8_UNW_EBADVERSION=9_UNW_ENOINFO=10
// file ../include/libunwind-common.h line 46
enum anonymous_1 { UNW_ESUCCESS=0, UNW_EUNSPEC=1, UNW_ENOMEM=2, UNW_EBADREG=3, UNW_EREADONLYREG=4, UNW_ESTOPUNWIND=5, UNW_EINVALIDIP=6, UNW_EBADFRAME=7, UNW_EINVAL=8, UNW_EBADVERSION=9, UNW_ENOINFO=10 };

// #anon_enum_X86_64_SCF_NONE=0_X86_64_SCF_LINUX_RT_SIGFRAME=1_X86_64_SCF_FREEBSD_SIGFRAME=2_X86_64_SCF_FREEBSD_SYSCALL=3
// file ../include/tdep-x86_64/libunwind_i.h line 85
enum anonymous_2 { X86_64_SCF_NONE=0, X86_64_SCF_LINUX_RT_SIGFRAME=1, X86_64_SCF_FREEBSD_SIGFRAME=2, X86_64_SCF_FREEBSD_SYSCALL=3 };

// tag-#anon#ST[*{*{V}_V_(*{V}_V_|U64|U64)->*{V}_V_}_*{V}_V_(*{V}_V_|U64|U64)->*{V}_V__'alloc'||*{V(*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|*{V}_V_)->V_'free'||*{V}_V_'opaque'|]
// file /usr/include/lzma/base.h line 349
struct anonymous_22;

// tag-#anon#ST[*{SYM#tag-#anon#ST[U64'virtual_address'||BF{S64}_S64_'frame_type'||BF{S64}_S64_'last_frame'||BF{S64}_S64_'cfa_reg_rsp'||BF{S64}_S64_'cfa_reg_offset'||BF{S64}_S64_'rbp_cfa_offset'||BF{S64}_S64_'rsp_cfa_offset'|]#}_SYM#tag-#anon#ST[U64'virtual_address'||BF{S64}_S64_'frame_type'||BF{S64}_S64_'last_frame'||BF{S64}_S64_'cfa_reg_rsp'||BF{S64}_S64_'cfa_reg_offset'||BF{S64}_S64_'rbp_cfa_offset'||BF{S64}_S64_'rsp_cfa_offset'|]#_'frames'||U64'log_size'||U64'used'||U64'dtor_count'|]
// file x86_64/Gtrace.c line 38
struct anonymous_6;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_8;

// tag-#anon#ST[ARR16{U8}_U8_'e_ident'||U16'e_type'||U16'e_machine'||U32'e_version'||U64'e_entry'||U64'e_phoff'||U64'e_shoff'||U32'e_flags'||U16'e_ehsize'||U16'e_phentsize'||U16'e_phnum'||U16'e_shentsize'||U16'e_shnum'||U16'e_shstrndx'|]
// file /usr/include/elf.h line 85
struct anonymous_20;

// tag-#anon#ST[ARR23{S64}_S64_'gregs'||*{SYM#tag-_libc_fpstate#}_SYM#tag-_libc_fpstate#_'fpregs'||ARR8{U64}_U64_'__reserved1'|]
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 124
struct anonymous_11;

// tag-#anon#ST[EN#anon_enum_DWARF_WHERE_UNDEF=0_DWARF_WHERE_SAME=1_DWARF_WHERE_CFAREL=2_DWARF_WHERE_REG=3_DWARF_WHERE_EXPR=4#{U32}_U32_'where'||U32'_pad0'||U64'val'|]
// file ../include/dwarf.h line 218
struct anonymous_12;

// tag-#anon#ST[S64'd_tag'||SYM#tag-#anon#UN[U64'd_val'||U64'd_ptr'|]#'d_un'|]
// file /usr/include/elf.h line 663
struct anonymous_18;

// tag-#anon#ST[U32'p_type'||U32'p_flags'||U64'p_offset'||U64'p_vaddr'||U64'p_paddr'||U64'p_filesz'||U64'p_memsz'||U64'p_align'|]
// file /usr/include/elf.h line 554
struct anonymous_16;

// tag-#anon#ST[U32'sh_name'||U32'sh_type'||U64'sh_flags'||U64'sh_addr'||U64'sh_offset'||U64'sh_size'||U32'sh_link'||U32'sh_info'||U64'sh_addralign'||U64'sh_entsize'|]
// file /usr/include/elf.h line 287
struct anonymous_26;

// tag-#anon#ST[U32'st_name'||U8'st_info'||U8'st_other'||U16'st_shndx'||U64'st_value'||U64'st_size'|]
// file /usr/include/elf.h line 392
struct anonymous;

// tag-#anon#ST[U32'version'||U32'_pad0'||U64'backward_size'||EN#anon_enum_LZMA_CHECK_NONE=0_LZMA_CHECK_CRC32=1_LZMA_CHECK_CRC64=4_LZMA_CHECK_SHA256=10#{U32}_U32_'check'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum1'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum2'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum3'||EN#anon_enum_LZMA_RESERVED_ENUM=0#{U32}_U32_'reserved_enum4'||U8'reserved_bool1'||U8'reserved_bool2'||U8'reserved_bool3'||U8'reserved_bool4'||U8'reserved_bool5'||U8'reserved_bool6'||U8'reserved_bool7'||U8'reserved_bool8'||U32'reserved_int1'||U32'reserved_int2'||U32'_pad1'|]
// file /usr/include/lzma/stream_flags.h line 33
struct anonymous_25;

// tag-#anon#ST[U64'virtual_address'||BF{S64}_S64_'frame_type'||BF{S64}_S64_'last_frame'||BF{S64}_S64_'cfa_reg_rsp'||BF{S64}_S64_'cfa_reg_offset'||BF{S64}_S64_'rbp_cfa_offset'||BF{S64}_S64_'rsp_cfa_offset'|]
// file ../include/tdep-x86_64/libunwind_i.h line 50
struct anonymous_5;

// tag-#anon#ST[]
// file ../include/libunwind-x86_64.h line 120
struct anonymous_14;

// tag-#anon#UN[*{SYM#tag-_fpstate#}_SYM#tag-_fpstate#_'fpstate'||U64'__fpstate_word'|]
// file /usr/include/x86_64-linux-gnu/bits/sigcontext.h line 165
union anonymous_3;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_7;

// tag-#anon#UN[SYM#tag-unw_dyn_proc_info#'pi'||SYM#tag-unw_dyn_table_info#'ti'||SYM#tag-unw_dyn_remote_table_info#'rti'|]
// file ../include/libunwind-dynamic.h line 140
union anonymous_19;

// tag-#anon#UN[U64'addr'||S32'regnum'|]
// file ../include/libunwind-common.h line 197
union anonymous_4;

// tag-#anon#UN[U64'd_val'||U64'd_ptr'|]
// file /usr/include/elf.h line 666
union anonymous_17;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_fpstate
// file /usr/include/x86_64-linux-gnu/bits/sigcontext.h line 121
struct _fpstate;

// tag-_fpxreg
// file /usr/include/x86_64-linux-gnu/bits/sigcontext.h line 44
struct _fpxreg;

// tag-_libc_fpstate
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 104
struct _libc_fpstate;

// tag-_libc_fpxreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 92
struct _libc_fpxreg;

// tag-_libc_xmmreg
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 99
struct _libc_xmmreg;

// tag-_xmmreg
// file /usr/include/x86_64-linux-gnu/bits/sigcontext.h line 51
struct _xmmreg;

// tag-cursor
// file ../include/tdep-x86_64/libunwind_i.h line 77
struct cursor;

// tag-dl_phdr_info
// file /usr/include/link.h line 138
struct dl_phdr_info;

// tag-dwarf_callback_data
// file ../include/dwarf.h line 347
struct dwarf_callback_data;

// tag-dwarf_cie_info
// file ../include/dwarf.h line 252
struct dwarf_cie_info;

// tag-dwarf_cursor
// file ../include/dwarf.h line 31
struct dwarf_cursor;

// tag-dwarf_eh_frame_hdr
// file ../include/dwarf-eh.h line 109
struct dwarf_eh_frame_hdr;

// tag-dwarf_loc
// file ../include/tdep-x86_64/dwarf-config.h line 50
struct dwarf_loc;

// tag-dwarf_reg_state
// file ../include/dwarf.h line 238
struct dwarf_reg_state;

// tag-dwarf_rs_cache
// file ../include/dwarf.h line 315
struct dwarf_rs_cache;

// tag-dwarf_state_record
// file ../include/dwarf.h line 272
struct dwarf_state_record;

// tag-elf_dyn_info
// file ../include/libunwind_i.h line 277
struct elf_dyn_info;

// tag-elf_image
// file ../include/libunwind_i.h line 271
struct elf_image;

// tag-lzma_index_s
// file /usr/include/lzma/index.h line 37
struct lzma_index_s;

// tag-map_iterator
// file os-linux.h line 30
struct map_iterator;

// tag-mempool
// file ../include/mempool.h line 61
struct mempool;

// tag-object
// file ../include/mempool.h line 68
struct object;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaltstack
// file /usr/include/x86_64-linux-gnu/bits/sigstack.h line 49
struct sigaltstack;

// tag-sigcontext
// file /usr/include/x86_64-linux-gnu/bits/sigcontext.h line 137
struct sigcontext;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-table_entry
// file ../include/dwarf.h line 341
struct table_entry;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-ucontext
// file /usr/include/x86_64-linux-gnu/sys/ucontext.h line 133
struct ucontext;

// tag-unw_accessors
// file ../include/libunwind-common.h line 144
struct unw_accessors;

// tag-unw_addr_space
// file ../include/libunwind-common.h line 117
struct unw_addr_space;

// tag-unw_cursor
// file ../include/libunwind-common.h line 95
struct unw_cursor;

// tag-unw_debug_frame_list
// file ../include/dwarf.h line 332
struct unw_debug_frame_list;

// tag-unw_dyn_info
// file ../include/libunwind-dynamic.h line 130
struct unw_dyn_info;

// tag-unw_dyn_info_list
// file ../include/libunwind-dynamic.h line 150
struct unw_dyn_info_list;

// tag-unw_dyn_op
// file ../include/libunwind-dynamic.h line 83
struct unw_dyn_op;

// tag-unw_dyn_proc_info
// file ../include/libunwind-dynamic.h line 102
struct unw_dyn_proc_info;

// tag-unw_dyn_region_info
// file ../include/libunwind-dynamic.h line 93
struct unw_dyn_region_info;

// tag-unw_dyn_remote_table_info
// file ../include/libunwind-dynamic.h line 121
struct unw_dyn_remote_table_info;

// tag-unw_dyn_table_info
// file ../include/libunwind-dynamic.h line 112
struct unw_dyn_table_info;

// tag-unw_proc_info
// file ../include/libunwind-common.h line 125
struct unw_proc_info;

// tag-unw_save_loc
// file ../include/libunwind-common.h line 194
struct unw_save_loc;

// tag-unw_save_loc_type
// file ../include/libunwind-common.h line 186
enum unw_save_loc_type { UNW_SLT_NONE=0, UNW_SLT_MEMORY=1, UNW_SLT_REG=2 };

// tag-unw_tdep_save_loc
// file ../include/libunwind-x86_64.h line 111
struct unw_tdep_save_loc;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef FENCE
#define FENCE(x) ((void)0)
#endif

// _UIx86_64__mempool_alloc
// file mi/mempool.c line 154
extern void * _UIx86_64__mempool_alloc(struct mempool *pool);
// _UIx86_64__mempool_free
// file mi/mempool.c line 175
extern void _UIx86_64__mempool_free(struct mempool *pool, void *object);
// _UIx86_64__mempool_init
// file mi/mempool.c line 127
extern void _UIx86_64__mempool_init(struct mempool *pool, unsigned long int obj_size, unsigned long int reserve);
// _UIx86_64__sos_alloc
// file mi/mempool.c line 47
extern void * _UIx86_64__sos_alloc(unsigned long int size);
// _UIx86_64_mi_init
// file mi/init.c line 44
extern void _UIx86_64_mi_init(void);
// _U_dyn_info_list_addr
// file ../include/libunwind_i.h line 267
extern unsigned long int _U_dyn_info_list_addr(void);
// _Uelf64_extract_minidebuginfo
// file elfxx.c line 215
static signed int _Uelf64_extract_minidebuginfo(struct elf_image *ei, struct elf_image *mdi);
// _Uelf64_get_load_offset
// file elfxx.c line 160
static unsigned long int _Uelf64_get_load_offset(struct elf_image *ei, unsigned long int segbase, unsigned long int mapoff);
// _Uelf64_get_proc_name
// file ./elfxx.h line 46
extern signed int _Uelf64_get_proc_name(struct unw_addr_space *as, signed int pid, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp);
// _Uelf64_get_proc_name_in_image
// file elfxx.c line 304
extern signed int _Uelf64_get_proc_name_in_image(struct unw_addr_space *as, struct elf_image *ei, unsigned long int segbase, unsigned long int mapoff, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp);
// _Uelf64_lookup_symbol
// file elfxx.c line 87
static signed int _Uelf64_lookup_symbol(struct unw_addr_space *as, unsigned long int ip, struct elf_image *ei, unsigned long int load_offset, char *buf, unsigned long int buf_len, unsigned long int *min_dist);
// _Uelf64_section_table
// file elfxx.c line 37
static struct anonymous_26 * _Uelf64_section_table(struct elf_image *ei);
// _Uelf64_string_table
// file elfxx.c line 55
static char * _Uelf64_string_table(struct elf_image *ei, signed int section);
// _Uelf64_valid_object
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object(struct elf_image *ei);
// _Uelf64_valid_object_link1
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object_link1(struct elf_image *ei_link1);
// _Uelf64_valid_object_link2
// file elfxx.h line 64
static inline signed int _Uelf64_valid_object_link2(struct elf_image *ei_link2);
// _Uelf64_valid_object_link3
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object_link3(struct elf_image *ei_link3);
// _Uelf64_valid_object_link4
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object_link4(struct elf_image *ei_link4);
// _Ux86_64_Idyn_remote_find_proc_info
// file mi/Gdyn-remote.c line 204
extern signed int _Ux86_64_Idyn_remote_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg);
// _Ux86_64_Idyn_remote_put_unwind_info
// file mi/Gdyn-remote.c line 289
extern void _Ux86_64_Idyn_remote_put_unwind_info(struct unw_addr_space *as, struct unw_proc_info *pi, void *arg);
// _Ux86_64_Idyn_validate_cache
// file mi/Gdyn-remote.c line 304
extern signed int _Ux86_64_Idyn_validate_cache(struct unw_addr_space *as, void *arg);
// _Ux86_64_Iextract_dynamic_proc_info
// file mi/Gdyn-extract.c line 29
extern signed int _Ux86_64_Iextract_dynamic_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, struct unw_dyn_info *di, signed int need_unwind_info, void *arg);
// _Ux86_64_Ifind_dynamic_proc_info
// file mi/Gfind_dynamic_proc_info.c line 83
extern signed int _Ux86_64_Ifind_dynamic_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg);
// _Ux86_64_Iput_dynamic_unwind_info
// file ../include/libunwind_i.h line 213
extern void _Ux86_64_Iput_dynamic_unwind_info(struct unw_addr_space *as, struct unw_proc_info *pi, void *arg);
// _Ux86_64_access_fpreg
// file ../include/tdep-x86_64/libunwind_i.h line 236
extern signed int _Ux86_64_access_fpreg(struct cursor *c, signed int reg, long double *valp, signed int write);
// _Ux86_64_access_reg
// file ../include/tdep-x86_64/libunwind_i.h line 234
extern signed int _Ux86_64_access_reg(struct cursor *c, signed int reg, unsigned long int *valp, signed int write);
// _Ux86_64_cache_frame
// file x86_64/Gos-linux.c line 51
extern void _Ux86_64_cache_frame(struct dwarf_cursor *dw, struct dwarf_reg_state *rs);
// _Ux86_64_create_addr_space
// file x86_64/Gcreate_addr_space.c line 38
extern struct unw_addr_space * _Ux86_64_create_addr_space(struct unw_accessors *a, signed int byte_order);
// _Ux86_64_destroy_addr_space
// file mi/Gdestroy_addr_space.c line 29
extern void _Ux86_64_destroy_addr_space(struct unw_addr_space *as);
// _Ux86_64_dwarf_callback
// file dwarf/Gfind_proc_info-lsb.c line 531
extern signed int _Ux86_64_dwarf_callback(struct dl_phdr_info *info, unsigned long int size, void *ptr);
// _Ux86_64_dwarf_create_state_record
// file dwarf/Gparser.c line 893
extern signed int _Ux86_64_dwarf_create_state_record(struct dwarf_cursor *c, struct dwarf_state_record *sr);
// _Ux86_64_dwarf_eval_expr
// file dwarf/Gexpr.c line 190
extern signed int _Ux86_64_dwarf_eval_expr(struct dwarf_cursor *c, unsigned long int *addr, unsigned long int len, unsigned long int *valp, signed int *is_register);
// _Ux86_64_dwarf_extract_proc_info_from_fde
// file dwarf/Gfde.c line 221
extern signed int _Ux86_64_dwarf_extract_proc_info_from_fde(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addrp, struct unw_proc_info *pi, signed int need_unwind_info, unsigned long int base, void *arg);
// _Ux86_64_dwarf_find_proc_info
// file ../include/dwarf.h line 380
extern signed int _Ux86_64_dwarf_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg);
// _Ux86_64_dwarf_find_save_locs
// file dwarf/Gparser.c line 842
extern signed int _Ux86_64_dwarf_find_save_locs(struct dwarf_cursor *c);
// _Ux86_64_dwarf_find_unwind_table
// file dwarf/Gfind_unwind_table.c line 38
extern signed int _Ux86_64_dwarf_find_unwind_table(struct elf_dyn_info *edi, struct unw_addr_space *as, char *path, unsigned long int segbase, unsigned long int mapoff, unsigned long int ip);
// _Ux86_64_dwarf_init
// file ../include/dwarf.h line 377
extern signed int _Ux86_64_dwarf_init(void);
// _Ux86_64_dwarf_make_proc_info
// file ../include/dwarf.h line 411
extern signed int _Ux86_64_dwarf_make_proc_info(struct dwarf_cursor *c);
// _Ux86_64_dwarf_put_unwind_info
// file dwarf/Gfind_proc_info-lsb.c line 928
extern void _Ux86_64_dwarf_put_unwind_info(struct unw_addr_space *as, struct unw_proc_info *pi, void *arg);
// _Ux86_64_dwarf_read_encoded_pointer
// file ../include/dwarf.h line 412
extern signed int _Ux86_64_dwarf_read_encoded_pointer(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned char encoding, const struct unw_proc_info *pi, unsigned long int *valp, void *arg);
// _Ux86_64_dwarf_search_unwind_table
// file ../include/dwarf.h line 388
extern signed int _Ux86_64_dwarf_search_unwind_table(struct unw_addr_space *as, unsigned long int ip, struct unw_dyn_info *di, struct unw_proc_info *pi, signed int need_unwind_info, void *arg);
// _Ux86_64_dwarf_step
// file ../include/dwarf.h line 418
extern signed int _Ux86_64_dwarf_step(struct dwarf_cursor *c);
// _Ux86_64_fetch_frame
// file x86_64/Gos-linux.c line 34
extern void _Ux86_64_fetch_frame(struct dwarf_cursor *dw, unsigned long int ip, signed int need_unwind_info);
// _Ux86_64_flush_cache
// file mi/flush_cache.c line 29
extern void _Ux86_64_flush_cache(struct unw_addr_space *as, unsigned long int lo, unsigned long int hi);
// _Ux86_64_get_accessors
// file ../include/libunwind-common.h line 234
extern struct unw_accessors * _Ux86_64_get_accessors(struct unw_addr_space *as);
// _Ux86_64_get_elf_image
// file os-linux.c line 33
extern signed int _Ux86_64_get_elf_image(struct elf_image *ei, signed int pid, unsigned long int ip, unsigned long int *segbase, unsigned long int *mapoff, char *path, unsigned long int pathlen);
// _Ux86_64_get_fpreg
// file mi/Gget_fpreg.c line 29
extern signed int _Ux86_64_get_fpreg(struct unw_cursor *cursor, signed int regnum, long double *valp);
// _Ux86_64_get_proc_info
// file x86_64/Gget_proc_info.c line 31
extern signed int _Ux86_64_get_proc_info(struct unw_cursor *cursor, struct unw_proc_info *pi);
// _Ux86_64_get_proc_info_by_ip
// file mi/Gget_proc_info_by_ip.c line 29
extern signed int _Ux86_64_get_proc_info_by_ip(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, void *as_arg);
// _Ux86_64_get_proc_name
// file mi/Gget_proc_name.c line 99
extern signed int _Ux86_64_get_proc_name(struct unw_cursor *cursor, char *buf, unsigned long int buf_len, unsigned long int *offp);
// _Ux86_64_get_reg
// file ../include/libunwind-common.h line 246
extern signed int _Ux86_64_get_reg(struct unw_cursor *cursor, signed int regnum, unsigned long int *valp);
// _Ux86_64_get_save_loc
// file x86_64/Gget_save_loc.c line 31
extern signed int _Ux86_64_get_save_loc(struct unw_cursor *cursor, signed int reg, struct unw_save_loc *sloc);
// _Ux86_64_getcontext
// file ../include/libunwind-x86_64.h line 132
extern signed int _Ux86_64_getcontext(struct ucontext *);
// _Ux86_64_handle_signal_frame
// file x86_64/Gos-linux.c line 89
extern signed int _Ux86_64_handle_signal_frame(struct unw_cursor *cursor);
// _Ux86_64_init
// file ../include/tdep-x86_64/libunwind_i.h line 225
extern void _Ux86_64_init(void);
// _Ux86_64_init_local
// file ../include/libunwind-common.h line 239
extern signed int _Ux86_64_init_local(struct unw_cursor *cursor, struct ucontext *uc);
// _Ux86_64_init_mem_validate
// file ../include/tdep-x86_64/libunwind_i.h line 226
extern void _Ux86_64_init_mem_validate(void);
// _Ux86_64_init_remote
// file x86_64/Ginit_remote.c line 32
extern signed int _Ux86_64_init_remote(struct unw_cursor *cursor, struct unw_addr_space *as, void *as_arg);
// _Ux86_64_is_fpreg
// file x86_64/is_fpreg.c line 31
extern signed int _Ux86_64_is_fpreg(signed int regnum);
// _Ux86_64_is_signal_frame
// file x86_64/Gos-linux.c line 82
extern signed int _Ux86_64_is_signal_frame(struct unw_cursor *cursor);
// _Ux86_64_local_addr_space_init
// file x86_64/unwind_i.h line 79
extern void _Ux86_64_local_addr_space_init(void);
// _Ux86_64_local_resume
// file x86_64/Gresume.c line 36
inline signed int _Ux86_64_local_resume(struct unw_addr_space *as, struct unw_cursor *cursor, void *arg);
// _Ux86_64_r_uc_addr
// file x86_64/Gos-linux.c line 106
extern void * _Ux86_64_r_uc_addr(struct ucontext *uc, signed int reg);
// _Ux86_64_regname
// file x86_64/regname.c line 50
extern const char * _Ux86_64_regname(signed int reg);
// _Ux86_64_resume
// file x86_64/Gresume.c line 102
extern signed int _Ux86_64_resume(struct unw_cursor *cursor);
// _Ux86_64_reuse_frame
// file x86_64/Gos-linux.c line 61
extern void _Ux86_64_reuse_frame(struct dwarf_cursor *dw, struct dwarf_reg_state *rs);
// _Ux86_64_set_caching_policy
// file ../include/libunwind-common.h line 236
extern signed int _Ux86_64_set_caching_policy(struct unw_addr_space *as, enum anonymous_10 policy);
// _Ux86_64_set_fpreg
// file mi/Gset_fpreg.c line 29
extern signed int _Ux86_64_set_fpreg(struct unw_cursor *cursor, signed int regnum, long double val);
// _Ux86_64_set_reg
// file mi/Gset_reg.c line 29
extern signed int _Ux86_64_set_reg(struct unw_cursor *cursor, signed int regnum, unsigned long int valp);
// _Ux86_64_setcontext
// file x86_64/unwind_i.h line 82
extern signed int _Ux86_64_setcontext(const struct ucontext *);
// _Ux86_64_sigreturn
// file x86_64/Gos-linux.c line 139
extern void _Ux86_64_sigreturn(struct unw_cursor *cursor);
// _Ux86_64_stash_frame
// file x86_64/Gstash_frame.c line 29
extern void _Ux86_64_stash_frame(struct dwarf_cursor *d, struct dwarf_reg_state *rs);
// _Ux86_64_step
// file ../include/libunwind-common.h line 241
extern signed int _Ux86_64_step(struct unw_cursor *cursor);
// _Ux86_64_strerror
// file mi/strerror.c line 31
extern const char * _Ux86_64_strerror(signed int err_code);
// _Ux86_64_tdep_trace
// file x86_64/Gtrace.c line 397
extern signed int _Ux86_64_tdep_trace(struct unw_cursor *cursor, void **buffer, signed int *size);
// __sync_fetch_and_add
// file gcc_builtin_headers_generic.h line 93
signed int __sync_fetch_and_add();
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// access_fpreg
// file x86_64/Ginit.c line 210
static signed int access_fpreg(struct unw_addr_space *as, signed int reg, long double *val, signed int write, void *arg);
// access_mem
// file x86_64/Ginit.c line 158
static signed int access_mem(struct unw_addr_space *as, unsigned long int addr, unsigned long int *val, signed int write, void *arg);
// access_reg
// file x86_64/Ginit.c line 180
static signed int access_reg(struct unw_addr_space *as, signed int reg, unsigned long int *val, signed int write, void *arg);
// add_memory
// file mi/mempool.c line 96
static void add_memory(struct mempool *pool, char *mem, unsigned long int size, unsigned long int obj_size);
// apply_reg_state
// file dwarf/Gparser.c line 713
static signed int apply_reg_state(struct dwarf_cursor *c, struct dwarf_reg_state *rs);
// cache_match
// file dwarf/Gparser.c line 564
static inline signed long int cache_match(struct dwarf_reg_state *rs, unsigned long int ip);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// common_init
// file x86_64/init.h line 45
static inline signed int common_init(struct cursor *c, unsigned int use_prev_instr);
// common_init_link1
// file x86_64/init.h line 45
static inline signed int common_init_link1(struct cursor *c_link1, unsigned int use_prev_instr_link1);
// create_state_record_for
// file dwarf/Gparser.c line 659
static signed int create_state_record_for(struct dwarf_cursor *c, struct dwarf_state_record *sr, unsigned long int ip);
// dl_iterate_phdr
// file /usr/include/link.h line 167
extern signed int dl_iterate_phdr(signed int (*)(struct dl_phdr_info *, unsigned long int, void *), void *);
// doit
// file Gtest-concurrent.c line 84
static void doit(void);
// dwarf_get
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get(struct dwarf_cursor *c, struct dwarf_loc loc, unsigned long int *val);
// dwarf_get_link1
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link1(struct dwarf_cursor *c_link1, struct dwarf_loc loc_link1, unsigned long int *val_link1);
// dwarf_get_link2
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link2(struct dwarf_cursor *c_link2, struct dwarf_loc loc_link2, unsigned long int *val_link2);
// dwarf_get_link3
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link3(struct dwarf_cursor *c_link3, struct dwarf_loc loc_link3, unsigned long int *val_link3);
// dwarf_get_link4
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link4(struct dwarf_cursor *c_link4, struct dwarf_loc loc_link4, unsigned long int *val_link4);
// dwarf_get_link5
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link5(struct dwarf_cursor *c_link5, struct dwarf_loc loc_link5, unsigned long int *val_link5);
// dwarf_put
// file ../include/tdep-x86_64/libunwind_i.h line 167
static inline signed int dwarf_put(struct dwarf_cursor *c, struct dwarf_loc loc, unsigned long int val);
// dwarf_put_link1
// file ../include/tdep-x86_64/libunwind_i.h line 167
static inline signed int dwarf_put_link1(struct dwarf_cursor *c_link1, struct dwarf_loc loc_link1, unsigned long int val_link1);
// dwarf_read_encoded_pointer_inlined
// file ../include/dwarf_i.h line 346
static inline signed int dwarf_read_encoded_pointer_inlined(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned char encoding, const struct unw_proc_info *pi, unsigned long int *valp, void *arg);
// dwarf_read_sleb128
// file ../include/dwarf_i.h line 320
static inline signed int dwarf_read_sleb128(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg);
// dwarf_read_sleb128_link1
// file ../include/dwarf_i.h line 320
static inline signed int dwarf_read_sleb128_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *valp_link1, void *arg_link1);
// dwarf_read_sleb128_link2
// file ../include/dwarf_i.h line 320
static inline signed int dwarf_read_sleb128_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned long int *valp_link2, void *arg_link2);
// dwarf_read_uleb128
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg);
// dwarf_read_uleb128_link1
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *valp_link1, void *arg_link1);
// dwarf_read_uleb128_link2
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned long int *valp_link2, void *arg_link2);
// dwarf_read_uleb128_link3
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned long int *valp_link3, void *arg_link3);
// dwarf_reads16
// file ../include/dwarf_i.h line 222
static inline signed int dwarf_reads16(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed short int *val, void *arg);
// dwarf_reads32
// file ../include/dwarf_i.h line 235
static inline signed int dwarf_reads32(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed int *val, void *arg);
// dwarf_reads32_link1
// file ../include/dwarf_i.h line 235
static inline signed int dwarf_reads32_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, signed int *val_link1, void *arg_link1);
// dwarf_reads32_link2
// file ../include/dwarf_i.h line 235
static inline signed int dwarf_reads32_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, signed int *val_link2, void *arg_link2);
// dwarf_reads64
// file ../include/dwarf_i.h line 248
static inline signed int dwarf_reads64(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed long int *val, void *arg);
// dwarf_reads64_link1
// file ../include/dwarf_i.h line 248
static inline signed int dwarf_reads64_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, signed long int *val_link1, void *arg_link1);
// dwarf_readu16
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned short int *val, void *arg);
// dwarf_readu16_link1
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned short int *val_link1, void *arg_link1);
// dwarf_readu16_link2
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned short int *val_link2, void *arg_link2);
// dwarf_readu16_link3
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned short int *val_link3, void *arg_link3);
// dwarf_readu16_link4
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link4(struct unw_addr_space *as_link4, struct unw_accessors *a_link4, unsigned long int *addr_link4, unsigned short int *val_link4, void *arg_link4);
// dwarf_readu32
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned int *val, void *arg);
// dwarf_readu32_link1
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned int *val_link1, void *arg_link1);
// dwarf_readu32_link2
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned int *val_link2, void *arg_link2);
// dwarf_readu32_link3
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned int *val_link3, void *arg_link3);
// dwarf_readu32_link4
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link4(struct unw_addr_space *as_link4, struct unw_accessors *a_link4, unsigned long int *addr_link4, unsigned int *val_link4, void *arg_link4);
// dwarf_readu64
// file ../include/dwarf_i.h line 191
static inline signed int dwarf_readu64(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *val, void *arg);
// dwarf_readu64_link1
// file ../include/dwarf_i.h line 191
static inline signed int dwarf_readu64_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *val_link1, void *arg_link1);
// dwarf_readu64_link2
// file ../include/dwarf_i.h line 191
static inline signed int dwarf_readu64_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned long int *val_link2, void *arg_link2);
// dwarf_readu8
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned char *valp, void *arg);
// dwarf_readu8_link1
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned char *valp_link1, void *arg_link1);
// dwarf_readu8_link2
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned char *valp_link2, void *arg_link2);
// dwarf_readu8_link3
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned char *valp_link3, void *arg_link3);
// dwarf_readu8_link4
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link4(struct unw_addr_space *as_link4, struct unw_accessors *a_link4, unsigned long int *addr_link4, unsigned char *valp_link4, void *arg_link4);
// dwarf_readw
// file ../include/dwarf_i.h line 263
static inline signed int dwarf_readw(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *val, void *arg);
// dwarf_readw_link1
// file ../include/dwarf_i.h line 263
static inline signed int dwarf_readw_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *val_link1, void *arg_link1);
// elf_map_image
// file ./elfxx.h line 76
static inline signed int elf_map_image(struct elf_image *ei, const char *path);
// elf_map_image_link1
// file ./elfxx.h line 76
static inline signed int elf_map_image_link1(struct elf_image *ei_link1, const char *path_link1);
// elf_map_image_link2
// file ./elfxx.h line 76
static inline signed int elf_map_image_link2(struct elf_image *ei_link2, const char *path_link2);
// establish_machine_state
// file x86_64/Gresume.c line 67
static inline signed int establish_machine_state(struct cursor *c);
// establish_machine_state::1::access_fpreg_object
//
signed int access_fpreg_object(struct unw_addr_space *, signed int, long double *, signed int, void *);
// establish_machine_state::1::access_reg_object
//
signed int access_reg_object(struct unw_addr_space *, signed int, unsigned long int *, signed int, void *);
// eval_location_expr
// file dwarf/Gparser.c line 689
static inline signed int eval_location_expr(struct dwarf_cursor *c, struct unw_addr_space *as, struct unw_accessors *a, unsigned long int addr, struct dwarf_loc *locp, void *arg);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expand
// file mi/mempool.c line 105
static void expand(struct mempool *pool);
// fetch16
// file ../include/remote.h line 71
static inline signed int fetch16(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed short int *valp, void *arg);
// fetch32
// file ../include/remote.h line 93
static inline signed int fetch32(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed int *valp, void *arg);
// fetch8
// file ../include/remote.h line 51
static inline signed int fetch8(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed char *valp, void *arg);
// fetch8_link1
// file ../include/remote.h line 51
static inline signed int fetch8_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, signed char *valp_link1, void *arg_link1);
// fetch_proc_info
// file dwarf/Gparser.c line 389
static signed int fetch_proc_info(struct dwarf_cursor *c, unsigned long int ip, signed int need_unwind_info);
// fetchw
// file ../include/remote.h line 115
static inline signed int fetchw(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg);
// flush_rs_cache
// file dwarf/Gparser.c line 500
static inline void flush_rs_cache(struct dwarf_rs_cache *cache);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_dyn_info
// file mi/Gdyn-remote.c line 127
static void free_dyn_info(struct unw_dyn_info *di);
// free_object
// file mi/mempool.c line 86
static void free_object(struct mempool *pool, void *object);
// free_regions
// file mi/Gdyn-remote.c line 32
static void free_regions(struct unw_dyn_region_info *region);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// get_dyn_info_list_addr
// file x86_64/Ginit.c line 64
static signed int get_dyn_info_list_addr(struct unw_addr_space *as, unsigned long int *dyn_info_list_addr, void *arg);
// get_proc_name
// file mi/Gget_proc_name.c line 49
static inline signed int get_proc_name(struct unw_addr_space *as, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp, void *arg);
// get_rs_cache
// file dwarf/Gparser.c line 520
static inline struct dwarf_rs_cache * get_rs_cache(struct unw_addr_space *as, struct anonymous_8 *saved_maskp);
// get_static_proc_name
// file x86_64/Ginit.c line 243
static signed int get_static_proc_name(struct unw_addr_space *as, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp, void *arg);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// handler
// file Gtest-concurrent.c line 51
void handler(signed int sig);
// hash
// file dwarf/Gparser.c line 555
static inline unsigned char hash(unsigned long int ip);
// intern_array
// file mi/Gdyn-remote.c line 100
static signed int intern_array(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int table_len, unsigned long int **table_data, void *arg);
// intern_dyn_info
// file mi/Gdyn-remote.c line 154
static signed int intern_dyn_info(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, struct unw_dyn_info *di, void *arg);
// intern_op
// file mi/Gdyn-remote.c line 40
static signed int intern_op(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, struct unw_dyn_op *op, void *arg);
// intern_regions
// file mi/Gdyn-remote.c line 55
static signed int intern_regions(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, struct unw_dyn_region_info **regionp, void *arg);
// intern_string
// file mi/Gget_proc_name.c line 30
static inline signed int intern_string(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int addr, char *buf, unsigned long int buf_len, void *arg);
// is_cie_id
// file dwarf/Gfde.c line 29
static inline signed int is_cie_id(unsigned long int val, signed int is_debug_frame);
// is_plt_entry
// file x86_64/Gstep.c line 36
static signed int is_plt_entry(struct dwarf_cursor *c);
// labs
// file /usr/include/stdlib.h line 775
extern signed long int labs(signed long int);
// linear_search
// file dwarf/Gfind_proc_info-lsb.c line 53
static signed int linear_search(struct unw_addr_space *as, unsigned long int ip, unsigned long int eh_frame_start, unsigned long int eh_frame_end, unsigned long int fde_count, struct unw_proc_info *pi, signed int need_unwind_info, void *arg);
// local_find_proc_info
// file mi/Gfind_dynamic_proc_info.c line 40
static inline signed int local_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg);
// lookup
// file dwarf/Gfind_proc_info-lsb.c line 757
static inline struct table_entry * lookup(struct table_entry *table, unsigned long int table_size, signed int rel_ip);
// ltoa
// file os-linux.h line 41
static inline char * ltoa(char *buf, signed long int val);
// ltoa_link1
// file os-linux.h line 41
static inline char * ltoa_link1(char *buf_link1, signed long int val_link1);
// ltoa_link2
// file os-linux.h line 41
static inline char * ltoa_link2(char *buf_link2, signed long int val_link2);
// lzma_index_buffer_decode
// file /usr/include/lzma/index.h line 679
extern enum anonymous_21 lzma_index_buffer_decode(struct lzma_index_s **, unsigned long int *, struct anonymous_22 *, const unsigned char *, unsigned long int *, unsigned long int);
// lzma_index_end
// file /usr/include/lzma/index.h line 315
extern void lzma_index_end(struct lzma_index_s *, struct anonymous_22 *);
// lzma_index_size
// file /usr/include/lzma/index.h line 424
extern unsigned long int lzma_index_size(const struct lzma_index_s *);
// lzma_index_uncompressed_size
// file /usr/include/lzma/index.h line 464
extern unsigned long int lzma_index_uncompressed_size(const struct lzma_index_s *);
// lzma_stream_buffer_decode
// file /usr/include/lzma/container.h line 420
extern enum anonymous_21 lzma_stream_buffer_decode(unsigned long int *, unsigned int, struct anonymous_22 *, const unsigned char *, unsigned long int *, unsigned long int, unsigned char *, unsigned long int *, unsigned long int);
// lzma_stream_footer_decode
// file /usr/include/lzma/stream_flags.h line 201
extern enum anonymous_21 lzma_stream_footer_decode(struct anonymous_25 *, const unsigned char *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// maps_close
// file os-linux.h line 284
static inline void maps_close(struct map_iterator *mi);
// maps_close_link1
// file os-linux.h line 284
static inline void maps_close_link1(struct map_iterator *mi_link1);
// maps_close_link2
// file os-linux.h line 284
static inline void maps_close_link2(struct map_iterator *mi_link2);
// maps_init
// file os-linux.h line 66
static inline signed int maps_init(struct map_iterator *mi, signed int pid);
// maps_init_link1
// file os-linux.h line 66
static inline signed int maps_init_link1(struct map_iterator *mi_link1, signed int pid_link1);
// maps_init_link2
// file os-linux.h line 66
static inline signed int maps_init_link2(struct map_iterator *mi_link2, signed int pid_link2);
// maps_next
// file os-linux.h line 203
static inline signed int maps_next(struct map_iterator *mi, unsigned long int *low, unsigned long int *high, unsigned long int *offset);
// maps_next_link1
// file os-linux.h line 203
static inline signed int maps_next_link1(struct map_iterator *mi_link1, unsigned long int *low_link1, unsigned long int *high_link1, unsigned long int *offset_link1);
// maps_next_link2
// file os-linux.h line 203
static inline signed int maps_next_link2(struct map_iterator *mi_link2, unsigned long int *low_link2, unsigned long int *high_link2, unsigned long int *offset_link2);
// mem_validate_func_object
//
signed int mem_validate_func_object(void *, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mincore
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 123
extern signed int mincore(void *, unsigned long int, unsigned char *);
// mincore_validate
// file x86_64/Ginit.c line 81
static signed int mincore_validate(void *addr, unsigned long int len);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// msync
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 89
extern signed int msync(void *, unsigned long int, signed int);
// msync_validate
// file x86_64/Ginit.c line 75
static signed int msync_validate(void *addr, unsigned long int len);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse_cie
// file dwarf/Gfde.c line 46
static inline signed int parse_cie(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int addr, const struct unw_proc_info *pi, struct dwarf_cie_info *dci, unsigned long int base, void *arg);
// parse_dynamic
// file dwarf/Gparser.c line 450
static signed int parse_dynamic(struct dwarf_cursor *c, unsigned long int ip, struct dwarf_state_record *sr);
// parse_fde
// file dwarf/Gparser.c line 476
static inline signed int parse_fde(struct dwarf_cursor *c, unsigned long int ip, struct dwarf_state_record *sr);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_7 *, const union anonymous_0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_7 *);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// put_rs_cache
// file dwarf/Gparser.c line 544
static inline void put_rs_cache(struct unw_addr_space *as, struct dwarf_rs_cache *cache, struct anonymous_8 *saved_maskp);
// put_unwind_info
// file x86_64/Ginit.c line 58
static void put_unwind_info(struct unw_addr_space *as, struct unw_proc_info *proc_info, void *arg);
// put_unwind_info_link1
// file dwarf/Gparser.c line 461
static inline void put_unwind_info_link1(struct dwarf_cursor *c, struct unw_proc_info *pi);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_operand
// file dwarf/Gexpr.c line 124
static inline unsigned long int read_operand(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed int operand_type, unsigned long int *val, void *arg);
// read_regnum
// file dwarf/Gparser.c line 34
static inline signed int read_regnum(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg);
// remote_find_proc_info
// file mi/Gfind_dynamic_proc_info.c line 74
static inline signed int remote_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg);
// remote_lookup
// file dwarf/Gfind_proc_info-lsb.c line 788
static signed int remote_lookup(struct unw_addr_space *as, unsigned long int table, unsigned long int table_size, signed int rel_ip, struct table_entry *e, void *arg);
// rs_lookup
// file dwarf/Gparser.c line 572
static struct dwarf_reg_state * rs_lookup(struct dwarf_rs_cache *cache, struct dwarf_cursor *c);
// rs_new
// file dwarf/Gparser.c line 604
static inline struct dwarf_reg_state * rs_new(struct dwarf_rs_cache *cache, struct dwarf_cursor *c);
// run_cfi_program
// file dwarf/Gparser.c line 60
static signed int run_cfi_program(struct dwarf_cursor *c, struct dwarf_state_record *sr, unsigned long int ip, unsigned long int *addr, unsigned long int end_addr, struct dwarf_cie_info *dci);
// scan_char
// file os-linux.h line 167
static inline char * scan_char(char *cp, char *valp);
// scan_char_link1
// file os-linux.h line 167
static inline char * scan_char_link1(char *cp_link1, char *valp_link1);
// scan_char_link2
// file os-linux.h line 167
static inline char * scan_char_link2(char *cp_link2, char *valp_link2);
// scan_dec
// file os-linux.h line 140
static inline char * scan_dec(char *cp, unsigned long int *valp);
// scan_dec_link1
// file os-linux.h line 140
static inline char * scan_dec_link1(char *cp_link1, unsigned long int *valp_link1);
// scan_dec_link2
// file os-linux.h line 140
static inline char * scan_dec_link2(char *cp_link2, unsigned long int *valp_link2);
// scan_hex
// file os-linux.h line 110
static inline char * scan_hex(char *cp, unsigned long int *valp);
// scan_hex_link1
// file os-linux.h line 110
static inline char * scan_hex_link1(char *cp_link1, unsigned long int *valp_link1);
// scan_hex_link2
// file os-linux.h line 110
static inline char * scan_hex_link2(char *cp_link2, unsigned long int *valp_link2);
// scan_string
// file os-linux.h line 183
static inline char * scan_string(char *cp, char *valp, unsigned long int buf_size);
// scan_string_link1
// file os-linux.h line 183
static inline char * scan_string_link1(char *cp_link1, char *valp_link1, unsigned long int buf_size_link1);
// scan_string_link2
// file os-linux.h line 183
static inline char * scan_string_link2(char *cp_link2, char *valp_link2, unsigned long int buf_size_link2);
// set_reg
// file dwarf/Gparser.c line 51
static inline void set_reg(struct dwarf_state_record *sr, unsigned long int regnum, enum anonymous_13 where, unsigned long int val);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous_8 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_8 *, struct anonymous_8 *);
// skip_whitespace
// file os-linux.h line 99
static inline char * skip_whitespace(char *cp);
// skip_whitespace_link1
// file os-linux.h line 99
static inline char * skip_whitespace_link1(char *cp_link1);
// skip_whitespace_link2
// file os-linux.h line 99
static inline char * skip_whitespace_link2(char *cp_link2);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// sword
// file dwarf/Gexpr.c line 111
static inline signed long int sword(struct unw_addr_space *as, unsigned long int val);
// trace_cache_buckets
// file x86_64/Gtrace.c line 86
static struct anonymous_5 * trace_cache_buckets(unsigned long int n);
// trace_cache_create
// file x86_64/Gtrace.c line 103
static struct anonymous_6 * trace_cache_create(void);
// trace_cache_expand
// file x86_64/Gtrace.c line 140
static signed int trace_cache_expand(struct anonymous_6 *cache);
// trace_cache_free
// file x86_64/Gtrace.c line 58
static void trace_cache_free(void *arg);
// trace_cache_get
// file x86_64/Gtrace.c line 180
static struct anonymous_6 * trace_cache_get(void);
// trace_cache_get_unthreaded
// file x86_64/Gtrace.c line 161
static struct anonymous_6 * trace_cache_get_unthreaded(void);
// trace_cache_init_once
// file x86_64/Gtrace.c line 78
static void trace_cache_init_once(void);
// trace_init_addr
// file x86_64/Gtrace.c line 214
static struct anonymous_5 * trace_init_addr(struct anonymous_5 *f, struct unw_cursor *cursor, unsigned long int cfa, unsigned long int rip, unsigned long int rbp, unsigned long int rsp);
// trace_lookup
// file x86_64/Gtrace.c line 273
static struct anonymous_5 * trace_lookup(struct unw_cursor *cursor, struct anonymous_6 *cache, unsigned long int cfa, unsigned long int rip, unsigned long int rbp, unsigned long int rsp);
// uncached_dwarf_find_save_locs
// file dwarf/Gparser.c line 821
static signed int uncached_dwarf_find_save_locs(struct dwarf_cursor *c);
// validate_mem
// file x86_64/Ginit.c line 116
static signed int validate_mem(unsigned long int addr);
// worker
// file Gtest-concurrent.c line 73
void * worker(void *arg);
// xz_uncompressed_size
// file elfxx.c line 183
static unsigned long int xz_uncompressed_size(unsigned char *compressed, unsigned long int length);

struct anonymous_22
{
  // alloc
  void * (*alloc)(void *, unsigned long int, unsigned long int);
  // free
  void (*free)(void *, void *);
  // opaque
  void *opaque;
};

struct anonymous_6
{
  // frames
  struct anonymous_5 *frames;
  // log_size
  unsigned long int log_size;
  // used
  unsigned long int used;
  // dtor_count
  unsigned long int dtor_count;
};

struct anonymous_8
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_20
{
  // e_ident
  unsigned char e_ident[16l];
  // e_type
  unsigned short int e_type;
  // e_machine
  unsigned short int e_machine;
  // e_version
  unsigned int e_version;
  // e_entry
  unsigned long int e_entry;
  // e_phoff
  unsigned long int e_phoff;
  // e_shoff
  unsigned long int e_shoff;
  // e_flags
  unsigned int e_flags;
  // e_ehsize
  unsigned short int e_ehsize;
  // e_phentsize
  unsigned short int e_phentsize;
  // e_phnum
  unsigned short int e_phnum;
  // e_shentsize
  unsigned short int e_shentsize;
  // e_shnum
  unsigned short int e_shnum;
  // e_shstrndx
  unsigned short int e_shstrndx;
};

struct anonymous_11
{
  // gregs
  signed long long int gregs[23l];
  // fpregs
  struct _libc_fpstate *fpregs;
  // __reserved1
  unsigned long long int __reserved1[8l];
};

struct anonymous_12
{
  // where
  enum anonymous_13 where;
  // val
  unsigned long int val;
};

union anonymous_17
{
  // d_val
  unsigned long int d_val;
  // d_ptr
  unsigned long int d_ptr;
};

struct anonymous_18
{
  // d_tag
  signed long int d_tag;
  // d_un
  union anonymous_17 d_un;
};

struct anonymous_16
{
  // p_type
  unsigned int p_type;
  // p_flags
  unsigned int p_flags;
  // p_offset
  unsigned long int p_offset;
  // p_vaddr
  unsigned long int p_vaddr;
  // p_paddr
  unsigned long int p_paddr;
  // p_filesz
  unsigned long int p_filesz;
  // p_memsz
  unsigned long int p_memsz;
  // p_align
  unsigned long int p_align;
};

struct anonymous_26
{
  // sh_name
  unsigned int sh_name;
  // sh_type
  unsigned int sh_type;
  // sh_flags
  unsigned long int sh_flags;
  // sh_addr
  unsigned long int sh_addr;
  // sh_offset
  unsigned long int sh_offset;
  // sh_size
  unsigned long int sh_size;
  // sh_link
  unsigned int sh_link;
  // sh_info
  unsigned int sh_info;
  // sh_addralign
  unsigned long int sh_addralign;
  // sh_entsize
  unsigned long int sh_entsize;
};

struct anonymous
{
  // st_name
  unsigned int st_name;
  // st_info
  unsigned char st_info;
  // st_other
  unsigned char st_other;
  // st_shndx
  unsigned short int st_shndx;
  // st_value
  unsigned long int st_value;
  // st_size
  unsigned long int st_size;
};

struct anonymous_25
{
  // version
  unsigned int version;
  // backward_size
  unsigned long int backward_size;
  // check
  enum anonymous_23 check;
  // reserved_enum1
  enum anonymous_24 reserved_enum1;
  // reserved_enum2
  enum anonymous_24 reserved_enum2;
  // reserved_enum3
  enum anonymous_24 reserved_enum3;
  // reserved_enum4
  enum anonymous_24 reserved_enum4;
  // reserved_bool1
  unsigned char reserved_bool1;
  // reserved_bool2
  unsigned char reserved_bool2;
  // reserved_bool3
  unsigned char reserved_bool3;
  // reserved_bool4
  unsigned char reserved_bool4;
  // reserved_bool5
  unsigned char reserved_bool5;
  // reserved_bool6
  unsigned char reserved_bool6;
  // reserved_bool7
  unsigned char reserved_bool7;
  // reserved_bool8
  unsigned char reserved_bool8;
  // reserved_int1
  unsigned int reserved_int1;
  // reserved_int2
  unsigned int reserved_int2;
};

struct anonymous_5
{
  // virtual_address
  unsigned long int virtual_address;
  // frame_type
  signed long int frame_type : 2;
  // last_frame
  signed long int last_frame : 1;
  // cfa_reg_rsp
  signed long int cfa_reg_rsp : 1;
  // cfa_reg_offset
  signed long int cfa_reg_offset : 30;
  // rbp_cfa_offset
  signed long int rbp_cfa_offset : 15;
  // rsp_cfa_offset
  signed long int rsp_cfa_offset : 15;
};

struct anonymous_14
{
};

union anonymous_3
{
  // fpstate
  struct _fpstate *fpstate;
  // __fpstate_word
  unsigned long int __fpstate_word;
};

union anonymous_0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct unw_dyn_proc_info
{
  // name_ptr
  unsigned long int name_ptr;
  // handler
  unsigned long int handler;
  // flags
  unsigned int flags;
  // pad0
  signed int pad0;
  // regions
  struct unw_dyn_region_info *regions;
};

struct unw_dyn_table_info
{
  // name_ptr
  unsigned long int name_ptr;
  // segbase
  unsigned long int segbase;
  // table_len
  unsigned long int table_len;
  // table_data
  unsigned long int *table_data;
};

struct unw_dyn_remote_table_info
{
  // name_ptr
  unsigned long int name_ptr;
  // segbase
  unsigned long int segbase;
  // table_len
  unsigned long int table_len;
  // table_data
  unsigned long int table_data;
};

union anonymous_19
{
  // pi
  struct unw_dyn_proc_info pi;
  // ti
  struct unw_dyn_table_info ti;
  // rti
  struct unw_dyn_remote_table_info rti;
};

union anonymous_4
{
  // addr
  unsigned long int addr;
  // regnum
  signed int regnum;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _fpxreg
{
  // significand
  unsigned short int significand[4l];
  // exponent
  unsigned short int exponent;
  // padding
  unsigned short int padding[3l];
};

struct _xmmreg
{
  // element
  unsigned int element[4l];
};

struct _fpstate
{
  // cwd
  unsigned short int cwd;
  // swd
  unsigned short int swd;
  // ftw
  unsigned short int ftw;
  // fop
  unsigned short int fop;
  // rip
  unsigned long int rip;
  // rdp
  unsigned long int rdp;
  // mxcsr
  unsigned int mxcsr;
  // mxcr_mask
  unsigned int mxcr_mask;
  // _st
  struct _fpxreg _st[8l];
  // _xmm
  struct _xmmreg _xmm[16l];
  // padding
  unsigned int padding[24l];
};

struct _libc_fpxreg
{
  // significand
  unsigned short int significand[4l];
  // exponent
  unsigned short int exponent;
  // padding
  unsigned short int padding[3l];
};

struct _libc_xmmreg
{
  // element
  unsigned int element[4l];
};

struct _libc_fpstate
{
  // cwd
  unsigned short int cwd;
  // swd
  unsigned short int swd;
  // ftw
  unsigned short int ftw;
  // fop
  unsigned short int fop;
  // rip
  unsigned long int rip;
  // rdp
  unsigned long int rdp;
  // mxcsr
  unsigned int mxcsr;
  // mxcr_mask
  unsigned int mxcr_mask;
  // _st
  struct _libc_fpxreg _st[8l];
  // _xmm
  struct _libc_xmmreg _xmm[16l];
  // padding
  unsigned int padding[24l];
};

struct dwarf_loc
{
  // val
  unsigned long int val;
  // type
  unsigned long int type;
};

struct unw_proc_info
{
  // start_ip
  unsigned long int start_ip;
  // end_ip
  unsigned long int end_ip;
  // lsda
  unsigned long int lsda;
  // handler
  unsigned long int handler;
  // gp
  unsigned long int gp;
  // flags
  unsigned long int flags;
  // format
  signed int format;
  // unwind_info_size
  signed int unwind_info_size;
  // unwind_info
  void *unwind_info;
  // extra
  struct anonymous_14 extra;
};

struct dwarf_cursor
{
  // as_arg
  void *as_arg;
  // as
  struct unw_addr_space *as;
  // cfa
  unsigned long int cfa;
  // ip
  unsigned long int ip;
  // args_size
  unsigned long int args_size;
  // ret_addr_column
  unsigned long int ret_addr_column;
  // eh_args
  unsigned long int eh_args[2l];
  // eh_valid_mask
  unsigned int eh_valid_mask;
  // loc
  struct dwarf_loc loc[17l];
  // stash_frames
  unsigned int stash_frames : 1;
  // use_prev_instr
  unsigned int use_prev_instr : 1;
  // pi_valid
  unsigned int pi_valid : 1;
  // pi_is_dynamic
  unsigned int pi_is_dynamic : 1;
  // pi
  struct unw_proc_info pi;
  // hint
  signed short int hint;
  // prev_rs
  signed short int prev_rs;
};

struct cursor
{
  // dwarf
  struct dwarf_cursor dwarf;
  // frame_info
  struct anonymous_5 frame_info;
  // sigcontext_format
  enum anonymous_2 sigcontext_format;
  // sigcontext_addr
  unsigned long int sigcontext_addr;
  // validate
  signed int validate;
  // uc
  struct ucontext *uc;
};

struct dl_phdr_info
{
  // dlpi_addr
  unsigned long int dlpi_addr;
  // dlpi_name
  const char *dlpi_name;
  // dlpi_phdr
  const struct anonymous_16 *dlpi_phdr;
  // dlpi_phnum
  unsigned short int dlpi_phnum;
  // dlpi_adds
  unsigned long long int dlpi_adds;
  // dlpi_subs
  unsigned long long int dlpi_subs;
  // dlpi_tls_modid
  unsigned long int dlpi_tls_modid;
  // dlpi_tls_data
  void *dlpi_tls_data;
};

struct unw_dyn_info
{
  // next
  struct unw_dyn_info *next;
  // prev
  struct unw_dyn_info *prev;
  // start_ip
  unsigned long int start_ip;
  // end_ip
  unsigned long int end_ip;
  // gp
  unsigned long int gp;
  // format
  signed int format;
  // pad
  signed int pad;
  // u
  union anonymous_19 u;
};

struct dwarf_callback_data
{
  // ip
  unsigned long int ip;
  // pi
  struct unw_proc_info *pi;
  // need_unwind_info
  signed int need_unwind_info;
  // single_fde
  signed int single_fde;
  // di
  struct unw_dyn_info di;
  // di_debug
  struct unw_dyn_info di_debug;
};

struct dwarf_cie_info
{
  // cie_instr_start
  unsigned long int cie_instr_start;
  // cie_instr_end
  unsigned long int cie_instr_end;
  // fde_instr_start
  unsigned long int fde_instr_start;
  // fde_instr_end
  unsigned long int fde_instr_end;
  // code_align
  unsigned long int code_align;
  // data_align
  unsigned long int data_align;
  // ret_addr_column
  unsigned long int ret_addr_column;
  // handler
  unsigned long int handler;
  // abi
  unsigned short int abi;
  // tag
  unsigned short int tag;
  // fde_encoding
  unsigned char fde_encoding;
  // lsda_encoding
  unsigned char lsda_encoding;
  // sized_augmentation
  unsigned int sized_augmentation : 1;
  // have_abi_marker
  unsigned int have_abi_marker : 1;
  // signal_frame
  unsigned int signal_frame : 1;
};

struct dwarf_eh_frame_hdr
{
  // version
  unsigned char version;
  // eh_frame_ptr_enc
  unsigned char eh_frame_ptr_enc;
  // fde_count_enc
  unsigned char fde_count_enc;
  // table_enc
  unsigned char table_enc;
};

struct dwarf_reg_state
{
  // next
  struct dwarf_reg_state *next;
  // reg
  struct anonymous_12 reg[19l];
  // ip
  unsigned long int ip;
  // ret_addr_column
  unsigned long int ret_addr_column;
  // lru_chain
  unsigned short int lru_chain;
  // coll_chain
  unsigned short int coll_chain;
  // hint
  unsigned short int hint;
  // valid
  unsigned short int valid : 1;
  // signal_frame
  unsigned short int signal_frame : 1;
};

struct dwarf_rs_cache
{
  // lock
  union anonymous_7 lock;
  // lru_head
  unsigned short int lru_head;
  // lru_tail
  unsigned short int lru_tail;
  // hash
  unsigned short int hash[256l];
  // generation
  unsigned int generation;
  // buckets
  struct dwarf_reg_state buckets[128l];
};

struct dwarf_state_record
{
  // fde_encoding
  unsigned char fde_encoding;
  // args_size
  unsigned long int args_size;
  // rs_initial
  struct dwarf_reg_state rs_initial;
  // rs_current
  struct dwarf_reg_state rs_current;
};

struct elf_image
{
  // image
  void *image;
  // size
  unsigned long int size;
};

struct elf_dyn_info
{
  // ei
  struct elf_image ei;
  // di_cache
  struct unw_dyn_info di_cache;
  // di_debug
  struct unw_dyn_info di_debug;
};

struct map_iterator
{
  // offset
  signed long int offset;
  // fd
  signed int fd;
  // buf_size
  unsigned long int buf_size;
  // buf
  char *buf;
  // buf_end
  char *buf_end;
  // path
  char *path;
};

struct mempool
{
  // lock
  union anonymous_7 lock;
  // obj_size
  unsigned long int obj_size;
  // chunk_size
  unsigned long int chunk_size;
  // reserve
  unsigned int reserve;
  // num_free
  unsigned int num_free;
  // free_list
  struct object *free_list;
};

struct object
{
  // next
  struct object *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaltstack
{
  // ss_sp
  void *ss_sp;
  // ss_flags
  signed int ss_flags;
  // ss_size
  unsigned long int ss_size;
};

struct sigcontext
{
  // r8
  unsigned long int r8;
  // r9
  unsigned long int r9;
  // r10
  unsigned long int r10;
  // r11
  unsigned long int r11;
  // r12
  unsigned long int r12;
  // r13
  unsigned long int r13;
  // r14
  unsigned long int r14;
  // r15
  unsigned long int r15;
  // rdi
  unsigned long int rdi;
  // rsi
  unsigned long int rsi;
  // rbp
  unsigned long int rbp;
  // rbx
  unsigned long int rbx;
  // rdx
  unsigned long int rdx;
  // rax
  unsigned long int rax;
  // rcx
  unsigned long int rcx;
  // rsp
  unsigned long int rsp;
  // rip
  unsigned long int rip;
  // eflags
  unsigned long int eflags;
  // cs
  unsigned short int cs;
  // gs
  unsigned short int gs;
  // fs
  unsigned short int fs;
  // __pad0
  unsigned short int __pad0;
  // err
  unsigned long int err;
  // trapno
  unsigned long int trapno;
  // oldmask
  unsigned long int oldmask;
  // cr2
  unsigned long int cr2;
  // _anon0
  union anonymous_3 _anon0;
  // __reserved1
  unsigned long int __reserved1[8l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct table_entry
{
  // start_ip_offset
  signed int start_ip_offset;
  // fde_offset
  signed int fde_offset;
};

struct ucontext
{
  // uc_flags
  unsigned long int uc_flags;
  // uc_link
  struct ucontext *uc_link;
  // uc_stack
  struct sigaltstack uc_stack;
  // uc_mcontext
  struct anonymous_11 uc_mcontext;
  // uc_sigmask
  struct anonymous_8 uc_sigmask;
  // __fpregs_mem
  struct _libc_fpstate __fpregs_mem;
};

struct unw_accessors
{
  // find_proc_info
  signed int (*find_proc_info)(struct unw_addr_space *, unsigned long int, struct unw_proc_info *, signed int, void *);
  // put_unwind_info
  void (*put_unwind_info)(struct unw_addr_space *, struct unw_proc_info *, void *);
  // get_dyn_info_list_addr
  signed int (*get_dyn_info_list_addr)(struct unw_addr_space *, unsigned long int *, void *);
  // access_mem
  signed int (*access_mem)(struct unw_addr_space *, unsigned long int, unsigned long int *, signed int, void *);
  // access_reg
  signed int (*access_reg)(struct unw_addr_space *, signed int, unsigned long int *, signed int, void *);
  // access_fpreg
  signed int (*access_fpreg)(struct unw_addr_space *, signed int, long double *, signed int, void *);
  // resume
  signed int (*resume)(struct unw_addr_space *, struct unw_cursor *, void *);
  // get_proc_name
  signed int (*get_proc_name)(struct unw_addr_space *, unsigned long int, char *, unsigned long int, unsigned long int *, void *);
};

struct unw_addr_space
{
  // acc
  struct unw_accessors acc;
  // caching_policy
  enum anonymous_10 caching_policy;
  // cache_generation
  unsigned int cache_generation;
  // dyn_generation
  unsigned long int dyn_generation;
  // dyn_info_list_addr
  unsigned long int dyn_info_list_addr;
  // global_cache
  struct dwarf_rs_cache global_cache;
  // debug_frames
  struct unw_debug_frame_list *debug_frames;
};

struct unw_cursor
{
  // opaque
  unsigned long int opaque[127l];
};

struct unw_debug_frame_list
{
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // debug_frame
  char *debug_frame;
  // debug_frame_size
  unsigned long int debug_frame_size;
  // index
  struct table_entry *index;
  // index_size
  unsigned long int index_size;
  // next
  struct unw_debug_frame_list *next;
};

struct unw_dyn_info_list
{
  // version
  unsigned int version;
  // generation
  unsigned int generation;
  // first
  struct unw_dyn_info *first;
};

struct unw_dyn_op
{
  // tag
  signed char tag;
  // qp
  signed char qp;
  // reg
  signed short int reg;
  // when
  signed int when;
  // val
  unsigned long int val;
};

struct unw_dyn_region_info
{
  // next
  struct unw_dyn_region_info *next;
  // insn_count
  signed int insn_count;
  // op_count
  unsigned int op_count;
  // op
  struct unw_dyn_op op[1l];
};

struct unw_tdep_save_loc
{
};

struct unw_save_loc
{
  // type
  enum unw_save_loc_type type;
  // u
  union anonymous_4 u;
  // extra
  struct unw_tdep_save_loc extra;
};


// _UIx86_64_full_mask
// file mi/init.c line 28
struct anonymous_8 _UIx86_64_full_mask;
// _U_dyn_info_list
// file x86_64/Ginit.c line 50
struct unw_dyn_info_list _U_dyn_info_list;
// _Ux86_64_dwarf_to_unw_regnum_map
// file x86_64/Gglobal.c line 37
const unsigned char _Ux86_64_dwarf_to_unw_regnum_map[17l] = { (const unsigned char)0, (const unsigned char)1, (const unsigned char)2, (const unsigned char)3, (const unsigned char)4, (const unsigned char)5, (const unsigned char)6, (const unsigned char)7, (const unsigned char)8, (const unsigned char)9, (const unsigned char)10, (const unsigned char)11, (const unsigned char)12, (const unsigned char)13, (const unsigned char)14, (const unsigned char)15, (const unsigned char)16 };
// _Ux86_64_init_done
// file x86_64/Gglobal.c line 33
signed int _Ux86_64_init_done;
// _Ux86_64_local_addr_space
// file x86_64/Ginit.c line 48
struct unw_addr_space *_Ux86_64_local_addr_space;
// local_addr_space
// file x86_64/Ginit.c line 46
static struct unw_addr_space local_addr_space;
// _Ux86_64_local_addr_space
// file x86_64/Ginit.c line 48
struct unw_addr_space *_Ux86_64_local_addr_space = &local_addr_space;
// _Ux86_64_lock
// file x86_64/Gglobal.c line 32
union anonymous_7 _Ux86_64_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// dwarf_cie_info_pool
// file dwarf/global.c line 29
struct mempool dwarf_cie_info_pool;
// dwarf_reg_state_pool
// file dwarf/global.c line 28
struct mempool dwarf_reg_state_pool;
// empty_frame
// file x86_64/Gtrace.c line 47
static const struct anonymous_5 empty_frame = { .virtual_address=(unsigned long int)0, .frame_type=0,
    .last_frame=-1, .cfa_reg_rsp=-1, .cfa_reg_offset=0,
    .rbp_cfa_offset=-1, .rsp_cfa_offset=-1 };
// got_usr1
// file Gtest-concurrent.c line 47
signed int got_usr1;
// got_usr2
// file Gtest-concurrent.c line 47
signed int got_usr2;
// last_good_addr
// file x86_64/Ginit.c line 112
static unsigned long int last_good_addr[4l];
// lga_victim
// file x86_64/Ginit.c line 113
static signed int lga_victim;
// mem_validate_func
// file x86_64/Ginit.c line 74
static signed int (*mem_validate_func)(void *, unsigned long int);
// nerrors
// file Gtest-concurrent.c line 46
signed int nerrors;
// operands
// file dwarf/Gexpr.c line 52
static const unsigned char operands[256l] = { 0, 0, 0, (const unsigned char)(1 << 6 | 0x7 << 3 | 0 << 0),
    0, 0, 0, 0, (const unsigned char)(1 << 6 | 0x0 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x0 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x1 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x1 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x2 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x2 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x3 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x3 << 3 | 0 << 0),
    0, 0, 0, 0, 0, (const unsigned char)(1 << 6 | 0x0 << 3 | 0 << 0),
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (const unsigned char)(1 << 6 | 0x4 << 3 | 0 << 0),
    0, 0, 0, 0, (const unsigned char)(1 << 6 | 0x1 << 3 | 0 << 0),
    0, 0, 0, 0, 0, 0, (const unsigned char)(1 << 6 | 0x1 << 3 | 0 << 0),
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x4 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x5 << 3 | 0 << 0),
    (const unsigned char)(2 << 6 | 0x4 << 3 | 0x5 << 0),
    (const unsigned char)(1 << 6 | 0x4 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x0 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x0 << 3 | 0 << 0),
    0, 0, (const unsigned char)(1 << 6 | 0x1 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x2 << 3 | 0 << 0),
    (const unsigned char)(1 << 6 | 0x6 << 3 | 0 << 0),
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// pg_size
// file mi/mempool.c line 44
static unsigned long int pg_size;
// regname
// file x86_64/regname.c line 28
static const char *regname[17l] = { "RAX", "RDX", "RCX", "RBX", "RSI", "RDI", "RBP", "RSP", "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15", "RIP" };
// sigusr1_sp
// file Gtest-concurrent.c line 48
char *sigusr1_sp;
// sos_memory
// file mi/mempool.c line 42
static char sos_memory[16384l];
// sos_memory_freepos
// file mi/mempool.c line 43
static unsigned long int sos_memory_freepos;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// tls_cache
// file x86_64/Gtrace.c line 53
static struct anonymous_6 *tls_cache;
// tls_cache_destroyed
// file x86_64/Gtrace.c line 54
static signed int tls_cache_destroyed;
// trace_cache_key
// file x86_64/Gtrace.c line 51
static unsigned int trace_cache_key;
// trace_cache_once
// file x86_64/Gtrace.c line 49
static signed int trace_cache_once = 0;
// trace_cache_once_happen
// file x86_64/Gtrace.c line 50
static signed int trace_cache_once_happen;
// trace_cache_pool
// file x86_64/Gtrace.c line 52
static struct mempool trace_cache_pool;
// trace_init_lock
// file x86_64/Gtrace.c line 48
static union anonymous_7 trace_init_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// verbose
// file Gtest-concurrent.c line 45
signed int verbose;

// _UIx86_64__mempool_alloc
// file mi/mempool.c line 154
extern void * _UIx86_64__mempool_alloc(struct mempool *pool)
{
  struct anonymous_8 saved_mask;
  struct object *obj;
  do
  {
    sigprocmask(2, &_UIx86_64_full_mask, &saved_mask);
    pthread_mutex_lock(&pool->lock);
  }
  while((_Bool)0);
  if(pool->reserve >= pool->num_free)
    expand(pool);

  pool->num_free = pool->num_free - 1u;
  obj = pool->free_list;
  pool->free_list = obj->next;
  do
  {
    pthread_mutex_unlock(&pool->lock);
    sigprocmask(2, &saved_mask, (struct anonymous_8 *)(void *)0);
  }
  while((_Bool)0);
  return (void *)obj;
}

// _UIx86_64__mempool_free
// file mi/mempool.c line 175
extern void _UIx86_64__mempool_free(struct mempool *pool, void *object)
{
  struct anonymous_8 saved_mask;
  do
  {
    sigprocmask(2, &_UIx86_64_full_mask, &saved_mask);
    pthread_mutex_lock(&pool->lock);
  }
  while((_Bool)0);
  free_object(pool, object);
  do
  {
    pthread_mutex_unlock(&pool->lock);
    sigprocmask(2, &saved_mask, (struct anonymous_8 *)(void *)0);
  }
  while((_Bool)0);
}

// _UIx86_64__mempool_init
// file mi/mempool.c line 127
extern void _UIx86_64__mempool_init(struct mempool *pool, unsigned long int obj_size, unsigned long int reserve)
{
  signed int return_value_getpagesize_1;
  if(pg_size == 0ul)
  {
    return_value_getpagesize_1=getpagesize();
    pg_size = (unsigned long int)return_value_getpagesize_1;
  }

  memset((void *)pool, 0, sizeof(struct mempool) /*72ul*/ );
  pthread_mutex_init(&pool->lock, (const union anonymous_0 *)(void *)0);
  obj_size = (obj_size + (unsigned long int)16) - 1UL & ~((unsigned long int)16 - 1UL);
  if(reserve == 0ul)
  {
    reserve = (pg_size / obj_size) / (unsigned long int)4;
    if(reserve == 0ul)
      reserve = (unsigned long int)16;

  }

  pool->obj_size = obj_size;
  pool->reserve = (unsigned int)reserve;
  pool->chunk_size = ((unsigned long int)2 * reserve * obj_size + pg_size) - 1UL & ~(pg_size - 1UL);
  expand(pool);
}

// _UIx86_64__sos_alloc
// file mi/mempool.c line 47
extern void * _UIx86_64__sos_alloc(unsigned long int size)
{
  unsigned long int pos;
  size = (size + (unsigned long int)16) - 1UL & ~((unsigned long int)16 - 1UL);
  __CPROVER_atomic_begin();
  pos = *(&sos_memory_freepos);
  *(&sos_memory_freepos) = *(&sos_memory_freepos) + size;
  FENCE(WRfence);
  __CPROVER_atomic_end();
  return (void *)&sos_memory[(signed long int)pos];
}

// _UIx86_64_mi_init
// file mi/init.c line 44
extern void _UIx86_64_mi_init(void)
{
  ;
}

// _Uelf64_extract_minidebuginfo
// file elfxx.c line 215
static signed int _Uelf64_extract_minidebuginfo(struct elf_image *ei, struct elf_image *mdi)
{
  struct anonymous_20 *ehdr = (struct anonymous_20 *)ei->image;
  struct anonymous_26 *shdr;
  char *strtab;
  signed int i;
  unsigned char *compressed = (unsigned char *)(void *)0;
  unsigned long int memlimit = 18446744073709551615UL;
  unsigned long int compressed_len;
  unsigned long int uncompressed_len;
  signed int return_value__Uelf64_valid_object_1;
  return_value__Uelf64_valid_object_1=_Uelf64_valid_object_link2(ei);
  if(return_value__Uelf64_valid_object_1 == 0)
    return 0;

  else
  {
    shdr=_Uelf64_section_table(ei);
    if(shdr == ((struct anonymous_26 *)NULL))
      return 0;

    else
    {
      strtab=_Uelf64_string_table(ei, (signed int)ehdr->e_shstrndx);
      if(strtab == ((char *)NULL))
        return 0;

      else
      {
        i = 0;
        for( ; !(i >= (signed int)ehdr->e_shnum); i = i + 1)
        {
          signed int return_value_strcmp_2;
          return_value_strcmp_2=strcmp(strtab + (signed long int)shdr->sh_name, ".gnu_debugdata");
          if(return_value_strcmp_2 == 0)
          {
            if(!(ei->size >= shdr->sh_offset + shdr->sh_size))
              return 0;

            compressed = (unsigned char *)ei->image + (signed long int)shdr->sh_offset;
            compressed_len = shdr->sh_size;
            break;
          }

          shdr = (struct anonymous_26 *)((char *)shdr + (signed long int)ehdr->e_shentsize);
        }
        if(compressed == ((unsigned char *)NULL))
          return 0;

        else
        {
          uncompressed_len=xz_uncompressed_size(compressed, compressed_len);
          if(uncompressed_len == 0ul)
            return 0;

          else
          {
            mdi->size = uncompressed_len;
            mdi->image=mmap((void *)0, uncompressed_len, 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
            if(mdi->image == (void *)-1)
              return 0;

            else
            {
              unsigned long int in_pos = (unsigned long int)0;
              unsigned long int out_pos = (unsigned long int)0;
              enum anonymous_21 lret;
              lret=lzma_stream_buffer_decode(&memlimit, (unsigned int)0, (struct anonymous_22 *)(void *)0, compressed, &in_pos, compressed_len, (unsigned char *)mdi->image, &out_pos, mdi->size);
              if(!((signed int)lret == LZMA_OK))
              {
                munmap(mdi->image, mdi->size);
                return 0;
              }

              else
                return 1;
            }
          }
        }
      }
    }
  }
}

// _Uelf64_get_load_offset
// file elfxx.c line 160
static unsigned long int _Uelf64_get_load_offset(struct elf_image *ei, unsigned long int segbase, unsigned long int mapoff)
{
  unsigned long int offset = (unsigned long int)0;
  struct anonymous_20 *ehdr;
  struct anonymous_16 *phdr;
  signed int i;
  ehdr = (struct anonymous_20 *)ei->image;
  phdr = (struct anonymous_16 *)((char *)ei->image + (signed long int)ehdr->e_phoff);
  i = 0;
  for( ; !(i >= (signed int)ehdr->e_phnum); i = i + 1)
    if((phdr + (signed long int)i)->p_type == 1u)
    {
      if((phdr + (signed long int)i)->p_offset == mapoff)
      {
        offset = segbase - (phdr + (signed long int)i)->p_vaddr;
        break;
      }

    }

  return offset;
}

// _Uelf64_get_proc_name
// file ./elfxx.h line 46
extern signed int _Uelf64_get_proc_name(struct unw_addr_space *as, signed int pid, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp)
{
  unsigned long int segbase;
  unsigned long int mapoff;
  struct elf_image ei;
  signed int ret;
  ret=_Ux86_64_get_elf_image(&ei, pid, ip, &segbase, &mapoff, (char *)(void *)0, (unsigned long int)0);
  if(!(ret >= 0))
    return ret;

  else
  {
    ret=_Uelf64_get_proc_name_in_image(as, &ei, segbase, mapoff, ip, buf, buf_len, offp);
    munmap(ei.image, ei.size);
    ei.image = (void *)0;
    return ret;
  }
}

// _Uelf64_get_proc_name_in_image
// file elfxx.c line 304
extern signed int _Uelf64_get_proc_name_in_image(struct unw_addr_space *as, struct elf_image *ei, unsigned long int segbase, unsigned long int mapoff, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp)
{
  unsigned long int load_offset;
  unsigned long int min_dist = ~((unsigned long int)0);
  signed int ret;
  load_offset=_Uelf64_get_load_offset(ei, segbase, mapoff);
  ret=_Uelf64_lookup_symbol(as, ip, ei, load_offset, buf, buf_len, &min_dist);
  struct elf_image mdi;
  signed int return_value__Uelf64_extract_minidebuginfo_1;
  return_value__Uelf64_extract_minidebuginfo_1=_Uelf64_extract_minidebuginfo(ei, &mdi);
  if(!(return_value__Uelf64_extract_minidebuginfo_1 == 0))
  {
    signed int ret_mdi;
    load_offset=_Uelf64_get_load_offset(&mdi, segbase, mapoff);
    ret_mdi=_Uelf64_lookup_symbol(as, ip, &mdi, load_offset, buf, buf_len, &min_dist);
    if(ret_mdi == 0 || ret_mdi == -2)
      ret = ret_mdi;

    munmap(mdi.image, mdi.size);
  }

  if(min_dist >= ei->size)
    return -UNW_ENOINFO;

  else
  {
    if(!(offp == ((unsigned long int *)NULL)))
      *offp = min_dist;

    return ret;
  }
}

// _Uelf64_lookup_symbol
// file elfxx.c line 87
static signed int _Uelf64_lookup_symbol(struct unw_addr_space *as, unsigned long int ip, struct elf_image *ei, unsigned long int load_offset, char *buf, unsigned long int buf_len, unsigned long int *min_dist)
{
  unsigned long int syment_size;
  struct anonymous_20 *ehdr = (struct anonymous_20 *)ei->image;
  struct anonymous *sym;
  struct anonymous *symtab;
  struct anonymous *symtab_end;
  struct anonymous_26 *shdr;
  unsigned long int val;
  signed int i;
  signed int ret = -UNW_ENOINFO;
  char *strtab;
  signed int return_value__Uelf64_valid_object_1;
  return_value__Uelf64_valid_object_1=_Uelf64_valid_object_link2(ei);
  if(return_value__Uelf64_valid_object_1 == 0)
    return -UNW_ENOINFO;

  else
  {
    shdr=_Uelf64_section_table(ei);
    if(shdr == ((struct anonymous_26 *)NULL))
      return -UNW_ENOINFO;

    else
    {
      i = 0;
      for( ; !(i >= (signed int)ehdr->e_shnum); i = i + 1)
      {
        if(shdr->sh_type == 2u || shdr->sh_type == 11u)
        {
          symtab = (struct anonymous *)((char *)ei->image + (signed long int)shdr->sh_offset);
          symtab_end = (struct anonymous *)((char *)symtab + (signed long int)shdr->sh_size);
          syment_size = shdr->sh_entsize;
          strtab=_Uelf64_string_table(ei, (signed int)shdr->sh_link);
          if(!(strtab == ((char *)NULL)))
          {
            sym = symtab;
            for( ; !(sym >= symtab_end); sym = (struct anonymous *)((char *)sym + (signed long int)syment_size))
              if((0xf & (signed int)sym->st_info) == 2)
              {
                if(!((signed int)sym->st_shndx == 0))
                {
                  val = sym->st_value;
                  if(!((signed int)sym->st_shndx == 0xfff1))
                    val = val + load_offset;

                  *(&val) = val;
                  if(!(ip + -val >= *min_dist))
                  {
                    *min_dist = (unsigned long int)(ip - val);
                    strncpy(buf, strtab + (signed long int)sym->st_name, buf_len);
                    buf[(signed long int)(buf_len - (unsigned long int)1)] = (char)0;
                    unsigned long int return_value_strlen_2;
                    return_value_strlen_2=strlen(strtab + (signed long int)sym->st_name);
                    ret = return_value_strlen_2 >= buf_len ? -UNW_ENOMEM : 0;
                  }

                }

              }

          }

        }

        shdr = (struct anonymous_26 *)((char *)shdr + (signed long int)ehdr->e_shentsize);
      }
      return ret;
    }
  }
}

// _Uelf64_section_table
// file elfxx.c line 37
static struct anonymous_26 * _Uelf64_section_table(struct elf_image *ei)
{
  struct anonymous_20 *ehdr = (struct anonymous_20 *)ei->image;
  unsigned long int soff = ehdr->e_shoff;
  if(!(ei->size >= soff + (unsigned long int)((signed int)ehdr->e_shentsize * (signed int)ehdr->e_shnum)))
    return (struct anonymous_26 *)(void *)0;

  else
    return (struct anonymous_26 *)((char *)ei->image + (signed long int)soff);
}

// _Uelf64_string_table
// file elfxx.c line 55
static char * _Uelf64_string_table(struct elf_image *ei, signed int section)
{
  struct anonymous_20 *ehdr = (struct anonymous_20 *)ei->image;
  unsigned long int soff;
  unsigned long int str_soff;
  struct anonymous_26 *str_shdr;
  soff = ehdr->e_shoff;
  str_soff = soff + (unsigned long int)(section * (signed int)ehdr->e_shentsize);
  if(!(ei->size >= str_soff + (unsigned long int)ehdr->e_shentsize))
    return (char *)(void *)0;

  else
  {
    str_shdr = (struct anonymous_26 *)((char *)ei->image + (signed long int)str_soff);
    if(!(ei->size >= str_shdr->sh_offset + str_shdr->sh_size))
      return (char *)(void *)0;

    else
      return (char *)(ei->image + (signed long int)str_shdr->sh_offset);
  }
}

// _Uelf64_valid_object
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object(struct elf_image *ei)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(ei->size >= 7ul))
    return 0;

  else
  {
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp(ei->image, (const void *)"\177ELF", (unsigned long int)4);
    if(return_value_memcmp_1 == 0)
      tmp_if_expr_2 = (signed int)((unsigned char *)ei->image)[(signed long int)4] == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (signed int)((unsigned char *)ei->image)[(signed long int)6] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (signed int)((unsigned char *)ei->image)[(signed long int)6] <= 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    return (signed int)tmp_if_expr_4;
  }
}

// _Uelf64_valid_object_link1
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object_link1(struct elf_image *ei_link1)
{
  _Bool tmp_if_expr_2_link1;
  _Bool tmp_if_expr_3_link1;
  _Bool tmp_if_expr_4_link1;
  if(!(ei_link1->size >= 7ul))
    return 0;

  else
  {
    signed int return_value_memcmp_1_link1;
    return_value_memcmp_1_link1=memcmp(ei_link1->image, (const void *)"\177ELF", (unsigned long int)4);
    if(return_value_memcmp_1_link1 == 0)
      tmp_if_expr_2_link1 = (signed int)((unsigned char *)ei_link1->image)[(signed long int)4] == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link1 = (_Bool)0;
    if(tmp_if_expr_2_link1)
      tmp_if_expr_3_link1 = (signed int)((unsigned char *)ei_link1->image)[(signed long int)6] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link1 = (_Bool)0;
    if(tmp_if_expr_3_link1)
      tmp_if_expr_4_link1 = (signed int)((unsigned char *)ei_link1->image)[(signed long int)6] <= 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4_link1 = (_Bool)0;
    return (signed int)tmp_if_expr_4_link1;
  }
}

// _Uelf64_valid_object_link2
// file elfxx.h line 64
static inline signed int _Uelf64_valid_object_link2(struct elf_image *ei_link2)
{
  _Bool tmp_if_expr_2_link2;
  _Bool tmp_if_expr_3_link2;
  _Bool tmp_if_expr_4_link2;
  if(!(ei_link2->size >= 7ul))
    return 0;

  else
  {
    signed int return_value_memcmp_1_link2;
    return_value_memcmp_1_link2=memcmp(ei_link2->image, (const void *)"\177ELF", (unsigned long int)4);
    if(return_value_memcmp_1_link2 == 0)
      tmp_if_expr_2_link2 = (signed int)((unsigned char *)ei_link2->image)[(signed long int)4] == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link2 = (_Bool)0;
    if(tmp_if_expr_2_link2)
      tmp_if_expr_3_link2 = (signed int)((unsigned char *)ei_link2->image)[(signed long int)6] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link2 = (_Bool)0;
    if(tmp_if_expr_3_link2)
      tmp_if_expr_4_link2 = (signed int)((unsigned char *)ei_link2->image)[(signed long int)6] <= 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4_link2 = (_Bool)0;
    return (signed int)tmp_if_expr_4_link2;
  }
}

// _Uelf64_valid_object_link3
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object_link3(struct elf_image *ei_link3)
{
  _Bool tmp_if_expr_2_link3;
  _Bool tmp_if_expr_3_link3;
  _Bool tmp_if_expr_4_link3;
  if(!(ei_link3->size >= 7ul))
    return 0;

  else
  {
    signed int return_value_memcmp_1_link3;
    return_value_memcmp_1_link3=memcmp(ei_link3->image, (const void *)"\177ELF", (unsigned long int)4);
    if(return_value_memcmp_1_link3 == 0)
      tmp_if_expr_2_link3 = (signed int)((unsigned char *)ei_link3->image)[(signed long int)4] == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link3 = (_Bool)0;
    if(tmp_if_expr_2_link3)
      tmp_if_expr_3_link3 = (signed int)((unsigned char *)ei_link3->image)[(signed long int)6] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link3 = (_Bool)0;
    if(tmp_if_expr_3_link3)
      tmp_if_expr_4_link3 = (signed int)((unsigned char *)ei_link3->image)[(signed long int)6] <= 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4_link3 = (_Bool)0;
    return (signed int)tmp_if_expr_4_link3;
  }
}

// _Uelf64_valid_object_link4
// file ./elfxx.h line 64
static inline signed int _Uelf64_valid_object_link4(struct elf_image *ei_link4)
{
  _Bool tmp_if_expr_2_link4;
  _Bool tmp_if_expr_3_link4;
  _Bool tmp_if_expr_4_link4;
  if(!(ei_link4->size >= 7ul))
    return 0;

  else
  {
    signed int return_value_memcmp_1_link4;
    return_value_memcmp_1_link4=memcmp(ei_link4->image, (const void *)"\177ELF", (unsigned long int)4);
    if(return_value_memcmp_1_link4 == 0)
      tmp_if_expr_2_link4 = (signed int)((unsigned char *)ei_link4->image)[(signed long int)4] == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2_link4 = (_Bool)0;
    if(tmp_if_expr_2_link4)
      tmp_if_expr_3_link4 = (signed int)((unsigned char *)ei_link4->image)[(signed long int)6] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link4 = (_Bool)0;
    if(tmp_if_expr_3_link4)
      tmp_if_expr_4_link4 = (signed int)((unsigned char *)ei_link4->image)[(signed long int)6] <= 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4_link4 = (_Bool)0;
    return (signed int)tmp_if_expr_4_link4;
  }
}

// _Ux86_64_Idyn_remote_find_proc_info
// file mi/Gdyn-remote.c line 204
extern signed int _Ux86_64_Idyn_remote_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg)
{
  struct unw_accessors *a;
  a=_Ux86_64_get_accessors(as);
  unsigned long int dyn_list_addr;
  unsigned long int addr;
  unsigned long int next_addr;
  unsigned long int gen1;
  unsigned long int gen2;
  unsigned long int start_ip;
  unsigned long int end_ip;
  struct unw_dyn_info *di = (struct unw_dyn_info *)(void *)0;
  signed int ret;
  if(!(as->dyn_info_list_addr == 0ul))
    dyn_list_addr = as->dyn_info_list_addr;

  else
  {
    signed int return_value;
    return_value=a->get_dyn_info_list_addr(as, &dyn_list_addr, arg);
    if(!(return_value >= 0))
      return -UNW_ENOINFO;

    if(!((signed int)as->caching_policy == UNW_CACHE_NONE))
      as->dyn_info_list_addr = dyn_list_addr;

  }
  _Bool tmp_if_expr_3;
  signed int return_value_fetchw_2;
  _Bool tmp_if_expr_7;
  signed int return_value_fetchw_6;
  void *return_value_calloc_8;
  _Bool tmp_if_expr_11;
  signed int return_value_fetch32_10;
  signed int return_value_intern_dyn_info_12;
  do
  {
    addr = dyn_list_addr;
    ret = -UNW_ENOINFO;
    signed int return_value_fetchw_1;
    return_value_fetchw_1=fetchw(as, a, &addr, &gen1, arg);
    if(!(return_value_fetchw_1 >= 0))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_fetchw_2=fetchw(as, a, &addr, &next_addr, arg);
      tmp_if_expr_3 = return_value_fetchw_2 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return ret;

    addr = next_addr;
    for( ; !(addr == 0ul); addr = next_addr)
    {
      signed int return_value_fetchw_4;
      return_value_fetchw_4=fetchw(as, a, &addr, &next_addr, arg);
      if(!(return_value_fetchw_4 >= 0))
        break;

      addr = addr + sizeof(unsigned long int) /*8ul*/ ;
      signed int return_value_fetchw_5;
      return_value_fetchw_5=fetchw(as, a, &addr, &start_ip, arg);
      if(!(return_value_fetchw_5 >= 0))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_fetchw_6=fetchw(as, a, &addr, &end_ip, arg);
        tmp_if_expr_7 = return_value_fetchw_6 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        break;

      if(ip >= start_ip && !(ip >= end_ip))
      {
        if(di == ((struct unw_dyn_info *)NULL))
        {
          return_value_calloc_8=calloc((unsigned long int)1, sizeof(struct unw_dyn_info) /*80ul*/ );
          di = (struct unw_dyn_info *)return_value_calloc_8;
        }

        di->start_ip = start_ip;
        di->end_ip = end_ip;
        signed int return_value_fetchw_9;
        return_value_fetchw_9=fetchw(as, a, &addr, &di->gp, arg);
        if(!(return_value_fetchw_9 >= 0))
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_fetch32_10=fetch32(as, a, &addr, &di->format, arg);
          tmp_if_expr_11 = return_value_fetch32_10 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
          break;

        addr = addr + (unsigned long int)4;
        if(!(need_unwind_info == 0))
        {
          return_value_intern_dyn_info_12=intern_dyn_info(as, a, &addr, di, arg);
          if(!(return_value_intern_dyn_info_12 >= 0))
            break;

        }

        signed int return_value__Ux86_64_Iextract_dynamic_proc_info_13;
        return_value__Ux86_64_Iextract_dynamic_proc_info_13=_Ux86_64_Iextract_dynamic_proc_info(as, ip, pi, di, need_unwind_info, arg);
        if(!(return_value__Ux86_64_Iextract_dynamic_proc_info_13 >= 0))
        {
          free_dyn_info(di);
          break;
        }

        ret = 0;
        break;
      }

    }

  recheck:
    ;
    addr = dyn_list_addr;
    signed int return_value_fetchw_14;
    return_value_fetchw_14=fetchw(as, a, &addr, &gen2, arg);
    if(!(return_value_fetchw_14 >= 0))
      return ret;

  }
  while(!(gen1 == gen2));
  if(!(di == ((struct unw_dyn_info *)NULL)) && !(ret >= 0))
    free((void *)di);

  return ret;
}

// _Ux86_64_Idyn_remote_put_unwind_info
// file mi/Gdyn-remote.c line 289
extern void _Ux86_64_Idyn_remote_put_unwind_info(struct unw_addr_space *as, struct unw_proc_info *pi, void *arg)
{
  if(!(pi->unwind_info == NULL))
  {
    free_dyn_info((struct unw_dyn_info *)pi->unwind_info);
    free(pi->unwind_info);
    pi->unwind_info = (void *)0;
  }

}

// _Ux86_64_Idyn_validate_cache
// file mi/Gdyn-remote.c line 304
extern signed int _Ux86_64_Idyn_validate_cache(struct unw_addr_space *as, void *arg)
{
  unsigned long int addr;
  unsigned long int gen;
  struct unw_accessors *a;
  if(as->dyn_info_list_addr == 0ul)
    return 0;

  else
  {
    a=_Ux86_64_get_accessors(as);
    addr = as->dyn_info_list_addr;
    signed int return_value_fetchw_1;
    return_value_fetchw_1=fetchw(as, a, &addr, &gen, arg);
    if(!(return_value_fetchw_1 >= 0))
      return 1;

    else
      if(gen == as->dyn_generation)
        return 1;

      else
      {
        _Ux86_64_flush_cache(as, (unsigned long int)0, (unsigned long int)0);
        as->dyn_generation = gen;
        return -1;
      }
  }
}

// _Ux86_64_Iextract_dynamic_proc_info
// file mi/Gdyn-extract.c line 29
extern signed int _Ux86_64_Iextract_dynamic_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, struct unw_dyn_info *di, signed int need_unwind_info, void *arg)
{
  pi->start_ip = di->start_ip;
  pi->end_ip = di->end_ip;
  pi->gp = di->gp;
  pi->format = di->format;
  signed int return_value__Ux86_64_dwarf_search_unwind_table_1;
  switch(di->format)
  {
    case 0:
    {
      pi->handler = di->u.pi.handler;
      pi->lsda = (unsigned long int)0;
      pi->flags = (unsigned long int)di->u.pi.flags;
      pi->unwind_info_size = 0;
      if(!(need_unwind_info == 0))
        pi->unwind_info = (void *)di;

      else
        pi->unwind_info = (void *)0;
      return 0;
    }
    case 1:

    case 2:
    {
      return_value__Ux86_64_dwarf_search_unwind_table_1=_Ux86_64_dwarf_search_unwind_table(as, ip, di, pi, need_unwind_info, arg);
      return return_value__Ux86_64_dwarf_search_unwind_table_1;
    }
    default:
      return -UNW_EINVAL;
  }
}

// _Ux86_64_Ifind_dynamic_proc_info
// file mi/Gfind_dynamic_proc_info.c line 83
extern signed int _Ux86_64_Ifind_dynamic_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg)
{
  signed int return_value_local_find_proc_info_1;
  signed int return_value_remote_find_proc_info_2;
  if(as == _Ux86_64_local_addr_space)
  {
    return_value_local_find_proc_info_1=local_find_proc_info(as, ip, pi, need_unwind_info, arg);
    return return_value_local_find_proc_info_1;
  }

  else
  {
    return_value_remote_find_proc_info_2=remote_find_proc_info(as, ip, pi, need_unwind_info, arg);
    return return_value_remote_find_proc_info_2;
  }
}

// _Ux86_64_Iput_dynamic_unwind_info
// file ../include/libunwind_i.h line 213
extern void _Ux86_64_Iput_dynamic_unwind_info(struct unw_addr_space *as, struct unw_proc_info *pi, void *arg)
{
  switch(pi->format)
  {
    case 0:
    {
      if(!(as == _Ux86_64_local_addr_space))
        _Ux86_64_Idyn_remote_put_unwind_info(as, pi, arg);

      break;
    }
    case 1:

    case 2:
      as->acc.put_unwind_info(as, pi, arg);
    default:
      ;
  }
}

// _Ux86_64_access_fpreg
// file ../include/tdep-x86_64/libunwind_i.h line 236
extern signed int _Ux86_64_access_fpreg(struct cursor *c, signed int reg, long double *valp, signed int write)
{
  return -UNW_EBADREG;
}

// _Ux86_64_access_reg
// file ../include/tdep-x86_64/libunwind_i.h line 234
extern signed int _Ux86_64_access_reg(struct cursor *c, signed int reg, unsigned long int *valp, signed int write)
{
  struct dwarf_loc loc = { .val=(unsigned long int)0, .type=(unsigned long int)0 };
  unsigned int mask;
  signed int arg_num;
  switch(reg)
  {
    case 16:
    {
      if(!(write == 0))
        c->dwarf.ip = *valp;

      loc = c->dwarf.loc[(signed long int)16];
      break;
    }
    case 17:

    case 7:
    {
      if(!(write == 0))
        return -UNW_EREADONLYREG;

      *valp = c->dwarf.cfa;
      return 0;
    }
    case 0:

    case 1:
    {
      arg_num = reg - 0;
      mask = (unsigned int)(1 << arg_num);
      if(!(write == 0))
      {
        c->dwarf.eh_args[(signed long int)arg_num] = *valp;
        c->dwarf.eh_valid_mask = c->dwarf.eh_valid_mask | mask;
        return 0;
      }

      else
        if(!((c->dwarf.eh_valid_mask & mask) == 0u))
        {
          *valp = c->dwarf.eh_args[(signed long int)arg_num];
          return 0;
        }

        else
          loc = c->dwarf.loc[(signed long int)(reg == 0 ? 0 : 1)];
      break;
    }
    case 2:
    {
      loc = c->dwarf.loc[(signed long int)2];
      break;
    }
    case 3:
    {
      loc = c->dwarf.loc[(signed long int)3];
      break;
    }
    case 6:
    {
      loc = c->dwarf.loc[(signed long int)6];
      break;
    }
    case 4:
    {
      loc = c->dwarf.loc[(signed long int)4];
      break;
    }
    case 5:
    {
      loc = c->dwarf.loc[(signed long int)5];
      break;
    }
    case 8:
    {
      loc = c->dwarf.loc[(signed long int)8];
      break;
    }
    case 9:
    {
      loc = c->dwarf.loc[(signed long int)9];
      break;
    }
    case 10:
    {
      loc = c->dwarf.loc[(signed long int)10];
      break;
    }
    case 11:
    {
      loc = c->dwarf.loc[(signed long int)11];
      break;
    }
    case 12:
    {
      loc = c->dwarf.loc[(signed long int)12];
      break;
    }
    case 13:
    {
      loc = c->dwarf.loc[(signed long int)13];
      break;
    }
    case 14:
    {
      loc = c->dwarf.loc[(signed long int)14];
      break;
    }
    case 15:
    {
      loc = c->dwarf.loc[(signed long int)15];
      break;
    }
    default:
      return -UNW_EBADREG;
  }
  signed int return_value_dwarf_put_1;
  signed int return_value_dwarf_get_2;
  if(!(write == 0))
  {
    return_value_dwarf_put_1=dwarf_put(&c->dwarf, loc, *valp);
    return return_value_dwarf_put_1;
  }

  else
  {
    return_value_dwarf_get_2=dwarf_get_link2(&c->dwarf, loc, valp);
    return return_value_dwarf_get_2;
  }
}

// _Ux86_64_cache_frame
// file x86_64/Gos-linux.c line 51
extern void _Ux86_64_cache_frame(struct dwarf_cursor *dw, struct dwarf_reg_state *rs)
{
  struct cursor *c = (struct cursor *)dw;
  rs->signal_frame = (unsigned short int)c->sigcontext_format;
}

// _Ux86_64_create_addr_space
// file x86_64/Gcreate_addr_space.c line 38
extern struct unw_addr_space * _Ux86_64_create_addr_space(struct unw_accessors *a, signed int byte_order)
{
  struct unw_addr_space *as;
  if(!(byte_order == 0) && !(byte_order == 1234))
    return (struct unw_addr_space *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct unw_addr_space) /*43664ul*/ );
    as = (struct unw_addr_space *)return_value_malloc_1;
    if(as == ((struct unw_addr_space *)NULL))
      return (struct unw_addr_space *)(void *)0;

    else
    {
      memset((void *)as, 0, sizeof(struct unw_addr_space) /*43664ul*/ );
      as->acc = *a;
      return as;
    }
  }
}

// _Ux86_64_destroy_addr_space
// file mi/Gdestroy_addr_space.c line 29
extern void _Ux86_64_destroy_addr_space(struct unw_addr_space *as)
{
  free((void *)as);
}

// _Ux86_64_dwarf_callback
// file dwarf/Gfind_proc_info-lsb.c line 531
extern signed int _Ux86_64_dwarf_callback(struct dl_phdr_info *info, unsigned long int size, void *ptr)
{
  struct dwarf_callback_data *cb_data = (struct dwarf_callback_data *)ptr;
  struct unw_dyn_info *di = &cb_data->di;
  const struct anonymous_16 *phdr;
  const struct anonymous_16 *p_eh_hdr;
  const struct anonymous_16 *p_dynamic;
  const struct anonymous_16 *p_text;
  unsigned long int addr;
  unsigned long int eh_frame_start;
  unsigned long int eh_frame_end;
  unsigned long int fde_count;
  unsigned long int ip;
  unsigned long int load_base;
  unsigned long int max_load_addr = (unsigned long int)0;
  signed int ret;
  signed int need_unwind_info = cb_data->need_unwind_info;
  struct unw_proc_info *pi = cb_data->pi;
  struct dwarf_eh_frame_hdr *hdr;
  struct unw_accessors *a;
  signed long int n;
  signed int found = 0;
  ip = cb_data->ip;
  if(!(size >= sizeof(unsigned short int) * 13 /*26ul*/ ))
    return -1;

  else
  {
    phdr = info->dlpi_phdr;
    load_base = info->dlpi_addr;
    p_text = (const struct anonymous_16 *)(void *)0;
    p_eh_hdr = (const struct anonymous_16 *)(void *)0;
    p_dynamic = (const struct anonymous_16 *)(void *)0;
    n = (signed long int)info->dlpi_phnum;
    do
    {
      n = n - 1l;
      if(!(n >= 0l))
        break;

      if(phdr->p_type == 1u)
      {
        unsigned long int vaddr = phdr->p_vaddr + load_base;
        if(ip >= vaddr)
        {
          if(!(ip >= phdr->p_memsz + vaddr))
            p_text = phdr;

        }

        if(!(max_load_addr >= phdr->p_filesz + vaddr))
          max_load_addr = vaddr + phdr->p_filesz;

      }

      else
        if(phdr->p_type == 1685382480u)
          p_eh_hdr = phdr;

        else
          if(phdr->p_type == 2u)
            p_dynamic = phdr;

      phdr = phdr + 1l;
    }
    while((_Bool)1);
    if(p_text == ((const struct anonymous_16 *)NULL))
      return 0;

    else
    {
      if(!(p_eh_hdr == ((const struct anonymous_16 *)NULL)))
      {
        if(!(p_dynamic == ((const struct anonymous_16 *)NULL)))
        {
          struct anonymous_18 *dyn = (struct anonymous_18 *)(p_dynamic->p_vaddr + load_base);
          for( ; !(dyn->d_tag == 0l); dyn = dyn + 1l)
            if(dyn->d_tag == 3l)
            {
              di->gp = dyn->d_un.d_ptr;
              break;
            }

        }

        else
          di->gp = (unsigned long int)0;
        pi->gp = di->gp;
        hdr = (struct dwarf_eh_frame_hdr *)(p_eh_hdr->p_vaddr + load_base);
        if(!((signed int)hdr->version == 1))
          return 0;

        a=_Ux86_64_get_accessors(_Ux86_64_local_addr_space);
        addr = (unsigned long int)(hdr + (signed long int)1);
        ret=_Ux86_64_dwarf_read_encoded_pointer(_Ux86_64_local_addr_space, a, &addr, hdr->eh_frame_ptr_enc, pi, &eh_frame_start, (void *)0);
        if(!(ret >= 0))
          return ret;

        ret=_Ux86_64_dwarf_read_encoded_pointer(_Ux86_64_local_addr_space, a, &addr, hdr->fde_count_enc, pi, &fde_count, (void *)0);
        if(!(ret >= 0))
          return ret;

        if(!((signed int)hdr->table_enc == 59))
        {
          eh_frame_end = max_load_addr;
          if((signed int)hdr->fde_count_enc == 0xff)
            fde_count = ~0UL;

          if((signed int)hdr->eh_frame_ptr_enc == 0xff)
            abort();

          cb_data->single_fde = 1;
          found=linear_search(_Ux86_64_local_addr_space, ip, eh_frame_start, eh_frame_end, fde_count, pi, need_unwind_info, (void *)0);
          if(!(found == 1))
            found = 0;

        }

        else
        {
          di->format = 2;
          di->start_ip = p_text->p_vaddr + load_base;
          di->end_ip = p_text->p_vaddr + load_base + p_text->p_memsz;
          di->u.rti.name_ptr = (unsigned long int)info->dlpi_name;
          di->u.rti.table_data = addr;
          di->u.rti.table_len = (fde_count * sizeof(struct table_entry) /*8ul*/ ) / sizeof(unsigned long int) /*8ul*/ ;
          di->u.rti.segbase = (unsigned long int)hdr;
          found = 1;
        }
      }

      return found;
    }
  }
}

// _Ux86_64_dwarf_create_state_record
// file dwarf/Gparser.c line 893
extern signed int _Ux86_64_dwarf_create_state_record(struct dwarf_cursor *c, struct dwarf_state_record *sr)
{
  signed int return_value_create_state_record_for_1;
  return_value_create_state_record_for_1=create_state_record_for(c, sr, c->ip);
  return return_value_create_state_record_for_1;
}

// _Ux86_64_dwarf_eval_expr
// file dwarf/Gexpr.c line 190
extern signed int _Ux86_64_dwarf_eval_expr(struct dwarf_cursor *c, unsigned long int *addr, unsigned long int len, unsigned long int *valp, signed int *is_register)
{
  unsigned long int operand1 = (unsigned long int)0;
  unsigned long int operand2 = (unsigned long int)0;
  unsigned long int tmp1;
  unsigned long int tmp2;
  unsigned long int tmp3;
  unsigned long int end_addr;
  unsigned char opcode;
  unsigned char operands_signature;
  unsigned char u8;
  struct unw_addr_space *as;
  struct unw_accessors *a;
  void *arg;
  unsigned long int stack[64l];
  unsigned int tos = (unsigned int)0;
  unsigned short int u16;
  unsigned int u32;
  unsigned long int u64;
  signed int ret;
  as = c->as;
  arg = c->as_arg;
  a=_Ux86_64_get_accessors(as);
  end_addr = *addr + len;
  *is_register = 0;
  unsigned int tmp_post_1;
  do
  {
    unsigned long int _x = c->cfa;
    if(tos >= 64u)
      return -UNW_EINVAL;

    tmp_post_1 = tos;
    tos = tos + 1u;
    stack[(signed long int)tmp_post_1] = _x;
  }
  while((_Bool)0);
  unsigned long int return_value_read_operand_3;
  unsigned int tmp_post_4;
  signed int tmp_if_expr_5;
  unsigned int tmp_post_6;
  signed int tmp_if_expr_7;
  unsigned int tmp_post_8;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_10;
  unsigned int tmp_post_11;
  unsigned int tmp_post_12;
  unsigned int tmp_post_13;
  unsigned int tmp_post_14;
  unsigned long int tmp_statement_expression_15;
  unsigned int tmp_post_16;
  unsigned long int tmp_statement_expression_17;
  unsigned int tmp_post_18;
  unsigned long int tmp_statement_expression_19;
  unsigned int tmp_post_20;
  unsigned long int tmp_statement_expression_21;
  unsigned int tmp_post_22;
  unsigned long int tmp_statement_expression_23;
  unsigned int tmp_post_24;
  unsigned long int tmp_statement_expression_25;
  unsigned long int tmp_statement_expression_26;
  unsigned int tmp_post_27;
  unsigned int tmp_post_28;
  unsigned long int tmp_statement_expression_29;
  unsigned long int tmp_statement_expression_30;
  unsigned long int tmp_statement_expression_31;
  unsigned int tmp_post_32;
  unsigned int tmp_post_33;
  unsigned int tmp_post_34;
  unsigned long int tmp_statement_expression_35;
  unsigned int tmp_post_36;
  unsigned long int tmp_statement_expression_37;
  unsigned long int tmp_statement_expression_38;
  unsigned int tmp_post_39;
  unsigned long int tmp_statement_expression_40;
  unsigned long int tmp_statement_expression_41;
  signed long int return_value_sword_42;
  signed long int return_value_sword_43;
  unsigned int tmp_post_44;
  unsigned long int tmp_statement_expression_45;
  unsigned long int tmp_statement_expression_46;
  unsigned int tmp_post_47;
  unsigned long int tmp_statement_expression_48;
  unsigned long int tmp_statement_expression_49;
  unsigned int tmp_post_50;
  unsigned long int tmp_statement_expression_51;
  unsigned long int tmp_statement_expression_52;
  unsigned int tmp_post_53;
  unsigned long int tmp_statement_expression_54;
  unsigned int tmp_post_55;
  unsigned long int tmp_statement_expression_56;
  unsigned int tmp_post_57;
  unsigned long int tmp_statement_expression_58;
  unsigned long int tmp_statement_expression_59;
  unsigned int tmp_post_60;
  unsigned long int tmp_statement_expression_61;
  unsigned long int tmp_statement_expression_62;
  unsigned int tmp_post_63;
  unsigned long int tmp_statement_expression_64;
  unsigned int tmp_post_65;
  unsigned long int tmp_statement_expression_66;
  unsigned long int tmp_statement_expression_67;
  unsigned int tmp_post_68;
  unsigned long int tmp_statement_expression_69;
  unsigned long int tmp_statement_expression_70;
  unsigned int tmp_post_71;
  unsigned long int tmp_statement_expression_72;
  unsigned long int tmp_statement_expression_73;
  unsigned int tmp_post_75;
  unsigned long int tmp_statement_expression_76;
  unsigned long int tmp_statement_expression_77;
  unsigned int tmp_post_78;
  unsigned long int tmp_statement_expression_79;
  unsigned long int tmp_statement_expression_80;
  unsigned int tmp_post_83;
  unsigned long int tmp_statement_expression_84;
  unsigned long int tmp_statement_expression_85;
  unsigned int tmp_post_88;
  unsigned long int tmp_statement_expression_89;
  unsigned long int tmp_statement_expression_90;
  unsigned int tmp_post_93;
  unsigned long int tmp_statement_expression_94;
  unsigned long int tmp_statement_expression_95;
  unsigned int tmp_post_98;
  unsigned long int tmp_statement_expression_99;
  unsigned long int tmp_statement_expression_100;
  unsigned int tmp_post_103;
  unsigned long int tmp_statement_expression_104;
  unsigned long int tmp_statement_expression_105;
  unsigned int tmp_post_108;
  unsigned long int tmp_statement_expression_109;
  while(!(*addr >= end_addr))
  {
    ret=dwarf_readu8(as, a, addr, &opcode, arg);
    if(!(ret >= 0))
      return ret;

    operands_signature = operands[(signed long int)opcode];
    if(((signed int)operands_signature >> 6 & 0x3) >= 1)
    {
      unsigned long int return_value_read_operand_2;
      return_value_read_operand_2=read_operand(as, a, addr, (signed int)operands_signature >> 3 & 0x7, &operand1, arg);
      ret = (signed int)return_value_read_operand_2;
      if(!(ret >= 0))
        return ret;

      if(((signed int)operands_signature >> 6 & 0x3) >= 2)
      {
        return_value_read_operand_3=read_operand(as, a, addr, (signed int)operands_signature >> 0 & 0x7, &operand2, arg);
        ret = (signed int)return_value_read_operand_3;
        if(!(ret >= 0))
          return ret;

      }

    }

    switch((signed int)(enum anonymous_9)opcode)
    {
      case DW_OP_lit0:

      case DW_OP_lit1:

      case DW_OP_lit2:

      case DW_OP_lit3:

      case DW_OP_lit4:

      case DW_OP_lit5:

      case DW_OP_lit6:

      case DW_OP_lit7:

      case DW_OP_lit8:

      case DW_OP_lit9:

      case DW_OP_lit10:

      case DW_OP_lit11:

      case DW_OP_lit12:

      case DW_OP_lit13:

      case DW_OP_lit14:

      case DW_OP_lit15:

      case DW_OP_lit16:

      case DW_OP_lit17:

      case DW_OP_lit18:

      case DW_OP_lit19:

      case DW_OP_lit20:

      case DW_OP_lit21:

      case DW_OP_lit22:

      case DW_OP_lit23:

      case DW_OP_lit24:

      case DW_OP_lit25:

      case DW_OP_lit26:

      case DW_OP_lit27:

      case DW_OP_lit28:

      case DW_OP_lit29:

      case DW_OP_lit30:

      case DW_OP_lit31:
      {
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__1___x = (unsigned long int)((signed int)opcode - DW_OP_lit0);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_4 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_4] = _Ux86_64_dwarf_eval_expr__1__2__2__1___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_breg0:

      case DW_OP_breg1:

      case DW_OP_breg2:

      case DW_OP_breg3:

      case DW_OP_breg4:

      case DW_OP_breg5:

      case DW_OP_breg6:

      case DW_OP_breg7:

      case DW_OP_breg8:

      case DW_OP_breg9:

      case DW_OP_breg10:

      case DW_OP_breg11:

      case DW_OP_breg12:

      case DW_OP_breg13:

      case DW_OP_breg14:

      case DW_OP_breg15:

      case DW_OP_breg16:

      case DW_OP_breg17:

      case DW_OP_breg18:

      case DW_OP_breg19:

      case DW_OP_breg20:

      case DW_OP_breg21:

      case DW_OP_breg22:

      case DW_OP_breg23:

      case DW_OP_breg24:

      case DW_OP_breg25:

      case DW_OP_breg26:

      case DW_OP_breg27:

      case DW_OP_breg28:

      case DW_OP_breg29:

      case DW_OP_breg30:

      case DW_OP_breg31:
      {
        if(!((signed int)opcode + -112 >= 17))
          tmp_if_expr_5 = (signed int)_Ux86_64_dwarf_to_unw_regnum_map[(signed long int)((signed int)opcode - DW_OP_breg0)];

        else
          tmp_if_expr_5 = 0;
        ret=_Ux86_64_get_reg((struct unw_cursor *)c, tmp_if_expr_5, &tmp1);
        if(!(ret >= 0))
          return ret;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__2___x = tmp1 + operand1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_6 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_6] = _Ux86_64_dwarf_eval_expr__1__2__2__2___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_bregx:
      {
        if(!(operand1 >= 17ul))
          tmp_if_expr_7 = (signed int)_Ux86_64_dwarf_to_unw_regnum_map[(signed long int)operand1];

        else
          tmp_if_expr_7 = 0;
        ret=_Ux86_64_get_reg((struct unw_cursor *)c, tmp_if_expr_7, &tmp1);
        if(!(ret >= 0))
          return ret;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__3___x = tmp1 + operand2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_8 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_8] = _Ux86_64_dwarf_eval_expr__1__2__2__3___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_reg0:

      case DW_OP_reg1:

      case DW_OP_reg2:

      case DW_OP_reg3:

      case DW_OP_reg4:

      case DW_OP_reg5:

      case DW_OP_reg6:

      case DW_OP_reg7:

      case DW_OP_reg8:

      case DW_OP_reg9:

      case DW_OP_reg10:

      case DW_OP_reg11:

      case DW_OP_reg12:

      case DW_OP_reg13:

      case DW_OP_reg14:

      case DW_OP_reg15:

      case DW_OP_reg16:

      case DW_OP_reg17:

      case DW_OP_reg18:

      case DW_OP_reg19:

      case DW_OP_reg20:

      case DW_OP_reg21:

      case DW_OP_reg22:

      case DW_OP_reg23:

      case DW_OP_reg24:

      case DW_OP_reg25:

      case DW_OP_reg26:

      case DW_OP_reg27:

      case DW_OP_reg28:

      case DW_OP_reg29:

      case DW_OP_reg30:

      case DW_OP_reg31:
      {
        if(!((signed int)opcode + -80 >= 17))
          tmp_if_expr_9 = (signed int)_Ux86_64_dwarf_to_unw_regnum_map[(signed long int)((signed int)opcode - DW_OP_reg0)];

        else
          tmp_if_expr_9 = 0;
        *valp = (unsigned long int)tmp_if_expr_9;
        *is_register = 1;
        return 0;
      }
      case DW_OP_regx:
      {
        if(!(operand1 >= 17ul))
          tmp_if_expr_10 = (signed int)_Ux86_64_dwarf_to_unw_regnum_map[(signed long int)operand1];

        else
          tmp_if_expr_10 = 0;
        *valp = (unsigned long int)tmp_if_expr_10;
        *is_register = 1;
        return 0;
      }
      case DW_OP_addr:

      case DW_OP_const1u:

      case DW_OP_const2u:

      case DW_OP_const4u:

      case DW_OP_const8u:

      case DW_OP_constu:

      case DW_OP_const8s:

      case DW_OP_consts:
      {
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__4___x = operand1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_11 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_11] = _Ux86_64_dwarf_eval_expr__1__2__2__4___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_const1s:
      {
        if(!((128ul & operand1) == 0ul))
          operand1 = operand1 | (unsigned long int)-1 << 8;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__5___x = operand1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_12 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_12] = _Ux86_64_dwarf_eval_expr__1__2__2__5___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_const2s:
      {
        if(!((32768ul & operand1) == 0ul))
          operand1 = operand1 | (unsigned long int)-1 << 16;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__6___x = operand1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_13 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_13] = _Ux86_64_dwarf_eval_expr__1__2__2__6___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_const4s:
      {
        if(!((2147483648ul & operand1) == 0ul))
          operand1 = operand1 | ((unsigned long int)-1 << 16) << 16;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__7___x = operand1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_14 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_14] = _Ux86_64_dwarf_eval_expr__1__2__2__7___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_deref:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_15 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_15;
        ret=dwarf_readw(as, a, &tmp1, &tmp2, arg);
        if(!(ret >= 0))
          return ret;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__9___x = tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_16 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_16] = _Ux86_64_dwarf_eval_expr__1__2__2__9___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_deref_size:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_17 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_17;
        if(!(operand1 == 1ul))
        {
          if(operand1 == 2ul)
            goto __CPROVER_DUMP_L45;

          if(operand1 == 3ul || operand1 == 4ul)
            goto __CPROVER_DUMP_L47;

          if(operand1 == 5ul || operand1 == 6ul || operand1 == 7ul || operand1 == 8ul)
            goto __CPROVER_DUMP_L51;

          return -UNW_EINVAL;
        }

        ret=dwarf_readu8(as, a, &tmp1, &u8, arg);
        if(!(ret >= 0))
          return ret;

        tmp2 = (unsigned long int)u8;
        goto __CPROVER_DUMP_L54;

      __CPROVER_DUMP_L45:
        ;
        ret=dwarf_readu16(as, a, &tmp1, &u16, arg);
        if(!(ret >= 0))
          return ret;

        tmp2 = (unsigned long int)u16;
        goto __CPROVER_DUMP_L54;

      __CPROVER_DUMP_L47:
        ;
        ret=dwarf_readu32(as, a, &tmp1, &u32, arg);
        if(!(ret >= 0))
          return ret;

        tmp2 = (unsigned long int)u32;
        if(operand1 == 3ul)
          tmp2 = tmp2 & (unsigned long int)0xffffff;

        goto __CPROVER_DUMP_L54;

      __CPROVER_DUMP_L51:
        ;
        ret=dwarf_readu64(as, a, &tmp1, &u64, arg);
        if(!(ret >= 0))
          return ret;

        tmp2 = u64;
        if(!(operand1 == 8ul))
          tmp2 = tmp2 & ~((unsigned long int)0) << (unsigned long int)8 * operand1;

        do
        {

        __CPROVER_DUMP_L54:
          ;
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__12___x = tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_18 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_18] = _Ux86_64_dwarf_eval_expr__1__2__2__12___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_dup:
      {
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__13___x;
          unsigned int _index = (tos - (unsigned int)1) - (unsigned int)0;
          if(_index >= 64u)
            return -UNW_EINVAL;

          tmp_statement_expression_19 = stack[(signed long int)_index];
          _Ux86_64_dwarf_eval_expr__1__2__2__13___x = tmp_statement_expression_19;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_20 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_20] = _Ux86_64_dwarf_eval_expr__1__2__2__13___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_drop:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        stack[(signed long int)tos];
        break;
      }
      case DW_OP_pick:
      {
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__15___x;
          unsigned int _Ux86_64_dwarf_eval_expr__1__2__2__15__1___index = (unsigned int)((unsigned long int)(tos - (unsigned int)1) - operand1);
          if(_Ux86_64_dwarf_eval_expr__1__2__2__15__1___index >= 64u)
            return -UNW_EINVAL;

          tmp_statement_expression_21 = stack[(signed long int)_Ux86_64_dwarf_eval_expr__1__2__2__15__1___index];
          _Ux86_64_dwarf_eval_expr__1__2__2__15___x = tmp_statement_expression_21;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_22 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_22] = _Ux86_64_dwarf_eval_expr__1__2__2__15___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_over:
      {
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__16___x;
          unsigned int _Ux86_64_dwarf_eval_expr__1__2__2__16__1___index = (tos - (unsigned int)1) - (unsigned int)1;
          if(_Ux86_64_dwarf_eval_expr__1__2__2__16__1___index >= 64u)
            return -UNW_EINVAL;

          tmp_statement_expression_23 = stack[(signed long int)_Ux86_64_dwarf_eval_expr__1__2__2__16__1___index];
          _Ux86_64_dwarf_eval_expr__1__2__2__16___x = tmp_statement_expression_23;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_24 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_24] = _Ux86_64_dwarf_eval_expr__1__2__2__16___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_swap:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_25 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_25;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_26 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_26;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__19___x = tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_27 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_27] = _Ux86_64_dwarf_eval_expr__1__2__2__19___x;
        }
        while((_Bool)0);
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__20___x = tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_28 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_28] = _Ux86_64_dwarf_eval_expr__1__2__2__20___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_rot:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_29 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_29;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_30 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_30;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_31 = stack[(signed long int)tos];
        tmp3 = tmp_statement_expression_31;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__24___x = tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_32 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_32] = _Ux86_64_dwarf_eval_expr__1__2__2__24___x;
        }
        while((_Bool)0);
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__25___x = tmp3;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_33 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_33] = _Ux86_64_dwarf_eval_expr__1__2__2__25___x;
        }
        while((_Bool)0);
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__26___x = tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_34 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_34] = _Ux86_64_dwarf_eval_expr__1__2__2__26___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_abs:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_35 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_35;
        if(!((9223372036854775808ul & tmp1) == 0ul))
          tmp1 = -tmp1;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__28___x = tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_36 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_36] = _Ux86_64_dwarf_eval_expr__1__2__2__28___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_and:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_37 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_37;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_38 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_38;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__31___x = tmp1 & tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_39 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_39] = _Ux86_64_dwarf_eval_expr__1__2__2__31___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_div:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_40 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_40;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_41 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_41;
        if(!(tmp1 == 0ul))
        {
          return_value_sword_42=sword(as, tmp2);
          return_value_sword_43=sword(as, tmp1);
          tmp1 = (unsigned long int)(return_value_sword_42 / return_value_sword_43);
        }

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__34___x = tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_44 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_44] = _Ux86_64_dwarf_eval_expr__1__2__2__34___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_minus:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_45 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_45;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_46 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_46;
        tmp1 = tmp2 - tmp1;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__37___x = tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_47 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_47] = _Ux86_64_dwarf_eval_expr__1__2__2__37___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_mod:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_48 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_48;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_49 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_49;
        if(!(tmp1 == 0ul))
          tmp1 = tmp2 % tmp1;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__40___x = tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_50 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_50] = _Ux86_64_dwarf_eval_expr__1__2__2__40___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_mul:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_51 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_51;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_52 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_52;
        if(!(tmp1 == 0ul))
          tmp1 = tmp2 * tmp1;

        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__43___x = tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_53 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_53] = _Ux86_64_dwarf_eval_expr__1__2__2__43___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_neg:
      {
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__44___x;
          if(tos + 4294967295u >= 64u)
            return -UNW_EINVAL;

          tos = tos - 1u;
          tmp_statement_expression_54 = stack[(signed long int)tos];
          _Ux86_64_dwarf_eval_expr__1__2__2__44___x = -tmp_statement_expression_54;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_55 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_55] = _Ux86_64_dwarf_eval_expr__1__2__2__44___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_not:
      {
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__45___x;
          if(tos + 4294967295u >= 64u)
            return -UNW_EINVAL;

          tos = tos - 1u;
          tmp_statement_expression_56 = stack[(signed long int)tos];
          _Ux86_64_dwarf_eval_expr__1__2__2__45___x = ~tmp_statement_expression_56;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_57 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_57] = _Ux86_64_dwarf_eval_expr__1__2__2__45___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_or:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_58 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_58;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_59 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_59;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__48___x = tmp1 | tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_60 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_60] = _Ux86_64_dwarf_eval_expr__1__2__2__48___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_plus:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_61 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_61;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_62 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_62;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__51___x = tmp1 + tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_63 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_63] = _Ux86_64_dwarf_eval_expr__1__2__2__51___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_plus_uconst:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_64 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_64;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__53___x = tmp1 + operand1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_65 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_65] = _Ux86_64_dwarf_eval_expr__1__2__2__53___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_shl:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_66 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_66;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_67 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_67;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__56___x = tmp2 << tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_68 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_68] = _Ux86_64_dwarf_eval_expr__1__2__2__56___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_shr:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_69 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_69;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_70 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_70;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__59___x = tmp2 >> tmp1;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_71 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_71] = _Ux86_64_dwarf_eval_expr__1__2__2__59___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_shra:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_72 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_72;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_73 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_73;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__62___x;
          signed long int return_value_sword_74;
          return_value_sword_74=sword(as, tmp2);
          _Ux86_64_dwarf_eval_expr__1__2__2__62___x = (unsigned long int)(return_value_sword_74 >> tmp1);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_75 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_75] = _Ux86_64_dwarf_eval_expr__1__2__2__62___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_xor:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_76 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_76;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_77 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_77;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__65___x = tmp1 ^ tmp2;
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_78 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_78] = _Ux86_64_dwarf_eval_expr__1__2__2__65___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_le:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_79 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_79;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_80 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_80;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__68___x;
          signed long int return_value_sword_81;
          return_value_sword_81=sword(as, tmp1);
          signed long int return_value_sword_82;
          return_value_sword_82=sword(as, tmp2);
          _Ux86_64_dwarf_eval_expr__1__2__2__68___x = (unsigned long int)(return_value_sword_81 <= return_value_sword_82);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_83 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_83] = _Ux86_64_dwarf_eval_expr__1__2__2__68___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_ge:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_84 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_84;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_85 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_85;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__71___x;
          signed long int return_value_sword_86;
          return_value_sword_86=sword(as, tmp1);
          signed long int return_value_sword_87;
          return_value_sword_87=sword(as, tmp2);
          _Ux86_64_dwarf_eval_expr__1__2__2__71___x = (unsigned long int)(return_value_sword_86 >= return_value_sword_87);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_88 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_88] = _Ux86_64_dwarf_eval_expr__1__2__2__71___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_eq:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_89 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_89;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_90 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_90;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__74___x;
          signed long int return_value_sword_91;
          return_value_sword_91=sword(as, tmp1);
          signed long int return_value_sword_92;
          return_value_sword_92=sword(as, tmp2);
          _Ux86_64_dwarf_eval_expr__1__2__2__74___x = (unsigned long int)(return_value_sword_91 == return_value_sword_92);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_93 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_93] = _Ux86_64_dwarf_eval_expr__1__2__2__74___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_lt:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_94 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_94;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_95 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_95;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__77___x;
          signed long int return_value_sword_96;
          return_value_sword_96=sword(as, tmp1);
          signed long int return_value_sword_97;
          return_value_sword_97=sword(as, tmp2);
          _Ux86_64_dwarf_eval_expr__1__2__2__77___x = (unsigned long int)(return_value_sword_96 < return_value_sword_97);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_98 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_98] = _Ux86_64_dwarf_eval_expr__1__2__2__77___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_gt:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_99 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_99;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_100 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_100;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__80___x;
          signed long int return_value_sword_101;
          return_value_sword_101=sword(as, tmp1);
          signed long int return_value_sword_102;
          return_value_sword_102=sword(as, tmp2);
          _Ux86_64_dwarf_eval_expr__1__2__2__80___x = (unsigned long int)(return_value_sword_101 > return_value_sword_102);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_103 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_103] = _Ux86_64_dwarf_eval_expr__1__2__2__80___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_ne:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_104 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_104;
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_105 = stack[(signed long int)tos];
        tmp2 = tmp_statement_expression_105;
        do
        {
          unsigned long int _Ux86_64_dwarf_eval_expr__1__2__2__83___x;
          signed long int return_value_sword_106;
          return_value_sword_106=sword(as, tmp1);
          signed long int return_value_sword_107;
          return_value_sword_107=sword(as, tmp2);
          _Ux86_64_dwarf_eval_expr__1__2__2__83___x = (unsigned long int)(return_value_sword_106 != return_value_sword_107);
          if(tos >= 64u)
            return -UNW_EINVAL;

          tmp_post_108 = tos;
          tos = tos + 1u;
          stack[(signed long int)tmp_post_108] = _Ux86_64_dwarf_eval_expr__1__2__2__83___x;
        }
        while((_Bool)0);
        break;
      }
      case DW_OP_skip:
      {
        *addr = *addr + (unsigned long int)(signed short int)operand1;
        break;
      }
      case DW_OP_bra:
      {
        if(tos + 4294967295u >= 64u)
          return -UNW_EINVAL;

        tos = tos - 1u;
        tmp_statement_expression_109 = stack[(signed long int)tos];
        tmp1 = tmp_statement_expression_109;
        if(!(tmp1 == 0ul))
          *addr = *addr + (unsigned long int)(signed short int)operand1;

        break;
      }
      case DW_OP_nop:
        break;
      case DW_OP_call2:

      case DW_OP_call4:

      case DW_OP_call_ref:

      case DW_OP_fbreg:

      case DW_OP_piece:

      case DW_OP_push_object_address:

      case DW_OP_xderef:

      case DW_OP_xderef_size:

      default:
        return -UNW_EINVAL;
    }
  }
  unsigned long int tmp_statement_expression_110;
  if(tos + 4294967295u >= 64u)
    return -UNW_EINVAL;

  else
  {
    tos = tos - 1u;
    tmp_statement_expression_110 = stack[(signed long int)tos];
    *valp = tmp_statement_expression_110;
    return 0;
  }
}

// _Ux86_64_dwarf_extract_proc_info_from_fde
// file dwarf/Gfde.c line 221
extern signed int _Ux86_64_dwarf_extract_proc_info_from_fde(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addrp, struct unw_proc_info *pi, signed int need_unwind_info, unsigned long int base, void *arg)
{
  unsigned long int fde_end_addr;
  unsigned long int cie_addr;
  unsigned long int cie_offset_addr;
  unsigned long int aug_end_addr = (unsigned long int)0;
  unsigned long int start_ip;
  unsigned long int ip_range;
  unsigned long int aug_size;
  unsigned long int addr = *addrp;
  signed int ret;
  signed int ip_range_encoding;
  struct dwarf_cie_info dci;
  unsigned long int u64val;
  unsigned int u32val;
  memset((void *)&dci, 0, sizeof(struct dwarf_cie_info) /*72ul*/ );
  ret=dwarf_readu32_link1(as, a, &addr, &u32val, arg);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(ret >= 0))
    return ret;

  else
  {
    if(!(u32val == 0xffffffff))
    {
      signed int cie_offset;
      if(u32val == 0u)
        return -UNW_ENOINFO;

      fde_end_addr = addr + (unsigned long int)u32val;
      *addrp = fde_end_addr;
      cie_offset_addr = addr;
      ret=dwarf_reads32(as, a, &addr, &cie_offset, arg);
      if(!(ret >= 0))
        return ret;

      signed int return_value_is_cie_id_1;
      return_value_is_cie_id_1=is_cie_id((unsigned long int)cie_offset, (signed int)(base != (unsigned long int)0));
      if(!(return_value_is_cie_id_1 == 0))
        return 0;

      if(!(base == 0ul))
        cie_addr = base + (unsigned long int)cie_offset;

      else
        cie_addr = cie_offset_addr - (unsigned long int)cie_offset;
    }

    else
    {
      signed long int _Ux86_64_dwarf_extract_proc_info_from_fde__1__2__cie_offset;
      ret=dwarf_readu64_link1(as, a, &addr, &u64val, arg);
      if(!(ret >= 0))
        return ret;

      fde_end_addr = addr + u64val;
      *addrp = fde_end_addr;
      cie_offset_addr = addr;
      ret=dwarf_reads64(as, a, &addr, &_Ux86_64_dwarf_extract_proc_info_from_fde__1__2__cie_offset, arg);
      if(!(ret >= 0))
        return ret;

      signed int return_value_is_cie_id_2;
      return_value_is_cie_id_2=is_cie_id((unsigned long int)_Ux86_64_dwarf_extract_proc_info_from_fde__1__2__cie_offset, (signed int)(base != (unsigned long int)0));
      if(!(return_value_is_cie_id_2 == 0))
        return 0;

      if(!(base == 0ul))
        cie_addr = base + (unsigned long int)_Ux86_64_dwarf_extract_proc_info_from_fde__1__2__cie_offset;

      else
        cie_addr = (unsigned long int)((unsigned long int)cie_offset_addr - (unsigned long int)_Ux86_64_dwarf_extract_proc_info_from_fde__1__2__cie_offset);
    }
    ret=parse_cie(as, a, cie_addr, pi, &dci, base, arg);
    if(!(ret >= 0))
      return ret;

    else
    {
      ip_range_encoding = (signed int)dci.fde_encoding & 0x0f;
      ret=_Ux86_64_dwarf_read_encoded_pointer(as, a, &addr, dci.fde_encoding, pi, &start_ip, arg);
      if(!(ret >= 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        ret=_Ux86_64_dwarf_read_encoded_pointer(as, a, &addr, (unsigned char)ip_range_encoding, pi, &ip_range, arg);
        tmp_if_expr_3 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        return ret;

      else
      {
        pi->start_ip = start_ip;
        pi->end_ip = start_ip + ip_range;
        pi->handler = dci.handler;
        if(!(dci.sized_augmentation == 0u))
        {
          ret=dwarf_read_uleb128_link1(as, a, &addr, &aug_size, arg);
          if(!(ret >= 0))
            return ret;

          aug_end_addr = addr + aug_size;
        }

        ret=_Ux86_64_dwarf_read_encoded_pointer(as, a, &addr, dci.lsda_encoding, pi, &pi->lsda, arg);
        if(!(ret >= 0))
          return ret;

        else
        {
          if(!(need_unwind_info == 0))
          {
            pi->format = 1;
            pi->unwind_info_size = (signed int)sizeof(struct dwarf_cie_info) /*72ul*/ ;
            pi->unwind_info=_UIx86_64__mempool_alloc(&dwarf_cie_info_pool);
            if(pi->unwind_info == NULL)
              return -UNW_ENOMEM;

            if(!(dci.have_abi_marker == 0u))
            {
              ret=dwarf_readu16_link1(as, a, &addr, &dci.abi, arg);
              if(!(ret >= 0))
                tmp_if_expr_4 = (_Bool)1;

              else
              {
                ret=dwarf_readu16_link1(as, a, &addr, &dci.tag, arg);
                tmp_if_expr_4 = ret < 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_4)
                return ret;

            }

            if(!(dci.sized_augmentation == 0u))
              dci.fde_instr_start = aug_end_addr;

            else
              dci.fde_instr_start = addr;
            dci.fde_instr_end = fde_end_addr;
            memcpy(pi->unwind_info, (const void *)&dci, sizeof(struct dwarf_cie_info) /*72ul*/ );
          }

          return 0;
        }
      }
    }
  }
}

// _Ux86_64_dwarf_find_proc_info
// file ../include/dwarf.h line 380
extern signed int _Ux86_64_dwarf_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg)
{
  struct dwarf_callback_data cb_data;
  struct anonymous_8 saved_mask;
  signed int ret;
  memset((void *)&cb_data, 0, sizeof(struct dwarf_callback_data) /*184ul*/ );
  cb_data.ip = ip;
  cb_data.pi = pi;
  cb_data.need_unwind_info = need_unwind_info;
  cb_data.di.format = -1;
  cb_data.di_debug.format = -1;
  sigprocmask(2, &_UIx86_64_full_mask, &saved_mask);
  ret=dl_iterate_phdr(_Ux86_64_dwarf_callback, (void *)&cb_data);
  sigprocmask(2, &saved_mask, (struct anonymous_8 *)(void *)0);
  if(!(ret >= 1))
    return -UNW_ENOINFO;

  else
    if(!(cb_data.single_fde == 0))
      return 0;

    else
    {
      if(!(cb_data.di.format == -1))
        ret=_Ux86_64_dwarf_search_unwind_table(as, ip, &cb_data.di, pi, need_unwind_info, arg);

      else
        ret = -UNW_ENOINFO;
      if(ret == -10 && !(cb_data.di_debug.format == -1))
        ret=_Ux86_64_dwarf_search_unwind_table(as, ip, &cb_data.di_debug, pi, need_unwind_info, arg);

      return ret;
    }
}

// _Ux86_64_dwarf_find_save_locs
// file dwarf/Gparser.c line 842
extern signed int _Ux86_64_dwarf_find_save_locs(struct dwarf_cursor *c)
{
  struct dwarf_state_record sr;
  struct dwarf_reg_state *rs;
  struct dwarf_reg_state rs_copy;
  struct dwarf_rs_cache *cache;
  signed int ret = 0;
  struct anonymous_8 saved_mask;
  signed int return_value_uncached_dwarf_find_save_locs_1;
  _Bool tmp_if_expr_2;
  if((signed int)c->as->caching_policy == UNW_CACHE_NONE)
  {
    return_value_uncached_dwarf_find_save_locs_1=uncached_dwarf_find_save_locs(c);
    return return_value_uncached_dwarf_find_save_locs_1;
  }

  else
  {
    cache=get_rs_cache(c->as, &saved_mask);
    rs=rs_lookup(cache, c);
    if(!(rs == ((struct dwarf_reg_state *)NULL)))
    {
      c->ret_addr_column = rs->ret_addr_column;
      c->use_prev_instr = (unsigned int)!(rs->signal_frame != 0);
    }

    else
    {
      ret=fetch_proc_info(c, c->ip, 1);
      if(!(ret >= 0))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        ret=create_state_record_for(c, &sr, c->ip);
        tmp_if_expr_2 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
      {
        put_rs_cache(c->as, cache, &saved_mask);
        return ret;
      }

      rs=rs_new(cache, c);
      memcpy((void *)rs, (const void *)&sr.rs_current, 312ul);
      cache->buckets[(signed long int)c->prev_rs].hint = (unsigned short int)(rs - cache->buckets);
      c->hint = (signed short int)rs->hint;
      c->prev_rs = (signed short int)(rs - cache->buckets);
      put_unwind_info_link1(c, &c->pi);
    }
    memcpy((void *)&rs_copy, (const void *)rs, sizeof(struct dwarf_reg_state) /*336ul*/ );
    put_rs_cache(c->as, cache, &saved_mask);
    _Ux86_64_reuse_frame(c, &rs_copy);
    ret=apply_reg_state(c, &rs_copy);
    if(!(ret >= 0))
      return ret;

    else
      return 0;
  }
}

// _Ux86_64_dwarf_find_unwind_table
// file dwarf/Gfind_unwind_table.c line 38
extern signed int _Ux86_64_dwarf_find_unwind_table(struct elf_dyn_info *edi, struct unw_addr_space *as, char *path, unsigned long int segbase, unsigned long int mapoff, unsigned long int ip)
{
  struct anonymous_16 *phdr;
  struct anonymous_16 *ptxt = (struct anonymous_16 *)(void *)0;
  struct anonymous_16 *peh_hdr = (struct anonymous_16 *)(void *)0;
  struct anonymous_16 *pdyn = (struct anonymous_16 *)(void *)0;
  unsigned long int addr;
  unsigned long int eh_frame_start;
  unsigned long int fde_count;
  unsigned long int load_base;
  unsigned long int max_load_addr = (unsigned long int)0;
  unsigned long int start_ip = (unsigned long int)-1;
  unsigned long int end_ip = (unsigned long int)0;
  struct dwarf_eh_frame_hdr *hdr;
  struct unw_proc_info pi;
  struct unw_accessors *a;
  struct anonymous_20 *ehdr;
  signed int i;
  signed int ret;
  signed int found = 0;
  signed int return_value__Uelf64_valid_object_1;
  return_value__Uelf64_valid_object_1=_Uelf64_valid_object_link1(&edi->ei);
  if(return_value__Uelf64_valid_object_1 == 0)
    return -UNW_ENOINFO;

  else
  {
    ehdr = (struct anonymous_20 *)edi->ei.image;
    phdr = (struct anonymous_16 *)((char *)edi->ei.image + (signed long int)ehdr->e_phoff);
    i = 0;
    for( ; !(i >= (signed int)ehdr->e_phnum); i = i + 1)
      switch((phdr + (signed long int)i)->p_type)
      {
        case (unsigned int)1:
        {
          if(!((phdr + (signed long int)i)->p_vaddr >= start_ip))
            start_ip = (phdr + (signed long int)i)->p_vaddr;

          if(!(end_ip >= (phdr + (signed long int)i)->p_memsz + (phdr + (signed long int)i)->p_vaddr))
            end_ip = (phdr + (signed long int)i)->p_vaddr + (phdr + (signed long int)i)->p_memsz;

          if((phdr + (signed long int)i)->p_offset == mapoff)
            ptxt = phdr + (signed long int)i;

          if(!(max_load_addr >= phdr->p_filesz + (unsigned long int)edi->ei.image))
            max_load_addr = (unsigned long int)edi->ei.image + phdr->p_filesz;

          break;
        }
        case (unsigned int)0x6474e550:
        {
          peh_hdr = phdr + (signed long int)i;
          break;
        }
        case (unsigned int)2:
          pdyn = phdr + (signed long int)i;
      }
    if(ptxt == ((struct anonymous_16 *)NULL))
      return 0;

    else
    {
      load_base = segbase - ptxt->p_vaddr;
      start_ip = start_ip + load_base;
      end_ip = end_ip + load_base;
      if(!(peh_hdr == ((struct anonymous_16 *)NULL)))
      {
        if(!(pdyn == ((struct anonymous_16 *)NULL)))
        {
          struct anonymous_18 *dyn = (struct anonymous_18 *)((signed long int)pdyn->p_offset + (char *)edi->ei.image);
          for( ; !(dyn->d_tag == 0l); dyn = dyn + 1l)
            if(dyn->d_tag == 3l)
            {
              edi->di_cache.gp = dyn->d_un.d_ptr;
              break;
            }

        }

        else
          edi->di_cache.gp = (unsigned long int)0;
        hdr = (struct dwarf_eh_frame_hdr *)((signed long int)peh_hdr->p_offset + (char *)edi->ei.image);
        if(!((signed int)hdr->version == 1))
          return -UNW_ENOINFO;

        a=_Ux86_64_get_accessors(_Ux86_64_local_addr_space);
        addr = (unsigned long int)(hdr + (signed long int)1);
        memset((void *)&pi, 0, sizeof(struct unw_proc_info) /*64ul*/ );
        pi.gp = edi->di_cache.gp;
        ret=_Ux86_64_dwarf_read_encoded_pointer(_Ux86_64_local_addr_space, a, &addr, hdr->eh_frame_ptr_enc, &pi, &eh_frame_start, (void *)0);
        if(!(ret >= 0))
          return -UNW_ENOINFO;

        ret=_Ux86_64_dwarf_read_encoded_pointer(_Ux86_64_local_addr_space, a, &addr, hdr->fde_count_enc, &pi, &fde_count, (void *)0);
        if(!(ret >= 0))
          return -UNW_ENOINFO;

        if(!((signed int)hdr->table_enc == 59))
          abort();

        edi->di_cache.start_ip = start_ip;
        edi->di_cache.end_ip = end_ip;
        edi->di_cache.format = 2;
        edi->di_cache.u.rti.name_ptr = (unsigned long int)0;
        edi->di_cache.u.rti.table_len = (fde_count * (unsigned long int)8) / sizeof(unsigned long int) /*8ul*/ ;
        edi->di_cache.u.rti.table_data = load_base + peh_hdr->p_vaddr + ((addr - (unsigned long int)edi->ei.image) - peh_hdr->p_offset);
        edi->di_cache.u.rti.segbase = load_base + peh_hdr->p_vaddr + (((unsigned long int)hdr - (unsigned long int)edi->ei.image) - peh_hdr->p_offset);
        found = 1;
      }

      return found;
    }
  }
}

// _Ux86_64_dwarf_init
// file ../include/dwarf.h line 377
extern signed int _Ux86_64_dwarf_init(void)
{
  _UIx86_64__mempool_init(&dwarf_reg_state_pool, sizeof(struct dwarf_reg_state) /*336ul*/ , (unsigned long int)0);
  _UIx86_64__mempool_init(&dwarf_cie_info_pool, sizeof(struct dwarf_cie_info) /*72ul*/ , (unsigned long int)0);
  return 0;
}

// _Ux86_64_dwarf_make_proc_info
// file ../include/dwarf.h line 411
extern signed int _Ux86_64_dwarf_make_proc_info(struct dwarf_cursor *c)
{
  signed int return_value_fetch_proc_info_1;
  return_value_fetch_proc_info_1=fetch_proc_info(c, c->ip, 0);
  return return_value_fetch_proc_info_1;
  return 0;
}

// _Ux86_64_dwarf_put_unwind_info
// file dwarf/Gfind_proc_info-lsb.c line 928
extern void _Ux86_64_dwarf_put_unwind_info(struct unw_addr_space *as, struct unw_proc_info *pi, void *arg)
{
  ;
}

// _Ux86_64_dwarf_read_encoded_pointer
// file ../include/dwarf.h line 412
extern signed int _Ux86_64_dwarf_read_encoded_pointer(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned char encoding, const struct unw_proc_info *pi, unsigned long int *valp, void *arg)
{
  signed int return_value_dwarf_read_encoded_pointer_inlined_1;
  return_value_dwarf_read_encoded_pointer_inlined_1=dwarf_read_encoded_pointer_inlined(as, a, addr, encoding, pi, valp, arg);
  return return_value_dwarf_read_encoded_pointer_inlined_1;
}

// _Ux86_64_dwarf_search_unwind_table
// file ../include/dwarf.h line 388
extern signed int _Ux86_64_dwarf_search_unwind_table(struct unw_addr_space *as, unsigned long int ip, struct unw_dyn_info *di, struct unw_proc_info *pi, signed int need_unwind_info, void *arg)
{
  struct table_entry *e = (struct table_entry *)(void *)0;
  struct table_entry *table;
  unsigned long int segbase = (unsigned long int)0;
  unsigned long int fde_addr;
  struct unw_accessors *a;
  struct table_entry ent;
  signed int ret;
  unsigned long int debug_frame_base;
  unsigned long int table_len;
  if(di->format == 2)
  {
    table = (struct table_entry *)(unsigned long int)di->u.rti.table_data;
    table_len = di->u.rti.table_len * sizeof(unsigned long int) /*8ul*/ ;
    debug_frame_base = (unsigned long int)0;
  }

  else
  {
    struct unw_debug_frame_list *fdesc = (struct unw_debug_frame_list *)(void *)di->u.ti.table_data;
    as = _Ux86_64_local_addr_space;
    table = fdesc->index;
    table_len = fdesc->index_size * sizeof(struct table_entry) /*8ul*/ ;
    debug_frame_base = (unsigned long int)fdesc->debug_frame;
  }
  a=_Ux86_64_get_accessors(as);
  if(as == _Ux86_64_local_addr_space)
  {
    segbase = di->u.rti.segbase;
    e=lookup(table, table_len, (signed int)(ip - segbase));
  }

  else
  {
    segbase = di->u.rti.segbase;
    ret=remote_lookup(as, (unsigned long int)table, table_len, (signed int)(ip - segbase), &ent, arg);
    if(!(ret >= 0))
      return ret;

    if(!(ret == 0))
      e = &ent;

    else
      e = (struct table_entry *)(void *)0;
  }
  _Bool tmp_if_expr_1;
  if(e == ((struct table_entry *)NULL))
    return -UNW_ENOINFO;

  else
  {
    if(!(debug_frame_base == 0ul))
      fde_addr = (unsigned long int)e->fde_offset + debug_frame_base;

    else
      fde_addr = (unsigned long int)e->fde_offset + segbase;
    ret=_Ux86_64_dwarf_extract_proc_info_from_fde(as, a, &fde_addr, pi, need_unwind_info, debug_frame_base, arg);
    if(!(ret >= 0))
      return ret;

    else
    {
      if(di->format == 1)
      {
        pi->start_ip = pi->start_ip + segbase;
        pi->end_ip = pi->end_ip + segbase;
        pi->flags = (unsigned long int)32;
      }

      if(!(ip >= pi->start_ip))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = ip >= pi->end_ip ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        return -UNW_ENOINFO;

      else
        return 0;
    }
  }
}

// _Ux86_64_dwarf_step
// file ../include/dwarf.h line 418
extern signed int _Ux86_64_dwarf_step(struct dwarf_cursor *c)
{
  signed int ret;
  ret=_Ux86_64_dwarf_find_save_locs(c);
  if(ret >= 0)
  {
    c->pi_valid = (unsigned int)0;
    ret = 1;
  }

  return ret;
}

// _Ux86_64_fetch_frame
// file x86_64/Gos-linux.c line 34
extern void _Ux86_64_fetch_frame(struct dwarf_cursor *dw, unsigned long int ip, signed int need_unwind_info)
{
  struct cursor *c = (struct cursor *)dw;
  _Bool tmp_if_expr_1;
  if(!(dw->pi_valid == 0u))
    tmp_if_expr_1 = dw->pi.unwind_info != NULL ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ((struct dwarf_cie_info *)dw->pi.unwind_info)->signal_frame != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    c->sigcontext_format = (enum anonymous_2)X86_64_SCF_LINUX_RT_SIGFRAME;

  else
    c->sigcontext_format = (enum anonymous_2)X86_64_SCF_NONE;
}

// _Ux86_64_flush_cache
// file mi/flush_cache.c line 29
extern void _Ux86_64_flush_cache(struct unw_addr_space *as, unsigned long int lo, unsigned long int hi)
{
  struct unw_debug_frame_list *w = as->debug_frames;
  as->dyn_info_list_addr = (unsigned long int)0;
  for( ; !(w == ((struct unw_debug_frame_list *)NULL)); w = w->next)
  {
    if(!(w->index == ((struct table_entry *)NULL)))
      free((void *)w->index);

    free((void *)w->debug_frame);
  }
  as->debug_frames = (struct unw_debug_frame_list *)(void *)0;
  __CPROVER_atomic_begin();
  *(&as->cache_generation) = *(&as->cache_generation) + (unsigned int)1;
  FENCE(WRfence);
  __CPROVER_atomic_end();
}

// _Ux86_64_get_accessors
// file ../include/libunwind-common.h line 234
extern struct unw_accessors * _Ux86_64_get_accessors(struct unw_addr_space *as)
{
  if(_Ux86_64_init_done == 0)
    _Ux86_64_init();

  return &as->acc;
}

// _Ux86_64_get_elf_image
// file os-linux.c line 33
extern signed int _Ux86_64_get_elf_image(struct elf_image *ei, signed int pid, unsigned long int ip, unsigned long int *segbase, unsigned long int *mapoff, char *path, unsigned long int pathlen)
{
  struct map_iterator mi;
  signed int found = 0;
  signed int rc;
  unsigned long int hi;
  signed int return_value_maps_init_1;
  return_value_maps_init_1=maps_init(&mi, pid);
  signed int return_value_maps_next_2;
  if(!(return_value_maps_init_1 >= 0))
    return -1;

  else
  {
    do
    {
      return_value_maps_next_2=maps_next(&mi, segbase, &hi, mapoff);
      if(return_value_maps_next_2 == 0)
        break;

      if(ip >= *segbase)
      {
        if(!(ip >= hi))
        {
          found = 1;
          break;
        }

      }

    }
    while((_Bool)1);
    if(found == 0)
    {
      maps_close(&mi);
      return -1;
    }

    else
    {
      if(!(path == ((char *)NULL)))
        strncpy(path, mi.path, pathlen);

      rc=elf_map_image(ei, mi.path);
      maps_close(&mi);
      return rc;
    }
  }
}

// _Ux86_64_get_fpreg
// file mi/Gget_fpreg.c line 29
extern signed int _Ux86_64_get_fpreg(struct unw_cursor *cursor, signed int regnum, long double *valp)
{
  struct cursor *c = (struct cursor *)cursor;
  signed int return_value__Ux86_64_access_fpreg_1;
  return_value__Ux86_64_access_fpreg_1=_Ux86_64_access_fpreg(c, regnum, valp, 0);
  return return_value__Ux86_64_access_fpreg_1;
}

// _Ux86_64_get_proc_info
// file x86_64/Gget_proc_info.c line 31
extern signed int _Ux86_64_get_proc_info(struct unw_cursor *cursor, struct unw_proc_info *pi)
{
  struct cursor *c = (struct cursor *)cursor;
  signed int return_value__Ux86_64_dwarf_make_proc_info_1;
  return_value__Ux86_64_dwarf_make_proc_info_1=_Ux86_64_dwarf_make_proc_info(&c->dwarf);
  if(!(return_value__Ux86_64_dwarf_make_proc_info_1 >= 0))
  {
    memset((void *)pi, 0, sizeof(struct unw_proc_info) /*64ul*/ );
    pi->start_ip = c->dwarf.ip;
    pi->end_ip = c->dwarf.ip + (unsigned long int)1;
    return 0;
  }

  else
  {
    *pi = c->dwarf.pi;
    return 0;
  }
}

// _Ux86_64_get_proc_info_by_ip
// file mi/Gget_proc_info_by_ip.c line 29
extern signed int _Ux86_64_get_proc_info_by_ip(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, void *as_arg)
{
  struct unw_accessors *a;
  a=_Ux86_64_get_accessors(as);
  signed int ret;
  ret=_Ux86_64_Ifind_dynamic_proc_info(as, ip, pi, 0, as_arg);
  if(ret == -10)
    ret=a->find_proc_info(as, ip, pi, 0, as_arg);

  return ret;
}

// _Ux86_64_get_proc_name
// file mi/Gget_proc_name.c line 99
extern signed int _Ux86_64_get_proc_name(struct unw_cursor *cursor, char *buf, unsigned long int buf_len, unsigned long int *offp)
{
  struct cursor *c = (struct cursor *)cursor;
  signed int return_value_get_proc_name_1;
  return_value_get_proc_name_1=get_proc_name(c->dwarf.as, c->dwarf.ip, buf, buf_len, offp, c->dwarf.as_arg);
  return return_value_get_proc_name_1;
}

// _Ux86_64_get_reg
// file ../include/libunwind-common.h line 246
extern signed int _Ux86_64_get_reg(struct unw_cursor *cursor, signed int regnum, unsigned long int *valp)
{
  struct cursor *c = (struct cursor *)cursor;
  if(regnum == 16)
  {
    *valp = c->dwarf.ip;
    return 0;
  }

  else
  {
    signed int return_value__Ux86_64_access_reg_1;
    return_value__Ux86_64_access_reg_1=_Ux86_64_access_reg(c, regnum, valp, 0);
    return return_value__Ux86_64_access_reg_1;
  }
}

// _Ux86_64_get_save_loc
// file x86_64/Gget_save_loc.c line 31
extern signed int _Ux86_64_get_save_loc(struct unw_cursor *cursor, signed int reg, struct unw_save_loc *sloc)
{
  struct cursor *c = (struct cursor *)cursor;
  struct dwarf_loc loc = { .val=(unsigned long int)0, .type=(unsigned long int)0 };
  switch(reg)
  {
    case 3:
    {
      loc = c->dwarf.loc[(signed long int)3];
      break;
    }
    case 7:
    {
      loc = c->dwarf.loc[(signed long int)7];
      break;
    }
    case 6:
    {
      loc = c->dwarf.loc[(signed long int)6];
      break;
    }
    case 12:
    {
      loc = c->dwarf.loc[(signed long int)12];
      break;
    }
    case 13:
    {
      loc = c->dwarf.loc[(signed long int)13];
      break;
    }
    case 14:
    {
      loc = c->dwarf.loc[(signed long int)14];
      break;
    }
    case 15:
      loc = c->dwarf.loc[(signed long int)15];
  }
  memset((void *)sloc, 0, sizeof(struct unw_save_loc) /*16ul*/ );
  _Bool tmp_statement_expression_1;
  struct dwarf_loc _l = loc;
  tmp_statement_expression_1 = _l.val == (unsigned long int)0 && _l.type == (unsigned long int)0;
  if(tmp_statement_expression_1)
  {
    sloc->type = (enum unw_save_loc_type)UNW_SLT_NONE;
    return 0;
  }

  else
  {
    if(!((2ul & loc.type) == 0ul))
    {
      sloc->type = (enum unw_save_loc_type)UNW_SLT_REG;
      sloc->u.regnum = (signed int)loc.val;
    }

    else
    {
      sloc->type = (enum unw_save_loc_type)UNW_SLT_MEMORY;
      sloc->u.addr = loc.val;
    }
    return 0;
  }
}

// _Ux86_64_handle_signal_frame
// file x86_64/Gos-linux.c line 89
extern signed int _Ux86_64_handle_signal_frame(struct unw_cursor *cursor)
{
  return -UNW_EBADFRAME;
}

// _Ux86_64_init
// file ../include/tdep-x86_64/libunwind_i.h line 225
extern void _Ux86_64_init(void)
{
  struct anonymous_8 saved_mask;
  sigfillset(&_UIx86_64_full_mask);
  do
  {
    sigprocmask(2, &_UIx86_64_full_mask, &saved_mask);
    pthread_mutex_lock(&_Ux86_64_lock);
  }
  while((_Bool)0);
  if(_Ux86_64_init_done == 0)
  {
    _UIx86_64_mi_init();
    _Ux86_64_dwarf_init();
    _Ux86_64_init_mem_validate();
    _Ux86_64_local_addr_space_init();
    _Ux86_64_init_done = 1;
  }


out:
  ;
  do
  {
    pthread_mutex_unlock(&_Ux86_64_lock);
    sigprocmask(2, &saved_mask, (struct anonymous_8 *)(void *)0);
  }
  while((_Bool)0);
}

// _Ux86_64_init_local
// file ../include/libunwind-common.h line 239
extern signed int _Ux86_64_init_local(struct unw_cursor *cursor, struct ucontext *uc)
{
  struct cursor *c = (struct cursor *)cursor;
  if(_Ux86_64_init_done == 0)
    _Ux86_64_init();

  c->dwarf.as = _Ux86_64_local_addr_space;
  c->dwarf.as_arg = (void *)c;
  c->uc = uc;
  c->validate = 0;
  signed int return_value_common_init_1;
  return_value_common_init_1=common_init(c, (unsigned int)1);
  return return_value_common_init_1;
}

// _Ux86_64_init_mem_validate
// file ../include/tdep-x86_64/libunwind_i.h line 226
extern void _Ux86_64_init_mem_validate(void)
{
  unsigned char present = (unsigned char)1;
  signed int return_value_mincore_1;
  return_value_mincore_1=mincore((void *)&present, (unsigned long int)1, &present);
  if(return_value_mincore_1 == 0)
    mem_validate_func = mincore_validate;

  else
    mem_validate_func = msync_validate;
}

// _Ux86_64_init_remote
// file x86_64/Ginit_remote.c line 32
extern signed int _Ux86_64_init_remote(struct unw_cursor *cursor, struct unw_addr_space *as, void *as_arg)
{
  struct cursor *c = (struct cursor *)cursor;
  if(_Ux86_64_init_done == 0)
    _Ux86_64_init();

  c->dwarf.as = as;
  if(as == _Ux86_64_local_addr_space)
  {
    c->dwarf.as_arg = (void *)c;
    c->uc = (struct ucontext *)as_arg;
  }

  else
  {
    c->dwarf.as_arg = as_arg;
    c->uc = (struct ucontext *)(void *)0;
  }
  signed int return_value_common_init_1;
  return_value_common_init_1=common_init_link1(c, (unsigned int)0);
  return return_value_common_init_1;
}

// _Ux86_64_is_fpreg
// file x86_64/is_fpreg.c line 31
extern signed int _Ux86_64_is_fpreg(signed int regnum)
{
  return 0;
}

// _Ux86_64_is_signal_frame
// file x86_64/Gos-linux.c line 82
extern signed int _Ux86_64_is_signal_frame(struct unw_cursor *cursor)
{
  struct cursor *c = (struct cursor *)cursor;
  return (signed int)((signed int)c->sigcontext_format != X86_64_SCF_NONE);
}

// _Ux86_64_local_addr_space_init
// file x86_64/unwind_i.h line 79
extern void _Ux86_64_local_addr_space_init(void)
{
  memset((void *)&local_addr_space, 0, sizeof(struct unw_addr_space) /*43664ul*/ );
  local_addr_space.caching_policy = (enum anonymous_10)UNW_CACHE_GLOBAL;
  local_addr_space.acc.find_proc_info = _Ux86_64_dwarf_find_proc_info;
  local_addr_space.acc.put_unwind_info = put_unwind_info;
  local_addr_space.acc.get_dyn_info_list_addr = get_dyn_info_list_addr;
  local_addr_space.acc.access_mem = access_mem;
  local_addr_space.acc.access_reg = access_reg;
  local_addr_space.acc.access_fpreg = access_fpreg;
  local_addr_space.acc.resume = _Ux86_64_local_resume;
  local_addr_space.acc.get_proc_name = get_static_proc_name;
  _Ux86_64_flush_cache(&local_addr_space, (unsigned long int)0, (unsigned long int)0);
  memset((void *)last_good_addr, 0, sizeof(unsigned long int) /*8ul*/  * (unsigned long int)4);
  lga_victim = 0;
}

// _Ux86_64_local_resume
// file x86_64/Gresume.c line 36
inline signed int _Ux86_64_local_resume(struct unw_addr_space *as, struct unw_cursor *cursor, void *arg)
{
  struct cursor *c = (struct cursor *)cursor;
  struct ucontext *uc = c->uc;
  _Ux86_64_dwarf_make_proc_info(&c->dwarf);
  if(!((signed int)c->sigcontext_format == X86_64_SCF_NONE))
  {
    _Ux86_64_sigreturn(cursor);
    abort();
  }

  else
    _Ux86_64_setcontext(uc);
  return -UNW_EINVAL;
}

// _Ux86_64_r_uc_addr
// file x86_64/Gos-linux.c line 106
extern void * _Ux86_64_r_uc_addr(struct ucontext *uc, signed int reg)
{
  void *addr;
  switch(reg)
  {
    case 8:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)0];
      break;
    }
    case 9:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)1];
      break;
    }
    case 10:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)2];
      break;
    }
    case 11:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)3];
      break;
    }
    case 12:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)4];
      break;
    }
    case 13:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)5];
      break;
    }
    case 14:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)6];
      break;
    }
    case 15:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)7];
      break;
    }
    case 5:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)8];
      break;
    }
    case 4:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)9];
      break;
    }
    case 6:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)10];
      break;
    }
    case 3:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)11];
      break;
    }
    case 1:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)12];
      break;
    }
    case 0:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)13];
      break;
    }
    case 2:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)14];
      break;
    }
    case 7:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)15];
      break;
    }
    case 16:
    {
      addr = (void *)&uc->uc_mcontext.gregs[(signed long int)16];
      break;
    }
    default:
      addr = (void *)0;
  }
  return addr;
}

// _Ux86_64_regname
// file x86_64/regname.c line 50
extern const char * _Ux86_64_regname(signed int reg)
{
  if(!(reg >= 17))
    return regname[(signed long int)reg];

  else
    return "???";
}

// _Ux86_64_resume
// file x86_64/Gresume.c line 102
extern signed int _Ux86_64_resume(struct unw_cursor *cursor)
{
  struct cursor *c = (struct cursor *)cursor;
  signed int ret;
  ret=establish_machine_state(c);
  if(!(ret >= 0))
    return ret;

  else
  {
    signed int return_value;
    return_value=c->dwarf.as->acc.resume(c->dwarf.as, (struct unw_cursor *)c, c->dwarf.as_arg);
    return return_value;
  }
}

// _Ux86_64_reuse_frame
// file x86_64/Gos-linux.c line 61
extern void _Ux86_64_reuse_frame(struct dwarf_cursor *dw, struct dwarf_reg_state *rs)
{
  struct cursor *c = (struct cursor *)dw;
  c->sigcontext_format = (enum anonymous_2)rs->signal_frame;
  if((signed int)c->sigcontext_format == X86_64_SCF_LINUX_RT_SIGFRAME)
  {
    c->frame_info.frame_type = (signed long int)-1;
    c->frame_info.cfa_reg_offset = (signed long int)0;
    c->sigcontext_addr = dw->cfa;
  }

  else
    c->sigcontext_addr = (unsigned long int)0;
}

// _Ux86_64_set_caching_policy
// file ../include/libunwind-common.h line 236
extern signed int _Ux86_64_set_caching_policy(struct unw_addr_space *as, enum anonymous_10 policy)
{
  if(_Ux86_64_init_done == 0)
    _Ux86_64_init();

  if((signed int)policy == UNW_CACHE_PER_THREAD)
    policy = (enum anonymous_10)UNW_CACHE_GLOBAL;

  if(policy == as->caching_policy)
    return 0;

  else
  {
    as->caching_policy = policy;
    _Ux86_64_flush_cache(as, (unsigned long int)0, (unsigned long int)0);
    return 0;
  }
}

// _Ux86_64_set_fpreg
// file mi/Gset_fpreg.c line 29
extern signed int _Ux86_64_set_fpreg(struct unw_cursor *cursor, signed int regnum, long double val)
{
  struct cursor *c = (struct cursor *)cursor;
  signed int return_value__Ux86_64_access_fpreg_1;
  return_value__Ux86_64_access_fpreg_1=_Ux86_64_access_fpreg(c, regnum, &val, 1);
  return return_value__Ux86_64_access_fpreg_1;
}

// _Ux86_64_set_reg
// file mi/Gset_reg.c line 29
extern signed int _Ux86_64_set_reg(struct unw_cursor *cursor, signed int regnum, unsigned long int valp)
{
  struct cursor *c = (struct cursor *)cursor;
  signed int return_value__Ux86_64_access_reg_1;
  return_value__Ux86_64_access_reg_1=_Ux86_64_access_reg(c, regnum, &valp, 1);
  return return_value__Ux86_64_access_reg_1;
}

// _Ux86_64_sigreturn
// file x86_64/Gos-linux.c line 139
extern void _Ux86_64_sigreturn(struct unw_cursor *cursor)
{
  struct cursor *c = (struct cursor *)cursor;
  struct sigcontext *sc = (struct sigcontext *)c->sigcontext_addr;
  asm("mov %0, %%rsp;mov %1, %%rax;syscall" :  : "r"(sc), "i"(15) : "memory");
  abort();
}

// _Ux86_64_stash_frame
// file x86_64/Gstash_frame.c line 29
extern void _Ux86_64_stash_frame(struct dwarf_cursor *d, struct dwarf_reg_state *rs)
{
  struct cursor *c = (struct cursor *)(struct unw_cursor *)d;
  struct anonymous_5 *f = &c->frame_info;
  _Bool tmp_if_expr_1;
  if((signed long int)f->frame_type == 0l)
    tmp_if_expr_1 = (signed int)rs->reg[(signed long int)17].where == DWARF_WHERE_REG ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
  {
    if(rs->reg[17l].val == 6ul)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = rs->reg[(signed long int)17].val == (unsigned long int)7 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_5;
  signed long int return_value_labs_4;
  if(tmp_if_expr_3)
  {
    return_value_labs_4=labs((signed long int)rs->reg[(signed long int)(17 + 1)].val);
    tmp_if_expr_5 = return_value_labs_4 < (signed long int)(1 << 29) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_5)
    tmp_if_expr_6 = d->loc[(signed long int)d->ret_addr_column].val == d->cfa - (unsigned long int)8 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_9;
  signed long int return_value_labs_8;
  _Bool tmp_if_expr_10;
  if(tmp_if_expr_6)
  {
    if((signed int)rs->reg[6l].where == DWARF_WHERE_UNDEF)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)rs->reg[(signed long int)6].where == DWARF_WHERE_SAME ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      if((signed int)rs->reg[6l].where == DWARF_WHERE_CFAREL)
      {
        return_value_labs_8=labs((signed long int)rs->reg[(signed long int)6].val);
        tmp_if_expr_9 = return_value_labs_8 < (signed long int)(1 << 14) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_9 = (_Bool)0;
      if(tmp_if_expr_9)
        tmp_if_expr_10 = rs->reg[(signed long int)6].val + (unsigned long int)1 != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_10 = (_Bool)0;
      tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_12 = (_Bool)0;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_15;
  signed long int return_value_labs_14;
  _Bool tmp_if_expr_16;
  if(tmp_if_expr_12)
  {
    if((signed int)rs->reg[7l].where == DWARF_WHERE_UNDEF)
      tmp_if_expr_13 = (_Bool)1;

    else
      tmp_if_expr_13 = (signed int)rs->reg[(signed long int)7].where == DWARF_WHERE_SAME ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_13)
      tmp_if_expr_17 = (_Bool)1;

    else
    {
      if((signed int)rs->reg[7l].where == DWARF_WHERE_CFAREL)
      {
        return_value_labs_14=labs((signed long int)rs->reg[(signed long int)7].val);
        tmp_if_expr_15 = return_value_labs_14 < (signed long int)(1 << 14) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_15 = (_Bool)0;
      if(tmp_if_expr_15)
        tmp_if_expr_16 = rs->reg[(signed long int)7].val + (unsigned long int)1 != (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_16 = (_Bool)0;
      tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_18 = (_Bool)0;
  if(tmp_if_expr_18)
  {
    f->frame_type = (signed long int)-2;
    f->cfa_reg_rsp = (signed long int)(rs->reg[(signed long int)17].val == (unsigned long int)7);
    f->cfa_reg_offset = (signed long int)rs->reg[(signed long int)(17 + 1)].val;
    if((signed int)rs->reg[6l].where == DWARF_WHERE_CFAREL)
      f->rbp_cfa_offset = (signed long int)rs->reg[(signed long int)6].val;

    if((signed int)rs->reg[7l].where == DWARF_WHERE_CFAREL)
      f->rsp_cfa_offset = (signed long int)rs->reg[(signed long int)7].val;

  }

}

// _Ux86_64_step
// file ../include/libunwind-common.h line 241
extern signed int _Ux86_64_step(struct unw_cursor *cursor)
{
  struct cursor *c = (struct cursor *)cursor;
  signed int ret;
  signed int i;
  signed int val = c->validate;
  c->validate = 1;
  c->sigcontext_format = (enum anonymous_2)X86_64_SCF_NONE;
  ret=_Ux86_64_dwarf_step(&c->dwarf);
  c->validate = val;
  _Bool tmp_statement_expression_1;
  signed int return_value_is_plt_entry_5;
  _Bool tmp_statement_expression_4;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_statement_expression_7;
  _Bool tmp_statement_expression_8;
  if(!(ret == -10) && !(ret >= 0))
    return ret;

  else
  {
    if(ret >= 0)
    {
      struct dwarf_loc _Ux86_64_step__1__2__1___l = c->dwarf.loc[(signed long int)6];
      tmp_statement_expression_1 = _Ux86_64_step__1__2__1___l.val == (unsigned long int)0 && _Ux86_64_step__1__2__1___l.type == (unsigned long int)0;
      if(tmp_statement_expression_1)
      {
        c->dwarf.ip = (unsigned long int)0;
        ret = 0;
      }

    }

    else
    {
      unsigned long int prev_ip = c->dwarf.ip;
      unsigned long int prev_cfa = c->dwarf.cfa;
      struct dwarf_loc rbp_loc;
      struct dwarf_loc rsp_loc;
      struct dwarf_loc rip_loc;
      c->validate = 1;
      signed int return_value__Ux86_64_is_signal_frame_6;
      return_value__Ux86_64_is_signal_frame_6=_Ux86_64_is_signal_frame(cursor);
      if(!(return_value__Ux86_64_is_signal_frame_6 == 0))
      {
        ret=_Ux86_64_handle_signal_frame(cursor);
        if(!(ret >= 0))
          return 0;

      }

      else
      {
        return_value_is_plt_entry_5=is_plt_entry(&c->dwarf);
        if(!(return_value_is_plt_entry_5 == 0))
        {
          c->frame_info.cfa_reg_offset = (signed long int)8;
          c->frame_info.cfa_reg_rsp = (signed long int)-1;
          c->frame_info.frame_type = (signed long int)-2;
          c->dwarf.loc[(signed long int)16] = (struct dwarf_loc){ .val=c->dwarf.cfa, .type=(unsigned long int)0 };
          c->dwarf.cfa = c->dwarf.cfa + (unsigned long int)8;
        }

        else
        {
          struct dwarf_loc _Ux86_64_step__1__3__3___l = c->dwarf.loc[(signed long int)6];
          tmp_statement_expression_4 = _Ux86_64_step__1__3__3___l.val == (unsigned long int)0 && _Ux86_64_step__1__3__3___l.type == (unsigned long int)0;
          if(tmp_statement_expression_4)
          {
            i = 0;
            for( ; !(i >= 17); i = i + 1)
              c->dwarf.loc[(signed long int)i] = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
          }

          else
          {
            unsigned long int rbp;
            ret=dwarf_get_link3(&c->dwarf, c->dwarf.loc[(signed long int)6], &rbp);
            if(!(ret >= 0))
              return ret;

            if(rbp == 0ul)
            {
              rbp_loc = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
              rsp_loc = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
              rip_loc = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
            }

            else
            {
              unsigned long int rbp1 = (unsigned long int)0;
              rbp_loc = (struct dwarf_loc){ .val=rbp, .type=(unsigned long int)0 };
              rsp_loc = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
              rip_loc = (struct dwarf_loc){ .val=rbp + (unsigned long int)8, .type=(unsigned long int)0 };
              ret=dwarf_get_link3(&c->dwarf, rbp_loc, &rbp1);
              if(!(ret >= 0))
                tmp_if_expr_2 = (_Bool)1;

              else
                tmp_if_expr_2 = rbp <= c->dwarf.cfa ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_2)
                tmp_if_expr_3 = (_Bool)1;

              else
                tmp_if_expr_3 = rbp - c->dwarf.cfa > (unsigned long int)0x4000 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_3)
              {
                rip_loc = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
                rbp_loc = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
              }

              c->frame_info.frame_type = (signed long int)1;
              c->frame_info.cfa_reg_rsp = (signed long int)0;
              c->frame_info.cfa_reg_offset = (signed long int)16;
              c->frame_info.rbp_cfa_offset = (signed long int)-16;
              c->dwarf.cfa = c->dwarf.cfa + (unsigned long int)16;
            }
            i = 0;
            for( ; !(i >= 17); i = i + 1)
              c->dwarf.loc[(signed long int)i] = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
            c->dwarf.loc[(signed long int)6] = rbp_loc;
            c->dwarf.loc[(signed long int)7] = rsp_loc;
            c->dwarf.loc[(signed long int)16] = rip_loc;
          }
        }
      }
      c->dwarf.ret_addr_column = (unsigned long int)16;
      struct dwarf_loc _l = c->dwarf.loc[(signed long int)6];
      tmp_statement_expression_7 = _l.val == (unsigned long int)0 && _l.type == (unsigned long int)0;
      if(tmp_statement_expression_7)
      {
        ret = 0;
        return ret;
      }

      struct dwarf_loc _Ux86_64_step__1__3__8___l = c->dwarf.loc[(signed long int)16];
      tmp_statement_expression_8 = _Ux86_64_step__1__3__8___l.val == (unsigned long int)0 && _Ux86_64_step__1__3__8___l.type == (unsigned long int)0;
      if(!tmp_statement_expression_8)
      {
        ret=dwarf_get_link3(&c->dwarf, c->dwarf.loc[(signed long int)16], &c->dwarf.ip);
        if(!(ret >= 0))
          return ret;

        ret = 1;
      }

      else
        c->dwarf.ip = (unsigned long int)0;
      if(c->dwarf.ip == prev_ip)
      {
        if(c->dwarf.cfa == prev_cfa)
          return -UNW_EBADFRAME;

      }

    }
    return ret;
  }
}

// _Ux86_64_strerror
// file mi/strerror.c line 31
extern const char * _Ux86_64_strerror(signed int err_code)
{
  const char *cp;
  enum anonymous_1 error = (enum anonymous_1)-err_code;
  switch((signed int)error)
  {
    case UNW_ESUCCESS:
    {
      cp = "no error";
      break;
    }
    case UNW_EUNSPEC:
    {
      cp = "unspecified (general) error";
      break;
    }
    case UNW_ENOMEM:
    {
      cp = "out of memory";
      break;
    }
    case UNW_EBADREG:
    {
      cp = "bad register number";
      break;
    }
    case UNW_EREADONLYREG:
    {
      cp = "attempt to write read-only register";
      break;
    }
    case UNW_ESTOPUNWIND:
    {
      cp = "stop unwinding";
      break;
    }
    case UNW_EINVALIDIP:
    {
      cp = "invalid IP";
      break;
    }
    case UNW_EBADFRAME:
    {
      cp = "bad frame";
      break;
    }
    case UNW_EINVAL:
    {
      cp = "unsupported operation or bad value";
      break;
    }
    case UNW_EBADVERSION:
    {
      cp = "unwind info has unsupported version";
      break;
    }
    case UNW_ENOINFO:
    {
      cp = "no unwind info found";
      break;
    }
    default:
      cp = "invalid error code";
  }
  return cp;
}

// _Ux86_64_tdep_trace
// file x86_64/Gtrace.c line 397
extern signed int _Ux86_64_tdep_trace(struct unw_cursor *cursor, void **buffer, signed int *size)
{
  struct cursor *c = (struct cursor *)cursor;
  struct dwarf_cursor *d = &c->dwarf;
  struct anonymous_6 *cache;
  unsigned long int rbp;
  unsigned long int rsp;
  unsigned long int rip;
  unsigned long int cfa;
  signed int maxdepth = 0;
  signed int depth = 0;
  signed int ret;
  _Bool tmp_if_expr_1;
  if(buffer == ((void **)NULL) || size == ((signed int *)NULL) || cursor == ((struct unw_cursor *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    maxdepth = *size;
    tmp_if_expr_1 = maxdepth <= 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int tmp_post_2;
  if(tmp_if_expr_1)
    return -UNW_EINVAL;

  else
  {
    d->stash_frames = (unsigned int)1;
    rip = d->ip;
    cfa = d->cfa;
    rsp = cfa;
    do
      ret=dwarf_get_link4(d, (struct dwarf_loc){ .val=d->loc[(signed long int)6].val, .type=(unsigned long int)0 }, &rbp);
    while((_Bool)0);
    cache=trace_cache_get();
    if(cache == ((struct anonymous_6 *)NULL))
    {
      *size = 0;
      d->stash_frames = (unsigned int)0;
      return -UNW_ENOMEM;
    }

    else
    {
      while(!(depth >= maxdepth))
      {
        rip = rip - (unsigned long int)d->use_prev_instr;
        struct anonymous_5 *f;
        f=trace_lookup(cursor, cache, cfa, rip, rbp, rsp);
        if(f == ((struct anonymous_5 *)NULL))
        {
          ret = -UNW_ENOINFO;
          break;
        }

        if(!(f->last_frame == 0l))
          break;

        switch((signed long int)f->frame_type)
        {
          case (signed long int)1:
            c->validate = 1;
          case (signed long int)-2:
          {
            cfa = (f->cfa_reg_rsp != 0l ? rsp : rbp) + (unsigned long int)f->cfa_reg_offset;
            do
              ret=dwarf_get_link4(d, (struct dwarf_loc){ .val=cfa - (unsigned long int)8, .type=(unsigned long int)0 }, &rip);
            while((_Bool)0);
            if(ret >= 0)
            {
              if(!((signed long int)f->rbp_cfa_offset == -1l))
                do
                  ret=dwarf_get_link4(d, (struct dwarf_loc){ .val=cfa + (unsigned long int)f->rbp_cfa_offset, .type=(unsigned long int)0 }, &rbp);
                while((_Bool)0);

            }

            rsp = cfa;
            d->use_prev_instr = (unsigned int)1;
            break;
          }
          case (signed long int)-1:
          {
            cfa = cfa + (unsigned long int)f->cfa_reg_offset;
            do
              ret=dwarf_get_link4(d, (struct dwarf_loc){ .val=cfa + (unsigned long int)0xa8, .type=(unsigned long int)0 }, &rip);
            while((_Bool)0);
            if(ret >= 0)
              do
                ret=dwarf_get_link4(d, (struct dwarf_loc){ .val=cfa + (unsigned long int)0x78, .type=(unsigned long int)0 }, &rbp);
              while((_Bool)0);

            if(ret >= 0)
              do
                ret=dwarf_get_link4(d, (struct dwarf_loc){ .val=cfa + (unsigned long int)0xa0, .type=(unsigned long int)0 }, &rsp);
              while((_Bool)0);

            cfa = rsp;
            d->use_prev_instr = (unsigned int)0;
            break;
          }
          default:
            ret = -UNW_ESTOPUNWIND;
        }
        if(!(ret >= 0) || !(rip >= 16384ul))
          break;

        tmp_post_2 = depth;
        depth = depth + 1;
        buffer[(signed long int)tmp_post_2] = (void *)(rip - (unsigned long int)d->use_prev_instr);
      }
      *size = depth;
      return ret;
    }
  }
}

// access_fpreg
// file x86_64/Ginit.c line 210
static signed int access_fpreg(struct unw_addr_space *as, signed int reg, long double *val, signed int write, void *arg)
{
  struct ucontext *uc = ((struct cursor *)arg)->uc;
  long double *addr;
  signed int return_value__Ux86_64_is_fpreg_1;
  return_value__Ux86_64_is_fpreg_1=_Ux86_64_is_fpreg(reg);
  void *return_value__Ux86_64_r_uc_addr_2;
  if(!(return_value__Ux86_64_is_fpreg_1 == 0))
  {
    return_value__Ux86_64_r_uc_addr_2=_Ux86_64_r_uc_addr(uc, reg);
    addr = (long double *)return_value__Ux86_64_r_uc_addr_2;
    if(addr == ((long double *)NULL))
      goto badreg;

    if(!(write == 0))
      *((long double *)addr) = *val;

    else
      *val = *((long double *)addr);
    return 0;
  }

  else
  {

  badreg:
    ;
    return -UNW_EBADREG;
  }
}

// access_mem
// file x86_64/Ginit.c line 158
static signed int access_mem(struct unw_addr_space *as, unsigned long int addr, unsigned long int *val, signed int write, void *arg)
{
  signed int return_value_validate_mem_1;
  if(!((signed long int)write == 0l))
    *((unsigned long int *)addr) = *val;

  else
  {
    struct cursor *c = (struct cursor *)arg;
    if(!(c == ((struct cursor *)NULL)))
    {
      if(!((signed long int)c->validate == 0l))
      {
        return_value_validate_mem_1=validate_mem(addr);
        if(!((signed long int)return_value_validate_mem_1 == 0l))
          return -1;

      }

    }

    *val = *((unsigned long int *)addr);
  }
  return 0;
}

// access_reg
// file x86_64/Ginit.c line 180
static signed int access_reg(struct unw_addr_space *as, signed int reg, unsigned long int *val, signed int write, void *arg)
{
  unsigned long int *addr;
  struct ucontext *uc = ((struct cursor *)arg)->uc;
  signed int return_value__Ux86_64_is_fpreg_1;
  return_value__Ux86_64_is_fpreg_1=_Ux86_64_is_fpreg(reg);
  void *return_value__Ux86_64_r_uc_addr_2;
  if(return_value__Ux86_64_is_fpreg_1 == 0)
  {
    return_value__Ux86_64_r_uc_addr_2=_Ux86_64_r_uc_addr(uc, reg);
    addr = (unsigned long int *)return_value__Ux86_64_r_uc_addr_2;
    if(addr == ((unsigned long int *)NULL))
      goto badreg;

    if(!(write == 0))
      *((unsigned long int *)addr) = *val;

    else
      *val = *((unsigned long int *)addr);
    return 0;
  }

  else
  {

  badreg:
    ;
    return -UNW_EBADREG;
  }
}

// add_memory
// file mi/mempool.c line 96
static void add_memory(struct mempool *pool, char *mem, unsigned long int size, unsigned long int obj_size)
{
  char *obj = mem;
  for( ; mem + (signed long int)size + -((signed long int)obj_size) >= obj; obj = obj + (signed long int)obj_size)
    free_object(pool, (void *)obj);
}

// apply_reg_state
// file dwarf/Gparser.c line 713
static signed int apply_reg_state(struct dwarf_cursor *c, struct dwarf_reg_state *rs)
{
  unsigned long int regnum;
  unsigned long int addr;
  unsigned long int cfa;
  unsigned long int ip;
  unsigned long int prev_ip;
  unsigned long int prev_cfa;
  struct unw_addr_space *as;
  struct dwarf_loc cfa_loc;
  struct unw_accessors *a;
  signed int i;
  signed int ret;
  void *arg;
  prev_ip = c->ip;
  prev_cfa = c->cfa;
  as = c->as;
  arg = c->as_arg;
  a=_Ux86_64_get_accessors(as);
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if((signed int)rs->reg[17l].where == DWARF_WHERE_REG)
  {
    if(rs->reg[17l].val == 7ul)
      tmp_if_expr_2 = (signed int)rs->reg[(signed long int)7].where == DWARF_WHERE_SAME ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      cfa = c->cfa;

    else
    {
      if(!(rs->reg[17l].val >= 17ul))
        tmp_if_expr_1 = (signed int)_Ux86_64_dwarf_to_unw_regnum_map[(signed long int)rs->reg[(signed long int)17].val];

      else
        tmp_if_expr_1 = 0;
      regnum = (unsigned long int)tmp_if_expr_1;
      ret=_Ux86_64_get_reg((struct unw_cursor *)c, (signed int)regnum, &cfa);
      if(!(ret >= 0))
        return ret;

    }
    cfa = cfa + rs->reg[(signed long int)(17 + 1)].val;
  }

  else
  {
    addr = rs->reg[(signed long int)17].val;
    ret=eval_location_expr(c, as, a, addr, &cfa_loc, arg);
    if(!(ret >= 0))
      return ret;

    if(!((2ul & cfa_loc.type) == 0ul))
      return -UNW_EBADFRAME;

    cfa = cfa_loc.val;
  }
  i = 0;
  signed int tmp_if_expr_3;
  while(!(i >= 17))
    switch((signed int)(enum anonymous_13)rs->reg[(signed long int)i].where)
    {
      case DWARF_WHERE_UNDEF:
      {
        c->loc[(signed long int)i] = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)0 };
        goto __CPROVER_DUMP_L19;
      }
      case DWARF_WHERE_SAME:
        goto __CPROVER_DUMP_L19;
      case DWARF_WHERE_CFAREL:
      {
        c->loc[(signed long int)i] = (struct dwarf_loc){ .val=cfa + rs->reg[(signed long int)i].val, .type=(unsigned long int)0 };
        goto __CPROVER_DUMP_L19;
      }
      case DWARF_WHERE_REG:
      {
        if(!(rs->reg[(signed long int)i].val >= 17ul))
          tmp_if_expr_3 = (signed int)_Ux86_64_dwarf_to_unw_regnum_map[(signed long int)rs->reg[(signed long int)i].val];

        else
          tmp_if_expr_3 = 0;
        c->loc[(signed long int)i] = (struct dwarf_loc){ .val=(unsigned long int)tmp_if_expr_3, .type=(unsigned long int)(1 << 1) };
        goto __CPROVER_DUMP_L19;
      }
      case DWARF_WHERE_EXPR:
      {
        addr = rs->reg[(signed long int)i].val;
        ret=eval_location_expr(c, as, a, addr, c->loc + (signed long int)i, arg);
        if(!(ret >= 0))
          return ret;

      }
      default:
      {

      __CPROVER_DUMP_L19:
        ;
        i = i + 1;
      }
    }
  c->cfa = cfa;
  _Bool tmp_statement_expression_4;
  struct dwarf_loc _l = c->loc[(signed long int)c->ret_addr_column];
  tmp_statement_expression_4 = _l.val == (unsigned long int)0 && _l.type == (unsigned long int)0;
  if(tmp_statement_expression_4)
    c->ip = (unsigned long int)0;

  else
  {
    ret=dwarf_get_link5(c, c->loc[(signed long int)c->ret_addr_column], &ip);
    if(!(ret >= 0))
      return ret;

    c->ip = ip;
  }
  if(c->ip == prev_ip)
  {
    if(!(c->cfa == prev_cfa))
      goto __CPROVER_DUMP_L24;

    return -UNW_EBADFRAME;
  }

  else
  {

  __CPROVER_DUMP_L24:
    ;
    if(!(c->stash_frames == 0u))
      _Ux86_64_stash_frame(c, rs);

    return 0;
  }
}

// cache_match
// file dwarf/Gparser.c line 564
static inline signed long int cache_match(struct dwarf_reg_state *rs, unsigned long int ip)
{
  if(!(rs->valid == 0))
  {
    if(!(ip == rs->ip))
      goto __CPROVER_DUMP_L1;

    return (signed long int)1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (signed long int)0;
  }
}

// common_init
// file x86_64/init.h line 45
static inline signed int common_init(struct cursor *c, unsigned int use_prev_instr)
{
  signed int ret;
  c->dwarf.loc[(signed long int)0] = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)1] = (struct dwarf_loc){ .val=(unsigned long int)1, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)2] = (struct dwarf_loc){ .val=(unsigned long int)2, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)3] = (struct dwarf_loc){ .val=(unsigned long int)3, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)4] = (struct dwarf_loc){ .val=(unsigned long int)4, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)5] = (struct dwarf_loc){ .val=(unsigned long int)5, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)6] = (struct dwarf_loc){ .val=(unsigned long int)6, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)7] = (struct dwarf_loc){ .val=(unsigned long int)7, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)8] = (struct dwarf_loc){ .val=(unsigned long int)8, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)9] = (struct dwarf_loc){ .val=(unsigned long int)9, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)10] = (struct dwarf_loc){ .val=(unsigned long int)10, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)11] = (struct dwarf_loc){ .val=(unsigned long int)11, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)12] = (struct dwarf_loc){ .val=(unsigned long int)12, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)13] = (struct dwarf_loc){ .val=(unsigned long int)13, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)14] = (struct dwarf_loc){ .val=(unsigned long int)14, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)15] = (struct dwarf_loc){ .val=(unsigned long int)15, .type=(unsigned long int)(1 << 1) };
  c->dwarf.loc[(signed long int)16] = (struct dwarf_loc){ .val=(unsigned long int)16, .type=(unsigned long int)(1 << 1) };
  ret=dwarf_get(&c->dwarf, c->dwarf.loc[(signed long int)16], &c->dwarf.ip);
  if(!(ret >= 0))
    return ret;

  else
  {
    ret=dwarf_get(&c->dwarf, (struct dwarf_loc){ .val=(unsigned long int)7, .type=(unsigned long int)(1 << 1) }, &c->dwarf.cfa);
    if(!(ret >= 0))
      return ret;

    else
    {
      c->sigcontext_format = (enum anonymous_2)X86_64_SCF_NONE;
      c->sigcontext_addr = (unsigned long int)0;
      c->dwarf.args_size = (unsigned long int)0;
      c->dwarf.ret_addr_column = (unsigned long int)16;
      c->dwarf.stash_frames = (unsigned int)0;
      c->dwarf.use_prev_instr = use_prev_instr;
      c->dwarf.pi_valid = (unsigned int)0;
      c->dwarf.pi_is_dynamic = (unsigned int)0;
      c->dwarf.hint = (signed short int)0;
      c->dwarf.prev_rs = (signed short int)0;
      return 0;
    }
  }
}

// common_init_link1
// file x86_64/init.h line 45
static inline signed int common_init_link1(struct cursor *c_link1, unsigned int use_prev_instr_link1)
{
  signed int ret_link1;
  c_link1->dwarf.loc[(signed long int)0] = (struct dwarf_loc){ .val=(unsigned long int)0, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)1] = (struct dwarf_loc){ .val=(unsigned long int)1, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)2] = (struct dwarf_loc){ .val=(unsigned long int)2, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)3] = (struct dwarf_loc){ .val=(unsigned long int)3, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)4] = (struct dwarf_loc){ .val=(unsigned long int)4, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)5] = (struct dwarf_loc){ .val=(unsigned long int)5, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)6] = (struct dwarf_loc){ .val=(unsigned long int)6, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)7] = (struct dwarf_loc){ .val=(unsigned long int)7, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)8] = (struct dwarf_loc){ .val=(unsigned long int)8, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)9] = (struct dwarf_loc){ .val=(unsigned long int)9, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)10] = (struct dwarf_loc){ .val=(unsigned long int)10, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)11] = (struct dwarf_loc){ .val=(unsigned long int)11, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)12] = (struct dwarf_loc){ .val=(unsigned long int)12, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)13] = (struct dwarf_loc){ .val=(unsigned long int)13, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)14] = (struct dwarf_loc){ .val=(unsigned long int)14, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)15] = (struct dwarf_loc){ .val=(unsigned long int)15, .type=(unsigned long int)(1 << 1) };
  c_link1->dwarf.loc[(signed long int)16] = (struct dwarf_loc){ .val=(unsigned long int)16, .type=(unsigned long int)(1 << 1) };
  ret_link1=dwarf_get_link1(&c_link1->dwarf, c_link1->dwarf.loc[(signed long int)16], &c_link1->dwarf.ip);
  if(!(ret_link1 >= 0))
    return ret_link1;

  else
  {
    ret_link1=dwarf_get_link1(&c_link1->dwarf, (struct dwarf_loc){ .val=(unsigned long int)7, .type=(unsigned long int)(1 << 1) }, &c_link1->dwarf.cfa);
    if(!(ret_link1 >= 0))
      return ret_link1;

    else
    {
      c_link1->sigcontext_format = (enum anonymous_2)X86_64_SCF_NONE;
      c_link1->sigcontext_addr = (unsigned long int)0;
      c_link1->dwarf.args_size = (unsigned long int)0;
      c_link1->dwarf.ret_addr_column = (unsigned long int)16;
      c_link1->dwarf.stash_frames = (unsigned int)0;
      c_link1->dwarf.use_prev_instr = use_prev_instr_link1;
      c_link1->dwarf.pi_valid = (unsigned int)0;
      c_link1->dwarf.pi_is_dynamic = (unsigned int)0;
      c_link1->dwarf.hint = (signed short int)0;
      c_link1->dwarf.prev_rs = (signed short int)0;
      return 0;
    }
  }
}

// create_state_record_for
// file dwarf/Gparser.c line 659
static signed int create_state_record_for(struct dwarf_cursor *c, struct dwarf_state_record *sr, unsigned long int ip)
{
  signed int i;
  signed int ret;
  memset((void *)sr, 0, sizeof(struct dwarf_state_record) /*688ul*/ );
  i = 0;
  for( ; !(i >= 2); i = i + 1)
    set_reg(sr, (unsigned long int)i, (enum anonymous_13)DWARF_WHERE_SAME, (unsigned long int)0);
  switch(c->pi.format)
  {
    case 1:

    case 2:
    {
      ret=parse_fde(c, ip, sr);
      break;
    }
    case 0:
    {
      ret=parse_dynamic(c, ip, sr);
      break;
    }
    default:
      ret = -UNW_EINVAL;
  }
  return ret;
}

// doit
// file Gtest-concurrent.c line 84
static void doit(void)
{
  unsigned long int th[128l];
  union pthread_attr_t attr;
  signed int i;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, (unsigned long int)(16384 + 64 * 1024));
  i = 0;
  signed int return_value_pthread_create_1;
  for( ; !(i >= 128); i = i + 1)
  {
    return_value_pthread_create_1=pthread_create(th + (signed long int)i, &attr, worker, (void *)0);
    if(!(return_value_pthread_create_1 == 0))
    {
      fprintf(stderr, "FAILURE: Failed to create %u threads (after %u threads)\n", 128, i);
      exit(-1);
    }

  }
  i = 0;
  for( ; !(i >= 128); i = i + 1)
    pthread_join(th[(signed long int)i], (void **)(void *)0);
}

// dwarf_get
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get(struct dwarf_cursor *c, struct dwarf_loc loc, unsigned long int *val)
{
  _Bool tmp_statement_expression_1;
  struct dwarf_loc _l = loc;
  tmp_statement_expression_1 = _l.val == (unsigned long int)0 && _l.type == (unsigned long int)0;
  signed int return_value;
  signed int return_value_1;
  if(tmp_statement_expression_1)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc.type) == 0ul))
    {
      return_value=c->as->acc.access_reg(c->as, (signed int)loc.val, val, 0, c->as_arg);
      return return_value;
    }

    else
    {
      return_value_1=c->as->acc.access_mem(c->as, loc.val, val, 0, c->as_arg);
      return return_value_1;
    }
}

// dwarf_get_link1
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link1(struct dwarf_cursor *c_link1, struct dwarf_loc loc_link1, unsigned long int *val_link1)
{
  _Bool tmp_statement_expression_1_link1;
  struct dwarf_loc _l_link1 = loc_link1;
  tmp_statement_expression_1_link1 = _l_link1.val == (unsigned long int)0 && _l_link1.type == (unsigned long int)0;
  signed int return_value_link1;
  signed int return_value_1_link1;
  if(tmp_statement_expression_1_link1)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc_link1.type) == 0ul))
    {
      return_value_link1=c_link1->as->acc.access_reg(c_link1->as, (signed int)loc_link1.val, val_link1, 0, c_link1->as_arg);
      return return_value_link1;
    }

    else
    {
      return_value_1_link1=c_link1->as->acc.access_mem(c_link1->as, loc_link1.val, val_link1, 0, c_link1->as_arg);
      return return_value_1_link1;
    }
}

// dwarf_get_link2
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link2(struct dwarf_cursor *c_link2, struct dwarf_loc loc_link2, unsigned long int *val_link2)
{
  _Bool tmp_statement_expression_1_link2;
  struct dwarf_loc _l_link2 = loc_link2;
  tmp_statement_expression_1_link2 = _l_link2.val == (unsigned long int)0 && _l_link2.type == (unsigned long int)0;
  signed int return_value_link2;
  signed int return_value_1_link2;
  if(tmp_statement_expression_1_link2)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc_link2.type) == 0ul))
    {
      return_value_link2=c_link2->as->acc.access_reg(c_link2->as, (signed int)loc_link2.val, val_link2, 0, c_link2->as_arg);
      return return_value_link2;
    }

    else
    {
      return_value_1_link2=c_link2->as->acc.access_mem(c_link2->as, loc_link2.val, val_link2, 0, c_link2->as_arg);
      return return_value_1_link2;
    }
}

// dwarf_get_link3
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link3(struct dwarf_cursor *c_link3, struct dwarf_loc loc_link3, unsigned long int *val_link3)
{
  _Bool tmp_statement_expression_1_link3;
  struct dwarf_loc _l_link3 = loc_link3;
  tmp_statement_expression_1_link3 = _l_link3.val == (unsigned long int)0 && _l_link3.type == (unsigned long int)0;
  signed int return_value_link3;
  signed int return_value_1_link3;
  if(tmp_statement_expression_1_link3)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc_link3.type) == 0ul))
    {
      return_value_link3=c_link3->as->acc.access_reg(c_link3->as, (signed int)loc_link3.val, val_link3, 0, c_link3->as_arg);
      return return_value_link3;
    }

    else
    {
      return_value_1_link3=c_link3->as->acc.access_mem(c_link3->as, loc_link3.val, val_link3, 0, c_link3->as_arg);
      return return_value_1_link3;
    }
}

// dwarf_get_link4
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link4(struct dwarf_cursor *c_link4, struct dwarf_loc loc_link4, unsigned long int *val_link4)
{
  _Bool tmp_statement_expression_1_link4;
  struct dwarf_loc _l_link4 = loc_link4;
  tmp_statement_expression_1_link4 = _l_link4.val == (unsigned long int)0 && _l_link4.type == (unsigned long int)0;
  signed int return_value_link4;
  signed int return_value_1_link4;
  if(tmp_statement_expression_1_link4)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc_link4.type) == 0ul))
    {
      return_value_link4=c_link4->as->acc.access_reg(c_link4->as, (signed int)loc_link4.val, val_link4, 0, c_link4->as_arg);
      return return_value_link4;
    }

    else
    {
      return_value_1_link4=c_link4->as->acc.access_mem(c_link4->as, loc_link4.val, val_link4, 0, c_link4->as_arg);
      return return_value_1_link4;
    }
}

// dwarf_get_link5
// file ../include/tdep-x86_64/libunwind_i.h line 153
static inline signed int dwarf_get_link5(struct dwarf_cursor *c_link5, struct dwarf_loc loc_link5, unsigned long int *val_link5)
{
  _Bool tmp_statement_expression_1_link5;
  struct dwarf_loc _l_link5 = loc_link5;
  tmp_statement_expression_1_link5 = _l_link5.val == (unsigned long int)0 && _l_link5.type == (unsigned long int)0;
  signed int return_value_link5;
  signed int return_value_1_link5;
  if(tmp_statement_expression_1_link5)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc_link5.type) == 0ul))
    {
      return_value_link5=c_link5->as->acc.access_reg(c_link5->as, (signed int)loc_link5.val, val_link5, 0, c_link5->as_arg);
      return return_value_link5;
    }

    else
    {
      return_value_1_link5=c_link5->as->acc.access_mem(c_link5->as, loc_link5.val, val_link5, 0, c_link5->as_arg);
      return return_value_1_link5;
    }
}

// dwarf_put
// file ../include/tdep-x86_64/libunwind_i.h line 167
static inline signed int dwarf_put(struct dwarf_cursor *c, struct dwarf_loc loc, unsigned long int val)
{
  _Bool tmp_statement_expression_1;
  struct dwarf_loc _l = loc;
  tmp_statement_expression_1 = _l.val == (unsigned long int)0 && _l.type == (unsigned long int)0;
  signed int return_value;
  signed int return_value_1;
  if(tmp_statement_expression_1)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc.type) == 0ul))
    {
      return_value=c->as->acc.access_reg(c->as, (signed int)loc.val, &val, 1, c->as_arg);
      return return_value;
    }

    else
    {
      return_value_1=c->as->acc.access_mem(c->as, loc.val, &val, 1, c->as_arg);
      return return_value_1;
    }
}

// dwarf_put_link1
// file ../include/tdep-x86_64/libunwind_i.h line 167
static inline signed int dwarf_put_link1(struct dwarf_cursor *c_link1, struct dwarf_loc loc_link1, unsigned long int val_link1)
{
  _Bool tmp_statement_expression_1_link1;
  struct dwarf_loc _l_link1 = loc_link1;
  tmp_statement_expression_1_link1 = _l_link1.val == (unsigned long int)0 && _l_link1.type == (unsigned long int)0;
  signed int return_value_link1;
  signed int return_value_1_link1;
  if(tmp_statement_expression_1_link1)
    return -UNW_EBADREG;

  else
    if(!((2ul & loc_link1.type) == 0ul))
    {
      return_value_link1=c_link1->as->acc.access_reg(c_link1->as, (signed int)loc_link1.val, &val_link1, 1, c_link1->as_arg);
      return return_value_link1;
    }

    else
    {
      return_value_1_link1=c_link1->as->acc.access_mem(c_link1->as, loc_link1.val, &val_link1, 1, c_link1->as_arg);
      return return_value_1_link1;
    }
}

// dwarf_read_encoded_pointer_inlined
// file ../include/dwarf_i.h line 346
static inline signed int dwarf_read_encoded_pointer_inlined(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned char encoding, const struct unw_proc_info *pi, unsigned long int *valp, void *arg)
{
  unsigned long int val;
  unsigned long int initial_addr = *addr;
  unsigned short int uval16;
  unsigned int uval32;
  unsigned long int uval64;
  signed short int sval16;
  signed int sval32;
  signed long int sval64;
  signed int ret;
  if((signed int)encoding == 0xff)
  {
    *valp = (unsigned long int)0;
    return 0;
  }

  else
    if((signed int)encoding == 0x50)
    {
      signed int size = (signed int)sizeof(unsigned long int) /*8ul*/ ;
      *addr = (initial_addr + (unsigned long int)size) - (unsigned long int)1 & (unsigned long int)-size;
      signed int return_value_dwarf_readw_1;
      return_value_dwarf_readw_1=dwarf_readw_link1(as, a, addr, valp, arg);
      return return_value_dwarf_readw_1;
    }

  switch((signed int)encoding & 0x0f)
  {
    case 0x00:
    {
      ret=dwarf_readw_link1(as, a, addr, &val, arg);
      if(!(ret >= 0))
        return ret;

      break;
    }
    case 0x01:
    {
      ret=dwarf_read_uleb128_link3(as, a, addr, &val, arg);
      if(!(ret >= 0))
        return ret;

      break;
    }
    case 0x02:
    {
      ret=dwarf_readu16_link3(as, a, addr, &uval16, arg);
      if(!(ret >= 0))
        return ret;

      val = (unsigned long int)uval16;
      break;
    }
    case 0x03:
    {
      ret=dwarf_readu32_link3(as, a, addr, &uval32, arg);
      if(!(ret >= 0))
        return ret;

      val = (unsigned long int)uval32;
      break;
    }
    case 0x04:
    {
      ret=dwarf_readu64_link2(as, a, addr, &uval64, arg);
      if(!(ret >= 0))
        return ret;

      val = uval64;
      break;
    }
    case 0x09:
    {
      ret=dwarf_read_uleb128_link3(as, a, addr, &val, arg);
      if(!(ret >= 0))
        return ret;

      break;
    }
    case 0x0a:
    {
      ret=dwarf_reads16(as, a, addr, &sval16, arg);
      if(!(ret >= 0))
        return ret;

      val = (unsigned long int)sval16;
      break;
    }
    case 0x0b:
    {
      ret=dwarf_reads32_link1(as, a, addr, &sval32, arg);
      if(!(ret >= 0))
        return ret;

      val = (unsigned long int)sval32;
      break;
    }
    case 0x0c:
    {
      ret=dwarf_reads64_link1(as, a, addr, &sval64, arg);
      if(!(ret >= 0))
        return ret;

      val = (unsigned long int)sval64;
      break;
    }
    default:
      return -UNW_EINVAL;
  }
  if(val == 0ul)
  {
    *valp = (unsigned long int)0;
    return 0;
  }

  else
  {
    switch((signed int)encoding & 0x70)
    {
      case 0x00:
        break;
      case 0x10:
      {
        val = val + initial_addr;
        break;
      }
      case 0x30:
      {
        val = val + pi->gp;
        break;
      }
      case 0x40:
      {
        val = val + pi->start_ip;
        break;
      }
      case 0x20:

      default:
        return -UNW_EINVAL;
    }
    if(!((0x80 & (signed int)encoding) == 0))
    {
      unsigned long int indirect_addr = val;
      ret=dwarf_readw_link1(as, a, &indirect_addr, &val, arg);
      if(!(ret >= 0))
        return ret;

    }

    *valp = val;
    return 0;
  }
}

// dwarf_read_sleb128
// file ../include/dwarf_i.h line 320
static inline signed int dwarf_read_sleb128(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg)
{
  unsigned long int val = (unsigned long int)0;
  unsigned long int shift = (unsigned long int)0;
  unsigned char byte;
  signed int ret;
  do
  {
    ret=dwarf_readu8(as, a, addr, &byte, arg);
    if(!(ret >= 0))
      return ret;

    val = val | ((unsigned long int)byte & (unsigned long int)0x7f) << shift;
    shift = shift + (unsigned long int)7;
  }
  while(!((0x80 & (signed int)byte) == 0));
  if(!((0x40 & (signed int)byte) == 0) && !(shift >= sizeof(unsigned long int) * 8 /*64ul*/ ))
    val = val | (unsigned long int)-1 << shift;

  *valp = val;
  return 0;
}

// dwarf_read_sleb128_link1
// file ../include/dwarf_i.h line 320
static inline signed int dwarf_read_sleb128_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *valp_link1, void *arg_link1)
{
  unsigned long int val_link1 = (unsigned long int)0;
  unsigned long int shift_link1 = (unsigned long int)0;
  unsigned char byte_link1;
  signed int ret_link1;
  do
  {
    ret_link1=dwarf_readu8_link1(as_link1, a_link1, addr_link1, &byte_link1, arg_link1);
    if(!(ret_link1 >= 0))
      return ret_link1;

    val_link1 = val_link1 | ((unsigned long int)byte_link1 & (unsigned long int)0x7f) << shift_link1;
    shift_link1 = shift_link1 + (unsigned long int)7;
  }
  while(!((0x80 & (signed int)byte_link1) == 0));
  if(!((0x40 & (signed int)byte_link1) == 0) && !(shift_link1 >= sizeof(unsigned long int) * 8 /*64ul*/ ))
    val_link1 = val_link1 | (unsigned long int)-1 << shift_link1;

  *valp_link1 = val_link1;
  return 0;
}

// dwarf_read_sleb128_link2
// file ../include/dwarf_i.h line 320
static inline signed int dwarf_read_sleb128_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned long int *valp_link2, void *arg_link2)
{
  unsigned long int val_link2 = (unsigned long int)0;
  unsigned long int shift_link2 = (unsigned long int)0;
  unsigned char byte_link2;
  signed int ret_link2;
  do
  {
    ret_link2=dwarf_readu8_link2(as_link2, a_link2, addr_link2, &byte_link2, arg_link2);
    if(!(ret_link2 >= 0))
      return ret_link2;

    val_link2 = val_link2 | ((unsigned long int)byte_link2 & (unsigned long int)0x7f) << shift_link2;
    shift_link2 = shift_link2 + (unsigned long int)7;
  }
  while(!((0x80 & (signed int)byte_link2) == 0));
  if(!((0x40 & (signed int)byte_link2) == 0) && !(shift_link2 >= sizeof(unsigned long int) * 8 /*64ul*/ ))
    val_link2 = val_link2 | (unsigned long int)-1 << shift_link2;

  *valp_link2 = val_link2;
  return 0;
}

// dwarf_read_uleb128
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg)
{
  unsigned long int val = (unsigned long int)0;
  unsigned long int shift = (unsigned long int)0;
  unsigned char byte;
  signed int ret;
  do
  {
    ret=dwarf_readu8(as, a, addr, &byte, arg);
    if(!(ret >= 0))
      return ret;

    val = val | ((unsigned long int)byte & (unsigned long int)0x7f) << shift;
    shift = shift + (unsigned long int)7;
  }
  while(!((0x80 & (signed int)byte) == 0));
  *valp = val;
  return 0;
}

// dwarf_read_uleb128_link1
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *valp_link1, void *arg_link1)
{
  unsigned long int val_link1 = (unsigned long int)0;
  unsigned long int shift_link1 = (unsigned long int)0;
  unsigned char byte_link1;
  signed int ret_link1;
  do
  {
    ret_link1=dwarf_readu8_link1(as_link1, a_link1, addr_link1, &byte_link1, arg_link1);
    if(!(ret_link1 >= 0))
      return ret_link1;

    val_link1 = val_link1 | ((unsigned long int)byte_link1 & (unsigned long int)0x7f) << shift_link1;
    shift_link1 = shift_link1 + (unsigned long int)7;
  }
  while(!((0x80 & (signed int)byte_link1) == 0));
  *valp_link1 = val_link1;
  return 0;
}

// dwarf_read_uleb128_link2
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned long int *valp_link2, void *arg_link2)
{
  unsigned long int val_link2 = (unsigned long int)0;
  unsigned long int shift_link2 = (unsigned long int)0;
  unsigned char byte_link2;
  signed int ret_link2;
  do
  {
    ret_link2=dwarf_readu8_link2(as_link2, a_link2, addr_link2, &byte_link2, arg_link2);
    if(!(ret_link2 >= 0))
      return ret_link2;

    val_link2 = val_link2 | ((unsigned long int)byte_link2 & (unsigned long int)0x7f) << shift_link2;
    shift_link2 = shift_link2 + (unsigned long int)7;
  }
  while(!((0x80 & (signed int)byte_link2) == 0));
  *valp_link2 = val_link2;
  return 0;
}

// dwarf_read_uleb128_link3
// file ../include/dwarf_i.h line 295
static inline signed int dwarf_read_uleb128_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned long int *valp_link3, void *arg_link3)
{
  unsigned long int val_link3 = (unsigned long int)0;
  unsigned long int shift_link3 = (unsigned long int)0;
  unsigned char byte_link3;
  signed int ret_link3;
  do
  {
    ret_link3=dwarf_readu8_link3(as_link3, a_link3, addr_link3, &byte_link3, arg_link3);
    if(!(ret_link3 >= 0))
      return ret_link3;

    val_link3 = val_link3 | ((unsigned long int)byte_link3 & (unsigned long int)0x7f) << shift_link3;
    shift_link3 = shift_link3 + (unsigned long int)7;
  }
  while(!((0x80 & (signed int)byte_link3) == 0));
  *valp_link3 = val_link3;
  return 0;
}

// dwarf_reads16
// file ../include/dwarf_i.h line 222
static inline signed int dwarf_reads16(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed short int *val, void *arg)
{
  unsigned short int uval;
  signed int ret;
  ret=dwarf_readu16_link3(as, a, addr, &uval, arg);
  if(!(ret >= 0))
    return ret;

  else
  {
    *val = (signed short int)uval;
    return 0;
  }
}

// dwarf_reads32
// file ../include/dwarf_i.h line 235
static inline signed int dwarf_reads32(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed int *val, void *arg)
{
  unsigned int uval;
  signed int ret;
  ret=dwarf_readu32_link1(as, a, addr, &uval, arg);
  if(!(ret >= 0))
    return ret;

  else
  {
    *val = (signed int)uval;
    return 0;
  }
}

// dwarf_reads32_link1
// file ../include/dwarf_i.h line 235
static inline signed int dwarf_reads32_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, signed int *val_link1, void *arg_link1)
{
  unsigned int uval_link1;
  signed int ret_link1;
  ret_link1=dwarf_readu32_link3(as_link1, a_link1, addr_link1, &uval_link1, arg_link1);
  if(!(ret_link1 >= 0))
    return ret_link1;

  else
  {
    *val_link1 = (signed int)uval_link1;
    return 0;
  }
}

// dwarf_reads32_link2
// file ../include/dwarf_i.h line 235
static inline signed int dwarf_reads32_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, signed int *val_link2, void *arg_link2)
{
  unsigned int uval_link2;
  signed int ret_link2;
  ret_link2=dwarf_readu32_link4(as_link2, a_link2, addr_link2, &uval_link2, arg_link2);
  if(!(ret_link2 >= 0))
    return ret_link2;

  else
  {
    *val_link2 = (signed int)uval_link2;
    return 0;
  }
}

// dwarf_reads64
// file ../include/dwarf_i.h line 248
static inline signed int dwarf_reads64(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed long int *val, void *arg)
{
  unsigned long int uval;
  signed int ret;
  ret=dwarf_readu64_link1(as, a, addr, &uval, arg);
  if(!(ret >= 0))
    return ret;

  else
  {
    *val = (signed long int)uval;
    return 0;
  }
}

// dwarf_reads64_link1
// file ../include/dwarf_i.h line 248
static inline signed int dwarf_reads64_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, signed long int *val_link1, void *arg_link1)
{
  unsigned long int uval_link1;
  signed int ret_link1;
  ret_link1=dwarf_readu64_link2(as_link1, a_link1, addr_link1, &uval_link1, arg_link1);
  if(!(ret_link1 >= 0))
    return ret_link1;

  else
  {
    *val_link1 = (signed long int)uval_link1;
    return 0;
  }
}

// dwarf_readu16
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned short int *val, void *arg)
{
  unsigned char v0;
  unsigned char v1;
  signed int ret;
  ret=dwarf_readu8(as, a, addr, &v0, arg);
  _Bool tmp_if_expr_1;
  if(!(ret >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ret=dwarf_readu8(as, a, addr, &v1, arg);
    tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    return ret;

  else
  {
    *val = (unsigned short int)((signed int)(unsigned short int)v1 << 8 | (signed int)v0);
    return 0;
  }
}

// dwarf_readu16_link1
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned short int *val_link1, void *arg_link1)
{
  unsigned char v0_link1;
  unsigned char v1_link1;
  signed int ret_link1;
  ret_link1=dwarf_readu8_link1(as_link1, a_link1, addr_link1, &v0_link1, arg_link1);
  _Bool tmp_if_expr_1_link1;
  if(!(ret_link1 >= 0))
    tmp_if_expr_1_link1 = (_Bool)1;

  else
  {
    ret_link1=dwarf_readu8_link1(as_link1, a_link1, addr_link1, &v1_link1, arg_link1);
    tmp_if_expr_1_link1 = ret_link1 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link1)
    return ret_link1;

  else
  {
    *val_link1 = (unsigned short int)((signed int)(unsigned short int)v1_link1 << 8 | (signed int)v0_link1);
    return 0;
  }
}

// dwarf_readu16_link2
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned short int *val_link2, void *arg_link2)
{
  unsigned char v0_link2;
  unsigned char v1_link2;
  signed int ret_link2;
  ret_link2=dwarf_readu8_link2(as_link2, a_link2, addr_link2, &v0_link2, arg_link2);
  _Bool tmp_if_expr_1_link2;
  if(!(ret_link2 >= 0))
    tmp_if_expr_1_link2 = (_Bool)1;

  else
  {
    ret_link2=dwarf_readu8_link2(as_link2, a_link2, addr_link2, &v1_link2, arg_link2);
    tmp_if_expr_1_link2 = ret_link2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link2)
    return ret_link2;

  else
  {
    *val_link2 = (unsigned short int)((signed int)(unsigned short int)v1_link2 << 8 | (signed int)v0_link2);
    return 0;
  }
}

// dwarf_readu16_link3
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned short int *val_link3, void *arg_link3)
{
  unsigned char v0_link3;
  unsigned char v1_link3;
  signed int ret_link3;
  ret_link3=dwarf_readu8_link3(as_link3, a_link3, addr_link3, &v0_link3, arg_link3);
  _Bool tmp_if_expr_1_link3;
  if(!(ret_link3 >= 0))
    tmp_if_expr_1_link3 = (_Bool)1;

  else
  {
    ret_link3=dwarf_readu8_link3(as_link3, a_link3, addr_link3, &v1_link3, arg_link3);
    tmp_if_expr_1_link3 = ret_link3 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link3)
    return ret_link3;

  else
  {
    *val_link3 = (unsigned short int)((signed int)(unsigned short int)v1_link3 << 8 | (signed int)v0_link3);
    return 0;
  }
}

// dwarf_readu16_link4
// file ../include/dwarf_i.h line 155
static inline signed int dwarf_readu16_link4(struct unw_addr_space *as_link4, struct unw_accessors *a_link4, unsigned long int *addr_link4, unsigned short int *val_link4, void *arg_link4)
{
  unsigned char v0_link4;
  unsigned char v1_link4;
  signed int ret_link4;
  ret_link4=dwarf_readu8_link4(as_link4, a_link4, addr_link4, &v0_link4, arg_link4);
  _Bool tmp_if_expr_1_link4;
  if(!(ret_link4 >= 0))
    tmp_if_expr_1_link4 = (_Bool)1;

  else
  {
    ret_link4=dwarf_readu8_link4(as_link4, a_link4, addr_link4, &v1_link4, arg_link4);
    tmp_if_expr_1_link4 = ret_link4 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link4)
    return ret_link4;

  else
  {
    *val_link4 = (unsigned short int)((signed int)(unsigned short int)v1_link4 << 8 | (signed int)v0_link4);
    return 0;
  }
}

// dwarf_readu32
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned int *val, void *arg)
{
  unsigned short int v0;
  unsigned short int v1;
  signed int ret;
  ret=dwarf_readu16(as, a, addr, &v0, arg);
  _Bool tmp_if_expr_1;
  if(!(ret >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ret=dwarf_readu16(as, a, addr, &v1, arg);
    tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    return ret;

  else
  {
    *val = (unsigned int)v1 << 16 | (unsigned int)v0;
    return 0;
  }
}

// dwarf_readu32_link1
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned int *val_link1, void *arg_link1)
{
  unsigned short int v0_link1;
  unsigned short int v1_link1;
  signed int ret_link1;
  ret_link1=dwarf_readu16_link1(as_link1, a_link1, addr_link1, &v0_link1, arg_link1);
  _Bool tmp_if_expr_1_link1;
  if(!(ret_link1 >= 0))
    tmp_if_expr_1_link1 = (_Bool)1;

  else
  {
    ret_link1=dwarf_readu16_link1(as_link1, a_link1, addr_link1, &v1_link1, arg_link1);
    tmp_if_expr_1_link1 = ret_link1 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link1)
    return ret_link1;

  else
  {
    *val_link1 = (unsigned int)v1_link1 << 16 | (unsigned int)v0_link1;
    return 0;
  }
}

// dwarf_readu32_link2
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned int *val_link2, void *arg_link2)
{
  unsigned short int v0_link2;
  unsigned short int v1_link2;
  signed int ret_link2;
  ret_link2=dwarf_readu16_link2(as_link2, a_link2, addr_link2, &v0_link2, arg_link2);
  _Bool tmp_if_expr_1_link2;
  if(!(ret_link2 >= 0))
    tmp_if_expr_1_link2 = (_Bool)1;

  else
  {
    ret_link2=dwarf_readu16_link2(as_link2, a_link2, addr_link2, &v1_link2, arg_link2);
    tmp_if_expr_1_link2 = ret_link2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link2)
    return ret_link2;

  else
  {
    *val_link2 = (unsigned int)v1_link2 << 16 | (unsigned int)v0_link2;
    return 0;
  }
}

// dwarf_readu32_link3
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned int *val_link3, void *arg_link3)
{
  unsigned short int v0_link3;
  unsigned short int v1_link3;
  signed int ret_link3;
  ret_link3=dwarf_readu16_link3(as_link3, a_link3, addr_link3, &v0_link3, arg_link3);
  _Bool tmp_if_expr_1_link3;
  if(!(ret_link3 >= 0))
    tmp_if_expr_1_link3 = (_Bool)1;

  else
  {
    ret_link3=dwarf_readu16_link3(as_link3, a_link3, addr_link3, &v1_link3, arg_link3);
    tmp_if_expr_1_link3 = ret_link3 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link3)
    return ret_link3;

  else
  {
    *val_link3 = (unsigned int)v1_link3 << 16 | (unsigned int)v0_link3;
    return 0;
  }
}

// dwarf_readu32_link4
// file ../include/dwarf_i.h line 173
static inline signed int dwarf_readu32_link4(struct unw_addr_space *as_link4, struct unw_accessors *a_link4, unsigned long int *addr_link4, unsigned int *val_link4, void *arg_link4)
{
  unsigned short int v0_link4;
  unsigned short int v1_link4;
  signed int ret_link4;
  ret_link4=dwarf_readu16_link4(as_link4, a_link4, addr_link4, &v0_link4, arg_link4);
  _Bool tmp_if_expr_1_link4;
  if(!(ret_link4 >= 0))
    tmp_if_expr_1_link4 = (_Bool)1;

  else
  {
    ret_link4=dwarf_readu16_link4(as_link4, a_link4, addr_link4, &v1_link4, arg_link4);
    tmp_if_expr_1_link4 = ret_link4 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link4)
    return ret_link4;

  else
  {
    *val_link4 = (unsigned int)v1_link4 << 16 | (unsigned int)v0_link4;
    return 0;
  }
}

// dwarf_readu64
// file ../include/dwarf_i.h line 191
static inline signed int dwarf_readu64(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *val, void *arg)
{
  unsigned int v0;
  unsigned int v1;
  signed int ret;
  ret=dwarf_readu32(as, a, addr, &v0, arg);
  _Bool tmp_if_expr_1;
  if(!(ret >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ret=dwarf_readu32(as, a, addr, &v1, arg);
    tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    return ret;

  else
  {
    *val = (unsigned long int)v1 << 32 | (unsigned long int)v0;
    return 0;
  }
}

// dwarf_readu64_link1
// file ../include/dwarf_i.h line 191
static inline signed int dwarf_readu64_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *val_link1, void *arg_link1)
{
  unsigned int v0_link1;
  unsigned int v1_link1;
  signed int ret_link1;
  ret_link1=dwarf_readu32_link1(as_link1, a_link1, addr_link1, &v0_link1, arg_link1);
  _Bool tmp_if_expr_1_link1;
  if(!(ret_link1 >= 0))
    tmp_if_expr_1_link1 = (_Bool)1;

  else
  {
    ret_link1=dwarf_readu32_link1(as_link1, a_link1, addr_link1, &v1_link1, arg_link1);
    tmp_if_expr_1_link1 = ret_link1 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link1)
    return ret_link1;

  else
  {
    *val_link1 = (unsigned long int)v1_link1 << 32 | (unsigned long int)v0_link1;
    return 0;
  }
}

// dwarf_readu64_link2
// file ../include/dwarf_i.h line 191
static inline signed int dwarf_readu64_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned long int *val_link2, void *arg_link2)
{
  unsigned int v0_link2;
  unsigned int v1_link2;
  signed int ret_link2;
  ret_link2=dwarf_readu32_link3(as_link2, a_link2, addr_link2, &v0_link2, arg_link2);
  _Bool tmp_if_expr_1_link2;
  if(!(ret_link2 >= 0))
    tmp_if_expr_1_link2 = (_Bool)1;

  else
  {
    ret_link2=dwarf_readu32_link3(as_link2, a_link2, addr_link2, &v1_link2, arg_link2);
    tmp_if_expr_1_link2 = ret_link2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1_link2)
    return ret_link2;

  else
  {
    *val_link2 = (unsigned long int)v1_link2 << 32 | (unsigned long int)v0_link2;
    return 0;
  }
}

// dwarf_readu8
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned char *valp, void *arg)
{
  unsigned long int val;
  unsigned long int aligned_addr = *addr & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off = *addr - aligned_addr;
  signed int ret;
  *addr = *addr + (unsigned long int)1;
  ret=a->access_mem(as, aligned_addr, &val, 0, arg);
  val = val >> (unsigned long int)8 * off;
  *valp = (unsigned char)val;
  return ret;
}

// dwarf_readu8_link1
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned char *valp_link1, void *arg_link1)
{
  unsigned long int val_link1;
  unsigned long int aligned_addr_link1 = *addr_link1 & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off_link1 = *addr_link1 - aligned_addr_link1;
  signed int ret_link1;
  *addr_link1 = *addr_link1 + (unsigned long int)1;
  ret_link1=a_link1->access_mem(as_link1, aligned_addr_link1, &val_link1, 0, arg_link1);
  val_link1 = val_link1 >> (unsigned long int)8 * off_link1;
  *valp_link1 = (unsigned char)val_link1;
  return ret_link1;
}

// dwarf_readu8_link2
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link2(struct unw_addr_space *as_link2, struct unw_accessors *a_link2, unsigned long int *addr_link2, unsigned char *valp_link2, void *arg_link2)
{
  unsigned long int val_link2;
  unsigned long int aligned_addr_link2 = *addr_link2 & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off_link2 = *addr_link2 - aligned_addr_link2;
  signed int ret_link2;
  *addr_link2 = *addr_link2 + (unsigned long int)1;
  ret_link2=a_link2->access_mem(as_link2, aligned_addr_link2, &val_link2, 0, arg_link2);
  val_link2 = val_link2 >> (unsigned long int)8 * off_link2;
  *valp_link2 = (unsigned char)val_link2;
  return ret_link2;
}

// dwarf_readu8_link3
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link3(struct unw_addr_space *as_link3, struct unw_accessors *a_link3, unsigned long int *addr_link3, unsigned char *valp_link3, void *arg_link3)
{
  unsigned long int val_link3;
  unsigned long int aligned_addr_link3 = *addr_link3 & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off_link3 = *addr_link3 - aligned_addr_link3;
  signed int ret_link3;
  *addr_link3 = *addr_link3 + (unsigned long int)1;
  ret_link3=a_link3->access_mem(as_link3, aligned_addr_link3, &val_link3, 0, arg_link3);
  val_link3 = val_link3 >> (unsigned long int)8 * off_link3;
  *valp_link3 = (unsigned char)val_link3;
  return ret_link3;
}

// dwarf_readu8_link4
// file ../include/dwarf_i.h line 136
static inline signed int dwarf_readu8_link4(struct unw_addr_space *as_link4, struct unw_accessors *a_link4, unsigned long int *addr_link4, unsigned char *valp_link4, void *arg_link4)
{
  unsigned long int val_link4;
  unsigned long int aligned_addr_link4 = *addr_link4 & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off_link4 = *addr_link4 - aligned_addr_link4;
  signed int ret_link4;
  *addr_link4 = *addr_link4 + (unsigned long int)1;
  ret_link4=a_link4->access_mem(as_link4, aligned_addr_link4, &val_link4, 0, arg_link4);
  val_link4 = val_link4 >> (unsigned long int)8 * off_link4;
  *valp_link4 = (unsigned char)val_link4;
  return ret_link4;
}

// dwarf_readw
// file ../include/dwarf_i.h line 263
static inline signed int dwarf_readw(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *val, void *arg)
{
  unsigned int u32;
  unsigned long int u64;
  signed int ret;
  switch(sizeof(unsigned long int) /*8ul*/ )
  {
    case (unsigned long int)4:
    {
      ret=dwarf_readu32(as, a, addr, &u32, arg);
      if(!(ret >= 0))
        return ret;

      *val = (unsigned long int)u32;
      return ret;
    }
    case (unsigned long int)8:
    {
      ret=dwarf_readu64(as, a, addr, &u64, arg);
      if(!(ret >= 0))
        return ret;

      *val = u64;
      return ret;
    }
    default:
      abort();
  }
}

// dwarf_readw_link1
// file ../include/dwarf_i.h line 263
static inline signed int dwarf_readw_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, unsigned long int *val_link1, void *arg_link1)
{
  unsigned int u32_link1;
  unsigned long int u64_link1;
  signed int ret_link1;
  switch(sizeof(unsigned long int) /*8ul*/ )
  {
    case (unsigned long int)4:
    {
      ret_link1=dwarf_readu32_link3(as_link1, a_link1, addr_link1, &u32_link1, arg_link1);
      if(!(ret_link1 >= 0))
        return ret_link1;

      *val_link1 = (unsigned long int)u32_link1;
      return ret_link1;
    }
    case (unsigned long int)8:
    {
      ret_link1=dwarf_readu64_link2(as_link1, a_link1, addr_link1, &u64_link1, arg_link1);
      if(!(ret_link1 >= 0))
        return ret_link1;

      *val_link1 = u64_link1;
      return ret_link1;
    }
    default:
      abort();
  }
}

// elf_map_image
// file ./elfxx.h line 76
static inline signed int elf_map_image(struct elf_image *ei, const char *path)
{
  struct stat stat;
  signed int fd;
  fd=open(path, 00);
  if(!(fd >= 0))
    return -1;

  else
  {
    signed int return_value_fstat_1;
    return_value_fstat_1=fstat(fd, &stat);
    if(!(return_value_fstat_1 >= 0))
    {
      close(fd);
      return -1;
    }

    else
    {
      ei->size = (unsigned long int)stat.st_size;
      ei->image=mmap((void *)0, ei->size, 0x1, 0x02, fd, (signed long int)0);
      close(fd);
      if(ei->image == (void *)-1)
        return -1;

      else
      {
        signed int return_value__Uelf64_valid_object_2;
        return_value__Uelf64_valid_object_2=_Uelf64_valid_object(ei);
        if(return_value__Uelf64_valid_object_2 == 0)
        {
          munmap(ei->image, ei->size);
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// elf_map_image_link1
// file ./elfxx.h line 76
static inline signed int elf_map_image_link1(struct elf_image *ei_link1, const char *path_link1)
{
  struct stat stat_link1;
  signed int fd_link1;
  fd_link1=open(path_link1, 00);
  if(!(fd_link1 >= 0))
    return -1;

  else
  {
    signed int return_value_fstat_1_link1;
    return_value_fstat_1_link1=fstat(fd_link1, &stat_link1);
    if(!(return_value_fstat_1_link1 >= 0))
    {
      close(fd_link1);
      return -1;
    }

    else
    {
      ei_link1->size = (unsigned long int)stat_link1.st_size;
      ei_link1->image=mmap((void *)0, ei_link1->size, 0x1, 0x02, fd_link1, (signed long int)0);
      close(fd_link1);
      if(ei_link1->image == (void *)-1)
        return -1;

      else
      {
        signed int return_value__Uelf64_valid_object_2_link1;
        return_value__Uelf64_valid_object_2_link1=_Uelf64_valid_object_link3(ei_link1);
        if(return_value__Uelf64_valid_object_2_link1 == 0)
        {
          munmap(ei_link1->image, ei_link1->size);
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// elf_map_image_link2
// file ./elfxx.h line 76
static inline signed int elf_map_image_link2(struct elf_image *ei_link2, const char *path_link2)
{
  struct stat stat_link2;
  signed int fd_link2;
  fd_link2=open(path_link2, 00);
  if(!(fd_link2 >= 0))
    return -1;

  else
  {
    signed int return_value_fstat_1_link2;
    return_value_fstat_1_link2=fstat(fd_link2, &stat_link2);
    if(!(return_value_fstat_1_link2 >= 0))
    {
      close(fd_link2);
      return -1;
    }

    else
    {
      ei_link2->size = (unsigned long int)stat_link2.st_size;
      ei_link2->image=mmap((void *)0, ei_link2->size, 0x1, 0x02, fd_link2, (signed long int)0);
      close(fd_link2);
      if(ei_link2->image == (void *)-1)
        return -1;

      else
      {
        signed int return_value__Uelf64_valid_object_2_link2;
        return_value__Uelf64_valid_object_2_link2=_Uelf64_valid_object_link4(ei_link2);
        if(return_value__Uelf64_valid_object_2_link2 == 0)
        {
          munmap(ei_link2->image, ei_link2->size);
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// establish_machine_state
// file x86_64/Gresume.c line 67
static inline signed int establish_machine_state(struct cursor *c)
{
  signed int (*establish_machine_state__1__access_reg)(struct unw_addr_space *, signed int, unsigned long int *, signed int, void *);
  signed int (*establish_machine_state__1__access_fpreg)(struct unw_addr_space *, signed int, long double *, signed int, void *);
  struct unw_addr_space *as = c->dwarf.as;
  void *arg = c->dwarf.as_arg;
  long double fpval;
  unsigned long int val;
  signed int reg;
  establish_machine_state__1__access_reg = as->acc.access_reg;
  establish_machine_state__1__access_fpreg = as->acc.access_fpreg;
  reg = 0;
  for( ; !(reg >= 17); reg = reg + 1)
  {
    signed int return_value__Ux86_64_is_fpreg_3;
    return_value__Ux86_64_is_fpreg_3=_Ux86_64_is_fpreg(reg);
    if(!(return_value__Ux86_64_is_fpreg_3 == 0))
    {
      signed int return_value__Ux86_64_access_fpreg_1;
      return_value__Ux86_64_access_fpreg_1=_Ux86_64_access_fpreg(c, reg, &fpval, 0);
      if(return_value__Ux86_64_access_fpreg_1 >= 0)
        establish_machine_state__1__access_fpreg(as, reg, &fpval, 1, arg);

    }

    else
    {
      signed int return_value__Ux86_64_access_reg_2;
      return_value__Ux86_64_access_reg_2=_Ux86_64_access_reg(c, reg, &val, 0);
      if(return_value__Ux86_64_access_reg_2 >= 0)
        establish_machine_state__1__access_reg(as, reg, &val, 1, arg);

    }
  }
  return 0;
}

// eval_location_expr
// file dwarf/Gparser.c line 689
static inline signed int eval_location_expr(struct dwarf_cursor *c, struct unw_addr_space *as, struct unw_accessors *a, unsigned long int addr, struct dwarf_loc *locp, void *arg)
{
  signed int ret;
  signed int is_register;
  unsigned long int len;
  unsigned long int val;
  ret=dwarf_read_uleb128_link2(as, a, &addr, &len, arg);
  signed int tmp_if_expr_1;
  if(!(ret >= 0))
    return ret;

  else
  {
    ret=_Ux86_64_dwarf_eval_expr(c, &addr, len, &val, &is_register);
    if(!(ret >= 0))
      return ret;

    else
    {
      if(!(is_register == 0))
      {
        if(!(val >= 17ul))
          tmp_if_expr_1 = (signed int)_Ux86_64_dwarf_to_unw_regnum_map[(signed long int)val];

        else
          tmp_if_expr_1 = 0;
        *locp = (struct dwarf_loc){ .val=(unsigned long int)tmp_if_expr_1, .type=(unsigned long int)(1 << 1) };
      }

      else
        *locp = (struct dwarf_loc){ .val=val, .type=(unsigned long int)0 };
      return 0;
    }
  }
}

// expand
// file mi/mempool.c line 105
static void expand(struct mempool *pool)
{
  unsigned long int size;
  char *mem;
  size = pool->chunk_size;
  do
  {
    void *return_value_mmap_1;
    return_value_mmap_1=mmap((void *)0, size, 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
    mem = (char *)return_value_mmap_1;
    if(mem == (char *)-1)
      mem = (char *)(void *)0;

  }
  while((_Bool)0);
  if(mem == ((char *)NULL))
  {
    size = (pool->obj_size + pg_size) - 1UL & ~(pg_size - 1UL);
    do
    {
      void *return_value_mmap_2;
      return_value_mmap_2=mmap((void *)0, size, 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
      mem = (char *)return_value_mmap_2;
      if(mem == (char *)-1)
        mem = (char *)(void *)0;

    }
    while((_Bool)0);
    if(mem == ((char *)NULL))
    {
      size = pool->obj_size;
      void *return_value__UIx86_64__sos_alloc_3;
      return_value__UIx86_64__sos_alloc_3=_UIx86_64__sos_alloc(size);
      mem = (char *)return_value__UIx86_64__sos_alloc_3;
    }

  }

  add_memory(pool, mem, size, pool->obj_size);
}

// fetch16
// file ../include/remote.h line 71
static inline signed int fetch16(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed short int *valp, void *arg)
{
  unsigned long int val;
  unsigned long int aligned_addr = *addr & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off = *addr - aligned_addr;
  signed int ret;
  *addr = *addr + (unsigned long int)2;
  ret=a->access_mem(as, aligned_addr, &val, 0, arg);
  val = val >> (unsigned long int)8 * off;
  *valp = (signed short int)(val & (unsigned long int)0xffff);
  return ret;
}

// fetch32
// file ../include/remote.h line 93
static inline signed int fetch32(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed int *valp, void *arg)
{
  unsigned long int val;
  unsigned long int aligned_addr = *addr & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off = *addr - aligned_addr;
  signed int ret;
  *addr = *addr + (unsigned long int)4;
  ret=a->access_mem(as, aligned_addr, &val, 0, arg);
  val = val >> (unsigned long int)8 * off;
  *valp = (signed int)(val & (unsigned long int)0xffffffff);
  return ret;
}

// fetch8
// file ../include/remote.h line 51
static inline signed int fetch8(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed char *valp, void *arg)
{
  unsigned long int val;
  unsigned long int aligned_addr = *addr & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off = *addr - aligned_addr;
  signed int ret;
  *addr = *addr + (unsigned long int)1;
  ret=a->access_mem(as, aligned_addr, &val, 0, arg);
  val = val >> (unsigned long int)8 * off;
  *valp = (signed char)(val & (unsigned long int)0xff);
  return ret;
}

// fetch8_link1
// file ../include/remote.h line 51
static inline signed int fetch8_link1(struct unw_addr_space *as_link1, struct unw_accessors *a_link1, unsigned long int *addr_link1, signed char *valp_link1, void *arg_link1)
{
  unsigned long int val_link1;
  unsigned long int aligned_addr_link1 = *addr_link1 & -sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int off_link1 = *addr_link1 - aligned_addr_link1;
  signed int ret_link1;
  *addr_link1 = *addr_link1 + (unsigned long int)1;
  ret_link1=a_link1->access_mem(as_link1, aligned_addr_link1, &val_link1, 0, arg_link1);
  val_link1 = val_link1 >> (unsigned long int)8 * off_link1;
  *valp_link1 = (signed char)(val_link1 & (unsigned long int)0xff);
  return ret_link1;
}

// fetch_proc_info
// file dwarf/Gparser.c line 389
static signed int fetch_proc_info(struct dwarf_cursor *c, unsigned long int ip, signed int need_unwind_info)
{
  signed int ret;
  signed int dynamic = 1;
  if(!(c->use_prev_instr == 0u))
    ip = ip - 1ul;

  if(!(c->pi_valid == 0u))
  {
    if(!(need_unwind_info == 0))
      goto __CPROVER_DUMP_L2;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    memset((void *)&c->pi, 0, sizeof(struct unw_proc_info) /*64ul*/ );
    ret=_Ux86_64_Ifind_dynamic_proc_info(c->as, ip, &c->pi, need_unwind_info, c->as_arg);
    if(ret == -10)
    {
      dynamic = 0;
      ret=c->as->acc.find_proc_info(c->as, ip, &c->pi, need_unwind_info, c->as_arg);
      return ret;
    }

    else
      if(!(c->pi.format == 0))
      {
        if(c->pi.format == 1)
          goto __CPROVER_DUMP_L4;

        if(c->pi.format == 2)
          goto __CPROVER_DUMP_L4;

        return -UNW_ENOINFO;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        c->pi_valid = (unsigned int)1;
        c->pi_is_dynamic = (unsigned int)dynamic;
        if(ret >= 0)
          _Ux86_64_fetch_frame(c, ip, need_unwind_info);

        if(!(need_unwind_info == 0))
        {
          struct dwarf_cie_info *dci = (struct dwarf_cie_info *)c->pi.unwind_info;
          c->use_prev_instr = (unsigned int)!(dci->signal_frame != 0u);
        }

        return ret;
      }
  }
}

// fetchw
// file ../include/remote.h line 115
static inline signed int fetchw(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg)
{
  signed int ret;
  ret=a->access_mem(as, *addr, valp, 0, arg);
  *addr = *addr + sizeof(unsigned long int) /*8ul*/ ;
  return ret;
}

// flush_rs_cache
// file dwarf/Gparser.c line 500
static inline void flush_rs_cache(struct dwarf_rs_cache *cache)
{
  signed int i;
  cache->lru_head = (unsigned short int)((1 << 7) - 1);
  cache->lru_tail = (unsigned short int)0;
  i = 0;
  for( ; !(i >= 128); i = i + 1)
  {
    if(i >= 1)
      cache->buckets[(signed long int)i].lru_chain = (unsigned short int)(i - 1);

    cache->buckets[(signed long int)i].coll_chain = (unsigned short int)-1;
    cache->buckets[(signed long int)i].ip = (unsigned long int)0;
    cache->buckets[(signed long int)i].valid = (unsigned short int)0;
  }
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    cache->hash[(signed long int)i] = (unsigned short int)-1;
}

// free_dyn_info
// file mi/Gdyn-remote.c line 127
static void free_dyn_info(struct unw_dyn_info *di)
{
  switch(di->format)
  {
    case 0:
    {
      if(!(di->u.pi.regions == ((struct unw_dyn_region_info *)NULL)))
      {
        free_regions(di->u.pi.regions);
        di->u.pi.regions = (struct unw_dyn_region_info *)(void *)0;
      }

      break;
    }
    case 1:
      if(!(di->u.ti.table_data == ((unsigned long int *)NULL)))
      {
        free((void *)di->u.ti.table_data);
        di->u.ti.table_data = (unsigned long int *)(void *)0;
      }

    case 2:

    default:
      ;
  }
}

// free_object
// file mi/mempool.c line 86
static void free_object(struct mempool *pool, void *object)
{
  struct object *obj = (struct object *)object;
  obj->next = pool->free_list;
  pool->free_list = obj;
  pool->num_free = pool->num_free + 1u;
}

// free_regions
// file mi/Gdyn-remote.c line 32
static void free_regions(struct unw_dyn_region_info *region)
{
  if(!(region->next == ((struct unw_dyn_region_info *)NULL)))
    free_regions(region->next);

  free((void *)region);
}

// get_dyn_info_list_addr
// file x86_64/Ginit.c line 64
static signed int get_dyn_info_list_addr(struct unw_addr_space *as, unsigned long int *dyn_info_list_addr, void *arg)
{
  *dyn_info_list_addr = (unsigned long int)&_U_dyn_info_list;
  return 0;
}

// get_proc_name
// file mi/Gget_proc_name.c line 49
static inline signed int get_proc_name(struct unw_addr_space *as, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp, void *arg)
{
  struct unw_accessors *a;
  a=_Ux86_64_get_accessors(as);
  struct unw_proc_info pi;
  signed int ret;
  buf[(signed long int)0] = (char)0;
  ret=_Ux86_64_Ifind_dynamic_proc_info(as, ip, &pi, 1, arg);
  if(ret == 0)
  {
    struct unw_dyn_info *di = (struct unw_dyn_info *)pi.unwind_info;
    if(!(offp == ((unsigned long int *)NULL)))
      *offp = ip - pi.start_ip;

    switch(di->format)
    {
      case 0:
      {
        ret=intern_string(as, a, di->u.pi.name_ptr, buf, buf_len, arg);
        break;
      }
      case 1:

      case 2:
      {
        ret = -UNW_ENOINFO;
        break;
      }
      default:
        ret = -UNW_EINVAL;
    }
    _Ux86_64_Iput_dynamic_unwind_info(as, &pi, arg);
    return ret;
  }

  signed int return_value;
  if(!(ret == -10))
    return ret;

  else
    if(!(a->get_proc_name == ((signed int (*)(struct unw_addr_space *, unsigned long int, char *, unsigned long int, unsigned long int *, void *))NULL)))
    {
      return_value=a->get_proc_name(as, ip, buf, buf_len, offp, arg);
      return return_value;
    }

    else
      return -UNW_ENOINFO;
}

// get_rs_cache
// file dwarf/Gparser.c line 520
static inline struct dwarf_rs_cache * get_rs_cache(struct unw_addr_space *as, struct anonymous_8 *saved_maskp)
{
  struct dwarf_rs_cache *cache = &as->global_cache;
  enum anonymous_10 caching = as->caching_policy;
  if((signed int)caching == UNW_CACHE_NONE)
    return (struct dwarf_rs_cache *)(void *)0;

  else
  {
    if((signed int)caching == UNW_CACHE_GLOBAL)
      do
      {
        sigprocmask(2, &_UIx86_64_full_mask, &(*saved_maskp));
        pthread_mutex_lock(&cache->lock);
      }
      while((_Bool)0);

    if(!(as->cache_generation == cache->generation))
    {
      flush_rs_cache(cache);
      cache->generation = as->cache_generation;
    }

    return cache;
  }
}

// get_static_proc_name
// file x86_64/Ginit.c line 243
static signed int get_static_proc_name(struct unw_addr_space *as, unsigned long int ip, char *buf, unsigned long int buf_len, unsigned long int *offp, void *arg)
{
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  signed int return_value__Uelf64_get_proc_name_2;
  return_value__Uelf64_get_proc_name_2=_Uelf64_get_proc_name(as, return_value_getpid_1, ip, buf, buf_len, offp);
  return return_value__Uelf64_get_proc_name_2;
}

// handler
// file Gtest-concurrent.c line 51
void handler(signed int sig)
{
  unsigned long int ip;
  struct ucontext uc;
  struct unw_cursor c;
  signed int ret;
  _Ux86_64_getcontext(&uc);
  _Ux86_64_init_local(&c, &uc);
  unsigned long int return_value_pthread_self_1;
  do
  {
    _Ux86_64_get_reg(&c, 16, &ip);
    if(!(verbose == 0))
    {
      return_value_pthread_self_1=pthread_self();
      printf("%lx: IP=%lx\n", (signed long int)return_value_pthread_self_1, (unsigned long int)ip);
    }

    ret=_Ux86_64_step(&c);
  }
  while(ret >= 1);
  if(!(ret >= 0))
    do
    {
      fprintf(stderr, "unw_step() returned %d\n", ret);
      nerrors = nerrors + 1;
    }
    while((_Bool)0);

}

// hash
// file dwarf/Gparser.c line 555
static inline unsigned char hash(unsigned long int ip)
{
  return (unsigned char)(ip * (unsigned long int)0x9e3779b97f4a7c16ULL >> sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8 - (unsigned long int)(7 + 1));
}

// intern_array
// file mi/Gdyn-remote.c line 100
static signed int intern_array(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int table_len, unsigned long int **table_data, void *arg)
{
  unsigned long int i;
  unsigned long int *data;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(table_len, sizeof(unsigned long int) /*8ul*/ );
  data = (unsigned long int *)return_value_calloc_1;
  signed int ret = 0;
  signed int return_value_fetchw_2;
  if(data == ((unsigned long int *)NULL))
    ret = -UNW_ENOMEM;

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= table_len); i = i + 1ul)
    {
      return_value_fetchw_2=fetchw(as, a, addr, data + (signed long int)i, arg);
      if(!(return_value_fetchw_2 >= 0))
        goto out;

    }
    *table_data = data;
    return 0;
  }

out:
  ;
  if(!(data == ((unsigned long int *)NULL)))
    free((void *)data);

  return ret;
}

// intern_dyn_info
// file mi/Gdyn-remote.c line 154
static signed int intern_dyn_info(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, struct unw_dyn_info *di, void *arg)
{
  unsigned long int first_region;
  signed int ret;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  switch(di->format)
  {
    case 0:
    {
      ret=fetchw(as, a, addr, &di->u.pi.name_ptr, arg);
      if(!(ret >= 0))
        tmp_if_expr_1 = (_Bool)1;

      else
      {
        ret=fetchw(as, a, addr, &di->u.pi.handler, arg);
        tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        ret=fetch32(as, a, addr, (signed int *)&di->u.pi.flags, arg);
        tmp_if_expr_2 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        goto out;

      *addr = *addr + (unsigned long int)4;
      ret=fetchw(as, a, addr, &first_region, arg);
      if(!(ret >= 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        ret=intern_regions(as, a, &first_region, &di->u.pi.regions, arg);
        tmp_if_expr_3 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        goto out;

      break;
    }
    case 1:
    {
      ret=fetchw(as, a, addr, &di->u.ti.name_ptr, arg);
      if(!(ret >= 0))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        ret=fetchw(as, a, addr, &di->u.ti.segbase, arg);
        tmp_if_expr_4 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        ret=fetchw(as, a, addr, &di->u.ti.table_len, arg);
        tmp_if_expr_5 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        ret=intern_array(as, a, addr, di->u.ti.table_len, &di->u.ti.table_data, arg);
        tmp_if_expr_6 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        goto out;

      break;
    }
    case 2:
    {
      ret=fetchw(as, a, addr, &di->u.rti.name_ptr, arg);
      if(!(ret >= 0))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        ret=fetchw(as, a, addr, &di->u.rti.segbase, arg);
        tmp_if_expr_7 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        ret=fetchw(as, a, addr, &di->u.rti.table_len, arg);
        tmp_if_expr_8 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        ret=fetchw(as, a, addr, &di->u.rti.table_data, arg);
        tmp_if_expr_9 = ret < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        goto out;

      break;
    }
    default:
    {
      ret = -UNW_ENOINFO;
      goto out;
    }
  }
  return 0;

out:
  ;
  free_dyn_info(di);
  return ret;
}

// intern_op
// file mi/Gdyn-remote.c line 40
static signed int intern_op(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, struct unw_dyn_op *op, void *arg)
{
  signed int ret;
  ret=fetch8(as, a, addr, &op->tag, arg);
  _Bool tmp_if_expr_1;
  if(!(ret >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ret=fetch8(as, a, addr, &op->qp, arg);
    tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    ret=fetch16(as, a, addr, &op->reg, arg);
    tmp_if_expr_2 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    ret=fetch32(as, a, addr, &op->when, arg);
    tmp_if_expr_3 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    ret=fetchw(as, a, addr, &op->val, arg);
    tmp_if_expr_4 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
    return ret;

  else
    return 0;
}

// intern_regions
// file mi/Gdyn-remote.c line 55
static signed int intern_regions(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, struct unw_dyn_region_info **regionp, void *arg)
{
  unsigned int insn_count;
  unsigned int op_count;
  unsigned int i;
  struct unw_dyn_region_info *region;
  unsigned long int next_addr;
  signed int ret;
  *regionp = (struct unw_dyn_region_info *)(void *)0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(*addr == 0ul)
    return 0;

  else
  {
    ret=fetchw(as, a, addr, &next_addr, arg);
    if(!(ret >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      ret=fetch32(as, a, addr, (signed int *)&insn_count, arg);
      tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      ret=fetch32(as, a, addr, (signed int *)&op_count, arg);
      tmp_if_expr_2 = ret < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      return ret;

    else
    {
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)((char *)(((struct unw_dyn_region_info *)(void *)0)->op + (signed long int)op_count) - (char *)(void *)0));
      region = (struct unw_dyn_region_info *)return_value_calloc_3;
      if(region == ((struct unw_dyn_region_info *)NULL))
        ret = -UNW_ENOMEM;

      else
      {
        region->insn_count = (signed int)insn_count;
        region->op_count = op_count;
        i = (unsigned int)0;
        for( ; !(i >= op_count); i = i + 1u)
        {
          ret=intern_op(as, a, addr, region->op + (signed long int)i, arg);
          if(!(ret >= 0))
            goto out;

        }
        if(!(next_addr == 0ul))
        {
          ret=intern_regions(as, a, &next_addr, &region->next, arg);
          if(!(ret >= 0))
            goto out;

        }

        *regionp = region;
        return 0;
      }

    out:
      ;
      if(!(region == ((struct unw_dyn_region_info *)NULL)))
        free_regions(region);

      return ret;
    }
  }
}

// intern_string
// file mi/Gget_proc_name.c line 30
static inline signed int intern_string(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int addr, char *buf, unsigned long int buf_len, void *arg)
{
  unsigned long int i;
  signed int ret;
  i = (unsigned long int)0;
  for( ; !(i >= buf_len); i = i + 1ul)
  {
    ret=fetch8_link1(as, a, &addr, (signed char *)buf + (signed long int)i, arg);
    if(!(ret >= 0))
      return ret;

    if((signed int)buf[(signed long int)i] == 0)
      return 0;

  }
  buf[(signed long int)(buf_len - (unsigned long int)1)] = (char)0;
  return -UNW_ENOMEM;
}

// is_cie_id
// file dwarf/Gfde.c line 29
static inline signed int is_cie_id(unsigned long int val, signed int is_debug_frame)
{
  if(!(is_debug_frame == 0))
    return (signed int)(val == (unsigned long int)-((unsigned int)1) || val == -((unsigned long int)1));

  else
    return (signed int)(val == (unsigned long int)0);
}

// is_plt_entry
// file x86_64/Gstep.c line 36
static signed int is_plt_entry(struct dwarf_cursor *c)
{
  unsigned long int w0;
  unsigned long int w1;
  struct unw_accessors *a;
  signed int ret;
  a=_Ux86_64_get_accessors(c->as);
  ret=a->access_mem(c->as, c->ip, &w0, 0, c->as_arg);
  _Bool tmp_if_expr_1;
  if(!(ret >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ret=a->access_mem(c->as, c->ip + (unsigned long int)8, &w1, 0, c->as_arg);
    tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_1)
    return 0;

  else
  {
    ret = (signed int)((w0 & (unsigned long int)0xffff) == (unsigned long int)0x25ff && (w0 >> 48 & (unsigned long int)0xff) == (unsigned long int)0x68 && (w1 >> 24 & (unsigned long int)0xff) == (unsigned long int)0xe9);
    return ret;
  }
}

// linear_search
// file dwarf/Gfind_proc_info-lsb.c line 53
static signed int linear_search(struct unw_addr_space *as, unsigned long int ip, unsigned long int eh_frame_start, unsigned long int eh_frame_end, unsigned long int fde_count, struct unw_proc_info *pi, signed int need_unwind_info, void *arg)
{
  struct unw_accessors *a;
  a=_Ux86_64_get_accessors(_Ux86_64_local_addr_space);
  unsigned long int i = (unsigned long int)0;
  unsigned long int fde_addr;
  unsigned long int addr = eh_frame_start;
  signed int ret;
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = i;
    i = i + 1ul;
    if(tmp_post_1 >= fde_count)
      break;

    if(addr >= eh_frame_end)
      break;

    fde_addr = addr;
    ret=_Ux86_64_dwarf_extract_proc_info_from_fde(as, a, &addr, pi, 0, (unsigned long int)0, arg);
    if(!(ret >= 0))
      return ret;

    if(ip >= pi->start_ip)
    {
      if(!(ip >= pi->end_ip))
      {
        if(need_unwind_info == 0)
          return 1;

        addr = fde_addr;
        ret=_Ux86_64_dwarf_extract_proc_info_from_fde(as, a, &addr, pi, need_unwind_info, (unsigned long int)0, arg);
        if(!(ret >= 0))
          return ret;

        return 1;
      }

    }

  }
  while((_Bool)1);
  return -UNW_ENOINFO;
}

// local_find_proc_info
// file mi/Gfind_dynamic_proc_info.c line 40
static inline signed int local_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg)
{
  struct unw_dyn_info_list *list;
  struct unw_dyn_info *di;
  signed int return_value__Ux86_64_Iextract_dynamic_proc_info_2;
  {
    unsigned long int return_value__U_dyn_info_list_addr_1;
    return_value__U_dyn_info_list_addr_1=_U_dyn_info_list_addr();
    list = (struct unw_dyn_info_list *)(unsigned long int)return_value__U_dyn_info_list_addr_1;
    di = list->first;
    for( ; !(di == ((struct unw_dyn_info *)NULL)); di = di->next)
      if(ip >= di->start_ip)
      {
        if(!(ip >= di->end_ip))
        {
          return_value__Ux86_64_Iextract_dynamic_proc_info_2=_Ux86_64_Iextract_dynamic_proc_info(as, ip, pi, di, need_unwind_info, arg);
          return return_value__Ux86_64_Iextract_dynamic_proc_info_2;
        }

      }

    return -UNW_ENOINFO;
  }
}

// lookup
// file dwarf/Gfind_proc_info-lsb.c line 757
static inline struct table_entry * lookup(struct table_entry *table, unsigned long int table_size, signed int rel_ip)
{
  unsigned long int table_len = table_size / sizeof(struct table_entry) /*8ul*/ ;
  struct table_entry *e = (struct table_entry *)(void *)0;
  unsigned long int lo;
  unsigned long int hi;
  unsigned long int mid;
  lo = (unsigned long int)0;
  hi = table_len;
  while(!(lo >= hi))
  {
    mid = (lo + hi) / (unsigned long int)2;
    e = table + (signed long int)mid;
    if(!(rel_ip >= e->start_ip_offset))
      hi = mid;

    else
      lo = mid + (unsigned long int)1;
  }
  if(!(hi >= 1ul))
    return (struct table_entry *)(void *)0;

  else
  {
    e = (table + (signed long int)hi) - (signed long int)1;
    return e;
  }
}

// ltoa
// file os-linux.h line 41
static inline char * ltoa(char *buf, signed long int val)
{
  char *cp = buf;
  char tmp;
  signed long int i;
  signed long int len;
  char *tmp_post_1;
  do
  {
    tmp_post_1 = cp;
    cp = cp + 1l;
    *tmp_post_1 = (char)((signed long int)48 + val % (signed long int)10);
    val = val / (signed long int)10;
  }
  while(!(val == 0l));
  len = cp - buf;
  cp = cp - 1l;
  i = (signed long int)0;
  for( ; !(i >= len / 2l); i = i + 1l)
  {
    tmp = buf[i];
    buf[i] = cp[-i];
    cp[-i] = tmp;
  }
  return buf + len;
}

// ltoa_link1
// file os-linux.h line 41
static inline char * ltoa_link1(char *buf_link1, signed long int val_link1)
{
  char *cp_link1 = buf_link1;
  char tmp_link1;
  signed long int i_link1;
  signed long int len_link1;
  char *tmp_post_1_link1;
  do
  {
    tmp_post_1_link1 = cp_link1;
    cp_link1 = cp_link1 + 1l;
    *tmp_post_1_link1 = (char)((signed long int)48 + val_link1 % (signed long int)10);
    val_link1 = val_link1 / (signed long int)10;
  }
  while(!(val_link1 == 0l));
  len_link1 = cp_link1 - buf_link1;
  cp_link1 = cp_link1 - 1l;
  i_link1 = (signed long int)0;
  for( ; !(i_link1 >= len_link1 / 2l); i_link1 = i_link1 + 1l)
  {
    tmp_link1 = buf_link1[i_link1];
    buf_link1[i_link1] = cp_link1[-i_link1];
    cp_link1[-i_link1] = tmp_link1;
  }
  return buf_link1 + len_link1;
}

// ltoa_link2
// file os-linux.h line 41
static inline char * ltoa_link2(char *buf_link2, signed long int val_link2)
{
  char *cp_link2 = buf_link2;
  char tmp_link2;
  signed long int i_link2;
  signed long int len_link2;
  char *tmp_post_1_link2;
  do
  {
    tmp_post_1_link2 = cp_link2;
    cp_link2 = cp_link2 + 1l;
    *tmp_post_1_link2 = (char)((signed long int)48 + val_link2 % (signed long int)10);
    val_link2 = val_link2 / (signed long int)10;
  }
  while(!(val_link2 == 0l));
  len_link2 = cp_link2 - buf_link2;
  cp_link2 = cp_link2 - 1l;
  i_link2 = (signed long int)0;
  for( ; !(i_link2 >= len_link2 / 2l); i_link2 = i_link2 + 1l)
  {
    tmp_link2 = buf_link2[i_link2];
    buf_link2[i_link2] = cp_link2[-i_link2];
    cp_link2[-i_link2] = tmp_link2;
  }
  return buf_link2 + len_link2;
}

// main
// file Gtest-concurrent.c line 107
signed int main(signed int argc, char **argv)
{
  if(argc >= 2)
    verbose = 1;

  if(!(verbose == 0))
    printf("Caching: none\n");

  _Ux86_64_set_caching_policy(_Ux86_64_local_addr_space, (enum anonymous_10)UNW_CACHE_NONE);
  doit();
  if(!(verbose == 0))
    printf("Caching: global\n");

  _Ux86_64_set_caching_policy(_Ux86_64_local_addr_space, (enum anonymous_10)UNW_CACHE_GLOBAL);
  doit();
  if(!(verbose == 0))
    printf("Caching: per-thread\n");

  _Ux86_64_set_caching_policy(_Ux86_64_local_addr_space, (enum anonymous_10)UNW_CACHE_PER_THREAD);
  doit();
  if(!(nerrors == 0))
  {
    fprintf(stderr, "FAILURE: detected %d errors\n", nerrors);
    exit(-1);
  }

  if(!(verbose == 0))
    printf("SUCCESS\n");

  return 0;
}

// maps_close
// file os-linux.h line 284
static inline void maps_close(struct map_iterator *mi)
{
  if(mi->fd >= 0)
  {
    close(mi->fd);
    mi->fd = -1;
    if(!(mi->buf == ((char *)NULL)))
    {
      munmap((void *)(mi->buf_end - (signed long int)mi->buf_size), mi->buf_size);
      mi->buf_end = (char *)(void *)0;
      mi->buf = mi->buf_end;
    }

  }

}

// maps_close_link1
// file os-linux.h line 284
static inline void maps_close_link1(struct map_iterator *mi_link1)
{
  if(mi_link1->fd >= 0)
  {
    close(mi_link1->fd);
    mi_link1->fd = -1;
    if(!(mi_link1->buf == ((char *)NULL)))
    {
      munmap((void *)(mi_link1->buf_end - (signed long int)mi_link1->buf_size), mi_link1->buf_size);
      mi_link1->buf_end = (char *)(void *)0;
      mi_link1->buf = mi_link1->buf_end;
    }

  }

}

// maps_close_link2
// file os-linux.h line 284
static inline void maps_close_link2(struct map_iterator *mi_link2)
{
  if(mi_link2->fd >= 0)
  {
    close(mi_link2->fd);
    mi_link2->fd = -1;
    if(!(mi_link2->buf == ((char *)NULL)))
    {
      munmap((void *)(mi_link2->buf_end - (signed long int)mi_link2->buf_size), mi_link2->buf_size);
      mi_link2->buf_end = (char *)(void *)0;
      mi_link2->buf = mi_link2->buf_end;
    }

  }

}

// maps_init
// file os-linux.h line 66
static inline signed int maps_init(struct map_iterator *mi, signed int pid)
{
  char path[(signed long int)sizeof(char [22l]) /*22l*/ ];
  char *cp;
  memcpy((void *)path, (const void *)"/proc/", (unsigned long int)6);
  cp=ltoa(path + (signed long int)6, (signed long int)pid);
  memcpy((void *)cp, (const void *)"/maps", (unsigned long int)6);
  mi->fd=open(path, 00);
  if(mi->fd >= 0)
  {
    signed int return_value_getpagesize_1;
    return_value_getpagesize_1=getpagesize();
    mi->buf_size = (unsigned long int)return_value_getpagesize_1;
    void *return_value_mmap_2;
    return_value_mmap_2=mmap((void *)0, mi->buf_size, 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
    cp = (char *)return_value_mmap_2;
    if(cp == (char *)-1)
    {
      close(mi->fd);
      mi->fd = -1;
      return -1;
    }

    else
    {
      mi->offset = (signed long int)0;
      mi->buf_end = cp + (signed long int)mi->buf_size;
      mi->buf = mi->buf_end;
      return 0;
    }
  }

  return -1;
}

// maps_init_link1
// file os-linux.h line 66
static inline signed int maps_init_link1(struct map_iterator *mi_link1, signed int pid_link1)
{
  char path_link1[(signed long int)sizeof(char [22l]) /*22l*/ ];
  char *cp_link1;
  memcpy((void *)path_link1, (const void *)"/proc/", (unsigned long int)6);
  cp_link1=ltoa_link1(path_link1 + (signed long int)6, (signed long int)pid_link1);
  memcpy((void *)cp_link1, (const void *)"/maps", (unsigned long int)6);
  mi_link1->fd=open(path_link1, 00);
  if(mi_link1->fd >= 0)
  {
    signed int return_value_getpagesize_1_link1;
    return_value_getpagesize_1_link1=getpagesize();
    mi_link1->buf_size = (unsigned long int)return_value_getpagesize_1_link1;
    void *return_value_mmap_2_link1;
    return_value_mmap_2_link1=mmap((void *)0, mi_link1->buf_size, 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
    cp_link1 = (char *)return_value_mmap_2_link1;
    if(cp_link1 == (char *)-1)
    {
      close(mi_link1->fd);
      mi_link1->fd = -1;
      return -1;
    }

    else
    {
      mi_link1->offset = (signed long int)0;
      mi_link1->buf_end = cp_link1 + (signed long int)mi_link1->buf_size;
      mi_link1->buf = mi_link1->buf_end;
      return 0;
    }
  }

  return -1;
}

// maps_init_link2
// file os-linux.h line 66
static inline signed int maps_init_link2(struct map_iterator *mi_link2, signed int pid_link2)
{
  char path_link2[(signed long int)sizeof(char [22l]) /*22l*/ ];
  char *cp_link2;
  memcpy((void *)path_link2, (const void *)"/proc/", (unsigned long int)6);
  cp_link2=ltoa_link2(path_link2 + (signed long int)6, (signed long int)pid_link2);
  memcpy((void *)cp_link2, (const void *)"/maps", (unsigned long int)6);
  mi_link2->fd=open(path_link2, 00);
  if(mi_link2->fd >= 0)
  {
    signed int return_value_getpagesize_1_link2;
    return_value_getpagesize_1_link2=getpagesize();
    mi_link2->buf_size = (unsigned long int)return_value_getpagesize_1_link2;
    void *return_value_mmap_2_link2;
    return_value_mmap_2_link2=mmap((void *)0, mi_link2->buf_size, 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
    cp_link2 = (char *)return_value_mmap_2_link2;
    if(cp_link2 == (char *)-1)
    {
      close(mi_link2->fd);
      mi_link2->fd = -1;
      return -1;
    }

    else
    {
      mi_link2->offset = (signed long int)0;
      mi_link2->buf_end = cp_link2 + (signed long int)mi_link2->buf_size;
      mi_link2->buf = mi_link2->buf_end;
      return 0;
    }
  }

  return -1;
}

// maps_next
// file os-linux.h line 203
static inline signed int maps_next(struct map_iterator *mi, unsigned long int *low, unsigned long int *high, unsigned long int *offset)
{
  char perm[16l];
  char dash = (char)0;
  char colon = (char)0;
  char *cp;
  unsigned long int major;
  unsigned long int minor;
  unsigned long int inum;
  signed long int i;
  signed long int nread;
  if(!(mi->fd >= 0))
    return 0;

  else
  {
    while((_Bool)1)
    {
      signed long int bytes_left = mi->buf_end - mi->buf;
      char *eol = (char *)(void *)0;
      i = (signed long int)0;
      for( ; !(i >= bytes_left); i = i + 1l)
        if((signed int)mi->buf[i] == 10)
        {
          eol = mi->buf + i;
          break;
        }

        else
          if((signed int)mi->buf[i] == 0)
            break;

      if(eol == ((char *)NULL))
      {
        if(bytes_left >= 1l)
          memmove((void *)(mi->buf_end - (signed long int)mi->buf_size), (const void *)mi->buf, (unsigned long int)bytes_left);

        mi->buf = mi->buf_end - (signed long int)mi->buf_size;
        nread=read(mi->fd, (void *)(mi->buf + bytes_left), mi->buf_size - (unsigned long int)bytes_left);
        if(!(nread >= 1l))
          return 0;

        else
          if(!((unsigned long int)bytes_left + (unsigned long int)nread >= mi->buf_size))
          {
            memmove((void *)((mi->buf_end - nread) - bytes_left), (const void *)mi->buf, (unsigned long int)(nread + bytes_left));
            mi->buf = (mi->buf_end - nread) - bytes_left;
          }

        eol = (mi->buf + bytes_left + nread) - (signed long int)1;
        i = bytes_left;
        for( ; !(i >= bytes_left + nread); i = i + 1l)
          if((signed int)mi->buf[i] == 10)
          {
            eol = mi->buf + i;
            break;
          }

      }

      cp = mi->buf;
      mi->buf = eol + (signed long int)1;
      *eol = (char)0;
      cp=scan_hex(cp, low);
      cp=scan_char(cp, &dash);
      cp=scan_hex(cp, high);
      cp=scan_string(cp, perm, sizeof(char [16l]) /*16ul*/ );
      cp=scan_hex(cp, offset);
      cp=scan_hex(cp, &major);
      cp=scan_char(cp, &colon);
      cp=scan_hex(cp, &minor);
      cp=scan_dec(cp, &inum);
      mi->path=skip_whitespace(cp);
      cp = mi->path;
      if(!(cp == ((char *)NULL)))
      {
        cp=scan_string(cp, (char *)(void *)0, (unsigned long int)0);
        if((signed int)colon == 58 && (signed int)dash == 45)
          return 1;

      }

    }
    return 0;
  }
}

// maps_next_link1
// file os-linux.h line 203
static inline signed int maps_next_link1(struct map_iterator *mi_link1, unsigned long int *low_link1, unsigned long int *high_link1, unsigned long int *offset_link1)
{
  char perm_link1[16l];
  char dash_link1 = (char)0;
  char colon_link1 = (char)0;
  char *cp_link1;
  unsigned long int major_link1;
  unsigned long int minor_link1;
  unsigned long int inum_link1;
  signed long int i_link1;
  signed long int nread_link1;
  if(!(mi_link1->fd >= 0))
    return 0;

  else
  {
    while((_Bool)1)
    {
      signed long int bytes_left_link1 = mi_link1->buf_end - mi_link1->buf;
      char *eol_link1 = (char *)(void *)0;
      i_link1 = (signed long int)0;
      for( ; !(i_link1 >= bytes_left_link1); i_link1 = i_link1 + 1l)
        if((signed int)mi_link1->buf[i_link1] == 10)
        {
          eol_link1 = mi_link1->buf + i_link1;
          break;
        }

        else
          if((signed int)mi_link1->buf[i_link1] == 0)
            break;

      if(eol_link1 == ((char *)NULL))
      {
        if(bytes_left_link1 >= 1l)
          memmove((void *)(mi_link1->buf_end - (signed long int)mi_link1->buf_size), (const void *)mi_link1->buf, (unsigned long int)bytes_left_link1);

        mi_link1->buf = mi_link1->buf_end - (signed long int)mi_link1->buf_size;
        nread_link1=read(mi_link1->fd, (void *)(mi_link1->buf + bytes_left_link1), mi_link1->buf_size - (unsigned long int)bytes_left_link1);
        if(!(nread_link1 >= 1l))
          return 0;

        else
          if(!((unsigned long int)bytes_left_link1 + (unsigned long int)nread_link1 >= mi_link1->buf_size))
          {
            memmove((void *)((mi_link1->buf_end - nread_link1) - bytes_left_link1), (const void *)mi_link1->buf, (unsigned long int)(nread_link1 + bytes_left_link1));
            mi_link1->buf = (mi_link1->buf_end - nread_link1) - bytes_left_link1;
          }

        eol_link1 = (mi_link1->buf + bytes_left_link1 + nread_link1) - (signed long int)1;
        i_link1 = bytes_left_link1;
        for( ; !(i_link1 >= bytes_left_link1 + nread_link1); i_link1 = i_link1 + 1l)
          if((signed int)mi_link1->buf[i_link1] == 10)
          {
            eol_link1 = mi_link1->buf + i_link1;
            break;
          }

      }

      cp_link1 = mi_link1->buf;
      mi_link1->buf = eol_link1 + (signed long int)1;
      *eol_link1 = (char)0;
      cp_link1=scan_hex_link1(cp_link1, low_link1);
      cp_link1=scan_char_link1(cp_link1, &dash_link1);
      cp_link1=scan_hex_link1(cp_link1, high_link1);
      cp_link1=scan_string_link1(cp_link1, perm_link1, sizeof(char [16l]) /*16ul*/ );
      cp_link1=scan_hex_link1(cp_link1, offset_link1);
      cp_link1=scan_hex_link1(cp_link1, &major_link1);
      cp_link1=scan_char_link1(cp_link1, &colon_link1);
      cp_link1=scan_hex_link1(cp_link1, &minor_link1);
      cp_link1=scan_dec_link1(cp_link1, &inum_link1);
      mi_link1->path=skip_whitespace_link1(cp_link1);
      cp_link1 = mi_link1->path;
      if(!(cp_link1 == ((char *)NULL)))
      {
        cp_link1=scan_string_link1(cp_link1, (char *)(void *)0, (unsigned long int)0);
        if((signed int)colon_link1 == 58 && (signed int)dash_link1 == 45)
          return 1;

      }

    }
    return 0;
  }
}

// maps_next_link2
// file os-linux.h line 203
static inline signed int maps_next_link2(struct map_iterator *mi_link2, unsigned long int *low_link2, unsigned long int *high_link2, unsigned long int *offset_link2)
{
  char perm_link2[16l];
  char dash_link2 = (char)0;
  char colon_link2 = (char)0;
  char *cp_link2;
  unsigned long int major_link2;
  unsigned long int minor_link2;
  unsigned long int inum_link2;
  signed long int i_link2;
  signed long int nread_link2;
  if(!(mi_link2->fd >= 0))
    return 0;

  else
  {
    while((_Bool)1)
    {
      signed long int bytes_left_link2 = mi_link2->buf_end - mi_link2->buf;
      char *eol_link2 = (char *)(void *)0;
      i_link2 = (signed long int)0;
      for( ; !(i_link2 >= bytes_left_link2); i_link2 = i_link2 + 1l)
        if((signed int)mi_link2->buf[i_link2] == 10)
        {
          eol_link2 = mi_link2->buf + i_link2;
          break;
        }

        else
          if((signed int)mi_link2->buf[i_link2] == 0)
            break;

      if(eol_link2 == ((char *)NULL))
      {
        if(bytes_left_link2 >= 1l)
          memmove((void *)(mi_link2->buf_end - (signed long int)mi_link2->buf_size), (const void *)mi_link2->buf, (unsigned long int)bytes_left_link2);

        mi_link2->buf = mi_link2->buf_end - (signed long int)mi_link2->buf_size;
        nread_link2=read(mi_link2->fd, (void *)(mi_link2->buf + bytes_left_link2), mi_link2->buf_size - (unsigned long int)bytes_left_link2);
        if(!(nread_link2 >= 1l))
          return 0;

        else
          if(!((unsigned long int)bytes_left_link2 + (unsigned long int)nread_link2 >= mi_link2->buf_size))
          {
            memmove((void *)((mi_link2->buf_end - nread_link2) - bytes_left_link2), (const void *)mi_link2->buf, (unsigned long int)(nread_link2 + bytes_left_link2));
            mi_link2->buf = (mi_link2->buf_end - nread_link2) - bytes_left_link2;
          }

        eol_link2 = (mi_link2->buf + bytes_left_link2 + nread_link2) - (signed long int)1;
        i_link2 = bytes_left_link2;
        for( ; !(i_link2 >= bytes_left_link2 + nread_link2); i_link2 = i_link2 + 1l)
          if((signed int)mi_link2->buf[i_link2] == 10)
          {
            eol_link2 = mi_link2->buf + i_link2;
            break;
          }

      }

      cp_link2 = mi_link2->buf;
      mi_link2->buf = eol_link2 + (signed long int)1;
      *eol_link2 = (char)0;
      cp_link2=scan_hex_link2(cp_link2, low_link2);
      cp_link2=scan_char_link2(cp_link2, &dash_link2);
      cp_link2=scan_hex_link2(cp_link2, high_link2);
      cp_link2=scan_string_link2(cp_link2, perm_link2, sizeof(char [16l]) /*16ul*/ );
      cp_link2=scan_hex_link2(cp_link2, offset_link2);
      cp_link2=scan_hex_link2(cp_link2, &major_link2);
      cp_link2=scan_char_link2(cp_link2, &colon_link2);
      cp_link2=scan_hex_link2(cp_link2, &minor_link2);
      cp_link2=scan_dec_link2(cp_link2, &inum_link2);
      mi_link2->path=skip_whitespace_link2(cp_link2);
      cp_link2 = mi_link2->path;
      if(!(cp_link2 == ((char *)NULL)))
      {
        cp_link2=scan_string_link2(cp_link2, (char *)(void *)0, (unsigned long int)0);
        if((signed int)colon_link2 == 58 && (signed int)dash_link2 == 45)
          return 1;

      }

    }
    return 0;
  }
}

// mincore_validate
// file x86_64/Ginit.c line 81
static signed int mincore_validate(void *addr, unsigned long int len)
{
  unsigned char mvec[2l];
  signed int return_value_mincore_1;
  return_value_mincore_1=mincore(addr, len, mvec);
  return return_value_mincore_1;
}

// msync_validate
// file x86_64/Ginit.c line 75
static signed int msync_validate(void *addr, unsigned long int len)
{
  signed int return_value_msync_1;
  return_value_msync_1=msync(addr, len, 1);
  return return_value_msync_1;
}

// parse_cie
// file dwarf/Gfde.c line 46
static inline signed int parse_cie(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int addr, const struct unw_proc_info *pi, struct dwarf_cie_info *dci, unsigned long int base, void *arg)
{
  unsigned char version;
  unsigned char ch;
  unsigned char augstr[5l];
  unsigned char fde_encoding;
  unsigned char handler_encoding;
  unsigned long int len;
  unsigned long int cie_end_addr;
  unsigned long int aug_size;
  unsigned int u32val;
  unsigned long int u64val;
  unsigned long int i;
  signed int ret;
  switch(sizeof(unsigned long int) /*8ul*/ )
  {
    case (unsigned long int)4:
    {
      fde_encoding = (unsigned char)0x03;
      break;
    }
    case (unsigned long int)8:
    {
      fde_encoding = (unsigned char)0x04;
      break;
    }
    default:
      fde_encoding = (unsigned char)0xff;
  }
  dci->lsda_encoding = (unsigned char)0xff;
  dci->handler = (unsigned long int)0;
  ret=dwarf_readu32_link1(as, a, &addr, &u32val, arg);
  unsigned long int tmp_post_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!(ret >= 0))
    return ret;

  else
  {
    if(!(u32val == 0xffffffff))
    {
      unsigned int parse_cie__1__2__cie_id;
      const unsigned int expected_id = base != 0ul ? 0xffffffff : (unsigned int)0;
      len = (unsigned long int)u32val;
      cie_end_addr = addr + len;
      ret=dwarf_readu32_link1(as, a, &addr, &parse_cie__1__2__cie_id, arg);
      if(!(ret >= 0))
        return ret;

      if(!(parse_cie__1__2__cie_id == expected_id))
        return -UNW_EINVAL;

    }

    else
    {
      unsigned long int cie_id;
      const unsigned long int parse_cie__1__3__expected_id = base != 0ul ? 0xffffffffffffffffull : (unsigned long int)0;
      ret=dwarf_readu64_link1(as, a, &addr, &u64val, arg);
      if(!(ret >= 0))
        return ret;

      len = u64val;
      cie_end_addr = addr + len;
      ret=dwarf_readu64_link1(as, a, &addr, &cie_id, arg);
      if(!(ret >= 0))
        return ret;

      if(!(cie_id == parse_cie__1__3__expected_id))
        return -UNW_EINVAL;

    }
    dci->cie_instr_end = cie_end_addr;
    ret=dwarf_readu8_link1(as, a, &addr, &version, arg);
    if(!(ret >= 0))
      return ret;

    else
      if(!((signed int)version == 1) && !((signed int)version == 3))
        return -UNW_EBADVERSION;

      else
      {
        memset((void *)augstr, 0, sizeof(unsigned char [5l]) /*5ul*/ );
        i = (unsigned long int)0;
        do
        {
          ret=dwarf_readu8_link1(as, a, &addr, &ch, arg);
          if(!(ret >= 0))
            return ret;

          if(ch == 0)
            break;

          if(!(i >= 4ul))
          {
            tmp_post_1 = i;
            i = i + 1ul;
            augstr[(signed long int)tmp_post_1] = ch;
          }

        }
        while((_Bool)1);
        ret=dwarf_read_uleb128_link1(as, a, &addr, &dci->code_align, arg);
        if(!(ret >= 0))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          ret=dwarf_read_sleb128_link1(as, a, &addr, &dci->data_align, arg);
          tmp_if_expr_2 = ret < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          return ret;

        else
        {
          if((signed int)version == 1)
          {
            ret=dwarf_readu8_link1(as, a, &addr, &ch, arg);
            if(!(ret >= 0))
              return ret;

            dci->ret_addr_column = (unsigned long int)ch;
          }

          else
          {
            ret=dwarf_read_uleb128_link1(as, a, &addr, &dci->ret_addr_column, arg);
            if(!(ret >= 0))
              return ret;

          }
          i = (unsigned long int)0;
          if((signed int)augstr[0l] == 122)
          {
            dci->sized_augmentation = (unsigned int)1;
            ret=dwarf_read_uleb128_link1(as, a, &addr, &aug_size, arg);
            if(!(ret >= 0))
              return ret;

            i = i + 1ul;
          }

          do
          {
            if(!(i >= sizeof(unsigned char [5l]) /*5ul*/ ))
              tmp_if_expr_3 = augstr[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
            if(!tmp_if_expr_3)
              break;

            switch((signed int)augstr[(signed long int)i])
            {
              case 76:
              {
                ret=dwarf_readu8_link1(as, a, &addr, &ch, arg);
                if(!(ret >= 0))
                  return ret;

                dci->lsda_encoding = ch;
                break;
              }
              case 82:
              {
                ret=dwarf_readu8_link1(as, a, &addr, &fde_encoding, arg);
                if(!(ret >= 0))
                  return ret;

                break;
              }
              case 80:
              {
                ret=dwarf_readu8_link1(as, a, &addr, &handler_encoding, arg);
                if(!(ret >= 0))
                  return ret;

                ret=_Ux86_64_dwarf_read_encoded_pointer(as, a, &addr, handler_encoding, pi, &dci->handler, arg);
                if(!(ret >= 0))
                  return ret;

                break;
              }
              case 83:
              {
                dci->signal_frame = (unsigned int)1;
                dci->have_abi_marker = (unsigned int)1;
                break;
              }
              default:
                if(!(dci->sized_augmentation == 0u))
                  goto done;

                else
                  return -UNW_EINVAL;
            }
            i = i + 1ul;
          }
          while((_Bool)1);

        done:
          ;
          dci->fde_encoding = fde_encoding;
          dci->cie_instr_start = addr;
          return 0;
        }
      }
  }
}

// parse_dynamic
// file dwarf/Gparser.c line 450
static signed int parse_dynamic(struct dwarf_cursor *c, unsigned long int ip, struct dwarf_state_record *sr)
{
  return -UNW_ENOINFO;
}

// parse_fde
// file dwarf/Gparser.c line 476
static inline signed int parse_fde(struct dwarf_cursor *c, unsigned long int ip, struct dwarf_state_record *sr)
{
  struct dwarf_cie_info *dci;
  unsigned long int addr;
  signed int ret;
  dci = (struct dwarf_cie_info *)c->pi.unwind_info;
  c->ret_addr_column = dci->ret_addr_column;
  addr = dci->cie_instr_start;
  ret=run_cfi_program(c, sr, ~((unsigned long int)0), &addr, dci->cie_instr_end, dci);
  if(!(ret >= 0))
    return ret;

  else
  {
    memcpy((void *)&sr->rs_initial, (const void *)&sr->rs_current, sizeof(struct dwarf_reg_state) /*336ul*/ );
    addr = dci->fde_instr_start;
    ret=run_cfi_program(c, sr, ip, &addr, dci->fde_instr_end, dci);
    if(!(ret >= 0))
      return ret;

    else
      return 0;
  }
}

// put_rs_cache
// file dwarf/Gparser.c line 544
static inline void put_rs_cache(struct unw_addr_space *as, struct dwarf_rs_cache *cache, struct anonymous_8 *saved_maskp)
{
  if((signed int)as->caching_policy == UNW_CACHE_GLOBAL)
    do
    {
      pthread_mutex_unlock(&cache->lock);
      sigprocmask(2, &(*saved_maskp), (struct anonymous_8 *)(void *)0);
    }
    while((_Bool)0);

}

// put_unwind_info
// file x86_64/Ginit.c line 58
static void put_unwind_info(struct unw_addr_space *as, struct unw_proc_info *proc_info, void *arg)
{
  ;
}

// put_unwind_info_link1
// file dwarf/Gparser.c line 461
static inline void put_unwind_info_link1(struct dwarf_cursor *c, struct unw_proc_info *pi)
{
  if(!(c->pi_valid == 0u))
  {
    if(!(c->pi_is_dynamic == 0u))
      _Ux86_64_Iput_dynamic_unwind_info(c->as, pi, c->as_arg);

    else
      if(!(pi->unwind_info == NULL))
      {
        _UIx86_64__mempool_free(&dwarf_cie_info_pool, pi->unwind_info);
        pi->unwind_info = (void *)0;
      }

  }

}

// read_operand
// file dwarf/Gexpr.c line 124
static inline unsigned long int read_operand(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, signed int operand_type, unsigned long int *val, void *arg)
{
  unsigned char u8;
  unsigned short int u16;
  unsigned int u32;
  unsigned long int u64;
  signed int ret;
  if(operand_type == 0x7)
    switch(sizeof(unsigned long int) /*8ul*/ )
    {
      case (unsigned long int)1:
      {
        operand_type = 0x0;
        break;
      }
      case (unsigned long int)2:
      {
        operand_type = 0x1;
        break;
      }
      case (unsigned long int)4:
      {
        operand_type = 0x2;
        break;
      }
      case (unsigned long int)8:
      {
        operand_type = 0x3;
        break;
      }
      default:
        abort();
    }

  switch(operand_type)
  {
    case 0x0:
    {
      ret=dwarf_readu8(as, a, addr, &u8, arg);
      if(!(ret >= 0))
        return (unsigned long int)ret;

      *val = (unsigned long int)u8;
      break;
    }
    case 0x1:
    {
      ret=dwarf_readu16(as, a, addr, &u16, arg);
      if(!(ret >= 0))
        return (unsigned long int)ret;

      *val = (unsigned long int)u16;
      break;
    }
    case 0x2:
    {
      ret=dwarf_readu32(as, a, addr, &u32, arg);
      if(!(ret >= 0))
        return (unsigned long int)ret;

      *val = (unsigned long int)u32;
      break;
    }
    case 0x3:
    {
      ret=dwarf_readu64(as, a, addr, &u64, arg);
      if(!(ret >= 0))
        return (unsigned long int)ret;

      *val = u64;
      break;
    }
    case 0x4:
    {
      ret=dwarf_read_uleb128(as, a, addr, val, arg);
      break;
    }
    case 0x5:
    {
      ret=dwarf_read_sleb128(as, a, addr, val, arg);
      break;
    }
    case 0x6:

    default:
      ret = -UNW_EINVAL;
  }
  return (unsigned long int)ret;
}

// read_regnum
// file dwarf/Gparser.c line 34
static inline signed int read_regnum(struct unw_addr_space *as, struct unw_accessors *a, unsigned long int *addr, unsigned long int *valp, void *arg)
{
  signed int ret;
  ret=dwarf_read_uleb128_link2(as, a, addr, valp, arg);
  if(!(ret >= 0))
    return ret;

  else
    if(*valp >= 17ul)
      return -UNW_EBADREG;

    else
      return 0;
}

// remote_find_proc_info
// file mi/Gfind_dynamic_proc_info.c line 74
static inline signed int remote_find_proc_info(struct unw_addr_space *as, unsigned long int ip, struct unw_proc_info *pi, signed int need_unwind_info, void *arg)
{
  signed int return_value__Ux86_64_Idyn_remote_find_proc_info_1;
  return_value__Ux86_64_Idyn_remote_find_proc_info_1=_Ux86_64_Idyn_remote_find_proc_info(as, ip, pi, need_unwind_info, arg);
  return return_value__Ux86_64_Idyn_remote_find_proc_info_1;
}

// remote_lookup
// file dwarf/Gfind_proc_info-lsb.c line 788
static signed int remote_lookup(struct unw_addr_space *as, unsigned long int table, unsigned long int table_size, signed int rel_ip, struct table_entry *e, void *arg)
{
  unsigned long int table_len = table_size / sizeof(struct table_entry) /*8ul*/ ;
  struct unw_accessors *a;
  a=_Ux86_64_get_accessors(as);
  unsigned long int lo;
  unsigned long int hi;
  unsigned long int mid;
  unsigned long int e_addr = (unsigned long int)0;
  signed int start;
  signed int ret;
  lo = (unsigned long int)0;
  hi = table_len;
  while(!(lo >= hi))
  {
    mid = (lo + hi) / (unsigned long int)2;
    e_addr = table + mid * sizeof(struct table_entry) /*8ul*/ ;
    ret=dwarf_reads32_link2(as, a, &e_addr, &start, arg);
    if(!(ret >= 0))
      return ret;

    if(!(rel_ip >= start))
      hi = mid;

    else
      lo = mid + (unsigned long int)1;
  }
  _Bool tmp_if_expr_1;
  if(!(hi >= 1ul))
    return 0;

  else
  {
    e_addr = table + (hi - (unsigned long int)1) * sizeof(struct table_entry) /*8ul*/ ;
    ret=dwarf_reads32_link2(as, a, &e_addr, &e->start_ip_offset, arg);
    if(!(ret >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      ret=dwarf_reads32_link2(as, a, &e_addr, &e->fde_offset, arg);
      tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      return ret;

    else
      return 1;
  }
}

// rs_lookup
// file dwarf/Gparser.c line 572
static struct dwarf_reg_state * rs_lookup(struct dwarf_rs_cache *cache, struct dwarf_cursor *c)
{
  struct dwarf_reg_state *rs = cache->buckets + (signed long int)c->hint;
  unsigned short int index;
  unsigned long int ip = c->ip;
  signed long int return_value_cache_match_1;
  return_value_cache_match_1=cache_match(rs, ip);
  if(!(return_value_cache_match_1 == 0l))
    return rs;

  else
  {
    unsigned char return_value_hash_2;
    return_value_hash_2=hash(ip);
    index = cache->hash[(signed long int)return_value_hash_2];
    if((signed int)index >= 128)
      return (struct dwarf_reg_state *)(void *)0;

    else
    {
      rs = cache->buckets + (signed long int)index;
      while((_Bool)1)
      {
        signed long int return_value_cache_match_3;
        return_value_cache_match_3=cache_match(rs, ip);
        if(!(return_value_cache_match_3 == 0l))
        {
          cache->buckets[(signed long int)c->prev_rs].hint = (unsigned short int)(rs - cache->buckets);
          c->hint = (signed short int)cache->buckets[(signed long int)c->prev_rs].hint;
          return rs;
        }

        if((signed int)rs->coll_chain >= 256)
          return (struct dwarf_reg_state *)(void *)0;

        rs = cache->buckets + (signed long int)rs->coll_chain;
      }
    }
  }
}

// rs_new
// file dwarf/Gparser.c line 604
static inline struct dwarf_reg_state * rs_new(struct dwarf_rs_cache *cache, struct dwarf_cursor *c)
{
  struct dwarf_reg_state *rs;
  struct dwarf_reg_state *prev;
  struct dwarf_reg_state *tmp;
  unsigned char index;
  unsigned short int head = cache->lru_head;
  rs = cache->buckets + (signed long int)head;
  cache->lru_head = rs->lru_chain;
  cache->buckets[(signed long int)cache->lru_tail].lru_chain = head;
  cache->lru_tail = head;
  if(!(rs->ip == 0ul))
  {
    index=hash(rs->ip);
    tmp = cache->buckets + (signed long int)cache->hash[(signed long int)index];
    prev = (struct dwarf_reg_state *)(void *)0;
    for( ; (_Bool)1; tmp = cache->buckets + (signed long int)tmp->coll_chain)
    {
      if(tmp == rs)
      {
        if(!(prev == ((struct dwarf_reg_state *)NULL)))
          prev->coll_chain = tmp->coll_chain;

        else
          cache->hash[(signed long int)index] = tmp->coll_chain;
        break;
      }

      else
        prev = tmp;
      if((signed int)tmp->coll_chain >= 128)
        break;

    }
  }

  index=hash(c->ip);
  rs->coll_chain = cache->hash[(signed long int)index];
  cache->hash[(signed long int)index] = (unsigned short int)(rs - cache->buckets);
  rs->hint = (unsigned short int)0;
  rs->ip = c->ip;
  rs->valid = (unsigned short int)1;
  rs->ret_addr_column = c->ret_addr_column;
  rs->signal_frame = (unsigned short int)0;
  _Ux86_64_cache_frame(c, rs);
  return rs;
}

// run_cfi_program
// file dwarf/Gparser.c line 60
static signed int run_cfi_program(struct dwarf_cursor *c, struct dwarf_state_record *sr, unsigned long int ip, unsigned long int *addr, unsigned long int end_addr, struct dwarf_cie_info *dci)
{
  unsigned long int curr_ip;
  unsigned long int operand = (unsigned long int)0;
  unsigned long int regnum;
  unsigned long int val;
  unsigned long int len;
  unsigned long int fde_encoding;
  struct dwarf_reg_state *rs_stack = (struct dwarf_reg_state *)(void *)0;
  struct dwarf_reg_state *new_rs;
  struct dwarf_reg_state *old_rs;
  struct unw_addr_space *as;
  struct unw_accessors *a;
  unsigned char u8;
  unsigned char op;
  unsigned short int u16;
  unsigned int u32;
  void *arg;
  signed int ret;
  as = c->as;
  arg = c->as_arg;
  if(!((32ul & c->pi.flags) == 0ul))
  {
    as = _Ux86_64_local_addr_space;
    arg = (void *)0;
  }

  a=_Ux86_64_get_accessors(as);
  curr_ip = c->pi.start_ip;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  void *return_value__UIx86_64__mempool_alloc_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  while(ip >= curr_ip)
  {
    if(*addr >= end_addr)
      break;

    ret=dwarf_readu8_link2(as, a, addr, &op, arg);
    if(!(ret >= 0))
      return ret;

    if(!((0xc0 & (signed int)op) == 0))
    {
      operand = (unsigned long int)((signed int)op & 0x3f);
      op = op & (unsigned char)~0x3f;
    }

    switch((signed int)(enum anonymous_15)op)
    {
      case DW_CFA_advance_loc:
      {
        curr_ip = curr_ip + operand * dci->code_align;
        break;
      }
      case DW_CFA_advance_loc1:
      {
        ret=dwarf_readu8_link2(as, a, addr, &u8, arg);
        if(!(ret >= 0))
          goto fail;

        curr_ip = curr_ip + (unsigned long int)u8 * dci->code_align;
        break;
      }
      case DW_CFA_advance_loc2:
      {
        ret=dwarf_readu16_link2(as, a, addr, &u16, arg);
        if(!(ret >= 0))
          goto fail;

        curr_ip = curr_ip + (unsigned long int)u16 * dci->code_align;
        break;
      }
      case DW_CFA_advance_loc4:
      {
        ret=dwarf_readu32_link2(as, a, addr, &u32, arg);
        if(!(ret >= 0))
          goto fail;

        curr_ip = curr_ip + (unsigned long int)u32 * dci->code_align;
        break;
      }
      case DW_CFA_MIPS_advance_loc8:
      {
        ret = -UNW_EINVAL;
        goto fail;
      }
      case DW_CFA_offset:
      {
        regnum = operand;
        if(regnum >= 17ul)
        {
          ret = -UNW_EBADREG;
          goto fail;
        }

        ret=dwarf_read_uleb128_link2(as, a, addr, &val, arg);
        if(!(ret >= 0))
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_CFAREL, val * dci->data_align);
        break;
      }
      case DW_CFA_offset_extended:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          tmp_if_expr_1 = (_Bool)1;

        else
        {
          ret=dwarf_read_uleb128_link2(as, a, addr, &val, arg);
          tmp_if_expr_1 = ret < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_1)
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_CFAREL, val * dci->data_align);
        break;
      }
      case DW_CFA_offset_extended_sf:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          ret=dwarf_read_sleb128_link2(as, a, addr, &val, arg);
          tmp_if_expr_2 = ret < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_CFAREL, val * dci->data_align);
        break;
      }
      case DW_CFA_restore:
      {
        regnum = operand;
        if(regnum >= 17ul)
        {
          ret = -UNW_EINVAL;
          goto fail;
        }

        sr->rs_current.reg[(signed long int)regnum] = sr->rs_initial.reg[(signed long int)regnum];
        break;
      }
      case DW_CFA_restore_extended:
      {
        ret=dwarf_read_uleb128_link2(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          goto fail;

        if(regnum >= 17ul)
        {
          ret = -UNW_EINVAL;
          goto fail;
        }

        sr->rs_current.reg[(signed long int)regnum] = sr->rs_initial.reg[(signed long int)regnum];
        break;
      }
      case DW_CFA_nop:
        break;
      case DW_CFA_set_loc:
      {
        fde_encoding = (unsigned long int)dci->fde_encoding;
        ret=_Ux86_64_dwarf_read_encoded_pointer(as, a, addr, (unsigned char)fde_encoding, &c->pi, &curr_ip, arg);
        if(!(ret >= 0))
          goto fail;

        break;
      }
      case DW_CFA_undefined:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_UNDEF, (unsigned long int)0);
        break;
      }
      case DW_CFA_same_value:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_SAME, (unsigned long int)0);
        break;
      }
      case DW_CFA_register:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          ret=dwarf_read_uleb128_link2(as, a, addr, &val, arg);
          tmp_if_expr_3 = ret < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_REG, val);
        break;
      }
      case DW_CFA_remember_state:
      {
        return_value__UIx86_64__mempool_alloc_4=_UIx86_64__mempool_alloc(&dwarf_reg_state_pool);
        new_rs = (struct dwarf_reg_state *)return_value__UIx86_64__mempool_alloc_4;
        if(new_rs == ((struct dwarf_reg_state *)NULL))
        {
          ret = -UNW_ENOMEM;
          goto fail;
        }

        memcpy((void *)new_rs->reg, (const void *)sr->rs_current.reg, sizeof(struct anonymous_12 [19l]) /*304ul*/ );
        new_rs->next = rs_stack;
        rs_stack = new_rs;
        break;
      }
      case DW_CFA_restore_state:
      {
        if(rs_stack == ((struct dwarf_reg_state *)NULL))
        {
          ret = -UNW_EINVAL;
          goto fail;
        }

        memcpy((void *)&sr->rs_current.reg, (const void *)&rs_stack->reg, sizeof(struct anonymous_12 [19l]) /*304ul*/ );
        old_rs = rs_stack;
        rs_stack = rs_stack->next;
        _UIx86_64__mempool_free(&dwarf_reg_state_pool, (void *)old_rs);
        break;
      }
      case DW_CFA_def_cfa:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          ret=dwarf_read_uleb128_link2(as, a, addr, &val, arg);
          tmp_if_expr_5 = ret < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          goto fail;

        set_reg(sr, (unsigned long int)17, (enum anonymous_13)DWARF_WHERE_REG, regnum);
        set_reg(sr, (unsigned long int)(17 + 1), (enum anonymous_13)0, val);
        break;
      }
      case DW_CFA_def_cfa_sf:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          ret=dwarf_read_sleb128_link2(as, a, addr, &val, arg);
          tmp_if_expr_6 = ret < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          goto fail;

        set_reg(sr, (unsigned long int)17, (enum anonymous_13)DWARF_WHERE_REG, regnum);
        set_reg(sr, (unsigned long int)(17 + 1), (enum anonymous_13)0, val * dci->data_align);
        break;
      }
      case DW_CFA_def_cfa_register:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          goto fail;

        set_reg(sr, (unsigned long int)17, (enum anonymous_13)DWARF_WHERE_REG, regnum);
        break;
      }
      case DW_CFA_def_cfa_offset:
      {
        ret=dwarf_read_uleb128_link2(as, a, addr, &val, arg);
        if(!(ret >= 0))
          goto fail;

        set_reg(sr, (unsigned long int)(17 + 1), (enum anonymous_13)0, val);
        break;
      }
      case DW_CFA_def_cfa_offset_sf:
      {
        ret=dwarf_read_sleb128_link2(as, a, addr, &val, arg);
        if(!(ret >= 0))
          goto fail;

        set_reg(sr, (unsigned long int)(17 + 1), (enum anonymous_13)0, val * dci->data_align);
        break;
      }
      case DW_CFA_def_cfa_expression:
      {
        set_reg(sr, (unsigned long int)17, (enum anonymous_13)DWARF_WHERE_EXPR, *addr);
        ret=dwarf_read_uleb128_link2(as, a, addr, &len, arg);
        if(!(ret >= 0))
          goto fail;

        *addr = *addr + len;
        break;
      }
      case DW_CFA_expression:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_EXPR, *addr);
        ret=dwarf_read_uleb128_link2(as, a, addr, &len, arg);
        if(!(ret >= 0))
          goto fail;

        *addr = *addr + len;
        break;
      }
      case DW_CFA_GNU_args_size:
      {
        ret=dwarf_read_uleb128_link2(as, a, addr, &val, arg);
        if(!(ret >= 0))
          goto fail;

        sr->args_size = val;
        break;
      }
      case DW_CFA_GNU_negative_offset_extended:
      {
        ret=read_regnum(as, a, addr, &regnum, arg);
        if(!(ret >= 0))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          ret=dwarf_read_uleb128_link2(as, a, addr, &val, arg);
          tmp_if_expr_7 = ret < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
          goto fail;

        set_reg(sr, regnum, (enum anonymous_13)DWARF_WHERE_CFAREL, -(val * dci->data_align));
        break;
      }
      case DW_CFA_GNU_window_save:

      case DW_CFA_lo_user:

      case DW_CFA_hi_user:
      {
        ret = -UNW_EINVAL;
        goto fail;
      }
      default:
        ;
    }
  }
  ret = 0;

fail:
  ;
  while(!(rs_stack == ((struct dwarf_reg_state *)NULL)))
  {
    old_rs = rs_stack;
    rs_stack = rs_stack->next;
    _UIx86_64__mempool_free(&dwarf_reg_state_pool, (void *)old_rs);
  }
  return ret;
}

// scan_char
// file os-linux.h line 167
static inline char * scan_char(char *cp, char *valp)
{
  if(cp == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    *valp = *cp;
    if(!(*cp == 0))
      cp = cp + 1l;

    return cp;
  }
}

// scan_char_link1
// file os-linux.h line 167
static inline char * scan_char_link1(char *cp_link1, char *valp_link1)
{
  if(cp_link1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    *valp_link1 = *cp_link1;
    if(!(*cp_link1 == 0))
      cp_link1 = cp_link1 + 1l;

    return cp_link1;
  }
}

// scan_char_link2
// file os-linux.h line 167
static inline char * scan_char_link2(char *cp_link2, char *valp_link2)
{
  if(cp_link2 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    *valp_link2 = *cp_link2;
    if(!(*cp_link2 == 0))
      cp_link2 = cp_link2 + 1l;

    return cp_link2;
  }
}

// scan_dec
// file os-linux.h line 140
static inline char * scan_dec(char *cp, unsigned long int *valp)
{
  unsigned long int num_digits = (unsigned long int)0;
  unsigned long int digit;
  unsigned long int val = (unsigned long int)0;
  cp=skip_whitespace(cp);
  if(cp == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; num_digits = num_digits + 1ul)
    {
      digit = (unsigned long int)*cp;
      if(!(digit + 18446744073709551568ul >= 10ul))
      {
        digit = digit - (unsigned long int)48;
        cp = cp + 1l;
      }

      else
        break;
      val = (unsigned long int)10 * val + digit;
    }
    if(num_digits == 0ul)
      return (char *)(void *)0;

    else
    {
      *valp = val;
      return cp;
    }
  }
}

// scan_dec_link1
// file os-linux.h line 140
static inline char * scan_dec_link1(char *cp_link1, unsigned long int *valp_link1)
{
  unsigned long int num_digits_link1 = (unsigned long int)0;
  unsigned long int digit_link1;
  unsigned long int val_link1 = (unsigned long int)0;
  cp_link1=skip_whitespace_link1(cp_link1);
  if(cp_link1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; num_digits_link1 = num_digits_link1 + 1ul)
    {
      digit_link1 = (unsigned long int)*cp_link1;
      if(!(digit_link1 + 18446744073709551568ul >= 10ul))
      {
        digit_link1 = digit_link1 - (unsigned long int)48;
        cp_link1 = cp_link1 + 1l;
      }

      else
        break;
      val_link1 = (unsigned long int)10 * val_link1 + digit_link1;
    }
    if(num_digits_link1 == 0ul)
      return (char *)(void *)0;

    else
    {
      *valp_link1 = val_link1;
      return cp_link1;
    }
  }
}

// scan_dec_link2
// file os-linux.h line 140
static inline char * scan_dec_link2(char *cp_link2, unsigned long int *valp_link2)
{
  unsigned long int num_digits_link2 = (unsigned long int)0;
  unsigned long int digit_link2;
  unsigned long int val_link2 = (unsigned long int)0;
  cp_link2=skip_whitespace_link2(cp_link2);
  if(cp_link2 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; num_digits_link2 = num_digits_link2 + 1ul)
    {
      digit_link2 = (unsigned long int)*cp_link2;
      if(!(digit_link2 + 18446744073709551568ul >= 10ul))
      {
        digit_link2 = digit_link2 - (unsigned long int)48;
        cp_link2 = cp_link2 + 1l;
      }

      else
        break;
      val_link2 = (unsigned long int)10 * val_link2 + digit_link2;
    }
    if(num_digits_link2 == 0ul)
      return (char *)(void *)0;

    else
    {
      *valp_link2 = val_link2;
      return cp_link2;
    }
  }
}

// scan_hex
// file os-linux.h line 110
static inline char * scan_hex(char *cp, unsigned long int *valp)
{
  unsigned long int num_digits = (unsigned long int)0;
  unsigned long int digit;
  unsigned long int val = (unsigned long int)0;
  cp=skip_whitespace(cp);
  if(cp == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; cp = cp + 1l)
    {
      digit = (unsigned long int)*cp;
      if(!(digit + 18446744073709551568ul >= 10ul))
        digit = digit - (unsigned long int)48;

      else
        if(!(digit + 18446744073709551519ul >= 6ul))
          digit = digit - (unsigned long int)(97 - 10);

        else
          if(!(digit + 18446744073709551551ul >= 6ul))
            digit = digit - (unsigned long int)(65 - 10);

          else
            break;
      val = val << 4 | digit;
      num_digits = num_digits + 1ul;
    }
    if(num_digits == 0ul)
      return (char *)(void *)0;

    else
    {
      *valp = val;
      return cp;
    }
  }
}

// scan_hex_link1
// file os-linux.h line 110
static inline char * scan_hex_link1(char *cp_link1, unsigned long int *valp_link1)
{
  unsigned long int num_digits_link1 = (unsigned long int)0;
  unsigned long int digit_link1;
  unsigned long int val_link1 = (unsigned long int)0;
  cp_link1=skip_whitespace_link1(cp_link1);
  if(cp_link1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; cp_link1 = cp_link1 + 1l)
    {
      digit_link1 = (unsigned long int)*cp_link1;
      if(!(digit_link1 + 18446744073709551568ul >= 10ul))
        digit_link1 = digit_link1 - (unsigned long int)48;

      else
        if(!(digit_link1 + 18446744073709551519ul >= 6ul))
          digit_link1 = digit_link1 - (unsigned long int)(97 - 10);

        else
          if(!(digit_link1 + 18446744073709551551ul >= 6ul))
            digit_link1 = digit_link1 - (unsigned long int)(65 - 10);

          else
            break;
      val_link1 = val_link1 << 4 | digit_link1;
      num_digits_link1 = num_digits_link1 + 1ul;
    }
    if(num_digits_link1 == 0ul)
      return (char *)(void *)0;

    else
    {
      *valp_link1 = val_link1;
      return cp_link1;
    }
  }
}

// scan_hex_link2
// file os-linux.h line 110
static inline char * scan_hex_link2(char *cp_link2, unsigned long int *valp_link2)
{
  unsigned long int num_digits_link2 = (unsigned long int)0;
  unsigned long int digit_link2;
  unsigned long int val_link2 = (unsigned long int)0;
  cp_link2=skip_whitespace_link2(cp_link2);
  if(cp_link2 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; cp_link2 = cp_link2 + 1l)
    {
      digit_link2 = (unsigned long int)*cp_link2;
      if(!(digit_link2 + 18446744073709551568ul >= 10ul))
        digit_link2 = digit_link2 - (unsigned long int)48;

      else
        if(!(digit_link2 + 18446744073709551519ul >= 6ul))
          digit_link2 = digit_link2 - (unsigned long int)(97 - 10);

        else
          if(!(digit_link2 + 18446744073709551551ul >= 6ul))
            digit_link2 = digit_link2 - (unsigned long int)(65 - 10);

          else
            break;
      val_link2 = val_link2 << 4 | digit_link2;
      num_digits_link2 = num_digits_link2 + 1ul;
    }
    if(num_digits_link2 == 0ul)
      return (char *)(void *)0;

    else
    {
      *valp_link2 = val_link2;
      return cp_link2;
    }
  }
}

// scan_string
// file os-linux.h line 183
static inline char * scan_string(char *cp, char *valp, unsigned long int buf_size)
{
  unsigned long int i = (unsigned long int)0;
  cp=skip_whitespace(cp);
  unsigned long int tmp_post_1;
  if(cp == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; !((signed int)*cp == 32); cp = cp + 1l)
    {
      if((signed int)*cp == 9)
        break;

      if((signed int)*cp == 0)
        break;

      if(!(valp == ((char *)NULL)) && !(i >= buf_size + 18446744073709551615ul))
      {
        tmp_post_1 = i;
        i = i + 1ul;
        valp[(signed long int)tmp_post_1] = *cp;
      }

    }
    if(i == 0ul || i >= buf_size)
      return (char *)(void *)0;

    else
    {
      valp[(signed long int)i] = (char)0;
      return cp;
    }
  }
}

// scan_string_link1
// file os-linux.h line 183
static inline char * scan_string_link1(char *cp_link1, char *valp_link1, unsigned long int buf_size_link1)
{
  unsigned long int i_link1 = (unsigned long int)0;
  cp_link1=skip_whitespace_link1(cp_link1);
  unsigned long int tmp_post_1_link1;
  if(cp_link1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; !((signed int)*cp_link1 == 32); cp_link1 = cp_link1 + 1l)
    {
      if((signed int)*cp_link1 == 9)
        break;

      if((signed int)*cp_link1 == 0)
        break;

      if(!(valp_link1 == ((char *)NULL)) && !(i_link1 >= buf_size_link1 + 18446744073709551615ul))
      {
        tmp_post_1_link1 = i_link1;
        i_link1 = i_link1 + 1ul;
        valp_link1[(signed long int)tmp_post_1_link1] = *cp_link1;
      }

    }
    if(i_link1 == 0ul || i_link1 >= buf_size_link1)
      return (char *)(void *)0;

    else
    {
      valp_link1[(signed long int)i_link1] = (char)0;
      return cp_link1;
    }
  }
}

// scan_string_link2
// file os-linux.h line 183
static inline char * scan_string_link2(char *cp_link2, char *valp_link2, unsigned long int buf_size_link2)
{
  unsigned long int i_link2 = (unsigned long int)0;
  cp_link2=skip_whitespace_link2(cp_link2);
  unsigned long int tmp_post_1_link2;
  if(cp_link2 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; !((signed int)*cp_link2 == 32); cp_link2 = cp_link2 + 1l)
    {
      if((signed int)*cp_link2 == 9)
        break;

      if((signed int)*cp_link2 == 0)
        break;

      if(!(valp_link2 == ((char *)NULL)) && !(i_link2 >= buf_size_link2 + 18446744073709551615ul))
      {
        tmp_post_1_link2 = i_link2;
        i_link2 = i_link2 + 1ul;
        valp_link2[(signed long int)tmp_post_1_link2] = *cp_link2;
      }

    }
    if(i_link2 == 0ul || i_link2 >= buf_size_link2)
      return (char *)(void *)0;

    else
    {
      valp_link2[(signed long int)i_link2] = (char)0;
      return cp_link2;
    }
  }
}

// set_reg
// file dwarf/Gparser.c line 51
static inline void set_reg(struct dwarf_state_record *sr, unsigned long int regnum, enum anonymous_13 where, unsigned long int val)
{
  sr->rs_current.reg[(signed long int)regnum].where = where;
  sr->rs_current.reg[(signed long int)regnum].val = val;
}

// skip_whitespace
// file os-linux.h line 99
static inline char * skip_whitespace(char *cp)
{
  if(cp == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; cp = cp + 1l)
      if(!((signed int)*cp == 32))
      {
        if(!((signed int)*cp == 9))
          goto __CPROVER_DUMP_L3;

      }


  __CPROVER_DUMP_L3:
    ;
    return cp;
  }
}

// skip_whitespace_link1
// file os-linux.h line 99
static inline char * skip_whitespace_link1(char *cp_link1)
{
  if(cp_link1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; cp_link1 = cp_link1 + 1l)
      if(!((signed int)*cp_link1 == 32))
      {
        if(!((signed int)*cp_link1 == 9))
          goto __CPROVER_DUMP_L3;

      }


  __CPROVER_DUMP_L3:
    ;
    return cp_link1;
  }
}

// skip_whitespace_link2
// file os-linux.h line 99
static inline char * skip_whitespace_link2(char *cp_link2)
{
  if(cp_link2 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    for( ; (_Bool)1; cp_link2 = cp_link2 + 1l)
      if(!((signed int)*cp_link2 == 32))
      {
        if(!((signed int)*cp_link2 == 9))
          goto __CPROVER_DUMP_L3;

      }


  __CPROVER_DUMP_L3:
    ;
    return cp_link2;
  }
}

// sword
// file dwarf/Gexpr.c line 111
static inline signed long int sword(struct unw_addr_space *as, unsigned long int val)
{
  switch(sizeof(unsigned long int) /*8ul*/ )
  {
    case (unsigned long int)1:
      return (signed long int)(signed char)val;
    case (unsigned long int)2:
      return (signed long int)(signed short int)val;
    case (unsigned long int)4:
      return (signed long int)(signed int)val;
    case (unsigned long int)8:
      return (signed long int)val;
    default:
      abort();
  }
}

// trace_cache_buckets
// file x86_64/Gtrace.c line 86
static struct anonymous_5 * trace_cache_buckets(unsigned long int n)
{
  struct anonymous_5 *frames;
  unsigned long int i;
  do
  {
    void *return_value_mmap_1;
    return_value_mmap_1=mmap((void *)0, n * sizeof(struct anonymous_5) /*16ul*/ , 0x1 | 0x2, 0x02 | 0x20, -1, (signed long int)0);
    frames = (struct anonymous_5 *)return_value_mmap_1;
    if(frames == (struct anonymous_5 *)-1)
      frames = (struct anonymous_5 *)(void *)0;

  }
  while((_Bool)0);
  if(!(frames == ((struct anonymous_5 *)NULL)))
  {
    i = (unsigned long int)0;
    for( ; !(i >= n); i = i + 1ul)
      frames[(signed long int)i] = empty_frame;
  }

  return frames;
}

// trace_cache_create
// file x86_64/Gtrace.c line 103
static struct anonymous_6 * trace_cache_create(void)
{
  struct anonymous_6 *cache;
  if(!(tls_cache_destroyed == 0))
    return (struct anonymous_6 *)(void *)0;

  else
  {
    void *return_value__UIx86_64__mempool_alloc_1;
    return_value__UIx86_64__mempool_alloc_1=_UIx86_64__mempool_alloc(&trace_cache_pool);
    cache = (struct anonymous_6 *)return_value__UIx86_64__mempool_alloc_1;
    if(cache == ((struct anonymous_6 *)NULL))
      return (struct anonymous_6 *)(void *)0;

    else
    {
      cache->frames=trace_cache_buckets((unsigned long int)(1u << 14));
      if(cache->frames == ((struct anonymous_5 *)NULL))
      {
        _UIx86_64__mempool_free(&trace_cache_pool, (void *)cache);
        return (struct anonymous_6 *)(void *)0;
      }

      else
      {
        cache->log_size = (unsigned long int)14;
        cache->used = (unsigned long int)0;
        cache->dtor_count = (unsigned long int)0;
        tls_cache_destroyed = 0;
        return cache;
      }
    }
  }
}

// trace_cache_expand
// file x86_64/Gtrace.c line 140
static signed int trace_cache_expand(struct anonymous_6 *cache)
{
  unsigned long int old_size = (unsigned long int)(1u << cache->log_size);
  unsigned long int new_log_size = cache->log_size + (unsigned long int)2;
  struct anonymous_5 *new_frames;
  new_frames=trace_cache_buckets((unsigned long int)(1u << new_log_size));
  if(new_frames == ((struct anonymous_5 *)NULL))
    return -UNW_ENOMEM;

  else
  {
    munmap((void *)cache->frames, old_size * sizeof(struct anonymous_5) /*16ul*/ );
    cache->frames = new_frames;
    cache->log_size = new_log_size;
    cache->used = (unsigned long int)0;
    return 0;
  }
}

// trace_cache_free
// file x86_64/Gtrace.c line 58
static void trace_cache_free(void *arg)
{
  struct anonymous_6 *cache = (struct anonymous_6 *)arg;
  cache->dtor_count = cache->dtor_count + 1ul;
  if(!(cache->dtor_count >= 4ul))
    pthread_setspecific(trace_cache_key, (const void *)cache);

  else
  {
    tls_cache_destroyed = 1;
    tls_cache = (struct anonymous_6 *)(void *)0;
    munmap((void *)cache->frames, (unsigned long int)(1u << cache->log_size) * sizeof(struct anonymous_5) /*16ul*/ );
    _UIx86_64__mempool_free(&trace_cache_pool, (void *)cache);
  }
}

// trace_cache_get
// file x86_64/Gtrace.c line 180
static struct anonymous_6 * trace_cache_get(void)
{
  struct anonymous_6 *cache;
  pthread_once(&trace_cache_once, trace_cache_init_once);
  if(trace_cache_once_happen == 0)
  {
    struct anonymous_6 *return_value_trace_cache_get_unthreaded_1;
    return_value_trace_cache_get_unthreaded_1=trace_cache_get_unthreaded();
    return return_value_trace_cache_get_unthreaded_1;
  }

  cache = tls_cache;
  if(cache == ((struct anonymous_6 *)NULL))
  {
    cache=trace_cache_create();
    pthread_setspecific(trace_cache_key, (const void *)cache);
    tls_cache = cache;
  }

  return cache;
}

// trace_cache_get_unthreaded
// file x86_64/Gtrace.c line 161
static struct anonymous_6 * trace_cache_get_unthreaded(void)
{
  struct anonymous_6 *cache;
  struct anonymous_8 saved_mask;
  do
  {
    sigprocmask(2, &_UIx86_64_full_mask, &saved_mask);
    pthread_mutex_lock(&trace_init_lock);
  }
  while((_Bool)0);
  static struct anonymous_6 *global_cache = (struct anonymous_6 *)(void *)0;
  if(global_cache == ((struct anonymous_6 *)NULL))
  {
    _UIx86_64__mempool_init(&trace_cache_pool, sizeof(struct anonymous_6) /*32ul*/ , (unsigned long int)0);
    global_cache=trace_cache_create();
  }

  cache = global_cache;
  do
  {
    pthread_mutex_unlock(&trace_init_lock);
    sigprocmask(2, &saved_mask, (struct anonymous_8 *)(void *)0);
  }
  while((_Bool)0);
  return cache;
}

// trace_cache_init_once
// file x86_64/Gtrace.c line 78
static void trace_cache_init_once(void)
{
  pthread_key_create(&trace_cache_key, trace_cache_free);
  _UIx86_64__mempool_init(&trace_cache_pool, sizeof(struct anonymous_6) /*32ul*/ , (unsigned long int)0);
  trace_cache_once_happen = 1;
}

// trace_init_addr
// file x86_64/Gtrace.c line 214
static struct anonymous_5 * trace_init_addr(struct anonymous_5 *f, struct unw_cursor *cursor, unsigned long int cfa, unsigned long int rip, unsigned long int rbp, unsigned long int rsp)
{
  struct cursor *c = (struct cursor *)cursor;
  struct dwarf_cursor *d = &c->dwarf;
  signed int ret = -UNW_EINVAL;
  f->virtual_address = rip;
  f->frame_type = (signed long int)0;
  f->last_frame = (signed long int)0;
  f->cfa_reg_rsp = (signed long int)-1;
  f->cfa_reg_offset = (signed long int)0;
  f->rbp_cfa_offset = (signed long int)-1;
  f->rsp_cfa_offset = (signed long int)-1;
  d->ip = rip + (unsigned long int)d->use_prev_instr;
  d->cfa = cfa;
  d->loc[(signed long int)16] = (struct dwarf_loc){ .val=(unsigned long int)16, .type=(unsigned long int)(1 << 1) };
  d->loc[(signed long int)6] = (struct dwarf_loc){ .val=(unsigned long int)6, .type=(unsigned long int)(1 << 1) };
  d->loc[(signed long int)7] = (struct dwarf_loc){ .val=(unsigned long int)7, .type=(unsigned long int)(1 << 1) };
  c->frame_info = *f;
  signed int return_value_dwarf_put_3;
  return_value_dwarf_put_3=dwarf_put_link1(d, d->loc[(signed long int)16], rip);
  signed int return_value_dwarf_put_2;
  signed int return_value_dwarf_put_1;
  if(return_value_dwarf_put_3 >= 0)
  {
    return_value_dwarf_put_2=dwarf_put_link1(d, d->loc[(signed long int)6], rbp);
    if(return_value_dwarf_put_2 >= 0)
    {
      return_value_dwarf_put_1=dwarf_put_link1(d, d->loc[(signed long int)7], rsp);
      if(return_value_dwarf_put_1 >= 0)
      {
        ret=_Ux86_64_step(cursor);
        if(ret >= 0)
          *f = c->frame_info;

      }

    }

  }

  if(ret == 0)
    f->last_frame = (signed long int)-1;

  return f;
}

// trace_lookup
// file x86_64/Gtrace.c line 273
static struct anonymous_5 * trace_lookup(struct unw_cursor *cursor, struct anonymous_6 *cache, unsigned long int cfa, unsigned long int rip, unsigned long int rbp, unsigned long int rsp)
{
  unsigned long int i;
  unsigned long int addr;
  unsigned long int cache_size = (unsigned long int)(1u << cache->log_size);
  unsigned long int slot = rip * 0x9e3779b97f4a7c16 >> 43 & cache_size - (unsigned long int)1;
  struct anonymous_5 *frame;
  i = (unsigned long int)0;
  for( ; !(i >= 16ul); i = i + 1ul)
  {
    frame = &cache->frames[(signed long int)slot];
    addr = frame->virtual_address;
    if(addr == rip)
      return frame;

    if(addr == 0ul)
      break;

    slot = slot + 1ul;
    if(slot >= cache_size)
      slot = slot - cache_size;

  }
  _Bool tmp_if_expr_2;
  if(!(addr == 0ul))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = cache->used >= cache_size / (unsigned long int)2 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_trace_cache_expand_1;
    return_value_trace_cache_expand_1=trace_cache_expand(cache);
    if(!(return_value_trace_cache_expand_1 >= 0))
      return (struct anonymous_5 *)(void *)0;

    cache_size = (unsigned long int)(1u << cache->log_size);
    slot = rip * 0x9e3779b97f4a7c16 >> 43 & cache_size - (unsigned long int)1;
    frame = &cache->frames[(signed long int)slot];
    addr = frame->virtual_address;
  }

  if(addr == 0ul)
    cache->used = cache->used + 1ul;

  struct anonymous_5 *return_value_trace_init_addr_3;
  return_value_trace_init_addr_3=trace_init_addr(frame, cursor, cfa, rip, rbp, rsp);
  return return_value_trace_init_addr_3;
}

// uncached_dwarf_find_save_locs
// file dwarf/Gparser.c line 821
static signed int uncached_dwarf_find_save_locs(struct dwarf_cursor *c)
{
  struct dwarf_state_record sr;
  signed int ret;
  ret=fetch_proc_info(c, c->ip, 1);
  if(!(ret >= 0))
    return ret;

  else
  {
    ret=create_state_record_for(c, &sr, c->ip);
    if(!(ret >= 0))
      return ret;

    else
    {
      ret=apply_reg_state(c, &sr.rs_current);
      if(!(ret >= 0))
        return ret;

      else
      {
        put_unwind_info_link1(c, &c->pi);
        return 0;
      }
    }
  }
}

// validate_mem
// file x86_64/Ginit.c line 116
static signed int validate_mem(unsigned long int addr)
{
  signed int i;
  signed int victim;
  unsigned long int len;
  if((sizeof(unsigned long int) /*8ul*/  + addr + 18446744073709551615ul & 18446744073709547520ul) == (18446744073709547520ul & addr))
    len = (unsigned long int)4096;

  else
    len = (unsigned long int)(4096 * 2);
  addr = addr & (unsigned long int)~(4096 - 1);
  signed int tmp_post_1;
  if(addr == 0ul)
    return -1;

  else
  {
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      if(!(last_good_addr[(signed long int)i] == 0ul))
      {
        if(addr == last_good_addr[(signed long int)i])
          return 0;

      }

    signed int return_value;
    return_value=mem_validate_func((void *)addr, len);
    if(return_value == -1)
      return -1;

    else
    {
      victim = lga_victim;
      i = 0;
      if(!(i >= 4))
      {
        if(last_good_addr[(signed long int)victim] == 0ul)
        {
          tmp_post_1 = victim;
          victim = victim + 1;
          last_good_addr[(signed long int)tmp_post_1] = addr;
          return 0;
        }

        victim = (victim + 1) % 4;
        i = i + 1;
      }

      last_good_addr[(signed long int)victim] = addr;
      victim = (victim + 1) % 4;
      lga_victim = victim;
      return 0;
    }
  }
}

// worker
// file Gtest-concurrent.c line 73
void * worker(void *arg)
{
  signal(10, handler);
  if(!(verbose == 0))
    printf("sending SIGUSR1\n");

  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  pthread_kill(return_value_pthread_self_1, 10);
  return (void *)0;
}

// xz_uncompressed_size
// file elfxx.c line 183
static unsigned long int xz_uncompressed_size(unsigned char *compressed, unsigned long int length)
{
  unsigned long int memlimit = 18446744073709551615UL;
  unsigned long int ret = (unsigned long int)0;
  unsigned long int pos = (unsigned long int)0;
  struct anonymous_25 options;
  struct lzma_index_s *index;
  if(!(length >= 12ul))
    return (unsigned long int)0;

  else
  {
    unsigned char *footer = (compressed + (signed long int)length) - (signed long int)12;
    enum anonymous_21 return_value_lzma_stream_footer_decode_1;
    return_value_lzma_stream_footer_decode_1=lzma_stream_footer_decode(&options, footer);
    if(!((signed int)return_value_lzma_stream_footer_decode_1 == LZMA_OK))
      return (unsigned long int)0;

    else
      if(!(length >= 12ul + options.backward_size))
        return (unsigned long int)0;

      else
      {
        unsigned char *indexdata = footer - (signed long int)options.backward_size;
        enum anonymous_21 return_value_lzma_index_buffer_decode_2;
        return_value_lzma_index_buffer_decode_2=lzma_index_buffer_decode(&index, &memlimit, (struct anonymous_22 *)(void *)0, indexdata, &pos, options.backward_size);
        if(!((signed int)return_value_lzma_index_buffer_decode_2 == LZMA_OK))
          return (unsigned long int)0;

        else
        {
          unsigned long int return_value_lzma_index_size_3;
          return_value_lzma_index_size_3=lzma_index_size(index);
          if(return_value_lzma_index_size_3 == options.backward_size)
            ret=lzma_index_uncompressed_size(index);

          lzma_index_end(index, (struct anonymous_22 *)(void *)0);
          return ret;
        }
      }
  }
}

