// #anon_enum$VAL_INT=255$VAL_NULL=0$VAL_FLOAT=1$VAL_BOOL=2$VAL_STRING=3$VAL_OBJECT=4$VAL_ARRAY=5$VAL_FUNCTION=6$VAL_ABSTRACT=7$VAL_INT32=8$VAL_PRIMITIVE=22$VAL_JITFUN=38$VAL_32_BITS=-1
// file vm/neko.h line 99
enum anonymous$7 { VAL_INT=255, VAL_NULL=0, VAL_FLOAT=1, VAL_BOOL=2, VAL_STRING=3, VAL_OBJECT=4, VAL_ARRAY=5, VAL_FUNCTION=6, VAL_ABSTRACT=7, VAL_INT32=8, VAL_PRIMITIVE=22, VAL_JITFUN=38, VAL_32_BITS=-1 };

// tag-#anon#ST[*{*{SYM#tag-hcell#}$SYM#tag-hcell#$}$*{SYM#tag-hcell#}$SYM#tag-hcell#$$'cells'||S32'ncells'||S32'nitems'|]
// file vm/neko.h line 189
struct anonymous$0;

// tag-#anon#ST[*{S8}$S8$'p'||S32'len'||U32'$pad0'|]
// file vm/neko_mod.h line 50
struct anonymous$20;

// tag-#anon#ST[*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'init'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'main'||*{V}$V$'param'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'|]
// file vm/threads.c line 80
struct anonymous$23;

// tag-#anon#ST[*{V(*{cS8}$cS8$|S32|*{V}$V$)->V}$V(*{cS8}$cS8$|S32|*{V}$V$)->V$'prev'||*{V}$V$'prev_param'||*{V(*{cS8}$cS8$|S32|*{V}$V$)->V}$V(*{cS8}$cS8$|S32|*{V}$V$)->V$'cur'||*{V}$V$'cur_param'|]
// file vm/interp.c line 198
struct anonymous$24;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$17;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$15;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$10;

// tag-#anon#ST[EN#anon_enum$VAL_INT=255$VAL_NULL=0$VAL_FLOAT=1$VAL_BOOL=2$VAL_STRING=3$VAL_OBJECT=4$VAL_ARRAY=5$VAL_FUNCTION=6$VAL_ABSTRACT=7$VAL_INT32=8$VAL_PRIMITIVE=22$VAL_JITFUN=38$VAL_32_BITS=-1#{S32}$S32$'t'||F64'f'|]
// file vm/neko.h line 141
struct anonymous$25;

// tag-#anon#ST[EN#anon_enum$VAL_INT=255$VAL_NULL=0$VAL_FLOAT=1$VAL_BOOL=2$VAL_STRING=3$VAL_OBJECT=4$VAL_ARRAY=5$VAL_FUNCTION=6$VAL_ABSTRACT=7$VAL_INT32=8$VAL_PRIMITIVE=22$VAL_JITFUN=38$VAL_32_BITS=-1#{S32}$S32$'t'||S32'i'|]
// file vm/neko.h line 146
struct anonymous$26;

// tag-#anon#ST[EN#anon_enum$VAL_INT=255$VAL_NULL=0$VAL_FLOAT=1$VAL_BOOL=2$VAL_STRING=3$VAL_OBJECT=4$VAL_ARRAY=5$VAL_FUNCTION=6$VAL_ABSTRACT=7$VAL_INT32=8$VAL_PRIMITIVE=22$VAL_JITFUN=38$VAL_32_BITS=-1#{S32}$S32$'t'||S32'nargs'||*{V}$V$'addr'||*{SYM#tag-_value#}$SYM#tag-_value#$'env'||*{V}$V$'module'|]
// file vm/neko.h line 158
struct anonymous$8;

// tag-#anon#ST[EN#anon_enum$VAL_INT=255$VAL_NULL=0$VAL_FLOAT=1$VAL_BOOL=2$VAL_STRING=3$VAL_OBJECT=4$VAL_ARRAY=5$VAL_FUNCTION=6$VAL_ABSTRACT=7$VAL_INT32=8$VAL_PRIMITIVE=22$VAL_JITFUN=38$VAL_32_BITS=-1#{S32}$S32$'t'||S8'c'||U24'$pad0'|]
// file vm/neko.h line 166
struct anonymous$5;

// tag-#anon#ST[EN#anon_enum$VAL_INT=255$VAL_NULL=0$VAL_FLOAT=1$VAL_BOOL=2$VAL_STRING=3$VAL_OBJECT=4$VAL_ARRAY=5$VAL_FUNCTION=6$VAL_ABSTRACT=7$VAL_INT32=8$VAL_PRIMITIVE=22$VAL_JITFUN=38$VAL_32_BITS=-1#{S32}$S32$'t'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'__zero'|]#}$SYM#tag-#anon#ST[S32'__zero'|]#$'kind'||*{V}$V$'data'|]
// file vm/neko.h line 176
struct anonymous$6;

// tag-#anon#ST[EN#anon_enum$VAL_INT=255$VAL_NULL=0$VAL_FLOAT=1$VAL_BOOL=2$VAL_STRING=3$VAL_OBJECT=4$VAL_ARRAY=5$VAL_FUNCTION=6$VAL_ABSTRACT=7$VAL_INT32=8$VAL_PRIMITIVE=22$VAL_JITFUN=38$VAL_32_BITS=-1#{S32}$S32$'t'||U32'$pad0'||*{SYM#tag-_value#}$SYM#tag-_value#$'ptr'|]
// file vm/neko.h line 171
struct anonymous$4;

// tag-#anon#ST[S32'__zero'|]
// file vm/neko.h line 121
struct anonymous;

// tag-#anon#ST[S32'id'||U32'$pad0'||*{SYM#tag-_value#}$SYM#tag-_value#$'v'|]
// file vm/neko.h line 124
struct anonymous$3;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$11;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$13;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$19;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$12;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$16;

// tag-#anon#ST[U32'l'||U32'h'|]
// file vm/builtins.c line 645
struct anonymous$1;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$9;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$18;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$21;

// tag-#anon#UN[F64'd'||SYM#tag-#anon#ST[U32'l'||U32'h'|]#'i'|]
// file vm/builtins.c line 643
union anonymous$2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$22;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_buffer
// file vm/neko.h line 119
struct _buffer;

// tag-_custom_list
// file vm/vm.h line 34
struct _custom_list;

// tag-_klist
// file vm/alloc.c line 61
struct _klist;

// tag-_liblist
// file vm/load.c line 191
struct _liblist;

// tag-_mt_local
// file vm/neko.h line 195
struct _mt_local;

// tag-_mt_lock
// file vm/neko.h line 196
struct _mt_lock;

// tag-_neko_debug
// file vm/neko_mod.h line 26
struct _neko_debug;

// tag-_neko_module
// file vm/neko_mod.h line 31
struct _neko_module;

// tag-_neko_vm
// file vm/neko_vm.h line 29
struct _neko_vm;

// tag-_objtable
// file vm/neko.h line 129
struct _objtable;

// tag-_statinfos
// file vm/stats.c line 33
struct _statinfos;

// tag-_stringitem
// file vm/others.c line 113
struct _stringitem;

// tag-_value
// file vm/neko.h line 115
struct _value;

// tag-_vobject
// file vm/neko.h line 152
struct _vobject;

// tag-hcell
// file vm/neko.h line 182
struct hcell;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-vlist
// file vm/others.c line 205
struct vlist;

// tag-vlist2
// file vm/others.c line 210
struct vlist2;

// tag-vparam
// file vm/hash.c line 29
struct vparam;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// GC_clear_roots
// file /usr/include/gc/gc.h line 510
extern void GC_clear_roots(void);
// GC_collect_a_little
// file /usr/include/gc/gc.h line 726
extern signed int GC_collect_a_little(void);
// GC_dlopen
// file /usr/include/gc/gc_pthread_redirects.h line 38
extern void * GC_dlopen(const char *, signed int);
// GC_free
// file /usr/include/gc/gc.h line 435
extern void GC_free(void *);
// GC_gcollect
// file /usr/include/gc/gc.h line 542
extern void GC_gcollect(void);
// GC_get_free_bytes
// file /usr/include/gc/gc.h line 594
extern unsigned long int GC_get_free_bytes(void);
// GC_get_heap_size
// file /usr/include/gc/gc.h line 589
extern unsigned long int GC_get_heap_size(void);
// GC_init
// file /usr/include/gc/gc.h line 396
extern void GC_init(void);
// GC_malloc
// file /usr/include/gc/gc.h line 412
extern void * GC_malloc(unsigned long int);
// GC_malloc_atomic
// file /usr/include/gc/gc.h line 414
extern void * GC_malloc_atomic(unsigned long int);
// GC_malloc_atomic_ignore_off_page
// file /usr/include/gc/gc.h line 745
extern void * GC_malloc_atomic_ignore_off_page(unsigned long int);
// GC_malloc_ignore_off_page
// file /usr/include/gc/gc.h line 743
extern void * GC_malloc_ignore_off_page(unsigned long int);
// GC_malloc_uncollectable
// file /usr/include/gc/gc.h line 419
extern void * GC_malloc_uncollectable(unsigned long int);
// GC_pthread_create
// file /usr/include/gc/gc_pthread_redirects.h line 52
extern signed int GC_pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// GC_register_finalizer_no_order
// file /usr/include/gc/gc.h line 983
extern void GC_register_finalizer_no_order(void *, void (*)(void *, void *), void *, void (**)(void *, void *), void **);
// GC_set_warn_proc
// file /usr/include/gc/gc.h line 1157
extern void GC_set_warn_proc(void (*)(char *, unsigned long int));
// ThreadMain
// file vm/threads.c line 110
static void * ThreadMain(void *_p);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __on_finalize
// file vm/alloc.c line 344
static void __on_finalize(struct _value *v, void *f);
// _neko_failure
// file vm/neko.h line 435
void _neko_failure(struct _value *msg, const char *file, signed int line);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// add_rec
// file vm/builtins.c line 796
static void add_rec(struct hcell **cc, signed int size, struct hcell *c);
// append_array
// file vm/module.c line 224
static void append_array(struct _value **arr, signed int pos, struct _value *v);
// apply1
// file vm/alloc.c line 249
static struct _value * apply1(struct _value *p1);
// apply2
// file vm/alloc.c line 257
static struct _value * apply2(struct _value *p1, struct _value *p2);
// apply3
// file vm/alloc.c line 266
static struct _value * apply3(struct _value *p1, struct _value *p2, struct _value *p3);
// apply4
// file vm/alloc.c line 276
static struct _value * apply4(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4);
// apply5
// file vm/alloc.c line 287
static struct _value * apply5(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// bitcount
// file vm/interp.c line 501
static signed int bitcount(unsigned int k);
// buffer_append_new
// file vm/others.c line 136
static void buffer_append_new(struct _buffer *b, const char *s, signed int len);
// builtin_ablit
// file vm/builtins.c line 131
static struct _value * builtin_ablit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l);
// builtin_aconcat
// file vm/builtins.c line 153
static struct _value * builtin_aconcat(struct _value *arrs);
// builtin_acopy
// file vm/builtins.c line 81
static struct _value * builtin_acopy(struct _value *a);
// builtin_amake
// file vm/builtins.c line 66
static struct _value * builtin_amake(struct _value *size);
// builtin_apply
// file vm/builtins.c line 556
static struct _value * builtin_apply(struct _value **args, signed int nargs);
// builtin_array
// file vm/builtins.c line 54
static struct _value * builtin_array(struct _value **args, signed int nargs);
// builtin_asize
// file vm/builtins.c line 95
static struct _value * builtin_asize(struct _value *a);
// builtin_asub
// file vm/builtins.c line 107
static struct _value * builtin_asub(struct _value *a, struct _value *p, struct _value *l);
// builtin_call
// file vm/builtins.c line 489
static struct _value * builtin_call(struct _value *f, struct _value *ctx, struct _value *args);
// builtin_callstack
// file vm/builtins.c line 1197
static struct _value * builtin_callstack();
// builtin_closure
// file vm/builtins.c line 530
static struct _value * builtin_closure(struct _value **args, signed int nargs);
// builtin_compare
// file vm/builtins.c line 1157
static struct _value * builtin_compare(struct _value *a, struct _value *b);
// builtin_excstack
// file vm/builtins.c line 1189
static struct _value * builtin_excstack();
// builtin_fasthash
// file vm/builtins.c line 422
static struct _value * builtin_fasthash(struct _value *f);
// builtin_field
// file vm/builtins.c line 439
static struct _value * builtin_field(struct _value *f);
// builtin_float
// file vm/builtins.c line 732
static struct _value * builtin_float(struct _value *f);
// builtin_getkind
// file vm/builtins.c line 749
static struct _value * builtin_getkind(struct _value *v);
// builtin_hadd
// file vm/builtins.c line 995
static struct _value * builtin_hadd(struct _value *vh, struct _value *key, struct _value *val);
// builtin_hash
// file vm/builtins.c line 413
static struct _value * builtin_hash(struct _value *f);
// builtin_hcount
// file vm/builtins.c line 1042
static struct _value * builtin_hcount(struct _value *vh);
// builtin_hget
// file vm/builtins.c line 838
static struct _value * builtin_hget(struct _value *vh, struct _value *key, struct _value *cmp);
// builtin_hiter
// file vm/builtins.c line 1021
static struct _value * builtin_hiter(struct _value *vh, struct _value *f);
// builtin_hkey
// file vm/builtins.c line 771
static struct _value * builtin_hkey(struct _value *v);
// builtin_hmem
// file vm/builtins.c line 870
static struct _value * builtin_hmem(struct _value *vh, struct _value *key, struct _value *cmp);
// builtin_hnew
// file vm/builtins.c line 781
static struct _value * builtin_hnew(struct _value *size);
// builtin_hremove
// file vm/builtins.c line 902
static struct _value * builtin_hremove(struct _value *vh, struct _value *key, struct _value *cmp);
// builtin_hresize
// file vm/builtins.c line 810
static struct _value * builtin_hresize(struct _value *vh, struct _value *size);
// builtin_hset
// file vm/builtins.c line 949
static struct _value * builtin_hset(struct _value *vh, struct _value *key, struct _value *val, struct _value *cmp);
// builtin_hsize
// file vm/builtins.c line 1051
static struct _value * builtin_hsize(struct _value *vh);
// builtin_iadd
// file vm/builtins.c line 613
static struct _value * builtin_iadd(struct _value *a, struct _value *b);
// builtin_idiv
// file vm/builtins.c line 637
static struct _value * builtin_idiv(struct _value *a, struct _value *b);
// builtin_imult
// file vm/builtins.c line 629
static struct _value * builtin_imult(struct _value *a, struct _value *b);
// builtin_int
// file vm/builtins.c line 689
static struct _value * builtin_int(struct _value *f);
// builtin_isinfinite
// file vm/builtins.c line 672
static struct _value * builtin_isinfinite(struct _value *f);
// builtin_iskind
// file vm/builtins.c line 760
static struct _value * builtin_iskind(struct _value *v, struct _value *k);
// builtin_isnan
// file vm/builtins.c line 655
static struct _value * builtin_isnan(struct _value *f);
// builtin_istrue
// file vm/builtins.c line 1098
static struct _value * builtin_istrue(struct _value *f);
// builtin_isub
// file vm/builtins.c line 621
static struct _value * builtin_isub(struct _value *a, struct _value *b);
// builtin_nargs
// file vm/builtins.c line 480
static struct _value * builtin_nargs(struct _value *f);
// builtin_new
// file vm/builtins.c line 329
static struct _value * builtin_new(struct _value *o);
// builtin_not
// file vm/builtins.c line 1106
static struct _value * builtin_not(struct _value *f);
// builtin_objcall
// file vm/builtins.c line 362
static struct _value * builtin_objcall(struct _value *o, struct _value *f, struct _value *args);
// builtin_objfield
// file vm/builtins.c line 374
static struct _value * builtin_objfield(struct _value *o, struct _value *f);
// builtin_objfields
// file vm/builtins.c line 397
static struct _value * builtin_objfields(struct _value *o);
// builtin_objfields_rec
// file vm/builtins.c line 389
static void builtin_objfields_rec(struct _value *d, signed int id, void *a);
// builtin_objget
// file vm/builtins.c line 339
static struct _value * builtin_objget(struct _value *o, struct _value *f);
// builtin_objgetproto
// file vm/builtins.c line 463
static struct _value * builtin_objgetproto(struct _value *o);
// builtin_objremove
// file vm/builtins.c line 383
static struct _value * builtin_objremove(struct _value *o, struct _value *f);
// builtin_objset
// file vm/builtins.c line 350
static struct _value * builtin_objset(struct _value *o, struct _value *f, struct _value *v);
// builtin_objsetproto
// file vm/builtins.c line 448
static struct _value * builtin_objsetproto(struct _value *o, struct _value *p);
// builtin_pcompare
// file vm/builtins.c line 1166
static struct _value * builtin_pcompare(struct _value *a, struct _value *b);
// builtin_print
// file vm/builtins.c line 1062
static struct _value * builtin_print(struct _value **args, signed int nargs);
// builtin_rethrow
// file vm/builtins.c line 1089
static struct _value * builtin_rethrow(struct _value *v);
// builtin_sblit
// file vm/builtins.c line 279
static struct _value * builtin_sblit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l);
// builtin_scopy
// file vm/builtins.c line 213
static struct _value * builtin_scopy(struct _value *s);
// builtin_setresolver
// file vm/builtins.c line 1213
static struct _value * builtin_setresolver(struct _value *f);
// builtin_sfind
// file vm/builtins.c line 302
static struct _value * builtin_sfind(struct _value *src, struct _value *pos, struct _value *pat);
// builtin_sget
// file vm/builtins.c line 241
static struct _value * builtin_sget(struct _value *s, struct _value *p);
// builtin_smake
// file vm/builtins.c line 192
static struct _value * builtin_smake(struct _value *l);
// builtin_sset
// file vm/builtins.c line 258
static struct _value * builtin_sset(struct _value *s, struct _value *p, struct _value *c);
// builtin_ssize
// file vm/builtins.c line 204
static struct _value * builtin_ssize(struct _value *s);
// builtin_ssub
// file vm/builtins.c line 225
static struct _value * builtin_ssub(struct _value *s, struct _value *p, struct _value *l);
// builtin_string
// file vm/builtins.c line 182
static struct _value * builtin_string(struct _value *v);
// builtin_throw
// file vm/builtins.c line 1080
static struct _value * builtin_throw(struct _value *v);
// builtin_typeof
// file vm/builtins.c line 1127
static struct _value * builtin_typeof(struct _value *v);
// builtin_varargs
// file vm/builtins.c line 599
static struct _value * builtin_varargs(struct _value *f);
// builtin_version
// file vm/builtins.c line 1205
static struct _value * builtin_version();
// clean_c_stack
// file vm/threads.c line 103
static signed int clean_c_stack(signed int n, void *f);
// close_module
// file vm/load.c line 187
static void close_module(void *p);
// closure_callback
// file vm/builtins.c line 502
static struct _value * closure_callback(struct _value **args, signed int nargs);
// cmp
// file vm/stats.c line 133
static signed int cmp(struct _statinfos *a, struct _statinfos *b);
// default_printer
// file vm/interp.c line 86
static void default_printer(const char *s, signed int len, void *out);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_nothing
// file vm/threads.c line 175
static signed int do_nothing(char (*sb)[64l]);
// executable_path
// file vm/main.c line 56
static char * executable_path();
// execute_file
// file vm/main.c line 196
static signed int execute_file(struct _neko_vm *vm, char *file, struct _value *mload);
// failure_to_string
// file vm/others.c line 499
static struct _value * failure_to_string();
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcmp
// file vm/others.c line 44
static inline signed int fcmp(double a, double b);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fmod
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 187
extern double fmod(double, double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_builtin
// file vm/module.c line 121
static struct _value * get_builtin(struct _neko_module *m, signed int id);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handle_signal
// file vm/main.c line 214
static void handle_signal(signed int signal);
// hash_obj_rec
// file vm/hash.c line 106
static void hash_obj_rec(struct _value *v, signed int f, void *_p);
// hash_rec
// file vm/hash.c line 39
static void hash_rec(struct _value *v, signed int *h, struct vlist *l);
// icmp
// file vm/others.c line 40
static inline signed int icmp(signed int a, signed int b);
// init_path
// file vm/load.c line 265
static struct _value * init_path(const char *path);
// jit_run
// file vm/interp.c line 265
static signed long int jit_run(struct _neko_vm *vm, struct anonymous$8 *acc);
// load_primitive
// file vm/load.c line 199
static void * load_primitive(const char *prim, signed int nargs, struct _value *path, struct _liblist **libs);
// load_primitive::1::ptr$object
//
struct _value * ptr$object();
// loader_loadmodule
// file vm/load.c line 371
static struct _value * loader_loadmodule(struct _value *mname, struct _value *vthis);
// loader_loadmodule::1::1::r$object
//
signed int r$object(void *, void *, signed int);
// loader_loadprim
// file vm/load.c line 337
static struct _value * loader_loadprim(struct _value *prim, struct _value *nargs);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// neko_alloc
// file vm/alloc.c line 164
char * neko_alloc(unsigned int nbytes);
// neko_alloc_abstract
// file vm/alloc.c line 215
struct _value * neko_alloc_abstract(struct anonymous *k, void *data);
// neko_alloc_apply
// file vm/alloc.c line 299
extern struct _value * neko_alloc_apply(signed int nargs, struct _value *env);
// neko_alloc_array
// file vm/neko.h line 400
struct _value * neko_alloc_array(unsigned int n);
// neko_alloc_buffer
// file vm/neko.h line 420
struct _buffer * neko_alloc_buffer(const char *init);
// neko_alloc_empty_string
// file vm/alloc.c line 172
struct _value * neko_alloc_empty_string(unsigned int size);
// neko_alloc_field
// file vm/neko.h line 396
void neko_alloc_field(struct _value *obj, signed int f, struct _value *v);
// neko_alloc_float
// file vm/alloc.c line 190
struct _value * neko_alloc_float(double f);
// neko_alloc_function
// file vm/neko.h line 418
struct _value * neko_alloc_function(void *c_prim, unsigned int nargs, const char *name);
// neko_alloc_int32
// file vm/alloc.c line 197
struct _value * neko_alloc_int32(signed int i);
// neko_alloc_local
// file vm/neko.h line 438
struct _mt_local * neko_alloc_local();
// neko_alloc_lock
// file vm/neko.h line 443
struct _mt_lock * neko_alloc_lock();
// neko_alloc_module_function
// file vm/alloc.c line 236
struct _value * neko_alloc_module_function(void *m, signed long int pos, signed int nargs);
// neko_alloc_object
// file vm/alloc.c line 316
struct _value * neko_alloc_object(struct _value *cpy);
// neko_alloc_private
// file vm/alloc.c line 168
char * neko_alloc_private(unsigned int nbytes);
// neko_alloc_root
// file vm/alloc.c line 357
struct _value ** neko_alloc_root(unsigned int nvals);
// neko_alloc_string
// file vm/neko.h line 388
struct _value * neko_alloc_string(const char *str);
// neko_append_int
// file vm/others.c line 323
struct _value * neko_append_int(struct _neko_vm *vm, struct _value *str, signed int x, signed int way);
// neko_append_strings
// file vm/others.c line 339
struct _value * neko_append_strings(struct _value *s1, struct _value *s2);
// neko_buffer_append
// file vm/neko.h line 421
void neko_buffer_append(struct _buffer *b, const char *s);
// neko_buffer_append_char
// file vm/neko.h line 423
void neko_buffer_append_char(struct _buffer *b, char c);
// neko_buffer_append_sub
// file vm/neko.h line 422
void neko_buffer_append_sub(struct _buffer *b, const char *s, signed long int _len);
// neko_buffer_to_string
// file vm/neko.h line 424
struct _value * neko_buffer_to_string(struct _buffer *b);
// neko_call_stack
// file vm/neko_vm.h line 47
struct _value * neko_call_stack(struct _neko_vm *vm);
// neko_can_jit
// file vm/jit_x86.c line 2778
signed int neko_can_jit();
// neko_check_stack
// file vm/module.c line 138
static signed int neko_check_stack(struct _neko_module *m, unsigned char *tmp, unsigned int i, signed int stack, signed int istack);
// neko_copy_string
// file vm/alloc.c line 333
struct _value * neko_copy_string(const char *str, signed long int strlen);
// neko_default_loader
// file vm/neko_vm.h line 54
struct _value * neko_default_loader(char **argv, signed int argc);
// neko_exc_stack
// file vm/neko_vm.h line 46
struct _value * neko_exc_stack(struct _neko_vm *vm);
// neko_execute_self
// file vm/main.c line 165
signed int neko_execute_self(struct _neko_vm *vm, struct _value *mload);
// neko_file_reader
// file vm/neko_mod.h line 60
signed int neko_file_reader(void *p, void *buf, signed int size);
// neko_flush_stack
// file vm/interp.c line 510
static struct _value * neko_flush_stack(signed long int *cspup, signed long int *csp, struct _value *old);
// neko_free_jit
// file vm/jit_x86.c line 2775
void neko_free_jit();
// neko_free_local
// file vm/neko.h line 441
void neko_free_local(struct _mt_local *l);
// neko_free_lock
// file vm/neko.h line 447
void neko_free_lock(struct _mt_lock *l);
// neko_free_root
// file vm/alloc.c line 361
void neko_free_root(struct _value **v);
// neko_gc_init
// file vm/alloc.c line 119
void neko_gc_init();
// neko_gc_loop
// file vm/alloc.c line 151
void neko_gc_loop();
// neko_gc_major
// file vm/alloc.c line 155
void neko_gc_major();
// neko_gc_stats
// file vm/alloc.c line 159
void neko_gc_stats(signed int *heap, signed int *free);
// neko_get_ttable
// file vm/vm.h line 70
extern signed long int * neko_get_ttable();
// neko_global_free
// file vm/neko_vm.h line 36
void neko_global_free();
// neko_global_init
// file vm/neko_vm.h line 35
void neko_global_init();
// neko_has_embedded_module
// file vm/main.c line 98
signed int neko_has_embedded_module(struct _neko_vm *vm);
// neko_init_builtins
// file vm/builtins.c line 1227
void neko_init_builtins();
// neko_init_jit
// file vm/jit_x86.c line 2772
void neko_init_jit();
// neko_interp
// file vm/vm.h line 69
extern struct _value * neko_interp(struct _neko_vm *vm, void *_m, signed long int acc, signed long int *pc);
// neko_interp_loop
// file vm/interp.c line 613
signed long int neko_interp_loop(struct _neko_vm *vm, struct _neko_module *m, signed long int _acc, signed long int *_pc);
// neko_is_big_endian
// file vm/module.c line 100
signed int neko_is_big_endian();
// neko_kind_share
// file vm/alloc.c line 430
void neko_kind_share(struct anonymous **k, const char *name);
// neko_local_get
// file vm/neko.h line 439
void * neko_local_get(struct _mt_local *l);
// neko_local_set
// file vm/neko.h line 440
void neko_local_set(struct _mt_local *l, void *v);
// neko_lock_acquire
// file vm/neko.h line 444
void neko_lock_acquire(struct _mt_lock *l);
// neko_lock_release
// file vm/neko.h line 446
void neko_lock_release(struct _mt_lock *l);
// neko_lock_try
// file vm/threads.c line 327
signed int neko_lock_try(struct _mt_lock *l);
// neko_module_jit
// file vm/jit_x86.c line 2782
void neko_module_jit(struct _neko_module *m);
// neko_process_trap
// file vm/interp.c line 588
void neko_process_trap(struct _neko_vm *vm);
// neko_read_module
// file vm/neko_mod.h line 59
struct _neko_module * neko_read_module(signed int (*r)(void *, void *, signed int), void *p, struct _value *loader);
// neko_read_module::r$object
//
signed int r$object(void *, void *, signed int);
// neko_select_file
// file vm/load.c line 138
struct _value * neko_select_file(struct _value *path, const char *file, const char *ext);
// neko_set_stack_base
// file vm/alloc.c line 426
void neko_set_stack_base(void *s);
// neko_setup_trap
// file vm/interp.c line 575
void neko_setup_trap(struct _neko_vm *vm);
// neko_stack_expand
// file vm/others.c line 348
signed int neko_stack_expand(signed long int *sp, signed long int *csp, struct _neko_vm *vm);
// neko_stats_build
// file vm/stats.c line 183
struct _value * neko_stats_build(struct _neko_vm *vm);
// neko_stats_measure
// file vm/stats.c line 79
void neko_stats_measure(struct _neko_vm *vm, const char *kind, signed int start);
// neko_string_reader
// file vm/module.c line 621
signed int neko_string_reader(void *p, void *buf, signed int size);
// neko_thread_blocking
// file vm/threads.c line 181
void neko_thread_blocking(void (*f)(void *), void *p);
// neko_thread_blocking::1::do_blocking$object
//
void do_blocking$object(void (*)(void *), void *);
// neko_thread_blocking::1::end$object
//
signed int end$object();
// neko_thread_blocking::1::start$object
//
signed int start$object();
// neko_thread_blocking::f$object
//
void f$object(void *);
// neko_thread_create
// file vm/threads.c line 128
signed int neko_thread_create(void (*init)(void *), void (*main)(void *), void *param, void **handle);
// neko_thread_create::init$object
//
void init$object(void *);
// neko_thread_create::main$object
//
void main$object(void *);
// neko_thread_register
// file vm/threads.c line 211
signed int neko_thread_register(signed int t);
// neko_thread_register::1::get_sb$object
//
signed int get_sb$object(char (*)[64l]);
// neko_thread_register::1::my_thread$object
//
signed int my_thread$object(char (*)[64l]);
// neko_thread_register::1::unreg_my_thread$object
//
signed int unreg_my_thread$object();
// neko_val_buffer
// file vm/neko.h line 425
void neko_val_buffer(struct _buffer *b, struct _value *v);
// neko_val_call0
// file vm/callback.c line 145
struct _value * neko_val_call0(struct _value *f);
// neko_val_call1
// file vm/neko.h line 404
struct _value * neko_val_call1(struct _value *f, struct _value *v);
// neko_val_call2
// file vm/neko.h line 405
struct _value * neko_val_call2(struct _value *f, struct _value *v1, struct _value *v2);
// neko_val_call3
// file vm/callback.c line 158
struct _value * neko_val_call3(struct _value *f, struct _value *arg1, struct _value *arg2, struct _value *arg3);
// neko_val_callEx
// file vm/neko.h line 412
struct _value * neko_val_callEx(struct _value *vthis, struct _value *f, struct _value **args, signed int nargs, struct _value **exc);
// neko_val_callN
// file vm/neko.h line 407
struct _value * neko_val_callN(struct _value *f, struct _value **args, signed int nargs);
// neko_val_compare
// file vm/neko.h line 427
signed int neko_val_compare(struct _value *a, struct _value *b);
// neko_val_field
// file vm/neko.h line 394
struct _value * neko_val_field(struct _value *_o, signed int id);
// neko_val_field_name
// file vm/neko.h line 398
struct _value * neko_val_field_name(signed int id);
// neko_val_gc
// file vm/alloc.c line 348
void neko_val_gc(struct _value *v, void (*f)(struct _value *));
// neko_val_gc::f$object
//
void f$object(struct _value *);
// neko_val_hash
// file vm/neko.h line 432
signed int neko_val_hash(struct _value *v);
// neko_val_id
// file vm/neko.h line 393
signed int neko_val_id(const char *name);
// neko_val_iter_fields
// file vm/others.c line 465
void neko_val_iter_fields(struct _value *o, void (*f)(struct _value *, signed int, void *), void *p);
// neko_val_iter_fields::f$object
//
void f$object(struct _value *, signed int, void *);
// neko_val_ocall0
// file vm/neko.h line 408
struct _value * neko_val_ocall0(struct _value *o, signed int f);
// neko_val_ocall1
// file vm/callback.c line 167
struct _value * neko_val_ocall1(struct _value *o, signed int f, struct _value *arg);
// neko_val_ocall2
// file vm/callback.c line 171
struct _value * neko_val_ocall2(struct _value *o, signed int f, struct _value *arg1, struct _value *arg2);
// neko_val_ocallN
// file vm/neko.h line 411
struct _value * neko_val_ocallN(struct _value *o, signed int f, struct _value **args, signed int nargs);
// neko_val_print
// file vm/neko.h line 428
void neko_val_print(struct _value *v);
// neko_val_rethrow
// file vm/neko.h line 431
void neko_val_rethrow(struct _value *v);
// neko_val_this
// file vm/callback.c line 176
struct _value * neko_val_this();
// neko_val_throw
// file vm/neko.h line 430
void neko_val_throw(struct _value *v);
// neko_vm_alloc
// file vm/neko_vm.h line 44
struct _neko_vm * neko_vm_alloc(void *custom);
// neko_vm_current
// file vm/interp.c line 160
struct _neko_vm * neko_vm_current();
// neko_vm_custom
// file vm/interp.c line 164
void * neko_vm_custom(struct _neko_vm *vm, struct anonymous *k);
// neko_vm_dump_stack
// file vm/interp.c line 547
void neko_vm_dump_stack(struct _neko_vm *vm);
// neko_vm_execute
// file vm/interp.c line 229
struct _value * neko_vm_execute(struct _neko_vm *vm, void *_m);
// neko_vm_jit
// file vm/neko_vm.h line 52
signed int neko_vm_jit(struct _neko_vm *vm, signed int enable_jit);
// neko_vm_redirect
// file vm/interp.c line 210
void neko_vm_redirect(struct _neko_vm *vm, void (*print)(const char *, signed int, void *), void *param);
// neko_vm_redirect::print$object
//
void print$object(const char *, signed int, void *);
// neko_vm_select
// file vm/neko_vm.h line 51
void neko_vm_select(struct _neko_vm *vm);
// neko_vm_set_custom
// file vm/interp.c line 174
void neko_vm_set_custom(struct _neko_vm *vm, struct anonymous *k, void *v);
// neko_vm_set_stats
// file vm/neko_vm.h line 56
void neko_vm_set_stats(struct _neko_vm *vm, void (*fstats)(struct _neko_vm *, const char *, signed int), void (*pstats)(struct _neko_vm *, const char *, signed int));
// neko_vm_set_stats::fstats$object
//
void fstats$object(struct _neko_vm *, const char *, signed int);
// neko_vm_set_stats::pstats$object
//
void pstats$object(struct _neko_vm *, const char *, signed int);
// neko_vm_trusted
// file vm/interp.c line 145
signed int neko_vm_trusted(struct _neko_vm *vm, signed int t);
// null_warn_proc
// file vm/alloc.c line 111
static void null_warn_proc(char *msg, signed int arg);
// open_module
// file vm/load.c line 169
static void open_module(struct _value *path, const char *mname, signed int (**r)(void *, void *, signed int), void **p);
// open_module::r$object$object
//
signed int r$object$object(void *, void *, signed int);
// otable_copy
// file vm/objtable.h line 80
void otable_copy(struct _objtable *t, struct _objtable *target);
// otable_find
// file vm/objtable.h line 31
static inline struct _value ** otable_find(struct _objtable *t, signed int id);
// otable_find$link1
// file vm/objtable.h line 31
static inline struct _value ** otable_find$link1(struct _objtable *t$link1, signed int id$link1);
// otable_find$link2
// file vm/objtable.h line 31
static inline struct _value ** otable_find$link2(struct _objtable *t$link2, signed int id$link2);
// otable_get
// file vm/objtable.h line 53
static inline struct _value * otable_get(struct _objtable *t, signed int id);
// otable_init
// file vm/objtable.h line 26
static inline void otable_init(struct _objtable *t);
// otable_iter
// file vm/objtable.h line 81
void otable_iter(struct _objtable *t, void (*f)(struct _value *, signed int, void *), void *p);
// otable_iter::f$object
//
void f$object(struct _value *, signed int, void *);
// otable_optimize
// file vm/objtable.c line 53
void otable_optimize(struct _objtable *t);
// otable_remove
// file vm/objtable.h line 76
signed int otable_remove(struct _objtable *t, signed int id);
// otable_replace
// file vm/objtable.h line 75
void otable_replace(struct _objtable *t, signed int id, struct _value *data);
// precise_timer
// file vm/stats.c line 49
static signed int precise_timer();
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_key_delete
// file /usr/include/pthread.h line 1118
extern signed int pthread_key_delete(unsigned int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$22 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$22 *, const union anonymous$21 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$22 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$22 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$22 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous$21 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous$21 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous$21 *, signed int);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// read_bytecode
// file vm/main.c line 150
static struct _value * read_bytecode(struct _value *str, struct _value *pos, struct _value *len);
// read_debug_infos
// file vm/module.c line 244
static void * read_debug_infos(signed int (*r)(void *, void *, signed int), void *p, char *tmp, struct _neko_module *m);
// read_debug_infos::r$object
//
signed int r$object(void *, void *, signed int);
// read_long
// file vm/module.c line 68
static void read_long(signed int (*r)(void *, void *, signed int), void *p, unsigned int *i);
// read_long::r$object
//
signed int r$object(void *, void *, signed int);
// read_short
// file vm/module.c line 76
static void read_short(signed int (*r)(void *, void *, signed int), void *p, unsigned short int *i);
// read_short::r$object
//
signed int r$object(void *, void *, signed int);
// read_string
// file vm/module.c line 108
static signed int read_string(signed int (*r)(void *, void *, signed int), void *p, char *buf);
// read_string::r$object
//
signed int r$object(void *, void *, signed int);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// redirected_print
// file vm/interp.c line 205
static void redirected_print(const char *s, signed int size, void *_p);
// report
// file vm/main.c line 120
static void report(struct _neko_vm *vm, struct _value *exc, signed int isexc);
// scmp
// file vm/others.c line 48
static inline signed int scmp(const char *s1, signed int l1, const char *s2, signed int l2);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$10 *);
// sort
// file vm/stats.c line 138
static struct _statinfos * sort(struct _statinfos *list);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stats_proxy
// file vm/load.c line 327
static struct _value * stats_proxy(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5, struct _value *p6);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// val_buffer_fields
// file vm/others.c line 219
static void val_buffer_fields(struct _value *v, signed int f, void *_l);
// val_buffer_rec
// file vm/others.c line 232
static void val_buffer_rec(struct _buffer *b, struct _value *v, struct vlist *stack);
// varargs_callback
// file vm/builtins.c line 583
static struct _value * varargs_callback(struct _value **args, signed int nargs);

struct anonymous$0
{
  // cells
  struct hcell **cells;
  // ncells
  signed int ncells;
  // nitems
  signed int nitems;
};

struct anonymous$20
{
  // p
  char *p;
  // len
  signed int len;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$22
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$23
{
  // init
  void (*init)(void *);
  // main
  void (*main)(void *);
  // param
  void *param;
  // lock
  union anonymous$22 lock;
};

struct anonymous$24
{
  // prev
  void (*prev)(const char *, signed int, void *);
  // prev_param
  void *prev_param;
  // cur
  void (*cur)(const char *, signed int, void *);
  // cur_param
  void *cur_param;
};

struct anonymous$17
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$15
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$10
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$25
{
  // t
  enum anonymous$7 t;
  // f
  double f;
};

struct anonymous$26
{
  // t
  enum anonymous$7 t;
  // i
  signed int i;
};

struct anonymous$8
{
  // t
  enum anonymous$7 t;
  // nargs
  signed int nargs;
  // addr
  void *addr;
  // env
  struct _value *env;
  // module
  void *module;
};

struct anonymous$5
{
  // t
  enum anonymous$7 t;
  // c
  char c;
};

struct anonymous$6
{
  // t
  enum anonymous$7 t;
  // kind
  struct anonymous *kind;
  // data
  void *data;
};

struct anonymous$4
{
  // t
  enum anonymous$7 t;
  // ptr
  struct _value *ptr;
};

struct anonymous
{
  // __zero
  signed int __zero;
};

struct anonymous$3
{
  // id
  signed int id;
  // v
  struct _value *v;
};

struct anonymous$11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$13
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$12
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$16
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$18
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$11 _kill;
  // _timer
  struct anonymous$12 _timer;
  // _rt
  struct anonymous$13 _rt;
  // _sigchld
  struct anonymous$14 _sigchld;
  // _sigfault
  struct anonymous$15 _sigfault;
  // _sigpoll
  struct anonymous$16 _sigpoll;
  // _sigsys
  struct anonymous$17 _sigsys;
};

struct anonymous$19
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$18 _sifields;
};

struct anonymous$1
{
  // l
  unsigned int l;
  // h
  unsigned int h;
};

union anonymous$9
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$19 *, void *);
};

union anonymous$21
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$2
{
  // d
  double d;
  // i
  struct anonymous$1 i;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$10 __saved_mask;
};

struct _buffer
{
  // totlen
  signed int totlen;
  // blen
  signed int blen;
  // data
  struct _stringitem *data;
};

struct _custom_list
{
  // tag
  struct anonymous *tag;
  // custom
  void *custom;
  // next
  struct _custom_list *next;
};

struct _klist
{
  // name
  const char *name;
  // k
  struct anonymous *k;
  // next
  struct _klist *next;
};

struct _liblist
{
  // name
  char *name;
  // handle
  void *handle;
  // next
  struct _liblist *next;
};

struct _mt_local
{
  // key
  unsigned int key;
};

struct _mt_lock
{
  // lock
  union anonymous$22 lock;
};

struct _neko_debug
{
  // base
  signed int base;
  // bits
  unsigned int bits;
};

struct _neko_module
{
  // jit
  void *jit;
  // nglobals
  unsigned int nglobals;
  // nfields
  unsigned int nfields;
  // codesize
  unsigned int codesize;
  // name
  struct _value *name;
  // globals
  struct _value **globals;
  // fields
  struct _value **fields;
  // loader
  struct _value *loader;
  // exports
  struct _value *exports;
  // dbgtbl
  struct _value *dbgtbl;
  // dbgidxs
  struct _neko_debug *dbgidxs;
  // code
  signed long int *code;
  // jit_gc
  struct _value *jit_gc;
};

struct _neko_vm
{
  // sp
  signed long int *sp;
  // csp
  signed long int *csp;
  // env
  struct _value *env;
  // vthis
  struct _value *vthis;
  // spmin
  signed long int *spmin;
  // spmax
  signed long int *spmax;
  // trap
  signed long int trap;
  // jit_val
  void *jit_val;
  // start
  struct __jmp_buf_tag start[1l];
  // c_stack_max
  void *c_stack_max;
  // run_jit
  signed int run_jit;
  // exc_stack
  struct _value *exc_stack;
  // print
  void (*print)(const char *, signed int, void *);
  // print_param
  void *print_param;
  // clist
  struct _custom_list *clist;
  // resolver
  struct _value *resolver;
  // tmp
  char tmp[100l];
  // trusted_code
  signed int trusted_code;
  // fstats
  void (*fstats)(struct _neko_vm *, const char *, signed int);
  // pstats
  void (*pstats)(struct _neko_vm *, const char *, signed int);
};

struct _objtable
{
  // count
  signed int count;
  // cells
  struct anonymous$3 *cells;
};

struct _statinfos
{
  // kind
  const char *kind;
  // ksize
  signed int ksize;
  // ncalls
  signed int ncalls;
  // nerrors
  signed int nerrors;
  // subtime
  signed int subtime;
  // totaltime
  signed int totaltime;
  // starttime
  signed int starttime;
  // stack
  struct _statinfos *stack;
  // next
  struct _statinfos *next;
};

struct _stringitem
{
  // str
  char *str;
  // size
  signed int size;
  // len
  signed int len;
  // next
  struct _stringitem *next;
};

struct _value
{
  // t
  enum anonymous$7 t;
};

struct _vobject
{
  // t
  enum anonymous$7 t;
  // table
  struct _objtable table;
  // proto
  struct _vobject *proto;
};

struct hcell
{
  // hkey
  signed int hkey;
  // key
  struct _value *key;
  // val
  struct _value *val;
  // next
  struct hcell *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$9 __sigaction_handler;
  // sa_mask
  struct anonymous$10 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct vlist
{
  // v
  struct _value *v;
  // next
  struct vlist *next;
};

struct vlist2
{
  // v
  struct _value *v;
  // next
  struct vlist *next;
  // b
  struct _buffer *b;
  // prev
  signed int prev;
};

struct vparam
{
  // h
  signed int *h;
  // l
  struct vlist l;
};


// GC_all_interior_pointers
// file /usr/include/gc/gc.h line 143
extern signed int GC_all_interior_pointers;
// GC_java_finalization
// file /usr/include/gc/gc.h line 169
extern signed int GC_java_finalization;
// GC_no_dls
// file /usr/include/gc/gc.h line 257
extern signed int GC_no_dls;
// NEKO_TYPEOF
// file vm/interp.c line 74
struct _value *NEKO_TYPEOF[9l] = { (struct _value *)(signed long int)((signed int)0 << 1 | 1),
    (struct _value *)(signed long int)((signed int)2 << 1 | 1),
    (struct _value *)(signed long int)((signed int)3 << 1 | 1),
    (struct _value *)(signed long int)((signed int)4 << 1 | 1),
    (struct _value *)(signed long int)((signed int)5 << 1 | 1),
    (struct _value *)(signed long int)((signed int)6 << 1 | 1),
    (struct _value *)(signed long int)((signed int)7 << 1 | 1),
    (struct _value *)(signed long int)((signed int)8 << 1 | 1),
    (struct _value *)(signed long int)((signed int)1 << 1 | 1) };
// __kind_k_hash
// file vm/others.c line 31
signed long int __kind_k_hash = (signed long int)0;
// __kind_k_loader_libs
// file vm/load.c line 36
signed long int __kind_k_loader_libs = (signed long int)0;
// __kind_k_old_int32
// file vm/builtins.c line 37
signed long int __kind_k_old_int32 = (signed long int)0;
// __kind_neko_k_kind
// file vm/builtins.c line 36
signed long int __kind_neko_k_kind = (signed long int)0;
// __kind_neko_kind_module
// file vm/module.c line 31
signed long int __kind_neko_kind_module = (signed long int)0;
// apply_string
// file vm/alloc.c line 68
static struct _value **apply_string = (struct _value **)(void *)0;
// callback_return
// file vm/alloc.c line 69
signed long int *callback_return;
// op_last
// file vm/alloc.c line 67
static signed long int op_last = (signed long int)67;
// callback_return
// file vm/alloc.c line 69
signed long int *callback_return = &op_last;
// empty_array
// file vm/alloc.c line 80
static struct anonymous$4 empty_array = { .t=(enum anonymous$7)VAL_ARRAY, .ptr=(struct _value *)(void *)0 };
// empty_string
// file vm/alloc.c line 81
static struct anonymous$5 empty_string = { .t=(enum anonymous$7)VAL_STRING, .c=(char)0 };
// id_add
// file vm/alloc.c line 91
signed int id_add;
// id_cache
// file vm/alloc.c line 87
signed int id_cache;
// id_compare
// file vm/alloc.c line 83
signed int id_compare;
// id_div
// file vm/alloc.c line 91
signed int id_div;
// id_exports
// file vm/alloc.c line 86
signed int id_exports;
// id_get
// file vm/alloc.c line 90
signed int id_get;
// id_loader
// file vm/alloc.c line 85
signed int id_loader;
// id_loader_libs
// file vm/alloc.c line 89
signed int id_loader_libs;
// id_mod
// file vm/alloc.c line 91
signed int id_mod;
// id_mult
// file vm/alloc.c line 91
signed int id_mult;
// id_path
// file vm/alloc.c line 88
signed int id_path;
// id_radd
// file vm/alloc.c line 91
signed int id_radd;
// id_rdiv
// file vm/alloc.c line 91
signed int id_rdiv;
// id_rmod
// file vm/alloc.c line 91
signed int id_rmod;
// id_rmult
// file vm/alloc.c line 91
signed int id_rmult;
// id_rsub
// file vm/alloc.c line 91
signed int id_rsub;
// id_set
// file vm/alloc.c line 90
signed int id_set;
// id_string
// file vm/alloc.c line 84
signed int id_string;
// id_sub
// file vm/alloc.c line 91
signed int id_sub;
// init_done
// file vm/stats.c line 47
static signed int init_done = 0;
// jit_boot_seq
// file vm/jit_x86.c line 2769
char *jit_boot_seq = (char *)(void *)0;
// jit_handle_trap
// file vm/jit_x86.c line 2770
char *jit_handle_trap;
// jit_handle_trap
// file vm/jit_x86.c line 2770
char *jit_handle_trap = (char *)&jit_boot_seq;
// k_loader_libs
// file vm/load.c line 36
struct anonymous *k_loader_libs;
// k_loader_libs
// file vm/load.c line 36
struct anonymous *k_loader_libs = (struct anonymous *)&__kind_k_loader_libs;
// k_old_int32
// file vm/builtins.c line 37
struct anonymous *k_old_int32;
// k_old_int32
// file vm/builtins.c line 37
struct anonymous *k_old_int32 = (struct anonymous *)&__kind_k_old_int32;
// kind_names
// file vm/alloc.c line 82
static struct _klist **kind_names = (struct _klist **)(void *)0;
// list
// file vm/stats.c line 45
static struct _statinfos *list = (struct _statinfos *)(void *)0;
// neko_builtins
// file vm/alloc.c line 70
struct _value **neko_builtins = (struct _value **)(void *)0;
// neko_fields
// file vm/alloc.c line 71
struct _objtable *neko_fields = (struct _objtable *)(void *)0;
// neko_fields_lock
// file vm/alloc.c line 72
struct _mt_lock *neko_fields_lock = (struct _mt_lock *)(void *)0;
// neko_id_module
// file vm/alloc.c line 92
signed int neko_id_module;
// neko_k_hash
// file vm/others.c line 31
struct anonymous *neko_k_hash;
// neko_k_hash
// file vm/others.c line 31
struct anonymous *neko_k_hash = (struct anonymous *)&__kind_k_hash;
// neko_k_kind
// file vm/builtins.c line 36
struct anonymous *neko_k_kind;
// neko_k_kind
// file vm/builtins.c line 36
struct anonymous *neko_k_kind = (struct anonymous *)&__kind_neko_k_kind;
// neko_kind_module
// file vm/module.c line 31
struct anonymous *neko_kind_module;
// neko_kind_module
// file vm/module.c line 31
struct anonymous *neko_kind_module = (struct anonymous *)&__kind_neko_kind_module;
// neko_vm_context
// file vm/alloc.c line 73
struct _mt_local *neko_vm_context = (struct _mt_local *)(void *)0;
// parameter_table
// file vm/opcodes.h line 103
static signed int parameter_table[67l] = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1 };
// self
// file vm/main.c line 50
static struct _IO_FILE *self;
// stack
// file vm/stats.c line 46
static struct _statinfos *stack = (struct _statinfos *)(void *)0;
// stack_table
// file vm/opcodes.h line 177
static signed int stack_table[68l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, -2, -1, 0, 1, -0xFF, -0xFF, -0xFF, 0, 0, 0, 6, -6, 0, -0xFF, -0xFF, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, 0, 0, -0xFF, 0, 0, 0, 0, -1, 0, 0, -0xFF, 0, 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// t_false
// file vm/alloc.c line 76
static enum anonymous$7 t_false = (enum anonymous$7)VAL_BOOL;
// t_null
// file vm/alloc.c line 74
static enum anonymous$7 t_null = (enum anonymous$7)VAL_NULL;
// t_true
// file vm/alloc.c line 75
static enum anonymous$7 t_true = (enum anonymous$7)VAL_BOOL;
// val_false
// file vm/alloc.c line 79
struct _value *val_false;
// val_false
// file vm/alloc.c line 79
struct _value *val_false = (struct _value *)&t_false;
// val_null
// file vm/alloc.c line 77
struct _value *val_null;
// val_null
// file vm/alloc.c line 77
struct _value *val_null = (struct _value *)&t_null;
// val_true
// file vm/alloc.c line 78
struct _value *val_true;
// val_true
// file vm/alloc.c line 78
struct _value *val_true = (struct _value *)&t_true;

// ThreadMain
// file vm/threads.c line 110
static void * ThreadMain(void *_p)
{
  struct anonymous$23 *lp = (struct anonymous$23 *)_p;
  struct anonymous$23 p = *lp;
  p.init(p.param);
  pthread_mutex_unlock(&lp->lock);
  clean_c_stack(40, (void *)clean_c_stack);
  p.main(p.param);
  return NULL;
}

// __on_finalize
// file vm/alloc.c line 344
static void __on_finalize(struct _value *v, void *f)
{
  ((void (*)(struct _value *))f)(v);
}

// _neko_failure
// file vm/neko.h line 435
void _neko_failure(struct _value *msg, const char *file, signed int line)
{
  char *fname;
  fname=strrchr(file, 47);
  char *fname2;
  fname2=strrchr(file, 92);
  struct _value *o;
  o=neko_alloc_object((struct _value *)(void *)0);
  if(!(fname >= fname2))
    fname = fname2;

  signed int return_value_neko_val_id$1;
  return_value_neko_val_id$1=neko_val_id("msg");
  neko_alloc_field(o, return_value_neko_val_id$1, msg);
  signed int return_value_neko_val_id$2;
  return_value_neko_val_id$2=neko_val_id("file");
  struct _value *return_value_neko_alloc_string$3;
  return_value_neko_alloc_string$3=neko_alloc_string(fname != ((char *)NULL) ? fname + (signed long int)1 : file);
  neko_alloc_field(o, return_value_neko_val_id$2, return_value_neko_alloc_string$3);
  signed int return_value_neko_val_id$4;
  return_value_neko_val_id$4=neko_val_id("line");
  neko_alloc_field(o, return_value_neko_val_id$4, (struct _value *)(signed long int)((signed int)line << 1 | 1));
  struct _value *return_value_neko_alloc_function$5;
  return_value_neko_alloc_function$5=neko_alloc_function((void *)failure_to_string, (unsigned int)0, "failure_to_string");
  neko_alloc_field(o, id_string, return_value_neko_alloc_function$5);
  neko_val_throw(o);
}

// add_rec
// file vm/builtins.c line 796
static void add_rec(struct hcell **cc, signed int size, struct hcell *c)
{
  signed int k;
  if(!(c == ((struct hcell *)NULL)))
  {
    add_rec(cc, size, c->next);
    k = c->hkey % size;
    c->next = cc[(signed long int)k];
    cc[(signed long int)k] = c;
  }

}

// append_array
// file vm/module.c line 224
static void append_array(struct _value **arr, signed int pos, struct _value *v)
{
  signed int len = (signed int)*((enum anonymous$7 *)*arr) >> 4;
  if(pos >= len)
  {
    struct _value *a2;
    a2=neko_alloc_array((unsigned int)((len * 3) / 2));
    memcpy((void *)&((struct anonymous$4 *)a2)->ptr, (const void *)&((struct anonymous$4 *)*arr)->ptr, (unsigned long int)len * sizeof(struct _value *) /*8ul*/ );
    *arr = a2;
  }

  (&((struct anonymous$4 *)*arr)->ptr)[(signed long int)pos] = v;
}

// apply1
// file vm/alloc.c line 249
static struct _value * apply1(struct _value *p1)
{
  struct _value *env;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get$1)->env;
  struct _value **a = &((struct anonymous$4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous$7 *)env) >> 4) - 1;
  a[(signed long int)(n - 1)] = p1;
  struct _value *return_value_neko_val_callN$2;
  return_value_neko_val_callN$2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN$2;
}

// apply2
// file vm/alloc.c line 257
static struct _value * apply2(struct _value *p1, struct _value *p2)
{
  struct _value *env;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get$1)->env;
  struct _value **a = &((struct anonymous$4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous$7 *)env) >> 4) - 1;
  a[(signed long int)(n - 2)] = p1;
  a[(signed long int)(n - 1)] = p2;
  struct _value *return_value_neko_val_callN$2;
  return_value_neko_val_callN$2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN$2;
}

// apply3
// file vm/alloc.c line 266
static struct _value * apply3(struct _value *p1, struct _value *p2, struct _value *p3)
{
  struct _value *env;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get$1)->env;
  struct _value **a = &((struct anonymous$4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous$7 *)env) >> 4) - 1;
  a[(signed long int)(n - 3)] = p1;
  a[(signed long int)(n - 2)] = p2;
  a[(signed long int)(n - 1)] = p3;
  struct _value *return_value_neko_val_callN$2;
  return_value_neko_val_callN$2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN$2;
}

// apply4
// file vm/alloc.c line 276
static struct _value * apply4(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4)
{
  struct _value *env;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get$1)->env;
  struct _value **a = &((struct anonymous$4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous$7 *)env) >> 4) - 1;
  a[(signed long int)(n - 4)] = p1;
  a[(signed long int)(n - 3)] = p2;
  a[(signed long int)(n - 2)] = p3;
  a[(signed long int)(n - 1)] = p4;
  struct _value *return_value_neko_val_callN$2;
  return_value_neko_val_callN$2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN$2;
}

// apply5
// file vm/alloc.c line 287
static struct _value * apply5(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5)
{
  struct _value *env;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get$1)->env;
  struct _value **a = &((struct anonymous$4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous$7 *)env) >> 4) - 1;
  a[(signed long int)(n - 4)] = p1;
  a[(signed long int)(n - 3)] = p2;
  a[(signed long int)(n - 2)] = p3;
  a[(signed long int)(n - 1)] = p4;
  a[(signed long int)(n - 1)] = p5;
  struct _value *return_value_neko_val_callN$2;
  return_value_neko_val_callN$2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN$2;
}

// bitcount
// file vm/interp.c line 501
static signed int bitcount(unsigned int k)
{
  signed int b = 0;
  for( ; !(k == 0u); k = k & k - (unsigned int)1)
    b = b + 1;
  return b;
}

// buffer_append_new
// file vm/others.c line 136
static void buffer_append_new(struct _buffer *b, const char *s, signed int len)
{
  signed int size;
  struct _stringitem *it;
  for( ; b->totlen >= b->blen << 2; b->blen = b->blen << 1)
    ;
  signed int tmp_if_expr$1;
  if(!(len >= b->blen))
    tmp_if_expr$1 = b->blen;

  else
    tmp_if_expr$1 = len;
  size = tmp_if_expr$1;
  char *return_value_neko_alloc$2;
  return_value_neko_alloc$2=neko_alloc((unsigned int)sizeof(struct _stringitem) /*24ul*/ );
  it = (struct _stringitem *)return_value_neko_alloc$2;
  it->str=neko_alloc_private((unsigned int)size);
  memcpy((void *)it->str, (const void *)s, (unsigned long int)len);
  it->size = size;
  it->len = len;
  it->next = b->data;
  b->data = it;
}

// builtin_ablit
// file vm/builtins.c line 131
static struct _value * builtin_ablit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l)
{
  signed int dpp;
  signed int spp;
  signed int ll;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)dst) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)dst) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)dp) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)src) == 0)
        tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)src) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        return (struct _value *)(void *)0;

      else
        if((1 & (signed int)sp) == 0)
          return (struct _value *)(void *)0;

        else
          if((1 & (signed int)l) == 0)
            return (struct _value *)(void *)0;

          else
          {
            dpp = (signed int)(signed long int)dp >> 1;
            spp = (signed int)(signed long int)sp >> 1;
            ll = (signed int)(signed long int)l >> 1;
            if(!(dpp + ll >= 0) || !(ll + spp >= 0) || !(dpp >= 0) || !(ll >= 0) || !(spp >= 0))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = dpp + ll > (signed int)*((enum anonymous$7 *)dst) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = spp + ll > (signed int)*((enum anonymous$7 *)src) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$4)
              return (struct _value *)(void *)0;

            else
            {
              memmove((void *)(&((struct anonymous$4 *)dst)->ptr + (signed long int)dpp), (const void *)(&((struct anonymous$4 *)src)->ptr + (signed long int)spp), (unsigned long int)ll * sizeof(struct _value *) /*8ul*/ );
              return val_null;
            }
          }
    }
}

// builtin_aconcat
// file vm/builtins.c line 153
static struct _value * builtin_aconcat(struct _value *arrs)
{
  signed int tot = 0;
  signed int len;
  signed int i;
  struct _value *all;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)arrs) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)arrs) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  signed int tmp_post$3;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    len = (signed int)*((enum anonymous$7 *)arrs) >> 4;
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      struct _value *a = (&((struct anonymous$4 *)arrs)->ptr)[(signed long int)i];
      if((1 & (signed int)a) == 0)
        tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        return (struct _value *)(void *)0;

      tot = tot + ((signed int)*((enum anonymous$7 *)a) >> 4);
    }
    all=neko_alloc_array((unsigned int)tot);
    tot = 0;
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      struct _value *builtin_aconcat$$1$$2$$1$$a = (&((struct anonymous$4 *)arrs)->ptr)[(signed long int)i];
      signed int j;
      signed int max = (signed int)*((enum anonymous$7 *)builtin_aconcat$$1$$2$$1$$a) >> 4;
      j = 0;
      for( ; !(j >= max); j = j + 1)
      {
        tmp_post$3 = tot;
        tot = tot + 1;
        (&((struct anonymous$4 *)all)->ptr)[(signed long int)tmp_post$3] = (&((struct anonymous$4 *)builtin_aconcat$$1$$2$$1$$a)->ptr)[(signed long int)j];
      }
    }
    return all;
  }
}

// builtin_acopy
// file vm/builtins.c line 81
static struct _value * builtin_acopy(struct _value *a)
{
  signed int i;
  struct _value *a2;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)a) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    a2=neko_alloc_array((unsigned int)((signed int)*((enum anonymous$7 *)a) >> 4));
    i = 0;
    for( ; !(i >= (signed int)*((enum anonymous$7 *)a) >> 4); i = i + 1)
      (&((struct anonymous$4 *)a2)->ptr)[(signed long int)i] = (&((struct anonymous$4 *)a)->ptr)[(signed long int)i];
    return a2;
  }
}

// builtin_amake
// file vm/builtins.c line 66
static struct _value * builtin_amake(struct _value *size)
{
  struct _value *a;
  signed int i;
  signed int s;
  if((1 & (signed int)size) == 0)
    return (struct _value *)(void *)0;

  else
  {
    s = (signed int)(signed long int)size >> 1;
    a=neko_alloc_array((unsigned int)s);
    i = 0;
    for( ; !(i >= s); i = i + 1)
      (&((struct anonymous$4 *)a)->ptr)[(signed long int)i] = val_null;
    return a;
  }
}

// builtin_apply
// file vm/builtins.c line 556
static struct _value * builtin_apply(struct _value **args, signed int nargs)
{
  struct _value *f;
  struct _value *env;
  signed int fargs;
  signed int i;
  nargs = nargs - 1;
  args = args + 1l;
  _Bool tmp_if_expr$1;
  struct _value *return_value_neko_val_callN$2;
  signed int tmp_post$3;
  if(!(nargs >= 0))
    return (struct _value *)(void *)0;

  else
  {
    f = args[(signed long int)-1];
    if((1 & (signed int)f) == 0)
      tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      return (struct _value *)(void *)0;

    else
      if(nargs == 0)
        return f;

      else
      {
        fargs = ((struct anonymous$8 *)f)->nargs;
        if(fargs == -1 || fargs == nargs)
        {
          return_value_neko_val_callN$2=neko_val_callN(f, args, nargs);
          return return_value_neko_val_callN$2;
        }

        else
          if(!(fargs >= nargs))
            return (struct _value *)(void *)0;

          else
          {
            env=neko_alloc_array((unsigned int)(fargs + 1));
            (&((struct anonymous$4 *)env)->ptr)[(signed long int)0] = f;
            i = 0;
            for( ; !(i >= nargs); i = i + 1)
              (&((struct anonymous$4 *)env)->ptr)[(signed long int)(i + 1)] = args[(signed long int)i];
            do
            {
              tmp_post$3 = i;
              i = i + 1;
              if(tmp_post$3 >= fargs)
                break;

              (&((struct anonymous$4 *)env)->ptr)[(signed long int)i] = val_null;
            }
            while((_Bool)1);
            struct _value *return_value_neko_alloc_apply$4;
            return_value_neko_alloc_apply$4=neko_alloc_apply(fargs - nargs, env);
            return return_value_neko_alloc_apply$4;
          }
      }
  }
}

// builtin_array
// file vm/builtins.c line 54
static struct _value * builtin_array(struct _value **args, signed int nargs)
{
  struct _value *a;
  a=neko_alloc_array((unsigned int)nargs);
  signed int i = 0;
  for( ; !(i >= nargs); i = i + 1)
    (&((struct anonymous$4 *)a)->ptr)[(signed long int)i] = args[(signed long int)i];
  return a;
}

// builtin_asize
// file vm/builtins.c line 95
static struct _value * builtin_asize(struct _value *a)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)a) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((signed int)*((enum anonymous$7 *)a) >> 4) << 1 | 1);
}

// builtin_asub
// file vm/builtins.c line 107
static struct _value * builtin_asub(struct _value *a, struct _value *p, struct _value *l)
{
  struct _value *a2;
  signed int i;
  signed int pp;
  signed int ll;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)a) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)l) == 0)
        return (struct _value *)(void *)0;

      else
      {
        pp = (signed int)(signed long int)p >> 1;
        ll = (signed int)(signed long int)l >> 1;
        if(!(ll + pp >= 0) || !(ll >= 0) || !(pp >= 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = pp + ll > (signed int)*((enum anonymous$7 *)a) >> 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return (struct _value *)(void *)0;

        else
        {
          a2=neko_alloc_array((unsigned int)ll);
          i = 0;
          for( ; !(i >= ll); i = i + 1)
            (&((struct anonymous$4 *)a2)->ptr)[(signed long int)i] = (&((struct anonymous$4 *)a)->ptr)[(signed long int)(pp + i)];
          return a2;
        }
      }
}

// builtin_call
// file vm/builtins.c line 489
static struct _value * builtin_call(struct _value *f, struct _value *ctx, struct _value *args)
{
  struct _value *old;
  struct _value *ret;
  struct _neko_vm *vm;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)args) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)args) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    void *return_value_neko_local_get$2;
    return_value_neko_local_get$2=neko_local_get(neko_vm_context);
    vm = (struct _neko_vm *)return_value_neko_local_get$2;
    old = vm->vthis;
    vm->vthis = ctx;
    ret=neko_val_callN(f, &((struct anonymous$4 *)args)->ptr, (signed int)*((enum anonymous$7 *)args) >> 4);
    vm->vthis = old;
    return ret;
  }
}

// builtin_callstack
// file vm/builtins.c line 1197
static struct _value * builtin_callstack()
{
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  struct _value *return_value_neko_call_stack$2;
  return_value_neko_call_stack$2=neko_call_stack((struct _neko_vm *)return_value_neko_local_get$1);
  return return_value_neko_call_stack$2;
}

// builtin_closure
// file vm/builtins.c line 530
static struct _value * builtin_closure(struct _value **args, signed int nargs)
{
  struct _value *f;
  struct _value *env;
  signed int fargs;
  struct _value *return_value_neko_alloc_string$1;
  if(!(nargs >= 2))
  {
    return_value_neko_alloc_string$1=neko_alloc_string("Invalid closure arguments number");
    _neko_failure(return_value_neko_alloc_string$1, "vm/builtins.c", 535);
  }

  f = args[(signed long int)0];
  _Bool tmp_if_expr$2;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  struct _value *return_value_neko_alloc_string$3;
  if(!tmp_if_expr$2)
    return (struct _value *)(void *)0;

  else
  {
    fargs = ((struct anonymous$8 *)f)->nargs;
    if(!(fargs == -1) && !(fargs >= nargs + -2))
    {
      return_value_neko_alloc_string$3=neko_alloc_string("Invalid closure arguments number");
      _neko_failure(return_value_neko_alloc_string$3, "vm/builtins.c", 541);
    }

    env=neko_alloc_array((unsigned int)nargs);
    memcpy((void *)&((struct anonymous$4 *)env)->ptr, (const void *)args, (unsigned long int)nargs * sizeof(struct _value *) /*8ul*/ );
    f=neko_alloc_function((void *)closure_callback, (unsigned int)-1, "closure_callback");
    ((struct anonymous$8 *)f)->env = env;
    return f;
  }
}

// builtin_compare
// file vm/builtins.c line 1157
static struct _value * builtin_compare(struct _value *a, struct _value *b)
{
  signed int r;
  r=neko_val_compare(a, b);
  return r == 0xFE ? val_null : (struct _value *)(signed long int)((signed int)r << 1 | 1);
}

// builtin_excstack
// file vm/builtins.c line 1189
static struct _value * builtin_excstack()
{
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  return ((struct _neko_vm *)return_value_neko_local_get$1)->exc_stack;
}

// builtin_fasthash
// file vm/builtins.c line 422
static struct _value * builtin_fasthash(struct _value *f)
{
  struct _value *acc = (struct _value *)(signed long int)((signed int)0 << 1 | 1);
  unsigned char *name;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    name = (unsigned char *)&((struct anonymous$5 *)f)->c;
    for( ; !(*name == 0); name = name + 1l)
      acc = (struct _value *)(signed long int)((signed int)(223 * ((signed int)(signed long int)acc >> 1) + (signed int)*name) << 1 | 1);
    return acc;
  }
}

// builtin_field
// file vm/builtins.c line 439
static struct _value * builtin_field(struct _value *f)
{
  if((1 & (signed int)f) == 0)
    return (struct _value *)(void *)0;

  else
  {
    struct _value *return_value_neko_val_field_name$1;
    return_value_neko_val_field_name$1=neko_val_field_name((signed int)(signed long int)f >> 1);
    return return_value_neko_val_field_name$1;
  }
}

// builtin_float
// file vm/builtins.c line 732
static struct _value * builtin_float(struct _value *f)
{
  struct _value *tmp_if_expr$3;
  struct _value *return_value_neko_alloc_float$2;
  if((1 & (signed int)f) == 0)
  {
    if((15 & (signed int)*((enum anonymous$7 *)f)) == VAL_STRING)
    {
      char *c = &((struct anonymous$5 *)f)->c;
      char *end;
      double builtin_float$$1$$1$$f;
      double return_value_strtod$1;
      return_value_strtod$1=strtod(c, &end);
      builtin_float$$1$$1$$f = (double)return_value_strtod$1;
      if(c == end)
        tmp_if_expr$3 = val_null;

      else
      {
        return_value_neko_alloc_float$2=neko_alloc_float(builtin_float$$1$$1$$f);
        tmp_if_expr$3 = return_value_neko_alloc_float$2;
      }
      return tmp_if_expr$3;
    }

  }

  _Bool tmp_if_expr$7;
  if(!((1 & (signed int)f) == 0))
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = (signed int)*((enum anonymous$7 *)f) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = (signed int)*((enum anonymous$7 *)f) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
  double tmp_if_expr$5;
  double tmp_if_expr$4;
  struct _value *return_value_neko_alloc_float$6;
  if(tmp_if_expr$8)
  {
    if(!((1 & (signed int)f) == 0))
      tmp_if_expr$5 = (double)((signed int)(signed long int)f >> 1);

    else
    {
      if((signed int)*((enum anonymous$7 *)f) == VAL_FLOAT)
        tmp_if_expr$4 = ((struct anonymous$25 *)f)->f;

      else
        tmp_if_expr$4 = (double)((struct anonymous$26 *)f)->i;
      tmp_if_expr$5 = tmp_if_expr$4;
    }
    return_value_neko_alloc_float$6=neko_alloc_float(tmp_if_expr$5);
    return return_value_neko_alloc_float$6;
  }

  else
    return val_null;
}

// builtin_getkind
// file vm/builtins.c line 749
static struct _value * builtin_getkind(struct _value *v)
{
  struct _value *return_value_neko_alloc_abstract$1;
  _Bool tmp_if_expr$2;
  if((1 & (signed int)v) == 0)
  {
    if(!((signed int)*((enum anonymous$7 *)v) == VAL_INT32))
      goto __CPROVER_DUMP_L1;

    return_value_neko_alloc_abstract$1=neko_alloc_abstract(neko_k_kind, (void *)k_old_int32);
    return return_value_neko_alloc_abstract$1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if((1 & (signed int)v) == 0)
      tmp_if_expr$2 = (signed int)*((enum anonymous$7 *)v) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      return (struct _value *)(void *)0;

    else
    {
      struct _value *return_value_neko_alloc_abstract$3;
      return_value_neko_alloc_abstract$3=neko_alloc_abstract(neko_k_kind, (void *)((struct anonymous$6 *)v)->kind);
      return return_value_neko_alloc_abstract$3;
    }
  }
}

// builtin_hadd
// file vm/builtins.c line 995
static struct _value * builtin_hadd(struct _value *vh, struct _value *key, struct _value *val)
{
  struct anonymous$0 *h;
  struct hcell *c;
  signed int hkey;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(!tmp_if_expr$2)
    return (struct _value *)(void *)0;

  else
  {
    h = (struct anonymous$0 *)((struct anonymous$6 *)vh)->data;
    hkey=neko_val_hash(key);
    if(!(hkey >= 0))
      return (struct _value *)(void *)0;

    else
    {
      if(h->nitems >= h->ncells << 1)
        builtin_hresize(vh, (struct _value *)(signed long int)((signed int)(h->ncells << 1) << 1 | 1));

      char *return_value_neko_alloc$3;
      return_value_neko_alloc$3=neko_alloc((unsigned int)sizeof(struct hcell) /*32ul*/ );
      c = (struct hcell *)return_value_neko_alloc$3;
      c->hkey = hkey;
      c->key = key;
      c->val = val;
      hkey = hkey % h->ncells;
      c->next = h->cells[(signed long int)hkey];
      h->cells[(signed long int)hkey] = c;
      h->nitems = h->nitems + 1;
      return val_null;
    }
  }
}

// builtin_hash
// file vm/builtins.c line 413
static struct _value * builtin_hash(struct _value *f)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    signed int return_value_neko_val_id$2;
    return_value_neko_val_id$2=neko_val_id(&((struct anonymous$5 *)f)->c);
    return (struct _value *)(signed long int)((signed int)return_value_neko_val_id$2 << 1 | 1);
  }
}

// builtin_hcount
// file vm/builtins.c line 1042
static struct _value * builtin_hcount(struct _value *vh)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(!tmp_if_expr$2)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((struct anonymous$0 *)((struct anonymous$6 *)vh)->data)->nitems << 1 | 1);
}

// builtin_hget
// file vm/builtins.c line 838
static struct _value * builtin_hget(struct _value *vh, struct _value *key, struct _value *cmp)
{
  struct anonymous$0 *h;
  struct hcell *c;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous$8 *)cmp)->nargs == 2))
        tmp_if_expr$2 = ((struct anonymous$8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr$4 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(!tmp_if_expr$5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous$0 *)((struct anonymous$6 *)vh)->data;
      signed int return_value_neko_val_hash$6;
      return_value_neko_val_hash$6=neko_val_hash(key);
      c = h->cells[(signed long int)(return_value_neko_val_hash$6 % h->ncells)];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare$7;
          return_value_neko_val_compare$7=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare$7 == 0)
            return c->val;

          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2$8;
          return_value_neko_val_call2$8=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2$8 == (struct _value *)1l)
            return c->val;

          c = c->next;
        }
      return val_null;
    }
  }
}

// builtin_hiter
// file vm/builtins.c line 1021
static struct _value * builtin_hiter(struct _value *vh, struct _value *f)
{
  signed int i;
  struct hcell *c;
  struct anonymous$0 *h;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(!(((struct anonymous$8 *)f)->nargs == 2))
      tmp_if_expr$2 = ((struct anonymous$8 *)f)->nargs != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$3)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)vh) == 0)
      tmp_if_expr$4 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(!tmp_if_expr$5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous$0 *)((struct anonymous$6 *)vh)->data;
      i = 0;
      for( ; !(i >= h->ncells); i = i + 1)
      {
        c = h->cells[(signed long int)i];
        for( ; !(c == ((struct hcell *)NULL)); c = c->next)
          neko_val_call2(f, c->key, c->val);
      }
      return val_null;
    }
  }
}

// builtin_hkey
// file vm/builtins.c line 771
static struct _value * builtin_hkey(struct _value *v)
{
  signed int return_value_neko_val_hash$1;
  return_value_neko_val_hash$1=neko_val_hash(v);
  return (struct _value *)(signed long int)((signed int)return_value_neko_val_hash$1 << 1 | 1);
}

// builtin_hmem
// file vm/builtins.c line 870
static struct _value * builtin_hmem(struct _value *vh, struct _value *key, struct _value *cmp)
{
  struct anonymous$0 *h;
  struct hcell *c;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous$8 *)cmp)->nargs == 2))
        tmp_if_expr$2 = ((struct anonymous$8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr$4 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(!tmp_if_expr$5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous$0 *)((struct anonymous$6 *)vh)->data;
      signed int return_value_neko_val_hash$6;
      return_value_neko_val_hash$6=neko_val_hash(key);
      c = h->cells[(signed long int)(return_value_neko_val_hash$6 % h->ncells)];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare$7;
          return_value_neko_val_compare$7=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare$7 == 0)
            return val_true;

          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2$8;
          return_value_neko_val_call2$8=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2$8 == (struct _value *)1l)
            return val_true;

          c = c->next;
        }
      return val_false;
    }
  }
}

// builtin_hnew
// file vm/builtins.c line 781
static struct _value * builtin_hnew(struct _value *size)
{
  struct anonymous$0 *h;
  signed int i;
  if((1 & (signed int)size) == 0)
    return (struct _value *)(void *)0;

  else
  {
    char *return_value_neko_alloc$1;
    return_value_neko_alloc$1=neko_alloc((unsigned int)sizeof(struct anonymous$0) /*16ul*/ );
    h = (struct anonymous$0 *)return_value_neko_alloc$1;
    h->nitems = 0;
    h->ncells = (signed int)(signed long int)size >> 1;
    if(!(h->ncells >= 1))
      h->ncells = 7;

    char *return_value_neko_alloc$2;
    return_value_neko_alloc$2=neko_alloc((unsigned int)(sizeof(struct hcell *) /*8ul*/  * (unsigned long int)h->ncells));
    h->cells = (struct hcell **)return_value_neko_alloc$2;
    i = 0;
    for( ; !(i >= h->ncells); i = i + 1)
      h->cells[(signed long int)i] = (struct hcell *)(void *)0;
    struct _value *return_value_neko_alloc_abstract$3;
    return_value_neko_alloc_abstract$3=neko_alloc_abstract(neko_k_hash, (void *)h);
    return return_value_neko_alloc_abstract$3;
  }
}

// builtin_hremove
// file vm/builtins.c line 902
static struct _value * builtin_hremove(struct _value *vh, struct _value *key, struct _value *cmp)
{
  struct anonymous$0 *h;
  struct hcell *c;
  struct hcell *prev = (struct hcell *)(void *)0;
  signed int hkey;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous$8 *)cmp)->nargs == 2))
        tmp_if_expr$2 = ((struct anonymous$8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr$4 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(!tmp_if_expr$5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous$0 *)((struct anonymous$6 *)vh)->data;
      signed int return_value_neko_val_hash$6;
      return_value_neko_val_hash$6=neko_val_hash(key);
      hkey = return_value_neko_val_hash$6 % h->ncells;
      c = h->cells[(signed long int)hkey];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare$7;
          return_value_neko_val_compare$7=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare$7 == 0)
          {
            if(prev == ((struct hcell *)NULL))
              h->cells[(signed long int)hkey] = c->next;

            else
              prev->next = c->next;
            h->nitems = h->nitems - 1;
            return val_true;
          }

          prev = c;
          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2$8;
          return_value_neko_val_call2$8=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2$8 == (struct _value *)1l)
          {
            if(prev == ((struct hcell *)NULL))
              h->cells[(signed long int)hkey] = c->next;

            else
              prev->next = c->next;
            h->nitems = h->nitems - 1;
            return val_true;
          }

          prev = c;
          c = c->next;
        }
      return val_false;
    }
  }
}

// builtin_hresize
// file vm/builtins.c line 810
static struct _value * builtin_hresize(struct _value *vh, struct _value *size)
{
  struct anonymous$0 *h;
  struct hcell **cc;
  signed int nsize;
  signed int i;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(!tmp_if_expr$2)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)size) == 0)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous$0 *)((struct anonymous$6 *)vh)->data;
      nsize = (signed int)(signed long int)size >> 1;
      if(!(nsize >= 1))
        nsize = 7;

      char *return_value_neko_alloc$3;
      return_value_neko_alloc$3=neko_alloc((unsigned int)(sizeof(struct hcell *) /*8ul*/  * (unsigned long int)nsize));
      cc = (struct hcell **)return_value_neko_alloc$3;
      memset((void *)cc, 0, sizeof(struct hcell *) /*8ul*/  * (unsigned long int)nsize);
      i = 0;
      for( ; !(i >= h->ncells); i = i + 1)
        add_rec(cc, nsize, h->cells[(signed long int)i]);
      h->cells = cc;
      h->ncells = nsize;
      return val_null;
    }
}

// builtin_hset
// file vm/builtins.c line 949
static struct _value * builtin_hset(struct _value *vh, struct _value *key, struct _value *val, struct _value *cmp)
{
  struct anonymous$0 *h;
  struct hcell *c;
  signed int hkey;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous$8 *)cmp)->nargs == 2))
        tmp_if_expr$2 = ((struct anonymous$8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr$4 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(!tmp_if_expr$5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous$0 *)((struct anonymous$6 *)vh)->data;
      hkey=neko_val_hash(key);
      c = h->cells[(signed long int)(hkey % h->ncells)];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare$6;
          return_value_neko_val_compare$6=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare$6 == 0)
          {
            c->val = val;
            return val_false;
          }

          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2$7;
          return_value_neko_val_call2$7=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2$7 == (struct _value *)1l)
          {
            c->val = val;
            return val_false;
          }

          c = c->next;
        }
      if(h->nitems >= h->ncells << 1)
        builtin_hresize(vh, (struct _value *)(signed long int)((signed int)(h->ncells << 1) << 1 | 1));

      char *return_value_neko_alloc$8;
      return_value_neko_alloc$8=neko_alloc((unsigned int)sizeof(struct hcell) /*32ul*/ );
      c = (struct hcell *)return_value_neko_alloc$8;
      c->hkey = hkey;
      c->key = key;
      c->val = val;
      hkey = hkey % h->ncells;
      c->next = h->cells[(signed long int)hkey];
      h->cells[(signed long int)hkey] = c;
      h->nitems = h->nitems + 1;
      return val_true;
    }
  }
}

// builtin_hsize
// file vm/builtins.c line 1051
static struct _value * builtin_hsize(struct _value *vh)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ((struct anonymous$6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(!tmp_if_expr$2)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((struct anonymous$0 *)((struct anonymous$6 *)vh)->data)->ncells << 1 | 1);
}

// builtin_iadd
// file vm/builtins.c line 613
static struct _value * builtin_iadd(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr$1 = (signed int)(signed long int)a >> 1;

  else
    tmp_if_expr$1 = ((struct anonymous$26 *)a)->i;
  signed int tmp_if_expr$2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr$2 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr$2 = ((struct anonymous$26 *)b)->i;
  struct _value *tmp_if_expr$8;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$4;
  struct _value *return_value_neko_alloc_int32$5;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$7;
  if(!((1073741824u + (unsigned int)tmp_if_expr$1 + (unsigned int)tmp_if_expr$2 & 0x80000000) == 0u))
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr$3 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr$3 = ((struct anonymous$26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr$4 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr$4 = ((struct anonymous$26 *)b)->i;
    return_value_neko_alloc_int32$5=neko_alloc_int32(tmp_if_expr$3 + tmp_if_expr$4);
    tmp_if_expr$8 = return_value_neko_alloc_int32$5;
  }

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr$6 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr$6 = ((struct anonymous$26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr$7 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr$7 = ((struct anonymous$26 *)b)->i;
    tmp_if_expr$8 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$6 + tmp_if_expr$7) << 1 | 1);
  }
  return tmp_if_expr$8;
}

// builtin_idiv
// file vm/builtins.c line 637
static struct _value * builtin_idiv(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr$1 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr$1 = ((struct anonymous$26 *)b)->i;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$3;
  struct _value *tmp_if_expr$9;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  struct _value *return_value_neko_alloc_int32$6;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$8;
  if(tmp_if_expr$1 == 0)
    return (struct _value *)(void *)0;

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr$2 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr$2 = ((struct anonymous$26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr$3 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr$3 = ((struct anonymous$26 *)b)->i;
    if(!((1073741824u + (unsigned int)(tmp_if_expr$2 / tmp_if_expr$3) & 0x80000000) == 0u))
    {
      if(!((1 & (signed int)a) == 0))
        tmp_if_expr$4 = (signed int)(signed long int)a >> 1;

      else
        tmp_if_expr$4 = ((struct anonymous$26 *)a)->i;
      if(!((1 & (signed int)b) == 0))
        tmp_if_expr$5 = (signed int)(signed long int)b >> 1;

      else
        tmp_if_expr$5 = ((struct anonymous$26 *)b)->i;
      return_value_neko_alloc_int32$6=neko_alloc_int32(tmp_if_expr$4 / tmp_if_expr$5);
      tmp_if_expr$9 = return_value_neko_alloc_int32$6;
    }

    else
    {
      if(!((1 & (signed int)a) == 0))
        tmp_if_expr$7 = (signed int)(signed long int)a >> 1;

      else
        tmp_if_expr$7 = ((struct anonymous$26 *)a)->i;
      if(!((1 & (signed int)b) == 0))
        tmp_if_expr$8 = (signed int)(signed long int)b >> 1;

      else
        tmp_if_expr$8 = ((struct anonymous$26 *)b)->i;
      tmp_if_expr$9 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$7 / tmp_if_expr$8) << 1 | 1);
    }
    return tmp_if_expr$9;
  }
}

// builtin_imult
// file vm/builtins.c line 629
static struct _value * builtin_imult(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr$1 = (signed int)(signed long int)a >> 1;

  else
    tmp_if_expr$1 = ((struct anonymous$26 *)a)->i;
  signed int tmp_if_expr$2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr$2 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr$2 = ((struct anonymous$26 *)b)->i;
  struct _value *tmp_if_expr$8;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$4;
  struct _value *return_value_neko_alloc_int32$5;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$7;
  if(!(((unsigned int)tmp_if_expr$1 * (unsigned int)tmp_if_expr$2 + 1073741824u & 0x80000000) == 0u))
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr$3 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr$3 = ((struct anonymous$26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr$4 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr$4 = ((struct anonymous$26 *)b)->i;
    return_value_neko_alloc_int32$5=neko_alloc_int32(tmp_if_expr$3 * tmp_if_expr$4);
    tmp_if_expr$8 = return_value_neko_alloc_int32$5;
  }

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr$6 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr$6 = ((struct anonymous$26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr$7 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr$7 = ((struct anonymous$26 *)b)->i;
    tmp_if_expr$8 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$6 * tmp_if_expr$7) << 1 | 1);
  }
  return tmp_if_expr$8;
}

// builtin_int
// file vm/builtins.c line 689
static struct _value * builtin_int(struct _value *f)
{
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)f) == 0))
    tmp_if_expr$1 = VAL_INT;

  else
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1;
  double return_value_fmod$2;
  char *c;
  char *end;
  signed int h;
  _Bool tmp_if_expr$6;
  char *tmp_post$3;
  struct _value *tmp_if_expr$5;
  struct _value *return_value_neko_alloc_int32$4;
  signed long int return_value_strtol$7;
  struct _value *tmp_if_expr$10;
  struct _value *tmp_if_expr$9;
  struct _value *return_value_neko_alloc_int32$8;
  switch(tmp_if_expr$1)
  {
    case VAL_FLOAT:
    {
      return_value_fmod$2=fmod(((struct anonymous$25 *)f)->f, 4294967296.0);
      return (struct _value *)(signed long int)((signed int)(unsigned int)return_value_fmod$2 << 1 | 1);
    }
    case VAL_STRING:
    {
      c = &((struct anonymous$5 *)f)->c;
      if((signed int)*((enum anonymous$7 *)f) >> 4 >= 2)
      {
        if((signed int)*c == 48)
        {
          if((signed int)c[1l] == 120)
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = (signed int)c[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$6)
          {
            h = 0;
            c = c + (signed long int)2;
            while(!(*c == 0))
            {
              char k;
              tmp_post$3 = c;
              c = c + 1l;
              k = *tmp_post$3;
              if((signed int)k >= 48 && !((signed int)k >= 58))
                h = h << 4 | (signed int)k - 48;

              else
                if((signed int)k >= 65 && !((signed int)k >= 71))
                  h = h << 4 | ((signed int)k - 65) + 10;

                else
                  if((signed int)k >= 97 && !((signed int)k >= 103))
                    h = h << 4 | ((signed int)k - 97) + 10;

                  else
                    return val_null;
            }
            if(!((1073741824u + (unsigned int)h & 0x80000000) == 0u))
            {
              return_value_neko_alloc_int32$4=neko_alloc_int32(h);
              tmp_if_expr$5 = return_value_neko_alloc_int32$4;
            }

            else
              tmp_if_expr$5 = (struct _value *)(signed long int)((signed int)h << 1 | 1);
            return tmp_if_expr$5;
          }

        }

      }

      return_value_strtol$7=strtol(c, &end, 10);
      h = (signed int)return_value_strtol$7;
      if(c == end)
        tmp_if_expr$10 = val_null;

      else
      {
        if(!((1073741824u + (unsigned int)h & 0x80000000) == 0u))
        {
          return_value_neko_alloc_int32$8=neko_alloc_int32(h);
          tmp_if_expr$9 = return_value_neko_alloc_int32$8;
        }

        else
          tmp_if_expr$9 = (struct _value *)(signed long int)((signed int)h << 1 | 1);
        tmp_if_expr$10 = tmp_if_expr$9;
      }
      return tmp_if_expr$10;
    }
    case VAL_INT:

    case VAL_INT32:
      return f;
    default:
      return val_null;
  }
}

// builtin_isinfinite
// file vm/builtins.c line 672
static struct _value * builtin_isinfinite(struct _value *f)
{
  union anonymous$2 q;
  unsigned int h;
  unsigned int l;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)f) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return val_false;

  else
  {
    q.d = ((struct anonymous$25 *)f)->f;
    h = q.i.h;
    l = q.i.l;
    l = l | h & (unsigned int)0xFFFFF;
    h = h & (unsigned int)0x7FF00000;
    return h == (unsigned int)0x7FF00000 && l == (unsigned int)0 ? val_true : val_false;
  }
}

// builtin_iskind
// file vm/builtins.c line 760
static struct _value * builtin_iskind(struct _value *v, struct _value *k)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)k) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)k) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ((struct anonymous$6 *)k)->kind == neko_k_kind ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$3;
  struct _value *tmp_if_expr$6;
  struct _value *tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$2)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)v) == 0)
      tmp_if_expr$3 = (signed int)*((enum anonymous$7 *)v) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$6 = ((struct anonymous$6 *)v)->kind == (struct anonymous *)((struct anonymous$6 *)k)->data ? val_true : val_false;

    else
    {
      if((struct anonymous *)((struct anonymous$6 *)k)->data == k_old_int32)
      {
        if((1 & (signed int)v) == 0)
          tmp_if_expr$4 = (signed int)*((enum anonymous$7 *)v) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? val_true : val_false;
      }

      else
        tmp_if_expr$5 = val_false;
      tmp_if_expr$6 = tmp_if_expr$5;
    }
    return tmp_if_expr$6;
  }
}

// builtin_isnan
// file vm/builtins.c line 655
static struct _value * builtin_isnan(struct _value *f)
{
  union anonymous$2 q;
  unsigned int h;
  unsigned int l;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)f) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return val_false;

  else
  {
    q.d = ((struct anonymous$25 *)f)->f;
    h = q.i.h;
    l = q.i.l;
    l = l | h & (unsigned int)0xFFFFF;
    h = h & (unsigned int)0x7FF00000;
    return h == (unsigned int)0x7FF00000 && l != (unsigned int)0 ? val_true : val_false;
  }
}

// builtin_istrue
// file vm/builtins.c line 1098
static struct _value * builtin_istrue(struct _value *f)
{
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(f == val_false) && !(f == val_null) && !(f == (struct _value *)1l))
  {
    if(!((1 & (signed int)f) == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)f) != VAL_INT32 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = ((struct anonymous$26 *)f)->i != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return tmp_if_expr$3 ? val_true : val_false;
}

// builtin_isub
// file vm/builtins.c line 621
static struct _value * builtin_isub(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr$1 = (signed int)(signed long int)a >> 1;

  else
    tmp_if_expr$1 = ((struct anonymous$26 *)a)->i;
  signed int tmp_if_expr$2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr$2 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr$2 = ((struct anonymous$26 *)b)->i;
  struct _value *tmp_if_expr$8;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$4;
  struct _value *return_value_neko_alloc_int32$5;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$7;
  if(!((1073741824u + (unsigned int)tmp_if_expr$1 + -((unsigned int)tmp_if_expr$2) & 0x80000000) == 0u))
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr$3 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr$3 = ((struct anonymous$26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr$4 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr$4 = ((struct anonymous$26 *)b)->i;
    return_value_neko_alloc_int32$5=neko_alloc_int32(tmp_if_expr$3 - tmp_if_expr$4);
    tmp_if_expr$8 = return_value_neko_alloc_int32$5;
  }

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr$6 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr$6 = ((struct anonymous$26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr$7 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr$7 = ((struct anonymous$26 *)b)->i;
    tmp_if_expr$8 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$6 - tmp_if_expr$7) << 1 | 1);
  }
  return tmp_if_expr$8;
}

// builtin_nargs
// file vm/builtins.c line 480
static struct _value * builtin_nargs(struct _value *f)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((struct anonymous$8 *)f)->nargs << 1 | 1);
}

// builtin_new
// file vm/builtins.c line 329
static struct _value * builtin_new(struct _value *o)
{
  _Bool tmp_if_expr$1;
  if(!(o == val_null))
  {
    if((1 & (signed int)o) == 0)
      tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      goto __CPROVER_DUMP_L3;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    struct _value *return_value_neko_alloc_object$2;
    return_value_neko_alloc_object$2=neko_alloc_object(o);
    return return_value_neko_alloc_object$2;
  }
}

// builtin_not
// file vm/builtins.c line 1106
static struct _value * builtin_not(struct _value *f)
{
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(f == val_false || f == val_null || f == (struct _value *)1l)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if((1 & (signed int)f) == 0)
      tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)f) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ((struct anonymous$26 *)f)->i == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr$3 ? val_true : val_false;
}

// builtin_objcall
// file vm/builtins.c line 362
static struct _value * builtin_objcall(struct _value *o, struct _value *f, struct _value *args)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    return val_null;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)args) == 0)
        tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)args) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        return (struct _value *)(void *)0;

      else
      {
        struct _value *return_value_neko_val_ocallN$3;
        return_value_neko_val_ocallN$3=neko_val_ocallN(o, (signed int)(signed long int)f >> 1, &((struct anonymous$4 *)args)->ptr, (signed int)*((enum anonymous$7 *)args) >> 4);
        return return_value_neko_val_ocallN$3;
      }
    }
}

// builtin_objfield
// file vm/builtins.c line 374
static struct _value * builtin_objfield(struct _value *o, struct _value *f)
{
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct _value **return_value_otable_find$2;
  if((1 & (signed int)f) == 0)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)o) == 0)
      tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      return_value_otable_find$2=otable_find(&((struct _vobject *)o)->table, (signed int)(signed long int)f >> 1);
      tmp_if_expr$3 = return_value_otable_find$2 != (struct _value **)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    return tmp_if_expr$3 ? val_true : val_false;
  }
}

// builtin_objfields
// file vm/builtins.c line 397
static struct _value * builtin_objfields(struct _value *o)
{
  struct _value *a;
  struct _value **aptr;
  struct _objtable *t;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    t = &((struct _vobject *)o)->table;
    a=neko_alloc_array((unsigned int)t->count);
    aptr = &((struct anonymous$4 *)a)->ptr;
    otable_iter(t, builtin_objfields_rec, (void *)&aptr);
    return a;
  }
}

// builtin_objfields_rec
// file vm/builtins.c line 389
static void builtin_objfields_rec(struct _value *d, signed int id, void *a)
{
  struct _value **tmp_post$1 = *((struct _value ***)a);
  *((struct _value ***)a) = *((struct _value ***)a) + 1l;
  *tmp_post$1 = (struct _value *)(signed long int)((signed int)id << 1 | 1);
}

// builtin_objget
// file vm/builtins.c line 339
static struct _value * builtin_objget(struct _value *o, struct _value *f)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return val_null;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      struct _value *return_value_neko_val_field$2;
      return_value_neko_val_field$2=neko_val_field(o, (signed int)(signed long int)f >> 1);
      return return_value_neko_val_field$2;
    }
}

// builtin_objgetproto
// file vm/builtins.c line 463
static struct _value * builtin_objgetproto(struct _value *o)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    o = (struct _value *)((struct _vobject *)o)->proto;
    if(o == ((struct _value *)NULL))
      return val_null;

    else
      return o;
  }
}

// builtin_objremove
// file vm/builtins.c line 383
static struct _value * builtin_objremove(struct _value *o, struct _value *f)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      signed int return_value_otable_remove$2;
      return_value_otable_remove$2=otable_remove(&((struct _vobject *)o)->table, (signed int)(signed long int)f >> 1);
      return return_value_otable_remove$2 != 0 ? val_true : val_false;
    }
}

// builtin_objset
// file vm/builtins.c line 350
static struct _value * builtin_objset(struct _value *o, struct _value *f, struct _value *v)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return val_null;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      neko_alloc_field(o, (signed int)(signed long int)f >> 1, v);
      return v;
    }
}

// builtin_objsetproto
// file vm/builtins.c line 448
static struct _value * builtin_objsetproto(struct _value *o, struct _value *p)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    if(p == val_null)
      ((struct _vobject *)o)->proto = (struct _vobject *)(void *)0;

    else
    {
      if((1 & (signed int)p) == 0)
        tmp_if_expr$2 = (signed int)*((enum anonymous$7 *)p) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        return (struct _value *)(void *)0;

      ((struct _vobject *)o)->proto = (struct _vobject *)p;
    }
    return val_null;
  }
}

// builtin_pcompare
// file vm/builtins.c line 1166
static struct _value * builtin_pcompare(struct _value *a, struct _value *b)
{
  signed long int ia = (signed long int)a;
  signed long int ib = (signed long int)b;
  if(!(ib >= ia))
    return (struct _value *)(signed long int)((signed int)1 << 1 | 1);

  else
    if(!(ia >= ib))
      return (struct _value *)(signed long int)((signed int)-1 << 1 | 1);

    else
      return (struct _value *)(signed long int)((signed int)0 << 1 | 1);
}

// builtin_print
// file vm/builtins.c line 1062
static struct _value * builtin_print(struct _value **args, signed int nargs)
{
  struct _buffer *b;
  signed int i;
  if(nargs == 1)
  {
    if(!((1 & (signed int)*args) == 0))
      goto __CPROVER_DUMP_L1;

    if(!((15 & (signed int)*((enum anonymous$7 *)*args)) == VAL_STRING))
      goto __CPROVER_DUMP_L1;

    neko_val_print(*args);
    return neko_builtins[(signed long int)1];
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    b=neko_alloc_buffer((const char *)(void *)0);
    i = 0;
    for( ; !(i >= nargs); i = i + 1)
      neko_val_buffer(b, args[(signed long int)i]);
    struct _value *return_value_neko_buffer_to_string$1;
    return_value_neko_buffer_to_string$1=neko_buffer_to_string(b);
    neko_val_print(return_value_neko_buffer_to_string$1);
    return neko_builtins[(signed long int)1];
  }
}

// builtin_rethrow
// file vm/builtins.c line 1089
static struct _value * builtin_rethrow(struct _value *v)
{
  neko_val_rethrow(v);
  return val_null;
}

// builtin_sblit
// file vm/builtins.c line 279
static struct _value * builtin_sblit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l)
{
  signed int dpp;
  signed int spp;
  signed int ll;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)dst) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)dst) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)dp) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)src) == 0)
        tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)src) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        return (struct _value *)(void *)0;

      else
        if((1 & (signed int)sp) == 0)
          return (struct _value *)(void *)0;

        else
          if((1 & (signed int)l) == 0)
            return (struct _value *)(void *)0;

          else
          {
            dpp = (signed int)(signed long int)dp >> 1;
            spp = (signed int)(signed long int)sp >> 1;
            ll = (signed int)(signed long int)l >> 1;
            if(!(dpp + ll >= 0) || !(ll + spp >= 0) || !(dpp >= 0) || !(ll >= 0) || !(spp >= 0))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = dpp + ll > (signed int)*((enum anonymous$7 *)dst) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = spp + ll > (signed int)*((enum anonymous$7 *)src) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$4)
              return (struct _value *)(void *)0;

            else
            {
              memmove((void *)(&((struct anonymous$5 *)dst)->c + (signed long int)dpp), (const void *)(&((struct anonymous$5 *)src)->c + (signed long int)spp), (unsigned long int)ll);
              return val_null;
            }
          }
    }
}

// builtin_scopy
// file vm/builtins.c line 213
static struct _value * builtin_scopy(struct _value *s)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    struct _value *return_value_neko_copy_string$2;
    return_value_neko_copy_string$2=neko_copy_string(&((struct anonymous$5 *)s)->c, (signed long int)((signed int)*((enum anonymous$7 *)s) >> 4));
    return return_value_neko_copy_string$2;
  }
}

// builtin_setresolver
// file vm/builtins.c line 1213
static struct _value * builtin_setresolver(struct _value *f)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(f == val_null)
    vm->resolver = (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)f) == 0)
      tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      if(!(((struct anonymous$8 *)f)->nargs == 2))
        tmp_if_expr$3 = ((struct anonymous$8 *)f)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      return (struct _value *)(void *)0;

    vm->resolver = f;
  }
  return val_null;
}

// builtin_sfind
// file vm/builtins.c line 302
static struct _value * builtin_sfind(struct _value *src, struct _value *pos, struct _value *pat)
{
  signed int p;
  signed int l;
  signed int l2;
  const char *ptr;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)src) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)src) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)pos) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)pat) == 0)
        tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)pat) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        return (struct _value *)(void *)0;

      else
      {
        p = (signed int)(signed long int)pos >> 1;
        l = (signed int)*((enum anonymous$7 *)src) >> 4;
        l2 = (signed int)*((enum anonymous$7 *)pat) >> 4;
        if(p >= l || !(p >= 0))
          return (struct _value *)(void *)0;

        else
        {
          ptr = &((struct anonymous$5 *)src)->c + (signed long int)p;
          while(l + -p >= l2)
          {
            signed int return_value_memcmp$3;
            return_value_memcmp$3=memcmp((const void *)ptr, (const void *)&((struct anonymous$5 *)pat)->c, (unsigned long int)l2);
            if(return_value_memcmp$3 == 0)
              return (struct _value *)(signed long int)((signed int)p << 1 | 1);

            p = p + 1;
            ptr = ptr + 1l;
          }
          return val_null;
        }
      }
    }
}

// builtin_sget
// file vm/builtins.c line 241
static struct _value * builtin_sget(struct _value *s, struct _value *p)
{
  signed int pp;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
    {
      pp = (signed int)(signed long int)p >> 1;
      if(!(pp >= 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = pp >= (signed int)*((enum anonymous$7 *)s) >> 4 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        return val_null;

      else
        return (struct _value *)(signed long int)((signed int)(unsigned char)(&((struct anonymous$5 *)s)->c)[(signed long int)pp] << 1 | 1);
    }
}

// builtin_smake
// file vm/builtins.c line 192
static struct _value * builtin_smake(struct _value *l)
{
  struct _value *v;
  if((1 & (signed int)l) == 0)
    return (struct _value *)(void *)0;

  else
  {
    v=neko_alloc_empty_string((unsigned int)((signed int)(signed long int)l >> 1));
    memset((void *)&((struct anonymous$5 *)v)->c, 0, (unsigned long int)((signed int)(signed long int)l >> 1));
    return v;
  }
}

// builtin_sset
// file vm/builtins.c line 258
static struct _value * builtin_sset(struct _value *s, struct _value *p, struct _value *c)
{
  signed int pp;
  unsigned char cc;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)c) == 0)
        return (struct _value *)(void *)0;

      else
      {
        pp = (signed int)(signed long int)p >> 1;
        if(!(pp >= 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = pp >= (signed int)*((enum anonymous$7 *)s) >> 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return val_null;

        else
        {
          cc = (unsigned char)((signed int)(signed long int)c >> 1);
          (&((struct anonymous$5 *)s)->c)[(signed long int)pp] = (char)cc;
          return (struct _value *)(signed long int)((signed int)cc << 1 | 1);
        }
      }
}

// builtin_ssize
// file vm/builtins.c line 204
static struct _value * builtin_ssize(struct _value *s)
{
  _Bool tmp_if_expr$1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((signed int)*((enum anonymous$7 *)s) >> 4) << 1 | 1);
}

// builtin_ssub
// file vm/builtins.c line 225
static struct _value * builtin_ssub(struct _value *s, struct _value *p, struct _value *l)
{
  signed int pp;
  signed int ll;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)l) == 0)
        return (struct _value *)(void *)0;

      else
      {
        pp = (signed int)(signed long int)p >> 1;
        ll = (signed int)(signed long int)l >> 1;
        if(!(ll + pp >= 0) || !(ll >= 0) || !(pp >= 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = pp + ll > (signed int)*((enum anonymous$7 *)s) >> 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return (struct _value *)(void *)0;

        else
        {
          struct _value *return_value_neko_copy_string$3;
          return_value_neko_copy_string$3=neko_copy_string(&((struct anonymous$5 *)s)->c + (signed long int)pp, (signed long int)ll);
          return return_value_neko_copy_string$3;
        }
      }
}

// builtin_string
// file vm/builtins.c line 182
static struct _value * builtin_string(struct _value *v)
{
  struct _buffer *b;
  b=neko_alloc_buffer((const char *)(void *)0);
  neko_val_buffer(b, v);
  struct _value *return_value_neko_buffer_to_string$1;
  return_value_neko_buffer_to_string$1=neko_buffer_to_string(b);
  return return_value_neko_buffer_to_string$1;
}

// builtin_throw
// file vm/builtins.c line 1080
static struct _value * builtin_throw(struct _value *v)
{
  neko_val_throw(v);
  return val_null;
}

// builtin_typeof
// file vm/builtins.c line 1127
static struct _value * builtin_typeof(struct _value *v)
{
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)v) == 0))
    tmp_if_expr$1 = VAL_INT;

  else
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)v) & (1 << 4) - 1;
  switch(tmp_if_expr$1)
  {
    case VAL_INT:

    case VAL_INT32:
      return (struct _value *)(signed long int)((signed int)1 << 1 | 1);
    case VAL_NULL:
      return (struct _value *)(signed long int)((signed int)0 << 1 | 1);
    case VAL_FLOAT:
      return (struct _value *)(signed long int)((signed int)2 << 1 | 1);
    case VAL_BOOL:
      return (struct _value *)(signed long int)((signed int)3 << 1 | 1);
    case VAL_STRING:
      return (struct _value *)(signed long int)((signed int)4 << 1 | 1);
    case VAL_OBJECT:
      return (struct _value *)(signed long int)((signed int)5 << 1 | 1);
    case VAL_ARRAY:
      return (struct _value *)(signed long int)((signed int)6 << 1 | 1);
    case VAL_FUNCTION:
      return (struct _value *)(signed long int)((signed int)7 << 1 | 1);
    case VAL_ABSTRACT:
      return (struct _value *)(signed long int)((signed int)8 << 1 | 1);
    default:
      return (struct _value *)(void *)0;
  }
}

// builtin_varargs
// file vm/builtins.c line 599
static struct _value * builtin_varargs(struct _value *f)
{
  struct _value *fvar;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(!tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if(!(((struct anonymous$8 *)f)->nargs == 1))
      tmp_if_expr$2 = ((struct anonymous$8 *)f)->nargs != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return (struct _value *)(void *)0;

  else
  {
    fvar=neko_alloc_function((void *)varargs_callback, (unsigned int)-1, "varargs");
    ((struct anonymous$8 *)fvar)->env = f;
    return fvar;
  }
}

// builtin_version
// file vm/builtins.c line 1205
static struct _value * builtin_version()
{
  return (struct _value *)(signed long int)((signed int)200 << 1 | 1);
}

// clean_c_stack
// file vm/threads.c line 103
static signed int clean_c_stack(signed int n, void *f)
{
  char buf[256l];
  memset((void *)buf, n, sizeof(char [256l]) /*256ul*/ );
  if(n == 0)
    return (signed int)buf[0l];

  else
  {
    signed int return_value;
    return_value=((signed int (*)(signed int, void *))f)(n - 1, f);
    return return_value != 0 ? 1 : 0;
  }
}

// close_module
// file vm/load.c line 187
static void close_module(void *p)
{
  fclose((struct _IO_FILE *)p);
}

// closure_callback
// file vm/builtins.c line 502
static struct _value * closure_callback(struct _value **args, signed int nargs)
{
  struct _value *env;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get$1)->env;
  signed int cargs = ((signed int)*((enum anonymous$7 *)env) >> 4) - 2;
  struct _value **a = &((struct anonymous$4 *)env)->ptr;
  struct _value *f = a[(signed long int)0];
  struct _value *o = a[(signed long int)1];
  signed int fargs = ((struct anonymous$8 *)f)->nargs;
  signed int i;
  if(!(fargs == cargs + nargs) && !(fargs == -1))
    return val_null;

  else
  {
    if(nargs == 0)
      a = &((struct anonymous$4 *)env)->ptr + (signed long int)2;

    else
      if(cargs == 0)
        a = args;

      else
      {
        char *return_value_neko_alloc$2;
        return_value_neko_alloc$2=neko_alloc((unsigned int)(sizeof(struct _value *) /*8ul*/  * (unsigned long int)(nargs + cargs)));
        a = (struct _value **)return_value_neko_alloc$2;
        i = 0;
        for( ; !(i >= cargs); i = i + 1)
          a[(signed long int)i] = (&((struct anonymous$4 *)env)->ptr)[(signed long int)(i + 2)];
        i = 0;
        for( ; !(i >= nargs); i = i + 1)
          a[(signed long int)(i + cargs)] = args[(signed long int)i];
      }
    struct _value *return_value_neko_val_callEx$3;
    return_value_neko_val_callEx$3=neko_val_callEx(o, f, a, nargs + cargs, (struct _value **)(void *)0);
    return return_value_neko_val_callEx$3;
  }
}

// cmp
// file vm/stats.c line 133
static signed int cmp(struct _statinfos *a, struct _statinfos *b)
{
  signed int delta = a->totaltime - b->totaltime;
  if(delta == 0)
    return b->ncalls - a->ncalls;

  else
    return delta;
}

// default_printer
// file vm/interp.c line 86
static void default_printer(const char *s, signed int len, void *out)
{
  while(len >= 1)
  {
    signed int p;
    unsigned long int return_value_fwrite$1;
    return_value_fwrite$1=fwrite((const void *)s, (unsigned long int)1, (unsigned long int)len, (struct _IO_FILE *)out);
    p = (signed int)return_value_fwrite$1;
    if(!(p >= 1))
    {
      fputs("[ABORTED]", (struct _IO_FILE *)out);
      break;
    }

    len = len - p;
    s = s + (signed long int)p;
  }
  fflush((struct _IO_FILE *)out);
}

// do_nothing
// file vm/threads.c line 175
static signed int do_nothing(char (*sb)[64l])
{
  return -1;
}

// executable_path
// file vm/main.c line 56
static char * executable_path()
{
  signed int length;
  signed long int return_value_readlink$1;
  static char path[1024l];
  return_value_readlink$1=readlink("/proc/self/exe", path, sizeof(char [1024l]) /*1024ul*/ );
  length = (signed int)return_value_readlink$1;
  if(length >= 1024 || !(length >= 0))
  {
    char *p;
    p=getenv("   ");
    if(p == ((char *)NULL))
      p=getenv("_");

    return p;
  }

  path[(signed long int)length] = (char)0;
  return path;
}

// execute_file
// file vm/main.c line 196
static signed int execute_file(struct _neko_vm *vm, char *file, struct _value *mload)
{
  struct _value *args[2l];
  struct _value *return_value_neko_alloc_string$1;
  return_value_neko_alloc_string$1=neko_alloc_string(file);
  args[0] = return_value_neko_alloc_string$1;
  args[1] = mload;
  struct _value *exc = (struct _value *)(void *)0;
  signed int return_value_neko_val_id$2;
  return_value_neko_val_id$2=neko_val_id("loadmodule");
  struct _value *return_value_neko_val_field$3;
  return_value_neko_val_field$3=neko_val_field(mload, return_value_neko_val_id$2);
  neko_val_callEx(mload, return_value_neko_val_field$3, args, 2, &exc);
  if(!(exc == ((struct _value *)NULL)))
  {
    report(vm, exc, 1);
    return 1;
  }

  else
    return 0;
}

// failure_to_string
// file vm/others.c line 499
static struct _value * failure_to_string()
{
  struct _value *o;
  o=neko_val_this();
  struct _buffer *b;
  b=neko_alloc_buffer((const char *)(void *)0);
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    signed int return_value_neko_val_id$2;
    return_value_neko_val_id$2=neko_val_id("file");
    struct _value *return_value_neko_val_field$3;
    return_value_neko_val_field$3=neko_val_field(o, return_value_neko_val_id$2);
    neko_val_buffer(b, return_value_neko_val_field$3);
    neko_buffer_append(b, "(");
    signed int return_value_neko_val_id$4;
    return_value_neko_val_id$4=neko_val_id("line");
    struct _value *return_value_neko_val_field$5;
    return_value_neko_val_field$5=neko_val_field(o, return_value_neko_val_id$4);
    neko_val_buffer(b, return_value_neko_val_field$5);
    neko_buffer_append(b, ") : ");
    signed int return_value_neko_val_id$6;
    return_value_neko_val_id$6=neko_val_id("msg");
    struct _value *return_value_neko_val_field$7;
    return_value_neko_val_field$7=neko_val_field(o, return_value_neko_val_id$6);
    neko_val_buffer(b, return_value_neko_val_field$7);
    struct _value *return_value_neko_buffer_to_string$8;
    return_value_neko_buffer_to_string$8=neko_buffer_to_string(b);
    return return_value_neko_buffer_to_string$8;
  }
}

// fcmp
// file vm/others.c line 44
static inline signed int fcmp(double a, double b)
{
  return IEEE_FLOAT_EQUAL(a, b) ? 0 : (a < b ? -1 : 1);
}

// get_builtin
// file vm/module.c line 121
static struct _value * get_builtin(struct _neko_module *m, signed int id)
{
  struct _value *f;
  f=neko_val_field(*neko_builtins, id);
  signed int return_value_neko_val_id$2;
  if(f == val_null)
  {
    unsigned int i = (unsigned int)0;
    for( ; !(i >= m->nfields); i = i + 1u)
    {
      return_value_neko_val_id$2=neko_val_id(&((struct anonymous$5 *)m->fields[(signed long int)i])->c);
      if(return_value_neko_val_id$2 == id)
      {
        struct _buffer *b;
        b=neko_alloc_buffer("Builtin not found : ");
        neko_val_buffer(b, m->fields[(signed long int)i]);
        struct _value *return_value_neko_buffer_to_string$1;
        return_value_neko_buffer_to_string$1=neko_buffer_to_string(b);
        _neko_failure(return_value_neko_buffer_to_string$1, "vm/module.c", 129);
      }

    }
    struct _value *return_value_neko_alloc_string$3;
    return_value_neko_alloc_string$3=neko_alloc_string("Builtin not found");
    _neko_failure(return_value_neko_alloc_string$3, "vm/module.c", 131);
  }

  return f;
}

// handle_signal
// file vm/main.c line 214
static void handle_signal(signed int signal)
{
  struct _value *return_value_neko_alloc_string$1;
  return_value_neko_alloc_string$1=neko_alloc_string("Segmentation fault");
  neko_val_throw(return_value_neko_alloc_string$1);
}

// hash_obj_rec
// file vm/hash.c line 106
static void hash_obj_rec(struct _value *v, signed int f, void *_p)
{
  struct vparam *p = (struct vparam *)_p;
  signed int *h = p->h;
  *h = *h * 65599 + (signed int)f;
  hash_rec(v, h, &p->l);
}

// hash_rec
// file vm/hash.c line 39
static void hash_rec(struct _value *v, signed int *h, struct vlist *l)
{
  enum anonymous$7 t;
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)v) == 0))
    tmp_if_expr$1 = VAL_INT;

  else
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)v) & (1 << 4) - 1;
  t = (enum anonymous$7)tmp_if_expr$1;
  switch((signed int)t)
  {
    case VAL_INT:
    {
      *h = *h * 65599 + ((signed int)(signed long int)v >> 1);
      goto __CPROVER_DUMP_L21;
    }
    case VAL_INT32:
    {
      *h = *h * 65599 + ((struct anonymous$26 *)v)->i;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_NULL:
    {
      *h = *h * 19 + 0;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_FLOAT:
    {
      signed int hash_rec$$1$$1$$1$$k = (signed int)sizeof(double) /*8ul*/ ;
      for( ; !(hash_rec$$1$$1$$1$$k == 0); *h = *h * 19 + (signed int)(&((struct anonymous$5 *)v)->c)[(signed long int)hash_rec$$1$$1$$1$$k])
        hash_rec$$1$$1$$1$$k = hash_rec$$1$$1$$1$$k - 1;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_BOOL:
    {
      *h = *h * 19 + (signed int)(v == val_true);
      goto __CPROVER_DUMP_L21;
    }
    case VAL_STRING:
    {
      signed int hash_rec$$1$$1$$2$$k = (signed int)*((enum anonymous$7 *)v) >> 4;
      for( ; !(hash_rec$$1$$1$$2$$k == 0); *h = *h * 19 + (signed int)(&((struct anonymous$5 *)v)->c)[(signed long int)hash_rec$$1$$1$$2$$k])
        hash_rec$$1$$1$$2$$k = hash_rec$$1$$1$$2$$k - 1;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_OBJECT:

    case VAL_ARRAY:
    {
      struct vlist *tmp = l;
      signed int k = 0;
      for( ; !(tmp == ((struct vlist *)NULL)); tmp = tmp->next)
      {
        if(tmp->v == v)
        {
          *h = *h * 19 + k;
          goto __CPROVER_DUMP_L22;
        }

        k = k + 1;
      }
      if((signed int)t == VAL_OBJECT)
      {
        struct vparam p;
        p.h = h;
        p.l.v = v;
        p.l.next = l;
        neko_val_iter_fields(v, hash_obj_rec, (void *)&p);
        v = (struct _value *)((struct _vobject *)v)->proto;
        if(!(v == ((struct _value *)NULL)))
          hash_rec(v, h, &p.l);

      }

      else
      {
        struct vlist cur;
        signed int hash_rec$$1$$1$$5$$k = (signed int)*((enum anonymous$7 *)v) >> 4;
        cur.v = v;
        cur.next = l;
        while(!(hash_rec$$1$$1$$5$$k == 0))
        {
          hash_rec$$1$$1$$5$$k = hash_rec$$1$$1$$5$$k - 1;
          hash_rec((&((struct anonymous$4 *)v)->ptr)[(signed long int)hash_rec$$1$$1$$5$$k], h, &cur);
        }
      }
    }
    default:

      __CPROVER_DUMP_L21:
        ;
  }

__CPROVER_DUMP_L22:
  ;
}

// icmp
// file vm/others.c line 40
static inline signed int icmp(signed int a, signed int b)
{
  return a == b ? 0 : (a < b ? -1 : 1);
}

// init_path
// file vm/load.c line 265
static struct _value * init_path(const char *path)
{
  struct _value *l = val_null;
  struct _value *tmp;
  char *p;
  char *p2;
  char *allocated = (char *)(void *)0;
  if(path == ((const char *)NULL))
  {
    allocated=strdup("/usr/local/lib/neko:/usr/lib/neko:/usr/local/bin:/usr/bin");
    path = allocated;
  }

  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  _Bool tmp_if_expr$7;
  unsigned long int return_value_strlen$6;
  while((_Bool)1)
  {
    if(!(*path == 0))
      tmp_if_expr$1 = (signed int)path[(signed long int)1] == 58 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      p=strchr(path + (signed long int)2, 58);
      p2=strchr(path + (signed long int)2, 59);
    }

    else
    {
      p=strchr(path, 58);
      p2=strchr(path, 59);
    }
    if(p == ((char *)NULL) || !(p2 == ((char *)NULL)) && !(p2 >= p))
      p = p2;

    if(!(p == ((char *)NULL)))
      *p = (char)0;

    tmp=neko_alloc_array((unsigned int)2);
    if(!(p == ((char *)NULL)))
      tmp_if_expr$2 = (signed int)p[(signed long int)-1] != 47 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (signed int)p[(signed long int)-1] != 92 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      if(p == ((char *)NULL))
      {
        return_value_strlen$4=strlen(path);
        tmp_if_expr$5 = (signed int)path[(signed long int)(return_value_strlen$4 - (unsigned long int)1)] != 47 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        return_value_strlen$6=strlen(path);
        tmp_if_expr$7 = (signed int)path[(signed long int)(return_value_strlen$6 - (unsigned long int)1)] != 92 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$7 = (_Bool)0;
      tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
    {
      struct _buffer *b;
      b=neko_alloc_buffer(path);
      char c = (char)47;
      neko_buffer_append_sub(b, &c, (signed long int)1);
      (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)0]=neko_buffer_to_string(b);
    }

    else
      (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)0]=neko_alloc_string(path);
    (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)1] = l;
    l = tmp;
    if(!(p == ((char *)NULL)))
      *p = (char)(p == p2 ? 59 : 58);

    else
      break;
    path = p + (signed long int)1;
  }
  if(!(allocated == ((char *)NULL)))
    free((void *)allocated);

  return l;
}

// jit_run
// file vm/interp.c line 265
static signed long int jit_run(struct _neko_vm *vm, struct anonymous$8 *acc)
{
  struct _neko_module *m = (struct _neko_module *)acc->module;
  signed long int return_value;
  return_value=((signed long int (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, acc->addr, (struct _value *)acc, m);
  return return_value;
}

// load_primitive
// file vm/load.c line 199
static void * load_primitive(const char *prim, signed int nargs, struct _value *path, struct _liblist **libs)
{
  char *pos;
  pos=strchr(prim, 64);
  signed int len;
  struct _liblist *l;
  struct _value * (*ptr)();
  struct _value *return_value;
  char *tmp_post$7;
  if(pos == ((char *)NULL))
    return (void *)0;

  else
  {
    l = *libs;
    *pos = (char)0;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(prim);
    len = (signed int)return_value_strlen$1 + 1;
    while(!(l == ((struct _liblist *)NULL)))
    {
      signed int return_value_memcmp$2;
      return_value_memcmp$2=memcmp((const void *)l->name, (const void *)prim, (unsigned long int)len);
      if(return_value_memcmp$2 == 0)
        break;

      l = l->next;
    }
    if(l == ((struct _liblist *)NULL))
    {
      void *h;
      struct _value *pname;
      pname=neko_select_file(path, prim, ".ndll");
      pname = pname;
      h=dlopen(&((struct anonymous$5 *)pname)->c, 0x00001);
      if(h == NULL)
      {
        struct _buffer *b;
        b=neko_alloc_buffer("Failed to load library : ");
        neko_val_buffer(b, pname);
        neko_buffer_append(b, " (");
        char *return_value_dlerror$3;
        return_value_dlerror$3=dlerror();
        neko_buffer_append(b, return_value_dlerror$3);
        neko_buffer_append(b, ")");
        *pos = (char)64;
        struct _value *return_value_neko_buffer_to_string$4;
        return_value_neko_buffer_to_string$4=neko_buffer_to_string(b);
        _neko_failure(return_value_neko_buffer_to_string$4, "vm/load.c", 237);
      }

      char *return_value_neko_alloc$5;
      return_value_neko_alloc$5=neko_alloc((unsigned int)sizeof(struct _liblist) /*24ul*/ );
      l = (struct _liblist *)return_value_neko_alloc$5;
      l->handle = h;
      l->name=neko_alloc_private((unsigned int)len);
      memcpy((void *)l->name, (const void *)prim, (unsigned long int)len);
      l->next = *libs;
      *libs = l;
      void *return_value_dlsym$6;
      return_value_dlsym$6=dlsym(l->handle, "__neko_entry_point");
      ptr = (struct _value * (*)())return_value_dlsym$6;
      if(!(ptr == ((struct _value * (*)())NULL)))
      {
        return_value=ptr();
        ((struct _value * (*)())return_value)();
      }

    }

    tmp_post$7 = pos;
    pos = pos + 1l;
    *tmp_post$7 = (char)64;
    char buf[100l];
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(pos);
    if(return_value_strlen$8 >= 91ul)
      return (void *)0;

    else
    {
      if(nargs == -1)
        sprintf(buf, "%s__MULT", pos);

      else
        sprintf(buf, "%s__%d", pos, nargs);
      void *return_value_dlsym$9;
      return_value_dlsym$9=dlsym(l->handle, buf);
      ptr = (struct _value * (*)())return_value_dlsym$9;
      if(ptr == ((struct _value * (*)())NULL))
        return (void *)0;

      else
      {
        struct _value *return_value_1;
        return_value_1=ptr();
        return (void *)return_value_1;
      }
    }
  }
}

// loader_loadmodule
// file vm/load.c line 371
static struct _value * loader_loadmodule(struct _value *mname, struct _value *vthis)
{
  struct _value *o;
  o=neko_val_this();
  struct _value *cache;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)mname) == 0)
      tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)mname) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)vthis) == 0)
        tmp_if_expr$3 = (signed int)*((enum anonymous$7 *)vthis) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        return (struct _value *)(void *)0;

      else
      {
        cache=neko_val_field(o, id_cache);
        if((1 & (signed int)cache) == 0)
          tmp_if_expr$4 = (signed int)*((enum anonymous$7 *)cache) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          return (struct _value *)(void *)0;

        else
        {
          signed int (*r)(void *, void *, signed int);
          void *p;
          struct _neko_module *m;
          struct _neko_vm *vm;
          void *return_value_neko_local_get$5;
          return_value_neko_local_get$5=neko_local_get(neko_vm_context);
          vm = (struct _neko_vm *)return_value_neko_local_get$5;
          signed int mid;
          mid=neko_val_id(&((struct anonymous$5 *)mname)->c);
          struct _value *mv;
          mv=neko_val_field(cache, mid);
          if((1 & (signed int)mv) == 0)
          {
            if(!((signed int)*((enum anonymous$7 *)mv) == VAL_ABSTRACT))
              goto __CPROVER_DUMP_L13;

            if(!(((struct anonymous$6 *)mv)->kind == neko_kind_module))
              goto __CPROVER_DUMP_L13;

            m = (struct _neko_module *)((struct anonymous$6 *)mv)->data;
            return m->exports;
          }

          else
          {

          __CPROVER_DUMP_L13:
            ;
            struct _value *return_value_neko_val_field$6;
            return_value_neko_val_field$6=neko_val_field(o, id_path);
            open_module(return_value_neko_val_field$6, &((struct anonymous$5 *)mname)->c, &r, &p);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, "neko_read_module", 1);

            m=neko_read_module(r, p, vthis);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, "neko_read_module", 0);

            close_module(p);
            if(m == ((struct _neko_module *)NULL))
            {
              struct _buffer *b;
              b=neko_alloc_buffer("Invalid module : ");
              neko_val_buffer(b, mname);
              struct _value *return_value_neko_buffer_to_string$7;
              return_value_neko_buffer_to_string$7=neko_buffer_to_string(b);
              _neko_failure(return_value_neko_buffer_to_string$7, "vm/load.c", 398);
            }

            m->name=neko_alloc_string(&((struct anonymous$5 *)mname)->c);
            mv=neko_alloc_abstract(neko_kind_module, (void *)m);
            neko_alloc_field(cache, mid, mv);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, &((struct anonymous$5 *)mname)->c, 1);

            struct _neko_vm *return_value_neko_vm_current$8;
            return_value_neko_vm_current$8=neko_vm_current();
            neko_vm_execute(return_value_neko_vm_current$8, (void *)m);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, &((struct anonymous$5 *)mname)->c, 0);

            return m->exports;
          }
        }
      }
    }
  }
}

// loader_loadprim
// file vm/load.c line 337
static struct _value * loader_loadprim(struct _value *prim, struct _value *nargs)
{
  struct _value *o;
  o=neko_val_this();
  struct _value *libs;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$1)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)prim) == 0)
      tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)prim) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)nargs) == 0)
        return (struct _value *)(void *)0;

      else
      {
        libs=neko_val_field(o, id_loader_libs);
        if((1 & (signed int)libs) == 0)
          tmp_if_expr$3 = (signed int)*((enum anonymous$7 *)libs) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = ((struct anonymous$6 *)libs)->kind == k_loader_libs ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          return (struct _value *)(void *)0;

        else
          if((signed int)nargs >> 1 >= 10 || !((signed int)nargs >> 1 >= -1))
            return (struct _value *)(void *)0;

          else
          {
            struct _neko_vm *vm;
            void *return_value_neko_local_get$5;
            return_value_neko_local_get$5=neko_local_get(neko_vm_context);
            vm = (struct _neko_vm *)return_value_neko_local_get$5;
            void *ptr;
            struct _value *return_value_neko_val_field$6;
            return_value_neko_val_field$6=neko_val_field(o, id_path);
            ptr=load_primitive(&((struct anonymous$5 *)prim)->c, (signed int)(signed long int)nargs >> 1, return_value_neko_val_field$6, (struct _liblist **)(void *)&((struct anonymous$6 *)libs)->data);
            struct anonymous$8 *f;
            if(ptr == NULL)
            {
              struct _buffer *b;
              b=neko_alloc_buffer("Primitive not found : ");
              neko_val_buffer(b, prim);
              neko_buffer_append(b, "(");
              neko_val_buffer(b, nargs);
              neko_buffer_append(b, ")");
              struct _value *return_value_neko_buffer_to_string$7;
              return_value_neko_buffer_to_string$7=neko_buffer_to_string(b);
              _neko_failure(return_value_neko_buffer_to_string$7, "vm/load.c", 357);
            }

            struct _value *return_value_neko_copy_string$8;
            return_value_neko_copy_string$8=neko_copy_string(&((struct anonymous$5 *)prim)->c, (signed long int)((signed int)*((enum anonymous$7 *)prim) >> 4));
            struct _value *return_value_neko_alloc_function$9;
            return_value_neko_alloc_function$9=neko_alloc_function(ptr, (unsigned int)((signed int)(signed long int)nargs >> 1), &((struct anonymous$5 *)return_value_neko_copy_string$8)->c);
            f = (struct anonymous$8 *)return_value_neko_alloc_function$9;
            if(!(vm->pstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
            {
              if(!((signed int)nargs >> 1 >= 7))
              {
                struct _value *env;
                env=neko_alloc_array((unsigned int)2);
                (&((struct anonymous$4 *)env)->ptr)[(signed long int)0] = (struct _value *)f->module;
                (&((struct anonymous$4 *)env)->ptr)[(signed long int)1] = (struct _value *)((signed long int)f->addr | (signed long int)1);
                f->addr = (void *)stats_proxy;
                f->env = env;
              }

            }

            return (struct _value *)f;
          }
      }
  }
}

// main
// file vm/main.c line 219
signed int main(signed int argc, char **argv)
{
  struct _neko_vm *vm;
  struct _value *mload;
  signed int r;
  neko_global_init();
  vm=neko_vm_alloc((void *)0);
  neko_vm_select(vm);
  signed int return_value_neko_has_embedded_module$7;
  return_value_neko_has_embedded_module$7=neko_has_embedded_module(vm);
  unsigned long int return_value_strlen$5;
  if(return_value_neko_has_embedded_module$7 == 0)
  {
    signed int jit = 1;
    signed int stats = 0;
    while(argc >= 2)
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(argv[(signed long int)1], "-interp");
      if(return_value_strcmp$1 == 0)
      {
        argc = argc - 1;
        argv = argv + 1l;
        jit = 0;
      }

      else
      {
        signed int return_value_strcmp$2;
        return_value_strcmp$2=strcmp(argv[(signed long int)1], "-stats");
        if(return_value_strcmp$2 == 0)
        {
          argc = argc - 1;
          argv = argv + 1l;
          stats = 1;
          neko_vm_set_stats(vm, neko_stats_measure, neko_stats_measure);
          neko_stats_measure(vm, "total", 1);
        }

        else
        {
          signed int return_value_strcmp$3;
          return_value_strcmp$3=strcmp(argv[(signed long int)1], "-version");
          if(return_value_strcmp$3 == 0)
          {
            argc = argc - 1;
            argv = argv + 1l;
            printf("%d.%d.%d", 200 / 100, (200 / 10) % 10, 200 % 10);
            return 0;
          }

          break;
        }
      }
    }
    if(!(jit == 0))
    {
      struct sigaction act;
      act.__sigaction_handler.sa_sigaction = (void (*)(signed int, struct anonymous$19 *, void *))(void *)0;
      act.__sigaction_handler.sa_handler = handle_signal;
      act.sa_flags = 0;
      sigemptyset(&act.sa_mask);
      sigaction(11, &act, (struct sigaction *)(void *)0);
    }

    neko_vm_jit(vm, jit);
    if(argc == 1)
    {
      printf("NekoVM %d.%d.%d (c)2005-2013 Haxe Foundation\n  Usage : neko <file>\n", 200 / 100, (200 / 10) % 10, 200 % 10);
      mload = (struct _value *)(void *)0;
      r = 1;
    }

    else
    {
      mload=neko_default_loader(argv + (signed long int)2, argc - 2);
      r=execute_file(vm, argv[(signed long int)1], mload);
    }
    if(!(stats == 0))
    {
      struct _value *v;
      neko_stats_measure(vm, "total", 0);
      v=neko_stats_build(vm);
      struct _value *return_value_neko_alloc_string$4;
      return_value_neko_alloc_string$4=neko_alloc_string("TOT\tTIME\tCOUNT\tNAME\n");
      neko_val_print(return_value_neko_alloc_string$4);
      while(!(v == val_null))
      {
        char buf[256l];
        struct _value **s = &((struct anonymous$4 *)v)->ptr;
        signed int errors = (signed int)(signed long int)s[(signed long int)4] >> 1;
        sprintf(buf, "%d\t%d\t%d\t%s%c", (signed int)(signed long int)s[(signed long int)1] >> 1, (signed int)(signed long int)s[(signed long int)2] >> 1, (signed int)(signed long int)s[(signed long int)3] >> 1, &((struct anonymous$5 *)s[(signed long int)0])->c, errors != 0 ? 32 : 10);
        if(!(errors == 0))
        {
          return_value_strlen$5=strlen(buf);
          sprintf(buf + (signed long int)return_value_strlen$5, "ERRORS=%d\n", errors);
        }

        struct _value *return_value_neko_alloc_string$6;
        return_value_neko_alloc_string$6=neko_alloc_string(buf);
        neko_val_print(return_value_neko_alloc_string$6);
        v = s[(signed long int)5];
      }
    }

  }

  else
  {
    mload=neko_default_loader(argv + (signed long int)1, argc - 1);
    r=neko_execute_self(vm, mload);
  }
  signed int return_value_neko_val_id$9;
  struct _value *return_value_neko_val_field$10;
  signed int return_value_neko_val_id$8;
  if(!(mload == ((struct _value *)NULL)))
  {
    return_value_neko_val_id$9=neko_val_id("dump_prof");
    return_value_neko_val_field$10=neko_val_field(mload, return_value_neko_val_id$9);
    if(!(return_value_neko_val_field$10 == val_null))
    {
      return_value_neko_val_id$8=neko_val_id("dump_prof");
      neko_val_ocall0(mload, return_value_neko_val_id$8);
    }

  }

  vm = (struct _neko_vm *)(void *)0;
  mload = (struct _value *)(void *)0;
  neko_vm_select((struct _neko_vm *)(void *)0);
  neko_global_free();
  return r;
}

// neko_alloc
// file vm/alloc.c line 164
char * neko_alloc(unsigned int nbytes)
{
  void *tmp_if_expr$3;
  void *return_value_GC_malloc_ignore_off_page$1;
  void *return_value_GC_malloc$2;
  if(nbytes >= 257u)
  {
    return_value_GC_malloc_ignore_off_page$1=GC_malloc_ignore_off_page((unsigned long int)nbytes);
    tmp_if_expr$3 = return_value_GC_malloc_ignore_off_page$1;
  }

  else
  {
    return_value_GC_malloc$2=GC_malloc((unsigned long int)nbytes);
    tmp_if_expr$3 = return_value_GC_malloc$2;
  }
  return (char *)tmp_if_expr$3;
}

// neko_alloc_abstract
// file vm/alloc.c line 215
struct _value * neko_alloc_abstract(struct anonymous *k, void *data)
{
  struct anonymous$6 *v;
  void *return_value_GC_malloc$1;
  return_value_GC_malloc$1=GC_malloc(sizeof(struct anonymous$6) /*24ul*/ );
  v = (struct anonymous$6 *)return_value_GC_malloc$1;
  v->t = (enum anonymous$7)VAL_ABSTRACT;
  v->kind = k;
  v->data = data;
  return (struct _value *)v;
}

// neko_alloc_apply
// file vm/alloc.c line 299
extern struct _value * neko_alloc_apply(signed int nargs, struct _value *env)
{
  struct anonymous$8 *v;
  void *return_value_GC_malloc$1;
  return_value_GC_malloc$1=GC_malloc(sizeof(struct anonymous$8) /*32ul*/ );
  v = (struct anonymous$8 *)return_value_GC_malloc$1;
  v->t = (enum anonymous$7)VAL_PRIMITIVE;
  struct _value *return_value_neko_alloc_string$2;
  switch(nargs)
  {
    case 1:
    {
      v->addr = (void *)apply1;
      break;
    }
    case 2:
    {
      v->addr = (void *)apply2;
      break;
    }
    case 3:
    {
      v->addr = (void *)apply3;
      break;
    }
    case 4:
    {
      v->addr = (void *)apply4;
      break;
    }
    case 5:
    {
      v->addr = (void *)apply5;
      break;
    }
    default:
    {
      return_value_neko_alloc_string$2=neko_alloc_string("Too many apply arguments");
      _neko_failure(return_value_neko_alloc_string$2, "vm/alloc.c", 308);
    }
  }
  v->nargs = nargs;
  v->env = env;
  v->module = (void *)*apply_string;
  return (struct _value *)v;
}

// neko_alloc_array
// file vm/neko.h line 400
struct _value * neko_alloc_array(unsigned int n)
{
  struct _value *v;
  struct _value *return_value_neko_alloc_string$1;
  void *tmp_if_expr$4;
  void *return_value_GC_malloc_ignore_off_page$2;
  void *return_value_GC_malloc$3;
  if(n == 0u)
    return (struct _value *)(void *)&empty_array;

  else
  {
    if(n >= 268435456u)
    {
      return_value_neko_alloc_string$1=neko_alloc_string("max_array_size reached");
      _neko_failure(return_value_neko_alloc_string$1, "vm/alloc.c", 209);
    }

    if(sizeof(struct _value *) /*8ul*/  * (unsigned long int)(n + 4294967295u) + sizeof(struct anonymous$4) /*16ul*/  >= 257ul)
    {
      return_value_GC_malloc_ignore_off_page$2=GC_malloc_ignore_off_page(sizeof(struct anonymous$4) /*16ul*/  + (unsigned long int)(n - (unsigned int)1) * sizeof(struct _value *) /*8ul*/ );
      tmp_if_expr$4 = return_value_GC_malloc_ignore_off_page$2;
    }

    else
    {
      return_value_GC_malloc$3=GC_malloc(sizeof(struct anonymous$4) /*16ul*/  + (unsigned long int)(n - (unsigned int)1) * sizeof(struct _value *) /*8ul*/ );
      tmp_if_expr$4 = return_value_GC_malloc$3;
    }
    v = (struct _value *)tmp_if_expr$4;
    v->t = (enum anonymous$7)((unsigned int)VAL_ARRAY | n << 4);
    return v;
  }
}

// neko_alloc_buffer
// file vm/neko.h line 420
struct _buffer * neko_alloc_buffer(const char *init)
{
  struct _buffer *b;
  char *return_value_neko_alloc$1;
  return_value_neko_alloc$1=neko_alloc((unsigned int)sizeof(struct _buffer) /*16ul*/ );
  b = (struct _buffer *)return_value_neko_alloc$1;
  b->totlen = 0;
  b->blen = 16;
  b->data = (struct _stringitem *)(void *)0;
  if(!(init == ((const char *)NULL)))
    neko_buffer_append(b, init);

  return b;
}

// neko_alloc_empty_string
// file vm/alloc.c line 172
struct _value * neko_alloc_empty_string(unsigned int size)
{
  struct anonymous$5 *s;
  struct _value *return_value_neko_alloc_string$1;
  void *tmp_if_expr$4;
  void *return_value_GC_malloc_atomic_ignore_off_page$2;
  void *return_value_GC_malloc_atomic$3;
  if(size == 0u)
    return (struct _value *)&empty_string;

  else
  {
    if(size >= 268435456u)
    {
      return_value_neko_alloc_string$1=neko_alloc_string("max_string_size reached");
      _neko_failure(return_value_neko_alloc_string$1, "vm/alloc.c", 177);
    }

    if(sizeof(struct anonymous$5) /*8ul*/  + (unsigned long int)size >= 257ul)
    {
      return_value_GC_malloc_atomic_ignore_off_page$2=GC_malloc_atomic_ignore_off_page((unsigned long int)size + sizeof(struct anonymous$5) /*8ul*/ );
      tmp_if_expr$4 = return_value_GC_malloc_atomic_ignore_off_page$2;
    }

    else
    {
      return_value_GC_malloc_atomic$3=GC_malloc_atomic((unsigned long int)size + sizeof(struct anonymous$5) /*8ul*/ );
      tmp_if_expr$4 = return_value_GC_malloc_atomic$3;
    }
    s = (struct anonymous$5 *)tmp_if_expr$4;
    s->t = (enum anonymous$7)((unsigned int)VAL_STRING | size << 4);
    (&s->c)[(signed long int)size] = (char)0;
    return (struct _value *)s;
  }
}

// neko_alloc_field
// file vm/neko.h line 396
void neko_alloc_field(struct _value *obj, signed int f, struct _value *v)
{
  otable_replace(&((struct _vobject *)obj)->table, f, v);
}

// neko_alloc_float
// file vm/alloc.c line 190
struct _value * neko_alloc_float(double f)
{
  struct anonymous$25 *v;
  void *return_value_GC_malloc_atomic$1;
  return_value_GC_malloc_atomic$1=GC_malloc_atomic(sizeof(struct anonymous$25) /*12ul*/ );
  v = (struct anonymous$25 *)return_value_GC_malloc_atomic$1;
  v->t = (enum anonymous$7)VAL_FLOAT;
  v->f = f;
  return (struct _value *)v;
}

// neko_alloc_function
// file vm/neko.h line 418
struct _value * neko_alloc_function(void *c_prim, unsigned int nargs, const char *name)
{
  struct anonymous$8 *v;
  struct _value *return_value_neko_alloc_string$1;
  if(c_prim == NULL)
  {
    return_value_neko_alloc_string$1=neko_alloc_string("alloc_function");
    _neko_failure(return_value_neko_alloc_string$1, "vm/alloc.c", 226);
  }

  void *return_value_GC_malloc$2;
  return_value_GC_malloc$2=GC_malloc(sizeof(struct anonymous$8) /*32ul*/ );
  v = (struct anonymous$8 *)return_value_GC_malloc$2;
  v->t = (enum anonymous$7)VAL_PRIMITIVE;
  v->addr = c_prim;
  v->nargs = (signed int)nargs;
  v->env=neko_alloc_array((unsigned int)0);
  struct _value *return_value_neko_alloc_string$3;
  return_value_neko_alloc_string$3=neko_alloc_string(name);
  v->module = (void *)return_value_neko_alloc_string$3;
  return (struct _value *)v;
}

// neko_alloc_int32
// file vm/alloc.c line 197
struct _value * neko_alloc_int32(signed int i)
{
  struct anonymous$26 *v;
  void *return_value_GC_malloc_atomic$1;
  return_value_GC_malloc_atomic$1=GC_malloc_atomic(sizeof(struct anonymous$26) /*8ul*/ );
  v = (struct anonymous$26 *)return_value_GC_malloc_atomic$1;
  v->t = (enum anonymous$7)VAL_INT32;
  v->i = i;
  return (struct _value *)v;
}

// neko_alloc_local
// file vm/neko.h line 438
struct _mt_local * neko_alloc_local()
{
  struct _mt_local *l;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _mt_local) /*4ul*/ );
  l = (struct _mt_local *)return_value_malloc$1;
  pthread_key_create(&l->key, (void (*)(void *))(void *)0);
  return l;
}

// neko_alloc_lock
// file vm/neko.h line 443
struct _mt_lock * neko_alloc_lock()
{
  struct _mt_lock *l;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _mt_lock) /*40ul*/ );
  l = (struct _mt_lock *)return_value_malloc$1;
  union anonymous$21 a;
  pthread_mutexattr_init(&a);
  pthread_mutexattr_settype(&a, 1);
  pthread_mutex_init(&l->lock, &a);
  pthread_mutexattr_destroy(&a);
  return l;
}

// neko_alloc_module_function
// file vm/alloc.c line 236
struct _value * neko_alloc_module_function(void *m, signed long int pos, signed int nargs)
{
  struct anonymous$8 *v;
  struct _value *return_value_neko_alloc_string$1;
  if(!(nargs == -1) && !(nargs >= 0))
  {
    return_value_neko_alloc_string$1=neko_alloc_string("alloc_module_function");
    _neko_failure(return_value_neko_alloc_string$1, "vm/alloc.c", 239);
  }

  void *return_value_GC_malloc$2;
  return_value_GC_malloc$2=GC_malloc(sizeof(struct anonymous$8) /*32ul*/ );
  v = (struct anonymous$8 *)return_value_GC_malloc$2;
  v->t = (enum anonymous$7)VAL_FUNCTION;
  v->addr = (void *)pos;
  v->nargs = nargs;
  v->env=neko_alloc_array((unsigned int)0);
  v->module = m;
  return (struct _value *)v;
}

// neko_alloc_object
// file vm/alloc.c line 316
struct _value * neko_alloc_object(struct _value *cpy)
{
  struct _vobject *v;
  _Bool tmp_if_expr$2;
  struct _value *return_value_neko_alloc_string$1;
  if(!(cpy == ((struct _value *)NULL)) && !(cpy == val_null))
  {
    if((1 & (signed int)cpy) == 0)
      tmp_if_expr$2 = (signed int)*((enum anonymous$7 *)cpy) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
    {
      return_value_neko_alloc_string$1=neko_alloc_string("$new");
      neko_val_throw(return_value_neko_alloc_string$1);
    }

  }

  void *return_value_GC_malloc$3;
  return_value_GC_malloc$3=GC_malloc(sizeof(struct _vobject) /*32ul*/ );
  v = (struct _vobject *)return_value_GC_malloc$3;
  v->t = (enum anonymous$7)VAL_OBJECT;
  if(cpy == ((struct _value *)NULL) || cpy == val_null)
  {
    v->proto = (struct _vobject *)(void *)0;
    otable_init(&v->table);
  }

  else
  {
    v->proto = ((struct _vobject *)cpy)->proto;
    otable_copy(&((struct _vobject *)cpy)->table, &v->table);
  }
  return (struct _value *)v;
}

// neko_alloc_private
// file vm/alloc.c line 168
char * neko_alloc_private(unsigned int nbytes)
{
  void *tmp_if_expr$3;
  void *return_value_GC_malloc_atomic_ignore_off_page$1;
  void *return_value_GC_malloc_atomic$2;
  if(nbytes >= 257u)
  {
    return_value_GC_malloc_atomic_ignore_off_page$1=GC_malloc_atomic_ignore_off_page((unsigned long int)nbytes);
    tmp_if_expr$3 = return_value_GC_malloc_atomic_ignore_off_page$1;
  }

  else
  {
    return_value_GC_malloc_atomic$2=GC_malloc_atomic((unsigned long int)nbytes);
    tmp_if_expr$3 = return_value_GC_malloc_atomic$2;
  }
  return (char *)tmp_if_expr$3;
}

// neko_alloc_root
// file vm/alloc.c line 357
struct _value ** neko_alloc_root(unsigned int nvals)
{
  void *return_value_GC_malloc_uncollectable$1;
  return_value_GC_malloc_uncollectable$1=GC_malloc_uncollectable((unsigned long int)nvals * sizeof(struct _value *) /*8ul*/ );
  return (struct _value **)return_value_GC_malloc_uncollectable$1;
}

// neko_alloc_string
// file vm/neko.h line 388
struct _value * neko_alloc_string(const char *str)
{
  if(str == ((const char *)NULL))
    return val_null;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    struct _value *return_value_neko_copy_string$2;
    return_value_neko_copy_string$2=neko_copy_string(str, (signed long int)return_value_strlen$1);
    return return_value_neko_copy_string$2;
  }
}

// neko_append_int
// file vm/others.c line 323
struct _value * neko_append_int(struct _neko_vm *vm, struct _value *str, signed int x, signed int way)
{
  signed int len;
  signed int len2;
  struct _value *v;
  len = (signed int)*((enum anonymous$7 *)str) >> 4;
  len2=sprintf(vm->tmp, "%d", x);
  v=neko_alloc_empty_string((unsigned int)(len + len2));
  if(!(way == 0))
  {
    memcpy((void *)(char *)&((struct anonymous$5 *)v)->c, (const void *)&((struct anonymous$5 *)str)->c, (unsigned long int)len);
    memcpy((void *)((char *)&((struct anonymous$5 *)v)->c + (signed long int)len), (const void *)vm->tmp, (unsigned long int)(len2 + 1));
  }

  else
  {
    memcpy((void *)(char *)&((struct anonymous$5 *)v)->c, (const void *)vm->tmp, (unsigned long int)len2);
    memcpy((void *)((char *)&((struct anonymous$5 *)v)->c + (signed long int)len2), (const void *)&((struct anonymous$5 *)str)->c, (unsigned long int)(len + 1));
  }
  return v;
}

// neko_append_strings
// file vm/others.c line 339
struct _value * neko_append_strings(struct _value *s1, struct _value *s2)
{
  signed int len1 = (signed int)*((enum anonymous$7 *)s1) >> 4;
  signed int len2 = (signed int)*((enum anonymous$7 *)s2) >> 4;
  struct _value *v;
  v=neko_alloc_empty_string((unsigned int)(len1 + len2));
  memcpy((void *)(char *)&((struct anonymous$5 *)v)->c, (const void *)&((struct anonymous$5 *)s1)->c, (unsigned long int)len1);
  memcpy((void *)((char *)&((struct anonymous$5 *)v)->c + (signed long int)len1), (const void *)&((struct anonymous$5 *)s2)->c, (unsigned long int)(len2 + 1));
  return v;
}

// neko_buffer_append
// file vm/neko.h line 421
void neko_buffer_append(struct _buffer *b, const char *s)
{
  if(!(s == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(s);
    neko_buffer_append_sub(b, s, (signed long int)return_value_strlen$1);
  }

}

// neko_buffer_append_char
// file vm/neko.h line 423
void neko_buffer_append_char(struct _buffer *b, char c)
{
  struct _stringitem *it;
  b->totlen = b->totlen + 1;
  it = b->data;
  signed int tmp_post$1;
  if(!(it == ((struct _stringitem *)NULL)))
  {
    if(it->len == it->size)
      goto __CPROVER_DUMP_L1;

    tmp_post$1 = it->len;
    it->len = it->len + 1;
    it->str[(signed long int)tmp_post$1] = c;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    buffer_append_new(b, &c, 1);
  }
}

// neko_buffer_append_sub
// file vm/neko.h line 422
void neko_buffer_append_sub(struct _buffer *b, const char *s, signed long int _len)
{
  struct _stringitem *it;
  signed int len = (signed int)_len;
  if(!(s == ((const char *)NULL)) && len >= 1)
  {
    b->totlen = b->totlen + len;
    it = b->data;
    if(!(it == ((struct _stringitem *)NULL)))
    {
      signed int neko_buffer_append_sub$$1$$1$$free = it->size - it->len;
      if(neko_buffer_append_sub$$1$$1$$free >= len)
      {
        memcpy((void *)(it->str + (signed long int)it->len), (const void *)s, (unsigned long int)len);
        it->len = it->len + len;
        goto __CPROVER_DUMP_L5;
      }

      else
      {
        memcpy((void *)(it->str + (signed long int)it->len), (const void *)s, (unsigned long int)neko_buffer_append_sub$$1$$1$$free);
        it->len = it->len + neko_buffer_append_sub$$1$$1$$free;
        s = s + (signed long int)neko_buffer_append_sub$$1$$1$$free;
        len = len - neko_buffer_append_sub$$1$$1$$free;
      }
    }

    buffer_append_new(b, s, len);
  }


__CPROVER_DUMP_L5:
  ;
}

// neko_buffer_to_string
// file vm/neko.h line 424
struct _value * neko_buffer_to_string(struct _buffer *b)
{
  struct _value *v;
  v=neko_alloc_empty_string((unsigned int)b->totlen);
  struct _stringitem *it = b->data;
  char *s = (char *)&((struct anonymous$5 *)v)->c + (signed long int)b->totlen;
  while(!(it == ((struct _stringitem *)NULL)))
  {
    struct _stringitem *tmp;
    s = s - (signed long int)it->len;
    memcpy((void *)s, (const void *)it->str, (unsigned long int)it->len);
    tmp = it->next;
    it = tmp;
  }
  return v;
}

// neko_call_stack
// file vm/neko_vm.h line 47
struct _value * neko_call_stack(struct _neko_vm *vm)
{
  struct _value *return_value_neko_flush_stack$1;
  return_value_neko_flush_stack$1=neko_flush_stack(vm->csp, vm->spmin - (signed long int)1, (struct _value *)(void *)0);
  return return_value_neko_flush_stack$1;
}

// neko_can_jit
// file vm/jit_x86.c line 2778
signed int neko_can_jit()
{
  return 0;
}

// neko_check_stack
// file vm/module.c line 138
static signed int neko_check_stack(struct _neko_module *m, unsigned char *tmp, unsigned int i, signed int stack, signed int istack)
{
  unsigned int itmp;
  _Bool tmp_if_expr$3;
  while((_Bool)1)
  {
    signed int c = (signed int)m->code[(signed long int)i];
    signed int s = stack_table[(signed long int)c];
    if(tmp[(signed long int)i] == 255)
      tmp[(signed long int)i] = (unsigned char)stack;

    else
      if(!((signed int)tmp[(signed long int)i] == stack))
        return 0;

      else
        return 1;
    if(s == 0xFF)
      stack = stack + (signed int)m->code[(signed long int)(i + (unsigned int)1)];

    else
      if(s == -255)
        stack = stack - (signed int)m->code[(signed long int)(i + (unsigned int)1)];

      else
        stack = stack + s;
    if(stack >= 128 || !(stack >= istack))
      return 0;

    switch(c)
    {
      case 23:

      case 24:

      case 25:

      case 26:
      {
        itmp = (unsigned int)(signed int)((signed long int *)m->code[(signed long int)(i + (unsigned int)1)] - m->code);
        if(tmp[(signed long int)itmp] == 255)
        {
          if(c == 26)
            stack = stack - s;

          signed int return_value_neko_check_stack$1;
          return_value_neko_check_stack$1=neko_check_stack(m, tmp, itmp, stack, istack);
          if(return_value_neko_check_stack$1 == 0)
            return 0;

          if(c == 26)
            stack = stack + s;

        }

        else
          if(!((signed int)tmp[(signed long int)itmp] == stack))
            return 0;

        if(c == 23)
          return 1;

        goto __CPROVER_DUMP_L37;
      }
      case 56:
      {
        itmp = (unsigned int)(signed int)m->code[(signed long int)(i + (unsigned int)1)];
        i = i + itmp;
        while(itmp >= 1u)
        {
          itmp = itmp - (unsigned int)2;
          if(!(m->code[(signed long int)(i + -itmp)] == 23l))
            return 0;

          signed int return_value_neko_check_stack$2;
          return_value_neko_check_stack$2=neko_check_stack(m, tmp, i - itmp, stack, istack);
          if(return_value_neko_check_stack$2 == 0)
            return 0;

        }
        goto __CPROVER_DUMP_L37;
      }
      case 5:

      case 12:
      {
        if(m->code[(signed long int)(1u + i)] >= (signed long int)stack)
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 58:
      {
        if(!(stack >= 1))
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 59:
      {
        if(!(stack >= 2))
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 67:
      {
        if(!(stack == 0))
          return 0;

        return 1;
      }
      case 28:
      {
        if(!(m->code[(signed long int)(1u + i)] == (signed long int)stack))
          return 0;

        return 1;
      }
      case 22:
      {
        stack = stack - 1;
        if(!(stack >= istack))
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 63:
      {
        if(!((signed long int)stack + -(7l & m->code[(signed long int)(1u + i)]) >= (signed long int)istack))
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = m->code[(signed long int)(i + (unsigned int)1)] >> 3 != (signed long int)stack ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
          return 0;

        return 1;
      }
      default:
      {

      __CPROVER_DUMP_L37:
        ;
        i = i + (unsigned int)(parameter_table[(signed long int)c] != 0 ? 2 : 1);
      }
    }
  }
  return 1;
}

// neko_copy_string
// file vm/alloc.c line 333
struct _value * neko_copy_string(const char *str, signed long int strlen)
{
  struct _value *v;
  v=neko_alloc_empty_string((unsigned int)strlen);
  char *c = (char *)&((struct anonymous$5 *)v)->c;
  memcpy((void *)c, (const void *)str, (unsigned long int)strlen);
  return v;
}

// neko_default_loader
// file vm/neko_vm.h line 54
struct _value * neko_default_loader(char **argv, signed int argc)
{
  struct _value *o;
  o=neko_alloc_object((struct _value *)(void *)0);
  struct _value *args;
  args=neko_alloc_array((unsigned int)argc);
  signed int i = 0;
  for( ; !(i >= argc); i = i + 1)
    (&((struct anonymous$4 *)args)->ptr)[(signed long int)i]=neko_alloc_string(argv[(signed long int)i]);
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("NEKOPATH");
  struct _value *return_value_init_path$2;
  return_value_init_path$2=init_path(return_value_getenv$1);
  neko_alloc_field(o, id_path, return_value_init_path$2);
  struct _value *return_value_neko_alloc_object$3;
  return_value_neko_alloc_object$3=neko_alloc_object((struct _value *)(void *)0);
  neko_alloc_field(o, id_cache, return_value_neko_alloc_object$3);
  struct _value *return_value_neko_alloc_abstract$4;
  return_value_neko_alloc_abstract$4=neko_alloc_abstract(k_loader_libs, (void *)0);
  neko_alloc_field(o, id_loader_libs, return_value_neko_alloc_abstract$4);
  signed int return_value_neko_val_id$5;
  return_value_neko_val_id$5=neko_val_id("args");
  neko_alloc_field(o, return_value_neko_val_id$5, args);
  signed int return_value_neko_val_id$6;
  return_value_neko_val_id$6=neko_val_id("loadprim");
  struct _value *return_value_neko_alloc_function$7;
  return_value_neko_alloc_function$7=neko_alloc_function((void *)loader_loadprim, (unsigned int)2, "loadprim");
  neko_alloc_field(o, return_value_neko_val_id$6, return_value_neko_alloc_function$7);
  signed int return_value_neko_val_id$8;
  return_value_neko_val_id$8=neko_val_id("loadmodule");
  struct _value *return_value_neko_alloc_function$9;
  return_value_neko_alloc_function$9=neko_alloc_function((void *)loader_loadmodule, (unsigned int)2, "loadmodule");
  neko_alloc_field(o, return_value_neko_val_id$8, return_value_neko_alloc_function$9);
  return o;
}

// neko_exc_stack
// file vm/neko_vm.h line 46
struct _value * neko_exc_stack(struct _neko_vm *vm)
{
  return vm->exc_stack;
}

// neko_execute_self
// file vm/main.c line 165
signed int neko_execute_self(struct _neko_vm *vm, struct _value *mload)
{
  struct _value *args[2l];
  struct _value *return_value_neko_alloc_string$1;
  return_value_neko_alloc_string$1=neko_alloc_string("std@module_read");
  args[0] = return_value_neko_alloc_string$1;
  args[1] = (struct _value *)(signed long int)((signed int)2 << 1 | 1);
  struct _value *args2[2l];
  struct _value *return_value_neko_alloc_string$2;
  return_value_neko_alloc_string$2=neko_alloc_string("std@module_exec");
  args2[0] = return_value_neko_alloc_string$2;
  args2[1] = (struct _value *)(signed long int)((signed int)1 << 1 | 1);
  struct _value *args3[2l];
  struct _value *return_value_neko_alloc_function$3;
  return_value_neko_alloc_function$3=neko_alloc_function((void *)read_bytecode, (unsigned int)3, "boot_read_bytecode");
  args3[0] = return_value_neko_alloc_function$3;
  args3[1] = mload;
  struct _value *exc = (struct _value *)(void *)0;
  struct _value *module_read;
  struct _value *module_exec;
  struct _value *module_val;
  signed int return_value_neko_val_id$4;
  return_value_neko_val_id$4=neko_val_id("loadprim");
  struct _value *return_value_neko_val_field$5;
  return_value_neko_val_field$5=neko_val_field(mload, return_value_neko_val_id$4);
  module_read=neko_val_callEx(mload, return_value_neko_val_field$5, args, 2, &exc);
  if(!(exc == ((struct _value *)NULL)))
  {
    report(vm, exc, 1);
    return 1;
  }

  else
  {
    signed int return_value_neko_val_id$6;
    return_value_neko_val_id$6=neko_val_id("loadprim");
    struct _value *return_value_neko_val_field$7;
    return_value_neko_val_field$7=neko_val_field(mload, return_value_neko_val_id$6);
    module_exec=neko_val_callEx(mload, return_value_neko_val_field$7, args2, 2, &exc);
    if(!(exc == ((struct _value *)NULL)))
    {
      report(vm, exc, 1);
      return 1;
    }

    else
    {
      module_val=neko_val_callEx(val_null, module_read, args3, 2, &exc);
      fclose(self);
      if(!(exc == ((struct _value *)NULL)))
      {
        report(vm, exc, 1);
        return 1;
      }

      else
      {
        signed int return_value_neko_val_id$8;
        return_value_neko_val_id$8=neko_val_id("cache");
        struct _value *return_value_neko_val_field$9;
        return_value_neko_val_field$9=neko_val_field(mload, return_value_neko_val_id$8);
        signed int return_value_neko_val_id$10;
        return_value_neko_val_id$10=neko_val_id("_self");
        neko_alloc_field(return_value_neko_val_field$9, return_value_neko_val_id$10, module_val);
        neko_val_callEx(val_null, module_exec, &module_val, 1, &exc);
        if(!(exc == ((struct _value *)NULL)))
        {
          report(vm, exc, 1);
          return 1;
        }

        else
          return 0;
      }
    }
  }
}

// neko_file_reader
// file vm/neko_mod.h line 60
signed int neko_file_reader(void *p, void *buf, signed int size)
{
  signed int len = 0;
  unsigned long int return_value_fread$1;
  signed int return_value_ferror$3;
  signed int *return_value___errno_location$2;
  while(size >= 1)
  {
    signed int l;
    do
    {

    fread_again:
      ;
      return_value_fread$1=fread(buf, (unsigned long int)1, (unsigned long int)size, (struct _IO_FILE *)p);
      l = (signed int)return_value_fread$1;
      if(l >= 1)
        goto __CPROVER_DUMP_L4;

      return_value_ferror$3=ferror((struct _IO_FILE *)p);
      if(return_value_ferror$3 == 0)
        break;

      return_value___errno_location$2=__errno_location();
    }
    while(*return_value___errno_location$2 == 4);
    return len;

  __CPROVER_DUMP_L4:
    ;
    size = size - l;
    len = len + l;
    buf = (void *)((char *)buf + (signed long int)l);
  }
  return len;
}

// neko_flush_stack
// file vm/interp.c line 510
static struct _value * neko_flush_stack(signed long int *cspup, signed long int *csp, struct _value *old)
{
  signed int ncalls = (signed int)((cspup - csp) / (signed long int)4);
  struct _value *stack_trace;
  signed int tmp_if_expr$1;
  if(old == ((struct _value *)NULL))
    tmp_if_expr$1 = 0;

  else
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)old) >> 4;
  stack_trace=neko_alloc_array((unsigned int)(ncalls + tmp_if_expr$1));
  struct _value **st = &((struct anonymous$4 *)stack_trace)->ptr;
  struct _neko_module *m;
  while(!(csp == cspup))
  {
    m = (struct _neko_module *)csp[(signed long int)4];
    if(!(m == ((struct _neko_module *)NULL)))
    {
      if(!(m->dbgidxs == ((struct _neko_debug *)NULL)))
      {
        unsigned int ppc = (unsigned int)((((signed long int **)csp)[(signed long int)1] - (signed long int)2) - m->code);
        if(!(ppc >= m->codesize))
        {
          signed int idx;
          signed int return_value_bitcount$2;
          return_value_bitcount$2=bitcount((m->dbgidxs + (signed long int)(ppc >> 5))->bits >> (unsigned int)31 - (ppc & (unsigned int)31));
          idx = (m->dbgidxs + (signed long int)(ppc >> 5))->base + return_value_bitcount$2;
          *st = (&((struct anonymous$4 *)m->dbgtbl)->ptr)[(signed long int)idx];
        }

        else
          *st = m->name;
      }

      else
        *st = m->name;
    }

    else
      *st = val_null;
    st = st + 1l;
    if(!(old == ((struct _value *)NULL)))
    {
      csp = csp + 1l;
      *csp = (signed long int)0;
      csp = csp + 1l;
      *csp = (signed long int)0;
      csp = csp + 1l;
      *csp = (signed long int)0;
      csp = csp + 1l;
      *csp = (signed long int)0;
    }

    else
      csp = csp + (signed long int)4;
  }
  signed int tmp_post$3;
  struct _value **tmp_post$4;
  struct _value **tmp_post$5;
  if(!(old == ((struct _value *)NULL)))
  {
    struct _value **oldst = &((struct anonymous$4 *)old)->ptr;
    ncalls = (signed int)*((enum anonymous$7 *)old) >> 4;
    do
    {
      tmp_post$3 = ncalls;
      ncalls = ncalls - 1;
      if(tmp_post$3 == 0)
        break;

      tmp_post$4 = st;
      st = st + 1l;
      tmp_post$5 = oldst;
      oldst = oldst + 1l;
      *tmp_post$4 = *tmp_post$5;
    }
    while((_Bool)1);
  }

  return stack_trace;
}

// neko_free_jit
// file vm/jit_x86.c line 2775
void neko_free_jit()
{
  ;
}

// neko_free_local
// file vm/neko.h line 441
void neko_free_local(struct _mt_local *l)
{
  pthread_key_delete(l->key);
  free((void *)l);
}

// neko_free_lock
// file vm/neko.h line 447
void neko_free_lock(struct _mt_lock *l)
{
  pthread_mutex_destroy(&l->lock);
  free((void *)l);
}

// neko_free_root
// file vm/alloc.c line 361
void neko_free_root(struct _value **v)
{
  GC_free((void *)v);
}

// neko_gc_init
// file vm/alloc.c line 119
void neko_gc_init()
{
  GC_set_warn_proc((void (*)(char *, unsigned long int))(void *)null_warn_proc);
  GC_all_interior_pointers = 0;
  GC_java_finalization = 1;
  GC_init();
  GC_no_dls = 1;
  GC_clear_roots();
}

// neko_gc_loop
// file vm/alloc.c line 151
void neko_gc_loop()
{
  GC_collect_a_little();
}

// neko_gc_major
// file vm/alloc.c line 155
void neko_gc_major()
{
  GC_gcollect();
}

// neko_gc_stats
// file vm/alloc.c line 159
void neko_gc_stats(signed int *heap, signed int *free)
{
  unsigned long int return_value_GC_get_heap_size$1;
  return_value_GC_get_heap_size$1=GC_get_heap_size();
  *heap = (signed int)return_value_GC_get_heap_size$1;
  unsigned long int return_value_GC_get_free_bytes$2;
  return_value_GC_get_free_bytes$2=GC_get_free_bytes();
  *free = (signed int)return_value_GC_get_free_bytes$2;
}

// neko_get_ttable
// file vm/vm.h line 70
extern signed long int * neko_get_ttable()
{
  signed long int return_value_neko_interp_loop$1;
  return_value_neko_interp_loop$1=neko_interp_loop((struct _neko_vm *)(void *)0, (struct _neko_module *)(void *)0, (signed long int)0, (signed long int *)(void *)0);
  return (signed long int *)return_value_neko_interp_loop$1;
}

// neko_global_free
// file vm/neko_vm.h line 36
void neko_global_free()
{
  neko_free_jit();
  neko_free_root((struct _value **)kind_names);
  neko_free_root(apply_string);
  neko_free_root(neko_builtins);
  neko_free_root((struct _value **)neko_fields);
  apply_string = (struct _value **)(void *)0;
  neko_free_local(neko_vm_context);
  neko_free_lock(neko_fields_lock);
  neko_gc_major();
}

// neko_global_init
// file vm/neko_vm.h line 35
void neko_global_init()
{
  signed long int *return_value_neko_get_ttable$1;
  return_value_neko_get_ttable$1=neko_get_ttable();
  op_last = return_value_neko_get_ttable$1[(signed long int)67];
  empty_array.ptr = val_null;
  neko_gc_init();
  neko_vm_context=neko_alloc_local();
  neko_fields_lock=neko_alloc_lock();
  struct _value **return_value_neko_alloc_root$2;
  return_value_neko_alloc_root$2=neko_alloc_root((unsigned int)(((unsigned long int)(63 + 1) * sizeof(struct _objtable) /*16ul*/ ) / sizeof(struct _value *) /*8ul*/ ));
  neko_fields = (struct _objtable *)return_value_neko_alloc_root$2;
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    otable_init(&neko_fields[(signed long int)i]);
  neko_init_builtins();
  struct _value **return_value_neko_alloc_root$3;
  return_value_neko_alloc_root$3=neko_alloc_root((unsigned int)1);
  kind_names = (struct _klist **)return_value_neko_alloc_root$3;
  *kind_names = (struct _klist *)(void *)0;
  id_loader=neko_val_id("loader");
  id_exports=neko_val_id("exports");
  id_cache=neko_val_id("cache");
  id_path=neko_val_id("path");
  id_loader_libs=neko_val_id("__libs");
  neko_id_module=neko_val_id("__module");
  id_compare=neko_val_id("__compare");
  id_string=neko_val_id("__string");
  id_add=neko_val_id("__add");
  id_radd=neko_val_id("__radd");
  id_sub=neko_val_id("__sub");
  id_rsub=neko_val_id("__rsub");
  id_mult=neko_val_id("__mult");
  id_rmult=neko_val_id("__rmult");
  id_div=neko_val_id("__div");
  id_rdiv=neko_val_id("__rdiv");
  id_mod=neko_val_id("__mod");
  id_rmod=neko_val_id("__rmod");
  id_get=neko_val_id("__get");
  id_set=neko_val_id("__set");
  apply_string=neko_alloc_root((unsigned int)1);
  *apply_string=neko_alloc_string("apply");
  neko_init_jit();
}

// neko_has_embedded_module
// file vm/main.c line 98
signed int neko_has_embedded_module(struct _neko_vm *vm)
{
  char *exe;
  exe=executable_path();
  unsigned char id[8l];
  signed int pos;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(exe == ((char *)NULL))
    return 0;

  else
  {
    self=fopen(exe, "rb");
    if(self == ((struct _IO_FILE *)NULL))
      return 0;

    else
    {
      fseek(self, (signed long int)-8, 2);
      unsigned long int return_value_fread$1;
      return_value_fread$1=fread((void *)id, (unsigned long int)1, (unsigned long int)8, self);
      if(!(return_value_fread$1 == 8ul))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)id[(signed long int)0] != 78 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)id[(signed long int)1] != 69 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)id[(signed long int)2] != 75 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)id[(signed long int)3] != 79 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
      {
        fclose(self);
        return 0;
      }

      else
      {
        pos = (signed int)id[(signed long int)4] | (signed int)id[(signed long int)5] << 8 | (signed int)id[(signed long int)6] << 16;
        fseek(self, (signed long int)pos, 0);
        if((1 & (signed int)id[7l]) == 0)
          neko_vm_jit(vm, 1);

        return 1;
      }
    }
  }
}

// neko_init_builtins
// file vm/builtins.c line 1227
void neko_init_builtins()
{
  neko_builtins=neko_alloc_root((unsigned int)2);
  neko_builtins[(signed long int)0]=neko_alloc_object((struct _value *)(void *)0);
  neko_builtins[(signed long int)1]=neko_alloc_function((void *)builtin_print, (unsigned int)-1, "$print");
  signed int return_value_neko_val_id$1;
  return_value_neko_val_id$1=neko_val_id("print");
  struct _value *return_value_neko_alloc_function$2;
  return_value_neko_alloc_function$2=neko_alloc_function((void *)builtin_print, (unsigned int)-1, "$print");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$1, return_value_neko_alloc_function$2);
  signed int return_value_neko_val_id$3;
  return_value_neko_val_id$3=neko_val_id("array");
  struct _value *return_value_neko_alloc_function$4;
  return_value_neko_alloc_function$4=neko_alloc_function((void *)builtin_array, (unsigned int)-1, "$array");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$3, return_value_neko_alloc_function$4);
  signed int return_value_neko_val_id$5;
  return_value_neko_val_id$5=neko_val_id("amake");
  struct _value *return_value_neko_alloc_function$6;
  return_value_neko_alloc_function$6=neko_alloc_function((void *)builtin_amake, (unsigned int)1, "$amake");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$5, return_value_neko_alloc_function$6);
  signed int return_value_neko_val_id$7;
  return_value_neko_val_id$7=neko_val_id("acopy");
  struct _value *return_value_neko_alloc_function$8;
  return_value_neko_alloc_function$8=neko_alloc_function((void *)builtin_acopy, (unsigned int)1, "$acopy");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$7, return_value_neko_alloc_function$8);
  signed int return_value_neko_val_id$9;
  return_value_neko_val_id$9=neko_val_id("asize");
  struct _value *return_value_neko_alloc_function$10;
  return_value_neko_alloc_function$10=neko_alloc_function((void *)builtin_asize, (unsigned int)1, "$asize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$9, return_value_neko_alloc_function$10);
  signed int return_value_neko_val_id$11;
  return_value_neko_val_id$11=neko_val_id("asub");
  struct _value *return_value_neko_alloc_function$12;
  return_value_neko_alloc_function$12=neko_alloc_function((void *)builtin_asub, (unsigned int)3, "$asub");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$11, return_value_neko_alloc_function$12);
  signed int return_value_neko_val_id$13;
  return_value_neko_val_id$13=neko_val_id("ablit");
  struct _value *return_value_neko_alloc_function$14;
  return_value_neko_alloc_function$14=neko_alloc_function((void *)builtin_ablit, (unsigned int)5, "$ablit");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$13, return_value_neko_alloc_function$14);
  signed int return_value_neko_val_id$15;
  return_value_neko_val_id$15=neko_val_id("aconcat");
  struct _value *return_value_neko_alloc_function$16;
  return_value_neko_alloc_function$16=neko_alloc_function((void *)builtin_aconcat, (unsigned int)1, "$aconcat");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$15, return_value_neko_alloc_function$16);
  signed int return_value_neko_val_id$17;
  return_value_neko_val_id$17=neko_val_id("smake");
  struct _value *return_value_neko_alloc_function$18;
  return_value_neko_alloc_function$18=neko_alloc_function((void *)builtin_smake, (unsigned int)1, "$smake");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$17, return_value_neko_alloc_function$18);
  signed int return_value_neko_val_id$19;
  return_value_neko_val_id$19=neko_val_id("ssize");
  struct _value *return_value_neko_alloc_function$20;
  return_value_neko_alloc_function$20=neko_alloc_function((void *)builtin_ssize, (unsigned int)1, "$ssize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$19, return_value_neko_alloc_function$20);
  signed int return_value_neko_val_id$21;
  return_value_neko_val_id$21=neko_val_id("scopy");
  struct _value *return_value_neko_alloc_function$22;
  return_value_neko_alloc_function$22=neko_alloc_function((void *)builtin_scopy, (unsigned int)1, "$scopy");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$21, return_value_neko_alloc_function$22);
  signed int return_value_neko_val_id$23;
  return_value_neko_val_id$23=neko_val_id("ssub");
  struct _value *return_value_neko_alloc_function$24;
  return_value_neko_alloc_function$24=neko_alloc_function((void *)builtin_ssub, (unsigned int)3, "$ssub");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$23, return_value_neko_alloc_function$24);
  signed int return_value_neko_val_id$25;
  return_value_neko_val_id$25=neko_val_id("sget");
  struct _value *return_value_neko_alloc_function$26;
  return_value_neko_alloc_function$26=neko_alloc_function((void *)builtin_sget, (unsigned int)2, "$sget");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$25, return_value_neko_alloc_function$26);
  signed int return_value_neko_val_id$27;
  return_value_neko_val_id$27=neko_val_id("sset");
  struct _value *return_value_neko_alloc_function$28;
  return_value_neko_alloc_function$28=neko_alloc_function((void *)builtin_sset, (unsigned int)3, "$sset");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$27, return_value_neko_alloc_function$28);
  signed int return_value_neko_val_id$29;
  return_value_neko_val_id$29=neko_val_id("sblit");
  struct _value *return_value_neko_alloc_function$30;
  return_value_neko_alloc_function$30=neko_alloc_function((void *)builtin_sblit, (unsigned int)5, "$sblit");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$29, return_value_neko_alloc_function$30);
  signed int return_value_neko_val_id$31;
  return_value_neko_val_id$31=neko_val_id("sfind");
  struct _value *return_value_neko_alloc_function$32;
  return_value_neko_alloc_function$32=neko_alloc_function((void *)builtin_sfind, (unsigned int)3, "$sfind");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$31, return_value_neko_alloc_function$32);
  signed int return_value_neko_val_id$33;
  return_value_neko_val_id$33=neko_val_id("new");
  struct _value *return_value_neko_alloc_function$34;
  return_value_neko_alloc_function$34=neko_alloc_function((void *)builtin_new, (unsigned int)1, "$new");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$33, return_value_neko_alloc_function$34);
  signed int return_value_neko_val_id$35;
  return_value_neko_val_id$35=neko_val_id("objget");
  struct _value *return_value_neko_alloc_function$36;
  return_value_neko_alloc_function$36=neko_alloc_function((void *)builtin_objget, (unsigned int)2, "$objget");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$35, return_value_neko_alloc_function$36);
  signed int return_value_neko_val_id$37;
  return_value_neko_val_id$37=neko_val_id("objset");
  struct _value *return_value_neko_alloc_function$38;
  return_value_neko_alloc_function$38=neko_alloc_function((void *)builtin_objset, (unsigned int)3, "$objset");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$37, return_value_neko_alloc_function$38);
  signed int return_value_neko_val_id$39;
  return_value_neko_val_id$39=neko_val_id("objcall");
  struct _value *return_value_neko_alloc_function$40;
  return_value_neko_alloc_function$40=neko_alloc_function((void *)builtin_objcall, (unsigned int)3, "$objcall");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$39, return_value_neko_alloc_function$40);
  signed int return_value_neko_val_id$41;
  return_value_neko_val_id$41=neko_val_id("objfield");
  struct _value *return_value_neko_alloc_function$42;
  return_value_neko_alloc_function$42=neko_alloc_function((void *)builtin_objfield, (unsigned int)2, "$objfield");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$41, return_value_neko_alloc_function$42);
  signed int return_value_neko_val_id$43;
  return_value_neko_val_id$43=neko_val_id("objremove");
  struct _value *return_value_neko_alloc_function$44;
  return_value_neko_alloc_function$44=neko_alloc_function((void *)builtin_objremove, (unsigned int)2, "$objremove");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$43, return_value_neko_alloc_function$44);
  signed int return_value_neko_val_id$45;
  return_value_neko_val_id$45=neko_val_id("objfields");
  struct _value *return_value_neko_alloc_function$46;
  return_value_neko_alloc_function$46=neko_alloc_function((void *)builtin_objfields, (unsigned int)1, "$objfields");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$45, return_value_neko_alloc_function$46);
  signed int return_value_neko_val_id$47;
  return_value_neko_val_id$47=neko_val_id("hash");
  struct _value *return_value_neko_alloc_function$48;
  return_value_neko_alloc_function$48=neko_alloc_function((void *)builtin_hash, (unsigned int)1, "$hash");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$47, return_value_neko_alloc_function$48);
  signed int return_value_neko_val_id$49;
  return_value_neko_val_id$49=neko_val_id("fasthash");
  struct _value *return_value_neko_alloc_function$50;
  return_value_neko_alloc_function$50=neko_alloc_function((void *)builtin_fasthash, (unsigned int)1, "$fasthash");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$49, return_value_neko_alloc_function$50);
  signed int return_value_neko_val_id$51;
  return_value_neko_val_id$51=neko_val_id("field");
  struct _value *return_value_neko_alloc_function$52;
  return_value_neko_alloc_function$52=neko_alloc_function((void *)builtin_field, (unsigned int)1, "$field");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$51, return_value_neko_alloc_function$52);
  signed int return_value_neko_val_id$53;
  return_value_neko_val_id$53=neko_val_id("objsetproto");
  struct _value *return_value_neko_alloc_function$54;
  return_value_neko_alloc_function$54=neko_alloc_function((void *)builtin_objsetproto, (unsigned int)2, "$objsetproto");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$53, return_value_neko_alloc_function$54);
  signed int return_value_neko_val_id$55;
  return_value_neko_val_id$55=neko_val_id("objgetproto");
  struct _value *return_value_neko_alloc_function$56;
  return_value_neko_alloc_function$56=neko_alloc_function((void *)builtin_objgetproto, (unsigned int)1, "$objgetproto");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$55, return_value_neko_alloc_function$56);
  signed int return_value_neko_val_id$57;
  return_value_neko_val_id$57=neko_val_id("int");
  struct _value *return_value_neko_alloc_function$58;
  return_value_neko_alloc_function$58=neko_alloc_function((void *)builtin_int, (unsigned int)1, "$int");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$57, return_value_neko_alloc_function$58);
  signed int return_value_neko_val_id$59;
  return_value_neko_val_id$59=neko_val_id("float");
  struct _value *return_value_neko_alloc_function$60;
  return_value_neko_alloc_function$60=neko_alloc_function((void *)builtin_float, (unsigned int)1, "$float");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$59, return_value_neko_alloc_function$60);
  signed int return_value_neko_val_id$61;
  return_value_neko_val_id$61=neko_val_id("string");
  struct _value *return_value_neko_alloc_function$62;
  return_value_neko_alloc_function$62=neko_alloc_function((void *)builtin_string, (unsigned int)1, "$string");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$61, return_value_neko_alloc_function$62);
  signed int return_value_neko_val_id$63;
  return_value_neko_val_id$63=neko_val_id("typeof");
  struct _value *return_value_neko_alloc_function$64;
  return_value_neko_alloc_function$64=neko_alloc_function((void *)builtin_typeof, (unsigned int)1, "$typeof");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$63, return_value_neko_alloc_function$64);
  signed int return_value_neko_val_id$65;
  return_value_neko_val_id$65=neko_val_id("closure");
  struct _value *return_value_neko_alloc_function$66;
  return_value_neko_alloc_function$66=neko_alloc_function((void *)builtin_closure, (unsigned int)-1, "$closure");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$65, return_value_neko_alloc_function$66);
  signed int return_value_neko_val_id$67;
  return_value_neko_val_id$67=neko_val_id("apply");
  struct _value *return_value_neko_alloc_function$68;
  return_value_neko_alloc_function$68=neko_alloc_function((void *)builtin_apply, (unsigned int)-1, "$apply");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$67, return_value_neko_alloc_function$68);
  signed int return_value_neko_val_id$69;
  return_value_neko_val_id$69=neko_val_id("varargs");
  struct _value *return_value_neko_alloc_function$70;
  return_value_neko_alloc_function$70=neko_alloc_function((void *)builtin_varargs, (unsigned int)1, "$varargs");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$69, return_value_neko_alloc_function$70);
  signed int return_value_neko_val_id$71;
  return_value_neko_val_id$71=neko_val_id("compare");
  struct _value *return_value_neko_alloc_function$72;
  return_value_neko_alloc_function$72=neko_alloc_function((void *)builtin_compare, (unsigned int)2, "$compare");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$71, return_value_neko_alloc_function$72);
  signed int return_value_neko_val_id$73;
  return_value_neko_val_id$73=neko_val_id("pcompare");
  struct _value *return_value_neko_alloc_function$74;
  return_value_neko_alloc_function$74=neko_alloc_function((void *)builtin_pcompare, (unsigned int)2, "$pcompare");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$73, return_value_neko_alloc_function$74);
  signed int return_value_neko_val_id$75;
  return_value_neko_val_id$75=neko_val_id("not");
  struct _value *return_value_neko_alloc_function$76;
  return_value_neko_alloc_function$76=neko_alloc_function((void *)builtin_not, (unsigned int)1, "$not");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$75, return_value_neko_alloc_function$76);
  signed int return_value_neko_val_id$77;
  return_value_neko_val_id$77=neko_val_id("throw");
  struct _value *return_value_neko_alloc_function$78;
  return_value_neko_alloc_function$78=neko_alloc_function((void *)builtin_throw, (unsigned int)1, "$throw");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$77, return_value_neko_alloc_function$78);
  signed int return_value_neko_val_id$79;
  return_value_neko_val_id$79=neko_val_id("rethrow");
  struct _value *return_value_neko_alloc_function$80;
  return_value_neko_alloc_function$80=neko_alloc_function((void *)builtin_rethrow, (unsigned int)1, "$rethrow");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$79, return_value_neko_alloc_function$80);
  signed int return_value_neko_val_id$81;
  return_value_neko_val_id$81=neko_val_id("nargs");
  struct _value *return_value_neko_alloc_function$82;
  return_value_neko_alloc_function$82=neko_alloc_function((void *)builtin_nargs, (unsigned int)1, "$nargs");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$81, return_value_neko_alloc_function$82);
  signed int return_value_neko_val_id$83;
  return_value_neko_val_id$83=neko_val_id("call");
  struct _value *return_value_neko_alloc_function$84;
  return_value_neko_alloc_function$84=neko_alloc_function((void *)builtin_call, (unsigned int)3, "$call");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$83, return_value_neko_alloc_function$84);
  signed int return_value_neko_val_id$85;
  return_value_neko_val_id$85=neko_val_id("isnan");
  struct _value *return_value_neko_alloc_function$86;
  return_value_neko_alloc_function$86=neko_alloc_function((void *)builtin_isnan, (unsigned int)1, "$isnan");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$85, return_value_neko_alloc_function$86);
  signed int return_value_neko_val_id$87;
  return_value_neko_val_id$87=neko_val_id("isinfinite");
  struct _value *return_value_neko_alloc_function$88;
  return_value_neko_alloc_function$88=neko_alloc_function((void *)builtin_isinfinite, (unsigned int)1, "$isinfinite");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$87, return_value_neko_alloc_function$88);
  signed int return_value_neko_val_id$89;
  return_value_neko_val_id$89=neko_val_id("istrue");
  struct _value *return_value_neko_alloc_function$90;
  return_value_neko_alloc_function$90=neko_alloc_function((void *)builtin_istrue, (unsigned int)1, "$istrue");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$89, return_value_neko_alloc_function$90);
  signed int return_value_neko_val_id$91;
  return_value_neko_val_id$91=neko_val_id("getkind");
  struct _value *return_value_neko_alloc_function$92;
  return_value_neko_alloc_function$92=neko_alloc_function((void *)builtin_getkind, (unsigned int)1, "$getkind");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$91, return_value_neko_alloc_function$92);
  signed int return_value_neko_val_id$93;
  return_value_neko_val_id$93=neko_val_id("iskind");
  struct _value *return_value_neko_alloc_function$94;
  return_value_neko_alloc_function$94=neko_alloc_function((void *)builtin_iskind, (unsigned int)2, "$iskind");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$93, return_value_neko_alloc_function$94);
  signed int return_value_neko_val_id$95;
  return_value_neko_val_id$95=neko_val_id("hnew");
  struct _value *return_value_neko_alloc_function$96;
  return_value_neko_alloc_function$96=neko_alloc_function((void *)builtin_hnew, (unsigned int)1, "$hnew");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$95, return_value_neko_alloc_function$96);
  signed int return_value_neko_val_id$97;
  return_value_neko_val_id$97=neko_val_id("hget");
  struct _value *return_value_neko_alloc_function$98;
  return_value_neko_alloc_function$98=neko_alloc_function((void *)builtin_hget, (unsigned int)3, "$hget");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$97, return_value_neko_alloc_function$98);
  signed int return_value_neko_val_id$99;
  return_value_neko_val_id$99=neko_val_id("hmem");
  struct _value *return_value_neko_alloc_function$100;
  return_value_neko_alloc_function$100=neko_alloc_function((void *)builtin_hmem, (unsigned int)3, "$hmem");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$99, return_value_neko_alloc_function$100);
  signed int return_value_neko_val_id$101;
  return_value_neko_val_id$101=neko_val_id("hset");
  struct _value *return_value_neko_alloc_function$102;
  return_value_neko_alloc_function$102=neko_alloc_function((void *)builtin_hset, (unsigned int)4, "$hset");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$101, return_value_neko_alloc_function$102);
  signed int return_value_neko_val_id$103;
  return_value_neko_val_id$103=neko_val_id("hadd");
  struct _value *return_value_neko_alloc_function$104;
  return_value_neko_alloc_function$104=neko_alloc_function((void *)builtin_hadd, (unsigned int)3, "$hadd");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$103, return_value_neko_alloc_function$104);
  signed int return_value_neko_val_id$105;
  return_value_neko_val_id$105=neko_val_id("hremove");
  struct _value *return_value_neko_alloc_function$106;
  return_value_neko_alloc_function$106=neko_alloc_function((void *)builtin_hremove, (unsigned int)3, "$hremove");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$105, return_value_neko_alloc_function$106);
  signed int return_value_neko_val_id$107;
  return_value_neko_val_id$107=neko_val_id("hresize");
  struct _value *return_value_neko_alloc_function$108;
  return_value_neko_alloc_function$108=neko_alloc_function((void *)builtin_hresize, (unsigned int)2, "$hresize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$107, return_value_neko_alloc_function$108);
  signed int return_value_neko_val_id$109;
  return_value_neko_val_id$109=neko_val_id("hkey");
  struct _value *return_value_neko_alloc_function$110;
  return_value_neko_alloc_function$110=neko_alloc_function((void *)builtin_hkey, (unsigned int)1, "$hkey");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$109, return_value_neko_alloc_function$110);
  signed int return_value_neko_val_id$111;
  return_value_neko_val_id$111=neko_val_id("hcount");
  struct _value *return_value_neko_alloc_function$112;
  return_value_neko_alloc_function$112=neko_alloc_function((void *)builtin_hcount, (unsigned int)1, "$hcount");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$111, return_value_neko_alloc_function$112);
  signed int return_value_neko_val_id$113;
  return_value_neko_val_id$113=neko_val_id("hsize");
  struct _value *return_value_neko_alloc_function$114;
  return_value_neko_alloc_function$114=neko_alloc_function((void *)builtin_hsize, (unsigned int)1, "$hsize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$113, return_value_neko_alloc_function$114);
  signed int return_value_neko_val_id$115;
  return_value_neko_val_id$115=neko_val_id("hiter");
  struct _value *return_value_neko_alloc_function$116;
  return_value_neko_alloc_function$116=neko_alloc_function((void *)builtin_hiter, (unsigned int)2, "$hiter");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$115, return_value_neko_alloc_function$116);
  signed int return_value_neko_val_id$117;
  return_value_neko_val_id$117=neko_val_id("iadd");
  struct _value *return_value_neko_alloc_function$118;
  return_value_neko_alloc_function$118=neko_alloc_function((void *)builtin_iadd, (unsigned int)2, "$iadd");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$117, return_value_neko_alloc_function$118);
  signed int return_value_neko_val_id$119;
  return_value_neko_val_id$119=neko_val_id("isub");
  struct _value *return_value_neko_alloc_function$120;
  return_value_neko_alloc_function$120=neko_alloc_function((void *)builtin_isub, (unsigned int)2, "$isub");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$119, return_value_neko_alloc_function$120);
  signed int return_value_neko_val_id$121;
  return_value_neko_val_id$121=neko_val_id("imult");
  struct _value *return_value_neko_alloc_function$122;
  return_value_neko_alloc_function$122=neko_alloc_function((void *)builtin_imult, (unsigned int)2, "$imult");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$121, return_value_neko_alloc_function$122);
  signed int return_value_neko_val_id$123;
  return_value_neko_val_id$123=neko_val_id("idiv");
  struct _value *return_value_neko_alloc_function$124;
  return_value_neko_alloc_function$124=neko_alloc_function((void *)builtin_idiv, (unsigned int)2, "$idiv");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$123, return_value_neko_alloc_function$124);
  signed int return_value_neko_val_id$125;
  return_value_neko_val_id$125=neko_val_id("excstack");
  struct _value *return_value_neko_alloc_function$126;
  return_value_neko_alloc_function$126=neko_alloc_function((void *)builtin_excstack, (unsigned int)0, "$excstack");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$125, return_value_neko_alloc_function$126);
  signed int return_value_neko_val_id$127;
  return_value_neko_val_id$127=neko_val_id("callstack");
  struct _value *return_value_neko_alloc_function$128;
  return_value_neko_alloc_function$128=neko_alloc_function((void *)builtin_callstack, (unsigned int)0, "$callstack");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$127, return_value_neko_alloc_function$128);
  signed int return_value_neko_val_id$129;
  return_value_neko_val_id$129=neko_val_id("version");
  struct _value *return_value_neko_alloc_function$130;
  return_value_neko_alloc_function$130=neko_alloc_function((void *)builtin_version, (unsigned int)0, "$version");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$129, return_value_neko_alloc_function$130);
  signed int return_value_neko_val_id$131;
  return_value_neko_val_id$131=neko_val_id("setresolver");
  struct _value *return_value_neko_alloc_function$132;
  return_value_neko_alloc_function$132=neko_alloc_function((void *)builtin_setresolver, (unsigned int)1, "$setresolver");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id$131, return_value_neko_alloc_function$132);
}

// neko_init_jit
// file vm/jit_x86.c line 2772
void neko_init_jit()
{
  ;
}

// neko_interp
// file vm/vm.h line 69
extern struct _value * neko_interp(struct _neko_vm *vm, void *_m, signed long int acc, signed long int *pc)
{
  signed long int *sp;
  signed long int *csp;
  signed long int *trap;
  signed long int init_sp = vm->spmax - vm->sp;
  struct _neko_module *m = (struct _neko_module *)_m;
  struct __jmp_buf_tag old[1l];
  memcpy((void *)&old, (const void *)&vm->start, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
  signed int return_value__setjmp$4;
  return_value__setjmp$4=_setjmp(vm->start);
  _Bool tmp_if_expr$1;
  signed long int *tmp_post$3;
  _Bool tmp_if_expr$5;
  if(!(return_value__setjmp$4 == 0))
  {
    acc = (signed long int)vm->vthis;
    if(vm->trap == 0l)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = vm->trap <= init_sp ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      char **tmp;
      memcpy((void *)&vm->start, (const void *)&old, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
      tmp = (char **)vm->start;
      if(*tmp == jit_handle_trap)
        ((void (*)(struct _neko_vm *))jit_handle_trap)(vm);

      else
        longjmp(vm->start, 1);
    }

    trap = vm->spmax - vm->trap;
    if(!(trap >= vm->sp))
    {
      vm->trap = (signed long int)0;
      struct _value *return_value_neko_alloc_string$2;
      return_value_neko_alloc_string$2=neko_alloc_string("Invalid Trap");
      neko_val_throw(return_value_neko_alloc_string$2);
    }

    csp = vm->spmin + (signed long int)((signed int)(signed long int)trap[(signed long int)0] >> 1);
    vm->exc_stack=neko_flush_stack(vm->csp, csp, vm->exc_stack);
    vm->csp = csp;
    vm->vthis = (struct _value *)trap[(signed long int)1];
    vm->env = (struct _value *)trap[(signed long int)2];
    pc = (signed long int *)(trap[(signed long int)3] & (signed long int)~1);
    m = (struct _neko_module *)(signed long int *)(trap[(signed long int)4] & (signed long int)~1);
    sp = trap + (signed long int)6;
    vm->trap = (signed long int)((signed int)(signed long int)trap[(signed long int)5] >> 1);
    for( ; !(vm->sp >= sp); *tmp_post$3 = (signed long int)0)
    {
      tmp_post$3 = vm->sp;
      vm->sp = vm->sp + 1l;
    }
    if(!((1 & (signed int)m) == 0))
      goto __CPROVER_DUMP_L9;

    if(!((signed int)*((enum anonymous$7 *)m) == VAL_ABSTRACT))
      goto __CPROVER_DUMP_L9;

    if(!(((struct anonymous$6 *)m)->kind == neko_kind_module))
      goto __CPROVER_DUMP_L9;

    m = (struct _neko_module *)((struct anonymous$6 *)m)->data;
    pc = (signed long int *)(((signed long int)pc >> 1) + (signed long int)m->jit);
    acc=((signed long int (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, (void *)pc, (struct _value *)acc, m);
    return (struct _value *)acc;
  }

  else
  {

  __CPROVER_DUMP_L9:
    ;
    if(!(m->jit == NULL))
      tmp_if_expr$5 = m->code == pc ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      acc=((signed long int (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, m->jit, (struct _value *)acc, m);

    else
      acc=neko_interp_loop(vm, m, acc, pc);
    memcpy((void *)&vm->start, (const void *)&old, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
    return (struct _value *)acc;
  }
}

// neko_interp_loop
// file vm/interp.c line 613
signed long int neko_interp_loop(struct _neko_vm *vm, struct _neko_module *m, signed long int _acc, signed long int *_pc)
{
  signed long int acc = _acc;
  signed long int *pc = _pc;
  signed long int *tmp_post$1;
  signed long int *tmp_post$2;
  struct _value *return_value_neko_alloc_int32$3;
  signed long int *tmp_post$4;
  signed long int *tmp_post$5;
  struct _value *return_value_neko_alloc_string$6;
  signed long int *tmp_post$9;
  _Bool tmp_if_expr$17;
  struct _value *return_value_neko_alloc_string$11;
  struct _value *return_value_neko_alloc_string$14;
  _Bool tmp_if_expr$37;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$35;
  struct _value *return_value_neko_alloc_string$19;
  struct _value *return_value_neko_alloc_string$22;
  signed long int *tmp_post$25;
  signed long int *tmp_post$26;
  signed long int *tmp_post$27;
  signed long int *tmp_post$28;
  _Bool tmp_if_expr$32;
  _Bool tmp_if_expr$34;
  _Bool tmp_if_expr$33;
  struct _value *return_value_neko_alloc_string$29;
  signed long int *tmp_post$38;
  _Bool tmp_if_expr$53;
  _Bool tmp_if_expr$52;
  struct _value *return_value_neko_alloc_string$39;
  struct _value *return_value_neko_alloc_string$42;
  signed long int *tmp_post$45;
  signed long int *tmp_post$46;
  signed long int *tmp_post$47;
  signed long int *tmp_post$48;
  struct _value *return_value_neko_alloc_string$49;
  _Bool tmp_if_expr$68;
  _Bool tmp_if_expr$67;
  struct _value *return_value_neko_alloc_string$54;
  struct _value *return_value_neko_alloc_string$57;
  signed long int *tmp_post$60;
  signed long int *tmp_post$61;
  signed long int *tmp_post$62;
  signed long int *tmp_post$63;
  struct _value *return_value_neko_alloc_string$64;
  _Bool tmp_if_expr$85;
  _Bool tmp_if_expr$69;
  _Bool tmp_if_expr$84;
  signed long int *tmp_post$70;
  struct _value *return_value_neko_alloc_string$71;
  struct _value *return_value_neko_alloc_string$74;
  signed long int *tmp_post$77;
  signed long int *tmp_post$78;
  signed long int *tmp_post$79;
  signed long int *tmp_post$80;
  struct _value *return_value_neko_alloc_string$81;
  signed long int *tmp_post$86;
  signed long int *tmp_post$87;
  signed long int *tmp_post$88;
  struct _value *return_value_neko_alloc_string$89;
  signed long int *tmp_post$92;
  _Bool tmp_if_expr$99;
  struct _value *return_value_neko_alloc_string$93;
  struct _value *return_value_neko_alloc_string$96;
  signed long int *tmp_post$100;
  _Bool tmp_if_expr$117;
  _Bool tmp_if_expr$118;
  _Bool tmp_if_expr$116;
  struct _value *return_value_neko_alloc_string$101;
  struct _value *return_value_neko_alloc_string$104;
  signed long int *tmp_post$106;
  signed long int *tmp_post$107;
  signed long int *tmp_post$108;
  signed long int *tmp_post$109;
  _Bool tmp_if_expr$113;
  _Bool tmp_if_expr$115;
  _Bool tmp_if_expr$114;
  struct _value *return_value_neko_alloc_string$110;
  signed long int *tmp_post$119;
  signed long int *tmp_post$120;
  _Bool tmp_if_expr$134;
  _Bool tmp_if_expr$133;
  struct _value *return_value_neko_alloc_string$121;
  struct _value *return_value_neko_alloc_string$124;
  signed long int *tmp_post$126;
  signed long int *tmp_post$127;
  signed long int *tmp_post$128;
  signed long int *tmp_post$129;
  struct _value *return_value_neko_alloc_string$130;
  signed long int *tmp_post$135;
  struct _value *return_value_neko_alloc_string$136;
  signed long int *tmp_post$138;
  signed int tmp_post$139;
  signed long int *tmp_post$140;
  _Bool tmp_if_expr$144;
  struct _value *return_value_neko_alloc_string$141;
  struct _value *return_value_neko_alloc_string$145;
  signed int tmp_post$148;
  signed int tmp_post$149;
  signed long int *tmp_post$150;
  signed long int *tmp_post$151;
  signed int tmp_post$153;
  signed long int *tmp_post$154;
  signed long int *tmp_post$155;
  signed long int *tmp_post$156;
  signed long int *tmp_post$157;
  signed long int *tmp_post$158;
  struct _value *return_value_neko_alloc_string$159;
  _Bool tmp_if_expr$193;
  struct _value *return_value_neko_alloc_string$162;
  struct _value *return_value_neko_alloc_string$164;
  signed long int *tmp_post$166;
  signed long int *tmp_post$167;
  signed long int *tmp_post$168;
  signed long int *tmp_post$169;
  struct _value *return_value_neko_alloc_string$170;
  signed long int *tmp_post$172;
  signed long int *tmp_post$173;
  signed long int *tmp_post$174;
  signed long int *tmp_post$175;
  struct _value *return_value_neko_alloc_string$176;
  signed int tmp_post$179;
  signed long int *tmp_post$180;
  struct _value *return_value_neko_alloc_string$181;
  signed long int *tmp_post$183;
  signed long int *tmp_post$184;
  signed long int *tmp_post$185;
  signed long int *tmp_post$186;
  struct _value *return_value_neko_alloc_string$187;
  struct _value *return_value_neko_alloc_string$190;
  struct _value *return_value_neko_alloc_string$194;
  _Bool tmp_if_expr$228;
  struct _value *return_value_neko_alloc_string$197;
  struct _value *return_value_neko_alloc_string$199;
  signed long int *tmp_post$201;
  signed long int *tmp_post$202;
  signed long int *tmp_post$203;
  signed long int *tmp_post$204;
  struct _value *return_value_neko_alloc_string$205;
  signed long int *tmp_post$207;
  signed long int *tmp_post$208;
  signed long int *tmp_post$209;
  signed long int *tmp_post$210;
  struct _value *return_value_neko_alloc_string$211;
  signed int tmp_post$214;
  signed long int *tmp_post$215;
  struct _value *return_value_neko_alloc_string$216;
  signed long int *tmp_post$218;
  signed long int *tmp_post$219;
  signed long int *tmp_post$220;
  signed long int *tmp_post$221;
  struct _value *return_value_neko_alloc_string$222;
  struct _value *return_value_neko_alloc_string$225;
  signed long int *tmp_post$229;
  struct _value *return_value_neko_alloc_string$230;
  _Bool tmp_if_expr$264;
  struct _value *return_value_neko_alloc_string$233;
  struct _value *return_value_neko_alloc_string$235;
  signed long int *tmp_post$237;
  signed long int *tmp_post$238;
  signed long int *tmp_post$239;
  signed long int *tmp_post$240;
  struct _value *return_value_neko_alloc_string$241;
  signed long int *tmp_post$243;
  signed long int *tmp_post$244;
  signed long int *tmp_post$245;
  signed long int *tmp_post$246;
  struct _value *return_value_neko_alloc_string$247;
  signed int tmp_post$250;
  signed long int *tmp_post$251;
  struct _value *return_value_neko_alloc_string$252;
  signed long int *tmp_post$254;
  signed long int *tmp_post$255;
  signed long int *tmp_post$256;
  signed long int *tmp_post$257;
  struct _value *return_value_neko_alloc_string$258;
  struct _value *return_value_neko_alloc_string$261;
  struct _value *return_value_neko_alloc_string$265;
  struct _value *return_value_neko_alloc_string$267;
  signed int tmp_post$270;
  signed long int *tmp_post$271;
  signed long int *tmp_post$272;
  signed int tmp_post$273;
  signed long int *tmp_post$274;
  signed long int *tmp_post$275;
  signed long int *tmp_post$276;
  signed long int *tmp_post$277;
  signed long int *tmp_post$278;
  signed long int *tmp_post$279;
  signed int tmp_post$281;
  signed long int *tmp_post$282;
  _Bool tmp_if_expr$286;
  struct _value *return_value_neko_alloc_string$283;
  signed long int *tmp_post$288;
  signed long int *tmp_post$289;
  signed long int *tmp_post$290;
  signed long int *tmp_post$291;
  _Bool tmp_if_expr$352;
  struct _value *tmp_if_expr$293;
  struct _value *return_value_neko_alloc_int32$292;
  struct _value *return_value_neko_alloc_float$294;
  struct _value *tmp_if_expr$296;
  struct _value *return_value_neko_alloc_int32$295;
  struct _value *return_value_neko_append_int$297;
  struct _value *return_value_neko_alloc_string$298;
  struct _value *return_value_neko_alloc_string$301;
  signed long int *tmp_post$304;
  signed long int *tmp_post$305;
  signed long int *tmp_post$306;
  signed long int *tmp_post$307;
  struct _value *return_value_neko_alloc_string$308;
  struct _value *return_value_neko_alloc_float$311;
  struct _value *tmp_if_expr$313;
  struct _value *return_value_neko_alloc_int32$312;
  struct _value *return_value_neko_append_int$314;
  struct _value *return_value_neko_alloc_string$315;
  struct _value *return_value_neko_alloc_string$318;
  signed long int *tmp_post$321;
  signed long int *tmp_post$322;
  signed long int *tmp_post$323;
  signed long int *tmp_post$324;
  struct _value *return_value_neko_alloc_string$325;
  struct _value *return_value_neko_alloc_float$328;
  struct _value *return_value_neko_alloc_float$329;
  struct _value *tmp_if_expr$331;
  struct _value *return_value_neko_alloc_int32$330;
  struct _value *return_value_neko_alloc_float$332;
  struct _value *return_value_neko_alloc_string$333;
  signed long int *tmp_post$336;
  signed long int *tmp_post$337;
  signed long int *tmp_post$338;
  signed long int *tmp_post$339;
  struct _value *return_value_neko_alloc_string$340;
  signed long int *tmp_post$343;
  signed long int *tmp_post$344;
  signed long int *tmp_post$345;
  signed long int *tmp_post$346;
  _Bool tmp_if_expr$351;
  struct _value *return_value_neko_alloc_string$348;
  signed long int *tmp_post$353;
  _Bool tmp_if_expr$413;
  struct _value *tmp_if_expr$355;
  struct _value *return_value_neko_alloc_int32$354;
  struct _value *return_value_neko_alloc_float$356;
  struct _value *tmp_if_expr$358;
  struct _value *return_value_neko_alloc_int32$357;
  struct _value *return_value_neko_alloc_string$359;
  struct _value *return_value_neko_alloc_string$362;
  signed long int *tmp_post$365;
  signed long int *tmp_post$366;
  signed long int *tmp_post$367;
  signed long int *tmp_post$368;
  struct _value *return_value_neko_alloc_string$369;
  struct _value *return_value_neko_alloc_float$372;
  struct _value *tmp_if_expr$374;
  struct _value *return_value_neko_alloc_int32$373;
  struct _value *return_value_neko_alloc_string$375;
  struct _value *return_value_neko_alloc_string$378;
  signed long int *tmp_post$381;
  signed long int *tmp_post$382;
  signed long int *tmp_post$383;
  signed long int *tmp_post$384;
  struct _value *return_value_neko_alloc_string$385;
  struct _value *return_value_neko_alloc_float$388;
  struct _value *return_value_neko_alloc_float$389;
  struct _value *tmp_if_expr$391;
  struct _value *return_value_neko_alloc_int32$390;
  struct _value *return_value_neko_alloc_float$392;
  struct _value *return_value_neko_alloc_string$393;
  signed long int *tmp_post$396;
  signed long int *tmp_post$397;
  signed long int *tmp_post$398;
  signed long int *tmp_post$399;
  struct _value *return_value_neko_alloc_string$400;
  struct _value *return_value_neko_alloc_string$403;
  signed long int *tmp_post$406;
  signed long int *tmp_post$407;
  signed long int *tmp_post$408;
  signed long int *tmp_post$409;
  struct _value *return_value_neko_alloc_string$410;
  signed long int *tmp_post$414;
  _Bool tmp_if_expr$474;
  struct _value *tmp_if_expr$416;
  struct _value *return_value_neko_alloc_int32$415;
  struct _value *return_value_neko_alloc_float$417;
  struct _value *tmp_if_expr$419;
  struct _value *return_value_neko_alloc_int32$418;
  struct _value *return_value_neko_alloc_string$420;
  struct _value *return_value_neko_alloc_string$423;
  signed long int *tmp_post$426;
  signed long int *tmp_post$427;
  signed long int *tmp_post$428;
  signed long int *tmp_post$429;
  struct _value *return_value_neko_alloc_string$430;
  struct _value *return_value_neko_alloc_float$433;
  struct _value *tmp_if_expr$435;
  struct _value *return_value_neko_alloc_int32$434;
  struct _value *return_value_neko_alloc_string$436;
  struct _value *return_value_neko_alloc_string$439;
  signed long int *tmp_post$442;
  signed long int *tmp_post$443;
  signed long int *tmp_post$444;
  signed long int *tmp_post$445;
  struct _value *return_value_neko_alloc_string$446;
  struct _value *return_value_neko_alloc_float$449;
  struct _value *return_value_neko_alloc_float$450;
  struct _value *tmp_if_expr$452;
  struct _value *return_value_neko_alloc_int32$451;
  struct _value *return_value_neko_alloc_float$453;
  struct _value *return_value_neko_alloc_string$454;
  signed long int *tmp_post$457;
  signed long int *tmp_post$458;
  signed long int *tmp_post$459;
  signed long int *tmp_post$460;
  struct _value *return_value_neko_alloc_string$461;
  struct _value *return_value_neko_alloc_string$464;
  signed long int *tmp_post$467;
  signed long int *tmp_post$468;
  signed long int *tmp_post$469;
  signed long int *tmp_post$470;
  struct _value *return_value_neko_alloc_string$471;
  signed long int *tmp_post$475;
  _Bool tmp_if_expr$503;
  _Bool tmp_if_expr$504;
  _Bool tmp_if_expr$507;
  _Bool tmp_if_expr$505;
  _Bool tmp_if_expr$506;
  double tmp_if_expr$477;
  double tmp_if_expr$476;
  double tmp_if_expr$479;
  double tmp_if_expr$478;
  struct _value *return_value_neko_alloc_float$480;
  _Bool tmp_if_expr$502;
  struct _value *return_value_neko_alloc_string$481;
  signed long int *tmp_post$484;
  signed long int *tmp_post$485;
  signed long int *tmp_post$486;
  signed long int *tmp_post$487;
  _Bool tmp_if_expr$501;
  struct _value *return_value_neko_alloc_string$488;
  struct _value *return_value_neko_alloc_string$491;
  signed long int *tmp_post$494;
  signed long int *tmp_post$495;
  signed long int *tmp_post$496;
  signed long int *tmp_post$497;
  struct _value *return_value_neko_alloc_string$498;
  signed long int *tmp_post$508;
  _Bool tmp_if_expr$515;
  _Bool tmp_if_expr$513;
  _Bool tmp_if_expr$514;
  _Bool tmp_if_expr$512;
  struct _value *return_value_neko_alloc_string$509;
  _Bool tmp_if_expr$580;
  struct _value *tmp_if_expr$517;
  struct _value *return_value_neko_alloc_int32$516;
  double return_value_fmod$518;
  struct _value *return_value_neko_alloc_float$519;
  struct _value *tmp_if_expr$521;
  struct _value *return_value_neko_alloc_int32$520;
  struct _value *return_value_neko_alloc_string$522;
  struct _value *return_value_neko_alloc_string$525;
  signed long int *tmp_post$528;
  signed long int *tmp_post$529;
  signed long int *tmp_post$530;
  signed long int *tmp_post$531;
  struct _value *return_value_neko_alloc_string$532;
  double return_value_fmod$535;
  struct _value *return_value_neko_alloc_float$536;
  struct _value *tmp_if_expr$538;
  struct _value *return_value_neko_alloc_int32$537;
  struct _value *return_value_neko_alloc_string$539;
  struct _value *return_value_neko_alloc_string$542;
  signed long int *tmp_post$545;
  signed long int *tmp_post$546;
  signed long int *tmp_post$547;
  signed long int *tmp_post$548;
  struct _value *return_value_neko_alloc_string$549;
  double return_value_fmod$552;
  struct _value *return_value_neko_alloc_float$553;
  double return_value_fmod$554;
  struct _value *return_value_neko_alloc_float$555;
  struct _value *tmp_if_expr$557;
  struct _value *return_value_neko_alloc_int32$556;
  double return_value_fmod$558;
  struct _value *return_value_neko_alloc_float$559;
  struct _value *return_value_neko_alloc_string$560;
  signed long int *tmp_post$563;
  signed long int *tmp_post$564;
  signed long int *tmp_post$565;
  signed long int *tmp_post$566;
  struct _value *return_value_neko_alloc_string$567;
  struct _value *return_value_neko_alloc_string$570;
  signed long int *tmp_post$573;
  signed long int *tmp_post$574;
  signed long int *tmp_post$575;
  signed long int *tmp_post$576;
  struct _value *return_value_neko_alloc_string$577;
  signed long int *tmp_post$581;
  _Bool tmp_if_expr$598;
  struct _value *tmp_if_expr$583;
  struct _value *return_value_neko_alloc_int32$582;
  _Bool tmp_if_expr$595;
  _Bool tmp_if_expr$597;
  _Bool tmp_if_expr$596;
  signed int tmp_if_expr$584;
  signed int tmp_if_expr$585;
  struct _value *tmp_if_expr$591;
  signed int tmp_if_expr$586;
  signed int tmp_if_expr$587;
  struct _value *return_value_neko_alloc_int32$588;
  signed int tmp_if_expr$589;
  signed int tmp_if_expr$590;
  struct _value *return_value_neko_alloc_string$592;
  signed long int *tmp_post$599;
  _Bool tmp_if_expr$616;
  struct _value *tmp_if_expr$601;
  struct _value *return_value_neko_alloc_int32$600;
  _Bool tmp_if_expr$613;
  _Bool tmp_if_expr$615;
  _Bool tmp_if_expr$614;
  signed int tmp_if_expr$602;
  signed int tmp_if_expr$603;
  struct _value *tmp_if_expr$609;
  signed int tmp_if_expr$604;
  signed int tmp_if_expr$605;
  struct _value *return_value_neko_alloc_int32$606;
  signed int tmp_if_expr$607;
  signed int tmp_if_expr$608;
  struct _value *return_value_neko_alloc_string$610;
  signed long int *tmp_post$617;
  _Bool tmp_if_expr$634;
  struct _value *tmp_if_expr$619;
  struct _value *return_value_neko_alloc_int32$618;
  _Bool tmp_if_expr$631;
  _Bool tmp_if_expr$633;
  _Bool tmp_if_expr$632;
  signed int tmp_if_expr$620;
  signed int tmp_if_expr$621;
  struct _value *tmp_if_expr$627;
  signed int tmp_if_expr$622;
  signed int tmp_if_expr$623;
  struct _value *return_value_neko_alloc_int32$624;
  signed int tmp_if_expr$625;
  signed int tmp_if_expr$626;
  struct _value *return_value_neko_alloc_string$628;
  signed long int *tmp_post$635;
  _Bool tmp_if_expr$652;
  struct _value *tmp_if_expr$637;
  struct _value *return_value_neko_alloc_int32$636;
  _Bool tmp_if_expr$649;
  _Bool tmp_if_expr$651;
  _Bool tmp_if_expr$650;
  signed int tmp_if_expr$638;
  signed int tmp_if_expr$639;
  struct _value *tmp_if_expr$645;
  signed int tmp_if_expr$640;
  signed int tmp_if_expr$641;
  struct _value *return_value_neko_alloc_int32$642;
  signed int tmp_if_expr$643;
  signed int tmp_if_expr$644;
  struct _value *return_value_neko_alloc_string$646;
  signed long int *tmp_post$653;
  _Bool tmp_if_expr$670;
  struct _value *tmp_if_expr$655;
  struct _value *return_value_neko_alloc_int32$654;
  _Bool tmp_if_expr$667;
  _Bool tmp_if_expr$669;
  _Bool tmp_if_expr$668;
  signed int tmp_if_expr$656;
  signed int tmp_if_expr$657;
  struct _value *tmp_if_expr$663;
  signed int tmp_if_expr$658;
  signed int tmp_if_expr$659;
  struct _value *return_value_neko_alloc_int32$660;
  signed int tmp_if_expr$661;
  signed int tmp_if_expr$662;
  struct _value *return_value_neko_alloc_string$664;
  signed long int *tmp_post$671;
  _Bool tmp_if_expr$688;
  struct _value *tmp_if_expr$673;
  struct _value *return_value_neko_alloc_int32$672;
  _Bool tmp_if_expr$685;
  _Bool tmp_if_expr$687;
  _Bool tmp_if_expr$686;
  signed int tmp_if_expr$674;
  signed int tmp_if_expr$675;
  struct _value *tmp_if_expr$681;
  signed int tmp_if_expr$676;
  signed int tmp_if_expr$677;
  struct _value *return_value_neko_alloc_int32$678;
  signed int tmp_if_expr$679;
  signed int tmp_if_expr$680;
  struct _value *return_value_neko_alloc_string$682;
  signed long int *tmp_post$689;
  signed int return_value_neko_val_compare$690;
  signed long int *tmp_post$691;
  signed int return_value_neko_val_compare$692;
  signed long int *tmp_post$693;
  signed int return_value_neko_val_compare$694;
  signed long int *tmp_post$695;
  signed int return_value_neko_val_compare$696;
  signed long int *tmp_post$697;
  signed int return_value_neko_val_compare$698;
  signed long int *tmp_post$699;
  signed int return_value_neko_val_compare$700;
  signed long int *tmp_post$701;
  struct _value *tmp_if_expr$702;
  signed int return_value_neko_val_compare$703;
  signed long int *tmp_post$704;
  struct _value *tmp_if_expr$705;
  signed long int *tmp_post$706;
  _Bool tmp_if_expr$711;
  struct _value *return_value_neko_alloc_string$708;
  struct _value *return_value_neko_alloc_object$712;
  _Bool tmp_if_expr$713;
  static void *instructions[68l] = { &&LabelAccNull, &&LabelAccTrue, &&LabelAccFalse, &&LabelAccThis, &&LabelAccInt, &&LabelAccStack, &&LabelAccGlobal, &&LabelAccEnv, &&LabelAccField, &&LabelAccArray, &&LabelAccIndex, &&LabelAccBuiltin, &&LabelSetStack, &&LabelSetGlobal, &&LabelSetEnv, &&LabelSetField, &&LabelSetArray, &&LabelSetIndex, &&LabelSetThis, &&LabelPush, &&LabelPop, &&LabelCall, &&LabelObjCall, &&LabelJump, &&LabelJumpIf, &&LabelJumpIfNot, &&LabelTrap, &&LabelEndTrap, &&LabelRet, &&LabelMakeEnv, &&LabelMakeArray, &&LabelBool, &&LabelIsNull, &&LabelIsNotNull, &&LabelAdd, &&LabelSub, &&LabelMult, &&LabelDiv, &&LabelMod, &&LabelShl, &&LabelShr, &&LabelUShr, &&LabelOr, &&LabelAnd, &&LabelXor, &&LabelEq, &&LabelNeq, &&LabelGt, &&LabelGte, &&LabelLt, &&LabelLte, &&LabelNot, &&LabelTypeOf, &&LabelCompare, &&LabelHash, &&LabelNew, &&LabelJumpTable, &&LabelApply, &&LabelAccStack0, &&LabelAccStack1, &&LabelAccIndex0, &&LabelAccIndex1, &&LabelPhysCompare, &&LabelTailCall, &&LabelLoop, &&LabelMakeArray2, &&LabelAccInt32, &&LabelLast };
  if(m == ((struct _neko_module *)NULL))
    return (signed long int)instructions;

  else
  {
    signed long int *sp = vm->sp;
    signed long int *csp = vm->csp;
    *pc++;
    if(!(*pc++ == &&id_mod_next2))
    {
      if(!(*pc++ == &&id_mod_next))
      {
        if(!(*pc++ == &&div_next))
        {
          if(!(*pc++ == &&id_mult_next2))
          {
            if(!(*pc++ == &&id_mult_next))
            {
              if(!(*pc++ == &&id_sub_next2))
              {
                if(!(*pc++ == &&id_sub_next))
                {
                  if(!(*pc++ == &&add_3))
                  {
                    if(!(*pc++ == &&add_2))
                    {
                      if(!(*pc++ == &&add_next))
                      {
                        if(!(*pc++ == &&do_call))
                        {
                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(!(*pc++ == &&LabelAccInt32))
                          {
                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(!(*pc++ == &&LabelAccInt))
                            {
                              if(!(*pc++ == &&LabelAccThis))
                              {
                                if(!(*pc++ == &&LabelAccFalse))
                                {
                                  if(!(*pc++ == &&LabelAccTrue))
                                  {
                                    if(!(*pc++ == &&LabelAccNull))
                                    {
                                      if(*pc++ == &&end)
                                        goto end;

                                    }

                                    do
                                    {

                                    LabelAccNull:
                                      ;
                                      acc = (signed long int)val_null;
                                      *pc++;
                                      if(*pc++ == &&id_mod_next2)
                                        goto id_mod_next2;

                                      if(*pc++ == &&id_mod_next)
                                        goto id_mod_next;

                                      if(*pc++ == &&div_next)
                                        goto div_next;

                                      if(*pc++ == &&id_mult_next2)
                                        goto id_mult_next2;

                                      if(*pc++ == &&id_mult_next)
                                        goto id_mult_next;

                                      if(*pc++ == &&id_sub_next2)
                                        goto id_sub_next2;

                                      if(*pc++ == &&id_sub_next)
                                        goto id_sub_next;

                                      if(*pc++ == &&add_3)
                                        goto add_3;

                                      if(*pc++ == &&add_2)
                                        goto add_2;

                                      if(*pc++ == &&add_next)
                                        goto add_next;

                                      if(*pc++ == &&do_call)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelLast)
                                        goto LabelLast;

                                      if(*pc++ == &&LabelAccInt32)
                                        goto LabelAccInt32;

                                      if(*pc++ == &&LabelMakeArray2)
                                        goto LabelMakeArray2;

                                      if(*pc++ == &&LabelLoop)
                                        goto LabelLoop;

                                      if(*pc++ == &&LabelTailCall)
                                        goto LabelTailCall;

                                      if(*pc++ == &&LabelPhysCompare)
                                        goto LabelPhysCompare;

                                      if(*pc++ == &&LabelAccIndex1)
                                        goto LabelAccIndex1;

                                      if(*pc++ == &&LabelAccIndex0)
                                        goto LabelAccIndex0;

                                      if(*pc++ == &&LabelAccStack1)
                                        goto LabelAccStack1;

                                      if(*pc++ == &&LabelAccStack0)
                                        goto LabelAccStack0;

                                      if(*pc++ == &&LabelApply)
                                        goto LabelApply;

                                      if(*pc++ == &&LabelJumpTable)
                                        goto LabelJumpTable;

                                      if(*pc++ == &&LabelNew)
                                        goto LabelNew;

                                      if(*pc++ == &&LabelHash)
                                        goto LabelHash;

                                      if(*pc++ == &&LabelCompare)
                                        goto LabelCompare;

                                      if(*pc++ == &&LabelTypeOf)
                                        goto LabelTypeOf;

                                      if(*pc++ == &&LabelNot)
                                        goto LabelNot;

                                      if(*pc++ == &&LabelLte)
                                        goto LabelLte;

                                      if(*pc++ == &&LabelLt)
                                        goto LabelLt;

                                      if(*pc++ == &&LabelGte)
                                        goto LabelGte;

                                      if(*pc++ == &&LabelGt)
                                        goto LabelGt;

                                      if(*pc++ == &&LabelNeq)
                                        goto LabelNeq;

                                      if(*pc++ == &&LabelEq)
                                        goto LabelEq;

                                      if(*pc++ == &&LabelXor)
                                        goto LabelXor;

                                      if(*pc++ == &&LabelAnd)
                                        goto LabelAnd;

                                      if(*pc++ == &&LabelOr)
                                        goto LabelOr;

                                      if(*pc++ == &&LabelUShr)
                                        goto LabelUShr;

                                      if(*pc++ == &&LabelShr)
                                        goto LabelShr;

                                      if(*pc++ == &&LabelShl)
                                        goto LabelShl;

                                      if(*pc++ == &&LabelMod)
                                        goto LabelMod;

                                      if(*pc++ == &&LabelDiv)
                                        goto LabelDiv;

                                      if(*pc++ == &&LabelMult)
                                        goto LabelMult;

                                      if(*pc++ == &&LabelSub)
                                        goto LabelSub;

                                      if(*pc++ == &&LabelAdd)
                                        goto LabelAdd;

                                      if(*pc++ == &&LabelIsNotNull)
                                        goto LabelIsNotNull;

                                      if(*pc++ == &&LabelIsNull)
                                        goto LabelIsNull;

                                      if(*pc++ == &&LabelBool)
                                        goto LabelBool;

                                      if(*pc++ == &&LabelMakeArray)
                                        goto LabelMakeArray;

                                      if(*pc++ == &&LabelMakeEnv)
                                        goto LabelMakeEnv;

                                      if(*pc++ == &&LabelRet)
                                        goto LabelRet;

                                      if(*pc++ == &&LabelEndTrap)
                                        goto LabelEndTrap;

                                      if(*pc++ == &&LabelTrap)
                                        goto LabelTrap;

                                      if(*pc++ == &&LabelJumpIfNot)
                                        goto LabelJumpIfNot;

                                      if(*pc++ == &&LabelJumpIf)
                                        goto LabelJumpIf;

                                      if(*pc++ == &&LabelJump)
                                        goto LabelJump;

                                      if(*pc++ == &&LabelObjCall)
                                        goto LabelObjCall;

                                      if(*pc++ == &&LabelCall)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelPop)
                                        goto LabelPop;

                                      if(*pc++ == &&LabelPush)
                                        goto LabelPush;

                                      if(*pc++ == &&LabelSetThis)
                                        goto LabelSetThis;

                                      if(*pc++ == &&LabelSetIndex)
                                        goto LabelSetIndex;

                                      if(*pc++ == &&LabelSetArray)
                                        goto LabelSetArray;

                                      if(*pc++ == &&LabelSetField)
                                        goto LabelSetField;

                                      if(*pc++ == &&LabelSetEnv)
                                        goto LabelSetEnv;

                                      if(*pc++ == &&LabelSetGlobal)
                                        goto LabelSetGlobal;

                                      if(*pc++ == &&LabelSetStack)
                                        goto LabelSetStack;

                                      if(*pc++ == &&LabelAccBuiltin)
                                        goto LabelAccBuiltin;

                                      if(*pc++ == &&LabelAccIndex)
                                        goto LabelAccIndex;

                                      if(*pc++ == &&LabelAccArray)
                                        goto LabelAccArray;

                                      if(*pc++ == &&LabelAccField)
                                        goto LabelAccField;

                                      if(*pc++ == &&LabelAccEnv)
                                        goto LabelAccEnv;

                                      if(*pc++ == &&LabelAccGlobal)
                                        goto LabelAccGlobal;

                                      if(*pc++ == &&LabelAccStack)
                                        goto LabelAccStack;

                                      if(*pc++ == &&LabelAccInt)
                                        goto LabelAccInt;

                                      if(*pc++ == &&LabelAccThis)
                                        goto LabelAccThis;

                                      if(*pc++ == &&LabelAccFalse)
                                        goto LabelAccFalse;

                                      if(*pc++ == &&LabelAccTrue)
                                        goto LabelAccTrue;

                                    }
                                    while(*pc++ == &&LabelAccNull);
                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelAccTrue:
                                    ;
                                    acc = (signed long int)val_true;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                    if(*pc++ == &&LabelAccStack0)
                                      goto LabelAccStack0;

                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                    if(*pc++ == &&LabelSetThis)
                                      goto LabelSetThis;

                                    if(*pc++ == &&LabelSetIndex)
                                      goto LabelSetIndex;

                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                    if(*pc++ == &&LabelAccField)
                                      goto LabelAccField;

                                    if(*pc++ == &&LabelAccEnv)
                                      goto LabelAccEnv;

                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                  }
                                  while(*pc++ == &&LabelAccTrue);
                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelAccFalse:
                                  ;
                                  acc = (signed long int)val_false;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                }
                                while(*pc++ == &&LabelAccFalse);
                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelAccThis:
                                ;
                                acc = (signed long int)vm->vthis;
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                                if(*pc++ == &&LabelAccIndex0)
                                  goto LabelAccIndex0;

                                if(*pc++ == &&LabelAccStack1)
                                  goto LabelAccStack1;

                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                                if(*pc++ == &&LabelShr)
                                  goto LabelShr;

                                if(*pc++ == &&LabelShl)
                                  goto LabelShl;

                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                                if(*pc++ == &&LabelPop)
                                  goto LabelPop;

                                if(*pc++ == &&LabelPush)
                                  goto LabelPush;

                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(*pc++ == &&LabelAccArray)
                                  goto LabelAccArray;

                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                              }
                              while(*pc++ == &&LabelAccThis);
                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelAccInt:
                              ;
                              tmp_post$1 = pc;
                              pc = pc + 1l;
                              acc = *tmp_post$1;
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                            }
                            while(*pc++ == &&LabelAccInt);
                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelAccInt32:
                            ;
                            tmp_post$2 = pc;
                            pc = pc + 1l;
                            return_value_neko_alloc_int32$3=neko_alloc_int32((signed int)*tmp_post$2);
                            acc = (signed long int)return_value_neko_alloc_int32$3;
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                          }
                          while(*pc++ == &&LabelAccInt32);
                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(!(*pc++ == &&LabelTailCall))
                          {
                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(!(*pc++ == &&LabelAccIndex1))
                            {
                              if(!(*pc++ == &&LabelAccIndex0))
                              {
                                if(!(*pc++ == &&LabelAccStack1))
                                {
                                  if(!(*pc++ == &&LabelAccStack0))
                                  {
                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                    if(*pc++ == &&LabelSetThis)
                                      goto LabelSetThis;

                                    if(*pc++ == &&LabelSetIndex)
                                      goto LabelSetIndex;

                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                    if(*pc++ == &&LabelAccField)
                                      goto LabelAccField;

                                    if(*pc++ == &&LabelAccEnv)
                                      goto LabelAccEnv;

                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                    if(*pc++ == &&LabelAccTrue)
                                      goto LabelAccTrue;

                                    if(*pc++ == &&LabelAccNull)
                                      goto LabelAccNull;

                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelAccStack0:
                                    ;
                                    acc = *sp;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                  }
                                  while(*pc++ == &&LabelAccStack0);
                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelAccStack1:
                                  ;
                                  acc = sp[(signed long int)1];
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                }
                                while(*pc++ == &&LabelAccStack1);
                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                                if(*pc++ == &&LabelShr)
                                  goto LabelShr;

                                if(*pc++ == &&LabelShl)
                                  goto LabelShl;

                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                                if(*pc++ == &&LabelPop)
                                  goto LabelPop;

                                if(*pc++ == &&LabelPush)
                                  goto LabelPush;

                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(!(*pc++ == &&LabelAccArray))
                                {
                                  if(!(*pc++ == &&LabelAccField))
                                  {
                                    if(!(*pc++ == &&LabelAccEnv))
                                    {
                                      if(!(*pc++ == &&LabelAccGlobal))
                                      {
                                        if(!(*pc++ == &&LabelAccStack))
                                        {
                                          if(*pc++ == &&LabelAccInt)
                                            goto LabelAccInt;

                                          if(*pc++ == &&LabelAccThis)
                                            goto LabelAccThis;

                                          if(*pc++ == &&LabelAccFalse)
                                            goto LabelAccFalse;

                                          if(*pc++ == &&LabelAccTrue)
                                            goto LabelAccTrue;

                                          if(*pc++ == &&LabelAccNull)
                                            goto LabelAccNull;

                                          if(*pc++ == &&end)
                                            goto end;

                                        }

                                        do
                                        {

                                        LabelAccStack:
                                          ;
                                          tmp_post$4 = pc;
                                          pc = pc + 1l;
                                          acc = sp[*tmp_post$4];
                                          *pc++;
                                          if(*pc++ == &&id_mod_next2)
                                            goto id_mod_next2;

                                          if(*pc++ == &&id_mod_next)
                                            goto id_mod_next;

                                          if(*pc++ == &&div_next)
                                            goto div_next;

                                          if(*pc++ == &&id_mult_next2)
                                            goto id_mult_next2;

                                          if(*pc++ == &&id_mult_next)
                                            goto id_mult_next;

                                          if(*pc++ == &&id_sub_next2)
                                            goto id_sub_next2;

                                          if(*pc++ == &&id_sub_next)
                                            goto id_sub_next;

                                          if(*pc++ == &&add_3)
                                            goto add_3;

                                          if(*pc++ == &&add_2)
                                            goto add_2;

                                          if(*pc++ == &&add_next)
                                            goto add_next;

                                          if(*pc++ == &&do_call)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelLast)
                                            goto LabelLast;

                                          if(*pc++ == &&LabelAccInt32)
                                            goto LabelAccInt32;

                                          if(*pc++ == &&LabelMakeArray2)
                                            goto LabelMakeArray2;

                                          if(*pc++ == &&LabelLoop)
                                            goto LabelLoop;

                                          if(*pc++ == &&LabelTailCall)
                                            goto LabelTailCall;

                                          if(*pc++ == &&LabelPhysCompare)
                                            goto LabelPhysCompare;

                                          if(*pc++ == &&LabelAccIndex1)
                                            goto LabelAccIndex1;

                                          if(*pc++ == &&LabelAccIndex0)
                                            goto LabelAccIndex0;

                                          if(*pc++ == &&LabelAccStack1)
                                            goto LabelAccStack1;

                                          if(*pc++ == &&LabelAccStack0)
                                            goto LabelAccStack0;

                                          if(*pc++ == &&LabelApply)
                                            goto LabelApply;

                                          if(*pc++ == &&LabelJumpTable)
                                            goto LabelJumpTable;

                                          if(*pc++ == &&LabelNew)
                                            goto LabelNew;

                                          if(*pc++ == &&LabelHash)
                                            goto LabelHash;

                                          if(*pc++ == &&LabelCompare)
                                            goto LabelCompare;

                                          if(*pc++ == &&LabelTypeOf)
                                            goto LabelTypeOf;

                                          if(*pc++ == &&LabelNot)
                                            goto LabelNot;

                                          if(*pc++ == &&LabelLte)
                                            goto LabelLte;

                                          if(*pc++ == &&LabelLt)
                                            goto LabelLt;

                                          if(*pc++ == &&LabelGte)
                                            goto LabelGte;

                                          if(*pc++ == &&LabelGt)
                                            goto LabelGt;

                                          if(*pc++ == &&LabelNeq)
                                            goto LabelNeq;

                                          if(*pc++ == &&LabelEq)
                                            goto LabelEq;

                                          if(*pc++ == &&LabelXor)
                                            goto LabelXor;

                                          if(*pc++ == &&LabelAnd)
                                            goto LabelAnd;

                                          if(*pc++ == &&LabelOr)
                                            goto LabelOr;

                                          if(*pc++ == &&LabelUShr)
                                            goto LabelUShr;

                                          if(*pc++ == &&LabelShr)
                                            goto LabelShr;

                                          if(*pc++ == &&LabelShl)
                                            goto LabelShl;

                                          if(*pc++ == &&LabelMod)
                                            goto LabelMod;

                                          if(*pc++ == &&LabelDiv)
                                            goto LabelDiv;

                                          if(*pc++ == &&LabelMult)
                                            goto LabelMult;

                                          if(*pc++ == &&LabelSub)
                                            goto LabelSub;

                                          if(*pc++ == &&LabelAdd)
                                            goto LabelAdd;

                                          if(*pc++ == &&LabelIsNotNull)
                                            goto LabelIsNotNull;

                                          if(*pc++ == &&LabelIsNull)
                                            goto LabelIsNull;

                                          if(*pc++ == &&LabelBool)
                                            goto LabelBool;

                                          if(*pc++ == &&LabelMakeArray)
                                            goto LabelMakeArray;

                                          if(*pc++ == &&LabelMakeEnv)
                                            goto LabelMakeEnv;

                                          if(*pc++ == &&LabelRet)
                                            goto LabelRet;

                                          if(*pc++ == &&LabelEndTrap)
                                            goto LabelEndTrap;

                                          if(*pc++ == &&LabelTrap)
                                            goto LabelTrap;

                                          if(*pc++ == &&LabelJumpIfNot)
                                            goto LabelJumpIfNot;

                                          if(*pc++ == &&LabelJumpIf)
                                            goto LabelJumpIf;

                                          if(*pc++ == &&LabelJump)
                                            goto LabelJump;

                                          if(*pc++ == &&LabelObjCall)
                                            goto LabelObjCall;

                                          if(*pc++ == &&LabelCall)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelPop)
                                            goto LabelPop;

                                          if(*pc++ == &&LabelPush)
                                            goto LabelPush;

                                          if(*pc++ == &&LabelSetThis)
                                            goto LabelSetThis;

                                          if(*pc++ == &&LabelSetIndex)
                                            goto LabelSetIndex;

                                          if(*pc++ == &&LabelSetArray)
                                            goto LabelSetArray;

                                          if(*pc++ == &&LabelSetField)
                                            goto LabelSetField;

                                          if(*pc++ == &&LabelSetEnv)
                                            goto LabelSetEnv;

                                          if(*pc++ == &&LabelSetGlobal)
                                            goto LabelSetGlobal;

                                          if(*pc++ == &&LabelSetStack)
                                            goto LabelSetStack;

                                          if(*pc++ == &&LabelAccBuiltin)
                                            goto LabelAccBuiltin;

                                          if(*pc++ == &&LabelAccIndex)
                                            goto LabelAccIndex;

                                          if(*pc++ == &&LabelAccArray)
                                            goto LabelAccArray;

                                          if(*pc++ == &&LabelAccField)
                                            goto LabelAccField;

                                          if(*pc++ == &&LabelAccEnv)
                                            goto LabelAccEnv;

                                          if(*pc++ == &&LabelAccGlobal)
                                            goto LabelAccGlobal;

                                        }
                                        while(*pc++ == &&LabelAccStack);
                                        if(*pc++ == &&LabelAccInt)
                                          goto LabelAccInt;

                                        if(*pc++ == &&LabelAccThis)
                                          goto LabelAccThis;

                                        if(*pc++ == &&LabelAccFalse)
                                          goto LabelAccFalse;

                                        if(*pc++ == &&LabelAccTrue)
                                          goto LabelAccTrue;

                                        if(*pc++ == &&LabelAccNull)
                                          goto LabelAccNull;

                                        if(*pc++ == &&end)
                                          goto end;

                                      }

                                      do
                                      {

                                      LabelAccGlobal:
                                        ;
                                        tmp_post$5 = pc;
                                        pc = pc + 1l;
                                        acc = *((signed long int *)*tmp_post$5);
                                        *pc++;
                                        if(*pc++ == &&id_mod_next2)
                                          goto id_mod_next2;

                                        if(*pc++ == &&id_mod_next)
                                          goto id_mod_next;

                                        if(*pc++ == &&div_next)
                                          goto div_next;

                                        if(*pc++ == &&id_mult_next2)
                                          goto id_mult_next2;

                                        if(*pc++ == &&id_mult_next)
                                          goto id_mult_next;

                                        if(*pc++ == &&id_sub_next2)
                                          goto id_sub_next2;

                                        if(*pc++ == &&id_sub_next)
                                          goto id_sub_next;

                                        if(*pc++ == &&add_3)
                                          goto add_3;

                                        if(*pc++ == &&add_2)
                                          goto add_2;

                                        if(*pc++ == &&add_next)
                                          goto add_next;

                                        if(*pc++ == &&do_call)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelLast)
                                          goto LabelLast;

                                        if(*pc++ == &&LabelAccInt32)
                                          goto LabelAccInt32;

                                        if(*pc++ == &&LabelMakeArray2)
                                          goto LabelMakeArray2;

                                        if(*pc++ == &&LabelLoop)
                                          goto LabelLoop;

                                        if(*pc++ == &&LabelTailCall)
                                          goto LabelTailCall;

                                        if(*pc++ == &&LabelPhysCompare)
                                          goto LabelPhysCompare;

                                        if(*pc++ == &&LabelAccIndex1)
                                          goto LabelAccIndex1;

                                        if(*pc++ == &&LabelAccIndex0)
                                          goto LabelAccIndex0;

                                        if(*pc++ == &&LabelAccStack1)
                                          goto LabelAccStack1;

                                        if(*pc++ == &&LabelAccStack0)
                                          goto LabelAccStack0;

                                        if(*pc++ == &&LabelApply)
                                          goto LabelApply;

                                        if(*pc++ == &&LabelJumpTable)
                                          goto LabelJumpTable;

                                        if(*pc++ == &&LabelNew)
                                          goto LabelNew;

                                        if(*pc++ == &&LabelHash)
                                          goto LabelHash;

                                        if(*pc++ == &&LabelCompare)
                                          goto LabelCompare;

                                        if(*pc++ == &&LabelTypeOf)
                                          goto LabelTypeOf;

                                        if(*pc++ == &&LabelNot)
                                          goto LabelNot;

                                        if(*pc++ == &&LabelLte)
                                          goto LabelLte;

                                        if(*pc++ == &&LabelLt)
                                          goto LabelLt;

                                        if(*pc++ == &&LabelGte)
                                          goto LabelGte;

                                        if(*pc++ == &&LabelGt)
                                          goto LabelGt;

                                        if(*pc++ == &&LabelNeq)
                                          goto LabelNeq;

                                        if(*pc++ == &&LabelEq)
                                          goto LabelEq;

                                        if(*pc++ == &&LabelXor)
                                          goto LabelXor;

                                        if(*pc++ == &&LabelAnd)
                                          goto LabelAnd;

                                        if(*pc++ == &&LabelOr)
                                          goto LabelOr;

                                        if(*pc++ == &&LabelUShr)
                                          goto LabelUShr;

                                        if(*pc++ == &&LabelShr)
                                          goto LabelShr;

                                        if(*pc++ == &&LabelShl)
                                          goto LabelShl;

                                        if(*pc++ == &&LabelMod)
                                          goto LabelMod;

                                        if(*pc++ == &&LabelDiv)
                                          goto LabelDiv;

                                        if(*pc++ == &&LabelMult)
                                          goto LabelMult;

                                        if(*pc++ == &&LabelSub)
                                          goto LabelSub;

                                        if(*pc++ == &&LabelAdd)
                                          goto LabelAdd;

                                        if(*pc++ == &&LabelIsNotNull)
                                          goto LabelIsNotNull;

                                        if(*pc++ == &&LabelIsNull)
                                          goto LabelIsNull;

                                        if(*pc++ == &&LabelBool)
                                          goto LabelBool;

                                        if(*pc++ == &&LabelMakeArray)
                                          goto LabelMakeArray;

                                        if(*pc++ == &&LabelMakeEnv)
                                          goto LabelMakeEnv;

                                        if(*pc++ == &&LabelRet)
                                          goto LabelRet;

                                        if(*pc++ == &&LabelEndTrap)
                                          goto LabelEndTrap;

                                        if(*pc++ == &&LabelTrap)
                                          goto LabelTrap;

                                        if(*pc++ == &&LabelJumpIfNot)
                                          goto LabelJumpIfNot;

                                        if(*pc++ == &&LabelJumpIf)
                                          goto LabelJumpIf;

                                        if(*pc++ == &&LabelJump)
                                          goto LabelJump;

                                        if(*pc++ == &&LabelObjCall)
                                          goto LabelObjCall;

                                        if(*pc++ == &&LabelCall)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelPop)
                                          goto LabelPop;

                                        if(*pc++ == &&LabelPush)
                                          goto LabelPush;

                                        if(*pc++ == &&LabelSetThis)
                                          goto LabelSetThis;

                                        if(*pc++ == &&LabelSetIndex)
                                          goto LabelSetIndex;

                                        if(*pc++ == &&LabelSetArray)
                                          goto LabelSetArray;

                                        if(*pc++ == &&LabelSetField)
                                          goto LabelSetField;

                                        if(*pc++ == &&LabelSetEnv)
                                          goto LabelSetEnv;

                                        if(*pc++ == &&LabelSetGlobal)
                                          goto LabelSetGlobal;

                                        if(*pc++ == &&LabelSetStack)
                                          goto LabelSetStack;

                                        if(*pc++ == &&LabelAccBuiltin)
                                          goto LabelAccBuiltin;

                                        if(*pc++ == &&LabelAccIndex)
                                          goto LabelAccIndex;

                                        if(*pc++ == &&LabelAccArray)
                                          goto LabelAccArray;

                                        if(*pc++ == &&LabelAccField)
                                          goto LabelAccField;

                                        if(*pc++ == &&LabelAccEnv)
                                          goto LabelAccEnv;

                                      }
                                      while(*pc++ == &&LabelAccGlobal);
                                      if(*pc++ == &&LabelAccStack)
                                        goto LabelAccStack;

                                      if(*pc++ == &&LabelAccInt)
                                        goto LabelAccInt;

                                      if(*pc++ == &&LabelAccThis)
                                        goto LabelAccThis;

                                      if(*pc++ == &&LabelAccFalse)
                                        goto LabelAccFalse;

                                      if(*pc++ == &&LabelAccTrue)
                                        goto LabelAccTrue;

                                      if(*pc++ == &&LabelAccNull)
                                        goto LabelAccNull;

                                      if(*pc++ == &&end)
                                        goto end;

                                    }


                                  LabelAccEnv:
                                    ;
                                    while((_Bool)1)
                                    {
                                      if(*pc >= (signed long int)((signed int)*((enum anonymous$7 *)vm->env) >> 4))
                                      {
                                        pc = pc + 1l;
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand$7;
                                          return_value_neko_stack_expand$7=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand$7 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string$6=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string$6);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string$8;
                                        return_value_neko_alloc_string$8=neko_alloc_string("Reading Outside Env");
                                        neko_val_throw(return_value_neko_alloc_string$8);
                                      }

                                      tmp_post$9 = pc;
                                      pc = pc + 1l;
                                      acc = (signed long int)(&((struct anonymous$4 *)vm->env)->ptr)[*tmp_post$9];
                                      *pc++;
                                      if(*pc++ == &&id_mod_next2)
                                        goto id_mod_next2;

                                      if(*pc++ == &&id_mod_next)
                                        goto id_mod_next;

                                      if(*pc++ == &&div_next)
                                        goto div_next;

                                      if(*pc++ == &&id_mult_next2)
                                        goto id_mult_next2;

                                      if(*pc++ == &&id_mult_next)
                                        goto id_mult_next;

                                      if(*pc++ == &&id_sub_next2)
                                        goto id_sub_next2;

                                      if(*pc++ == &&id_sub_next)
                                        goto id_sub_next;

                                      if(*pc++ == &&add_3)
                                        goto add_3;

                                      if(*pc++ == &&add_2)
                                        goto add_2;

                                      if(*pc++ == &&add_next)
                                        goto add_next;

                                      if(*pc++ == &&do_call)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelLast)
                                        goto LabelLast;

                                      if(*pc++ == &&LabelAccInt32)
                                        goto LabelAccInt32;

                                      if(*pc++ == &&LabelMakeArray2)
                                        goto LabelMakeArray2;

                                      if(*pc++ == &&LabelLoop)
                                        goto LabelLoop;

                                      if(*pc++ == &&LabelTailCall)
                                        goto LabelTailCall;

                                      if(*pc++ == &&LabelPhysCompare)
                                        goto LabelPhysCompare;

                                      if(*pc++ == &&LabelAccIndex1)
                                        goto LabelAccIndex1;

                                      if(*pc++ == &&LabelAccIndex0)
                                        goto LabelAccIndex0;

                                      if(*pc++ == &&LabelAccStack1)
                                        goto LabelAccStack1;

                                      if(*pc++ == &&LabelAccStack0)
                                        goto LabelAccStack0;

                                      if(*pc++ == &&LabelApply)
                                        goto LabelApply;

                                      if(*pc++ == &&LabelJumpTable)
                                        goto LabelJumpTable;

                                      if(*pc++ == &&LabelNew)
                                        goto LabelNew;

                                      if(*pc++ == &&LabelHash)
                                        goto LabelHash;

                                      if(*pc++ == &&LabelCompare)
                                        goto LabelCompare;

                                      if(*pc++ == &&LabelTypeOf)
                                        goto LabelTypeOf;

                                      if(*pc++ == &&LabelNot)
                                        goto LabelNot;

                                      if(*pc++ == &&LabelLte)
                                        goto LabelLte;

                                      if(*pc++ == &&LabelLt)
                                        goto LabelLt;

                                      if(*pc++ == &&LabelGte)
                                        goto LabelGte;

                                      if(*pc++ == &&LabelGt)
                                        goto LabelGt;

                                      if(*pc++ == &&LabelNeq)
                                        goto LabelNeq;

                                      if(*pc++ == &&LabelEq)
                                        goto LabelEq;

                                      if(*pc++ == &&LabelXor)
                                        goto LabelXor;

                                      if(*pc++ == &&LabelAnd)
                                        goto LabelAnd;

                                      if(*pc++ == &&LabelOr)
                                        goto LabelOr;

                                      if(*pc++ == &&LabelUShr)
                                        goto LabelUShr;

                                      if(*pc++ == &&LabelShr)
                                        goto LabelShr;

                                      if(*pc++ == &&LabelShl)
                                        goto LabelShl;

                                      if(*pc++ == &&LabelMod)
                                        goto LabelMod;

                                      if(*pc++ == &&LabelDiv)
                                        goto LabelDiv;

                                      if(*pc++ == &&LabelMult)
                                        goto LabelMult;

                                      if(*pc++ == &&LabelSub)
                                        goto LabelSub;

                                      if(*pc++ == &&LabelAdd)
                                        goto LabelAdd;

                                      if(*pc++ == &&LabelIsNotNull)
                                        goto LabelIsNotNull;

                                      if(*pc++ == &&LabelIsNull)
                                        goto LabelIsNull;

                                      if(*pc++ == &&LabelBool)
                                        goto LabelBool;

                                      if(*pc++ == &&LabelMakeArray)
                                        goto LabelMakeArray;

                                      if(*pc++ == &&LabelMakeEnv)
                                        goto LabelMakeEnv;

                                      if(*pc++ == &&LabelRet)
                                        goto LabelRet;

                                      if(*pc++ == &&LabelEndTrap)
                                        goto LabelEndTrap;

                                      if(*pc++ == &&LabelTrap)
                                        goto LabelTrap;

                                      if(*pc++ == &&LabelJumpIfNot)
                                        goto LabelJumpIfNot;

                                      if(*pc++ == &&LabelJumpIf)
                                        goto LabelJumpIf;

                                      if(*pc++ == &&LabelJump)
                                        goto LabelJump;

                                      if(*pc++ == &&LabelObjCall)
                                        goto LabelObjCall;

                                      if(*pc++ == &&LabelCall)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelPop)
                                        goto LabelPop;

                                      if(*pc++ == &&LabelPush)
                                        goto LabelPush;

                                      if(*pc++ == &&LabelSetThis)
                                        goto LabelSetThis;

                                      if(*pc++ == &&LabelSetIndex)
                                        goto LabelSetIndex;

                                      if(*pc++ == &&LabelSetArray)
                                        goto LabelSetArray;

                                      if(*pc++ == &&LabelSetField)
                                        goto LabelSetField;

                                      if(*pc++ == &&LabelSetEnv)
                                        goto LabelSetEnv;

                                      if(*pc++ == &&LabelSetGlobal)
                                        goto LabelSetGlobal;

                                      if(*pc++ == &&LabelSetStack)
                                        goto LabelSetStack;

                                      if(*pc++ == &&LabelAccBuiltin)
                                        goto LabelAccBuiltin;

                                      if(*pc++ == &&LabelAccIndex)
                                        goto LabelAccIndex;

                                      if(*pc++ == &&LabelAccArray)
                                        goto LabelAccArray;

                                      if(*pc++ == &&LabelAccField)
                                        goto LabelAccField;

                                      if(!(*pc++ == &&LabelAccEnv))
                                        break;

                                    }
                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                    if(*pc++ == &&LabelAccTrue)
                                      goto LabelAccTrue;

                                    if(*pc++ == &&LabelAccNull)
                                      goto LabelAccNull;

                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelAccField:
                                    ;
                                    if((1 & (signed int)acc) == 0)
                                      tmp_if_expr$17 = (signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr$17 = (_Bool)0;
                                    if(tmp_if_expr$17)
                                    {
                                      struct _value **f;
                                      struct _value *old = (struct _value *)acc;
                                      struct _value *tacc = (struct _value *)acc;
                                      do
                                      {
                                        f=otable_find$link1(&((struct _vobject *)acc)->table, (signed int)*pc);
                                        if(!(f == ((struct _value **)NULL)))
                                          break;

                                        acc = (signed long int)((struct _vobject *)tacc)->proto;
                                        tacc = (struct _value *)acc;
                                      }
                                      while(!(acc == 0l));
                                      if(!(f == ((struct _value **)NULL)))
                                        acc = (signed long int)*f;

                                      else
                                        if(!(vm->resolver == ((struct _value *)NULL)))
                                        {
                                          vm->sp = sp;
                                          vm->csp = csp;
                                          struct _value *return_value_neko_val_call2$10;
                                          return_value_neko_val_call2$10=neko_val_call2(vm->resolver, old, (struct _value *)(signed long int)((signed int)*pc << 1 | 1));
                                          acc = (signed long int)return_value_neko_val_call2$10;
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                          acc = (signed long int)val_null;
                                    }

                                    else
                                    {
                                      struct _value *v;
                                      v=neko_val_field_name((signed int)*pc);
                                      struct _buffer *b;
                                      if(v == val_null)
                                      {
                                        pc = pc + 1l;
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand$12;
                                          return_value_neko_stack_expand$12=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand$12 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string$11=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string$11);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string$13;
                                        return_value_neko_alloc_string$13=neko_alloc_string("Invalid field access");
                                        neko_val_throw(return_value_neko_alloc_string$13);
                                      }

                                      b=neko_alloc_buffer("Invalid field access : ");
                                      neko_val_buffer(b, v);
                                      pc = pc + 1l;
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$15;
                                        return_value_neko_stack_expand$15=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$15 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$14=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$14);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_buffer_to_string$16;
                                      return_value_neko_buffer_to_string$16=neko_buffer_to_string(b);
                                      neko_val_throw(return_value_neko_buffer_to_string$16);
                                    }
                                    pc = pc + 1l;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                    if(*pc++ == &&LabelAccStack0)
                                      goto LabelAccStack0;

                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                    if(*pc++ == &&LabelSetThis)
                                      goto LabelSetThis;

                                    if(*pc++ == &&LabelSetIndex)
                                      goto LabelSetIndex;

                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                  }
                                  while(*pc++ == &&LabelAccField);
                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelAccArray:
                                  ;
                                  if(!((1 & (signed int)acc) == 0))
                                  {
                                    if((1 & (signed int)*sp) == 0)
                                      tmp_if_expr$36 = ((signed int)*((enum anonymous$7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr$36 = (_Bool)0;
                                    tmp_if_expr$37 = tmp_if_expr$36 ? (_Bool)1 : (_Bool)0;
                                  }

                                  else
                                    tmp_if_expr$37 = (_Bool)0;
                                  if(tmp_if_expr$37)
                                  {
                                    signed int k = (signed int)(signed long int)acc >> 1;
                                    if(!(k >= 0))
                                      tmp_if_expr$18 = (_Bool)1;

                                    else
                                      tmp_if_expr$18 = k >= (signed int)*((enum anonymous$7 *)*sp) >> 4 ? (_Bool)1 : (_Bool)0;
                                    if(tmp_if_expr$18)
                                      acc = (signed long int)val_null;

                                    else
                                      acc = (signed long int)(&((struct anonymous$4 *)*sp)->ptr)[(signed long int)k];
                                  }

                                  else
                                  {
                                    if((1 & (signed int)*sp) == 0)
                                      tmp_if_expr$35 = (signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr$35 = (_Bool)0;
                                    if(tmp_if_expr$35)
                                    {
                                      struct _value *_o = (struct _value *)*sp;
                                      struct _value *_arg = (struct _value *)acc;
                                      struct _value *_f;
                                      _f=neko_val_field(_o, id_get);
                                      if(_f == val_null)
                                      {
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand$20;
                                          return_value_neko_stack_expand$20=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand$20 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string$19=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string$19);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string$21;
                                        return_value_neko_alloc_string$21=neko_alloc_string("Unsupported operation");
                                        neko_val_throw(return_value_neko_alloc_string$21);
                                      }

                                      else
                                      {
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand$23;
                                          return_value_neko_stack_expand$23=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand$23 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string$22=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string$22);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_val_callEx$24;
                                        return_value_neko_val_callEx$24=neko_val_callEx(_o, _f, &_arg, 1, (struct _value **)(void *)0);
                                        acc = (signed long int)return_value_neko_val_callEx$24;
                                        sp = vm->sp;
                                        csp = vm->csp;
                                        m = (struct _neko_module *)*csp;
                                        tmp_post$25 = csp;
                                        csp = csp - 1l;
                                        *tmp_post$25 = (signed long int)0;
                                        vm->vthis = (struct _value *)*csp;
                                        tmp_post$26 = csp;
                                        csp = csp - 1l;
                                        *tmp_post$26 = (signed long int)0;
                                        vm->env = (struct _value *)*csp;
                                        tmp_post$27 = csp;
                                        csp = csp - 1l;
                                        *tmp_post$27 = (signed long int)0;
                                        tmp_post$28 = csp;
                                        csp = csp - 1l;
                                        *tmp_post$28 = (signed long int)0;
                                      }
                                    }

                                    else
                                    {
                                      if((1 & (signed int)acc) == 0)
                                        tmp_if_expr$32 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

                                      else
                                        tmp_if_expr$32 = (_Bool)0;
                                      if(tmp_if_expr$32)
                                      {
                                        if((1 & (signed int)*sp) == 0)
                                          tmp_if_expr$33 = ((signed int)*((enum anonymous$7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr$33 = (_Bool)0;
                                        tmp_if_expr$34 = tmp_if_expr$33 ? (_Bool)1 : (_Bool)0;
                                      }

                                      else
                                        tmp_if_expr$34 = (_Bool)0;
                                      if(tmp_if_expr$34)
                                        acc = (signed long int)val_null;

                                      else
                                      {
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand$30;
                                          return_value_neko_stack_expand$30=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand$30 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string$29=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string$29);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string$31;
                                        return_value_neko_alloc_string$31=neko_alloc_string("Invalid array access");
                                        neko_val_throw(return_value_neko_alloc_string$31);
                                      }
                                    }
                                  }
                                  tmp_post$38 = sp;
                                  sp = sp + 1l;
                                  *tmp_post$38 = (signed long int)0;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                }
                                while(*pc++ == &&LabelAccArray);
                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                                if(*pc++ == &&LabelAccThis)
                                  goto LabelAccThis;

                                if(*pc++ == &&LabelAccFalse)
                                  goto LabelAccFalse;

                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelAccIndex0:
                                ;
                                if((1 & (signed int)acc) == 0)
                                  tmp_if_expr$53 = ((signed int)*((enum anonymous$7 *)acc) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr$53 = (_Bool)0;
                                if(tmp_if_expr$53)
                                {
                                  if(!((signed int)*((enum anonymous$7 *)acc) >> 4 == 0))
                                    acc = (signed long int)*(&((struct anonymous$4 *)acc)->ptr);

                                  else
                                    acc = (signed long int)val_null;
                                }

                                else
                                {
                                  if((1 & (signed int)acc) == 0)
                                    tmp_if_expr$52 = (signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr$52 = (_Bool)0;
                                  if(tmp_if_expr$52)
                                  {
                                    struct _value *neko_interp_loop$$1$$1$$1$$8$$_o = (struct _value *)acc;
                                    struct _value *neko_interp_loop$$1$$1$$1$$8$$_arg = (struct _value *)(signed long int)((signed int)0 << 1 | 1);
                                    struct _value *neko_interp_loop$$1$$1$$1$$8$$_f;
                                    neko_interp_loop$$1$$1$$1$$8$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$8$$_o, id_get);
                                    if(neko_interp_loop$$1$$1$$1$$8$$_f == val_null)
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$40;
                                        return_value_neko_stack_expand$40=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$40 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$39=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$39);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string$41;
                                      return_value_neko_alloc_string$41=neko_alloc_string("Unsupported operation");
                                      neko_val_throw(return_value_neko_alloc_string$41);
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$43;
                                        return_value_neko_stack_expand$43=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$43 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$42=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$42);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_val_callEx$44;
                                      return_value_neko_val_callEx$44=neko_val_callEx(neko_interp_loop$$1$$1$$1$$8$$_o, neko_interp_loop$$1$$1$$1$$8$$_f, &neko_interp_loop$$1$$1$$1$$8$$_arg, 1, (struct _value **)(void *)0);
                                      acc = (signed long int)return_value_neko_val_callEx$44;
                                      sp = vm->sp;
                                      csp = vm->csp;
                                      m = (struct _neko_module *)*csp;
                                      tmp_post$45 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$45 = (signed long int)0;
                                      vm->vthis = (struct _value *)*csp;
                                      tmp_post$46 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$46 = (signed long int)0;
                                      vm->env = (struct _value *)*csp;
                                      tmp_post$47 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$47 = (signed long int)0;
                                      tmp_post$48 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$48 = (signed long int)0;
                                    }
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$50;
                                      return_value_neko_stack_expand$50=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$50 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$49=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$49);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$51;
                                    return_value_neko_alloc_string$51=neko_alloc_string("Invalid array access");
                                    neko_val_throw(return_value_neko_alloc_string$51);
                                  }
                                }
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                              }
                              while(*pc++ == &&LabelAccIndex0);
                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelAccIndex1:
                              ;
                              if((1 & (signed int)acc) == 0)
                                tmp_if_expr$68 = ((signed int)*((enum anonymous$7 *)acc) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$68 = (_Bool)0;
                              if(tmp_if_expr$68)
                              {
                                if((signed int)*((enum anonymous$7 *)acc) >> 4 >= 2)
                                  acc = (signed long int)(&((struct anonymous$4 *)acc)->ptr)[(signed long int)1];

                                else
                                  acc = (signed long int)val_null;
                              }

                              else
                              {
                                if((1 & (signed int)acc) == 0)
                                  tmp_if_expr$67 = (signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr$67 = (_Bool)0;
                                if(tmp_if_expr$67)
                                {
                                  struct _value *neko_interp_loop$$1$$1$$1$$11$$_o = (struct _value *)acc;
                                  struct _value *neko_interp_loop$$1$$1$$1$$11$$_arg = (struct _value *)(signed long int)((signed int)1 << 1 | 1);
                                  struct _value *neko_interp_loop$$1$$1$$1$$11$$_f;
                                  neko_interp_loop$$1$$1$$1$$11$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$11$$_o, id_get);
                                  if(neko_interp_loop$$1$$1$$1$$11$$_f == val_null)
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$55;
                                      return_value_neko_stack_expand$55=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$55 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$54=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$54);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$56;
                                    return_value_neko_alloc_string$56=neko_alloc_string("Unsupported operation");
                                    neko_val_throw(return_value_neko_alloc_string$56);
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$58;
                                      return_value_neko_stack_expand$58=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$58 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$57=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$57);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_val_callEx$59;
                                    return_value_neko_val_callEx$59=neko_val_callEx(neko_interp_loop$$1$$1$$1$$11$$_o, neko_interp_loop$$1$$1$$1$$11$$_f, &neko_interp_loop$$1$$1$$1$$11$$_arg, 1, (struct _value **)(void *)0);
                                    acc = (signed long int)return_value_neko_val_callEx$59;
                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$60 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$60 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$61 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$61 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$62 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$62 = (signed long int)0;
                                    tmp_post$63 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$63 = (signed long int)0;
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$65;
                                    return_value_neko_stack_expand$65=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$65 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$64=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$64);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string$66;
                                  return_value_neko_alloc_string$66=neko_alloc_string("Invalid array access");
                                  neko_val_throw(return_value_neko_alloc_string$66);
                                }
                              }
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                            }
                            while(*pc++ == &&LabelAccIndex1);
                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(!(*pc++ == &&LabelApply))
                            {
                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(!(*pc++ == &&LabelPop))
                              {
                                if(!(*pc++ == &&LabelPush))
                                {
                                  if(!(*pc++ == &&LabelSetThis))
                                  {
                                    if(!(*pc++ == &&LabelSetIndex))
                                    {
                                      if(!(*pc++ == &&LabelSetArray))
                                      {
                                        if(!(*pc++ == &&LabelSetField))
                                        {
                                          if(!(*pc++ == &&LabelSetEnv))
                                          {
                                            if(!(*pc++ == &&LabelSetGlobal))
                                            {
                                              if(!(*pc++ == &&LabelSetStack))
                                              {
                                                if(!(*pc++ == &&LabelAccBuiltin))
                                                {
                                                  if(!(*pc++ == &&LabelAccIndex))
                                                  {
                                                    if(*pc++ == &&LabelAccArray)
                                                      goto LabelAccArray;

                                                    if(*pc++ == &&LabelAccField)
                                                      goto LabelAccField;

                                                    if(*pc++ == &&LabelAccEnv)
                                                      goto LabelAccEnv;

                                                    if(*pc++ == &&LabelAccGlobal)
                                                      goto LabelAccGlobal;

                                                    if(*pc++ == &&LabelAccStack)
                                                      goto LabelAccStack;

                                                    if(*pc++ == &&LabelAccInt)
                                                      goto LabelAccInt;

                                                    if(*pc++ == &&LabelAccThis)
                                                      goto LabelAccThis;

                                                    if(*pc++ == &&LabelAccFalse)
                                                      goto LabelAccFalse;

                                                    if(*pc++ == &&LabelAccTrue)
                                                      goto LabelAccTrue;

                                                    if(*pc++ == &&LabelAccNull)
                                                      goto LabelAccNull;

                                                    if(*pc++ == &&end)
                                                      goto end;

                                                  }

                                                  do
                                                  {

                                                  LabelAccIndex:
                                                    ;
                                                    if((1 & (signed int)acc) == 0)
                                                      tmp_if_expr$85 = ((signed int)*((enum anonymous$7 *)acc) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                                    else
                                                      tmp_if_expr$85 = (_Bool)0;
                                                    if(tmp_if_expr$85)
                                                    {
                                                      if(!(*pc >= 0l))
                                                        tmp_if_expr$69 = (_Bool)1;

                                                      else
                                                        tmp_if_expr$69 = *pc >= (signed long int)((signed int)*((enum anonymous$7 *)acc) >> 4) ? (_Bool)1 : (_Bool)0;
                                                      if(tmp_if_expr$69)
                                                        acc = (signed long int)val_null;

                                                      else
                                                        acc = (signed long int)(&((struct anonymous$4 *)acc)->ptr)[*pc];
                                                      pc = pc + 1l;
                                                    }

                                                    else
                                                    {
                                                      if((1 & (signed int)acc) == 0)
                                                        tmp_if_expr$84 = (signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                                      else
                                                        tmp_if_expr$84 = (_Bool)0;
                                                      if(tmp_if_expr$84)
                                                      {
                                                        struct _value *neko_interp_loop$$1$$1$$1$$14$$_o = (struct _value *)acc;
                                                        struct _value *neko_interp_loop$$1$$1$$1$$14$$_arg;
                                                        tmp_post$70 = pc;
                                                        pc = pc + 1l;
                                                        neko_interp_loop$$1$$1$$1$$14$$_arg = (struct _value *)(signed long int)((signed int)*tmp_post$70 << 1 | 1);
                                                        struct _value *neko_interp_loop$$1$$1$$1$$14$$_f;
                                                        neko_interp_loop$$1$$1$$1$$14$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$14$$_o, id_get);
                                                        if(neko_interp_loop$$1$$1$$1$$14$$_f == val_null)
                                                        {
                                                          if(csp + 4l >= sp)
                                                          {
                                                            signed int return_value_neko_stack_expand$72;
                                                            return_value_neko_stack_expand$72=neko_stack_expand(sp, csp, vm);
                                                            if(!(return_value_neko_stack_expand$72 == 0))
                                                            {
                                                              sp = vm->sp;
                                                              csp = vm->csp;
                                                            }

                                                            else
                                                            {
                                                              return_value_neko_alloc_string$71=neko_alloc_string("Stack Overflow");
                                                              neko_val_throw(return_value_neko_alloc_string$71);
                                                            }
                                                          }

                                                          csp = csp + 1l;
                                                          *csp = (signed long int)pc;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->env;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->vthis;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)m;
                                                          vm->sp = sp;
                                                          vm->csp = csp;
                                                          struct _value *return_value_neko_alloc_string$73;
                                                          return_value_neko_alloc_string$73=neko_alloc_string("Unsupported operation");
                                                          neko_val_throw(return_value_neko_alloc_string$73);
                                                        }

                                                        else
                                                        {
                                                          if(csp + 4l >= sp)
                                                          {
                                                            signed int return_value_neko_stack_expand$75;
                                                            return_value_neko_stack_expand$75=neko_stack_expand(sp, csp, vm);
                                                            if(!(return_value_neko_stack_expand$75 == 0))
                                                            {
                                                              sp = vm->sp;
                                                              csp = vm->csp;
                                                            }

                                                            else
                                                            {
                                                              return_value_neko_alloc_string$74=neko_alloc_string("Stack Overflow");
                                                              neko_val_throw(return_value_neko_alloc_string$74);
                                                            }
                                                          }

                                                          csp = csp + 1l;
                                                          *csp = (signed long int)pc;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->env;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->vthis;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)m;
                                                          vm->sp = sp;
                                                          vm->csp = csp;
                                                          struct _value *return_value_neko_val_callEx$76;
                                                          return_value_neko_val_callEx$76=neko_val_callEx(neko_interp_loop$$1$$1$$1$$14$$_o, neko_interp_loop$$1$$1$$1$$14$$_f, &neko_interp_loop$$1$$1$$1$$14$$_arg, 1, (struct _value **)(void *)0);
                                                          acc = (signed long int)return_value_neko_val_callEx$76;
                                                          sp = vm->sp;
                                                          csp = vm->csp;
                                                          m = (struct _neko_module *)*csp;
                                                          tmp_post$77 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post$77 = (signed long int)0;
                                                          vm->vthis = (struct _value *)*csp;
                                                          tmp_post$78 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post$78 = (signed long int)0;
                                                          vm->env = (struct _value *)*csp;
                                                          tmp_post$79 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post$79 = (signed long int)0;
                                                          tmp_post$80 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post$80 = (signed long int)0;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        pc = pc + 1l;
                                                        if(csp + 4l >= sp)
                                                        {
                                                          signed int return_value_neko_stack_expand$82;
                                                          return_value_neko_stack_expand$82=neko_stack_expand(sp, csp, vm);
                                                          if(!(return_value_neko_stack_expand$82 == 0))
                                                          {
                                                            sp = vm->sp;
                                                            csp = vm->csp;
                                                          }

                                                          else
                                                          {
                                                            return_value_neko_alloc_string$81=neko_alloc_string("Stack Overflow");
                                                            neko_val_throw(return_value_neko_alloc_string$81);
                                                          }
                                                        }

                                                        csp = csp + 1l;
                                                        *csp = (signed long int)pc;
                                                        csp = csp + 1l;
                                                        *csp = (signed long int)vm->env;
                                                        csp = csp + 1l;
                                                        *csp = (signed long int)vm->vthis;
                                                        csp = csp + 1l;
                                                        *csp = (signed long int)m;
                                                        vm->sp = sp;
                                                        vm->csp = csp;
                                                        struct _value *return_value_neko_alloc_string$83;
                                                        return_value_neko_alloc_string$83=neko_alloc_string("Invalid array access");
                                                        neko_val_throw(return_value_neko_alloc_string$83);
                                                      }
                                                    }
                                                    *pc++;
                                                    if(*pc++ == &&id_mod_next2)
                                                      goto id_mod_next2;

                                                    if(*pc++ == &&id_mod_next)
                                                      goto id_mod_next;

                                                    if(*pc++ == &&div_next)
                                                      goto div_next;

                                                    if(*pc++ == &&id_mult_next2)
                                                      goto id_mult_next2;

                                                    if(*pc++ == &&id_mult_next)
                                                      goto id_mult_next;

                                                    if(*pc++ == &&id_sub_next2)
                                                      goto id_sub_next2;

                                                    if(*pc++ == &&id_sub_next)
                                                      goto id_sub_next;

                                                    if(*pc++ == &&add_3)
                                                      goto add_3;

                                                    if(*pc++ == &&add_2)
                                                      goto add_2;

                                                    if(*pc++ == &&add_next)
                                                      goto add_next;

                                                    if(*pc++ == &&do_call)
                                                      goto LabelCall;

                                                    if(*pc++ == &&LabelLast)
                                                      goto LabelLast;

                                                    if(*pc++ == &&LabelAccInt32)
                                                      goto LabelAccInt32;

                                                    if(*pc++ == &&LabelMakeArray2)
                                                      goto LabelMakeArray2;

                                                    if(*pc++ == &&LabelLoop)
                                                      goto LabelLoop;

                                                    if(*pc++ == &&LabelTailCall)
                                                      goto LabelTailCall;

                                                    if(*pc++ == &&LabelPhysCompare)
                                                      goto LabelPhysCompare;

                                                    if(*pc++ == &&LabelAccIndex1)
                                                      goto LabelAccIndex1;

                                                    if(*pc++ == &&LabelAccIndex0)
                                                      goto LabelAccIndex0;

                                                    if(*pc++ == &&LabelAccStack1)
                                                      goto LabelAccStack1;

                                                    if(*pc++ == &&LabelAccStack0)
                                                      goto LabelAccStack0;

                                                    if(*pc++ == &&LabelApply)
                                                      goto LabelApply;

                                                    if(*pc++ == &&LabelJumpTable)
                                                      goto LabelJumpTable;

                                                    if(*pc++ == &&LabelNew)
                                                      goto LabelNew;

                                                    if(*pc++ == &&LabelHash)
                                                      goto LabelHash;

                                                    if(*pc++ == &&LabelCompare)
                                                      goto LabelCompare;

                                                    if(*pc++ == &&LabelTypeOf)
                                                      goto LabelTypeOf;

                                                    if(*pc++ == &&LabelNot)
                                                      goto LabelNot;

                                                    if(*pc++ == &&LabelLte)
                                                      goto LabelLte;

                                                    if(*pc++ == &&LabelLt)
                                                      goto LabelLt;

                                                    if(*pc++ == &&LabelGte)
                                                      goto LabelGte;

                                                    if(*pc++ == &&LabelGt)
                                                      goto LabelGt;

                                                    if(*pc++ == &&LabelNeq)
                                                      goto LabelNeq;

                                                    if(*pc++ == &&LabelEq)
                                                      goto LabelEq;

                                                    if(*pc++ == &&LabelXor)
                                                      goto LabelXor;

                                                    if(*pc++ == &&LabelAnd)
                                                      goto LabelAnd;

                                                    if(*pc++ == &&LabelOr)
                                                      goto LabelOr;

                                                    if(*pc++ == &&LabelUShr)
                                                      goto LabelUShr;

                                                    if(*pc++ == &&LabelShr)
                                                      goto LabelShr;

                                                    if(*pc++ == &&LabelShl)
                                                      goto LabelShl;

                                                    if(*pc++ == &&LabelMod)
                                                      goto LabelMod;

                                                    if(*pc++ == &&LabelDiv)
                                                      goto LabelDiv;

                                                    if(*pc++ == &&LabelMult)
                                                      goto LabelMult;

                                                    if(*pc++ == &&LabelSub)
                                                      goto LabelSub;

                                                    if(*pc++ == &&LabelAdd)
                                                      goto LabelAdd;

                                                    if(*pc++ == &&LabelIsNotNull)
                                                      goto LabelIsNotNull;

                                                    if(*pc++ == &&LabelIsNull)
                                                      goto LabelIsNull;

                                                    if(*pc++ == &&LabelBool)
                                                      goto LabelBool;

                                                    if(*pc++ == &&LabelMakeArray)
                                                      goto LabelMakeArray;

                                                    if(*pc++ == &&LabelMakeEnv)
                                                      goto LabelMakeEnv;

                                                    if(*pc++ == &&LabelRet)
                                                      goto LabelRet;

                                                    if(*pc++ == &&LabelEndTrap)
                                                      goto LabelEndTrap;

                                                    if(*pc++ == &&LabelTrap)
                                                      goto LabelTrap;

                                                    if(*pc++ == &&LabelJumpIfNot)
                                                      goto LabelJumpIfNot;

                                                    if(*pc++ == &&LabelJumpIf)
                                                      goto LabelJumpIf;

                                                    if(*pc++ == &&LabelJump)
                                                      goto LabelJump;

                                                    if(*pc++ == &&LabelObjCall)
                                                      goto LabelObjCall;

                                                    if(*pc++ == &&LabelCall)
                                                      goto LabelCall;

                                                    if(*pc++ == &&LabelPop)
                                                      goto LabelPop;

                                                    if(*pc++ == &&LabelPush)
                                                      goto LabelPush;

                                                    if(*pc++ == &&LabelSetThis)
                                                      goto LabelSetThis;

                                                    if(*pc++ == &&LabelSetIndex)
                                                      goto LabelSetIndex;

                                                    if(*pc++ == &&LabelSetArray)
                                                      goto LabelSetArray;

                                                    if(*pc++ == &&LabelSetField)
                                                      goto LabelSetField;

                                                    if(*pc++ == &&LabelSetEnv)
                                                      goto LabelSetEnv;

                                                    if(*pc++ == &&LabelSetGlobal)
                                                      goto LabelSetGlobal;

                                                    if(*pc++ == &&LabelSetStack)
                                                      goto LabelSetStack;

                                                    if(*pc++ == &&LabelAccBuiltin)
                                                      goto LabelAccBuiltin;

                                                  }
                                                  while(*pc++ == &&LabelAccIndex);
                                                  if(*pc++ == &&LabelAccArray)
                                                    goto LabelAccArray;

                                                  if(*pc++ == &&LabelAccField)
                                                    goto LabelAccField;

                                                  if(*pc++ == &&LabelAccEnv)
                                                    goto LabelAccEnv;

                                                  if(*pc++ == &&LabelAccGlobal)
                                                    goto LabelAccGlobal;

                                                  if(*pc++ == &&LabelAccStack)
                                                    goto LabelAccStack;

                                                  if(*pc++ == &&LabelAccInt)
                                                    goto LabelAccInt;

                                                  if(*pc++ == &&LabelAccThis)
                                                    goto LabelAccThis;

                                                  if(*pc++ == &&LabelAccFalse)
                                                    goto LabelAccFalse;

                                                  if(*pc++ == &&LabelAccTrue)
                                                    goto LabelAccTrue;

                                                  if(*pc++ == &&LabelAccNull)
                                                    goto LabelAccNull;

                                                  if(*pc++ == &&end)
                                                    goto end;

                                                }

                                                do
                                                {

                                                LabelAccBuiltin:
                                                  ;
                                                  tmp_post$86 = pc;
                                                  pc = pc + 1l;
                                                  acc = *tmp_post$86;
                                                  *pc++;
                                                  if(*pc++ == &&id_mod_next2)
                                                    goto id_mod_next2;

                                                  if(*pc++ == &&id_mod_next)
                                                    goto id_mod_next;

                                                  if(*pc++ == &&div_next)
                                                    goto div_next;

                                                  if(*pc++ == &&id_mult_next2)
                                                    goto id_mult_next2;

                                                  if(*pc++ == &&id_mult_next)
                                                    goto id_mult_next;

                                                  if(*pc++ == &&id_sub_next2)
                                                    goto id_sub_next2;

                                                  if(*pc++ == &&id_sub_next)
                                                    goto id_sub_next;

                                                  if(*pc++ == &&add_3)
                                                    goto add_3;

                                                  if(*pc++ == &&add_2)
                                                    goto add_2;

                                                  if(*pc++ == &&add_next)
                                                    goto add_next;

                                                  if(*pc++ == &&do_call)
                                                    goto LabelCall;

                                                  if(*pc++ == &&LabelLast)
                                                    goto LabelLast;

                                                  if(*pc++ == &&LabelAccInt32)
                                                    goto LabelAccInt32;

                                                  if(*pc++ == &&LabelMakeArray2)
                                                    goto LabelMakeArray2;

                                                  if(*pc++ == &&LabelLoop)
                                                    goto LabelLoop;

                                                  if(*pc++ == &&LabelTailCall)
                                                    goto LabelTailCall;

                                                  if(*pc++ == &&LabelPhysCompare)
                                                    goto LabelPhysCompare;

                                                  if(*pc++ == &&LabelAccIndex1)
                                                    goto LabelAccIndex1;

                                                  if(*pc++ == &&LabelAccIndex0)
                                                    goto LabelAccIndex0;

                                                  if(*pc++ == &&LabelAccStack1)
                                                    goto LabelAccStack1;

                                                  if(*pc++ == &&LabelAccStack0)
                                                    goto LabelAccStack0;

                                                  if(*pc++ == &&LabelApply)
                                                    goto LabelApply;

                                                  if(*pc++ == &&LabelJumpTable)
                                                    goto LabelJumpTable;

                                                  if(*pc++ == &&LabelNew)
                                                    goto LabelNew;

                                                  if(*pc++ == &&LabelHash)
                                                    goto LabelHash;

                                                  if(*pc++ == &&LabelCompare)
                                                    goto LabelCompare;

                                                  if(*pc++ == &&LabelTypeOf)
                                                    goto LabelTypeOf;

                                                  if(*pc++ == &&LabelNot)
                                                    goto LabelNot;

                                                  if(*pc++ == &&LabelLte)
                                                    goto LabelLte;

                                                  if(*pc++ == &&LabelLt)
                                                    goto LabelLt;

                                                  if(*pc++ == &&LabelGte)
                                                    goto LabelGte;

                                                  if(*pc++ == &&LabelGt)
                                                    goto LabelGt;

                                                  if(*pc++ == &&LabelNeq)
                                                    goto LabelNeq;

                                                  if(*pc++ == &&LabelEq)
                                                    goto LabelEq;

                                                  if(*pc++ == &&LabelXor)
                                                    goto LabelXor;

                                                  if(*pc++ == &&LabelAnd)
                                                    goto LabelAnd;

                                                  if(*pc++ == &&LabelOr)
                                                    goto LabelOr;

                                                  if(*pc++ == &&LabelUShr)
                                                    goto LabelUShr;

                                                  if(*pc++ == &&LabelShr)
                                                    goto LabelShr;

                                                  if(*pc++ == &&LabelShl)
                                                    goto LabelShl;

                                                  if(*pc++ == &&LabelMod)
                                                    goto LabelMod;

                                                  if(*pc++ == &&LabelDiv)
                                                    goto LabelDiv;

                                                  if(*pc++ == &&LabelMult)
                                                    goto LabelMult;

                                                  if(*pc++ == &&LabelSub)
                                                    goto LabelSub;

                                                  if(*pc++ == &&LabelAdd)
                                                    goto LabelAdd;

                                                  if(*pc++ == &&LabelIsNotNull)
                                                    goto LabelIsNotNull;

                                                  if(*pc++ == &&LabelIsNull)
                                                    goto LabelIsNull;

                                                  if(*pc++ == &&LabelBool)
                                                    goto LabelBool;

                                                  if(*pc++ == &&LabelMakeArray)
                                                    goto LabelMakeArray;

                                                  if(*pc++ == &&LabelMakeEnv)
                                                    goto LabelMakeEnv;

                                                  if(*pc++ == &&LabelRet)
                                                    goto LabelRet;

                                                  if(*pc++ == &&LabelEndTrap)
                                                    goto LabelEndTrap;

                                                  if(*pc++ == &&LabelTrap)
                                                    goto LabelTrap;

                                                  if(*pc++ == &&LabelJumpIfNot)
                                                    goto LabelJumpIfNot;

                                                  if(*pc++ == &&LabelJumpIf)
                                                    goto LabelJumpIf;

                                                  if(*pc++ == &&LabelJump)
                                                    goto LabelJump;

                                                  if(*pc++ == &&LabelObjCall)
                                                    goto LabelObjCall;

                                                  if(*pc++ == &&LabelCall)
                                                    goto LabelCall;

                                                  if(*pc++ == &&LabelPop)
                                                    goto LabelPop;

                                                  if(*pc++ == &&LabelPush)
                                                    goto LabelPush;

                                                  if(*pc++ == &&LabelSetThis)
                                                    goto LabelSetThis;

                                                  if(*pc++ == &&LabelSetIndex)
                                                    goto LabelSetIndex;

                                                  if(*pc++ == &&LabelSetArray)
                                                    goto LabelSetArray;

                                                  if(*pc++ == &&LabelSetField)
                                                    goto LabelSetField;

                                                  if(*pc++ == &&LabelSetEnv)
                                                    goto LabelSetEnv;

                                                  if(*pc++ == &&LabelSetGlobal)
                                                    goto LabelSetGlobal;

                                                  if(*pc++ == &&LabelSetStack)
                                                    goto LabelSetStack;

                                                }
                                                while(*pc++ == &&LabelAccBuiltin);
                                                if(*pc++ == &&LabelAccIndex)
                                                  goto LabelAccIndex;

                                                if(*pc++ == &&LabelAccArray)
                                                  goto LabelAccArray;

                                                if(*pc++ == &&LabelAccField)
                                                  goto LabelAccField;

                                                if(*pc++ == &&LabelAccEnv)
                                                  goto LabelAccEnv;

                                                if(*pc++ == &&LabelAccGlobal)
                                                  goto LabelAccGlobal;

                                                if(*pc++ == &&LabelAccStack)
                                                  goto LabelAccStack;

                                                if(*pc++ == &&LabelAccInt)
                                                  goto LabelAccInt;

                                                if(*pc++ == &&LabelAccThis)
                                                  goto LabelAccThis;

                                                if(*pc++ == &&LabelAccFalse)
                                                  goto LabelAccFalse;

                                                if(*pc++ == &&LabelAccTrue)
                                                  goto LabelAccTrue;

                                                if(*pc++ == &&LabelAccNull)
                                                  goto LabelAccNull;

                                                if(*pc++ == &&end)
                                                  goto end;

                                              }

                                              do
                                              {

                                              LabelSetStack:
                                                ;
                                                tmp_post$87 = pc;
                                                pc = pc + 1l;
                                                sp[*tmp_post$87] = acc;
                                                *pc++;
                                                if(*pc++ == &&id_mod_next2)
                                                  goto id_mod_next2;

                                                if(*pc++ == &&id_mod_next)
                                                  goto id_mod_next;

                                                if(*pc++ == &&div_next)
                                                  goto div_next;

                                                if(*pc++ == &&id_mult_next2)
                                                  goto id_mult_next2;

                                                if(*pc++ == &&id_mult_next)
                                                  goto id_mult_next;

                                                if(*pc++ == &&id_sub_next2)
                                                  goto id_sub_next2;

                                                if(*pc++ == &&id_sub_next)
                                                  goto id_sub_next;

                                                if(*pc++ == &&add_3)
                                                  goto add_3;

                                                if(*pc++ == &&add_2)
                                                  goto add_2;

                                                if(*pc++ == &&add_next)
                                                  goto add_next;

                                                if(*pc++ == &&do_call)
                                                  goto LabelCall;

                                                if(*pc++ == &&LabelLast)
                                                  goto LabelLast;

                                                if(*pc++ == &&LabelAccInt32)
                                                  goto LabelAccInt32;

                                                if(*pc++ == &&LabelMakeArray2)
                                                  goto LabelMakeArray2;

                                                if(*pc++ == &&LabelLoop)
                                                  goto LabelLoop;

                                                if(*pc++ == &&LabelTailCall)
                                                  goto LabelTailCall;

                                                if(*pc++ == &&LabelPhysCompare)
                                                  goto LabelPhysCompare;

                                                if(*pc++ == &&LabelAccIndex1)
                                                  goto LabelAccIndex1;

                                                if(*pc++ == &&LabelAccIndex0)
                                                  goto LabelAccIndex0;

                                                if(*pc++ == &&LabelAccStack1)
                                                  goto LabelAccStack1;

                                                if(*pc++ == &&LabelAccStack0)
                                                  goto LabelAccStack0;

                                                if(*pc++ == &&LabelApply)
                                                  goto LabelApply;

                                                if(*pc++ == &&LabelJumpTable)
                                                  goto LabelJumpTable;

                                                if(*pc++ == &&LabelNew)
                                                  goto LabelNew;

                                                if(*pc++ == &&LabelHash)
                                                  goto LabelHash;

                                                if(*pc++ == &&LabelCompare)
                                                  goto LabelCompare;

                                                if(*pc++ == &&LabelTypeOf)
                                                  goto LabelTypeOf;

                                                if(*pc++ == &&LabelNot)
                                                  goto LabelNot;

                                                if(*pc++ == &&LabelLte)
                                                  goto LabelLte;

                                                if(*pc++ == &&LabelLt)
                                                  goto LabelLt;

                                                if(*pc++ == &&LabelGte)
                                                  goto LabelGte;

                                                if(*pc++ == &&LabelGt)
                                                  goto LabelGt;

                                                if(*pc++ == &&LabelNeq)
                                                  goto LabelNeq;

                                                if(*pc++ == &&LabelEq)
                                                  goto LabelEq;

                                                if(*pc++ == &&LabelXor)
                                                  goto LabelXor;

                                                if(*pc++ == &&LabelAnd)
                                                  goto LabelAnd;

                                                if(*pc++ == &&LabelOr)
                                                  goto LabelOr;

                                                if(*pc++ == &&LabelUShr)
                                                  goto LabelUShr;

                                                if(*pc++ == &&LabelShr)
                                                  goto LabelShr;

                                                if(*pc++ == &&LabelShl)
                                                  goto LabelShl;

                                                if(*pc++ == &&LabelMod)
                                                  goto LabelMod;

                                                if(*pc++ == &&LabelDiv)
                                                  goto LabelDiv;

                                                if(*pc++ == &&LabelMult)
                                                  goto LabelMult;

                                                if(*pc++ == &&LabelSub)
                                                  goto LabelSub;

                                                if(*pc++ == &&LabelAdd)
                                                  goto LabelAdd;

                                                if(*pc++ == &&LabelIsNotNull)
                                                  goto LabelIsNotNull;

                                                if(*pc++ == &&LabelIsNull)
                                                  goto LabelIsNull;

                                                if(*pc++ == &&LabelBool)
                                                  goto LabelBool;

                                                if(*pc++ == &&LabelMakeArray)
                                                  goto LabelMakeArray;

                                                if(*pc++ == &&LabelMakeEnv)
                                                  goto LabelMakeEnv;

                                                if(*pc++ == &&LabelRet)
                                                  goto LabelRet;

                                                if(*pc++ == &&LabelEndTrap)
                                                  goto LabelEndTrap;

                                                if(*pc++ == &&LabelTrap)
                                                  goto LabelTrap;

                                                if(*pc++ == &&LabelJumpIfNot)
                                                  goto LabelJumpIfNot;

                                                if(*pc++ == &&LabelJumpIf)
                                                  goto LabelJumpIf;

                                                if(*pc++ == &&LabelJump)
                                                  goto LabelJump;

                                                if(*pc++ == &&LabelObjCall)
                                                  goto LabelObjCall;

                                                if(*pc++ == &&LabelCall)
                                                  goto LabelCall;

                                                if(*pc++ == &&LabelPop)
                                                  goto LabelPop;

                                                if(*pc++ == &&LabelPush)
                                                  goto LabelPush;

                                                if(*pc++ == &&LabelSetThis)
                                                  goto LabelSetThis;

                                                if(*pc++ == &&LabelSetIndex)
                                                  goto LabelSetIndex;

                                                if(*pc++ == &&LabelSetArray)
                                                  goto LabelSetArray;

                                                if(*pc++ == &&LabelSetField)
                                                  goto LabelSetField;

                                                if(*pc++ == &&LabelSetEnv)
                                                  goto LabelSetEnv;

                                                if(*pc++ == &&LabelSetGlobal)
                                                  goto LabelSetGlobal;

                                              }
                                              while(*pc++ == &&LabelSetStack);
                                              if(*pc++ == &&LabelAccBuiltin)
                                                goto LabelAccBuiltin;

                                              if(*pc++ == &&LabelAccIndex)
                                                goto LabelAccIndex;

                                              if(*pc++ == &&LabelAccArray)
                                                goto LabelAccArray;

                                              if(*pc++ == &&LabelAccField)
                                                goto LabelAccField;

                                              if(*pc++ == &&LabelAccEnv)
                                                goto LabelAccEnv;

                                              if(*pc++ == &&LabelAccGlobal)
                                                goto LabelAccGlobal;

                                              if(*pc++ == &&LabelAccStack)
                                                goto LabelAccStack;

                                              if(*pc++ == &&LabelAccInt)
                                                goto LabelAccInt;

                                              if(*pc++ == &&LabelAccThis)
                                                goto LabelAccThis;

                                              if(*pc++ == &&LabelAccFalse)
                                                goto LabelAccFalse;

                                              if(*pc++ == &&LabelAccTrue)
                                                goto LabelAccTrue;

                                              if(*pc++ == &&LabelAccNull)
                                                goto LabelAccNull;

                                              if(*pc++ == &&end)
                                                goto end;

                                            }

                                            do
                                            {

                                            LabelSetGlobal:
                                              ;
                                              tmp_post$88 = pc;
                                              pc = pc + 1l;
                                              *((signed long int *)*tmp_post$88) = acc;
                                              *pc++;
                                              if(*pc++ == &&id_mod_next2)
                                                goto id_mod_next2;

                                              if(*pc++ == &&id_mod_next)
                                                goto id_mod_next;

                                              if(*pc++ == &&div_next)
                                                goto div_next;

                                              if(*pc++ == &&id_mult_next2)
                                                goto id_mult_next2;

                                              if(*pc++ == &&id_mult_next)
                                                goto id_mult_next;

                                              if(*pc++ == &&id_sub_next2)
                                                goto id_sub_next2;

                                              if(*pc++ == &&id_sub_next)
                                                goto id_sub_next;

                                              if(*pc++ == &&add_3)
                                                goto add_3;

                                              if(*pc++ == &&add_2)
                                                goto add_2;

                                              if(*pc++ == &&add_next)
                                                goto add_next;

                                              if(*pc++ == &&do_call)
                                                goto LabelCall;

                                              if(*pc++ == &&LabelLast)
                                                goto LabelLast;

                                              if(*pc++ == &&LabelAccInt32)
                                                goto LabelAccInt32;

                                              if(*pc++ == &&LabelMakeArray2)
                                                goto LabelMakeArray2;

                                              if(*pc++ == &&LabelLoop)
                                                goto LabelLoop;

                                              if(*pc++ == &&LabelTailCall)
                                                goto LabelTailCall;

                                              if(*pc++ == &&LabelPhysCompare)
                                                goto LabelPhysCompare;

                                              if(*pc++ == &&LabelAccIndex1)
                                                goto LabelAccIndex1;

                                              if(*pc++ == &&LabelAccIndex0)
                                                goto LabelAccIndex0;

                                              if(*pc++ == &&LabelAccStack1)
                                                goto LabelAccStack1;

                                              if(*pc++ == &&LabelAccStack0)
                                                goto LabelAccStack0;

                                              if(*pc++ == &&LabelApply)
                                                goto LabelApply;

                                              if(*pc++ == &&LabelJumpTable)
                                                goto LabelJumpTable;

                                              if(*pc++ == &&LabelNew)
                                                goto LabelNew;

                                              if(*pc++ == &&LabelHash)
                                                goto LabelHash;

                                              if(*pc++ == &&LabelCompare)
                                                goto LabelCompare;

                                              if(*pc++ == &&LabelTypeOf)
                                                goto LabelTypeOf;

                                              if(*pc++ == &&LabelNot)
                                                goto LabelNot;

                                              if(*pc++ == &&LabelLte)
                                                goto LabelLte;

                                              if(*pc++ == &&LabelLt)
                                                goto LabelLt;

                                              if(*pc++ == &&LabelGte)
                                                goto LabelGte;

                                              if(*pc++ == &&LabelGt)
                                                goto LabelGt;

                                              if(*pc++ == &&LabelNeq)
                                                goto LabelNeq;

                                              if(*pc++ == &&LabelEq)
                                                goto LabelEq;

                                              if(*pc++ == &&LabelXor)
                                                goto LabelXor;

                                              if(*pc++ == &&LabelAnd)
                                                goto LabelAnd;

                                              if(*pc++ == &&LabelOr)
                                                goto LabelOr;

                                              if(*pc++ == &&LabelUShr)
                                                goto LabelUShr;

                                              if(*pc++ == &&LabelShr)
                                                goto LabelShr;

                                              if(*pc++ == &&LabelShl)
                                                goto LabelShl;

                                              if(*pc++ == &&LabelMod)
                                                goto LabelMod;

                                              if(*pc++ == &&LabelDiv)
                                                goto LabelDiv;

                                              if(*pc++ == &&LabelMult)
                                                goto LabelMult;

                                              if(*pc++ == &&LabelSub)
                                                goto LabelSub;

                                              if(*pc++ == &&LabelAdd)
                                                goto LabelAdd;

                                              if(*pc++ == &&LabelIsNotNull)
                                                goto LabelIsNotNull;

                                              if(*pc++ == &&LabelIsNull)
                                                goto LabelIsNull;

                                              if(*pc++ == &&LabelBool)
                                                goto LabelBool;

                                              if(*pc++ == &&LabelMakeArray)
                                                goto LabelMakeArray;

                                              if(*pc++ == &&LabelMakeEnv)
                                                goto LabelMakeEnv;

                                              if(*pc++ == &&LabelRet)
                                                goto LabelRet;

                                              if(*pc++ == &&LabelEndTrap)
                                                goto LabelEndTrap;

                                              if(*pc++ == &&LabelTrap)
                                                goto LabelTrap;

                                              if(*pc++ == &&LabelJumpIfNot)
                                                goto LabelJumpIfNot;

                                              if(*pc++ == &&LabelJumpIf)
                                                goto LabelJumpIf;

                                              if(*pc++ == &&LabelJump)
                                                goto LabelJump;

                                              if(*pc++ == &&LabelObjCall)
                                                goto LabelObjCall;

                                              if(*pc++ == &&LabelCall)
                                                goto LabelCall;

                                              if(*pc++ == &&LabelPop)
                                                goto LabelPop;

                                              if(*pc++ == &&LabelPush)
                                                goto LabelPush;

                                              if(*pc++ == &&LabelSetThis)
                                                goto LabelSetThis;

                                              if(*pc++ == &&LabelSetIndex)
                                                goto LabelSetIndex;

                                              if(*pc++ == &&LabelSetArray)
                                                goto LabelSetArray;

                                              if(*pc++ == &&LabelSetField)
                                                goto LabelSetField;

                                              if(*pc++ == &&LabelSetEnv)
                                                goto LabelSetEnv;

                                            }
                                            while(*pc++ == &&LabelSetGlobal);
                                            if(*pc++ == &&LabelSetStack)
                                              goto LabelSetStack;

                                            if(*pc++ == &&LabelAccBuiltin)
                                              goto LabelAccBuiltin;

                                            if(*pc++ == &&LabelAccIndex)
                                              goto LabelAccIndex;

                                            if(*pc++ == &&LabelAccArray)
                                              goto LabelAccArray;

                                            if(*pc++ == &&LabelAccField)
                                              goto LabelAccField;

                                            if(*pc++ == &&LabelAccEnv)
                                              goto LabelAccEnv;

                                            if(*pc++ == &&LabelAccGlobal)
                                              goto LabelAccGlobal;

                                            if(*pc++ == &&LabelAccStack)
                                              goto LabelAccStack;

                                            if(*pc++ == &&LabelAccInt)
                                              goto LabelAccInt;

                                            if(*pc++ == &&LabelAccThis)
                                              goto LabelAccThis;

                                            if(*pc++ == &&LabelAccFalse)
                                              goto LabelAccFalse;

                                            if(*pc++ == &&LabelAccTrue)
                                              goto LabelAccTrue;

                                            if(*pc++ == &&LabelAccNull)
                                              goto LabelAccNull;

                                            if(*pc++ == &&end)
                                              goto end;

                                          }


                                        LabelSetEnv:
                                          ;
                                          while((_Bool)1)
                                          {
                                            if(*pc >= (signed long int)((signed int)*((enum anonymous$7 *)vm->env) >> 4))
                                            {
                                              pc = pc + 1l;
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand$90;
                                                return_value_neko_stack_expand$90=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand$90 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string$89=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string$89);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string$91;
                                              return_value_neko_alloc_string$91=neko_alloc_string("Writing Outside Env");
                                              neko_val_throw(return_value_neko_alloc_string$91);
                                            }

                                            tmp_post$92 = pc;
                                            pc = pc + 1l;
                                            (&((struct anonymous$4 *)vm->env)->ptr)[*tmp_post$92] = (struct _value *)acc;
                                            *pc++;
                                            if(*pc++ == &&id_mod_next2)
                                              goto id_mod_next2;

                                            if(*pc++ == &&id_mod_next)
                                              goto id_mod_next;

                                            if(*pc++ == &&div_next)
                                              goto div_next;

                                            if(*pc++ == &&id_mult_next2)
                                              goto id_mult_next2;

                                            if(*pc++ == &&id_mult_next)
                                              goto id_mult_next;

                                            if(*pc++ == &&id_sub_next2)
                                              goto id_sub_next2;

                                            if(*pc++ == &&id_sub_next)
                                              goto id_sub_next;

                                            if(*pc++ == &&add_3)
                                              goto add_3;

                                            if(*pc++ == &&add_2)
                                              goto add_2;

                                            if(*pc++ == &&add_next)
                                              goto add_next;

                                            if(*pc++ == &&do_call)
                                              goto LabelCall;

                                            if(*pc++ == &&LabelLast)
                                              goto LabelLast;

                                            if(*pc++ == &&LabelAccInt32)
                                              goto LabelAccInt32;

                                            if(*pc++ == &&LabelMakeArray2)
                                              goto LabelMakeArray2;

                                            if(*pc++ == &&LabelLoop)
                                              goto LabelLoop;

                                            if(*pc++ == &&LabelTailCall)
                                              goto LabelTailCall;

                                            if(*pc++ == &&LabelPhysCompare)
                                              goto LabelPhysCompare;

                                            if(*pc++ == &&LabelAccIndex1)
                                              goto LabelAccIndex1;

                                            if(*pc++ == &&LabelAccIndex0)
                                              goto LabelAccIndex0;

                                            if(*pc++ == &&LabelAccStack1)
                                              goto LabelAccStack1;

                                            if(*pc++ == &&LabelAccStack0)
                                              goto LabelAccStack0;

                                            if(*pc++ == &&LabelApply)
                                              goto LabelApply;

                                            if(*pc++ == &&LabelJumpTable)
                                              goto LabelJumpTable;

                                            if(*pc++ == &&LabelNew)
                                              goto LabelNew;

                                            if(*pc++ == &&LabelHash)
                                              goto LabelHash;

                                            if(*pc++ == &&LabelCompare)
                                              goto LabelCompare;

                                            if(*pc++ == &&LabelTypeOf)
                                              goto LabelTypeOf;

                                            if(*pc++ == &&LabelNot)
                                              goto LabelNot;

                                            if(*pc++ == &&LabelLte)
                                              goto LabelLte;

                                            if(*pc++ == &&LabelLt)
                                              goto LabelLt;

                                            if(*pc++ == &&LabelGte)
                                              goto LabelGte;

                                            if(*pc++ == &&LabelGt)
                                              goto LabelGt;

                                            if(*pc++ == &&LabelNeq)
                                              goto LabelNeq;

                                            if(*pc++ == &&LabelEq)
                                              goto LabelEq;

                                            if(*pc++ == &&LabelXor)
                                              goto LabelXor;

                                            if(*pc++ == &&LabelAnd)
                                              goto LabelAnd;

                                            if(*pc++ == &&LabelOr)
                                              goto LabelOr;

                                            if(*pc++ == &&LabelUShr)
                                              goto LabelUShr;

                                            if(*pc++ == &&LabelShr)
                                              goto LabelShr;

                                            if(*pc++ == &&LabelShl)
                                              goto LabelShl;

                                            if(*pc++ == &&LabelMod)
                                              goto LabelMod;

                                            if(*pc++ == &&LabelDiv)
                                              goto LabelDiv;

                                            if(*pc++ == &&LabelMult)
                                              goto LabelMult;

                                            if(*pc++ == &&LabelSub)
                                              goto LabelSub;

                                            if(*pc++ == &&LabelAdd)
                                              goto LabelAdd;

                                            if(*pc++ == &&LabelIsNotNull)
                                              goto LabelIsNotNull;

                                            if(*pc++ == &&LabelIsNull)
                                              goto LabelIsNull;

                                            if(*pc++ == &&LabelBool)
                                              goto LabelBool;

                                            if(*pc++ == &&LabelMakeArray)
                                              goto LabelMakeArray;

                                            if(*pc++ == &&LabelMakeEnv)
                                              goto LabelMakeEnv;

                                            if(*pc++ == &&LabelRet)
                                              goto LabelRet;

                                            if(*pc++ == &&LabelEndTrap)
                                              goto LabelEndTrap;

                                            if(*pc++ == &&LabelTrap)
                                              goto LabelTrap;

                                            if(*pc++ == &&LabelJumpIfNot)
                                              goto LabelJumpIfNot;

                                            if(*pc++ == &&LabelJumpIf)
                                              goto LabelJumpIf;

                                            if(*pc++ == &&LabelJump)
                                              goto LabelJump;

                                            if(*pc++ == &&LabelObjCall)
                                              goto LabelObjCall;

                                            if(*pc++ == &&LabelCall)
                                              goto LabelCall;

                                            if(*pc++ == &&LabelPop)
                                              goto LabelPop;

                                            if(*pc++ == &&LabelPush)
                                              goto LabelPush;

                                            if(*pc++ == &&LabelSetThis)
                                              goto LabelSetThis;

                                            if(*pc++ == &&LabelSetIndex)
                                              goto LabelSetIndex;

                                            if(*pc++ == &&LabelSetArray)
                                              goto LabelSetArray;

                                            if(*pc++ == &&LabelSetField)
                                              goto LabelSetField;

                                            if(!(*pc++ == &&LabelSetEnv))
                                              break;

                                          }
                                          if(*pc++ == &&LabelSetGlobal)
                                            goto LabelSetGlobal;

                                          if(*pc++ == &&LabelSetStack)
                                            goto LabelSetStack;

                                          if(*pc++ == &&LabelAccBuiltin)
                                            goto LabelAccBuiltin;

                                          if(*pc++ == &&LabelAccIndex)
                                            goto LabelAccIndex;

                                          if(*pc++ == &&LabelAccArray)
                                            goto LabelAccArray;

                                          if(*pc++ == &&LabelAccField)
                                            goto LabelAccField;

                                          if(*pc++ == &&LabelAccEnv)
                                            goto LabelAccEnv;

                                          if(*pc++ == &&LabelAccGlobal)
                                            goto LabelAccGlobal;

                                          if(*pc++ == &&LabelAccStack)
                                            goto LabelAccStack;

                                          if(*pc++ == &&LabelAccInt)
                                            goto LabelAccInt;

                                          if(*pc++ == &&LabelAccThis)
                                            goto LabelAccThis;

                                          if(*pc++ == &&LabelAccFalse)
                                            goto LabelAccFalse;

                                          if(*pc++ == &&LabelAccTrue)
                                            goto LabelAccTrue;

                                          if(*pc++ == &&LabelAccNull)
                                            goto LabelAccNull;

                                          if(*pc++ == &&end)
                                            goto end;

                                        }

                                        do
                                        {

                                        LabelSetField:
                                          ;
                                          if((1 & (signed int)*sp) == 0)
                                            tmp_if_expr$99 = (signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                          else
                                            tmp_if_expr$99 = (_Bool)0;
                                          if(tmp_if_expr$99)
                                            otable_replace(&((struct _vobject *)*sp)->table, (signed int)*pc, (struct _value *)acc);

                                          else
                                          {
                                            struct _value *neko_interp_loop$$1$$1$$1$$18$$v;
                                            neko_interp_loop$$1$$1$$1$$18$$v=neko_val_field_name((signed int)*pc);
                                            struct _buffer *neko_interp_loop$$1$$1$$1$$18$$b;
                                            if(neko_interp_loop$$1$$1$$1$$18$$v == val_null)
                                            {
                                              pc = pc + 1l;
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand$94;
                                                return_value_neko_stack_expand$94=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand$94 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string$93=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string$93);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string$95;
                                              return_value_neko_alloc_string$95=neko_alloc_string("Invalid field access");
                                              neko_val_throw(return_value_neko_alloc_string$95);
                                            }

                                            neko_interp_loop$$1$$1$$1$$18$$b=neko_alloc_buffer("Invalid field access : ");
                                            neko_val_buffer(neko_interp_loop$$1$$1$$1$$18$$b, neko_interp_loop$$1$$1$$1$$18$$v);
                                            pc = pc + 1l;
                                            if(csp + 4l >= sp)
                                            {
                                              signed int return_value_neko_stack_expand$97;
                                              return_value_neko_stack_expand$97=neko_stack_expand(sp, csp, vm);
                                              if(!(return_value_neko_stack_expand$97 == 0))
                                              {
                                                sp = vm->sp;
                                                csp = vm->csp;
                                              }

                                              else
                                              {
                                                return_value_neko_alloc_string$96=neko_alloc_string("Stack Overflow");
                                                neko_val_throw(return_value_neko_alloc_string$96);
                                              }
                                            }

                                            csp = csp + 1l;
                                            *csp = (signed long int)pc;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->env;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->vthis;
                                            csp = csp + 1l;
                                            *csp = (signed long int)m;
                                            vm->sp = sp;
                                            vm->csp = csp;
                                            struct _value *return_value_neko_buffer_to_string$98;
                                            return_value_neko_buffer_to_string$98=neko_buffer_to_string(neko_interp_loop$$1$$1$$1$$18$$b);
                                            neko_val_throw(return_value_neko_buffer_to_string$98);
                                          }
                                          tmp_post$100 = sp;
                                          sp = sp + 1l;
                                          *tmp_post$100 = (signed long int)0;
                                          pc = pc + 1l;
                                          *pc++;
                                          if(*pc++ == &&id_mod_next2)
                                            goto id_mod_next2;

                                          if(*pc++ == &&id_mod_next)
                                            goto id_mod_next;

                                          if(*pc++ == &&div_next)
                                            goto div_next;

                                          if(*pc++ == &&id_mult_next2)
                                            goto id_mult_next2;

                                          if(*pc++ == &&id_mult_next)
                                            goto id_mult_next;

                                          if(*pc++ == &&id_sub_next2)
                                            goto id_sub_next2;

                                          if(*pc++ == &&id_sub_next)
                                            goto id_sub_next;

                                          if(*pc++ == &&add_3)
                                            goto add_3;

                                          if(*pc++ == &&add_2)
                                            goto add_2;

                                          if(*pc++ == &&add_next)
                                            goto add_next;

                                          if(*pc++ == &&do_call)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelLast)
                                            goto LabelLast;

                                          if(*pc++ == &&LabelAccInt32)
                                            goto LabelAccInt32;

                                          if(*pc++ == &&LabelMakeArray2)
                                            goto LabelMakeArray2;

                                          if(*pc++ == &&LabelLoop)
                                            goto LabelLoop;

                                          if(*pc++ == &&LabelTailCall)
                                            goto LabelTailCall;

                                          if(*pc++ == &&LabelPhysCompare)
                                            goto LabelPhysCompare;

                                          if(*pc++ == &&LabelAccIndex1)
                                            goto LabelAccIndex1;

                                          if(*pc++ == &&LabelAccIndex0)
                                            goto LabelAccIndex0;

                                          if(*pc++ == &&LabelAccStack1)
                                            goto LabelAccStack1;

                                          if(*pc++ == &&LabelAccStack0)
                                            goto LabelAccStack0;

                                          if(*pc++ == &&LabelApply)
                                            goto LabelApply;

                                          if(*pc++ == &&LabelJumpTable)
                                            goto LabelJumpTable;

                                          if(*pc++ == &&LabelNew)
                                            goto LabelNew;

                                          if(*pc++ == &&LabelHash)
                                            goto LabelHash;

                                          if(*pc++ == &&LabelCompare)
                                            goto LabelCompare;

                                          if(*pc++ == &&LabelTypeOf)
                                            goto LabelTypeOf;

                                          if(*pc++ == &&LabelNot)
                                            goto LabelNot;

                                          if(*pc++ == &&LabelLte)
                                            goto LabelLte;

                                          if(*pc++ == &&LabelLt)
                                            goto LabelLt;

                                          if(*pc++ == &&LabelGte)
                                            goto LabelGte;

                                          if(*pc++ == &&LabelGt)
                                            goto LabelGt;

                                          if(*pc++ == &&LabelNeq)
                                            goto LabelNeq;

                                          if(*pc++ == &&LabelEq)
                                            goto LabelEq;

                                          if(*pc++ == &&LabelXor)
                                            goto LabelXor;

                                          if(*pc++ == &&LabelAnd)
                                            goto LabelAnd;

                                          if(*pc++ == &&LabelOr)
                                            goto LabelOr;

                                          if(*pc++ == &&LabelUShr)
                                            goto LabelUShr;

                                          if(*pc++ == &&LabelShr)
                                            goto LabelShr;

                                          if(*pc++ == &&LabelShl)
                                            goto LabelShl;

                                          if(*pc++ == &&LabelMod)
                                            goto LabelMod;

                                          if(*pc++ == &&LabelDiv)
                                            goto LabelDiv;

                                          if(*pc++ == &&LabelMult)
                                            goto LabelMult;

                                          if(*pc++ == &&LabelSub)
                                            goto LabelSub;

                                          if(*pc++ == &&LabelAdd)
                                            goto LabelAdd;

                                          if(*pc++ == &&LabelIsNotNull)
                                            goto LabelIsNotNull;

                                          if(*pc++ == &&LabelIsNull)
                                            goto LabelIsNull;

                                          if(*pc++ == &&LabelBool)
                                            goto LabelBool;

                                          if(*pc++ == &&LabelMakeArray)
                                            goto LabelMakeArray;

                                          if(*pc++ == &&LabelMakeEnv)
                                            goto LabelMakeEnv;

                                          if(*pc++ == &&LabelRet)
                                            goto LabelRet;

                                          if(*pc++ == &&LabelEndTrap)
                                            goto LabelEndTrap;

                                          if(*pc++ == &&LabelTrap)
                                            goto LabelTrap;

                                          if(*pc++ == &&LabelJumpIfNot)
                                            goto LabelJumpIfNot;

                                          if(*pc++ == &&LabelJumpIf)
                                            goto LabelJumpIf;

                                          if(*pc++ == &&LabelJump)
                                            goto LabelJump;

                                          if(*pc++ == &&LabelObjCall)
                                            goto LabelObjCall;

                                          if(*pc++ == &&LabelCall)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelPop)
                                            goto LabelPop;

                                          if(*pc++ == &&LabelPush)
                                            goto LabelPush;

                                          if(*pc++ == &&LabelSetThis)
                                            goto LabelSetThis;

                                          if(*pc++ == &&LabelSetIndex)
                                            goto LabelSetIndex;

                                          if(*pc++ == &&LabelSetArray)
                                            goto LabelSetArray;

                                        }
                                        while(*pc++ == &&LabelSetField);
                                        if(*pc++ == &&LabelSetEnv)
                                          goto LabelSetEnv;

                                        if(*pc++ == &&LabelSetGlobal)
                                          goto LabelSetGlobal;

                                        if(*pc++ == &&LabelSetStack)
                                          goto LabelSetStack;

                                        if(*pc++ == &&LabelAccBuiltin)
                                          goto LabelAccBuiltin;

                                        if(*pc++ == &&LabelAccIndex)
                                          goto LabelAccIndex;

                                        if(*pc++ == &&LabelAccArray)
                                          goto LabelAccArray;

                                        if(*pc++ == &&LabelAccField)
                                          goto LabelAccField;

                                        if(*pc++ == &&LabelAccEnv)
                                          goto LabelAccEnv;

                                        if(*pc++ == &&LabelAccGlobal)
                                          goto LabelAccGlobal;

                                        if(*pc++ == &&LabelAccStack)
                                          goto LabelAccStack;

                                        if(*pc++ == &&LabelAccInt)
                                          goto LabelAccInt;

                                        if(*pc++ == &&LabelAccThis)
                                          goto LabelAccThis;

                                        if(*pc++ == &&LabelAccFalse)
                                          goto LabelAccFalse;

                                        if(*pc++ == &&LabelAccTrue)
                                          goto LabelAccTrue;

                                        if(*pc++ == &&LabelAccNull)
                                          goto LabelAccNull;

                                        if(*pc++ == &&end)
                                          goto end;

                                      }

                                      do
                                      {

                                      LabelSetArray:
                                        ;
                                        if((1 & (signed int)*sp) == 0)
                                          tmp_if_expr$117 = ((signed int)*((enum anonymous$7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr$117 = (_Bool)0;
                                        if(tmp_if_expr$117)
                                          tmp_if_expr$118 = ((signed int)(signed long int)sp[(signed long int)1] & 1) != 0 ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr$118 = (_Bool)0;
                                        if(tmp_if_expr$118)
                                        {
                                          signed int neko_interp_loop$$1$$1$$1$$19$$k = (signed int)(signed long int)sp[(signed long int)1] >> 1;
                                          if(neko_interp_loop$$1$$1$$1$$19$$k >= 0)
                                          {
                                            if(!(neko_interp_loop$$1$$1$$1$$19$$k >= (signed int)*((enum anonymous$7 *)*sp) >> 4))
                                              (&((struct anonymous$4 *)*sp)->ptr)[(signed long int)neko_interp_loop$$1$$1$$1$$19$$k] = (struct _value *)acc;

                                          }

                                        }

                                        else
                                        {
                                          if((1 & (signed int)*sp) == 0)
                                            tmp_if_expr$116 = (signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                          else
                                            tmp_if_expr$116 = (_Bool)0;
                                          if(tmp_if_expr$116)
                                          {
                                            struct _value *args[2l] = { (struct _value *)sp[(signed long int)1],
    (struct _value *)acc };
                                            struct _value *neko_interp_loop$$1$$1$$1$$20$$f;
                                            neko_interp_loop$$1$$1$$1$$20$$f=neko_val_field((struct _value *)*sp, id_set);
                                            if(neko_interp_loop$$1$$1$$1$$20$$f == val_null)
                                            {
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand$102;
                                                return_value_neko_stack_expand$102=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand$102 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string$101=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string$101);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string$103;
                                              return_value_neko_alloc_string$103=neko_alloc_string("Unsupported operation");
                                              neko_val_throw(return_value_neko_alloc_string$103);
                                            }

                                            if(csp + 4l >= sp)
                                            {
                                              signed int return_value_neko_stack_expand$105;
                                              return_value_neko_stack_expand$105=neko_stack_expand(sp, csp, vm);
                                              if(!(return_value_neko_stack_expand$105 == 0))
                                              {
                                                sp = vm->sp;
                                                csp = vm->csp;
                                              }

                                              else
                                              {
                                                return_value_neko_alloc_string$104=neko_alloc_string("Stack Overflow");
                                                neko_val_throw(return_value_neko_alloc_string$104);
                                              }
                                            }

                                            csp = csp + 1l;
                                            *csp = (signed long int)pc;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->env;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->vthis;
                                            csp = csp + 1l;
                                            *csp = (signed long int)m;
                                            vm->sp = sp;
                                            vm->csp = csp;
                                            neko_val_callEx((struct _value *)*sp, neko_interp_loop$$1$$1$$1$$20$$f, args, 2, (struct _value **)(void *)0);
                                            sp = vm->sp;
                                            csp = vm->csp;
                                            m = (struct _neko_module *)*csp;
                                            tmp_post$106 = csp;
                                            csp = csp - 1l;
                                            *tmp_post$106 = (signed long int)0;
                                            vm->vthis = (struct _value *)*csp;
                                            tmp_post$107 = csp;
                                            csp = csp - 1l;
                                            *tmp_post$107 = (signed long int)0;
                                            vm->env = (struct _value *)*csp;
                                            tmp_post$108 = csp;
                                            csp = csp - 1l;
                                            *tmp_post$108 = (signed long int)0;
                                            tmp_post$109 = csp;
                                            csp = csp - 1l;
                                            *tmp_post$109 = (signed long int)0;
                                            acc = (signed long int)args[(signed long int)1];
                                          }

                                          else
                                          {
                                            if((1 & (signed int)sp[1l]) == 0)
                                              tmp_if_expr$113 = (signed int)*((enum anonymous$7 *)sp[(signed long int)1]) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

                                            else
                                              tmp_if_expr$113 = (_Bool)0;
                                            if(tmp_if_expr$113)
                                            {
                                              if((1 & (signed int)*sp) == 0)
                                                tmp_if_expr$114 = ((signed int)*((enum anonymous$7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                              else
                                                tmp_if_expr$114 = (_Bool)0;
                                              tmp_if_expr$115 = tmp_if_expr$114 ? (_Bool)1 : (_Bool)0;
                                            }

                                            else
                                              tmp_if_expr$115 = (_Bool)0;
                                            if(!tmp_if_expr$115)
                                            {
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand$111;
                                                return_value_neko_stack_expand$111=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand$111 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string$110=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string$110);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string$112;
                                              return_value_neko_alloc_string$112=neko_alloc_string("Invalid array access");
                                              neko_val_throw(return_value_neko_alloc_string$112);
                                            }

                                          }
                                        }
                                        tmp_post$119 = sp;
                                        sp = sp + 1l;
                                        *tmp_post$119 = (signed long int)0;
                                        tmp_post$120 = sp;
                                        sp = sp + 1l;
                                        *tmp_post$120 = (signed long int)0;
                                        *pc++;
                                        if(*pc++ == &&id_mod_next2)
                                          goto id_mod_next2;

                                        if(*pc++ == &&id_mod_next)
                                          goto id_mod_next;

                                        if(*pc++ == &&div_next)
                                          goto div_next;

                                        if(*pc++ == &&id_mult_next2)
                                          goto id_mult_next2;

                                        if(*pc++ == &&id_mult_next)
                                          goto id_mult_next;

                                        if(*pc++ == &&id_sub_next2)
                                          goto id_sub_next2;

                                        if(*pc++ == &&id_sub_next)
                                          goto id_sub_next;

                                        if(*pc++ == &&add_3)
                                          goto add_3;

                                        if(*pc++ == &&add_2)
                                          goto add_2;

                                        if(*pc++ == &&add_next)
                                          goto add_next;

                                        if(*pc++ == &&do_call)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelLast)
                                          goto LabelLast;

                                        if(*pc++ == &&LabelAccInt32)
                                          goto LabelAccInt32;

                                        if(*pc++ == &&LabelMakeArray2)
                                          goto LabelMakeArray2;

                                        if(*pc++ == &&LabelLoop)
                                          goto LabelLoop;

                                        if(*pc++ == &&LabelTailCall)
                                          goto LabelTailCall;

                                        if(*pc++ == &&LabelPhysCompare)
                                          goto LabelPhysCompare;

                                        if(*pc++ == &&LabelAccIndex1)
                                          goto LabelAccIndex1;

                                        if(*pc++ == &&LabelAccIndex0)
                                          goto LabelAccIndex0;

                                        if(*pc++ == &&LabelAccStack1)
                                          goto LabelAccStack1;

                                        if(*pc++ == &&LabelAccStack0)
                                          goto LabelAccStack0;

                                        if(*pc++ == &&LabelApply)
                                          goto LabelApply;

                                        if(*pc++ == &&LabelJumpTable)
                                          goto LabelJumpTable;

                                        if(*pc++ == &&LabelNew)
                                          goto LabelNew;

                                        if(*pc++ == &&LabelHash)
                                          goto LabelHash;

                                        if(*pc++ == &&LabelCompare)
                                          goto LabelCompare;

                                        if(*pc++ == &&LabelTypeOf)
                                          goto LabelTypeOf;

                                        if(*pc++ == &&LabelNot)
                                          goto LabelNot;

                                        if(*pc++ == &&LabelLte)
                                          goto LabelLte;

                                        if(*pc++ == &&LabelLt)
                                          goto LabelLt;

                                        if(*pc++ == &&LabelGte)
                                          goto LabelGte;

                                        if(*pc++ == &&LabelGt)
                                          goto LabelGt;

                                        if(*pc++ == &&LabelNeq)
                                          goto LabelNeq;

                                        if(*pc++ == &&LabelEq)
                                          goto LabelEq;

                                        if(*pc++ == &&LabelXor)
                                          goto LabelXor;

                                        if(*pc++ == &&LabelAnd)
                                          goto LabelAnd;

                                        if(*pc++ == &&LabelOr)
                                          goto LabelOr;

                                        if(*pc++ == &&LabelUShr)
                                          goto LabelUShr;

                                        if(*pc++ == &&LabelShr)
                                          goto LabelShr;

                                        if(*pc++ == &&LabelShl)
                                          goto LabelShl;

                                        if(*pc++ == &&LabelMod)
                                          goto LabelMod;

                                        if(*pc++ == &&LabelDiv)
                                          goto LabelDiv;

                                        if(*pc++ == &&LabelMult)
                                          goto LabelMult;

                                        if(*pc++ == &&LabelSub)
                                          goto LabelSub;

                                        if(*pc++ == &&LabelAdd)
                                          goto LabelAdd;

                                        if(*pc++ == &&LabelIsNotNull)
                                          goto LabelIsNotNull;

                                        if(*pc++ == &&LabelIsNull)
                                          goto LabelIsNull;

                                        if(*pc++ == &&LabelBool)
                                          goto LabelBool;

                                        if(*pc++ == &&LabelMakeArray)
                                          goto LabelMakeArray;

                                        if(*pc++ == &&LabelMakeEnv)
                                          goto LabelMakeEnv;

                                        if(*pc++ == &&LabelRet)
                                          goto LabelRet;

                                        if(*pc++ == &&LabelEndTrap)
                                          goto LabelEndTrap;

                                        if(*pc++ == &&LabelTrap)
                                          goto LabelTrap;

                                        if(*pc++ == &&LabelJumpIfNot)
                                          goto LabelJumpIfNot;

                                        if(*pc++ == &&LabelJumpIf)
                                          goto LabelJumpIf;

                                        if(*pc++ == &&LabelJump)
                                          goto LabelJump;

                                        if(*pc++ == &&LabelObjCall)
                                          goto LabelObjCall;

                                        if(*pc++ == &&LabelCall)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelPop)
                                          goto LabelPop;

                                        if(*pc++ == &&LabelPush)
                                          goto LabelPush;

                                        if(*pc++ == &&LabelSetThis)
                                          goto LabelSetThis;

                                        if(*pc++ == &&LabelSetIndex)
                                          goto LabelSetIndex;

                                      }
                                      while(*pc++ == &&LabelSetArray);
                                      if(*pc++ == &&LabelSetField)
                                        goto LabelSetField;

                                      if(*pc++ == &&LabelSetEnv)
                                        goto LabelSetEnv;

                                      if(*pc++ == &&LabelSetGlobal)
                                        goto LabelSetGlobal;

                                      if(*pc++ == &&LabelSetStack)
                                        goto LabelSetStack;

                                      if(*pc++ == &&LabelAccBuiltin)
                                        goto LabelAccBuiltin;

                                      if(*pc++ == &&LabelAccIndex)
                                        goto LabelAccIndex;

                                      if(*pc++ == &&LabelAccArray)
                                        goto LabelAccArray;

                                      if(*pc++ == &&LabelAccField)
                                        goto LabelAccField;

                                      if(*pc++ == &&LabelAccEnv)
                                        goto LabelAccEnv;

                                      if(*pc++ == &&LabelAccGlobal)
                                        goto LabelAccGlobal;

                                      if(*pc++ == &&LabelAccStack)
                                        goto LabelAccStack;

                                      if(*pc++ == &&LabelAccInt)
                                        goto LabelAccInt;

                                      if(*pc++ == &&LabelAccThis)
                                        goto LabelAccThis;

                                      if(*pc++ == &&LabelAccFalse)
                                        goto LabelAccFalse;

                                      if(*pc++ == &&LabelAccTrue)
                                        goto LabelAccTrue;

                                      if(*pc++ == &&LabelAccNull)
                                        goto LabelAccNull;

                                      if(*pc++ == &&end)
                                        goto end;

                                    }

                                    do
                                    {

                                    LabelSetIndex:
                                      ;
                                      if((1 & (signed int)*sp) == 0)
                                        tmp_if_expr$134 = ((signed int)*((enum anonymous$7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                      else
                                        tmp_if_expr$134 = (_Bool)0;
                                      if(tmp_if_expr$134)
                                      {
                                        if(*pc >= 0l)
                                        {
                                          if(!(*pc >= (signed long int)((signed int)*((enum anonymous$7 *)*sp) >> 4)))
                                            (&((struct anonymous$4 *)*sp)->ptr)[*pc] = (struct _value *)acc;

                                        }

                                      }

                                      else
                                      {
                                        if((1 & (signed int)*sp) == 0)
                                          tmp_if_expr$133 = (signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr$133 = (_Bool)0;
                                        if(tmp_if_expr$133)
                                        {
                                          struct _value *neko_interp_loop$$1$$1$$1$$24$$args[2l] = { (struct _value *)(signed long int)((signed int)*pc << 1 | 1),
    (struct _value *)acc };
                                          struct _value *neko_interp_loop$$1$$1$$1$$24$$f;
                                          neko_interp_loop$$1$$1$$1$$24$$f=neko_val_field((struct _value *)*sp, id_set);
                                          if(neko_interp_loop$$1$$1$$1$$24$$f == val_null)
                                          {
                                            pc = pc + 1l;
                                            if(csp + 4l >= sp)
                                            {
                                              signed int return_value_neko_stack_expand$122;
                                              return_value_neko_stack_expand$122=neko_stack_expand(sp, csp, vm);
                                              if(!(return_value_neko_stack_expand$122 == 0))
                                              {
                                                sp = vm->sp;
                                                csp = vm->csp;
                                              }

                                              else
                                              {
                                                return_value_neko_alloc_string$121=neko_alloc_string("Stack Overflow");
                                                neko_val_throw(return_value_neko_alloc_string$121);
                                              }
                                            }

                                            csp = csp + 1l;
                                            *csp = (signed long int)pc;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->env;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->vthis;
                                            csp = csp + 1l;
                                            *csp = (signed long int)m;
                                            vm->sp = sp;
                                            vm->csp = csp;
                                            struct _value *return_value_neko_alloc_string$123;
                                            return_value_neko_alloc_string$123=neko_alloc_string("Unsupported operation");
                                            neko_val_throw(return_value_neko_alloc_string$123);
                                          }

                                          if(csp + 4l >= sp)
                                          {
                                            signed int return_value_neko_stack_expand$125;
                                            return_value_neko_stack_expand$125=neko_stack_expand(sp, csp, vm);
                                            if(!(return_value_neko_stack_expand$125 == 0))
                                            {
                                              sp = vm->sp;
                                              csp = vm->csp;
                                            }

                                            else
                                            {
                                              return_value_neko_alloc_string$124=neko_alloc_string("Stack Overflow");
                                              neko_val_throw(return_value_neko_alloc_string$124);
                                            }
                                          }

                                          csp = csp + 1l;
                                          *csp = (signed long int)pc;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->env;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->vthis;
                                          csp = csp + 1l;
                                          *csp = (signed long int)m;
                                          vm->sp = sp;
                                          vm->csp = csp;
                                          neko_val_callEx((struct _value *)*sp, neko_interp_loop$$1$$1$$1$$24$$f, neko_interp_loop$$1$$1$$1$$24$$args, 2, (struct _value **)(void *)0);
                                          sp = vm->sp;
                                          csp = vm->csp;
                                          m = (struct _neko_module *)*csp;
                                          tmp_post$126 = csp;
                                          csp = csp - 1l;
                                          *tmp_post$126 = (signed long int)0;
                                          vm->vthis = (struct _value *)*csp;
                                          tmp_post$127 = csp;
                                          csp = csp - 1l;
                                          *tmp_post$127 = (signed long int)0;
                                          vm->env = (struct _value *)*csp;
                                          tmp_post$128 = csp;
                                          csp = csp - 1l;
                                          *tmp_post$128 = (signed long int)0;
                                          tmp_post$129 = csp;
                                          csp = csp - 1l;
                                          *tmp_post$129 = (signed long int)0;
                                          acc = (signed long int)neko_interp_loop$$1$$1$$1$$24$$args[(signed long int)1];
                                        }

                                        else
                                        {
                                          pc = pc + 1l;
                                          if(csp + 4l >= sp)
                                          {
                                            signed int return_value_neko_stack_expand$131;
                                            return_value_neko_stack_expand$131=neko_stack_expand(sp, csp, vm);
                                            if(!(return_value_neko_stack_expand$131 == 0))
                                            {
                                              sp = vm->sp;
                                              csp = vm->csp;
                                            }

                                            else
                                            {
                                              return_value_neko_alloc_string$130=neko_alloc_string("Stack Overflow");
                                              neko_val_throw(return_value_neko_alloc_string$130);
                                            }
                                          }

                                          csp = csp + 1l;
                                          *csp = (signed long int)pc;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->env;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->vthis;
                                          csp = csp + 1l;
                                          *csp = (signed long int)m;
                                          vm->sp = sp;
                                          vm->csp = csp;
                                          struct _value *return_value_neko_alloc_string$132;
                                          return_value_neko_alloc_string$132=neko_alloc_string("Invalid array access");
                                          neko_val_throw(return_value_neko_alloc_string$132);
                                        }
                                      }
                                      pc = pc + 1l;
                                      tmp_post$135 = sp;
                                      sp = sp + 1l;
                                      *tmp_post$135 = (signed long int)0;
                                      *pc++;
                                      if(*pc++ == &&id_mod_next2)
                                        goto id_mod_next2;

                                      if(*pc++ == &&id_mod_next)
                                        goto id_mod_next;

                                      if(*pc++ == &&div_next)
                                        goto div_next;

                                      if(*pc++ == &&id_mult_next2)
                                        goto id_mult_next2;

                                      if(*pc++ == &&id_mult_next)
                                        goto id_mult_next;

                                      if(*pc++ == &&id_sub_next2)
                                        goto id_sub_next2;

                                      if(*pc++ == &&id_sub_next)
                                        goto id_sub_next;

                                      if(*pc++ == &&add_3)
                                        goto add_3;

                                      if(*pc++ == &&add_2)
                                        goto add_2;

                                      if(*pc++ == &&add_next)
                                        goto add_next;

                                      if(*pc++ == &&do_call)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelLast)
                                        goto LabelLast;

                                      if(*pc++ == &&LabelAccInt32)
                                        goto LabelAccInt32;

                                      if(*pc++ == &&LabelMakeArray2)
                                        goto LabelMakeArray2;

                                      if(*pc++ == &&LabelLoop)
                                        goto LabelLoop;

                                      if(*pc++ == &&LabelTailCall)
                                        goto LabelTailCall;

                                      if(*pc++ == &&LabelPhysCompare)
                                        goto LabelPhysCompare;

                                      if(*pc++ == &&LabelAccIndex1)
                                        goto LabelAccIndex1;

                                      if(*pc++ == &&LabelAccIndex0)
                                        goto LabelAccIndex0;

                                      if(*pc++ == &&LabelAccStack1)
                                        goto LabelAccStack1;

                                      if(*pc++ == &&LabelAccStack0)
                                        goto LabelAccStack0;

                                      if(*pc++ == &&LabelApply)
                                        goto LabelApply;

                                      if(*pc++ == &&LabelJumpTable)
                                        goto LabelJumpTable;

                                      if(*pc++ == &&LabelNew)
                                        goto LabelNew;

                                      if(*pc++ == &&LabelHash)
                                        goto LabelHash;

                                      if(*pc++ == &&LabelCompare)
                                        goto LabelCompare;

                                      if(*pc++ == &&LabelTypeOf)
                                        goto LabelTypeOf;

                                      if(*pc++ == &&LabelNot)
                                        goto LabelNot;

                                      if(*pc++ == &&LabelLte)
                                        goto LabelLte;

                                      if(*pc++ == &&LabelLt)
                                        goto LabelLt;

                                      if(*pc++ == &&LabelGte)
                                        goto LabelGte;

                                      if(*pc++ == &&LabelGt)
                                        goto LabelGt;

                                      if(*pc++ == &&LabelNeq)
                                        goto LabelNeq;

                                      if(*pc++ == &&LabelEq)
                                        goto LabelEq;

                                      if(*pc++ == &&LabelXor)
                                        goto LabelXor;

                                      if(*pc++ == &&LabelAnd)
                                        goto LabelAnd;

                                      if(*pc++ == &&LabelOr)
                                        goto LabelOr;

                                      if(*pc++ == &&LabelUShr)
                                        goto LabelUShr;

                                      if(*pc++ == &&LabelShr)
                                        goto LabelShr;

                                      if(*pc++ == &&LabelShl)
                                        goto LabelShl;

                                      if(*pc++ == &&LabelMod)
                                        goto LabelMod;

                                      if(*pc++ == &&LabelDiv)
                                        goto LabelDiv;

                                      if(*pc++ == &&LabelMult)
                                        goto LabelMult;

                                      if(*pc++ == &&LabelSub)
                                        goto LabelSub;

                                      if(*pc++ == &&LabelAdd)
                                        goto LabelAdd;

                                      if(*pc++ == &&LabelIsNotNull)
                                        goto LabelIsNotNull;

                                      if(*pc++ == &&LabelIsNull)
                                        goto LabelIsNull;

                                      if(*pc++ == &&LabelBool)
                                        goto LabelBool;

                                      if(*pc++ == &&LabelMakeArray)
                                        goto LabelMakeArray;

                                      if(*pc++ == &&LabelMakeEnv)
                                        goto LabelMakeEnv;

                                      if(*pc++ == &&LabelRet)
                                        goto LabelRet;

                                      if(*pc++ == &&LabelEndTrap)
                                        goto LabelEndTrap;

                                      if(*pc++ == &&LabelTrap)
                                        goto LabelTrap;

                                      if(*pc++ == &&LabelJumpIfNot)
                                        goto LabelJumpIfNot;

                                      if(*pc++ == &&LabelJumpIf)
                                        goto LabelJumpIf;

                                      if(*pc++ == &&LabelJump)
                                        goto LabelJump;

                                      if(*pc++ == &&LabelObjCall)
                                        goto LabelObjCall;

                                      if(*pc++ == &&LabelCall)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelPop)
                                        goto LabelPop;

                                      if(*pc++ == &&LabelPush)
                                        goto LabelPush;

                                      if(*pc++ == &&LabelSetThis)
                                        goto LabelSetThis;

                                    }
                                    while(*pc++ == &&LabelSetIndex);
                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                    if(*pc++ == &&LabelAccField)
                                      goto LabelAccField;

                                    if(*pc++ == &&LabelAccEnv)
                                      goto LabelAccEnv;

                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                    if(*pc++ == &&LabelAccTrue)
                                      goto LabelAccTrue;

                                    if(*pc++ == &&LabelAccNull)
                                      goto LabelAccNull;

                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelSetThis:
                                    ;
                                    vm->vthis = (struct _value *)acc;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                    if(*pc++ == &&LabelAccStack0)
                                      goto LabelAccStack0;

                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                  }
                                  while(*pc++ == &&LabelSetThis);
                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelPush:
                                  ;
                                  sp = sp - 1l;
                                  if(csp >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$137;
                                    return_value_neko_stack_expand$137=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$137 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$136=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$136);
                                    }
                                  }

                                  *sp = acc;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                }
                                while(*pc++ == &&LabelPush);
                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(*pc++ == &&LabelAccArray)
                                  goto LabelAccArray;

                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                                if(*pc++ == &&LabelAccThis)
                                  goto LabelAccThis;

                                if(*pc++ == &&LabelAccFalse)
                                  goto LabelAccFalse;

                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelPop:
                                ;
                                signed int tmp;
                                tmp_post$138 = pc;
                                pc = pc + 1l;
                                tmp = (signed int)*tmp_post$138;
                                do
                                {
                                  tmp_post$139 = tmp;
                                  tmp = tmp - 1;
                                  if(!(tmp_post$139 >= 1))
                                    break;

                                  tmp_post$140 = sp;
                                  sp = sp + 1l;
                                  *tmp_post$140 = (signed long int)0;
                                }
                                while((_Bool)1);
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                                if(*pc++ == &&LabelAccIndex0)
                                  goto LabelAccIndex0;

                                if(*pc++ == &&LabelAccStack1)
                                  goto LabelAccStack1;

                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                                if(*pc++ == &&LabelShr)
                                  goto LabelShr;

                                if(*pc++ == &&LabelShl)
                                  goto LabelShl;

                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                              }
                              while(*pc++ == &&LabelPop);
                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelApply:
                              ;
                              if((1 & (signed int)acc) == 0)
                                tmp_if_expr$144 = ((signed int)*((enum anonymous$7 *)acc) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$144 = (_Bool)0;
                              if(!tmp_if_expr$144)
                              {
                                pc = pc + 1l;
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand$142;
                                  return_value_neko_stack_expand$142=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand$142 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string$141=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string$141);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                vm->sp = sp;
                                vm->csp = csp;
                                struct _value *return_value_neko_alloc_string$143;
                                return_value_neko_alloc_string$143=neko_alloc_string("$apply");
                                neko_val_throw(return_value_neko_alloc_string$143);
                              }

                              signed int fargs = ((struct anonymous$8 *)acc)->nargs;
                              if(fargs == -1 || (signed long int)fargs == *pc)
                                goto LabelCall;

                              if(!((signed long int)fargs >= *pc))
                              {
                                pc = pc + 1l;
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand$146;
                                  return_value_neko_stack_expand$146=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand$146 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string$145=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string$145);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                vm->sp = sp;
                                vm->csp = csp;
                                struct _value *return_value_neko_alloc_string$147;
                                return_value_neko_alloc_string$147=neko_alloc_string("$apply");
                                neko_val_throw(return_value_neko_alloc_string$147);
                              }

                              signed int i = fargs;
                              struct _value *env;
                              env=neko_alloc_array((unsigned int)(fargs + 1));
                              (&((struct anonymous$4 *)env)->ptr)[(signed long int)0] = (struct _value *)acc;
                              for( ; !(*pc >= (signed long int)i); (&((struct anonymous$4 *)env)->ptr)[(signed long int)tmp_post$148] = val_null)
                              {
                                tmp_post$148 = i;
                                i = i - 1;
                              }
                              for( ; !(i == 0); *tmp_post$150 = (signed long int)0)
                              {
                                tmp_post$149 = i;
                                i = i - 1;
                                (&((struct anonymous$4 *)env)->ptr)[(signed long int)tmp_post$149] = (struct _value *)*sp;
                                tmp_post$150 = sp;
                                sp = sp + 1l;
                              }
                              tmp_post$151 = pc;
                              pc = pc + 1l;
                              struct _value *return_value_neko_alloc_apply$152;
                              return_value_neko_alloc_apply$152=neko_alloc_apply((signed int)((signed long int)fargs - *tmp_post$151), env);
                              acc = (signed long int)return_value_neko_alloc_apply$152;
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                            }
                            while(*pc++ == &&LabelApply);
                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelTailCall:
                            ;
                            signed int neko_interp_loop$$1$$1$$1$$30$$stack = (signed int)(*pc >> 3);
                            signed int nargs = (signed int)(*pc & (signed long int)7);
                            signed int neko_interp_loop$$1$$1$$1$$30$$i = nargs;
                            struct _value *cur_this = vm->vthis;
                            neko_interp_loop$$1$$1$$1$$30$$stack = neko_interp_loop$$1$$1$$1$$30$$stack - nargs;
                            sp = sp + (signed long int)nargs;
                            for( ; neko_interp_loop$$1$$1$$1$$30$$i >= 1; neko_interp_loop$$1$$1$$1$$30$$i = neko_interp_loop$$1$$1$$1$$30$$i - 1)
                            {
                              sp = sp - 1l;
                              sp[(signed long int)neko_interp_loop$$1$$1$$1$$30$$stack] = *sp;
                            }
                            do
                            {
                              tmp_post$153 = neko_interp_loop$$1$$1$$1$$30$$stack;
                              neko_interp_loop$$1$$1$$1$$30$$stack = neko_interp_loop$$1$$1$$1$$30$$stack - 1;
                              if(!(tmp_post$153 >= 1))
                                break;

                              tmp_post$154 = sp;
                              sp = sp + 1l;
                              *tmp_post$154 = (signed long int)0;
                            }
                            while((_Bool)1);
                            m = (struct _neko_module *)*csp;
                            tmp_post$155 = csp;
                            csp = csp - 1l;
                            *tmp_post$155 = (signed long int)0;
                            vm->vthis = (struct _value *)*csp;
                            tmp_post$156 = csp;
                            csp = csp - 1l;
                            *tmp_post$156 = (signed long int)0;
                            vm->env = (struct _value *)*csp;
                            tmp_post$157 = csp;
                            csp = csp - 1l;
                            *tmp_post$157 = (signed long int)0;
                            pc = (signed long int *)*csp;
                            tmp_post$158 = csp;
                            csp = csp - 1l;
                            *tmp_post$158 = (signed long int)0;
                            if(!((1l & acc) == 0l))
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$160;
                                return_value_neko_stack_expand$160=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$160 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$159=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$159);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string$161;
                              return_value_neko_alloc_string$161=neko_alloc_string("Invalid call");
                              neko_val_throw(return_value_neko_alloc_string$161);
                            }

                            else
                            {
                              if((signed int)*((enum anonymous$7 *)acc) == VAL_FUNCTION)
                                tmp_if_expr$193 = nargs == ((struct anonymous$8 *)acc)->nargs ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$193 = (_Bool)0;
                              if(tmp_if_expr$193)
                              {
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand$163;
                                  return_value_neko_stack_expand$163=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand$163 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string$162=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string$162);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                m = (struct _neko_module *)((struct anonymous$8 *)acc)->module;
                                pc = (signed long int *)((struct anonymous$8 *)acc)->addr;
                                vm->vthis = cur_this;
                                vm->env = ((struct anonymous$8 *)acc)->env;
                              }

                              else
                                if((signed int)*((enum anonymous$7 *)acc) == VAL_PRIMITIVE)
                                {
                                  if(nargs == ((struct anonymous$8 *)acc)->nargs)
                                  {
                                    struct anonymous$8 *neko_interp_loop$$1$$1$$1$$30$$4$$1$$f = (struct anonymous$8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$165;
                                      return_value_neko_stack_expand$165=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$165 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$164=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$164);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = cur_this;
                                    vm->env = ((struct anonymous$8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    switch(nargs)
                                    {
                                      case 0:
                                        acc=((signed long int (*)())((struct anonymous$8 *)acc)->addr)();
                                      case 1:
                                        acc=((signed long int (*)(signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)0]);
                                      case 2:
                                        acc=((signed long int (*)(signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)1], sp[(signed long int)0]);
                                      case 3:
                                        acc=((signed long int (*)(signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                      case 4:
                                        acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                      case 5:
                                        acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)4], sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    }
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$30$$4$$1$$f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$166 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$166 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$167 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$167 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$168 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$168 = (signed long int)0;
                                    tmp_post$169 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$169 = (signed long int)0;
                                  }

                                  else
                                    if(((struct anonymous$8 *)acc)->nargs == -1)
                                    {
                                      signed long int neko_interp_loop$$1$$1$$1$$30$$4$$2$$args[5l];
                                      signed long int neko_interp_loop$$1$$1$$1$$30$$4$$2$$tmp;
                                      struct anonymous$8 *neko_interp_loop$$1$$1$$1$$30$$4$$2$$f = (struct anonymous$8 *)acc;
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$171;
                                        return_value_neko_stack_expand$171=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$171 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$170=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$170);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->vthis = cur_this;
                                      vm->env = ((struct anonymous$8 *)acc)->env;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      sp = sp + (signed long int)nargs;
                                      neko_interp_loop$$1$$1$$1$$30$$4$$2$$tmp = (signed long int)0;
                                      for( ; !(neko_interp_loop$$1$$1$$1$$30$$4$$2$$tmp >= (signed long int)nargs); neko_interp_loop$$1$$1$$1$$30$$4$$2$$tmp = neko_interp_loop$$1$$1$$1$$30$$4$$2$$tmp + 1l)
                                      {
                                        sp = sp - 1l;
                                        neko_interp_loop$$1$$1$$1$$30$$4$$2$$args[neko_interp_loop$$1$$1$$1$$30$$4$$2$$tmp] = *sp;
                                      }
                                      acc=((signed long int (*)(struct _value **, signed int))((struct anonymous$8 *)acc)->addr)((struct _value **)(void *)neko_interp_loop$$1$$1$$1$$30$$4$$2$$args, (signed int)nargs);
                                      if(acc == 0l)
                                        neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$30$$4$$2$$f->module);

                                      sp = vm->sp;
                                      csp = vm->csp;
                                      m = (struct _neko_module *)*csp;
                                      tmp_post$172 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$172 = (signed long int)0;
                                      vm->vthis = (struct _value *)*csp;
                                      tmp_post$173 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$173 = (signed long int)0;
                                      vm->env = (struct _value *)*csp;
                                      tmp_post$174 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$174 = (signed long int)0;
                                      tmp_post$175 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$175 = (signed long int)0;
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$177;
                                        return_value_neko_stack_expand$177=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$177 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$176=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$176);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string$178;
                                      return_value_neko_alloc_string$178=neko_alloc_string("Invalid call");
                                      neko_val_throw(return_value_neko_alloc_string$178);
                                    }
                                  signed int neko_interp_loop$$1$$1$$1$$30$$4$$4$$tmp = (signed int)nargs;
                                  do
                                  {
                                    tmp_post$179 = neko_interp_loop$$1$$1$$1$$30$$4$$4$$tmp;
                                    neko_interp_loop$$1$$1$$1$$30$$4$$4$$tmp = neko_interp_loop$$1$$1$$1$$30$$4$$4$$tmp - 1;
                                    if(!(tmp_post$179 >= 1))
                                      break;

                                    tmp_post$180 = sp;
                                    sp = sp + 1l;
                                    *tmp_post$180 = (signed long int)0;
                                  }
                                  while((_Bool)1);
                                }

                                else
                                  if((signed int)*((enum anonymous$7 *)acc) == VAL_JITFUN)
                                  {
                                    if(nargs == ((struct anonymous$8 *)acc)->nargs)
                                    {
                                      struct anonymous$8 *neko_interp_loop$$1$$1$$1$$30$$5$$1$$f = (struct anonymous$8 *)acc;
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$182;
                                        return_value_neko_stack_expand$182=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$182 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$181=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$181);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->vthis = cur_this;
                                      vm->env = ((struct anonymous$8 *)acc)->env;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      acc=jit_run(vm, (struct anonymous$8 *)acc);
                                      if(acc == 0l)
                                        neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$30$$5$$1$$f->module);

                                      sp = vm->sp;
                                      csp = vm->csp;
                                      m = (struct _neko_module *)*csp;
                                      tmp_post$183 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$183 = (signed long int)0;
                                      vm->vthis = (struct _value *)*csp;
                                      tmp_post$184 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$184 = (signed long int)0;
                                      vm->env = (struct _value *)*csp;
                                      tmp_post$185 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$185 = (signed long int)0;
                                      tmp_post$186 = csp;
                                      csp = csp - 1l;
                                      *tmp_post$186 = (signed long int)0;
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$188;
                                        return_value_neko_stack_expand$188=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$188 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$187=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$187);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string$189;
                                      return_value_neko_alloc_string$189=neko_alloc_string("Invalid call");
                                      neko_val_throw(return_value_neko_alloc_string$189);
                                    }
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$191;
                                      return_value_neko_stack_expand$191=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$191 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$190=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$190);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$192;
                                    return_value_neko_alloc_string$192=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string$192);
                                  }
                            }
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                          }
                          while(*pc++ == &&LabelTailCall);
                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(!(*pc++ == &&LabelCall))
                          {
                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                        }

                        do
                        {

                        LabelCall:

                          do_call:
                            ;
                          pc = pc + 1l;
                          if(!((1l & acc) == 0l))
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand$195;
                              return_value_neko_stack_expand$195=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand$195 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string$194=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string$194);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string$196;
                            return_value_neko_alloc_string$196=neko_alloc_string("Invalid call");
                            neko_val_throw(return_value_neko_alloc_string$196);
                          }

                          else
                          {
                            if((signed int)*((enum anonymous$7 *)acc) == VAL_FUNCTION)
                              tmp_if_expr$228 = pc[(signed long int)-1] == (signed long int)((struct anonymous$8 *)acc)->nargs ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr$228 = (_Bool)0;
                            if(tmp_if_expr$228)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$198;
                                return_value_neko_stack_expand$198=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$198 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$197=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$197);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              m = (struct _neko_module *)((struct anonymous$8 *)acc)->module;
                              pc = (signed long int *)((struct anonymous$8 *)acc)->addr;
                              vm->vthis = vm->vthis;
                              vm->env = ((struct anonymous$8 *)acc)->env;
                            }

                            else
                              if((signed int)*((enum anonymous$7 *)acc) == VAL_PRIMITIVE)
                              {
                                if(pc[-1l] == (signed long int)((struct anonymous$8 *)acc)->nargs)
                                {
                                  struct anonymous$8 *neko_interp_loop$$1$$1$$1$$33$$1$$f = (struct anonymous$8 *)acc;
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$200;
                                    return_value_neko_stack_expand$200=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$200 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$199=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$199);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->vthis = vm->vthis;
                                  vm->env = ((struct anonymous$8 *)acc)->env;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  switch(pc[(signed long int)-1])
                                  {
                                    case (signed long int)0:
                                      acc=((signed long int (*)())((struct anonymous$8 *)acc)->addr)();
                                    case (signed long int)1:
                                      acc=((signed long int (*)(signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)0]);
                                    case (signed long int)2:
                                      acc=((signed long int (*)(signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)3:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)4:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)5:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)4], sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                  }
                                  if(acc == 0l)
                                    neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$33$$1$$f->module);

                                  sp = vm->sp;
                                  csp = vm->csp;
                                  m = (struct _neko_module *)*csp;
                                  tmp_post$201 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$201 = (signed long int)0;
                                  vm->vthis = (struct _value *)*csp;
                                  tmp_post$202 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$202 = (signed long int)0;
                                  vm->env = (struct _value *)*csp;
                                  tmp_post$203 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$203 = (signed long int)0;
                                  tmp_post$204 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$204 = (signed long int)0;
                                }

                                else
                                  if(((struct anonymous$8 *)acc)->nargs == -1)
                                  {
                                    signed long int neko_interp_loop$$1$$1$$1$$33$$2$$args[5l];
                                    signed long int neko_interp_loop$$1$$1$$1$$33$$2$$tmp;
                                    struct anonymous$8 *neko_interp_loop$$1$$1$$1$$33$$2$$f = (struct anonymous$8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$206;
                                      return_value_neko_stack_expand$206=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$206 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$205=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$205);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vm->vthis;
                                    vm->env = ((struct anonymous$8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    sp = sp + pc[(signed long int)-1];
                                    neko_interp_loop$$1$$1$$1$$33$$2$$tmp = (signed long int)0;
                                    for( ; !(neko_interp_loop$$1$$1$$1$$33$$2$$tmp >= pc[-1l]); neko_interp_loop$$1$$1$$1$$33$$2$$tmp = neko_interp_loop$$1$$1$$1$$33$$2$$tmp + 1l)
                                    {
                                      sp = sp - 1l;
                                      neko_interp_loop$$1$$1$$1$$33$$2$$args[neko_interp_loop$$1$$1$$1$$33$$2$$tmp] = *sp;
                                    }
                                    acc=((signed long int (*)(struct _value **, signed int))((struct anonymous$8 *)acc)->addr)((struct _value **)(void *)neko_interp_loop$$1$$1$$1$$33$$2$$args, (signed int)pc[(signed long int)-1]);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$33$$2$$f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$207 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$207 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$208 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$208 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$209 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$209 = (signed long int)0;
                                    tmp_post$210 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$210 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$212;
                                      return_value_neko_stack_expand$212=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$212 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$211=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$211);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$213;
                                    return_value_neko_alloc_string$213=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string$213);
                                  }
                                signed int neko_interp_loop$$1$$1$$1$$33$$4$$tmp = (signed int)pc[(signed long int)-1];
                                do
                                {
                                  tmp_post$214 = neko_interp_loop$$1$$1$$1$$33$$4$$tmp;
                                  neko_interp_loop$$1$$1$$1$$33$$4$$tmp = neko_interp_loop$$1$$1$$1$$33$$4$$tmp - 1;
                                  if(!(tmp_post$214 >= 1))
                                    break;

                                  tmp_post$215 = sp;
                                  sp = sp + 1l;
                                  *tmp_post$215 = (signed long int)0;
                                }
                                while((_Bool)1);
                              }

                              else
                                if((signed int)*((enum anonymous$7 *)acc) == VAL_JITFUN)
                                {
                                  if(pc[-1l] == (signed long int)((struct anonymous$8 *)acc)->nargs)
                                  {
                                    struct anonymous$8 *neko_interp_loop$$1$$1$$1$$34$$1$$f = (struct anonymous$8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$217;
                                      return_value_neko_stack_expand$217=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$217 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$216=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$216);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vm->vthis;
                                    vm->env = ((struct anonymous$8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    acc=jit_run(vm, (struct anonymous$8 *)acc);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$34$$1$$f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$218 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$218 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$219 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$219 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$220 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$220 = (signed long int)0;
                                    tmp_post$221 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$221 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$223;
                                      return_value_neko_stack_expand$223=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$223 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$222=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$222);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$224;
                                    return_value_neko_alloc_string$224=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string$224);
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$226;
                                    return_value_neko_stack_expand$226=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$226 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$225=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$225);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string$227;
                                  return_value_neko_alloc_string$227=neko_alloc_string("Invalid call");
                                  neko_val_throw(return_value_neko_alloc_string$227);
                                }
                          }
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                        }
                        while(*pc++ == &&LabelCall);
                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelObjCall:
                          ;
                          struct _value *vtmp = (struct _value *)*sp;
                          tmp_post$229 = sp;
                          sp = sp + 1l;
                          *tmp_post$229 = (signed long int)0;
                          pc = pc + 1l;
                          if(!((1l & acc) == 0l))
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand$231;
                              return_value_neko_stack_expand$231=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand$231 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string$230=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string$230);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string$232;
                            return_value_neko_alloc_string$232=neko_alloc_string("Invalid call");
                            neko_val_throw(return_value_neko_alloc_string$232);
                          }

                          else
                          {
                            if((signed int)*((enum anonymous$7 *)acc) == VAL_FUNCTION)
                              tmp_if_expr$264 = pc[(signed long int)-1] == (signed long int)((struct anonymous$8 *)acc)->nargs ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr$264 = (_Bool)0;
                            if(tmp_if_expr$264)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$234;
                                return_value_neko_stack_expand$234=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$234 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$233=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$233);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              m = (struct _neko_module *)((struct anonymous$8 *)acc)->module;
                              pc = (signed long int *)((struct anonymous$8 *)acc)->addr;
                              vm->vthis = vtmp;
                              vm->env = ((struct anonymous$8 *)acc)->env;
                            }

                            else
                              if((signed int)*((enum anonymous$7 *)acc) == VAL_PRIMITIVE)
                              {
                                if(pc[-1l] == (signed long int)((struct anonymous$8 *)acc)->nargs)
                                {
                                  struct anonymous$8 *neko_interp_loop$$1$$1$$1$$36$$3$$1$$f = (struct anonymous$8 *)acc;
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$236;
                                    return_value_neko_stack_expand$236=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$236 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$235=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$235);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->vthis = vtmp;
                                  vm->env = ((struct anonymous$8 *)acc)->env;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  switch(pc[(signed long int)-1])
                                  {
                                    case (signed long int)0:
                                      acc=((signed long int (*)())((struct anonymous$8 *)acc)->addr)();
                                    case (signed long int)1:
                                      acc=((signed long int (*)(signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)0]);
                                    case (signed long int)2:
                                      acc=((signed long int (*)(signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)3:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)4:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)5:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int, signed long int))((struct anonymous$8 *)acc)->addr)(sp[(signed long int)4], sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                  }
                                  if(acc == 0l)
                                    neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$36$$3$$1$$f->module);

                                  sp = vm->sp;
                                  csp = vm->csp;
                                  m = (struct _neko_module *)*csp;
                                  tmp_post$237 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$237 = (signed long int)0;
                                  vm->vthis = (struct _value *)*csp;
                                  tmp_post$238 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$238 = (signed long int)0;
                                  vm->env = (struct _value *)*csp;
                                  tmp_post$239 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$239 = (signed long int)0;
                                  tmp_post$240 = csp;
                                  csp = csp - 1l;
                                  *tmp_post$240 = (signed long int)0;
                                }

                                else
                                  if(((struct anonymous$8 *)acc)->nargs == -1)
                                  {
                                    signed long int neko_interp_loop$$1$$1$$1$$36$$3$$2$$args[5l];
                                    signed long int neko_interp_loop$$1$$1$$1$$36$$3$$2$$tmp;
                                    struct anonymous$8 *neko_interp_loop$$1$$1$$1$$36$$3$$2$$f = (struct anonymous$8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$242;
                                      return_value_neko_stack_expand$242=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$242 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$241=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$241);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vtmp;
                                    vm->env = ((struct anonymous$8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    sp = sp + pc[(signed long int)-1];
                                    neko_interp_loop$$1$$1$$1$$36$$3$$2$$tmp = (signed long int)0;
                                    for( ; !(neko_interp_loop$$1$$1$$1$$36$$3$$2$$tmp >= pc[-1l]); neko_interp_loop$$1$$1$$1$$36$$3$$2$$tmp = neko_interp_loop$$1$$1$$1$$36$$3$$2$$tmp + 1l)
                                    {
                                      sp = sp - 1l;
                                      neko_interp_loop$$1$$1$$1$$36$$3$$2$$args[neko_interp_loop$$1$$1$$1$$36$$3$$2$$tmp] = *sp;
                                    }
                                    acc=((signed long int (*)(struct _value **, signed int))((struct anonymous$8 *)acc)->addr)((struct _value **)(void *)neko_interp_loop$$1$$1$$1$$36$$3$$2$$args, (signed int)pc[(signed long int)-1]);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$36$$3$$2$$f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$243 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$243 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$244 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$244 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$245 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$245 = (signed long int)0;
                                    tmp_post$246 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$246 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$248;
                                      return_value_neko_stack_expand$248=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$248 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$247=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$247);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$249;
                                    return_value_neko_alloc_string$249=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string$249);
                                  }
                                signed int neko_interp_loop$$1$$1$$1$$36$$3$$4$$tmp = (signed int)pc[(signed long int)-1];
                                do
                                {
                                  tmp_post$250 = neko_interp_loop$$1$$1$$1$$36$$3$$4$$tmp;
                                  neko_interp_loop$$1$$1$$1$$36$$3$$4$$tmp = neko_interp_loop$$1$$1$$1$$36$$3$$4$$tmp - 1;
                                  if(!(tmp_post$250 >= 1))
                                    break;

                                  tmp_post$251 = sp;
                                  sp = sp + 1l;
                                  *tmp_post$251 = (signed long int)0;
                                }
                                while((_Bool)1);
                              }

                              else
                                if((signed int)*((enum anonymous$7 *)acc) == VAL_JITFUN)
                                {
                                  if(pc[-1l] == (signed long int)((struct anonymous$8 *)acc)->nargs)
                                  {
                                    struct anonymous$8 *neko_interp_loop$$1$$1$$1$$36$$4$$1$$f = (struct anonymous$8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$253;
                                      return_value_neko_stack_expand$253=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$253 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$252=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$252);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vtmp;
                                    vm->env = ((struct anonymous$8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    acc=jit_run(vm, (struct anonymous$8 *)acc);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop$$1$$1$$1$$36$$4$$1$$f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$254 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$254 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$255 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$255 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$256 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$256 = (signed long int)0;
                                    tmp_post$257 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$257 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$259;
                                      return_value_neko_stack_expand$259=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$259 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$258=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$258);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$260;
                                    return_value_neko_alloc_string$260=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string$260);
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$262;
                                    return_value_neko_stack_expand$262=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$262 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$261=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$261);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string$263;
                                  return_value_neko_alloc_string$263=neko_alloc_string("Invalid call");
                                  neko_val_throw(return_value_neko_alloc_string$263);
                                }
                          }
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                        }
                        while(*pc++ == &&LabelObjCall);
                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelJump:
                          ;
                          pc = (signed long int *)*pc;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                        }
                        while(*pc++ == &&LabelJump);
                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;


                      LabelJumpIf:
                        ;
                        while((_Bool)1)
                        {
                          if(acc == (signed long int)val_true)
                            pc = (signed long int *)*pc;

                          else
                            pc = pc + 1l;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(!(*pc++ == &&LabelJumpIf))
                            break;

                        }
                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;


                      LabelJumpIfNot:
                        ;
                        while((_Bool)1)
                        {
                          if(!(acc == (signed long int)val_true))
                            pc = (signed long int *)*pc;

                          else
                            pc = pc + 1l;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(!(*pc++ == &&LabelJumpIfNot))
                            break;

                        }
                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelTrap:
                          ;
                          sp = sp - (signed long int)6;
                          if(csp >= sp)
                          {
                            signed int return_value_neko_stack_expand$266;
                            return_value_neko_stack_expand$266=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand$266 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string$265=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string$265);
                            }
                          }

                          sp[(signed long int)0] = (signed long int)(struct _value *)(signed long int)((signed int)(signed long int)(csp - vm->spmin) << 1 | 1);
                          sp[(signed long int)1] = (signed long int)vm->vthis;
                          sp[(signed long int)2] = (signed long int)vm->env;
                          sp[(signed long int)3] = (signed long int)*pc | (signed long int)1;
                          sp[(signed long int)4] = (signed long int)m | (signed long int)1;
                          sp[(signed long int)5] = (signed long int)(struct _value *)(signed long int)((signed int)vm->trap << 1 | 1);
                          vm->trap = vm->spmax - sp;
                          pc = pc + 1l;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                        }
                        while(*pc++ == &&LabelTrap);
                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;


                      LabelEndTrap:
                        ;
                        while((_Bool)1)
                        {
                          if(!(vm->spmax + -vm->trap == sp))
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand$268;
                              return_value_neko_stack_expand$268=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand$268 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string$267=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string$267);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string$269;
                            return_value_neko_alloc_string$269=neko_alloc_string("Invalid End Trap");
                            neko_val_throw(return_value_neko_alloc_string$269);
                          }

                          vm->trap = (signed long int)((signed int)(signed long int)sp[(signed long int)5] >> 1);
                          signed int neko_interp_loop$$1$$1$$1$$39$$tmp = (signed int)6;
                          do
                          {
                            tmp_post$270 = neko_interp_loop$$1$$1$$1$$39$$tmp;
                            neko_interp_loop$$1$$1$$1$$39$$tmp = neko_interp_loop$$1$$1$$1$$39$$tmp - 1;
                            if(!(tmp_post$270 >= 1))
                              break;

                            tmp_post$271 = sp;
                            sp = sp + 1l;
                            *tmp_post$271 = (signed long int)0;
                          }
                          while((_Bool)1);
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(!(*pc++ == &&LabelEndTrap))
                            break;

                        }
                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelRet:
                          ;
                          signed int neko_interp_loop$$1$$1$$1$$40$$tmp;
                          tmp_post$272 = pc;
                          pc = pc + 1l;
                          neko_interp_loop$$1$$1$$1$$40$$tmp = (signed int)*tmp_post$272;
                          do
                          {
                            tmp_post$273 = neko_interp_loop$$1$$1$$1$$40$$tmp;
                            neko_interp_loop$$1$$1$$1$$40$$tmp = neko_interp_loop$$1$$1$$1$$40$$tmp - 1;
                            if(!(tmp_post$273 >= 1))
                              break;

                            tmp_post$274 = sp;
                            sp = sp + 1l;
                            *tmp_post$274 = (signed long int)0;
                          }
                          while((_Bool)1);
                          m = (struct _neko_module *)*csp;
                          tmp_post$275 = csp;
                          csp = csp - 1l;
                          *tmp_post$275 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post$276 = csp;
                          csp = csp - 1l;
                          *tmp_post$276 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post$277 = csp;
                          csp = csp - 1l;
                          *tmp_post$277 = (signed long int)0;
                          pc = (signed long int *)*csp;
                          tmp_post$278 = csp;
                          csp = csp - 1l;
                          *tmp_post$278 = (signed long int)0;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                        }
                        while(*pc++ == &&LabelRet);
                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelMakeEnv:
                          ;
                          signed int n;
                          tmp_post$279 = pc;
                          pc = pc + 1l;
                          n = (signed int)*tmp_post$279;
                          signed long int neko_interp_loop$$1$$1$$1$$41$$tmp;
                          struct _value *return_value_neko_alloc_array$280;
                          return_value_neko_alloc_array$280=neko_alloc_array((unsigned int)n);
                          neko_interp_loop$$1$$1$$1$$41$$tmp = (signed long int)return_value_neko_alloc_array$280;
                          do
                          {
                            tmp_post$281 = n;
                            n = n - 1;
                            if(tmp_post$281 == 0)
                              break;

                            (&((struct anonymous$4 *)neko_interp_loop$$1$$1$$1$$41$$tmp)->ptr)[(signed long int)n] = (struct _value *)*sp;
                            tmp_post$282 = sp;
                            sp = sp + 1l;
                            *tmp_post$282 = (signed long int)0;
                          }
                          while((_Bool)1);
                          if(!((1 & (signed int)acc) == 0))
                            tmp_if_expr$286 = (_Bool)1;

                          else
                            tmp_if_expr$286 = (signed int)*((enum anonymous$7 *)acc) != VAL_FUNCTION ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$286)
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand$284;
                              return_value_neko_stack_expand$284=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand$284 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string$283=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string$283);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string$285;
                            return_value_neko_alloc_string$285=neko_alloc_string("Invalid environment");
                            neko_val_throw(return_value_neko_alloc_string$285);
                          }

                          struct _value *return_value_neko_alloc_module_function$287;
                          return_value_neko_alloc_module_function$287=neko_alloc_module_function(((struct anonymous$8 *)acc)->module, (signed long int)((struct anonymous$8 *)acc)->addr, ((struct anonymous$8 *)acc)->nargs);
                          acc = (signed long int)return_value_neko_alloc_module_function$287;
                          ((struct anonymous$8 *)acc)->env = (struct _value *)neko_interp_loop$$1$$1$$1$$41$$tmp;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                        }
                        while(*pc++ == &&LabelMakeEnv);
                        if(*pc++ == &&LabelRet)
                          goto LabelRet;

                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelMakeArray:
                          ;
                          signed int neko_interp_loop$$1$$1$$1$$42$$n;
                          tmp_post$288 = pc;
                          pc = pc + 1l;
                          neko_interp_loop$$1$$1$$1$$42$$n = (signed int)*tmp_post$288;
                          struct _value *arr;
                          arr=neko_alloc_array((unsigned int)(neko_interp_loop$$1$$1$$1$$42$$n + 1));
                          for( ; !(neko_interp_loop$$1$$1$$1$$42$$n == 0); neko_interp_loop$$1$$1$$1$$42$$n = neko_interp_loop$$1$$1$$1$$42$$n - 1)
                          {
                            (&((struct anonymous$4 *)arr)->ptr)[(signed long int)neko_interp_loop$$1$$1$$1$$42$$n] = (struct _value *)*sp;
                            tmp_post$289 = sp;
                            sp = sp + 1l;
                            *tmp_post$289 = (signed long int)0;
                          }
                          (&((struct anonymous$4 *)arr)->ptr)[(signed long int)0] = (struct _value *)acc;
                          acc = (signed long int)arr;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                        }
                        while(*pc++ == &&LabelMakeArray);
                        if(*pc++ == &&LabelMakeEnv)
                          goto LabelMakeEnv;

                        if(*pc++ == &&LabelRet)
                          goto LabelRet;

                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelMakeArray2:
                          ;
                          signed int neko_interp_loop$$1$$1$$1$$43$$n;
                          tmp_post$290 = pc;
                          pc = pc + 1l;
                          neko_interp_loop$$1$$1$$1$$43$$n = (signed int)*tmp_post$290;
                          struct _value *neko_interp_loop$$1$$1$$1$$43$$arr;
                          neko_interp_loop$$1$$1$$1$$43$$arr=neko_alloc_array((unsigned int)(neko_interp_loop$$1$$1$$1$$43$$n + 1));
                          if(neko_interp_loop$$1$$1$$1$$43$$n == 2)
                            neko_interp_loop$$1$$1$$1$$43$$n = neko_interp_loop$$1$$1$$1$$43$$n + 0;

                          (&((struct anonymous$4 *)neko_interp_loop$$1$$1$$1$$43$$arr)->ptr)[(signed long int)neko_interp_loop$$1$$1$$1$$43$$n] = (struct _value *)acc;
                          for( ; !(neko_interp_loop$$1$$1$$1$$43$$n == 0); *tmp_post$291 = (signed long int)0)
                          {
                            neko_interp_loop$$1$$1$$1$$43$$n = neko_interp_loop$$1$$1$$1$$43$$n - 1;
                            (&((struct anonymous$4 *)neko_interp_loop$$1$$1$$1$$43$$arr)->ptr)[(signed long int)neko_interp_loop$$1$$1$$1$$43$$n] = (struct _value *)*sp;
                            tmp_post$291 = sp;
                            sp = sp + 1l;
                          }
                          acc = (signed long int)neko_interp_loop$$1$$1$$1$$43$$arr;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                        }
                        while(*pc++ == &&LabelMakeArray2);
                        if(*pc++ == &&LabelLoop)
                          goto LabelLoop;

                        if(*pc++ == &&LabelTailCall)
                          goto LabelTailCall;

                        if(*pc++ == &&LabelPhysCompare)
                          goto LabelPhysCompare;

                        if(*pc++ == &&LabelAccIndex1)
                          goto LabelAccIndex1;

                        if(*pc++ == &&LabelAccIndex0)
                          goto LabelAccIndex0;

                        if(*pc++ == &&LabelAccStack1)
                          goto LabelAccStack1;

                        if(*pc++ == &&LabelAccStack0)
                          goto LabelAccStack0;

                        if(*pc++ == &&LabelApply)
                          goto LabelApply;

                        if(*pc++ == &&LabelJumpTable)
                          goto LabelJumpTable;

                        if(*pc++ == &&LabelNew)
                          goto LabelNew;

                        if(*pc++ == &&LabelHash)
                          goto LabelHash;

                        if(*pc++ == &&LabelCompare)
                          goto LabelCompare;

                        if(*pc++ == &&LabelTypeOf)
                          goto LabelTypeOf;

                        if(!(*pc++ == &&LabelNot))
                        {
                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(!(*pc++ == &&LabelBool))
                          {
                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelBool:
                            ;
                            acc = acc == (signed long int)val_false || acc == (signed long int)val_null || acc == (signed long int)1 ? (signed long int)val_false : (signed long int)val_true;
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                          }
                          while(*pc++ == &&LabelBool);
                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(*pc++ == &&LabelCall)
                            goto LabelCall;

                          if(*pc++ == &&LabelPop)
                            goto LabelPop;

                          if(*pc++ == &&LabelPush)
                            goto LabelPush;

                          if(*pc++ == &&LabelSetThis)
                            goto LabelSetThis;

                          if(*pc++ == &&LabelSetIndex)
                            goto LabelSetIndex;

                          if(*pc++ == &&LabelSetArray)
                            goto LabelSetArray;

                          if(*pc++ == &&LabelSetField)
                            goto LabelSetField;

                          if(*pc++ == &&LabelSetEnv)
                            goto LabelSetEnv;

                          if(*pc++ == &&LabelSetGlobal)
                            goto LabelSetGlobal;

                          if(*pc++ == &&LabelSetStack)
                            goto LabelSetStack;

                          if(*pc++ == &&LabelAccBuiltin)
                            goto LabelAccBuiltin;

                          if(*pc++ == &&LabelAccIndex)
                            goto LabelAccIndex;

                          if(*pc++ == &&LabelAccArray)
                            goto LabelAccArray;

                          if(*pc++ == &&LabelAccField)
                            goto LabelAccField;

                          if(*pc++ == &&LabelAccEnv)
                            goto LabelAccEnv;

                          if(*pc++ == &&LabelAccGlobal)
                            goto LabelAccGlobal;

                          if(*pc++ == &&LabelAccStack)
                            goto LabelAccStack;

                          if(*pc++ == &&LabelAccInt)
                            goto LabelAccInt;

                          if(*pc++ == &&LabelAccThis)
                            goto LabelAccThis;

                          if(*pc++ == &&LabelAccFalse)
                            goto LabelAccFalse;

                          if(*pc++ == &&LabelAccTrue)
                            goto LabelAccTrue;

                          if(*pc++ == &&LabelAccNull)
                            goto LabelAccNull;

                          if(*pc++ == &&end)
                            goto end;

                        }

                        do
                        {

                        LabelNot:
                          ;
                          acc = acc == (signed long int)val_false || acc == (signed long int)val_null || acc == (signed long int)1 ? (signed long int)val_true : (signed long int)val_false;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                        }
                        while(*pc++ == &&LabelNot);
                        if(*pc++ == &&LabelLte)
                          goto LabelLte;

                        if(*pc++ == &&LabelLt)
                          goto LabelLt;

                        if(*pc++ == &&LabelGte)
                          goto LabelGte;

                        if(*pc++ == &&LabelGt)
                          goto LabelGt;

                        if(*pc++ == &&LabelNeq)
                          goto LabelNeq;

                        if(*pc++ == &&LabelEq)
                          goto LabelEq;

                        if(*pc++ == &&LabelXor)
                          goto LabelXor;

                        if(*pc++ == &&LabelAnd)
                          goto LabelAnd;

                        if(*pc++ == &&LabelOr)
                          goto LabelOr;

                        if(*pc++ == &&LabelUShr)
                          goto LabelUShr;

                        if(*pc++ == &&LabelShr)
                          goto LabelShr;

                        if(*pc++ == &&LabelShl)
                          goto LabelShl;

                        if(*pc++ == &&LabelMod)
                          goto LabelMod;

                        if(*pc++ == &&LabelDiv)
                          goto LabelDiv;

                        if(*pc++ == &&LabelMult)
                          goto LabelMult;

                        if(*pc++ == &&LabelSub)
                          goto LabelSub;

                        if(!(*pc++ == &&LabelAdd))
                        {
                          if(!(*pc++ == &&LabelIsNotNull))
                          {
                            if(!(*pc++ == &&LabelIsNull))
                            {
                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelIsNull:
                              ;
                              acc = (signed long int)(acc == (signed long int)val_null ? val_true : val_false);
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                            }
                            while(*pc++ == &&LabelIsNull);
                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelIsNotNull:
                            ;
                            acc = (signed long int)(acc == (signed long int)val_null ? val_false : val_true);
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                          }
                          while(*pc++ == &&LabelIsNotNull);
                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(*pc++ == &&LabelCall)
                            goto LabelCall;

                          if(*pc++ == &&LabelPop)
                            goto LabelPop;

                          if(*pc++ == &&LabelPush)
                            goto LabelPush;

                          if(*pc++ == &&LabelSetThis)
                            goto LabelSetThis;

                          if(*pc++ == &&LabelSetIndex)
                            goto LabelSetIndex;

                          if(*pc++ == &&LabelSetArray)
                            goto LabelSetArray;

                          if(*pc++ == &&LabelSetField)
                            goto LabelSetField;

                          if(*pc++ == &&LabelSetEnv)
                            goto LabelSetEnv;

                          if(*pc++ == &&LabelSetGlobal)
                            goto LabelSetGlobal;

                          if(*pc++ == &&LabelSetStack)
                            goto LabelSetStack;

                          if(*pc++ == &&LabelAccBuiltin)
                            goto LabelAccBuiltin;

                          if(*pc++ == &&LabelAccIndex)
                            goto LabelAccIndex;

                          if(*pc++ == &&LabelAccArray)
                            goto LabelAccArray;

                          if(*pc++ == &&LabelAccField)
                            goto LabelAccField;

                          if(*pc++ == &&LabelAccEnv)
                            goto LabelAccEnv;

                          if(*pc++ == &&LabelAccGlobal)
                            goto LabelAccGlobal;

                          if(*pc++ == &&LabelAccStack)
                            goto LabelAccStack;

                          if(*pc++ == &&LabelAccInt)
                            goto LabelAccInt;

                          if(*pc++ == &&LabelAccThis)
                            goto LabelAccThis;

                          if(*pc++ == &&LabelAccFalse)
                            goto LabelAccFalse;

                          if(*pc++ == &&LabelAccTrue)
                            goto LabelAccTrue;

                          if(*pc++ == &&LabelAccNull)
                            goto LabelAccNull;

                          if(*pc++ == &&end)
                            goto end;

                        }


                      LabelAdd:
                        ;
                        if(!((1l & acc) == 0l))
                          tmp_if_expr$352 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr$352 = (_Bool)0;
                        if(tmp_if_expr$352)
                        {
                          if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + (unsigned int)((signed int)acc >> 1) & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32$292=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) + ((signed int)(signed long int)acc >> 1));
                            tmp_if_expr$293 = return_value_neko_alloc_int32$292;
                          }

                          else
                            tmp_if_expr$293 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) + ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                          acc = (signed long int)tmp_if_expr$293;
                          goto __CPROVER_DUMP_L546;
                        }

                        if(!((1l & acc) == 0l))
                        {
                          if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                          {
                            return_value_neko_alloc_float$294=neko_alloc_float(((struct anonymous$25 *)*sp)->f + (double)((signed int)(signed long int)acc >> 1));
                            acc = (signed long int)return_value_neko_alloc_float$294;
                          }

                          else
                            if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                            {
                              if(!((1073741824u + (unsigned int)((signed int)acc >> 1) + (unsigned int)((struct anonymous$26 *)*sp)->i & 0x80000000) == 0u))
                              {
                                return_value_neko_alloc_int32$295=neko_alloc_int32(((struct anonymous$26 *)*sp)->i + ((signed int)(signed long int)acc >> 1));
                                tmp_if_expr$296 = return_value_neko_alloc_int32$295;
                              }

                              else
                                tmp_if_expr$296 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i + ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                              acc = (signed long int)tmp_if_expr$296;
                            }

                            else
                              if((15 & (signed int)*((enum anonymous$7 *)*sp)) == VAL_STRING)
                              {
                                return_value_neko_append_int$297=neko_append_int(vm, (struct _value *)*sp, (signed int)(signed long int)acc >> 1, 1);
                                acc = (signed long int)return_value_neko_append_int$297;
                              }

                              else
                                if((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT)
                                {
                                  struct _value *neko_interp_loop$$1$$1$$1$$44$$1$$_o = (struct _value *)*sp;
                                  struct _value *neko_interp_loop$$1$$1$$1$$44$$1$$_arg = (struct _value *)acc;
                                  struct _value *neko_interp_loop$$1$$1$$1$$44$$1$$_f;
                                  neko_interp_loop$$1$$1$$1$$44$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$44$$1$$_o, id_add);
                                  if(neko_interp_loop$$1$$1$$1$$44$$1$$_f == val_null)
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$299;
                                      return_value_neko_stack_expand$299=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$299 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$298=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$298);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$300;
                                    return_value_neko_alloc_string$300=neko_alloc_string("Unsupported operation");
                                    neko_val_throw(return_value_neko_alloc_string$300);
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$302;
                                      return_value_neko_stack_expand$302=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$302 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$301=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$301);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_val_callEx$303;
                                    return_value_neko_val_callEx$303=neko_val_callEx(neko_interp_loop$$1$$1$$1$$44$$1$$_o, neko_interp_loop$$1$$1$$1$$44$$1$$_f, &neko_interp_loop$$1$$1$$1$$44$$1$$_arg, 1, (struct _value **)(void *)0);
                                    acc = (signed long int)return_value_neko_val_callEx$303;
                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$304 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$304 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$305 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$305 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$306 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$306 = (signed long int)0;
                                    tmp_post$307 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$307 = (signed long int)0;
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$309;
                                    return_value_neko_stack_expand$309=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$309 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$308=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$308);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string$310;
                                  return_value_neko_alloc_string$310=neko_alloc_string("Invalid operation (+)");
                                  neko_val_throw(return_value_neko_alloc_string$310);
                                }
                          goto __CPROVER_DUMP_L546;
                        }

                        if(!((1l & *sp) == 0l))
                        {
                          if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
                          {
                            return_value_neko_alloc_float$311=neko_alloc_float((double)((signed int)(signed long int)*sp >> 1) + ((struct anonymous$25 *)acc)->f);
                            acc = (signed long int)return_value_neko_alloc_float$311;
                          }

                          else
                            if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
                            {
                              if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + (unsigned int)((struct anonymous$26 *)acc)->i & 0x80000000) == 0u))
                              {
                                return_value_neko_alloc_int32$312=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) + ((struct anonymous$26 *)acc)->i);
                                tmp_if_expr$313 = return_value_neko_alloc_int32$312;
                              }

                              else
                                tmp_if_expr$313 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) + ((struct anonymous$26 *)acc)->i) << 1 | 1);
                              acc = (signed long int)tmp_if_expr$313;
                            }

                            else
                              if((15 & (signed int)*((enum anonymous$7 *)acc)) == VAL_STRING)
                              {
                                return_value_neko_append_int$314=neko_append_int(vm, (struct _value *)acc, (signed int)(signed long int)*sp >> 1, 0);
                                acc = (signed long int)return_value_neko_append_int$314;
                              }

                              else
                                if((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT)
                                {
                                  struct _value *neko_interp_loop$$1$$1$$1$$45$$1$$_o = (struct _value *)acc;
                                  struct _value *neko_interp_loop$$1$$1$$1$$45$$1$$_arg = (struct _value *)*sp;
                                  struct _value *neko_interp_loop$$1$$1$$1$$45$$1$$_f;
                                  neko_interp_loop$$1$$1$$1$$45$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$45$$1$$_o, id_radd);
                                  if(neko_interp_loop$$1$$1$$1$$45$$1$$_f == val_null)
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$316;
                                      return_value_neko_stack_expand$316=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$316 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$315=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$315);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$317;
                                    return_value_neko_alloc_string$317=neko_alloc_string("Unsupported operation");
                                    neko_val_throw(return_value_neko_alloc_string$317);
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$319;
                                      return_value_neko_stack_expand$319=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$319 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$318=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$318);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_val_callEx$320;
                                    return_value_neko_val_callEx$320=neko_val_callEx(neko_interp_loop$$1$$1$$1$$45$$1$$_o, neko_interp_loop$$1$$1$$1$$45$$1$$_f, &neko_interp_loop$$1$$1$$1$$45$$1$$_arg, 1, (struct _value **)(void *)0);
                                    acc = (signed long int)return_value_neko_val_callEx$320;
                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post$321 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$321 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post$322 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$322 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post$323 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$323 = (signed long int)0;
                                    tmp_post$324 = csp;
                                    csp = csp - 1l;
                                    *tmp_post$324 = (signed long int)0;
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$326;
                                    return_value_neko_stack_expand$326=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$326 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$325=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$325);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string$327;
                                  return_value_neko_alloc_string$327=neko_alloc_string("Invalid operation (+)");
                                  neko_val_throw(return_value_neko_alloc_string$327);
                                }
                          goto __CPROVER_DUMP_L546;
                        }

                        if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
                        {
                          if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                          {
                            return_value_neko_alloc_float$328=neko_alloc_float(((struct anonymous$25 *)*sp)->f + ((struct anonymous$25 *)acc)->f);
                            acc = (signed long int)return_value_neko_alloc_float$328;
                          }

                          else
                            if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                            {
                              return_value_neko_alloc_float$329=neko_alloc_float((double)((struct anonymous$26 *)*sp)->i + ((struct anonymous$25 *)acc)->f);
                              acc = (signed long int)return_value_neko_alloc_float$329;
                            }

                            else
                              goto add_next;
                          goto __CPROVER_DUMP_L546;
                        }

                        if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
                        {
                          if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                          {
                            if(!((1073741824u + (unsigned int)((struct anonymous$26 *)*sp)->i + (unsigned int)((struct anonymous$26 *)acc)->i & 0x80000000) == 0u))
                            {
                              return_value_neko_alloc_int32$330=neko_alloc_int32(((struct anonymous$26 *)*sp)->i + ((struct anonymous$26 *)acc)->i);
                              tmp_if_expr$331 = return_value_neko_alloc_int32$330;
                            }

                            else
                              tmp_if_expr$331 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i + ((struct anonymous$26 *)acc)->i) << 1 | 1);
                            acc = (signed long int)tmp_if_expr$331;
                          }

                          else
                            if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                            {
                              return_value_neko_alloc_float$332=neko_alloc_float(((struct anonymous$25 *)*sp)->f + (double)((struct anonymous$26 *)acc)->i);
                              acc = (signed long int)return_value_neko_alloc_float$332;
                            }

                            else
                              goto add_next;
                          goto __CPROVER_DUMP_L546;
                        }

                      }


                    add_next:
                      ;
                      if((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT)
                      {
                        struct _value *neko_interp_loop$$1$$1$$1$$48$$1$$_o = (struct _value *)*sp;
                        struct _value *neko_interp_loop$$1$$1$$1$$48$$1$$_arg = (struct _value *)acc;
                        struct _value *neko_interp_loop$$1$$1$$1$$48$$1$$_f;
                        neko_interp_loop$$1$$1$$1$$48$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$48$$1$$_o, id_add);
                        if(neko_interp_loop$$1$$1$$1$$48$$1$$_f == val_null)
                          goto add_2;

                        else
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand$334;
                            return_value_neko_stack_expand$334=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand$334 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string$333=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string$333);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_val_callEx$335;
                          return_value_neko_val_callEx$335=neko_val_callEx(neko_interp_loop$$1$$1$$1$$48$$1$$_o, neko_interp_loop$$1$$1$$1$$48$$1$$_f, &neko_interp_loop$$1$$1$$1$$48$$1$$_arg, 1, (struct _value **)(void *)0);
                          acc = (signed long int)return_value_neko_val_callEx$335;
                          sp = vm->sp;
                          csp = vm->csp;
                          m = (struct _neko_module *)*csp;
                          tmp_post$336 = csp;
                          csp = csp - 1l;
                          *tmp_post$336 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post$337 = csp;
                          csp = csp - 1l;
                          *tmp_post$337 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post$338 = csp;
                          csp = csp - 1l;
                          *tmp_post$338 = (signed long int)0;
                          tmp_post$339 = csp;
                          csp = csp - 1l;
                          *tmp_post$339 = (signed long int)0;
                        }
                        goto __CPROVER_DUMP_L546;
                      }

                    }


                  add_2:
                    ;
                    if(!((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT))
                      goto add_3;

                    struct _value *neko_interp_loop$$1$$1$$1$$48$$2$$1$$_o = (struct _value *)acc;
                    struct _value *neko_interp_loop$$1$$1$$1$$48$$2$$1$$_arg = (struct _value *)*sp;
                    struct _value *neko_interp_loop$$1$$1$$1$$48$$2$$1$$_f;
                    neko_interp_loop$$1$$1$$1$$48$$2$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$48$$2$$1$$_o, id_radd);
                    if(neko_interp_loop$$1$$1$$1$$48$$2$$1$$_f == val_null)
                      goto add_3;

                    else
                    {
                      if(csp + 4l >= sp)
                      {
                        signed int return_value_neko_stack_expand$341;
                        return_value_neko_stack_expand$341=neko_stack_expand(sp, csp, vm);
                        if(!(return_value_neko_stack_expand$341 == 0))
                        {
                          sp = vm->sp;
                          csp = vm->csp;
                        }

                        else
                        {
                          return_value_neko_alloc_string$340=neko_alloc_string("Stack Overflow");
                          neko_val_throw(return_value_neko_alloc_string$340);
                        }
                      }

                      csp = csp + 1l;
                      *csp = (signed long int)pc;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->env;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->vthis;
                      csp = csp + 1l;
                      *csp = (signed long int)m;
                      vm->sp = sp;
                      vm->csp = csp;
                      struct _value *return_value_neko_val_callEx$342;
                      return_value_neko_val_callEx$342=neko_val_callEx(neko_interp_loop$$1$$1$$1$$48$$2$$1$$_o, neko_interp_loop$$1$$1$$1$$48$$2$$1$$_f, &neko_interp_loop$$1$$1$$1$$48$$2$$1$$_arg, 1, (struct _value **)(void *)0);
                      acc = (signed long int)return_value_neko_val_callEx$342;
                      sp = vm->sp;
                      csp = vm->csp;
                      m = (struct _neko_module *)*csp;
                      tmp_post$343 = csp;
                      csp = csp - 1l;
                      *tmp_post$343 = (signed long int)0;
                      vm->vthis = (struct _value *)*csp;
                      tmp_post$344 = csp;
                      csp = csp - 1l;
                      *tmp_post$344 = (signed long int)0;
                      vm->env = (struct _value *)*csp;
                      tmp_post$345 = csp;
                      csp = csp - 1l;
                      *tmp_post$345 = (signed long int)0;
                      tmp_post$346 = csp;
                      csp = csp - 1l;
                      *tmp_post$346 = (signed long int)0;
                    }
                  }

                  else
                  {

                  add_3:
                    ;
                    if((15 & (signed int)*((enum anonymous$7 *)acc)) == VAL_STRING)
                      tmp_if_expr$351 = (_Bool)1;

                    else
                      tmp_if_expr$351 = ((signed int)*((enum anonymous$7 *)*sp) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$351)
                    {
                      struct _buffer *neko_interp_loop$$1$$1$$1$$48$$2$$2$$1$$b;
                      neko_interp_loop$$1$$1$$1$$48$$2$$2$$1$$b=neko_alloc_buffer((const char *)(void *)0);
                      vm->sp = sp;
                      vm->csp = csp;
                      neko_val_buffer(neko_interp_loop$$1$$1$$1$$48$$2$$2$$1$$b, (struct _value *)*sp);
                      neko_val_buffer(neko_interp_loop$$1$$1$$1$$48$$2$$2$$1$$b, (struct _value *)acc);
                      sp = vm->sp;
                      csp = vm->csp;
                      struct _value *return_value_neko_buffer_to_string$347;
                      return_value_neko_buffer_to_string$347=neko_buffer_to_string(neko_interp_loop$$1$$1$$1$$48$$2$$2$$1$$b);
                      acc = (signed long int)return_value_neko_buffer_to_string$347;
                    }

                    else
                    {
                      if(csp + 4l >= sp)
                      {
                        signed int return_value_neko_stack_expand$349;
                        return_value_neko_stack_expand$349=neko_stack_expand(sp, csp, vm);
                        if(!(return_value_neko_stack_expand$349 == 0))
                        {
                          sp = vm->sp;
                          csp = vm->csp;
                        }

                        else
                        {
                          return_value_neko_alloc_string$348=neko_alloc_string("Stack Overflow");
                          neko_val_throw(return_value_neko_alloc_string$348);
                        }
                      }

                      csp = csp + 1l;
                      *csp = (signed long int)pc;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->env;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->vthis;
                      csp = csp + 1l;
                      *csp = (signed long int)m;
                      vm->sp = sp;
                      vm->csp = csp;
                      struct _value *return_value_neko_alloc_string$350;
                      return_value_neko_alloc_string$350=neko_alloc_string("Invalid operation (+)");
                      neko_val_throw(return_value_neko_alloc_string$350);
                    }
                  }

                __CPROVER_DUMP_L546:
                  ;
                  tmp_post$353 = sp;
                  sp = sp + 1l;
                  *tmp_post$353 = (signed long int)0;
                  *pc++;
                  if(*pc++ == &&id_mod_next2)
                    goto id_mod_next2;

                  if(*pc++ == &&id_mod_next)
                    goto id_mod_next;

                  if(*pc++ == &&div_next)
                    goto div_next;

                  if(*pc++ == &&id_mult_next2)
                    goto id_mult_next2;

                  if(*pc++ == &&id_mult_next)
                    goto id_mult_next;

                  if(*pc++ == &&id_sub_next2)
                    goto id_sub_next2;

                  if(!(*pc++ == &&id_sub_next))
                  {
                    if(*pc++ == &&add_3)
                      goto add_3;

                    if(*pc++ == &&add_2)
                      goto add_2;

                    if(*pc++ == &&add_next)
                      goto add_next;

                    if(*pc++ == &&do_call)
                      goto LabelCall;

                    if(*pc++ == &&LabelLast)
                      goto LabelLast;

                    if(*pc++ == &&LabelAccInt32)
                      goto LabelAccInt32;

                    if(*pc++ == &&LabelMakeArray2)
                      goto LabelMakeArray2;

                    if(*pc++ == &&LabelLoop)
                      goto LabelLoop;

                    if(*pc++ == &&LabelTailCall)
                      goto LabelTailCall;

                    if(*pc++ == &&LabelPhysCompare)
                      goto LabelPhysCompare;

                    if(*pc++ == &&LabelAccIndex1)
                      goto LabelAccIndex1;

                    if(*pc++ == &&LabelAccIndex0)
                      goto LabelAccIndex0;

                    if(*pc++ == &&LabelAccStack1)
                      goto LabelAccStack1;

                    if(*pc++ == &&LabelAccStack0)
                      goto LabelAccStack0;

                    if(*pc++ == &&LabelApply)
                      goto LabelApply;

                    if(*pc++ == &&LabelJumpTable)
                      goto LabelJumpTable;

                    if(*pc++ == &&LabelNew)
                      goto LabelNew;

                    if(*pc++ == &&LabelHash)
                      goto LabelHash;

                    if(*pc++ == &&LabelCompare)
                      goto LabelCompare;

                    if(*pc++ == &&LabelTypeOf)
                      goto LabelTypeOf;

                    if(*pc++ == &&LabelNot)
                      goto LabelNot;

                    if(*pc++ == &&LabelLte)
                      goto LabelLte;

                    if(*pc++ == &&LabelLt)
                      goto LabelLt;

                    if(*pc++ == &&LabelGte)
                      goto LabelGte;

                    if(*pc++ == &&LabelGt)
                      goto LabelGt;

                    if(*pc++ == &&LabelNeq)
                      goto LabelNeq;

                    if(*pc++ == &&LabelEq)
                      goto LabelEq;

                    if(*pc++ == &&LabelXor)
                      goto LabelXor;

                    if(*pc++ == &&LabelAnd)
                      goto LabelAnd;

                    if(*pc++ == &&LabelOr)
                      goto LabelOr;

                    if(*pc++ == &&LabelUShr)
                      goto LabelUShr;

                    if(*pc++ == &&LabelShr)
                      goto LabelShr;

                    if(*pc++ == &&LabelShl)
                      goto LabelShl;

                    if(*pc++ == &&LabelMod)
                      goto LabelMod;

                    if(*pc++ == &&LabelDiv)
                      goto LabelDiv;

                    if(*pc++ == &&LabelMult)
                      goto LabelMult;

                    if(!(*pc++ == &&LabelSub))
                    {
                      if(*pc++ == &&LabelAdd)
                        goto LabelAdd;

                      if(*pc++ == &&LabelIsNotNull)
                        goto LabelIsNotNull;

                      if(*pc++ == &&LabelIsNull)
                        goto LabelIsNull;

                      if(*pc++ == &&LabelBool)
                        goto LabelBool;

                      if(*pc++ == &&LabelMakeArray)
                        goto LabelMakeArray;

                      if(*pc++ == &&LabelMakeEnv)
                        goto LabelMakeEnv;

                      if(*pc++ == &&LabelRet)
                        goto LabelRet;

                      if(*pc++ == &&LabelEndTrap)
                        goto LabelEndTrap;

                      if(*pc++ == &&LabelTrap)
                        goto LabelTrap;

                      if(*pc++ == &&LabelJumpIfNot)
                        goto LabelJumpIfNot;

                      if(*pc++ == &&LabelJumpIf)
                        goto LabelJumpIf;

                      if(*pc++ == &&LabelJump)
                        goto LabelJump;

                      if(*pc++ == &&LabelObjCall)
                        goto LabelObjCall;

                      if(*pc++ == &&LabelCall)
                        goto LabelCall;

                      if(*pc++ == &&LabelPop)
                        goto LabelPop;

                      if(*pc++ == &&LabelPush)
                        goto LabelPush;

                      if(*pc++ == &&LabelSetThis)
                        goto LabelSetThis;

                      if(*pc++ == &&LabelSetIndex)
                        goto LabelSetIndex;

                      if(*pc++ == &&LabelSetArray)
                        goto LabelSetArray;

                      if(*pc++ == &&LabelSetField)
                        goto LabelSetField;

                      if(*pc++ == &&LabelSetEnv)
                        goto LabelSetEnv;

                      if(*pc++ == &&LabelSetGlobal)
                        goto LabelSetGlobal;

                      if(*pc++ == &&LabelSetStack)
                        goto LabelSetStack;

                      if(*pc++ == &&LabelAccBuiltin)
                        goto LabelAccBuiltin;

                      if(*pc++ == &&LabelAccIndex)
                        goto LabelAccIndex;

                      if(*pc++ == &&LabelAccArray)
                        goto LabelAccArray;

                      if(*pc++ == &&LabelAccField)
                        goto LabelAccField;

                      if(*pc++ == &&LabelAccEnv)
                        goto LabelAccEnv;

                      if(*pc++ == &&LabelAccGlobal)
                        goto LabelAccGlobal;

                      if(*pc++ == &&LabelAccStack)
                        goto LabelAccStack;

                      if(*pc++ == &&LabelAccInt)
                        goto LabelAccInt;

                      if(*pc++ == &&LabelAccThis)
                        goto LabelAccThis;

                      if(*pc++ == &&LabelAccFalse)
                        goto LabelAccFalse;

                      if(*pc++ == &&LabelAccTrue)
                        goto LabelAccTrue;

                      if(*pc++ == &&LabelAccNull)
                        goto LabelAccNull;

                      if(*pc++ == &&end)
                        goto end;

                    }


                  LabelSub:
                    ;
                    if(!((1l & acc) == 0l))
                      tmp_if_expr$413 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$413 = (_Bool)0;
                    if(tmp_if_expr$413)
                    {
                      if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + -((unsigned int)((signed int)acc >> 1)) & 0x80000000) == 0u))
                      {
                        return_value_neko_alloc_int32$354=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) - ((signed int)(signed long int)acc >> 1));
                        tmp_if_expr$355 = return_value_neko_alloc_int32$354;
                      }

                      else
                        tmp_if_expr$355 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) - ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                      acc = (signed long int)tmp_if_expr$355;
                      goto __CPROVER_DUMP_L627;
                    }

                    if(!((1l & acc) == 0l))
                    {
                      if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                      {
                        return_value_neko_alloc_float$356=neko_alloc_float(((struct anonymous$25 *)*sp)->f - (double)((signed int)(signed long int)acc >> 1));
                        acc = (signed long int)return_value_neko_alloc_float$356;
                      }

                      else
                        if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                        {
                          if(!((1073741824u + (unsigned int)((struct anonymous$26 *)*sp)->i + -((unsigned int)((signed int)acc >> 1)) & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32$357=neko_alloc_int32(((struct anonymous$26 *)*sp)->i - ((signed int)(signed long int)acc >> 1));
                            tmp_if_expr$358 = return_value_neko_alloc_int32$357;
                          }

                          else
                            tmp_if_expr$358 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i - ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                          acc = (signed long int)tmp_if_expr$358;
                        }

                        else
                          if((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT)
                          {
                            struct _value *neko_interp_loop$$1$$1$$1$$49$$1$$_o = (struct _value *)*sp;
                            struct _value *neko_interp_loop$$1$$1$$1$$49$$1$$_arg = (struct _value *)acc;
                            struct _value *neko_interp_loop$$1$$1$$1$$49$$1$$_f;
                            neko_interp_loop$$1$$1$$1$$49$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$49$$1$$_o, id_sub);
                            if(neko_interp_loop$$1$$1$$1$$49$$1$$_f == val_null)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$360;
                                return_value_neko_stack_expand$360=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$360 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$359=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$359);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string$361;
                              return_value_neko_alloc_string$361=neko_alloc_string("Unsupported operation");
                              neko_val_throw(return_value_neko_alloc_string$361);
                            }

                            else
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$363;
                                return_value_neko_stack_expand$363=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$363 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$362=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$362);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_val_callEx$364;
                              return_value_neko_val_callEx$364=neko_val_callEx(neko_interp_loop$$1$$1$$1$$49$$1$$_o, neko_interp_loop$$1$$1$$1$$49$$1$$_f, &neko_interp_loop$$1$$1$$1$$49$$1$$_arg, 1, (struct _value **)(void *)0);
                              acc = (signed long int)return_value_neko_val_callEx$364;
                              sp = vm->sp;
                              csp = vm->csp;
                              m = (struct _neko_module *)*csp;
                              tmp_post$365 = csp;
                              csp = csp - 1l;
                              *tmp_post$365 = (signed long int)0;
                              vm->vthis = (struct _value *)*csp;
                              tmp_post$366 = csp;
                              csp = csp - 1l;
                              *tmp_post$366 = (signed long int)0;
                              vm->env = (struct _value *)*csp;
                              tmp_post$367 = csp;
                              csp = csp - 1l;
                              *tmp_post$367 = (signed long int)0;
                              tmp_post$368 = csp;
                              csp = csp - 1l;
                              *tmp_post$368 = (signed long int)0;
                            }
                          }

                          else
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand$370;
                              return_value_neko_stack_expand$370=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand$370 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string$369=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string$369);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string$371;
                            return_value_neko_alloc_string$371=neko_alloc_string("Invalid operation (-)");
                            neko_val_throw(return_value_neko_alloc_string$371);
                          }
                      goto __CPROVER_DUMP_L627;
                    }

                    if(!((1l & *sp) == 0l))
                    {
                      if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
                      {
                        return_value_neko_alloc_float$372=neko_alloc_float((double)((signed int)(signed long int)*sp >> 1) - ((struct anonymous$25 *)acc)->f);
                        acc = (signed long int)return_value_neko_alloc_float$372;
                      }

                      else
                        if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
                        {
                          if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + -((unsigned int)((struct anonymous$26 *)acc)->i) & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32$373=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) - ((struct anonymous$26 *)acc)->i);
                            tmp_if_expr$374 = return_value_neko_alloc_int32$373;
                          }

                          else
                            tmp_if_expr$374 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) - ((struct anonymous$26 *)acc)->i) << 1 | 1);
                          acc = (signed long int)tmp_if_expr$374;
                        }

                        else
                          if((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT)
                          {
                            struct _value *neko_interp_loop$$1$$1$$1$$50$$1$$_o = (struct _value *)acc;
                            struct _value *neko_interp_loop$$1$$1$$1$$50$$1$$_arg = (struct _value *)*sp;
                            struct _value *neko_interp_loop$$1$$1$$1$$50$$1$$_f;
                            neko_interp_loop$$1$$1$$1$$50$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$50$$1$$_o, id_rsub);
                            if(neko_interp_loop$$1$$1$$1$$50$$1$$_f == val_null)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$376;
                                return_value_neko_stack_expand$376=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$376 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$375=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$375);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string$377;
                              return_value_neko_alloc_string$377=neko_alloc_string("Unsupported operation");
                              neko_val_throw(return_value_neko_alloc_string$377);
                            }

                            else
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$379;
                                return_value_neko_stack_expand$379=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$379 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$378=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$378);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_val_callEx$380;
                              return_value_neko_val_callEx$380=neko_val_callEx(neko_interp_loop$$1$$1$$1$$50$$1$$_o, neko_interp_loop$$1$$1$$1$$50$$1$$_f, &neko_interp_loop$$1$$1$$1$$50$$1$$_arg, 1, (struct _value **)(void *)0);
                              acc = (signed long int)return_value_neko_val_callEx$380;
                              sp = vm->sp;
                              csp = vm->csp;
                              m = (struct _neko_module *)*csp;
                              tmp_post$381 = csp;
                              csp = csp - 1l;
                              *tmp_post$381 = (signed long int)0;
                              vm->vthis = (struct _value *)*csp;
                              tmp_post$382 = csp;
                              csp = csp - 1l;
                              *tmp_post$382 = (signed long int)0;
                              vm->env = (struct _value *)*csp;
                              tmp_post$383 = csp;
                              csp = csp - 1l;
                              *tmp_post$383 = (signed long int)0;
                              tmp_post$384 = csp;
                              csp = csp - 1l;
                              *tmp_post$384 = (signed long int)0;
                            }
                          }

                          else
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand$386;
                              return_value_neko_stack_expand$386=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand$386 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string$385=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string$385);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string$387;
                            return_value_neko_alloc_string$387=neko_alloc_string("Invalid operation (-)");
                            neko_val_throw(return_value_neko_alloc_string$387);
                          }
                      goto __CPROVER_DUMP_L627;
                    }

                    if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
                    {
                      if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                      {
                        return_value_neko_alloc_float$388=neko_alloc_float(((struct anonymous$25 *)*sp)->f - ((struct anonymous$25 *)acc)->f);
                        acc = (signed long int)return_value_neko_alloc_float$388;
                      }

                      else
                        if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                        {
                          return_value_neko_alloc_float$389=neko_alloc_float((double)((struct anonymous$26 *)*sp)->i - ((struct anonymous$25 *)acc)->f);
                          acc = (signed long int)return_value_neko_alloc_float$389;
                        }

                        else
                          goto id_sub_next;
                      goto __CPROVER_DUMP_L627;
                    }

                    if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
                    {
                      if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                      {
                        if(!((1073741824u + (unsigned int)((struct anonymous$26 *)*sp)->i + -((unsigned int)((struct anonymous$26 *)acc)->i) & 0x80000000) == 0u))
                        {
                          return_value_neko_alloc_int32$390=neko_alloc_int32(((struct anonymous$26 *)*sp)->i - ((struct anonymous$26 *)acc)->i);
                          tmp_if_expr$391 = return_value_neko_alloc_int32$390;
                        }

                        else
                          tmp_if_expr$391 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i - ((struct anonymous$26 *)acc)->i) << 1 | 1);
                        acc = (signed long int)tmp_if_expr$391;
                      }

                      else
                        if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                        {
                          return_value_neko_alloc_float$392=neko_alloc_float(((struct anonymous$25 *)*sp)->f - (double)((struct anonymous$26 *)acc)->i);
                          acc = (signed long int)return_value_neko_alloc_float$392;
                        }

                        else
                          goto id_sub_next;
                      goto __CPROVER_DUMP_L627;
                    }

                  }

                }


              id_sub_next:
                ;
                if(!((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT))
                  goto id_sub_next2;

                struct _value *neko_interp_loop$$1$$1$$1$$53$$1$$_o = (struct _value *)*sp;
                struct _value *neko_interp_loop$$1$$1$$1$$53$$1$$_arg = (struct _value *)acc;
                struct _value *neko_interp_loop$$1$$1$$1$$53$$1$$_f;
                neko_interp_loop$$1$$1$$1$$53$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$53$$1$$_o, id_sub);
                if(neko_interp_loop$$1$$1$$1$$53$$1$$_f == val_null)
                  goto id_sub_next2;

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand$394;
                    return_value_neko_stack_expand$394=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand$394 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string$393=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string$393);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_val_callEx$395;
                  return_value_neko_val_callEx$395=neko_val_callEx(neko_interp_loop$$1$$1$$1$$53$$1$$_o, neko_interp_loop$$1$$1$$1$$53$$1$$_f, &neko_interp_loop$$1$$1$$1$$53$$1$$_arg, 1, (struct _value **)(void *)0);
                  acc = (signed long int)return_value_neko_val_callEx$395;
                  sp = vm->sp;
                  csp = vm->csp;
                  m = (struct _neko_module *)*csp;
                  tmp_post$396 = csp;
                  csp = csp - 1l;
                  *tmp_post$396 = (signed long int)0;
                  vm->vthis = (struct _value *)*csp;
                  tmp_post$397 = csp;
                  csp = csp - 1l;
                  *tmp_post$397 = (signed long int)0;
                  vm->env = (struct _value *)*csp;
                  tmp_post$398 = csp;
                  csp = csp - 1l;
                  *tmp_post$398 = (signed long int)0;
                  tmp_post$399 = csp;
                  csp = csp - 1l;
                  *tmp_post$399 = (signed long int)0;
                }
              }

              else
              {

              id_sub_next2:
                ;
                if((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT)
                {
                  struct _value *neko_interp_loop$$1$$1$$1$$53$$2$$1$$_o = (struct _value *)acc;
                  struct _value *neko_interp_loop$$1$$1$$1$$53$$2$$1$$_arg = (struct _value *)*sp;
                  struct _value *neko_interp_loop$$1$$1$$1$$53$$2$$1$$_f;
                  neko_interp_loop$$1$$1$$1$$53$$2$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$53$$2$$1$$_o, id_rsub);
                  if(neko_interp_loop$$1$$1$$1$$53$$2$$1$$_f == val_null)
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand$401;
                      return_value_neko_stack_expand$401=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand$401 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string$400=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string$400);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_alloc_string$402;
                    return_value_neko_alloc_string$402=neko_alloc_string("Unsupported operation");
                    neko_val_throw(return_value_neko_alloc_string$402);
                  }

                  else
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand$404;
                      return_value_neko_stack_expand$404=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand$404 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string$403=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string$403);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_val_callEx$405;
                    return_value_neko_val_callEx$405=neko_val_callEx(neko_interp_loop$$1$$1$$1$$53$$2$$1$$_o, neko_interp_loop$$1$$1$$1$$53$$2$$1$$_f, &neko_interp_loop$$1$$1$$1$$53$$2$$1$$_arg, 1, (struct _value **)(void *)0);
                    acc = (signed long int)return_value_neko_val_callEx$405;
                    sp = vm->sp;
                    csp = vm->csp;
                    m = (struct _neko_module *)*csp;
                    tmp_post$406 = csp;
                    csp = csp - 1l;
                    *tmp_post$406 = (signed long int)0;
                    vm->vthis = (struct _value *)*csp;
                    tmp_post$407 = csp;
                    csp = csp - 1l;
                    *tmp_post$407 = (signed long int)0;
                    vm->env = (struct _value *)*csp;
                    tmp_post$408 = csp;
                    csp = csp - 1l;
                    *tmp_post$408 = (signed long int)0;
                    tmp_post$409 = csp;
                    csp = csp - 1l;
                    *tmp_post$409 = (signed long int)0;
                  }
                }

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand$411;
                    return_value_neko_stack_expand$411=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand$411 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string$410=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string$410);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_alloc_string$412;
                  return_value_neko_alloc_string$412=neko_alloc_string("Invalid operation (-)");
                  neko_val_throw(return_value_neko_alloc_string$412);
                }
              }

            __CPROVER_DUMP_L627:
              ;
              tmp_post$414 = sp;
              sp = sp + 1l;
              *tmp_post$414 = (signed long int)0;
              *pc++;
              if(*pc++ == &&id_mod_next2)
                goto id_mod_next2;

              if(*pc++ == &&id_mod_next)
                goto id_mod_next;

              if(*pc++ == &&div_next)
                goto div_next;

              if(*pc++ == &&id_mult_next2)
                goto id_mult_next2;

              if(!(*pc++ == &&id_mult_next))
              {
                if(*pc++ == &&id_sub_next2)
                  goto id_sub_next2;

                if(*pc++ == &&id_sub_next)
                  goto id_sub_next;

                if(*pc++ == &&add_3)
                  goto add_3;

                if(*pc++ == &&add_2)
                  goto add_2;

                if(*pc++ == &&add_next)
                  goto add_next;

                if(*pc++ == &&do_call)
                  goto LabelCall;

                if(*pc++ == &&LabelLast)
                  goto LabelLast;

                if(*pc++ == &&LabelAccInt32)
                  goto LabelAccInt32;

                if(*pc++ == &&LabelMakeArray2)
                  goto LabelMakeArray2;

                if(*pc++ == &&LabelLoop)
                  goto LabelLoop;

                if(*pc++ == &&LabelTailCall)
                  goto LabelTailCall;

                if(*pc++ == &&LabelPhysCompare)
                  goto LabelPhysCompare;

                if(*pc++ == &&LabelAccIndex1)
                  goto LabelAccIndex1;

                if(*pc++ == &&LabelAccIndex0)
                  goto LabelAccIndex0;

                if(*pc++ == &&LabelAccStack1)
                  goto LabelAccStack1;

                if(*pc++ == &&LabelAccStack0)
                  goto LabelAccStack0;

                if(*pc++ == &&LabelApply)
                  goto LabelApply;

                if(*pc++ == &&LabelJumpTable)
                  goto LabelJumpTable;

                if(*pc++ == &&LabelNew)
                  goto LabelNew;

                if(*pc++ == &&LabelHash)
                  goto LabelHash;

                if(*pc++ == &&LabelCompare)
                  goto LabelCompare;

                if(*pc++ == &&LabelTypeOf)
                  goto LabelTypeOf;

                if(*pc++ == &&LabelNot)
                  goto LabelNot;

                if(*pc++ == &&LabelLte)
                  goto LabelLte;

                if(*pc++ == &&LabelLt)
                  goto LabelLt;

                if(*pc++ == &&LabelGte)
                  goto LabelGte;

                if(*pc++ == &&LabelGt)
                  goto LabelGt;

                if(*pc++ == &&LabelNeq)
                  goto LabelNeq;

                if(*pc++ == &&LabelEq)
                  goto LabelEq;

                if(*pc++ == &&LabelXor)
                  goto LabelXor;

                if(*pc++ == &&LabelAnd)
                  goto LabelAnd;

                if(*pc++ == &&LabelOr)
                  goto LabelOr;

                if(*pc++ == &&LabelUShr)
                  goto LabelUShr;

                if(*pc++ == &&LabelShr)
                  goto LabelShr;

                if(*pc++ == &&LabelShl)
                  goto LabelShl;

                if(*pc++ == &&LabelMod)
                  goto LabelMod;

                if(*pc++ == &&LabelDiv)
                  goto LabelDiv;

                if(!(*pc++ == &&LabelMult))
                {
                  if(*pc++ == &&LabelSub)
                    goto LabelSub;

                  if(*pc++ == &&LabelAdd)
                    goto LabelAdd;

                  if(*pc++ == &&LabelIsNotNull)
                    goto LabelIsNotNull;

                  if(*pc++ == &&LabelIsNull)
                    goto LabelIsNull;

                  if(*pc++ == &&LabelBool)
                    goto LabelBool;

                  if(*pc++ == &&LabelMakeArray)
                    goto LabelMakeArray;

                  if(*pc++ == &&LabelMakeEnv)
                    goto LabelMakeEnv;

                  if(*pc++ == &&LabelRet)
                    goto LabelRet;

                  if(*pc++ == &&LabelEndTrap)
                    goto LabelEndTrap;

                  if(*pc++ == &&LabelTrap)
                    goto LabelTrap;

                  if(*pc++ == &&LabelJumpIfNot)
                    goto LabelJumpIfNot;

                  if(*pc++ == &&LabelJumpIf)
                    goto LabelJumpIf;

                  if(*pc++ == &&LabelJump)
                    goto LabelJump;

                  if(*pc++ == &&LabelObjCall)
                    goto LabelObjCall;

                  if(*pc++ == &&LabelCall)
                    goto LabelCall;

                  if(*pc++ == &&LabelPop)
                    goto LabelPop;

                  if(*pc++ == &&LabelPush)
                    goto LabelPush;

                  if(*pc++ == &&LabelSetThis)
                    goto LabelSetThis;

                  if(*pc++ == &&LabelSetIndex)
                    goto LabelSetIndex;

                  if(*pc++ == &&LabelSetArray)
                    goto LabelSetArray;

                  if(*pc++ == &&LabelSetField)
                    goto LabelSetField;

                  if(*pc++ == &&LabelSetEnv)
                    goto LabelSetEnv;

                  if(*pc++ == &&LabelSetGlobal)
                    goto LabelSetGlobal;

                  if(*pc++ == &&LabelSetStack)
                    goto LabelSetStack;

                  if(*pc++ == &&LabelAccBuiltin)
                    goto LabelAccBuiltin;

                  if(*pc++ == &&LabelAccIndex)
                    goto LabelAccIndex;

                  if(*pc++ == &&LabelAccArray)
                    goto LabelAccArray;

                  if(*pc++ == &&LabelAccField)
                    goto LabelAccField;

                  if(*pc++ == &&LabelAccEnv)
                    goto LabelAccEnv;

                  if(*pc++ == &&LabelAccGlobal)
                    goto LabelAccGlobal;

                  if(*pc++ == &&LabelAccStack)
                    goto LabelAccStack;

                  if(*pc++ == &&LabelAccInt)
                    goto LabelAccInt;

                  if(*pc++ == &&LabelAccThis)
                    goto LabelAccThis;

                  if(*pc++ == &&LabelAccFalse)
                    goto LabelAccFalse;

                  if(*pc++ == &&LabelAccTrue)
                    goto LabelAccTrue;

                  if(*pc++ == &&LabelAccNull)
                    goto LabelAccNull;

                  if(*pc++ == &&end)
                    goto end;

                }


              LabelMult:
                ;
                if(!((1l & acc) == 0l))
                  tmp_if_expr$474 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$474 = (_Bool)0;
                if(tmp_if_expr$474)
                {
                  if(!(((unsigned int)((signed int)*sp >> 1) * (unsigned int)((signed int)acc >> 1) + 1073741824u & 0x80000000) == 0u))
                  {
                    return_value_neko_alloc_int32$415=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) * ((signed int)(signed long int)acc >> 1));
                    tmp_if_expr$416 = return_value_neko_alloc_int32$415;
                  }

                  else
                    tmp_if_expr$416 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) * ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                  acc = (signed long int)tmp_if_expr$416;
                  goto __CPROVER_DUMP_L708;
                }

                if(!((1l & acc) == 0l))
                {
                  if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                  {
                    return_value_neko_alloc_float$417=neko_alloc_float(((struct anonymous$25 *)*sp)->f * (double)((signed int)(signed long int)acc >> 1));
                    acc = (signed long int)return_value_neko_alloc_float$417;
                  }

                  else
                    if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                    {
                      if(!(((unsigned int)((signed int)acc >> 1) * (unsigned int)((struct anonymous$26 *)*sp)->i + 1073741824u & 0x80000000) == 0u))
                      {
                        return_value_neko_alloc_int32$418=neko_alloc_int32(((struct anonymous$26 *)*sp)->i * ((signed int)(signed long int)acc >> 1));
                        tmp_if_expr$419 = return_value_neko_alloc_int32$418;
                      }

                      else
                        tmp_if_expr$419 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i * ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                      acc = (signed long int)tmp_if_expr$419;
                    }

                    else
                      if((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT)
                      {
                        struct _value *neko_interp_loop$$1$$1$$1$$54$$1$$_o = (struct _value *)*sp;
                        struct _value *neko_interp_loop$$1$$1$$1$$54$$1$$_arg = (struct _value *)acc;
                        struct _value *neko_interp_loop$$1$$1$$1$$54$$1$$_f;
                        neko_interp_loop$$1$$1$$1$$54$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$54$$1$$_o, id_mult);
                        if(neko_interp_loop$$1$$1$$1$$54$$1$$_f == val_null)
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand$421;
                            return_value_neko_stack_expand$421=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand$421 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string$420=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string$420);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_alloc_string$422;
                          return_value_neko_alloc_string$422=neko_alloc_string("Unsupported operation");
                          neko_val_throw(return_value_neko_alloc_string$422);
                        }

                        else
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand$424;
                            return_value_neko_stack_expand$424=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand$424 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string$423=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string$423);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_val_callEx$425;
                          return_value_neko_val_callEx$425=neko_val_callEx(neko_interp_loop$$1$$1$$1$$54$$1$$_o, neko_interp_loop$$1$$1$$1$$54$$1$$_f, &neko_interp_loop$$1$$1$$1$$54$$1$$_arg, 1, (struct _value **)(void *)0);
                          acc = (signed long int)return_value_neko_val_callEx$425;
                          sp = vm->sp;
                          csp = vm->csp;
                          m = (struct _neko_module *)*csp;
                          tmp_post$426 = csp;
                          csp = csp - 1l;
                          *tmp_post$426 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post$427 = csp;
                          csp = csp - 1l;
                          *tmp_post$427 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post$428 = csp;
                          csp = csp - 1l;
                          *tmp_post$428 = (signed long int)0;
                          tmp_post$429 = csp;
                          csp = csp - 1l;
                          *tmp_post$429 = (signed long int)0;
                        }
                      }

                      else
                      {
                        if(csp + 4l >= sp)
                        {
                          signed int return_value_neko_stack_expand$431;
                          return_value_neko_stack_expand$431=neko_stack_expand(sp, csp, vm);
                          if(!(return_value_neko_stack_expand$431 == 0))
                          {
                            sp = vm->sp;
                            csp = vm->csp;
                          }

                          else
                          {
                            return_value_neko_alloc_string$430=neko_alloc_string("Stack Overflow");
                            neko_val_throw(return_value_neko_alloc_string$430);
                          }
                        }

                        csp = csp + 1l;
                        *csp = (signed long int)pc;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->env;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->vthis;
                        csp = csp + 1l;
                        *csp = (signed long int)m;
                        vm->sp = sp;
                        vm->csp = csp;
                        struct _value *return_value_neko_alloc_string$432;
                        return_value_neko_alloc_string$432=neko_alloc_string("Invalid operation (*)");
                        neko_val_throw(return_value_neko_alloc_string$432);
                      }
                  goto __CPROVER_DUMP_L708;
                }

                if(!((1l & *sp) == 0l))
                {
                  if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
                  {
                    return_value_neko_alloc_float$433=neko_alloc_float((double)((signed int)(signed long int)*sp >> 1) * ((struct anonymous$25 *)acc)->f);
                    acc = (signed long int)return_value_neko_alloc_float$433;
                  }

                  else
                    if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
                    {
                      if(!(((unsigned int)((signed int)*sp >> 1) * (unsigned int)((struct anonymous$26 *)acc)->i + 1073741824u & 0x80000000) == 0u))
                      {
                        return_value_neko_alloc_int32$434=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) * ((struct anonymous$26 *)acc)->i);
                        tmp_if_expr$435 = return_value_neko_alloc_int32$434;
                      }

                      else
                        tmp_if_expr$435 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) * ((struct anonymous$26 *)acc)->i) << 1 | 1);
                      acc = (signed long int)tmp_if_expr$435;
                    }

                    else
                      if((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT)
                      {
                        struct _value *neko_interp_loop$$1$$1$$1$$55$$1$$_o = (struct _value *)acc;
                        struct _value *neko_interp_loop$$1$$1$$1$$55$$1$$_arg = (struct _value *)*sp;
                        struct _value *neko_interp_loop$$1$$1$$1$$55$$1$$_f;
                        neko_interp_loop$$1$$1$$1$$55$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$55$$1$$_o, id_rmult);
                        if(neko_interp_loop$$1$$1$$1$$55$$1$$_f == val_null)
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand$437;
                            return_value_neko_stack_expand$437=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand$437 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string$436=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string$436);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_alloc_string$438;
                          return_value_neko_alloc_string$438=neko_alloc_string("Unsupported operation");
                          neko_val_throw(return_value_neko_alloc_string$438);
                        }

                        else
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand$440;
                            return_value_neko_stack_expand$440=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand$440 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string$439=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string$439);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_val_callEx$441;
                          return_value_neko_val_callEx$441=neko_val_callEx(neko_interp_loop$$1$$1$$1$$55$$1$$_o, neko_interp_loop$$1$$1$$1$$55$$1$$_f, &neko_interp_loop$$1$$1$$1$$55$$1$$_arg, 1, (struct _value **)(void *)0);
                          acc = (signed long int)return_value_neko_val_callEx$441;
                          sp = vm->sp;
                          csp = vm->csp;
                          m = (struct _neko_module *)*csp;
                          tmp_post$442 = csp;
                          csp = csp - 1l;
                          *tmp_post$442 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post$443 = csp;
                          csp = csp - 1l;
                          *tmp_post$443 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post$444 = csp;
                          csp = csp - 1l;
                          *tmp_post$444 = (signed long int)0;
                          tmp_post$445 = csp;
                          csp = csp - 1l;
                          *tmp_post$445 = (signed long int)0;
                        }
                      }

                      else
                      {
                        if(csp + 4l >= sp)
                        {
                          signed int return_value_neko_stack_expand$447;
                          return_value_neko_stack_expand$447=neko_stack_expand(sp, csp, vm);
                          if(!(return_value_neko_stack_expand$447 == 0))
                          {
                            sp = vm->sp;
                            csp = vm->csp;
                          }

                          else
                          {
                            return_value_neko_alloc_string$446=neko_alloc_string("Stack Overflow");
                            neko_val_throw(return_value_neko_alloc_string$446);
                          }
                        }

                        csp = csp + 1l;
                        *csp = (signed long int)pc;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->env;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->vthis;
                        csp = csp + 1l;
                        *csp = (signed long int)m;
                        vm->sp = sp;
                        vm->csp = csp;
                        struct _value *return_value_neko_alloc_string$448;
                        return_value_neko_alloc_string$448=neko_alloc_string("Invalid operation (*)");
                        neko_val_throw(return_value_neko_alloc_string$448);
                      }
                  goto __CPROVER_DUMP_L708;
                }

                if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
                {
                  if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                  {
                    return_value_neko_alloc_float$449=neko_alloc_float(((struct anonymous$25 *)*sp)->f * ((struct anonymous$25 *)acc)->f);
                    acc = (signed long int)return_value_neko_alloc_float$449;
                  }

                  else
                    if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                    {
                      return_value_neko_alloc_float$450=neko_alloc_float((double)((struct anonymous$26 *)*sp)->i * ((struct anonymous$25 *)acc)->f);
                      acc = (signed long int)return_value_neko_alloc_float$450;
                    }

                    else
                      goto id_mult_next;
                  goto __CPROVER_DUMP_L708;
                }

                if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
                {
                  if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
                  {
                    if(!(((unsigned int)((struct anonymous$26 *)*sp)->i * (unsigned int)((struct anonymous$26 *)acc)->i + 1073741824u & 0x80000000) == 0u))
                    {
                      return_value_neko_alloc_int32$451=neko_alloc_int32(((struct anonymous$26 *)*sp)->i * ((struct anonymous$26 *)acc)->i);
                      tmp_if_expr$452 = return_value_neko_alloc_int32$451;
                    }

                    else
                      tmp_if_expr$452 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i * ((struct anonymous$26 *)acc)->i) << 1 | 1);
                    acc = (signed long int)tmp_if_expr$452;
                  }

                  else
                    if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                    {
                      return_value_neko_alloc_float$453=neko_alloc_float(((struct anonymous$25 *)*sp)->f * (double)((struct anonymous$26 *)acc)->i);
                      acc = (signed long int)return_value_neko_alloc_float$453;
                    }

                    else
                      goto id_mult_next;
                  goto __CPROVER_DUMP_L708;
                }

              }

            }


          id_mult_next:
            ;
            if(!((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT))
              goto id_mult_next2;

            struct _value *neko_interp_loop$$1$$1$$1$$58$$1$$_o = (struct _value *)*sp;
            struct _value *neko_interp_loop$$1$$1$$1$$58$$1$$_arg = (struct _value *)acc;
            struct _value *neko_interp_loop$$1$$1$$1$$58$$1$$_f;
            neko_interp_loop$$1$$1$$1$$58$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$58$$1$$_o, id_mult);
            if(neko_interp_loop$$1$$1$$1$$58$$1$$_f == val_null)
              goto id_mult_next2;

            else
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand$455;
                return_value_neko_stack_expand$455=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand$455 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string$454=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string$454);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_val_callEx$456;
              return_value_neko_val_callEx$456=neko_val_callEx(neko_interp_loop$$1$$1$$1$$58$$1$$_o, neko_interp_loop$$1$$1$$1$$58$$1$$_f, &neko_interp_loop$$1$$1$$1$$58$$1$$_arg, 1, (struct _value **)(void *)0);
              acc = (signed long int)return_value_neko_val_callEx$456;
              sp = vm->sp;
              csp = vm->csp;
              m = (struct _neko_module *)*csp;
              tmp_post$457 = csp;
              csp = csp - 1l;
              *tmp_post$457 = (signed long int)0;
              vm->vthis = (struct _value *)*csp;
              tmp_post$458 = csp;
              csp = csp - 1l;
              *tmp_post$458 = (signed long int)0;
              vm->env = (struct _value *)*csp;
              tmp_post$459 = csp;
              csp = csp - 1l;
              *tmp_post$459 = (signed long int)0;
              tmp_post$460 = csp;
              csp = csp - 1l;
              *tmp_post$460 = (signed long int)0;
            }
          }

          else
          {

          id_mult_next2:
            ;
            if((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT)
            {
              struct _value *neko_interp_loop$$1$$1$$1$$58$$2$$1$$_o = (struct _value *)acc;
              struct _value *neko_interp_loop$$1$$1$$1$$58$$2$$1$$_arg = (struct _value *)*sp;
              struct _value *neko_interp_loop$$1$$1$$1$$58$$2$$1$$_f;
              neko_interp_loop$$1$$1$$1$$58$$2$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$58$$2$$1$$_o, id_rmult);
              if(neko_interp_loop$$1$$1$$1$$58$$2$$1$$_f == val_null)
              {
                if(csp + 4l >= sp)
                {
                  signed int return_value_neko_stack_expand$462;
                  return_value_neko_stack_expand$462=neko_stack_expand(sp, csp, vm);
                  if(!(return_value_neko_stack_expand$462 == 0))
                  {
                    sp = vm->sp;
                    csp = vm->csp;
                  }

                  else
                  {
                    return_value_neko_alloc_string$461=neko_alloc_string("Stack Overflow");
                    neko_val_throw(return_value_neko_alloc_string$461);
                  }
                }

                csp = csp + 1l;
                *csp = (signed long int)pc;
                csp = csp + 1l;
                *csp = (signed long int)vm->env;
                csp = csp + 1l;
                *csp = (signed long int)vm->vthis;
                csp = csp + 1l;
                *csp = (signed long int)m;
                vm->sp = sp;
                vm->csp = csp;
                struct _value *return_value_neko_alloc_string$463;
                return_value_neko_alloc_string$463=neko_alloc_string("Unsupported operation");
                neko_val_throw(return_value_neko_alloc_string$463);
              }

              else
              {
                if(csp + 4l >= sp)
                {
                  signed int return_value_neko_stack_expand$465;
                  return_value_neko_stack_expand$465=neko_stack_expand(sp, csp, vm);
                  if(!(return_value_neko_stack_expand$465 == 0))
                  {
                    sp = vm->sp;
                    csp = vm->csp;
                  }

                  else
                  {
                    return_value_neko_alloc_string$464=neko_alloc_string("Stack Overflow");
                    neko_val_throw(return_value_neko_alloc_string$464);
                  }
                }

                csp = csp + 1l;
                *csp = (signed long int)pc;
                csp = csp + 1l;
                *csp = (signed long int)vm->env;
                csp = csp + 1l;
                *csp = (signed long int)vm->vthis;
                csp = csp + 1l;
                *csp = (signed long int)m;
                vm->sp = sp;
                vm->csp = csp;
                struct _value *return_value_neko_val_callEx$466;
                return_value_neko_val_callEx$466=neko_val_callEx(neko_interp_loop$$1$$1$$1$$58$$2$$1$$_o, neko_interp_loop$$1$$1$$1$$58$$2$$1$$_f, &neko_interp_loop$$1$$1$$1$$58$$2$$1$$_arg, 1, (struct _value **)(void *)0);
                acc = (signed long int)return_value_neko_val_callEx$466;
                sp = vm->sp;
                csp = vm->csp;
                m = (struct _neko_module *)*csp;
                tmp_post$467 = csp;
                csp = csp - 1l;
                *tmp_post$467 = (signed long int)0;
                vm->vthis = (struct _value *)*csp;
                tmp_post$468 = csp;
                csp = csp - 1l;
                *tmp_post$468 = (signed long int)0;
                vm->env = (struct _value *)*csp;
                tmp_post$469 = csp;
                csp = csp - 1l;
                *tmp_post$469 = (signed long int)0;
                tmp_post$470 = csp;
                csp = csp - 1l;
                *tmp_post$470 = (signed long int)0;
              }
            }

            else
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand$472;
                return_value_neko_stack_expand$472=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand$472 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string$471=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string$471);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_alloc_string$473;
              return_value_neko_alloc_string$473=neko_alloc_string("Invalid operation (*)");
              neko_val_throw(return_value_neko_alloc_string$473);
            }
          }

        __CPROVER_DUMP_L708:
          ;
          tmp_post$475 = sp;
          sp = sp + 1l;
          *tmp_post$475 = (signed long int)0;
          *pc++;
          if(*pc++ == &&id_mod_next2)
            goto id_mod_next2;

          if(*pc++ == &&id_mod_next)
            goto id_mod_next;

          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

          if(*pc++ == &&LabelPhysCompare)
            goto LabelPhysCompare;

          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

          if(*pc++ == &&LabelJumpTable)
            goto LabelJumpTable;

          if(*pc++ == &&LabelNew)
            goto LabelNew;

          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(*pc++ == &&LabelCompare)
            goto LabelCompare;

          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(*pc++ == &&LabelMod)
            goto LabelMod;

          if(!(*pc++ == &&LabelDiv))
          {
            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }


        LabelDiv:
          ;
          if(!((1 & (signed int)acc) == 0))
            tmp_if_expr$503 = (_Bool)1;

          else
            tmp_if_expr$503 = (signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$503)
            tmp_if_expr$504 = (_Bool)1;

          else
            tmp_if_expr$504 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$504)
          {
            if(!((1 & (signed int)*sp) == 0))
              tmp_if_expr$505 = (_Bool)1;

            else
              tmp_if_expr$505 = (signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$505)
              tmp_if_expr$506 = (_Bool)1;

            else
              tmp_if_expr$506 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$507 = tmp_if_expr$506 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$507 = (_Bool)0;
          if(tmp_if_expr$507)
          {
            if(!((1 & (signed int)*sp) == 0))
              tmp_if_expr$477 = (double)((signed int)(signed long int)*sp >> 1);

            else
            {
              if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
                tmp_if_expr$476 = ((struct anonymous$25 *)*sp)->f;

              else
                tmp_if_expr$476 = (double)((struct anonymous$26 *)*sp)->i;
              tmp_if_expr$477 = tmp_if_expr$476;
            }
            if(!((1 & (signed int)acc) == 0))
              tmp_if_expr$479 = (double)((signed int)(signed long int)acc >> 1);

            else
            {
              if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
                tmp_if_expr$478 = ((struct anonymous$25 *)acc)->f;

              else
                tmp_if_expr$478 = (double)((struct anonymous$26 *)acc)->i;
              tmp_if_expr$479 = tmp_if_expr$478;
            }
            return_value_neko_alloc_float$480=neko_alloc_float((double)tmp_if_expr$477 / tmp_if_expr$479);
            acc = (signed long int)return_value_neko_alloc_float$480;
            goto __CPROVER_DUMP_L755;
          }

          if((1 & (signed int)*sp) == 0)
            tmp_if_expr$502 = (signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$502 = (_Bool)0;
          if(!tmp_if_expr$502)
            goto div_next;

          struct _value *neko_interp_loop$$1$$1$$1$$59$$_o = (struct _value *)*sp;
          struct _value *neko_interp_loop$$1$$1$$1$$59$$_arg = (struct _value *)acc;
          struct _value *neko_interp_loop$$1$$1$$1$$59$$_f;
          neko_interp_loop$$1$$1$$1$$59$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$59$$_o, id_div);
          if(neko_interp_loop$$1$$1$$1$$59$$_f == val_null)
            goto div_next;

          else
          {
            if(csp + 4l >= sp)
            {
              signed int return_value_neko_stack_expand$482;
              return_value_neko_stack_expand$482=neko_stack_expand(sp, csp, vm);
              if(!(return_value_neko_stack_expand$482 == 0))
              {
                sp = vm->sp;
                csp = vm->csp;
              }

              else
              {
                return_value_neko_alloc_string$481=neko_alloc_string("Stack Overflow");
                neko_val_throw(return_value_neko_alloc_string$481);
              }
            }

            csp = csp + 1l;
            *csp = (signed long int)pc;
            csp = csp + 1l;
            *csp = (signed long int)vm->env;
            csp = csp + 1l;
            *csp = (signed long int)vm->vthis;
            csp = csp + 1l;
            *csp = (signed long int)m;
            vm->sp = sp;
            vm->csp = csp;
            struct _value *return_value_neko_val_callEx$483;
            return_value_neko_val_callEx$483=neko_val_callEx(neko_interp_loop$$1$$1$$1$$59$$_o, neko_interp_loop$$1$$1$$1$$59$$_f, &neko_interp_loop$$1$$1$$1$$59$$_arg, 1, (struct _value **)(void *)0);
            acc = (signed long int)return_value_neko_val_callEx$483;
            sp = vm->sp;
            csp = vm->csp;
            m = (struct _neko_module *)*csp;
            tmp_post$484 = csp;
            csp = csp - 1l;
            *tmp_post$484 = (signed long int)0;
            vm->vthis = (struct _value *)*csp;
            tmp_post$485 = csp;
            csp = csp - 1l;
            *tmp_post$485 = (signed long int)0;
            vm->env = (struct _value *)*csp;
            tmp_post$486 = csp;
            csp = csp - 1l;
            *tmp_post$486 = (signed long int)0;
            tmp_post$487 = csp;
            csp = csp - 1l;
            *tmp_post$487 = (signed long int)0;
          }
        }

        else
        {

        div_next:
          ;
          if((1 & (signed int)acc) == 0)
            tmp_if_expr$501 = (signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$501 = (_Bool)0;
          if(tmp_if_expr$501)
          {
            struct _value *neko_interp_loop$$1$$1$$1$$60$$1$$_o = (struct _value *)acc;
            struct _value *neko_interp_loop$$1$$1$$1$$60$$1$$_arg = (struct _value *)*sp;
            struct _value *neko_interp_loop$$1$$1$$1$$60$$1$$_f;
            neko_interp_loop$$1$$1$$1$$60$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$60$$1$$_o, id_rdiv);
            if(neko_interp_loop$$1$$1$$1$$60$$1$$_f == val_null)
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand$489;
                return_value_neko_stack_expand$489=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand$489 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string$488=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string$488);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_alloc_string$490;
              return_value_neko_alloc_string$490=neko_alloc_string("Unsupported operation");
              neko_val_throw(return_value_neko_alloc_string$490);
            }

            else
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand$492;
                return_value_neko_stack_expand$492=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand$492 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string$491=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string$491);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_val_callEx$493;
              return_value_neko_val_callEx$493=neko_val_callEx(neko_interp_loop$$1$$1$$1$$60$$1$$_o, neko_interp_loop$$1$$1$$1$$60$$1$$_f, &neko_interp_loop$$1$$1$$1$$60$$1$$_arg, 1, (struct _value **)(void *)0);
              acc = (signed long int)return_value_neko_val_callEx$493;
              sp = vm->sp;
              csp = vm->csp;
              m = (struct _neko_module *)*csp;
              tmp_post$494 = csp;
              csp = csp - 1l;
              *tmp_post$494 = (signed long int)0;
              vm->vthis = (struct _value *)*csp;
              tmp_post$495 = csp;
              csp = csp - 1l;
              *tmp_post$495 = (signed long int)0;
              vm->env = (struct _value *)*csp;
              tmp_post$496 = csp;
              csp = csp - 1l;
              *tmp_post$496 = (signed long int)0;
              tmp_post$497 = csp;
              csp = csp - 1l;
              *tmp_post$497 = (signed long int)0;
            }
          }

          else
          {
            if(csp + 4l >= sp)
            {
              signed int return_value_neko_stack_expand$499;
              return_value_neko_stack_expand$499=neko_stack_expand(sp, csp, vm);
              if(!(return_value_neko_stack_expand$499 == 0))
              {
                sp = vm->sp;
                csp = vm->csp;
              }

              else
              {
                return_value_neko_alloc_string$498=neko_alloc_string("Stack Overflow");
                neko_val_throw(return_value_neko_alloc_string$498);
              }
            }

            csp = csp + 1l;
            *csp = (signed long int)pc;
            csp = csp + 1l;
            *csp = (signed long int)vm->env;
            csp = csp + 1l;
            *csp = (signed long int)vm->vthis;
            csp = csp + 1l;
            *csp = (signed long int)m;
            vm->sp = sp;
            vm->csp = csp;
            struct _value *return_value_neko_alloc_string$500;
            return_value_neko_alloc_string$500=neko_alloc_string("Invalid operation (/)");
            neko_val_throw(return_value_neko_alloc_string$500);
          }
        }

      __CPROVER_DUMP_L755:
        ;
        tmp_post$508 = sp;
        sp = sp + 1l;
        *tmp_post$508 = (signed long int)0;
        *pc++;
        if(*pc++ == &&id_mod_next2)
          goto id_mod_next2;

        if(!(*pc++ == &&id_mod_next))
        {
          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

          if(*pc++ == &&LabelPhysCompare)
            goto LabelPhysCompare;

          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

          if(*pc++ == &&LabelJumpTable)
            goto LabelJumpTable;

          if(*pc++ == &&LabelNew)
            goto LabelNew;

          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(*pc++ == &&LabelCompare)
            goto LabelCompare;

          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(!(*pc++ == &&LabelMod))
          {
            if(*pc++ == &&LabelDiv)
              goto LabelDiv;

            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }


        LabelMod:
          ;
          if(acc == 1l)
            tmp_if_expr$515 = (_Bool)1;

          else
          {
            if((1 & (signed int)acc) == 0)
              tmp_if_expr$513 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$513 = (_Bool)0;
            if(tmp_if_expr$513)
              tmp_if_expr$514 = ((struct anonymous$26 *)acc)->i == 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$514 = (_Bool)0;
            tmp_if_expr$515 = tmp_if_expr$514 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$515)
          {
            if(!((1 & (signed int)*sp) == 0))
              tmp_if_expr$512 = (_Bool)1;

            else
              tmp_if_expr$512 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$512)
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand$510;
                return_value_neko_stack_expand$510=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand$510 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string$509=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string$509);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_alloc_string$511;
              return_value_neko_alloc_string$511=neko_alloc_string("Invalid operation (%)");
              neko_val_throw(return_value_neko_alloc_string$511);
            }

          }

          if(!((1l & acc) == 0l))
            tmp_if_expr$580 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$580 = (_Bool)0;
          if(tmp_if_expr$580)
          {
            if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) % ((signed int)acc >> 1)) & 0x80000000) == 0u))
            {
              return_value_neko_alloc_int32$516=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) % ((signed int)(signed long int)acc >> 1));
              tmp_if_expr$517 = return_value_neko_alloc_int32$516;
            }

            else
              tmp_if_expr$517 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) % ((signed int)(signed long int)acc >> 1)) << 1 | 1);
            acc = (signed long int)tmp_if_expr$517;
            goto __CPROVER_DUMP_L849;
          }

          if(!((1l & acc) == 0l))
          {
            if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
            {
              return_value_fmod$518=fmod(((struct anonymous$25 *)*sp)->f, (double)((signed int)(signed long int)acc >> 1));
              return_value_neko_alloc_float$519=neko_alloc_float(return_value_fmod$518);
              acc = (signed long int)return_value_neko_alloc_float$519;
            }

            else
              if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
              {
                if(!((1073741824u + (unsigned int)(((struct anonymous$26 *)*sp)->i % ((signed int)acc >> 1)) & 0x80000000) == 0u))
                {
                  return_value_neko_alloc_int32$520=neko_alloc_int32(((struct anonymous$26 *)*sp)->i % ((signed int)(signed long int)acc >> 1));
                  tmp_if_expr$521 = return_value_neko_alloc_int32$520;
                }

                else
                  tmp_if_expr$521 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i % ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                acc = (signed long int)tmp_if_expr$521;
              }

              else
                if((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT)
                {
                  struct _value *neko_interp_loop$$1$$1$$1$$62$$1$$_o = (struct _value *)*sp;
                  struct _value *neko_interp_loop$$1$$1$$1$$62$$1$$_arg = (struct _value *)acc;
                  struct _value *neko_interp_loop$$1$$1$$1$$62$$1$$_f;
                  neko_interp_loop$$1$$1$$1$$62$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$62$$1$$_o, id_mod);
                  if(neko_interp_loop$$1$$1$$1$$62$$1$$_f == val_null)
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand$523;
                      return_value_neko_stack_expand$523=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand$523 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string$522=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string$522);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_alloc_string$524;
                    return_value_neko_alloc_string$524=neko_alloc_string("Unsupported operation");
                    neko_val_throw(return_value_neko_alloc_string$524);
                  }

                  else
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand$526;
                      return_value_neko_stack_expand$526=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand$526 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string$525=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string$525);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_val_callEx$527;
                    return_value_neko_val_callEx$527=neko_val_callEx(neko_interp_loop$$1$$1$$1$$62$$1$$_o, neko_interp_loop$$1$$1$$1$$62$$1$$_f, &neko_interp_loop$$1$$1$$1$$62$$1$$_arg, 1, (struct _value **)(void *)0);
                    acc = (signed long int)return_value_neko_val_callEx$527;
                    sp = vm->sp;
                    csp = vm->csp;
                    m = (struct _neko_module *)*csp;
                    tmp_post$528 = csp;
                    csp = csp - 1l;
                    *tmp_post$528 = (signed long int)0;
                    vm->vthis = (struct _value *)*csp;
                    tmp_post$529 = csp;
                    csp = csp - 1l;
                    *tmp_post$529 = (signed long int)0;
                    vm->env = (struct _value *)*csp;
                    tmp_post$530 = csp;
                    csp = csp - 1l;
                    *tmp_post$530 = (signed long int)0;
                    tmp_post$531 = csp;
                    csp = csp - 1l;
                    *tmp_post$531 = (signed long int)0;
                  }
                }

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand$533;
                    return_value_neko_stack_expand$533=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand$533 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string$532=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string$532);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_alloc_string$534;
                  return_value_neko_alloc_string$534=neko_alloc_string("Invalid operation (%)");
                  neko_val_throw(return_value_neko_alloc_string$534);
                }
            goto __CPROVER_DUMP_L849;
          }

          if(!((1l & *sp) == 0l))
          {
            if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
            {
              return_value_fmod$535=fmod((double)((signed int)(signed long int)*sp >> 1), ((struct anonymous$25 *)acc)->f);
              return_value_neko_alloc_float$536=neko_alloc_float(return_value_fmod$535);
              acc = (signed long int)return_value_neko_alloc_float$536;
            }

            else
              if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
              {
                if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) % ((struct anonymous$26 *)acc)->i) & 0x80000000) == 0u))
                {
                  return_value_neko_alloc_int32$537=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) % ((struct anonymous$26 *)acc)->i);
                  tmp_if_expr$538 = return_value_neko_alloc_int32$537;
                }

                else
                  tmp_if_expr$538 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) % ((struct anonymous$26 *)acc)->i) << 1 | 1);
                acc = (signed long int)tmp_if_expr$538;
              }

              else
                if((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT)
                {
                  struct _value *neko_interp_loop$$1$$1$$1$$63$$1$$_o = (struct _value *)acc;
                  struct _value *neko_interp_loop$$1$$1$$1$$63$$1$$_arg = (struct _value *)*sp;
                  struct _value *neko_interp_loop$$1$$1$$1$$63$$1$$_f;
                  neko_interp_loop$$1$$1$$1$$63$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$63$$1$$_o, id_rmod);
                  if(neko_interp_loop$$1$$1$$1$$63$$1$$_f == val_null)
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand$540;
                      return_value_neko_stack_expand$540=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand$540 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string$539=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string$539);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_alloc_string$541;
                    return_value_neko_alloc_string$541=neko_alloc_string("Unsupported operation");
                    neko_val_throw(return_value_neko_alloc_string$541);
                  }

                  else
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand$543;
                      return_value_neko_stack_expand$543=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand$543 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string$542=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string$542);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_val_callEx$544;
                    return_value_neko_val_callEx$544=neko_val_callEx(neko_interp_loop$$1$$1$$1$$63$$1$$_o, neko_interp_loop$$1$$1$$1$$63$$1$$_f, &neko_interp_loop$$1$$1$$1$$63$$1$$_arg, 1, (struct _value **)(void *)0);
                    acc = (signed long int)return_value_neko_val_callEx$544;
                    sp = vm->sp;
                    csp = vm->csp;
                    m = (struct _neko_module *)*csp;
                    tmp_post$545 = csp;
                    csp = csp - 1l;
                    *tmp_post$545 = (signed long int)0;
                    vm->vthis = (struct _value *)*csp;
                    tmp_post$546 = csp;
                    csp = csp - 1l;
                    *tmp_post$546 = (signed long int)0;
                    vm->env = (struct _value *)*csp;
                    tmp_post$547 = csp;
                    csp = csp - 1l;
                    *tmp_post$547 = (signed long int)0;
                    tmp_post$548 = csp;
                    csp = csp - 1l;
                    *tmp_post$548 = (signed long int)0;
                  }
                }

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand$550;
                    return_value_neko_stack_expand$550=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand$550 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string$549=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string$549);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_alloc_string$551;
                  return_value_neko_alloc_string$551=neko_alloc_string("Invalid operation (%)");
                  neko_val_throw(return_value_neko_alloc_string$551);
                }
            goto __CPROVER_DUMP_L849;
          }

          if((signed int)*((enum anonymous$7 *)acc) == VAL_FLOAT)
          {
            if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
            {
              return_value_fmod$552=fmod(((struct anonymous$25 *)*sp)->f, ((struct anonymous$25 *)acc)->f);
              return_value_neko_alloc_float$553=neko_alloc_float(return_value_fmod$552);
              acc = (signed long int)return_value_neko_alloc_float$553;
            }

            else
              if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
              {
                return_value_fmod$554=fmod((double)((struct anonymous$26 *)*sp)->i, ((struct anonymous$25 *)acc)->f);
                return_value_neko_alloc_float$555=neko_alloc_float(return_value_fmod$554);
                acc = (signed long int)return_value_neko_alloc_float$555;
              }

              else
                goto id_mod_next;
            goto __CPROVER_DUMP_L849;
          }

          if((signed int)*((enum anonymous$7 *)acc) == VAL_INT32)
          {
            if((signed int)*((enum anonymous$7 *)*sp) == VAL_INT32)
            {
              if(!((1073741824u + (unsigned int)(((struct anonymous$26 *)*sp)->i % ((struct anonymous$26 *)acc)->i) & 0x80000000) == 0u))
              {
                return_value_neko_alloc_int32$556=neko_alloc_int32(((struct anonymous$26 *)*sp)->i % ((struct anonymous$26 *)acc)->i);
                tmp_if_expr$557 = return_value_neko_alloc_int32$556;
              }

              else
                tmp_if_expr$557 = (struct _value *)(signed long int)((signed int)(((struct anonymous$26 *)*sp)->i % ((struct anonymous$26 *)acc)->i) << 1 | 1);
              acc = (signed long int)tmp_if_expr$557;
            }

            else
              if((signed int)*((enum anonymous$7 *)*sp) == VAL_FLOAT)
              {
                return_value_fmod$558=fmod(((struct anonymous$25 *)*sp)->f, (double)((struct anonymous$26 *)acc)->i);
                return_value_neko_alloc_float$559=neko_alloc_float(return_value_fmod$558);
                acc = (signed long int)return_value_neko_alloc_float$559;
              }

              else
                goto id_mod_next;
            goto __CPROVER_DUMP_L849;
          }

        }

      }


    id_mod_next:
      ;
      if(!((signed int)*((enum anonymous$7 *)*sp) == VAL_OBJECT))
        goto id_mod_next2;

      struct _value *neko_interp_loop$$1$$1$$1$$66$$1$$_o = (struct _value *)*sp;
      struct _value *neko_interp_loop$$1$$1$$1$$66$$1$$_arg = (struct _value *)acc;
      struct _value *neko_interp_loop$$1$$1$$1$$66$$1$$_f;
      neko_interp_loop$$1$$1$$1$$66$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$66$$1$$_o, id_mod);
      if(neko_interp_loop$$1$$1$$1$$66$$1$$_f == val_null)
        goto id_mod_next2;

      else
      {
        if(csp + 4l >= sp)
        {
          signed int return_value_neko_stack_expand$561;
          return_value_neko_stack_expand$561=neko_stack_expand(sp, csp, vm);
          if(!(return_value_neko_stack_expand$561 == 0))
          {
            sp = vm->sp;
            csp = vm->csp;
          }

          else
          {
            return_value_neko_alloc_string$560=neko_alloc_string("Stack Overflow");
            neko_val_throw(return_value_neko_alloc_string$560);
          }
        }

        csp = csp + 1l;
        *csp = (signed long int)pc;
        csp = csp + 1l;
        *csp = (signed long int)vm->env;
        csp = csp + 1l;
        *csp = (signed long int)vm->vthis;
        csp = csp + 1l;
        *csp = (signed long int)m;
        vm->sp = sp;
        vm->csp = csp;
        struct _value *return_value_neko_val_callEx$562;
        return_value_neko_val_callEx$562=neko_val_callEx(neko_interp_loop$$1$$1$$1$$66$$1$$_o, neko_interp_loop$$1$$1$$1$$66$$1$$_f, &neko_interp_loop$$1$$1$$1$$66$$1$$_arg, 1, (struct _value **)(void *)0);
        acc = (signed long int)return_value_neko_val_callEx$562;
        sp = vm->sp;
        csp = vm->csp;
        m = (struct _neko_module *)*csp;
        tmp_post$563 = csp;
        csp = csp - 1l;
        *tmp_post$563 = (signed long int)0;
        vm->vthis = (struct _value *)*csp;
        tmp_post$564 = csp;
        csp = csp - 1l;
        *tmp_post$564 = (signed long int)0;
        vm->env = (struct _value *)*csp;
        tmp_post$565 = csp;
        csp = csp - 1l;
        *tmp_post$565 = (signed long int)0;
        tmp_post$566 = csp;
        csp = csp - 1l;
        *tmp_post$566 = (signed long int)0;
      }
    }

    else
    {

    id_mod_next2:
      ;
      if((signed int)*((enum anonymous$7 *)acc) == VAL_OBJECT)
      {
        struct _value *neko_interp_loop$$1$$1$$1$$66$$2$$1$$_o = (struct _value *)acc;
        struct _value *neko_interp_loop$$1$$1$$1$$66$$2$$1$$_arg = (struct _value *)*sp;
        struct _value *neko_interp_loop$$1$$1$$1$$66$$2$$1$$_f;
        neko_interp_loop$$1$$1$$1$$66$$2$$1$$_f=neko_val_field(neko_interp_loop$$1$$1$$1$$66$$2$$1$$_o, id_rmod);
        if(neko_interp_loop$$1$$1$$1$$66$$2$$1$$_f == val_null)
        {
          if(csp + 4l >= sp)
          {
            signed int return_value_neko_stack_expand$568;
            return_value_neko_stack_expand$568=neko_stack_expand(sp, csp, vm);
            if(!(return_value_neko_stack_expand$568 == 0))
            {
              sp = vm->sp;
              csp = vm->csp;
            }

            else
            {
              return_value_neko_alloc_string$567=neko_alloc_string("Stack Overflow");
              neko_val_throw(return_value_neko_alloc_string$567);
            }
          }

          csp = csp + 1l;
          *csp = (signed long int)pc;
          csp = csp + 1l;
          *csp = (signed long int)vm->env;
          csp = csp + 1l;
          *csp = (signed long int)vm->vthis;
          csp = csp + 1l;
          *csp = (signed long int)m;
          vm->sp = sp;
          vm->csp = csp;
          struct _value *return_value_neko_alloc_string$569;
          return_value_neko_alloc_string$569=neko_alloc_string("Unsupported operation");
          neko_val_throw(return_value_neko_alloc_string$569);
        }

        else
        {
          if(csp + 4l >= sp)
          {
            signed int return_value_neko_stack_expand$571;
            return_value_neko_stack_expand$571=neko_stack_expand(sp, csp, vm);
            if(!(return_value_neko_stack_expand$571 == 0))
            {
              sp = vm->sp;
              csp = vm->csp;
            }

            else
            {
              return_value_neko_alloc_string$570=neko_alloc_string("Stack Overflow");
              neko_val_throw(return_value_neko_alloc_string$570);
            }
          }

          csp = csp + 1l;
          *csp = (signed long int)pc;
          csp = csp + 1l;
          *csp = (signed long int)vm->env;
          csp = csp + 1l;
          *csp = (signed long int)vm->vthis;
          csp = csp + 1l;
          *csp = (signed long int)m;
          vm->sp = sp;
          vm->csp = csp;
          struct _value *return_value_neko_val_callEx$572;
          return_value_neko_val_callEx$572=neko_val_callEx(neko_interp_loop$$1$$1$$1$$66$$2$$1$$_o, neko_interp_loop$$1$$1$$1$$66$$2$$1$$_f, &neko_interp_loop$$1$$1$$1$$66$$2$$1$$_arg, 1, (struct _value **)(void *)0);
          acc = (signed long int)return_value_neko_val_callEx$572;
          sp = vm->sp;
          csp = vm->csp;
          m = (struct _neko_module *)*csp;
          tmp_post$573 = csp;
          csp = csp - 1l;
          *tmp_post$573 = (signed long int)0;
          vm->vthis = (struct _value *)*csp;
          tmp_post$574 = csp;
          csp = csp - 1l;
          *tmp_post$574 = (signed long int)0;
          vm->env = (struct _value *)*csp;
          tmp_post$575 = csp;
          csp = csp - 1l;
          *tmp_post$575 = (signed long int)0;
          tmp_post$576 = csp;
          csp = csp - 1l;
          *tmp_post$576 = (signed long int)0;
        }
      }

      else
      {
        if(csp + 4l >= sp)
        {
          signed int return_value_neko_stack_expand$578;
          return_value_neko_stack_expand$578=neko_stack_expand(sp, csp, vm);
          if(!(return_value_neko_stack_expand$578 == 0))
          {
            sp = vm->sp;
            csp = vm->csp;
          }

          else
          {
            return_value_neko_alloc_string$577=neko_alloc_string("Stack Overflow");
            neko_val_throw(return_value_neko_alloc_string$577);
          }
        }

        csp = csp + 1l;
        *csp = (signed long int)pc;
        csp = csp + 1l;
        *csp = (signed long int)vm->env;
        csp = csp + 1l;
        *csp = (signed long int)vm->vthis;
        csp = csp + 1l;
        *csp = (signed long int)m;
        vm->sp = sp;
        vm->csp = csp;
        struct _value *return_value_neko_alloc_string$579;
        return_value_neko_alloc_string$579=neko_alloc_string("Invalid operation (%)");
        neko_val_throw(return_value_neko_alloc_string$579);
      }
    }

  __CPROVER_DUMP_L849:
    ;
    tmp_post$581 = sp;
    sp = sp + 1l;
    *tmp_post$581 = (signed long int)0;
    *pc++;
    if(*pc++ == &&id_mod_next2)
      goto id_mod_next2;

    if(*pc++ == &&id_mod_next)
      goto id_mod_next;

    if(*pc++ == &&div_next)
      goto div_next;

    if(*pc++ == &&id_mult_next2)
      goto id_mult_next2;

    if(*pc++ == &&id_mult_next)
      goto id_mult_next;

    if(*pc++ == &&id_sub_next2)
      goto id_sub_next2;

    if(*pc++ == &&id_sub_next)
      goto id_sub_next;

    if(*pc++ == &&add_3)
      goto add_3;

    if(*pc++ == &&add_2)
      goto add_2;

    if(*pc++ == &&add_next)
      goto add_next;

    if(*pc++ == &&do_call)
      goto LabelCall;

    if(!(*pc++ == &&LabelLast))
    {
      if(*pc++ == &&LabelAccInt32)
        goto LabelAccInt32;

      if(*pc++ == &&LabelMakeArray2)
        goto LabelMakeArray2;

      if(!(*pc++ == &&LabelLoop))
      {
        if(*pc++ == &&LabelTailCall)
          goto LabelTailCall;

        if(!(*pc++ == &&LabelPhysCompare))
        {
          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

          if(*pc++ == &&LabelJumpTable)
            goto LabelJumpTable;

          if(*pc++ == &&LabelNew)
            goto LabelNew;

          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(!(*pc++ == &&LabelCompare))
          {
            if(!(*pc++ == &&LabelTypeOf))
            {
              if(*pc++ == &&LabelNot)
                goto LabelNot;

              if(!(*pc++ == &&LabelLte))
              {
                if(!(*pc++ == &&LabelLt))
                {
                  if(*pc++ == &&LabelGte)
                    goto LabelGte;

                  if(*pc++ == &&LabelGt)
                    goto LabelGt;

                  if(!(*pc++ == &&LabelNeq))
                  {
                    if(!(*pc++ == &&LabelEq))
                    {
                      if(!(*pc++ == &&LabelXor))
                      {
                        if(!(*pc++ == &&LabelAnd))
                        {
                          if(!(*pc++ == &&LabelOr))
                          {
                            if(!(*pc++ == &&LabelUShr))
                            {
                              if(!(*pc++ == &&LabelShr))
                              {
                                if(!(*pc++ == &&LabelShl))
                                {
                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelShl:
                                  ;
                                  if(!((1l & acc) == 0l))
                                    tmp_if_expr$598 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr$598 = (_Bool)0;
                                  if(tmp_if_expr$598)
                                  {
                                    if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) << ((signed int)acc >> 1)) & 0x80000000) == 0u))
                                    {
                                      return_value_neko_alloc_int32$582=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) << ((signed int)(signed long int)acc >> 1));
                                      tmp_if_expr$583 = return_value_neko_alloc_int32$582;
                                    }

                                    else
                                      tmp_if_expr$583 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) << ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                                    acc = (signed long int)tmp_if_expr$583;
                                  }

                                  else
                                  {
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr$595 = (_Bool)1;

                                    else
                                      tmp_if_expr$595 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                    if(tmp_if_expr$595)
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr$596 = (_Bool)1;

                                      else
                                        tmp_if_expr$596 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                      tmp_if_expr$597 = tmp_if_expr$596 ? (_Bool)1 : (_Bool)0;
                                    }

                                    else
                                      tmp_if_expr$597 = (_Bool)0;
                                    if(tmp_if_expr$597)
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr$584 = (signed int)(signed long int)*sp >> 1;

                                      else
                                        tmp_if_expr$584 = ((struct anonymous$26 *)*sp)->i;
                                      if(!((1 & (signed int)acc) == 0))
                                        tmp_if_expr$585 = (signed int)(signed long int)acc >> 1;

                                      else
                                        tmp_if_expr$585 = ((struct anonymous$26 *)acc)->i;
                                      if(!((1073741824u + (unsigned int)(tmp_if_expr$584 << tmp_if_expr$585) & 0x80000000) == 0u))
                                      {
                                        if(!((1 & (signed int)*sp) == 0))
                                          tmp_if_expr$586 = (signed int)(signed long int)*sp >> 1;

                                        else
                                          tmp_if_expr$586 = ((struct anonymous$26 *)*sp)->i;
                                        if(!((1 & (signed int)acc) == 0))
                                          tmp_if_expr$587 = (signed int)(signed long int)acc >> 1;

                                        else
                                          tmp_if_expr$587 = ((struct anonymous$26 *)acc)->i;
                                        return_value_neko_alloc_int32$588=neko_alloc_int32(tmp_if_expr$586 << tmp_if_expr$587);
                                        tmp_if_expr$591 = return_value_neko_alloc_int32$588;
                                      }

                                      else
                                      {
                                        if(!((1 & (signed int)*sp) == 0))
                                          tmp_if_expr$589 = (signed int)(signed long int)*sp >> 1;

                                        else
                                          tmp_if_expr$589 = ((struct anonymous$26 *)*sp)->i;
                                        if(!((1 & (signed int)acc) == 0))
                                          tmp_if_expr$590 = (signed int)(signed long int)acc >> 1;

                                        else
                                          tmp_if_expr$590 = ((struct anonymous$26 *)acc)->i;
                                        tmp_if_expr$591 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$589 << tmp_if_expr$590) << 1 | 1);
                                      }
                                      acc = (signed long int)tmp_if_expr$591;
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand$593;
                                        return_value_neko_stack_expand$593=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand$593 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string$592=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string$592);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string$594;
                                      return_value_neko_alloc_string$594=neko_alloc_string("Invalid operation (<<)");
                                      neko_val_throw(return_value_neko_alloc_string$594);
                                    }
                                  }
                                  tmp_post$599 = sp;
                                  sp = sp + 1l;
                                  *tmp_post$599 = (signed long int)0;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                }
                                while(*pc++ == &&LabelShl);
                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                                if(*pc++ == &&LabelPop)
                                  goto LabelPop;

                                if(*pc++ == &&LabelPush)
                                  goto LabelPush;

                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(*pc++ == &&LabelAccArray)
                                  goto LabelAccArray;

                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                                if(*pc++ == &&LabelAccThis)
                                  goto LabelAccThis;

                                if(*pc++ == &&LabelAccFalse)
                                  goto LabelAccFalse;

                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelShr:
                                ;
                                if(!((1l & acc) == 0l))
                                  tmp_if_expr$616 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr$616 = (_Bool)0;
                                if(tmp_if_expr$616)
                                {
                                  if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) >> ((signed int)acc >> 1)) & 0x80000000) == 0u))
                                  {
                                    return_value_neko_alloc_int32$600=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1));
                                    tmp_if_expr$601 = return_value_neko_alloc_int32$600;
                                  }

                                  else
                                    tmp_if_expr$601 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                                  acc = (signed long int)tmp_if_expr$601;
                                }

                                else
                                {
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr$613 = (_Bool)1;

                                  else
                                    tmp_if_expr$613 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                  if(tmp_if_expr$613)
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr$614 = (_Bool)1;

                                    else
                                      tmp_if_expr$614 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                    tmp_if_expr$615 = tmp_if_expr$614 ? (_Bool)1 : (_Bool)0;
                                  }

                                  else
                                    tmp_if_expr$615 = (_Bool)0;
                                  if(tmp_if_expr$615)
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr$602 = (signed int)(signed long int)*sp >> 1;

                                    else
                                      tmp_if_expr$602 = ((struct anonymous$26 *)*sp)->i;
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr$603 = (signed int)(signed long int)acc >> 1;

                                    else
                                      tmp_if_expr$603 = ((struct anonymous$26 *)acc)->i;
                                    if(!((1073741824u + (unsigned int)(tmp_if_expr$602 >> tmp_if_expr$603) & 0x80000000) == 0u))
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr$604 = (signed int)(signed long int)*sp >> 1;

                                      else
                                        tmp_if_expr$604 = ((struct anonymous$26 *)*sp)->i;
                                      if(!((1 & (signed int)acc) == 0))
                                        tmp_if_expr$605 = (signed int)(signed long int)acc >> 1;

                                      else
                                        tmp_if_expr$605 = ((struct anonymous$26 *)acc)->i;
                                      return_value_neko_alloc_int32$606=neko_alloc_int32(tmp_if_expr$604 >> tmp_if_expr$605);
                                      tmp_if_expr$609 = return_value_neko_alloc_int32$606;
                                    }

                                    else
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr$607 = (signed int)(signed long int)*sp >> 1;

                                      else
                                        tmp_if_expr$607 = ((struct anonymous$26 *)*sp)->i;
                                      if(!((1 & (signed int)acc) == 0))
                                        tmp_if_expr$608 = (signed int)(signed long int)acc >> 1;

                                      else
                                        tmp_if_expr$608 = ((struct anonymous$26 *)acc)->i;
                                      tmp_if_expr$609 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$607 >> tmp_if_expr$608) << 1 | 1);
                                    }
                                    acc = (signed long int)tmp_if_expr$609;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand$611;
                                      return_value_neko_stack_expand$611=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand$611 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string$610=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string$610);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string$612;
                                    return_value_neko_alloc_string$612=neko_alloc_string("Invalid operation (>>)");
                                    neko_val_throw(return_value_neko_alloc_string$612);
                                  }
                                }
                                tmp_post$617 = sp;
                                sp = sp + 1l;
                                *tmp_post$617 = (signed long int)0;
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                                if(*pc++ == &&LabelAccIndex0)
                                  goto LabelAccIndex0;

                                if(*pc++ == &&LabelAccStack1)
                                  goto LabelAccStack1;

                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                              }
                              while(*pc++ == &&LabelShr);
                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelUShr:
                              ;
                              if(!((1l & acc) == 0l))
                                tmp_if_expr$634 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$634 = (_Bool)0;
                              if(tmp_if_expr$634)
                              {
                                if(!((1073741824u + ((unsigned int)((signed int)*sp >> 1) >> ((signed int)acc >> 1)) & 0x80000000) == 0u))
                                {
                                  return_value_neko_alloc_int32$618=neko_alloc_int32((signed int)((unsigned int)((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1)));
                                  tmp_if_expr$619 = return_value_neko_alloc_int32$618;
                                }

                                else
                                  tmp_if_expr$619 = (struct _value *)(signed long int)((signed int)((unsigned int)((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                                acc = (signed long int)tmp_if_expr$619;
                              }

                              else
                              {
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr$631 = (_Bool)1;

                                else
                                  tmp_if_expr$631 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr$631)
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr$632 = (_Bool)1;

                                  else
                                    tmp_if_expr$632 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                  tmp_if_expr$633 = tmp_if_expr$632 ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr$633 = (_Bool)0;
                                if(tmp_if_expr$633)
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr$620 = (signed int)(signed long int)*sp >> 1;

                                  else
                                    tmp_if_expr$620 = ((struct anonymous$26 *)*sp)->i;
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr$621 = (signed int)(signed long int)acc >> 1;

                                  else
                                    tmp_if_expr$621 = ((struct anonymous$26 *)acc)->i;
                                  if(!((1073741824u + ((unsigned int)tmp_if_expr$620 >> tmp_if_expr$621) & 0x80000000) == 0u))
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr$622 = (signed int)(signed long int)*sp >> 1;

                                    else
                                      tmp_if_expr$622 = ((struct anonymous$26 *)*sp)->i;
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr$623 = (signed int)(signed long int)acc >> 1;

                                    else
                                      tmp_if_expr$623 = ((struct anonymous$26 *)acc)->i;
                                    return_value_neko_alloc_int32$624=neko_alloc_int32((signed int)((unsigned int)tmp_if_expr$622 >> tmp_if_expr$623));
                                    tmp_if_expr$627 = return_value_neko_alloc_int32$624;
                                  }

                                  else
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr$625 = (signed int)(signed long int)*sp >> 1;

                                    else
                                      tmp_if_expr$625 = ((struct anonymous$26 *)*sp)->i;
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr$626 = (signed int)(signed long int)acc >> 1;

                                    else
                                      tmp_if_expr$626 = ((struct anonymous$26 *)acc)->i;
                                    tmp_if_expr$627 = (struct _value *)(signed long int)((signed int)((unsigned int)tmp_if_expr$625 >> tmp_if_expr$626) << 1 | 1);
                                  }
                                  acc = (signed long int)tmp_if_expr$627;
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand$629;
                                    return_value_neko_stack_expand$629=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand$629 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string$628=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string$628);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string$630;
                                  return_value_neko_alloc_string$630=neko_alloc_string("Invalid operation (>>>)");
                                  neko_val_throw(return_value_neko_alloc_string$630);
                                }
                              }
                              tmp_post$635 = sp;
                              sp = sp + 1l;
                              *tmp_post$635 = (signed long int)0;
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                            }
                            while(*pc++ == &&LabelUShr);
                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelOr:
                            ;
                            if(!((1l & acc) == 0l))
                              tmp_if_expr$652 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr$652 = (_Bool)0;
                            if(tmp_if_expr$652)
                            {
                              if(!((((unsigned int)((signed int)*sp >> 1) | (unsigned int)((signed int)acc >> 1)) + 1073741824u & 0x80000000) == 0u))
                              {
                                return_value_neko_alloc_int32$636=neko_alloc_int32((signed int)(signed long int)*sp >> 1 | (signed int)(signed long int)acc >> 1);
                                tmp_if_expr$637 = return_value_neko_alloc_int32$636;
                              }

                              else
                                tmp_if_expr$637 = (struct _value *)(signed long int)((signed int)((signed int)(signed long int)*sp >> 1 | (signed int)(signed long int)acc >> 1) << 1 | 1);
                              acc = (signed long int)tmp_if_expr$637;
                            }

                            else
                            {
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr$649 = (_Bool)1;

                              else
                                tmp_if_expr$649 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                              if(tmp_if_expr$649)
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr$650 = (_Bool)1;

                                else
                                  tmp_if_expr$650 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                tmp_if_expr$651 = tmp_if_expr$650 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr$651 = (_Bool)0;
                              if(tmp_if_expr$651)
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr$638 = (signed int)(signed long int)*sp >> 1;

                                else
                                  tmp_if_expr$638 = ((struct anonymous$26 *)*sp)->i;
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr$639 = (signed int)(signed long int)acc >> 1;

                                else
                                  tmp_if_expr$639 = ((struct anonymous$26 *)acc)->i;
                                if(!((((unsigned int)tmp_if_expr$638 | (unsigned int)tmp_if_expr$639) + 1073741824u & 0x80000000) == 0u))
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr$640 = (signed int)(signed long int)*sp >> 1;

                                  else
                                    tmp_if_expr$640 = ((struct anonymous$26 *)*sp)->i;
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr$641 = (signed int)(signed long int)acc >> 1;

                                  else
                                    tmp_if_expr$641 = ((struct anonymous$26 *)acc)->i;
                                  return_value_neko_alloc_int32$642=neko_alloc_int32(tmp_if_expr$640 | tmp_if_expr$641);
                                  tmp_if_expr$645 = return_value_neko_alloc_int32$642;
                                }

                                else
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr$643 = (signed int)(signed long int)*sp >> 1;

                                  else
                                    tmp_if_expr$643 = ((struct anonymous$26 *)*sp)->i;
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr$644 = (signed int)(signed long int)acc >> 1;

                                  else
                                    tmp_if_expr$644 = ((struct anonymous$26 *)acc)->i;
                                  tmp_if_expr$645 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$643 | tmp_if_expr$644) << 1 | 1);
                                }
                                acc = (signed long int)tmp_if_expr$645;
                              }

                              else
                              {
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand$647;
                                  return_value_neko_stack_expand$647=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand$647 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string$646=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string$646);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                vm->sp = sp;
                                vm->csp = csp;
                                struct _value *return_value_neko_alloc_string$648;
                                return_value_neko_alloc_string$648=neko_alloc_string("Invalid operation (|)");
                                neko_val_throw(return_value_neko_alloc_string$648);
                              }
                            }
                            tmp_post$653 = sp;
                            sp = sp + 1l;
                            *tmp_post$653 = (signed long int)0;
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                          }
                          while(*pc++ == &&LabelOr);
                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(*pc++ == &&LabelCall)
                            goto LabelCall;

                          if(*pc++ == &&LabelPop)
                            goto LabelPop;

                          if(*pc++ == &&LabelPush)
                            goto LabelPush;

                          if(*pc++ == &&LabelSetThis)
                            goto LabelSetThis;

                          if(*pc++ == &&LabelSetIndex)
                            goto LabelSetIndex;

                          if(*pc++ == &&LabelSetArray)
                            goto LabelSetArray;

                          if(*pc++ == &&LabelSetField)
                            goto LabelSetField;

                          if(*pc++ == &&LabelSetEnv)
                            goto LabelSetEnv;

                          if(*pc++ == &&LabelSetGlobal)
                            goto LabelSetGlobal;

                          if(*pc++ == &&LabelSetStack)
                            goto LabelSetStack;

                          if(*pc++ == &&LabelAccBuiltin)
                            goto LabelAccBuiltin;

                          if(*pc++ == &&LabelAccIndex)
                            goto LabelAccIndex;

                          if(*pc++ == &&LabelAccArray)
                            goto LabelAccArray;

                          if(*pc++ == &&LabelAccField)
                            goto LabelAccField;

                          if(*pc++ == &&LabelAccEnv)
                            goto LabelAccEnv;

                          if(*pc++ == &&LabelAccGlobal)
                            goto LabelAccGlobal;

                          if(*pc++ == &&LabelAccStack)
                            goto LabelAccStack;

                          if(*pc++ == &&LabelAccInt)
                            goto LabelAccInt;

                          if(*pc++ == &&LabelAccThis)
                            goto LabelAccThis;

                          if(*pc++ == &&LabelAccFalse)
                            goto LabelAccFalse;

                          if(*pc++ == &&LabelAccTrue)
                            goto LabelAccTrue;

                          if(*pc++ == &&LabelAccNull)
                            goto LabelAccNull;

                          if(*pc++ == &&end)
                            goto end;

                        }

                        do
                        {

                        LabelAnd:
                          ;
                          if(!((1l & acc) == 0l))
                            tmp_if_expr$670 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr$670 = (_Bool)0;
                          if(tmp_if_expr$670)
                          {
                            if(!((((unsigned int)((signed int)*sp >> 1) & (unsigned int)((signed int)acc >> 1)) + 1073741824u & 0x80000000) == 0u))
                            {
                              return_value_neko_alloc_int32$654=neko_alloc_int32((signed int)(signed long int)*sp >> 1 & (signed int)(signed long int)acc >> 1);
                              tmp_if_expr$655 = return_value_neko_alloc_int32$654;
                            }

                            else
                              tmp_if_expr$655 = (struct _value *)(signed long int)((signed int)((signed int)(signed long int)*sp >> 1 & (signed int)(signed long int)acc >> 1) << 1 | 1);
                            acc = (signed long int)tmp_if_expr$655;
                          }

                          else
                          {
                            if(!((1 & (signed int)acc) == 0))
                              tmp_if_expr$667 = (_Bool)1;

                            else
                              tmp_if_expr$667 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                            if(tmp_if_expr$667)
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr$668 = (_Bool)1;

                              else
                                tmp_if_expr$668 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                              tmp_if_expr$669 = tmp_if_expr$668 ? (_Bool)1 : (_Bool)0;
                            }

                            else
                              tmp_if_expr$669 = (_Bool)0;
                            if(tmp_if_expr$669)
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr$656 = (signed int)(signed long int)*sp >> 1;

                              else
                                tmp_if_expr$656 = ((struct anonymous$26 *)*sp)->i;
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr$657 = (signed int)(signed long int)acc >> 1;

                              else
                                tmp_if_expr$657 = ((struct anonymous$26 *)acc)->i;
                              if(!((((unsigned int)tmp_if_expr$656 & (unsigned int)tmp_if_expr$657) + 1073741824u & 0x80000000) == 0u))
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr$658 = (signed int)(signed long int)*sp >> 1;

                                else
                                  tmp_if_expr$658 = ((struct anonymous$26 *)*sp)->i;
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr$659 = (signed int)(signed long int)acc >> 1;

                                else
                                  tmp_if_expr$659 = ((struct anonymous$26 *)acc)->i;
                                return_value_neko_alloc_int32$660=neko_alloc_int32(tmp_if_expr$658 & tmp_if_expr$659);
                                tmp_if_expr$663 = return_value_neko_alloc_int32$660;
                              }

                              else
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr$661 = (signed int)(signed long int)*sp >> 1;

                                else
                                  tmp_if_expr$661 = ((struct anonymous$26 *)*sp)->i;
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr$662 = (signed int)(signed long int)acc >> 1;

                                else
                                  tmp_if_expr$662 = ((struct anonymous$26 *)acc)->i;
                                tmp_if_expr$663 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$661 & tmp_if_expr$662) << 1 | 1);
                              }
                              acc = (signed long int)tmp_if_expr$663;
                            }

                            else
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand$665;
                                return_value_neko_stack_expand$665=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand$665 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string$664=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string$664);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string$666;
                              return_value_neko_alloc_string$666=neko_alloc_string("Invalid operation (&)");
                              neko_val_throw(return_value_neko_alloc_string$666);
                            }
                          }
                          tmp_post$671 = sp;
                          sp = sp + 1l;
                          *tmp_post$671 = (signed long int)0;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                        }
                        while(*pc++ == &&LabelAnd);
                        if(*pc++ == &&LabelOr)
                          goto LabelOr;

                        if(*pc++ == &&LabelUShr)
                          goto LabelUShr;

                        if(*pc++ == &&LabelShr)
                          goto LabelShr;

                        if(*pc++ == &&LabelShl)
                          goto LabelShl;

                        if(*pc++ == &&LabelMod)
                          goto LabelMod;

                        if(*pc++ == &&LabelDiv)
                          goto LabelDiv;

                        if(*pc++ == &&LabelMult)
                          goto LabelMult;

                        if(*pc++ == &&LabelSub)
                          goto LabelSub;

                        if(*pc++ == &&LabelAdd)
                          goto LabelAdd;

                        if(*pc++ == &&LabelIsNotNull)
                          goto LabelIsNotNull;

                        if(*pc++ == &&LabelIsNull)
                          goto LabelIsNull;

                        if(*pc++ == &&LabelBool)
                          goto LabelBool;

                        if(*pc++ == &&LabelMakeArray)
                          goto LabelMakeArray;

                        if(*pc++ == &&LabelMakeEnv)
                          goto LabelMakeEnv;

                        if(*pc++ == &&LabelRet)
                          goto LabelRet;

                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                      }

                      do
                      {

                      LabelXor:
                        ;
                        if(!((1l & acc) == 0l))
                          tmp_if_expr$688 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr$688 = (_Bool)0;
                        if(tmp_if_expr$688)
                        {
                          if(!((((unsigned int)((signed int)*sp >> 1) ^ (unsigned int)((signed int)acc >> 1)) + 1073741824u & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32$672=neko_alloc_int32((signed int)(signed long int)*sp >> 1 ^ (signed int)(signed long int)acc >> 1);
                            tmp_if_expr$673 = return_value_neko_alloc_int32$672;
                          }

                          else
                            tmp_if_expr$673 = (struct _value *)(signed long int)((signed int)((signed int)(signed long int)*sp >> 1 ^ (signed int)(signed long int)acc >> 1) << 1 | 1);
                          acc = (signed long int)tmp_if_expr$673;
                        }

                        else
                        {
                          if(!((1 & (signed int)acc) == 0))
                            tmp_if_expr$685 = (_Bool)1;

                          else
                            tmp_if_expr$685 = (signed int)*((enum anonymous$7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$685)
                          {
                            if(!((1 & (signed int)*sp) == 0))
                              tmp_if_expr$686 = (_Bool)1;

                            else
                              tmp_if_expr$686 = (signed int)*((enum anonymous$7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                            tmp_if_expr$687 = tmp_if_expr$686 ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr$687 = (_Bool)0;
                          if(tmp_if_expr$687)
                          {
                            if(!((1 & (signed int)*sp) == 0))
                              tmp_if_expr$674 = (signed int)(signed long int)*sp >> 1;

                            else
                              tmp_if_expr$674 = ((struct anonymous$26 *)*sp)->i;
                            if(!((1 & (signed int)acc) == 0))
                              tmp_if_expr$675 = (signed int)(signed long int)acc >> 1;

                            else
                              tmp_if_expr$675 = ((struct anonymous$26 *)acc)->i;
                            if(!((((unsigned int)tmp_if_expr$674 ^ (unsigned int)tmp_if_expr$675) + 1073741824u & 0x80000000) == 0u))
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr$676 = (signed int)(signed long int)*sp >> 1;

                              else
                                tmp_if_expr$676 = ((struct anonymous$26 *)*sp)->i;
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr$677 = (signed int)(signed long int)acc >> 1;

                              else
                                tmp_if_expr$677 = ((struct anonymous$26 *)acc)->i;
                              return_value_neko_alloc_int32$678=neko_alloc_int32(tmp_if_expr$676 ^ tmp_if_expr$677);
                              tmp_if_expr$681 = return_value_neko_alloc_int32$678;
                            }

                            else
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr$679 = (signed int)(signed long int)*sp >> 1;

                              else
                                tmp_if_expr$679 = ((struct anonymous$26 *)*sp)->i;
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr$680 = (signed int)(signed long int)acc >> 1;

                              else
                                tmp_if_expr$680 = ((struct anonymous$26 *)acc)->i;
                              tmp_if_expr$681 = (struct _value *)(signed long int)((signed int)(tmp_if_expr$679 ^ tmp_if_expr$680) << 1 | 1);
                            }
                            acc = (signed long int)tmp_if_expr$681;
                          }

                          else
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand$683;
                              return_value_neko_stack_expand$683=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand$683 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string$682=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string$682);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string$684;
                            return_value_neko_alloc_string$684=neko_alloc_string("Invalid operation (^)");
                            neko_val_throw(return_value_neko_alloc_string$684);
                          }
                        }
                        tmp_post$689 = sp;
                        sp = sp + 1l;
                        *tmp_post$689 = (signed long int)0;
                        *pc++;
                        if(*pc++ == &&id_mod_next2)
                          goto id_mod_next2;

                        if(*pc++ == &&id_mod_next)
                          goto id_mod_next;

                        if(*pc++ == &&div_next)
                          goto div_next;

                        if(*pc++ == &&id_mult_next2)
                          goto id_mult_next2;

                        if(*pc++ == &&id_mult_next)
                          goto id_mult_next;

                        if(*pc++ == &&id_sub_next2)
                          goto id_sub_next2;

                        if(*pc++ == &&id_sub_next)
                          goto id_sub_next;

                        if(*pc++ == &&add_3)
                          goto add_3;

                        if(*pc++ == &&add_2)
                          goto add_2;

                        if(*pc++ == &&add_next)
                          goto add_next;

                        if(*pc++ == &&do_call)
                          goto LabelCall;

                        if(*pc++ == &&LabelLast)
                          goto LabelLast;

                        if(*pc++ == &&LabelAccInt32)
                          goto LabelAccInt32;

                        if(*pc++ == &&LabelMakeArray2)
                          goto LabelMakeArray2;

                        if(*pc++ == &&LabelLoop)
                          goto LabelLoop;

                        if(*pc++ == &&LabelTailCall)
                          goto LabelTailCall;

                        if(*pc++ == &&LabelPhysCompare)
                          goto LabelPhysCompare;

                        if(*pc++ == &&LabelAccIndex1)
                          goto LabelAccIndex1;

                        if(*pc++ == &&LabelAccIndex0)
                          goto LabelAccIndex0;

                        if(*pc++ == &&LabelAccStack1)
                          goto LabelAccStack1;

                        if(*pc++ == &&LabelAccStack0)
                          goto LabelAccStack0;

                        if(*pc++ == &&LabelApply)
                          goto LabelApply;

                        if(*pc++ == &&LabelJumpTable)
                          goto LabelJumpTable;

                        if(*pc++ == &&LabelNew)
                          goto LabelNew;

                        if(*pc++ == &&LabelHash)
                          goto LabelHash;

                        if(*pc++ == &&LabelCompare)
                          goto LabelCompare;

                        if(*pc++ == &&LabelTypeOf)
                          goto LabelTypeOf;

                        if(*pc++ == &&LabelNot)
                          goto LabelNot;

                        if(*pc++ == &&LabelLte)
                          goto LabelLte;

                        if(*pc++ == &&LabelLt)
                          goto LabelLt;

                        if(*pc++ == &&LabelGte)
                          goto LabelGte;

                        if(*pc++ == &&LabelGt)
                          goto LabelGt;

                        if(*pc++ == &&LabelNeq)
                          goto LabelNeq;

                        if(*pc++ == &&LabelEq)
                          goto LabelEq;

                      }
                      while(*pc++ == &&LabelXor);
                      if(*pc++ == &&LabelAnd)
                        goto LabelAnd;

                      if(*pc++ == &&LabelOr)
                        goto LabelOr;

                      if(*pc++ == &&LabelUShr)
                        goto LabelUShr;

                      if(*pc++ == &&LabelShr)
                        goto LabelShr;

                      if(*pc++ == &&LabelShl)
                        goto LabelShl;

                      if(*pc++ == &&LabelMod)
                        goto LabelMod;

                      if(*pc++ == &&LabelDiv)
                        goto LabelDiv;

                      if(*pc++ == &&LabelMult)
                        goto LabelMult;

                      if(*pc++ == &&LabelSub)
                        goto LabelSub;

                      if(*pc++ == &&LabelAdd)
                        goto LabelAdd;

                      if(*pc++ == &&LabelIsNotNull)
                        goto LabelIsNotNull;

                      if(*pc++ == &&LabelIsNull)
                        goto LabelIsNull;

                      if(*pc++ == &&LabelBool)
                        goto LabelBool;

                      if(*pc++ == &&LabelMakeArray)
                        goto LabelMakeArray;

                      if(*pc++ == &&LabelMakeEnv)
                        goto LabelMakeEnv;

                      if(*pc++ == &&LabelRet)
                        goto LabelRet;

                      if(*pc++ == &&LabelEndTrap)
                        goto LabelEndTrap;

                      if(*pc++ == &&LabelTrap)
                        goto LabelTrap;

                      if(*pc++ == &&LabelJumpIfNot)
                        goto LabelJumpIfNot;

                      if(*pc++ == &&LabelJumpIf)
                        goto LabelJumpIf;

                      if(*pc++ == &&LabelJump)
                        goto LabelJump;

                      if(*pc++ == &&LabelObjCall)
                        goto LabelObjCall;

                      if(*pc++ == &&LabelCall)
                        goto LabelCall;

                      if(*pc++ == &&LabelPop)
                        goto LabelPop;

                      if(*pc++ == &&LabelPush)
                        goto LabelPush;

                      if(*pc++ == &&LabelSetThis)
                        goto LabelSetThis;

                      if(*pc++ == &&LabelSetIndex)
                        goto LabelSetIndex;

                      if(*pc++ == &&LabelSetArray)
                        goto LabelSetArray;

                      if(*pc++ == &&LabelSetField)
                        goto LabelSetField;

                      if(*pc++ == &&LabelSetEnv)
                        goto LabelSetEnv;

                      if(*pc++ == &&LabelSetGlobal)
                        goto LabelSetGlobal;

                      if(*pc++ == &&LabelSetStack)
                        goto LabelSetStack;

                      if(*pc++ == &&LabelAccBuiltin)
                        goto LabelAccBuiltin;

                      if(*pc++ == &&LabelAccIndex)
                        goto LabelAccIndex;

                      if(*pc++ == &&LabelAccArray)
                        goto LabelAccArray;

                      if(*pc++ == &&LabelAccField)
                        goto LabelAccField;

                      if(*pc++ == &&LabelAccEnv)
                        goto LabelAccEnv;

                      if(*pc++ == &&LabelAccGlobal)
                        goto LabelAccGlobal;

                      if(*pc++ == &&LabelAccStack)
                        goto LabelAccStack;

                      if(*pc++ == &&LabelAccInt)
                        goto LabelAccInt;

                      if(*pc++ == &&LabelAccThis)
                        goto LabelAccThis;

                      if(*pc++ == &&LabelAccFalse)
                        goto LabelAccFalse;

                      if(*pc++ == &&LabelAccTrue)
                        goto LabelAccTrue;

                      if(*pc++ == &&LabelAccNull)
                        goto LabelAccNull;

                      if(*pc++ == &&end)
                        goto end;

                    }

                    do
                    {

                    LabelEq:
                      ;
                      vm->sp = sp;
                      vm->csp = csp;
                      return_value_neko_val_compare$690=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                      acc = (signed long int)return_value_neko_val_compare$690;
                      sp = vm->sp;
                      csp = vm->csp;
                      tmp_post$691 = sp;
                      sp = sp + 1l;
                      *tmp_post$691 = (signed long int)0;
                      acc = (signed long int)(acc == (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                      *pc++;
                      if(*pc++ == &&id_mod_next2)
                        goto id_mod_next2;

                      if(*pc++ == &&id_mod_next)
                        goto id_mod_next;

                      if(*pc++ == &&div_next)
                        goto div_next;

                      if(*pc++ == &&id_mult_next2)
                        goto id_mult_next2;

                      if(*pc++ == &&id_mult_next)
                        goto id_mult_next;

                      if(*pc++ == &&id_sub_next2)
                        goto id_sub_next2;

                      if(*pc++ == &&id_sub_next)
                        goto id_sub_next;

                      if(*pc++ == &&add_3)
                        goto add_3;

                      if(*pc++ == &&add_2)
                        goto add_2;

                      if(*pc++ == &&add_next)
                        goto add_next;

                      if(*pc++ == &&do_call)
                        goto LabelCall;

                      if(*pc++ == &&LabelLast)
                        goto LabelLast;

                      if(*pc++ == &&LabelAccInt32)
                        goto LabelAccInt32;

                      if(*pc++ == &&LabelMakeArray2)
                        goto LabelMakeArray2;

                      if(*pc++ == &&LabelLoop)
                        goto LabelLoop;

                      if(*pc++ == &&LabelTailCall)
                        goto LabelTailCall;

                      if(*pc++ == &&LabelPhysCompare)
                        goto LabelPhysCompare;

                      if(*pc++ == &&LabelAccIndex1)
                        goto LabelAccIndex1;

                      if(*pc++ == &&LabelAccIndex0)
                        goto LabelAccIndex0;

                      if(*pc++ == &&LabelAccStack1)
                        goto LabelAccStack1;

                      if(*pc++ == &&LabelAccStack0)
                        goto LabelAccStack0;

                      if(*pc++ == &&LabelApply)
                        goto LabelApply;

                      if(*pc++ == &&LabelJumpTable)
                        goto LabelJumpTable;

                      if(*pc++ == &&LabelNew)
                        goto LabelNew;

                      if(*pc++ == &&LabelHash)
                        goto LabelHash;

                      if(*pc++ == &&LabelCompare)
                        goto LabelCompare;

                      if(*pc++ == &&LabelTypeOf)
                        goto LabelTypeOf;

                      if(*pc++ == &&LabelNot)
                        goto LabelNot;

                      if(*pc++ == &&LabelLte)
                        goto LabelLte;

                      if(*pc++ == &&LabelLt)
                        goto LabelLt;

                      if(*pc++ == &&LabelGte)
                        goto LabelGte;

                      if(*pc++ == &&LabelGt)
                        goto LabelGt;

                      if(*pc++ == &&LabelNeq)
                        goto LabelNeq;

                    }
                    while(*pc++ == &&LabelEq);
                    if(*pc++ == &&LabelXor)
                      goto LabelXor;

                    if(*pc++ == &&LabelAnd)
                      goto LabelAnd;

                    if(*pc++ == &&LabelOr)
                      goto LabelOr;

                    if(*pc++ == &&LabelUShr)
                      goto LabelUShr;

                    if(*pc++ == &&LabelShr)
                      goto LabelShr;

                    if(*pc++ == &&LabelShl)
                      goto LabelShl;

                    if(*pc++ == &&LabelMod)
                      goto LabelMod;

                    if(*pc++ == &&LabelDiv)
                      goto LabelDiv;

                    if(*pc++ == &&LabelMult)
                      goto LabelMult;

                    if(*pc++ == &&LabelSub)
                      goto LabelSub;

                    if(*pc++ == &&LabelAdd)
                      goto LabelAdd;

                    if(*pc++ == &&LabelIsNotNull)
                      goto LabelIsNotNull;

                    if(*pc++ == &&LabelIsNull)
                      goto LabelIsNull;

                    if(*pc++ == &&LabelBool)
                      goto LabelBool;

                    if(*pc++ == &&LabelMakeArray)
                      goto LabelMakeArray;

                    if(*pc++ == &&LabelMakeEnv)
                      goto LabelMakeEnv;

                    if(*pc++ == &&LabelRet)
                      goto LabelRet;

                    if(*pc++ == &&LabelEndTrap)
                      goto LabelEndTrap;

                    if(*pc++ == &&LabelTrap)
                      goto LabelTrap;

                    if(*pc++ == &&LabelJumpIfNot)
                      goto LabelJumpIfNot;

                    if(*pc++ == &&LabelJumpIf)
                      goto LabelJumpIf;

                    if(*pc++ == &&LabelJump)
                      goto LabelJump;

                    if(*pc++ == &&LabelObjCall)
                      goto LabelObjCall;

                    if(*pc++ == &&LabelCall)
                      goto LabelCall;

                    if(*pc++ == &&LabelPop)
                      goto LabelPop;

                    if(*pc++ == &&LabelPush)
                      goto LabelPush;

                    if(*pc++ == &&LabelSetThis)
                      goto LabelSetThis;

                    if(*pc++ == &&LabelSetIndex)
                      goto LabelSetIndex;

                    if(*pc++ == &&LabelSetArray)
                      goto LabelSetArray;

                    if(*pc++ == &&LabelSetField)
                      goto LabelSetField;

                    if(*pc++ == &&LabelSetEnv)
                      goto LabelSetEnv;

                    if(*pc++ == &&LabelSetGlobal)
                      goto LabelSetGlobal;

                    if(*pc++ == &&LabelSetStack)
                      goto LabelSetStack;

                    if(*pc++ == &&LabelAccBuiltin)
                      goto LabelAccBuiltin;

                    if(*pc++ == &&LabelAccIndex)
                      goto LabelAccIndex;

                    if(*pc++ == &&LabelAccArray)
                      goto LabelAccArray;

                    if(*pc++ == &&LabelAccField)
                      goto LabelAccField;

                    if(*pc++ == &&LabelAccEnv)
                      goto LabelAccEnv;

                    if(*pc++ == &&LabelAccGlobal)
                      goto LabelAccGlobal;

                    if(*pc++ == &&LabelAccStack)
                      goto LabelAccStack;

                    if(*pc++ == &&LabelAccInt)
                      goto LabelAccInt;

                    if(*pc++ == &&LabelAccThis)
                      goto LabelAccThis;

                    if(*pc++ == &&LabelAccFalse)
                      goto LabelAccFalse;

                    if(*pc++ == &&LabelAccTrue)
                      goto LabelAccTrue;

                    if(*pc++ == &&LabelAccNull)
                      goto LabelAccNull;

                    if(*pc++ == &&end)
                      goto end;

                  }

                  do
                  {

                  LabelNeq:
                    ;
                    vm->sp = sp;
                    vm->csp = csp;
                    return_value_neko_val_compare$692=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                    acc = (signed long int)(return_value_neko_val_compare$692 == 0 ? val_false : val_true);
                    sp = vm->sp;
                    csp = vm->csp;
                    tmp_post$693 = sp;
                    sp = sp + 1l;
                    *tmp_post$693 = (signed long int)0;
                    *pc++;
                    if(*pc++ == &&id_mod_next2)
                      goto id_mod_next2;

                    if(*pc++ == &&id_mod_next)
                      goto id_mod_next;

                    if(*pc++ == &&div_next)
                      goto div_next;

                    if(*pc++ == &&id_mult_next2)
                      goto id_mult_next2;

                    if(*pc++ == &&id_mult_next)
                      goto id_mult_next;

                    if(*pc++ == &&id_sub_next2)
                      goto id_sub_next2;

                    if(*pc++ == &&id_sub_next)
                      goto id_sub_next;

                    if(*pc++ == &&add_3)
                      goto add_3;

                    if(*pc++ == &&add_2)
                      goto add_2;

                    if(*pc++ == &&add_next)
                      goto add_next;

                    if(*pc++ == &&do_call)
                      goto LabelCall;

                    if(*pc++ == &&LabelLast)
                      goto LabelLast;

                    if(*pc++ == &&LabelAccInt32)
                      goto LabelAccInt32;

                    if(*pc++ == &&LabelMakeArray2)
                      goto LabelMakeArray2;

                    if(*pc++ == &&LabelLoop)
                      goto LabelLoop;

                    if(*pc++ == &&LabelTailCall)
                      goto LabelTailCall;

                    if(*pc++ == &&LabelPhysCompare)
                      goto LabelPhysCompare;

                    if(*pc++ == &&LabelAccIndex1)
                      goto LabelAccIndex1;

                    if(*pc++ == &&LabelAccIndex0)
                      goto LabelAccIndex0;

                    if(*pc++ == &&LabelAccStack1)
                      goto LabelAccStack1;

                    if(*pc++ == &&LabelAccStack0)
                      goto LabelAccStack0;

                    if(*pc++ == &&LabelApply)
                      goto LabelApply;

                    if(*pc++ == &&LabelJumpTable)
                      goto LabelJumpTable;

                    if(*pc++ == &&LabelNew)
                      goto LabelNew;

                    if(*pc++ == &&LabelHash)
                      goto LabelHash;

                    if(*pc++ == &&LabelCompare)
                      goto LabelCompare;

                    if(*pc++ == &&LabelTypeOf)
                      goto LabelTypeOf;

                    if(*pc++ == &&LabelNot)
                      goto LabelNot;

                    if(*pc++ == &&LabelLte)
                      goto LabelLte;

                    if(*pc++ == &&LabelLt)
                      goto LabelLt;

                    if(*pc++ == &&LabelGte)
                      goto LabelGte;

                    if(*pc++ == &&LabelGt)
                      goto LabelGt;

                  }
                  while(*pc++ == &&LabelNeq);
                  if(*pc++ == &&LabelEq)
                    goto LabelEq;

                  if(*pc++ == &&LabelXor)
                    goto LabelXor;

                  if(*pc++ == &&LabelAnd)
                    goto LabelAnd;

                  if(*pc++ == &&LabelOr)
                    goto LabelOr;

                  if(*pc++ == &&LabelUShr)
                    goto LabelUShr;

                  if(*pc++ == &&LabelShr)
                    goto LabelShr;

                  if(*pc++ == &&LabelShl)
                    goto LabelShl;

                  if(*pc++ == &&LabelMod)
                    goto LabelMod;

                  if(*pc++ == &&LabelDiv)
                    goto LabelDiv;

                  if(*pc++ == &&LabelMult)
                    goto LabelMult;

                  if(*pc++ == &&LabelSub)
                    goto LabelSub;

                  if(*pc++ == &&LabelAdd)
                    goto LabelAdd;

                  if(*pc++ == &&LabelIsNotNull)
                    goto LabelIsNotNull;

                  if(*pc++ == &&LabelIsNull)
                    goto LabelIsNull;

                  if(*pc++ == &&LabelBool)
                    goto LabelBool;

                  if(*pc++ == &&LabelMakeArray)
                    goto LabelMakeArray;

                  if(*pc++ == &&LabelMakeEnv)
                    goto LabelMakeEnv;

                  if(*pc++ == &&LabelRet)
                    goto LabelRet;

                  if(*pc++ == &&LabelEndTrap)
                    goto LabelEndTrap;

                  if(*pc++ == &&LabelTrap)
                    goto LabelTrap;

                  if(*pc++ == &&LabelJumpIfNot)
                    goto LabelJumpIfNot;

                  if(*pc++ == &&LabelJumpIf)
                    goto LabelJumpIf;

                  if(*pc++ == &&LabelJump)
                    goto LabelJump;

                  if(*pc++ == &&LabelObjCall)
                    goto LabelObjCall;

                  if(*pc++ == &&LabelCall)
                    goto LabelCall;

                  if(*pc++ == &&LabelPop)
                    goto LabelPop;

                  if(*pc++ == &&LabelPush)
                    goto LabelPush;

                  if(*pc++ == &&LabelSetThis)
                    goto LabelSetThis;

                  if(*pc++ == &&LabelSetIndex)
                    goto LabelSetIndex;

                  if(*pc++ == &&LabelSetArray)
                    goto LabelSetArray;

                  if(*pc++ == &&LabelSetField)
                    goto LabelSetField;

                  if(*pc++ == &&LabelSetEnv)
                    goto LabelSetEnv;

                  if(*pc++ == &&LabelSetGlobal)
                    goto LabelSetGlobal;

                  if(*pc++ == &&LabelSetStack)
                    goto LabelSetStack;

                  if(*pc++ == &&LabelAccBuiltin)
                    goto LabelAccBuiltin;

                  if(*pc++ == &&LabelAccIndex)
                    goto LabelAccIndex;

                  if(*pc++ == &&LabelAccArray)
                    goto LabelAccArray;

                  if(*pc++ == &&LabelAccField)
                    goto LabelAccField;

                  if(*pc++ == &&LabelAccEnv)
                    goto LabelAccEnv;

                  if(*pc++ == &&LabelAccGlobal)
                    goto LabelAccGlobal;

                  if(*pc++ == &&LabelAccStack)
                    goto LabelAccStack;

                  if(*pc++ == &&LabelAccInt)
                    goto LabelAccInt;

                  if(*pc++ == &&LabelAccThis)
                    goto LabelAccThis;

                  if(*pc++ == &&LabelAccFalse)
                    goto LabelAccFalse;

                  if(*pc++ == &&LabelAccTrue)
                    goto LabelAccTrue;

                  if(*pc++ == &&LabelAccNull)
                    goto LabelAccNull;

                  if(*pc++ == &&end)
                    goto end;

                }

                do
                {

                LabelLt:
                  ;
                  vm->sp = sp;
                  vm->csp = csp;
                  return_value_neko_val_compare$694=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                  acc = (signed long int)return_value_neko_val_compare$694;
                  sp = vm->sp;
                  csp = vm->csp;
                  tmp_post$695 = sp;
                  sp = sp + 1l;
                  *tmp_post$695 = (signed long int)0;
                  acc = (signed long int)(acc < (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                  *pc++;
                  if(*pc++ == &&id_mod_next2)
                    goto id_mod_next2;

                  if(*pc++ == &&id_mod_next)
                    goto id_mod_next;

                  if(*pc++ == &&div_next)
                    goto div_next;

                  if(*pc++ == &&id_mult_next2)
                    goto id_mult_next2;

                  if(*pc++ == &&id_mult_next)
                    goto id_mult_next;

                  if(*pc++ == &&id_sub_next2)
                    goto id_sub_next2;

                  if(*pc++ == &&id_sub_next)
                    goto id_sub_next;

                  if(*pc++ == &&add_3)
                    goto add_3;

                  if(*pc++ == &&add_2)
                    goto add_2;

                  if(*pc++ == &&add_next)
                    goto add_next;

                  if(*pc++ == &&do_call)
                    goto LabelCall;

                  if(*pc++ == &&LabelLast)
                    goto LabelLast;

                  if(*pc++ == &&LabelAccInt32)
                    goto LabelAccInt32;

                  if(*pc++ == &&LabelMakeArray2)
                    goto LabelMakeArray2;

                  if(*pc++ == &&LabelLoop)
                    goto LabelLoop;

                  if(*pc++ == &&LabelTailCall)
                    goto LabelTailCall;

                  if(*pc++ == &&LabelPhysCompare)
                    goto LabelPhysCompare;

                  if(*pc++ == &&LabelAccIndex1)
                    goto LabelAccIndex1;

                  if(*pc++ == &&LabelAccIndex0)
                    goto LabelAccIndex0;

                  if(*pc++ == &&LabelAccStack1)
                    goto LabelAccStack1;

                  if(*pc++ == &&LabelAccStack0)
                    goto LabelAccStack0;

                  if(*pc++ == &&LabelApply)
                    goto LabelApply;

                  if(*pc++ == &&LabelJumpTable)
                    goto LabelJumpTable;

                  if(*pc++ == &&LabelNew)
                    goto LabelNew;

                  if(*pc++ == &&LabelHash)
                    goto LabelHash;

                  if(*pc++ == &&LabelCompare)
                    goto LabelCompare;

                  if(*pc++ == &&LabelTypeOf)
                    goto LabelTypeOf;

                  if(*pc++ == &&LabelNot)
                    goto LabelNot;

                  if(*pc++ == &&LabelLte)
                    goto LabelLte;

                }
                while(*pc++ == &&LabelLt);
                if(*pc++ == &&LabelGte)
                  goto LabelGte;

                if(*pc++ == &&LabelGt)
                  goto LabelGt;

                if(*pc++ == &&LabelNeq)
                  goto LabelNeq;

                if(*pc++ == &&LabelEq)
                  goto LabelEq;

                if(*pc++ == &&LabelXor)
                  goto LabelXor;

                if(*pc++ == &&LabelAnd)
                  goto LabelAnd;

                if(*pc++ == &&LabelOr)
                  goto LabelOr;

                if(*pc++ == &&LabelUShr)
                  goto LabelUShr;

                if(*pc++ == &&LabelShr)
                  goto LabelShr;

                if(*pc++ == &&LabelShl)
                  goto LabelShl;

                if(*pc++ == &&LabelMod)
                  goto LabelMod;

                if(*pc++ == &&LabelDiv)
                  goto LabelDiv;

                if(*pc++ == &&LabelMult)
                  goto LabelMult;

                if(*pc++ == &&LabelSub)
                  goto LabelSub;

                if(*pc++ == &&LabelAdd)
                  goto LabelAdd;

                if(*pc++ == &&LabelIsNotNull)
                  goto LabelIsNotNull;

                if(*pc++ == &&LabelIsNull)
                  goto LabelIsNull;

                if(*pc++ == &&LabelBool)
                  goto LabelBool;

                if(*pc++ == &&LabelMakeArray)
                  goto LabelMakeArray;

                if(*pc++ == &&LabelMakeEnv)
                  goto LabelMakeEnv;

                if(*pc++ == &&LabelRet)
                  goto LabelRet;

                if(*pc++ == &&LabelEndTrap)
                  goto LabelEndTrap;

                if(*pc++ == &&LabelTrap)
                  goto LabelTrap;

                if(*pc++ == &&LabelJumpIfNot)
                  goto LabelJumpIfNot;

                if(*pc++ == &&LabelJumpIf)
                  goto LabelJumpIf;

                if(*pc++ == &&LabelJump)
                  goto LabelJump;

                if(*pc++ == &&LabelObjCall)
                  goto LabelObjCall;

                if(*pc++ == &&LabelCall)
                  goto LabelCall;

                if(*pc++ == &&LabelPop)
                  goto LabelPop;

                if(*pc++ == &&LabelPush)
                  goto LabelPush;

                if(*pc++ == &&LabelSetThis)
                  goto LabelSetThis;

                if(*pc++ == &&LabelSetIndex)
                  goto LabelSetIndex;

                if(*pc++ == &&LabelSetArray)
                  goto LabelSetArray;

                if(*pc++ == &&LabelSetField)
                  goto LabelSetField;

                if(*pc++ == &&LabelSetEnv)
                  goto LabelSetEnv;

                if(*pc++ == &&LabelSetGlobal)
                  goto LabelSetGlobal;

                if(*pc++ == &&LabelSetStack)
                  goto LabelSetStack;

                if(*pc++ == &&LabelAccBuiltin)
                  goto LabelAccBuiltin;

                if(*pc++ == &&LabelAccIndex)
                  goto LabelAccIndex;

                if(*pc++ == &&LabelAccArray)
                  goto LabelAccArray;

                if(*pc++ == &&LabelAccField)
                  goto LabelAccField;

                if(*pc++ == &&LabelAccEnv)
                  goto LabelAccEnv;

                if(*pc++ == &&LabelAccGlobal)
                  goto LabelAccGlobal;

                if(*pc++ == &&LabelAccStack)
                  goto LabelAccStack;

                if(*pc++ == &&LabelAccInt)
                  goto LabelAccInt;

                if(*pc++ == &&LabelAccThis)
                  goto LabelAccThis;

                if(*pc++ == &&LabelAccFalse)
                  goto LabelAccFalse;

                if(*pc++ == &&LabelAccTrue)
                  goto LabelAccTrue;

                if(*pc++ == &&LabelAccNull)
                  goto LabelAccNull;

                if(*pc++ == &&end)
                  goto end;

              }

              do
              {

              LabelLte:
                ;
                vm->sp = sp;
                vm->csp = csp;
                return_value_neko_val_compare$696=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                acc = (signed long int)return_value_neko_val_compare$696;
                sp = vm->sp;
                csp = vm->csp;
                tmp_post$697 = sp;
                sp = sp + 1l;
                *tmp_post$697 = (signed long int)0;
                acc = (signed long int)(acc <= (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                *pc++;
                if(*pc++ == &&id_mod_next2)
                  goto id_mod_next2;

                if(*pc++ == &&id_mod_next)
                  goto id_mod_next;

                if(*pc++ == &&div_next)
                  goto div_next;

                if(*pc++ == &&id_mult_next2)
                  goto id_mult_next2;

                if(*pc++ == &&id_mult_next)
                  goto id_mult_next;

                if(*pc++ == &&id_sub_next2)
                  goto id_sub_next2;

                if(*pc++ == &&id_sub_next)
                  goto id_sub_next;

                if(*pc++ == &&add_3)
                  goto add_3;

                if(*pc++ == &&add_2)
                  goto add_2;

                if(*pc++ == &&add_next)
                  goto add_next;

                if(*pc++ == &&do_call)
                  goto LabelCall;

                if(*pc++ == &&LabelLast)
                  goto LabelLast;

                if(*pc++ == &&LabelAccInt32)
                  goto LabelAccInt32;

                if(*pc++ == &&LabelMakeArray2)
                  goto LabelMakeArray2;

                if(*pc++ == &&LabelLoop)
                  goto LabelLoop;

                if(*pc++ == &&LabelTailCall)
                  goto LabelTailCall;

                if(*pc++ == &&LabelPhysCompare)
                  goto LabelPhysCompare;

                if(*pc++ == &&LabelAccIndex1)
                  goto LabelAccIndex1;

                if(*pc++ == &&LabelAccIndex0)
                  goto LabelAccIndex0;

                if(*pc++ == &&LabelAccStack1)
                  goto LabelAccStack1;

                if(*pc++ == &&LabelAccStack0)
                  goto LabelAccStack0;

                if(*pc++ == &&LabelApply)
                  goto LabelApply;

                if(*pc++ == &&LabelJumpTable)
                  goto LabelJumpTable;

                if(*pc++ == &&LabelNew)
                  goto LabelNew;

                if(*pc++ == &&LabelHash)
                  goto LabelHash;

                if(*pc++ == &&LabelCompare)
                  goto LabelCompare;

                if(*pc++ == &&LabelTypeOf)
                  goto LabelTypeOf;

                if(*pc++ == &&LabelNot)
                  goto LabelNot;

              }
              while(*pc++ == &&LabelLte);
              if(*pc++ == &&LabelLt)
                goto LabelLt;

              if(!(*pc++ == &&LabelGte))
              {
                if(!(*pc++ == &&LabelGt))
                {
                  if(*pc++ == &&LabelNeq)
                    goto LabelNeq;

                  if(*pc++ == &&LabelEq)
                    goto LabelEq;

                  if(*pc++ == &&LabelXor)
                    goto LabelXor;

                  if(*pc++ == &&LabelAnd)
                    goto LabelAnd;

                  if(*pc++ == &&LabelOr)
                    goto LabelOr;

                  if(*pc++ == &&LabelUShr)
                    goto LabelUShr;

                  if(*pc++ == &&LabelShr)
                    goto LabelShr;

                  if(*pc++ == &&LabelShl)
                    goto LabelShl;

                  if(*pc++ == &&LabelMod)
                    goto LabelMod;

                  if(*pc++ == &&LabelDiv)
                    goto LabelDiv;

                  if(*pc++ == &&LabelMult)
                    goto LabelMult;

                  if(*pc++ == &&LabelSub)
                    goto LabelSub;

                  if(*pc++ == &&LabelAdd)
                    goto LabelAdd;

                  if(*pc++ == &&LabelIsNotNull)
                    goto LabelIsNotNull;

                  if(*pc++ == &&LabelIsNull)
                    goto LabelIsNull;

                  if(*pc++ == &&LabelBool)
                    goto LabelBool;

                  if(*pc++ == &&LabelMakeArray)
                    goto LabelMakeArray;

                  if(*pc++ == &&LabelMakeEnv)
                    goto LabelMakeEnv;

                  if(*pc++ == &&LabelRet)
                    goto LabelRet;

                  if(*pc++ == &&LabelEndTrap)
                    goto LabelEndTrap;

                  if(*pc++ == &&LabelTrap)
                    goto LabelTrap;

                  if(*pc++ == &&LabelJumpIfNot)
                    goto LabelJumpIfNot;

                  if(*pc++ == &&LabelJumpIf)
                    goto LabelJumpIf;

                  if(*pc++ == &&LabelJump)
                    goto LabelJump;

                  if(*pc++ == &&LabelObjCall)
                    goto LabelObjCall;

                  if(*pc++ == &&LabelCall)
                    goto LabelCall;

                  if(*pc++ == &&LabelPop)
                    goto LabelPop;

                  if(*pc++ == &&LabelPush)
                    goto LabelPush;

                  if(*pc++ == &&LabelSetThis)
                    goto LabelSetThis;

                  if(*pc++ == &&LabelSetIndex)
                    goto LabelSetIndex;

                  if(*pc++ == &&LabelSetArray)
                    goto LabelSetArray;

                  if(*pc++ == &&LabelSetField)
                    goto LabelSetField;

                  if(*pc++ == &&LabelSetEnv)
                    goto LabelSetEnv;

                  if(*pc++ == &&LabelSetGlobal)
                    goto LabelSetGlobal;

                  if(*pc++ == &&LabelSetStack)
                    goto LabelSetStack;

                  if(*pc++ == &&LabelAccBuiltin)
                    goto LabelAccBuiltin;

                  if(*pc++ == &&LabelAccIndex)
                    goto LabelAccIndex;

                  if(*pc++ == &&LabelAccArray)
                    goto LabelAccArray;

                  if(*pc++ == &&LabelAccField)
                    goto LabelAccField;

                  if(*pc++ == &&LabelAccEnv)
                    goto LabelAccEnv;

                  if(*pc++ == &&LabelAccGlobal)
                    goto LabelAccGlobal;

                  if(*pc++ == &&LabelAccStack)
                    goto LabelAccStack;

                  if(*pc++ == &&LabelAccInt)
                    goto LabelAccInt;

                  if(*pc++ == &&LabelAccThis)
                    goto LabelAccThis;

                  if(*pc++ == &&LabelAccFalse)
                    goto LabelAccFalse;

                  if(*pc++ == &&LabelAccTrue)
                    goto LabelAccTrue;

                  if(*pc++ == &&LabelAccNull)
                    goto LabelAccNull;

                  if(*pc++ == &&end)
                    goto end;

                }

                do
                {

                LabelGt:
                  ;
                  vm->sp = sp;
                  vm->csp = csp;
                  return_value_neko_val_compare$698=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                  acc = (signed long int)return_value_neko_val_compare$698;
                  sp = vm->sp;
                  csp = vm->csp;
                  tmp_post$699 = sp;
                  sp = sp + 1l;
                  *tmp_post$699 = (signed long int)0;
                  acc = (signed long int)(acc > (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                  *pc++;
                  if(*pc++ == &&id_mod_next2)
                    goto id_mod_next2;

                  if(*pc++ == &&id_mod_next)
                    goto id_mod_next;

                  if(*pc++ == &&div_next)
                    goto div_next;

                  if(*pc++ == &&id_mult_next2)
                    goto id_mult_next2;

                  if(*pc++ == &&id_mult_next)
                    goto id_mult_next;

                  if(*pc++ == &&id_sub_next2)
                    goto id_sub_next2;

                  if(*pc++ == &&id_sub_next)
                    goto id_sub_next;

                  if(*pc++ == &&add_3)
                    goto add_3;

                  if(*pc++ == &&add_2)
                    goto add_2;

                  if(*pc++ == &&add_next)
                    goto add_next;

                  if(*pc++ == &&do_call)
                    goto LabelCall;

                  if(*pc++ == &&LabelLast)
                    goto LabelLast;

                  if(*pc++ == &&LabelAccInt32)
                    goto LabelAccInt32;

                  if(*pc++ == &&LabelMakeArray2)
                    goto LabelMakeArray2;

                  if(*pc++ == &&LabelLoop)
                    goto LabelLoop;

                  if(*pc++ == &&LabelTailCall)
                    goto LabelTailCall;

                  if(*pc++ == &&LabelPhysCompare)
                    goto LabelPhysCompare;

                  if(*pc++ == &&LabelAccIndex1)
                    goto LabelAccIndex1;

                  if(*pc++ == &&LabelAccIndex0)
                    goto LabelAccIndex0;

                  if(*pc++ == &&LabelAccStack1)
                    goto LabelAccStack1;

                  if(*pc++ == &&LabelAccStack0)
                    goto LabelAccStack0;

                  if(*pc++ == &&LabelApply)
                    goto LabelApply;

                  if(*pc++ == &&LabelJumpTable)
                    goto LabelJumpTable;

                  if(*pc++ == &&LabelNew)
                    goto LabelNew;

                  if(*pc++ == &&LabelHash)
                    goto LabelHash;

                  if(*pc++ == &&LabelCompare)
                    goto LabelCompare;

                  if(*pc++ == &&LabelTypeOf)
                    goto LabelTypeOf;

                  if(*pc++ == &&LabelNot)
                    goto LabelNot;

                  if(*pc++ == &&LabelLte)
                    goto LabelLte;

                  if(*pc++ == &&LabelLt)
                    goto LabelLt;

                  if(*pc++ == &&LabelGte)
                    goto LabelGte;

                }
                while(*pc++ == &&LabelGt);
                if(*pc++ == &&LabelNeq)
                  goto LabelNeq;

                if(*pc++ == &&LabelEq)
                  goto LabelEq;

                if(*pc++ == &&LabelXor)
                  goto LabelXor;

                if(*pc++ == &&LabelAnd)
                  goto LabelAnd;

                if(*pc++ == &&LabelOr)
                  goto LabelOr;

                if(*pc++ == &&LabelUShr)
                  goto LabelUShr;

                if(*pc++ == &&LabelShr)
                  goto LabelShr;

                if(*pc++ == &&LabelShl)
                  goto LabelShl;

                if(*pc++ == &&LabelMod)
                  goto LabelMod;

                if(*pc++ == &&LabelDiv)
                  goto LabelDiv;

                if(*pc++ == &&LabelMult)
                  goto LabelMult;

                if(*pc++ == &&LabelSub)
                  goto LabelSub;

                if(*pc++ == &&LabelAdd)
                  goto LabelAdd;

                if(*pc++ == &&LabelIsNotNull)
                  goto LabelIsNotNull;

                if(*pc++ == &&LabelIsNull)
                  goto LabelIsNull;

                if(*pc++ == &&LabelBool)
                  goto LabelBool;

                if(*pc++ == &&LabelMakeArray)
                  goto LabelMakeArray;

                if(*pc++ == &&LabelMakeEnv)
                  goto LabelMakeEnv;

                if(*pc++ == &&LabelRet)
                  goto LabelRet;

                if(*pc++ == &&LabelEndTrap)
                  goto LabelEndTrap;

                if(*pc++ == &&LabelTrap)
                  goto LabelTrap;

                if(*pc++ == &&LabelJumpIfNot)
                  goto LabelJumpIfNot;

                if(*pc++ == &&LabelJumpIf)
                  goto LabelJumpIf;

                if(*pc++ == &&LabelJump)
                  goto LabelJump;

                if(*pc++ == &&LabelObjCall)
                  goto LabelObjCall;

                if(*pc++ == &&LabelCall)
                  goto LabelCall;

                if(*pc++ == &&LabelPop)
                  goto LabelPop;

                if(*pc++ == &&LabelPush)
                  goto LabelPush;

                if(*pc++ == &&LabelSetThis)
                  goto LabelSetThis;

                if(*pc++ == &&LabelSetIndex)
                  goto LabelSetIndex;

                if(*pc++ == &&LabelSetArray)
                  goto LabelSetArray;

                if(*pc++ == &&LabelSetField)
                  goto LabelSetField;

                if(*pc++ == &&LabelSetEnv)
                  goto LabelSetEnv;

                if(*pc++ == &&LabelSetGlobal)
                  goto LabelSetGlobal;

                if(*pc++ == &&LabelSetStack)
                  goto LabelSetStack;

                if(*pc++ == &&LabelAccBuiltin)
                  goto LabelAccBuiltin;

                if(*pc++ == &&LabelAccIndex)
                  goto LabelAccIndex;

                if(*pc++ == &&LabelAccArray)
                  goto LabelAccArray;

                if(*pc++ == &&LabelAccField)
                  goto LabelAccField;

                if(*pc++ == &&LabelAccEnv)
                  goto LabelAccEnv;

                if(*pc++ == &&LabelAccGlobal)
                  goto LabelAccGlobal;

                if(*pc++ == &&LabelAccStack)
                  goto LabelAccStack;

                if(*pc++ == &&LabelAccInt)
                  goto LabelAccInt;

                if(*pc++ == &&LabelAccThis)
                  goto LabelAccThis;

                if(*pc++ == &&LabelAccFalse)
                  goto LabelAccFalse;

                if(*pc++ == &&LabelAccTrue)
                  goto LabelAccTrue;

                if(*pc++ == &&LabelAccNull)
                  goto LabelAccNull;

                if(*pc++ == &&end)
                  goto end;

              }

              do
              {

              LabelGte:
                ;
                vm->sp = sp;
                vm->csp = csp;
                return_value_neko_val_compare$700=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                acc = (signed long int)return_value_neko_val_compare$700;
                sp = vm->sp;
                csp = vm->csp;
                tmp_post$701 = sp;
                sp = sp + 1l;
                *tmp_post$701 = (signed long int)0;
                acc = (signed long int)(acc >= (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                *pc++;
                if(*pc++ == &&id_mod_next2)
                  goto id_mod_next2;

                if(*pc++ == &&id_mod_next)
                  goto id_mod_next;

                if(*pc++ == &&div_next)
                  goto div_next;

                if(*pc++ == &&id_mult_next2)
                  goto id_mult_next2;

                if(*pc++ == &&id_mult_next)
                  goto id_mult_next;

                if(*pc++ == &&id_sub_next2)
                  goto id_sub_next2;

                if(*pc++ == &&id_sub_next)
                  goto id_sub_next;

                if(*pc++ == &&add_3)
                  goto add_3;

                if(*pc++ == &&add_2)
                  goto add_2;

                if(*pc++ == &&add_next)
                  goto add_next;

                if(*pc++ == &&do_call)
                  goto LabelCall;

                if(*pc++ == &&LabelLast)
                  goto LabelLast;

                if(*pc++ == &&LabelAccInt32)
                  goto LabelAccInt32;

                if(*pc++ == &&LabelMakeArray2)
                  goto LabelMakeArray2;

                if(*pc++ == &&LabelLoop)
                  goto LabelLoop;

                if(*pc++ == &&LabelTailCall)
                  goto LabelTailCall;

                if(*pc++ == &&LabelPhysCompare)
                  goto LabelPhysCompare;

                if(*pc++ == &&LabelAccIndex1)
                  goto LabelAccIndex1;

                if(*pc++ == &&LabelAccIndex0)
                  goto LabelAccIndex0;

                if(*pc++ == &&LabelAccStack1)
                  goto LabelAccStack1;

                if(*pc++ == &&LabelAccStack0)
                  goto LabelAccStack0;

                if(*pc++ == &&LabelApply)
                  goto LabelApply;

                if(*pc++ == &&LabelJumpTable)
                  goto LabelJumpTable;

                if(*pc++ == &&LabelNew)
                  goto LabelNew;

                if(*pc++ == &&LabelHash)
                  goto LabelHash;

                if(*pc++ == &&LabelCompare)
                  goto LabelCompare;

                if(*pc++ == &&LabelTypeOf)
                  goto LabelTypeOf;

                if(*pc++ == &&LabelNot)
                  goto LabelNot;

                if(*pc++ == &&LabelLte)
                  goto LabelLte;

                if(*pc++ == &&LabelLt)
                  goto LabelLt;

              }
              while(*pc++ == &&LabelGte);
              if(*pc++ == &&LabelGt)
                goto LabelGt;

              if(*pc++ == &&LabelNeq)
                goto LabelNeq;

              if(*pc++ == &&LabelEq)
                goto LabelEq;

              if(*pc++ == &&LabelXor)
                goto LabelXor;

              if(*pc++ == &&LabelAnd)
                goto LabelAnd;

              if(*pc++ == &&LabelOr)
                goto LabelOr;

              if(*pc++ == &&LabelUShr)
                goto LabelUShr;

              if(*pc++ == &&LabelShr)
                goto LabelShr;

              if(*pc++ == &&LabelShl)
                goto LabelShl;

              if(*pc++ == &&LabelMod)
                goto LabelMod;

              if(*pc++ == &&LabelDiv)
                goto LabelDiv;

              if(*pc++ == &&LabelMult)
                goto LabelMult;

              if(*pc++ == &&LabelSub)
                goto LabelSub;

              if(*pc++ == &&LabelAdd)
                goto LabelAdd;

              if(*pc++ == &&LabelIsNotNull)
                goto LabelIsNotNull;

              if(*pc++ == &&LabelIsNull)
                goto LabelIsNull;

              if(*pc++ == &&LabelBool)
                goto LabelBool;

              if(*pc++ == &&LabelMakeArray)
                goto LabelMakeArray;

              if(*pc++ == &&LabelMakeEnv)
                goto LabelMakeEnv;

              if(*pc++ == &&LabelRet)
                goto LabelRet;

              if(*pc++ == &&LabelEndTrap)
                goto LabelEndTrap;

              if(*pc++ == &&LabelTrap)
                goto LabelTrap;

              if(*pc++ == &&LabelJumpIfNot)
                goto LabelJumpIfNot;

              if(*pc++ == &&LabelJumpIf)
                goto LabelJumpIf;

              if(*pc++ == &&LabelJump)
                goto LabelJump;

              if(*pc++ == &&LabelObjCall)
                goto LabelObjCall;

              if(*pc++ == &&LabelCall)
                goto LabelCall;

              if(*pc++ == &&LabelPop)
                goto LabelPop;

              if(*pc++ == &&LabelPush)
                goto LabelPush;

              if(*pc++ == &&LabelSetThis)
                goto LabelSetThis;

              if(*pc++ == &&LabelSetIndex)
                goto LabelSetIndex;

              if(*pc++ == &&LabelSetArray)
                goto LabelSetArray;

              if(*pc++ == &&LabelSetField)
                goto LabelSetField;

              if(*pc++ == &&LabelSetEnv)
                goto LabelSetEnv;

              if(*pc++ == &&LabelSetGlobal)
                goto LabelSetGlobal;

              if(*pc++ == &&LabelSetStack)
                goto LabelSetStack;

              if(*pc++ == &&LabelAccBuiltin)
                goto LabelAccBuiltin;

              if(*pc++ == &&LabelAccIndex)
                goto LabelAccIndex;

              if(*pc++ == &&LabelAccArray)
                goto LabelAccArray;

              if(*pc++ == &&LabelAccField)
                goto LabelAccField;

              if(*pc++ == &&LabelAccEnv)
                goto LabelAccEnv;

              if(*pc++ == &&LabelAccGlobal)
                goto LabelAccGlobal;

              if(*pc++ == &&LabelAccStack)
                goto LabelAccStack;

              if(*pc++ == &&LabelAccInt)
                goto LabelAccInt;

              if(*pc++ == &&LabelAccThis)
                goto LabelAccThis;

              if(*pc++ == &&LabelAccFalse)
                goto LabelAccFalse;

              if(*pc++ == &&LabelAccTrue)
                goto LabelAccTrue;

              if(*pc++ == &&LabelAccNull)
                goto LabelAccNull;

              if(*pc++ == &&end)
                goto end;

            }

            do
            {

            LabelTypeOf:
              ;
              if(!((1 & (signed int)acc) == 0))
                tmp_if_expr$702 = (struct _value *)(signed long int)((signed int)1 << 1 | 1);

              else
                tmp_if_expr$702 = NEKO_TYPEOF[(signed long int)((signed int)*((enum anonymous$7 *)acc) & (1 << 4) - 1)];
              acc = (signed long int)tmp_if_expr$702;
              *pc++;
              if(*pc++ == &&id_mod_next2)
                goto id_mod_next2;

              if(*pc++ == &&id_mod_next)
                goto id_mod_next;

              if(*pc++ == &&div_next)
                goto div_next;

              if(*pc++ == &&id_mult_next2)
                goto id_mult_next2;

              if(*pc++ == &&id_mult_next)
                goto id_mult_next;

              if(*pc++ == &&id_sub_next2)
                goto id_sub_next2;

              if(*pc++ == &&id_sub_next)
                goto id_sub_next;

              if(*pc++ == &&add_3)
                goto add_3;

              if(*pc++ == &&add_2)
                goto add_2;

              if(*pc++ == &&add_next)
                goto add_next;

              if(*pc++ == &&do_call)
                goto LabelCall;

              if(*pc++ == &&LabelLast)
                goto LabelLast;

              if(*pc++ == &&LabelAccInt32)
                goto LabelAccInt32;

              if(*pc++ == &&LabelMakeArray2)
                goto LabelMakeArray2;

              if(*pc++ == &&LabelLoop)
                goto LabelLoop;

              if(*pc++ == &&LabelTailCall)
                goto LabelTailCall;

              if(*pc++ == &&LabelPhysCompare)
                goto LabelPhysCompare;

              if(*pc++ == &&LabelAccIndex1)
                goto LabelAccIndex1;

              if(*pc++ == &&LabelAccIndex0)
                goto LabelAccIndex0;

              if(*pc++ == &&LabelAccStack1)
                goto LabelAccStack1;

              if(*pc++ == &&LabelAccStack0)
                goto LabelAccStack0;

              if(*pc++ == &&LabelApply)
                goto LabelApply;

              if(*pc++ == &&LabelJumpTable)
                goto LabelJumpTable;

              if(*pc++ == &&LabelNew)
                goto LabelNew;

              if(*pc++ == &&LabelHash)
                goto LabelHash;

              if(*pc++ == &&LabelCompare)
                goto LabelCompare;

            }
            while(*pc++ == &&LabelTypeOf);
            if(*pc++ == &&LabelNot)
              goto LabelNot;

            if(*pc++ == &&LabelLte)
              goto LabelLte;

            if(*pc++ == &&LabelLt)
              goto LabelLt;

            if(*pc++ == &&LabelGte)
              goto LabelGte;

            if(*pc++ == &&LabelGt)
              goto LabelGt;

            if(*pc++ == &&LabelNeq)
              goto LabelNeq;

            if(*pc++ == &&LabelEq)
              goto LabelEq;

            if(*pc++ == &&LabelXor)
              goto LabelXor;

            if(*pc++ == &&LabelAnd)
              goto LabelAnd;

            if(*pc++ == &&LabelOr)
              goto LabelOr;

            if(*pc++ == &&LabelUShr)
              goto LabelUShr;

            if(*pc++ == &&LabelShr)
              goto LabelShr;

            if(*pc++ == &&LabelShl)
              goto LabelShl;

            if(*pc++ == &&LabelMod)
              goto LabelMod;

            if(*pc++ == &&LabelDiv)
              goto LabelDiv;

            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }

          do
          {

          LabelCompare:
            ;
            vm->sp = sp;
            vm->csp = csp;
            return_value_neko_val_compare$703=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
            acc = (signed long int)return_value_neko_val_compare$703;
            sp = vm->sp;
            csp = vm->csp;
            acc = (signed long int)(acc == (signed long int)0xFE ? val_null : (struct _value *)(signed long int)((signed int)acc << 1 | 1));
            tmp_post$704 = sp;
            sp = sp + 1l;
            *tmp_post$704 = (signed long int)0;
            *pc++;
            if(*pc++ == &&id_mod_next2)
              goto id_mod_next2;

            if(*pc++ == &&id_mod_next)
              goto id_mod_next;

            if(*pc++ == &&div_next)
              goto div_next;

            if(*pc++ == &&id_mult_next2)
              goto id_mult_next2;

            if(*pc++ == &&id_mult_next)
              goto id_mult_next;

            if(*pc++ == &&id_sub_next2)
              goto id_sub_next2;

            if(*pc++ == &&id_sub_next)
              goto id_sub_next;

            if(*pc++ == &&add_3)
              goto add_3;

            if(*pc++ == &&add_2)
              goto add_2;

            if(*pc++ == &&add_next)
              goto add_next;

            if(*pc++ == &&do_call)
              goto LabelCall;

            if(*pc++ == &&LabelLast)
              goto LabelLast;

            if(*pc++ == &&LabelAccInt32)
              goto LabelAccInt32;

            if(*pc++ == &&LabelMakeArray2)
              goto LabelMakeArray2;

            if(*pc++ == &&LabelLoop)
              goto LabelLoop;

            if(*pc++ == &&LabelTailCall)
              goto LabelTailCall;

            if(*pc++ == &&LabelPhysCompare)
              goto LabelPhysCompare;

            if(*pc++ == &&LabelAccIndex1)
              goto LabelAccIndex1;

            if(*pc++ == &&LabelAccIndex0)
              goto LabelAccIndex0;

            if(*pc++ == &&LabelAccStack1)
              goto LabelAccStack1;

            if(*pc++ == &&LabelAccStack0)
              goto LabelAccStack0;

            if(*pc++ == &&LabelApply)
              goto LabelApply;

            if(*pc++ == &&LabelJumpTable)
              goto LabelJumpTable;

            if(*pc++ == &&LabelNew)
              goto LabelNew;

            if(*pc++ == &&LabelHash)
              goto LabelHash;

          }
          while(*pc++ == &&LabelCompare);
          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(*pc++ == &&LabelMod)
            goto LabelMod;

          if(*pc++ == &&LabelDiv)
            goto LabelDiv;

          if(*pc++ == &&LabelMult)
            goto LabelMult;

          if(*pc++ == &&LabelSub)
            goto LabelSub;

          if(*pc++ == &&LabelAdd)
            goto LabelAdd;

          if(*pc++ == &&LabelIsNotNull)
            goto LabelIsNotNull;

          if(*pc++ == &&LabelIsNull)
            goto LabelIsNull;

          if(*pc++ == &&LabelBool)
            goto LabelBool;

          if(*pc++ == &&LabelMakeArray)
            goto LabelMakeArray;

          if(*pc++ == &&LabelMakeEnv)
            goto LabelMakeEnv;

          if(*pc++ == &&LabelRet)
            goto LabelRet;

          if(*pc++ == &&LabelEndTrap)
            goto LabelEndTrap;

          if(*pc++ == &&LabelTrap)
            goto LabelTrap;

          if(*pc++ == &&LabelJumpIfNot)
            goto LabelJumpIfNot;

          if(*pc++ == &&LabelJumpIf)
            goto LabelJumpIf;

          if(*pc++ == &&LabelJump)
            goto LabelJump;

          if(*pc++ == &&LabelObjCall)
            goto LabelObjCall;

          if(*pc++ == &&LabelCall)
            goto LabelCall;

          if(*pc++ == &&LabelPop)
            goto LabelPop;

          if(*pc++ == &&LabelPush)
            goto LabelPush;

          if(*pc++ == &&LabelSetThis)
            goto LabelSetThis;

          if(*pc++ == &&LabelSetIndex)
            goto LabelSetIndex;

          if(*pc++ == &&LabelSetArray)
            goto LabelSetArray;

          if(*pc++ == &&LabelSetField)
            goto LabelSetField;

          if(*pc++ == &&LabelSetEnv)
            goto LabelSetEnv;

          if(*pc++ == &&LabelSetGlobal)
            goto LabelSetGlobal;

          if(*pc++ == &&LabelSetStack)
            goto LabelSetStack;

          if(*pc++ == &&LabelAccBuiltin)
            goto LabelAccBuiltin;

          if(*pc++ == &&LabelAccIndex)
            goto LabelAccIndex;

          if(*pc++ == &&LabelAccArray)
            goto LabelAccArray;

          if(*pc++ == &&LabelAccField)
            goto LabelAccField;

          if(*pc++ == &&LabelAccEnv)
            goto LabelAccEnv;

          if(*pc++ == &&LabelAccGlobal)
            goto LabelAccGlobal;

          if(*pc++ == &&LabelAccStack)
            goto LabelAccStack;

          if(*pc++ == &&LabelAccInt)
            goto LabelAccInt;

          if(*pc++ == &&LabelAccThis)
            goto LabelAccThis;

          if(*pc++ == &&LabelAccFalse)
            goto LabelAccFalse;

          if(*pc++ == &&LabelAccTrue)
            goto LabelAccTrue;

          if(*pc++ == &&LabelAccNull)
            goto LabelAccNull;

          if(*pc++ == &&end)
            goto end;

        }

        do
        {

        LabelPhysCompare:
          ;
          if(!(acc >= *sp))
            tmp_if_expr$705 = (struct _value *)(signed long int)((signed int)1 << 1 | 1);

          else
            tmp_if_expr$705 = *sp < acc ? (struct _value *)(signed long int)((signed int)-1 << 1 | 1) : (struct _value *)(signed long int)((signed int)0 << 1 | 1);
          acc = (signed long int)tmp_if_expr$705;
          tmp_post$706 = sp;
          sp = sp + 1l;
          *tmp_post$706 = (signed long int)0;
          *pc++;
          if(*pc++ == &&id_mod_next2)
            goto id_mod_next2;

          if(*pc++ == &&id_mod_next)
            goto id_mod_next;

          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

        }
        while(*pc++ == &&LabelPhysCompare);
        if(*pc++ == &&LabelAccIndex1)
          goto LabelAccIndex1;

        if(*pc++ == &&LabelAccIndex0)
          goto LabelAccIndex0;

        if(*pc++ == &&LabelAccStack1)
          goto LabelAccStack1;

        if(*pc++ == &&LabelAccStack0)
          goto LabelAccStack0;

        if(*pc++ == &&LabelApply)
          goto LabelApply;

        if(!(*pc++ == &&LabelJumpTable))
        {
          if(!(*pc++ == &&LabelNew))
          {
            if(!(*pc++ == &&LabelHash))
            {
              if(*pc++ == &&LabelCompare)
                goto LabelCompare;

              if(*pc++ == &&LabelTypeOf)
                goto LabelTypeOf;

              if(*pc++ == &&LabelNot)
                goto LabelNot;

              if(*pc++ == &&LabelLte)
                goto LabelLte;

              if(*pc++ == &&LabelLt)
                goto LabelLt;

              if(*pc++ == &&LabelGte)
                goto LabelGte;

              if(*pc++ == &&LabelGt)
                goto LabelGt;

              if(*pc++ == &&LabelNeq)
                goto LabelNeq;

              if(*pc++ == &&LabelEq)
                goto LabelEq;

              if(*pc++ == &&LabelXor)
                goto LabelXor;

              if(*pc++ == &&LabelAnd)
                goto LabelAnd;

              if(*pc++ == &&LabelOr)
                goto LabelOr;

              if(*pc++ == &&LabelUShr)
                goto LabelUShr;

              if(*pc++ == &&LabelShr)
                goto LabelShr;

              if(*pc++ == &&LabelShl)
                goto LabelShl;

              if(*pc++ == &&LabelMod)
                goto LabelMod;

              if(*pc++ == &&LabelDiv)
                goto LabelDiv;

              if(*pc++ == &&LabelMult)
                goto LabelMult;

              if(*pc++ == &&LabelSub)
                goto LabelSub;

              if(*pc++ == &&LabelAdd)
                goto LabelAdd;

              if(*pc++ == &&LabelIsNotNull)
                goto LabelIsNotNull;

              if(*pc++ == &&LabelIsNull)
                goto LabelIsNull;

              if(*pc++ == &&LabelBool)
                goto LabelBool;

              if(*pc++ == &&LabelMakeArray)
                goto LabelMakeArray;

              if(*pc++ == &&LabelMakeEnv)
                goto LabelMakeEnv;

              if(*pc++ == &&LabelRet)
                goto LabelRet;

              if(*pc++ == &&LabelEndTrap)
                goto LabelEndTrap;

              if(*pc++ == &&LabelTrap)
                goto LabelTrap;

              if(*pc++ == &&LabelJumpIfNot)
                goto LabelJumpIfNot;

              if(*pc++ == &&LabelJumpIf)
                goto LabelJumpIf;

              if(*pc++ == &&LabelJump)
                goto LabelJump;

              if(*pc++ == &&LabelObjCall)
                goto LabelObjCall;

              if(*pc++ == &&LabelCall)
                goto LabelCall;

              if(*pc++ == &&LabelPop)
                goto LabelPop;

              if(*pc++ == &&LabelPush)
                goto LabelPush;

              if(*pc++ == &&LabelSetThis)
                goto LabelSetThis;

              if(*pc++ == &&LabelSetIndex)
                goto LabelSetIndex;

              if(*pc++ == &&LabelSetArray)
                goto LabelSetArray;

              if(*pc++ == &&LabelSetField)
                goto LabelSetField;

              if(*pc++ == &&LabelSetEnv)
                goto LabelSetEnv;

              if(*pc++ == &&LabelSetGlobal)
                goto LabelSetGlobal;

              if(*pc++ == &&LabelSetStack)
                goto LabelSetStack;

              if(*pc++ == &&LabelAccBuiltin)
                goto LabelAccBuiltin;

              if(*pc++ == &&LabelAccIndex)
                goto LabelAccIndex;

              if(*pc++ == &&LabelAccArray)
                goto LabelAccArray;

              if(*pc++ == &&LabelAccField)
                goto LabelAccField;

              if(*pc++ == &&LabelAccEnv)
                goto LabelAccEnv;

              if(*pc++ == &&LabelAccGlobal)
                goto LabelAccGlobal;

              if(*pc++ == &&LabelAccStack)
                goto LabelAccStack;

              if(*pc++ == &&LabelAccInt)
                goto LabelAccInt;

              if(*pc++ == &&LabelAccThis)
                goto LabelAccThis;

              if(*pc++ == &&LabelAccFalse)
                goto LabelAccFalse;

              if(*pc++ == &&LabelAccTrue)
                goto LabelAccTrue;

              if(*pc++ == &&LabelAccNull)
                goto LabelAccNull;

              if(*pc++ == &&end)
                goto end;

            }

            do
            {

            LabelHash:
              ;
              if((1 & (signed int)acc) == 0)
                tmp_if_expr$711 = ((signed int)*((enum anonymous$7 *)acc) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$711 = (_Bool)0;
              if(tmp_if_expr$711)
              {
                vm->sp = sp;
                vm->csp = csp;
                signed int return_value_neko_val_id$707;
                return_value_neko_val_id$707=neko_val_id(&((struct anonymous$5 *)acc)->c);
                acc = (signed long int)(struct _value *)(signed long int)((signed int)return_value_neko_val_id$707 << 1 | 1);
              }

              else
              {
                if(csp + 4l >= sp)
                {
                  signed int return_value_neko_stack_expand$709;
                  return_value_neko_stack_expand$709=neko_stack_expand(sp, csp, vm);
                  if(!(return_value_neko_stack_expand$709 == 0))
                  {
                    sp = vm->sp;
                    csp = vm->csp;
                  }

                  else
                  {
                    return_value_neko_alloc_string$708=neko_alloc_string("Stack Overflow");
                    neko_val_throw(return_value_neko_alloc_string$708);
                  }
                }

                csp = csp + 1l;
                *csp = (signed long int)pc;
                csp = csp + 1l;
                *csp = (signed long int)vm->env;
                csp = csp + 1l;
                *csp = (signed long int)vm->vthis;
                csp = csp + 1l;
                *csp = (signed long int)m;
                vm->sp = sp;
                vm->csp = csp;
                struct _value *return_value_neko_alloc_string$710;
                return_value_neko_alloc_string$710=neko_alloc_string("$hash");
                neko_val_throw(return_value_neko_alloc_string$710);
              }
              *pc++;
              if(*pc++ == &&id_mod_next2)
                goto id_mod_next2;

              if(*pc++ == &&id_mod_next)
                goto id_mod_next;

              if(*pc++ == &&div_next)
                goto div_next;

              if(*pc++ == &&id_mult_next2)
                goto id_mult_next2;

              if(*pc++ == &&id_mult_next)
                goto id_mult_next;

              if(*pc++ == &&id_sub_next2)
                goto id_sub_next2;

              if(*pc++ == &&id_sub_next)
                goto id_sub_next;

              if(*pc++ == &&add_3)
                goto add_3;

              if(*pc++ == &&add_2)
                goto add_2;

              if(*pc++ == &&add_next)
                goto add_next;

              if(*pc++ == &&do_call)
                goto LabelCall;

              if(*pc++ == &&LabelLast)
                goto LabelLast;

              if(*pc++ == &&LabelAccInt32)
                goto LabelAccInt32;

              if(*pc++ == &&LabelMakeArray2)
                goto LabelMakeArray2;

              if(*pc++ == &&LabelLoop)
                goto LabelLoop;

              if(*pc++ == &&LabelTailCall)
                goto LabelTailCall;

              if(*pc++ == &&LabelPhysCompare)
                goto LabelPhysCompare;

              if(*pc++ == &&LabelAccIndex1)
                goto LabelAccIndex1;

              if(*pc++ == &&LabelAccIndex0)
                goto LabelAccIndex0;

              if(*pc++ == &&LabelAccStack1)
                goto LabelAccStack1;

              if(*pc++ == &&LabelAccStack0)
                goto LabelAccStack0;

              if(*pc++ == &&LabelApply)
                goto LabelApply;

              if(*pc++ == &&LabelJumpTable)
                goto LabelJumpTable;

              if(*pc++ == &&LabelNew)
                goto LabelNew;

            }
            while(*pc++ == &&LabelHash);
            if(*pc++ == &&LabelCompare)
              goto LabelCompare;

            if(*pc++ == &&LabelTypeOf)
              goto LabelTypeOf;

            if(*pc++ == &&LabelNot)
              goto LabelNot;

            if(*pc++ == &&LabelLte)
              goto LabelLte;

            if(*pc++ == &&LabelLt)
              goto LabelLt;

            if(*pc++ == &&LabelGte)
              goto LabelGte;

            if(*pc++ == &&LabelGt)
              goto LabelGt;

            if(*pc++ == &&LabelNeq)
              goto LabelNeq;

            if(*pc++ == &&LabelEq)
              goto LabelEq;

            if(*pc++ == &&LabelXor)
              goto LabelXor;

            if(*pc++ == &&LabelAnd)
              goto LabelAnd;

            if(*pc++ == &&LabelOr)
              goto LabelOr;

            if(*pc++ == &&LabelUShr)
              goto LabelUShr;

            if(*pc++ == &&LabelShr)
              goto LabelShr;

            if(*pc++ == &&LabelShl)
              goto LabelShl;

            if(*pc++ == &&LabelMod)
              goto LabelMod;

            if(*pc++ == &&LabelDiv)
              goto LabelDiv;

            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }

          do
          {

          LabelNew:
            ;
            vm->sp = sp;
            vm->csp = csp;
            return_value_neko_alloc_object$712=neko_alloc_object((struct _value *)acc);
            acc = (signed long int)return_value_neko_alloc_object$712;
            *pc++;
            if(*pc++ == &&id_mod_next2)
              goto id_mod_next2;

            if(*pc++ == &&id_mod_next)
              goto id_mod_next;

            if(*pc++ == &&div_next)
              goto div_next;

            if(*pc++ == &&id_mult_next2)
              goto id_mult_next2;

            if(*pc++ == &&id_mult_next)
              goto id_mult_next;

            if(*pc++ == &&id_sub_next2)
              goto id_sub_next2;

            if(*pc++ == &&id_sub_next)
              goto id_sub_next;

            if(*pc++ == &&add_3)
              goto add_3;

            if(*pc++ == &&add_2)
              goto add_2;

            if(*pc++ == &&add_next)
              goto add_next;

            if(*pc++ == &&do_call)
              goto LabelCall;

            if(*pc++ == &&LabelLast)
              goto LabelLast;

            if(*pc++ == &&LabelAccInt32)
              goto LabelAccInt32;

            if(*pc++ == &&LabelMakeArray2)
              goto LabelMakeArray2;

            if(*pc++ == &&LabelLoop)
              goto LabelLoop;

            if(*pc++ == &&LabelTailCall)
              goto LabelTailCall;

            if(*pc++ == &&LabelPhysCompare)
              goto LabelPhysCompare;

            if(*pc++ == &&LabelAccIndex1)
              goto LabelAccIndex1;

            if(*pc++ == &&LabelAccIndex0)
              goto LabelAccIndex0;

            if(*pc++ == &&LabelAccStack1)
              goto LabelAccStack1;

            if(*pc++ == &&LabelAccStack0)
              goto LabelAccStack0;

            if(*pc++ == &&LabelApply)
              goto LabelApply;

            if(*pc++ == &&LabelJumpTable)
              goto LabelJumpTable;

          }
          while(*pc++ == &&LabelNew);
          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(*pc++ == &&LabelCompare)
            goto LabelCompare;

          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(*pc++ == &&LabelMod)
            goto LabelMod;

          if(*pc++ == &&LabelDiv)
            goto LabelDiv;

          if(*pc++ == &&LabelMult)
            goto LabelMult;

          if(*pc++ == &&LabelSub)
            goto LabelSub;

          if(*pc++ == &&LabelAdd)
            goto LabelAdd;

          if(*pc++ == &&LabelIsNotNull)
            goto LabelIsNotNull;

          if(*pc++ == &&LabelIsNull)
            goto LabelIsNull;

          if(*pc++ == &&LabelBool)
            goto LabelBool;

          if(*pc++ == &&LabelMakeArray)
            goto LabelMakeArray;

          if(*pc++ == &&LabelMakeEnv)
            goto LabelMakeEnv;

          if(*pc++ == &&LabelRet)
            goto LabelRet;

          if(*pc++ == &&LabelEndTrap)
            goto LabelEndTrap;

          if(*pc++ == &&LabelTrap)
            goto LabelTrap;

          if(*pc++ == &&LabelJumpIfNot)
            goto LabelJumpIfNot;

          if(*pc++ == &&LabelJumpIf)
            goto LabelJumpIf;

          if(*pc++ == &&LabelJump)
            goto LabelJump;

          if(*pc++ == &&LabelObjCall)
            goto LabelObjCall;

          if(*pc++ == &&LabelCall)
            goto LabelCall;

          if(*pc++ == &&LabelPop)
            goto LabelPop;

          if(*pc++ == &&LabelPush)
            goto LabelPush;

          if(*pc++ == &&LabelSetThis)
            goto LabelSetThis;

          if(*pc++ == &&LabelSetIndex)
            goto LabelSetIndex;

          if(*pc++ == &&LabelSetArray)
            goto LabelSetArray;

          if(*pc++ == &&LabelSetField)
            goto LabelSetField;

          if(*pc++ == &&LabelSetEnv)
            goto LabelSetEnv;

          if(*pc++ == &&LabelSetGlobal)
            goto LabelSetGlobal;

          if(*pc++ == &&LabelSetStack)
            goto LabelSetStack;

          if(*pc++ == &&LabelAccBuiltin)
            goto LabelAccBuiltin;

          if(*pc++ == &&LabelAccIndex)
            goto LabelAccIndex;

          if(*pc++ == &&LabelAccArray)
            goto LabelAccArray;

          if(*pc++ == &&LabelAccField)
            goto LabelAccField;

          if(*pc++ == &&LabelAccEnv)
            goto LabelAccEnv;

          if(*pc++ == &&LabelAccGlobal)
            goto LabelAccGlobal;

          if(*pc++ == &&LabelAccStack)
            goto LabelAccStack;

          if(*pc++ == &&LabelAccInt)
            goto LabelAccInt;

          if(*pc++ == &&LabelAccThis)
            goto LabelAccThis;

          if(*pc++ == &&LabelAccFalse)
            goto LabelAccFalse;

          if(*pc++ == &&LabelAccTrue)
            goto LabelAccTrue;

          if(*pc++ == &&LabelAccNull)
            goto LabelAccNull;

          if(*pc++ == &&end)
            goto end;

        }

        do
        {

        LabelJumpTable:
          ;
          if(!((1 & (signed int)acc) == 0))
            tmp_if_expr$713 = (unsigned int)acc < (unsigned int)*pc ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$713 = (_Bool)0;
          if(tmp_if_expr$713)
            pc = pc + acc;

          else
            pc = pc + *pc + (signed long int)1;
          *pc++;
          if(*pc++ == &&id_mod_next2)
            goto id_mod_next2;

          if(*pc++ == &&id_mod_next)
            goto id_mod_next;

          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

          if(*pc++ == &&LabelPhysCompare)
            goto LabelPhysCompare;

          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

        }
        while(*pc++ == &&LabelJumpTable);
        if(*pc++ == &&LabelNew)
          goto LabelNew;

        if(*pc++ == &&LabelHash)
          goto LabelHash;

        if(*pc++ == &&LabelCompare)
          goto LabelCompare;

        if(*pc++ == &&LabelTypeOf)
          goto LabelTypeOf;

        if(*pc++ == &&LabelNot)
          goto LabelNot;

        if(*pc++ == &&LabelLte)
          goto LabelLte;

        if(*pc++ == &&LabelLt)
          goto LabelLt;

        if(*pc++ == &&LabelGte)
          goto LabelGte;

        if(*pc++ == &&LabelGt)
          goto LabelGt;

        if(*pc++ == &&LabelNeq)
          goto LabelNeq;

        if(*pc++ == &&LabelEq)
          goto LabelEq;

        if(*pc++ == &&LabelXor)
          goto LabelXor;

        if(*pc++ == &&LabelAnd)
          goto LabelAnd;

        if(*pc++ == &&LabelOr)
          goto LabelOr;

        if(*pc++ == &&LabelUShr)
          goto LabelUShr;

        if(*pc++ == &&LabelShr)
          goto LabelShr;

        if(*pc++ == &&LabelShl)
          goto LabelShl;

        if(*pc++ == &&LabelMod)
          goto LabelMod;

        if(*pc++ == &&LabelDiv)
          goto LabelDiv;

        if(*pc++ == &&LabelMult)
          goto LabelMult;

        if(*pc++ == &&LabelSub)
          goto LabelSub;

        if(*pc++ == &&LabelAdd)
          goto LabelAdd;

        if(*pc++ == &&LabelIsNotNull)
          goto LabelIsNotNull;

        if(*pc++ == &&LabelIsNull)
          goto LabelIsNull;

        if(*pc++ == &&LabelBool)
          goto LabelBool;

        if(*pc++ == &&LabelMakeArray)
          goto LabelMakeArray;

        if(*pc++ == &&LabelMakeEnv)
          goto LabelMakeEnv;

        if(*pc++ == &&LabelRet)
          goto LabelRet;

        if(*pc++ == &&LabelEndTrap)
          goto LabelEndTrap;

        if(*pc++ == &&LabelTrap)
          goto LabelTrap;

        if(*pc++ == &&LabelJumpIfNot)
          goto LabelJumpIfNot;

        if(*pc++ == &&LabelJumpIf)
          goto LabelJumpIf;

        if(*pc++ == &&LabelJump)
          goto LabelJump;

        if(*pc++ == &&LabelObjCall)
          goto LabelObjCall;

        if(*pc++ == &&LabelCall)
          goto LabelCall;

        if(*pc++ == &&LabelPop)
          goto LabelPop;

        if(*pc++ == &&LabelPush)
          goto LabelPush;

        if(*pc++ == &&LabelSetThis)
          goto LabelSetThis;

        if(*pc++ == &&LabelSetIndex)
          goto LabelSetIndex;

        if(*pc++ == &&LabelSetArray)
          goto LabelSetArray;

        if(*pc++ == &&LabelSetField)
          goto LabelSetField;

        if(*pc++ == &&LabelSetEnv)
          goto LabelSetEnv;

        if(*pc++ == &&LabelSetGlobal)
          goto LabelSetGlobal;

        if(*pc++ == &&LabelSetStack)
          goto LabelSetStack;

        if(*pc++ == &&LabelAccBuiltin)
          goto LabelAccBuiltin;

        if(*pc++ == &&LabelAccIndex)
          goto LabelAccIndex;

        if(*pc++ == &&LabelAccArray)
          goto LabelAccArray;

        if(*pc++ == &&LabelAccField)
          goto LabelAccField;

        if(*pc++ == &&LabelAccEnv)
          goto LabelAccEnv;

        if(*pc++ == &&LabelAccGlobal)
          goto LabelAccGlobal;

        if(*pc++ == &&LabelAccStack)
          goto LabelAccStack;

        if(*pc++ == &&LabelAccInt)
          goto LabelAccInt;

        if(*pc++ == &&LabelAccThis)
          goto LabelAccThis;

        if(*pc++ == &&LabelAccFalse)
          goto LabelAccFalse;

        if(*pc++ == &&LabelAccTrue)
          goto LabelAccTrue;

        if(*pc++ == &&LabelAccNull)
          goto LabelAccNull;

        if(*pc++ == &&end)
          goto end;

      }

      do
      {

      LabelLoop:
        ;
        *pc++;
        if(*pc++ == &&id_mod_next2)
          goto id_mod_next2;

        if(*pc++ == &&id_mod_next)
          goto id_mod_next;

        if(*pc++ == &&div_next)
          goto div_next;

        if(*pc++ == &&id_mult_next2)
          goto id_mult_next2;

        if(*pc++ == &&id_mult_next)
          goto id_mult_next;

        if(*pc++ == &&id_sub_next2)
          goto id_sub_next2;

        if(*pc++ == &&id_sub_next)
          goto id_sub_next;

        if(*pc++ == &&add_3)
          goto add_3;

        if(*pc++ == &&add_2)
          goto add_2;

        if(*pc++ == &&add_next)
          goto add_next;

        if(*pc++ == &&do_call)
          goto LabelCall;

        if(*pc++ == &&LabelLast)
          goto LabelLast;

        if(*pc++ == &&LabelAccInt32)
          goto LabelAccInt32;

        if(*pc++ == &&LabelMakeArray2)
          goto LabelMakeArray2;

      }
      while(*pc++ == &&LabelLoop);
      if(*pc++ == &&LabelTailCall)
        goto LabelTailCall;

      if(*pc++ == &&LabelPhysCompare)
        goto LabelPhysCompare;

      if(*pc++ == &&LabelAccIndex1)
        goto LabelAccIndex1;

      if(*pc++ == &&LabelAccIndex0)
        goto LabelAccIndex0;

      if(*pc++ == &&LabelAccStack1)
        goto LabelAccStack1;

      if(*pc++ == &&LabelAccStack0)
        goto LabelAccStack0;

      if(*pc++ == &&LabelApply)
        goto LabelApply;

      if(*pc++ == &&LabelJumpTable)
        goto LabelJumpTable;

      if(*pc++ == &&LabelNew)
        goto LabelNew;

      if(*pc++ == &&LabelHash)
        goto LabelHash;

      if(*pc++ == &&LabelCompare)
        goto LabelCompare;

      if(*pc++ == &&LabelTypeOf)
        goto LabelTypeOf;

      if(*pc++ == &&LabelNot)
        goto LabelNot;

      if(*pc++ == &&LabelLte)
        goto LabelLte;

      if(*pc++ == &&LabelLt)
        goto LabelLt;

      if(*pc++ == &&LabelGte)
        goto LabelGte;

      if(*pc++ == &&LabelGt)
        goto LabelGt;

      if(*pc++ == &&LabelNeq)
        goto LabelNeq;

      if(*pc++ == &&LabelEq)
        goto LabelEq;

      if(*pc++ == &&LabelXor)
        goto LabelXor;

      if(*pc++ == &&LabelAnd)
        goto LabelAnd;

      if(*pc++ == &&LabelOr)
        goto LabelOr;

      if(*pc++ == &&LabelUShr)
        goto LabelUShr;

      if(*pc++ == &&LabelShr)
        goto LabelShr;

      if(*pc++ == &&LabelShl)
        goto LabelShl;

      if(*pc++ == &&LabelMod)
        goto LabelMod;

      if(*pc++ == &&LabelDiv)
        goto LabelDiv;

      if(*pc++ == &&LabelMult)
        goto LabelMult;

      if(*pc++ == &&LabelSub)
        goto LabelSub;

      if(*pc++ == &&LabelAdd)
        goto LabelAdd;

      if(*pc++ == &&LabelIsNotNull)
        goto LabelIsNotNull;

      if(*pc++ == &&LabelIsNull)
        goto LabelIsNull;

      if(*pc++ == &&LabelBool)
        goto LabelBool;

      if(*pc++ == &&LabelMakeArray)
        goto LabelMakeArray;

      if(*pc++ == &&LabelMakeEnv)
        goto LabelMakeEnv;

      if(*pc++ == &&LabelRet)
        goto LabelRet;

      if(*pc++ == &&LabelEndTrap)
        goto LabelEndTrap;

      if(*pc++ == &&LabelTrap)
        goto LabelTrap;

      if(*pc++ == &&LabelJumpIfNot)
        goto LabelJumpIfNot;

      if(*pc++ == &&LabelJumpIf)
        goto LabelJumpIf;

      if(*pc++ == &&LabelJump)
        goto LabelJump;

      if(*pc++ == &&LabelObjCall)
        goto LabelObjCall;

      if(*pc++ == &&LabelCall)
        goto LabelCall;

      if(*pc++ == &&LabelPop)
        goto LabelPop;

      if(*pc++ == &&LabelPush)
        goto LabelPush;

      if(*pc++ == &&LabelSetThis)
        goto LabelSetThis;

      if(*pc++ == &&LabelSetIndex)
        goto LabelSetIndex;

      if(*pc++ == &&LabelSetArray)
        goto LabelSetArray;

      if(*pc++ == &&LabelSetField)
        goto LabelSetField;

      if(*pc++ == &&LabelSetEnv)
        goto LabelSetEnv;

      if(*pc++ == &&LabelSetGlobal)
        goto LabelSetGlobal;

      if(*pc++ == &&LabelSetStack)
        goto LabelSetStack;

      if(*pc++ == &&LabelAccBuiltin)
        goto LabelAccBuiltin;

      if(*pc++ == &&LabelAccIndex)
        goto LabelAccIndex;

      if(*pc++ == &&LabelAccArray)
        goto LabelAccArray;

      if(*pc++ == &&LabelAccField)
        goto LabelAccField;

      if(*pc++ == &&LabelAccEnv)
        goto LabelAccEnv;

      if(*pc++ == &&LabelAccGlobal)
        goto LabelAccGlobal;

      if(*pc++ == &&LabelAccStack)
        goto LabelAccStack;

      if(*pc++ == &&LabelAccInt)
        goto LabelAccInt;

      if(*pc++ == &&LabelAccThis)
        goto LabelAccThis;

      if(*pc++ == &&LabelAccFalse)
        goto LabelAccFalse;

      if(*pc++ == &&LabelAccTrue)
        goto LabelAccTrue;

      if(*pc++ == &&LabelAccNull)
        goto LabelAccNull;

      if(*pc++ == &&end)
        goto end;

    }


  LabelLast:
    ;
    goto end;

  end:
    ;
    vm->sp = sp;
    vm->csp = csp;
    return acc;
  }
}

// neko_is_big_endian
// file vm/module.c line 100
signed int neko_is_big_endian()
{
  return 0;
}

// neko_kind_share
// file vm/alloc.c line 430
void neko_kind_share(struct anonymous **k, const char *name)
{
  struct _klist *l = *kind_names;
  while(!(l == ((struct _klist *)NULL)))
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(l->name, name);
    if(return_value_strcmp$1 == 0)
    {
      *k = l->k;
      goto __CPROVER_DUMP_L4;
    }

    l = l->next;
  }
  char *return_value_neko_alloc$2;
  return_value_neko_alloc$2=neko_alloc((unsigned int)sizeof(struct _klist) /*24ul*/ );
  l = (struct _klist *)return_value_neko_alloc$2;
  l->k = *k;
  l->name = name;
  l->next = *kind_names;
  *kind_names = l;

__CPROVER_DUMP_L4:
  ;
}

// neko_local_get
// file vm/neko.h line 439
void * neko_local_get(struct _mt_local *l)
{
  if(l == ((struct _mt_local *)NULL))
    return (void *)0;

  else
  {
    void *return_value_pthread_getspecific$1;
    return_value_pthread_getspecific$1=pthread_getspecific(l->key);
    return return_value_pthread_getspecific$1;
  }
}

// neko_local_set
// file vm/neko.h line 440
void neko_local_set(struct _mt_local *l, void *v)
{
  pthread_setspecific(l->key, v);
}

// neko_lock_acquire
// file vm/neko.h line 444
void neko_lock_acquire(struct _mt_lock *l)
{
  pthread_mutex_lock(&l->lock);
}

// neko_lock_release
// file vm/neko.h line 446
void neko_lock_release(struct _mt_lock *l)
{
  pthread_mutex_unlock(&l->lock);
}

// neko_lock_try
// file vm/threads.c line 327
signed int neko_lock_try(struct _mt_lock *l)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&l->lock);
  return (signed int)(return_value_pthread_mutex_trylock$1 == 0);
}

// neko_module_jit
// file vm/jit_x86.c line 2782
void neko_module_jit(struct _neko_module *m)
{
  ;
}

// neko_process_trap
// file vm/interp.c line 588
void neko_process_trap(struct _neko_vm *vm)
{
  signed long int *sp;
  signed long int *trap;
  signed long int *tmp_post$1;
  if(!(vm->trap == 0l))
  {
    trap = vm->spmax - vm->trap;
    sp = vm->spmin + (signed long int)((signed int)(signed long int)trap[(signed long int)0] >> 1);
    vm->exc_stack=neko_flush_stack(vm->csp, sp, vm->exc_stack);
    vm->csp = sp;
    vm->vthis = (struct _value *)trap[(signed long int)1];
    vm->env = (struct _value *)trap[(signed long int)2];
    vm->jit_val = (void *)(signed long int *)(trap[(signed long int)3] & (signed long int)~1);
    sp = trap + (signed long int)6;
    vm->trap = (signed long int)((signed int)(signed long int)trap[(signed long int)5] >> 1);
    for( ; !(vm->sp >= sp); *tmp_post$1 = (signed long int)0)
    {
      tmp_post$1 = vm->sp;
      vm->sp = vm->sp + 1l;
    }
  }

}

// neko_read_module
// file vm/neko_mod.h line 59
struct _neko_module * neko_read_module(signed int (*r)(void *, void *, signed int), void *p, struct _value *loader)
{
  unsigned int i;
  unsigned int itmp;
  unsigned char t;
  unsigned short int stmp;
  char *tmp = (char *)(void *)0;
  unsigned char version = (unsigned char)1;
  struct _neko_module *m;
  char *return_value_neko_alloc$1;
  return_value_neko_alloc$1=neko_alloc((unsigned int)sizeof(struct _neko_module) /*96ul*/ );
  m = (struct _neko_module *)return_value_neko_alloc$1;
  struct _neko_vm *vm;
  void *return_value_neko_local_get$2;
  return_value_neko_local_get$2=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get$2;
  read_long(r, p, &itmp);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  unsigned int tmp_if_expr$7;
  signed int return_value_read_string$12;
  signed int return_value_1;
  signed int return_value_read_string$13;
  double return_value_atof$14;
  void *return_value_read_debug_infos$15;
  signed int return_value_2;
  unsigned int tmp_post$18;
  unsigned int tmp_post$19;
  unsigned int tmp_post$20;
  unsigned int tmp_post$21;
  unsigned int tmp_post$22;
  unsigned int tmp_post$23;
  unsigned int tmp_post$24;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$26;
  struct _value *return_value_get_builtin$27;
  struct _value *return_value_neko_alloc_string$28;
  struct _value *return_value_neko_alloc_string$29;
  _Bool tmp_if_expr$30;
  signed int return_value_neko_check_stack$32;
  signed int tmp_if_expr$35;
  _Bool tmp_if_expr$33;
  signed int return_value_neko_check_stack$34;
  if(!(itmp == 1330333006u))
  {
    free((void *)tmp);
    return (struct _neko_module *)(void *)0;
  }

  else
  {
    read_long(r, p, &m->nglobals);
    read_long(r, p, &m->nfields);
    read_long(r, p, &m->codesize);
    if(m->nglobals >= 65536u)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = m->nfields < (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = m->nfields > (unsigned int)0xFFFF ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = m->codesize < (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = m->codesize > (unsigned int)0xFFFFF ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      free((void *)tmp);
      return (struct _neko_module *)(void *)0;
    }

    else
    {
      if(1u + m->codesize >= 257u)
        tmp_if_expr$7 = m->codesize + (unsigned int)1;

      else
        tmp_if_expr$7 = (unsigned int)0x100;
      void *return_value_malloc$8;
      return_value_malloc$8=malloc(sizeof(char) /*1ul*/  * (unsigned long int)tmp_if_expr$7);
      tmp = (char *)return_value_malloc$8;
      m->jit = (void *)0;
      m->jit_gc = (struct _value *)(void *)0;
      m->dbgtbl = val_null;
      m->dbgidxs = (struct _neko_debug *)(void *)0;
      char *return_value_neko_alloc$9;
      return_value_neko_alloc$9=neko_alloc((unsigned int)((unsigned long int)m->nglobals * sizeof(struct _value *) /*8ul*/ ));
      m->globals = (struct _value **)return_value_neko_alloc$9;
      char *return_value_neko_alloc$10;
      return_value_neko_alloc$10=neko_alloc((unsigned int)(sizeof(struct _value **) /*8ul*/  * (unsigned long int)m->nfields));
      m->fields = (struct _value **)return_value_neko_alloc$10;
      m->loader = loader;
      m->exports=neko_alloc_object((struct _value *)(void *)0);
      if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
        vm->fstats(vm, "neko_read_module_data", 1);

      struct _value *return_value_neko_alloc_abstract$11;
      return_value_neko_alloc_abstract$11=neko_alloc_abstract(neko_kind_module, (void *)m);
      neko_alloc_field(m->exports, neko_id_module, return_value_neko_alloc_abstract$11);
      i = (unsigned int)0;
      if(!(i >= m->nglobals))
      {
        signed int return_value;
        return_value=r(p, (void *)&t, 1);
        if(return_value == -1)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        if((signed int)t == 1)
        {
          return_value_read_string$12=read_string(r, p, tmp);
          if(return_value_read_string$12 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i] = val_null;
          read_long(r, p, &itmp);
          if((16777215u & itmp) >= m->codesize)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i]=neko_alloc_module_function((void *)m, (signed long int)(itmp & (unsigned int)0xFFFFFF), (signed int)(itmp >> 24));
          read_short(r, p, &stmp);
          m->globals[(signed long int)i]=neko_alloc_empty_string((unsigned int)stmp);
          return_value_1=r(p, (void *)&((struct anonymous$5 *)m->globals[(signed long int)i])->c, (signed int)stmp);
          if(return_value_1 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          return_value_read_string$13=read_string(r, p, tmp);
          if(return_value_read_string$13 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          return_value_atof$14=atof(tmp);
          m->globals[(signed long int)i]=neko_alloc_float(return_value_atof$14);
          return_value_read_debug_infos$15=read_debug_infos(r, p, tmp, m);
          if(return_value_read_debug_infos$15 == NULL)
          {
            tmp = (char *)(void *)0;
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i] = val_null;
          return_value_2=r(p, (void *)&version, 1);
          if(return_value_2 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i] = val_null;
        }

        free((void *)tmp);
        return (struct _neko_module *)(void *)0;
        i = i + 1u;
      }

      i = (unsigned int)0;
      for( ; !(i >= m->nfields); i = i + 1u)
      {
        signed int return_value_read_string$16;
        return_value_read_string$16=read_string(r, p, tmp);
        if(return_value_read_string$16 == -1)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        m->fields[(signed long int)i]=neko_alloc_string(tmp);
      }
      if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
      {
        vm->fstats(vm, "neko_read_module_data", 0);
        vm->fstats(vm, "neko_read_module_code", 1);
      }

      char *return_value_neko_alloc_private$17;
      return_value_neko_alloc_private$17=neko_alloc_private((unsigned int)(sizeof(signed long int) /*8ul*/  * (unsigned long int)(m->codesize + (unsigned int)1)));
      m->code = (signed long int *)return_value_neko_alloc_private$17;
      i = (unsigned int)0;
      if(!(i >= m->codesize))
      {
        signed int return_value_3;
        return_value_3=r(p, (void *)&t, 1);
        if(return_value_3 == -1)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        tmp[(signed long int)i] = (char)1;
        if((3 & (signed int)t) == 0)
        {
          tmp_post$18 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post$18] = (signed long int)((signed int)t >> 2);
          tmp_post$19 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post$19] = (signed long int)((signed int)t >> 3);
          tmp[(signed long int)i] = (char)0;
          tmp_post$20 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post$20] = (signed long int)((signed int)t >> 2 & 1);
          tmp_post$21 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post$21] = (signed long int)((signed int)t >> 2);
          if((signed int)t == 2)
          {
            signed int return_value_4;
            return_value_4=r(p, (void *)&t, 1);
            if(return_value_4 == -1)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i - (unsigned int)1)] = (signed long int)t;
          }

          else
          {
            signed int return_value_5;
            return_value_5=r(p, (void *)&t, 1);
            if(return_value_5 == -1)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            tmp[(signed long int)i] = (char)0;
            tmp_post$22 = i;
            i = i + 1u;
            m->code[(signed long int)tmp_post$22] = (signed long int)t;
          }
          tmp_post$23 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post$23] = (signed long int)((signed int)t >> 2);
          read_long(r, p, &itmp);
          tmp[(signed long int)i] = (char)0;
          tmp_post$24 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post$24] = (signed long int)(signed int)itmp;
        }

      }

      tmp[(signed long int)i] = (char)1;
      m->code[(signed long int)i] = (signed long int)67;
      if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
      {
        vm->fstats(vm, "neko_read_module_code", 0);
        vm->fstats(vm, "neko_read_module_check", 1);
      }

      i = (unsigned int)0;
      for( ; !(i >= m->codesize); i = i + 1u)
      {
        signed int c = (signed int)m->code[(signed long int)i];
        itmp = (unsigned int)m->code[(signed long int)(i + (unsigned int)1)];
        if(c >= 67)
          tmp_if_expr$25 = (_Bool)1;

        else
          tmp_if_expr$25 = (signed int)tmp[(signed long int)(i + (unsigned int)1)] == parameter_table[(signed long int)c] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$25)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        switch(m->code[(signed long int)i])
        {
          case (signed long int)6:

          case (signed long int)13:
          {
            if(itmp >= m->nglobals)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)(m->globals + (signed long int)itmp);
            break;
          }
          case (signed long int)23:

          case (signed long int)24:

          case (signed long int)25:

          case (signed long int)26:
          {
            itmp = itmp + i;
            if(!(m->codesize >= itmp))
              tmp_if_expr$26 = (_Bool)1;

            else
              tmp_if_expr$26 = !(tmp[(signed long int)itmp] != 0) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$26)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)(m->code + (signed long int)itmp);
            break;
          }
          case (signed long int)4:
          {
            if(!((1073741824u + (unsigned int)(signed int)itmp & 0x80000000) == 0u))
              m->code[(signed long int)i] = (signed long int)66;

            else
              m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)(struct _value *)(signed long int)((signed int)itmp << 1 | 1);
            break;
          }
          case (signed long int)10:
          {
            m->code[(signed long int)(i + (unsigned int)1)] = m->code[(signed long int)(i + (unsigned int)1)] + (signed long int)2;
            break;
          }
          case (signed long int)5:
          {
            m->code[(signed long int)(i + (unsigned int)1)] = m->code[(signed long int)(i + (unsigned int)1)] + (signed long int)2;
            itmp = (unsigned int)m->code[(signed long int)(i + (unsigned int)1)];
          }
          case (signed long int)12:
          {
            if(!((signed int)itmp >= 0))
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)28:

          case (signed long int)20:

          case (signed long int)7:

          case (signed long int)14:
          {
            if(!((signed int)itmp >= 0))
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)11:
          {
            signed int f = (signed int)(signed long int)itmp;
            if(f == id_loader)
              m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)loader;

            else
              if(f == id_exports)
                m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)m->exports;

              else
              {
                return_value_get_builtin$27=get_builtin(m, f);
                m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)return_value_get_builtin$27;
              }
            break;
          }
          case (signed long int)21:

          case (signed long int)22:
          {
            if(itmp >= 6u)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)63:
          {
            if((7u & itmp) >= 6u)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)57:
          {
            if(itmp == 0u || itmp >= 5u)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)29:
          {
            if(itmp >= 256u)
            {
              return_value_neko_alloc_string$28=neko_alloc_string("Too much big environment");
              _neko_failure(return_value_neko_alloc_string$28, "vm/module.c", 537);
            }

            break;
          }
          case (signed long int)30:
          {
            if(itmp >= 65537u)
            {
              return_value_neko_alloc_string$29=neko_alloc_string("Too much big array");
              _neko_failure(return_value_neko_alloc_string$29, "vm/module.c", 541);
            }

            if((signed int)version >= 2)
              m->code[(signed long int)i] = (signed long int)65;

            break;
          }
          case (signed long int)56:
          {
            if(itmp >= 513u)
              tmp_if_expr$30 = (_Bool)1;

            else
              tmp_if_expr$30 = i + (unsigned int)1 + itmp * (unsigned int)2 >= m->codesize ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$30)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i + (unsigned int)1)] = m->code[(signed long int)(i + (unsigned int)1)] << 1;
          }
        }
        if(tmp[(signed long int)(1u + i)] == 0)
          i = i + 1u;

      }
      unsigned char *neko_read_module$$1$$9$$stmp;
      void *return_value_malloc$31;
      return_value_malloc$31=malloc((unsigned long int)(m->codesize + (unsigned int)1));
      neko_read_module$$1$$9$$stmp = (unsigned char *)return_value_malloc$31;
      unsigned int prev = (unsigned int)0;
      memset((void *)neko_read_module$$1$$9$$stmp, (signed int)(unsigned char)-1, (unsigned long int)(m->codesize + (unsigned int)1));
      if(vm->trusted_code == 0)
      {
        return_value_neko_check_stack$32=neko_check_stack(m, neko_read_module$$1$$9$$stmp, (unsigned int)0, 0, 0);
        if(!(return_value_neko_check_stack$32 == 0))
          goto __CPROVER_DUMP_L89;

        free((void *)neko_read_module$$1$$9$$stmp);
        free((void *)tmp);
        return (struct _neko_module *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L89:
        ;
        i = (unsigned int)0;
        for( ; !(i >= m->nglobals); i = i + 1u)
        {
          struct anonymous$8 *neko_read_module$$1$$9$$2$$1$$f = (struct anonymous$8 *)m->globals[(signed long int)i];
          if(!((1 & (signed int)neko_read_module$$1$$9$$2$$1$$f) == 0))
            tmp_if_expr$35 = VAL_INT;

          else
            tmp_if_expr$35 = (signed int)*((enum anonymous$7 *)neko_read_module$$1$$9$$2$$1$$f) & (1 << 4) - 1;
          if(tmp_if_expr$35 == VAL_FUNCTION)
          {
            itmp = (unsigned int)(signed long int)neko_read_module$$1$$9$$2$$1$$f->addr;
            if(itmp >= m->codesize)
              tmp_if_expr$33 = (_Bool)1;

            else
              tmp_if_expr$33 = !(tmp[(signed long int)itmp] != 0) ? (_Bool)1 : (_Bool)0;
            if(!(itmp >= prev) || tmp_if_expr$33)
            {
              free((void *)neko_read_module$$1$$9$$stmp);
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            if(vm->trusted_code == 0)
            {
              return_value_neko_check_stack$34=neko_check_stack(m, neko_read_module$$1$$9$$stmp, itmp, neko_read_module$$1$$9$$2$$1$$f->nargs, neko_read_module$$1$$9$$2$$1$$f->nargs);
              if(return_value_neko_check_stack$34 == 0)
              {
                free((void *)neko_read_module$$1$$9$$stmp);
                free((void *)tmp);
                return (struct _neko_module *)(void *)0;
              }

            }

            neko_read_module$$1$$9$$2$$1$$f->addr = (void *)(m->code + (signed long int)itmp);
            prev = itmp;
          }

        }
        free((void *)neko_read_module$$1$$9$$stmp);
        free((void *)tmp);
        if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
          vm->fstats(vm, "neko_read_module_check", 0);

        if(!(vm->run_jit == 0))
        {
          if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
            vm->fstats(vm, "neko_read_module_jit", 1);

          neko_module_jit(m);
          if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
            vm->fstats(vm, "neko_read_module_jit", 0);

        }

        signed long int *jtbl;
        jtbl=neko_get_ttable();
        if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
          vm->fstats(vm, "neko_read_module_thread", 1);

        i = (unsigned int)0;
        for( ; m->codesize >= i; i = i + 1u)
        {
          signed long int neko_read_module$$1$$11$$1$$1$$c = m->code[(signed long int)i];
          m->code[(signed long int)i] = jtbl[neko_read_module$$1$$11$$1$$1$$c];
          i = i + (unsigned int)parameter_table[neko_read_module$$1$$11$$1$$1$$c];
        }
        if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
          vm->fstats(vm, "neko_read_module_thread", 0);

        return m;
      }
    }
  }
}

// neko_select_file
// file vm/load.c line 138
struct _value * neko_select_file(struct _value *path, const char *file, const char *ext)
{
  struct stat s;
  struct _value *ff;
  struct _buffer *b;
  b=neko_alloc_buffer(file);
  neko_buffer_append(b, ext);
  ff=neko_buffer_to_string(b);
  signed int return_value_stat$2;
  return_value_stat$2=stat(&((struct anonymous$5 *)ff)->c, &s);
  if(return_value_stat$2 == 0)
  {
    char *p;
    p=strchr(file, 47);
    if(p == ((char *)NULL))
      p=strchr(file, 92);

    if(!(p == ((char *)NULL)))
      return ff;

    b=neko_alloc_buffer("./");
    neko_buffer_append(b, file);
    neko_buffer_append(b, ext);
    struct _value *return_value_neko_buffer_to_string$1;
    return_value_neko_buffer_to_string$1=neko_buffer_to_string(b);
    return return_value_neko_buffer_to_string$1;
  }

  while((1 & (signed int)path) == 0)
  {
    if(!((15 & (signed int)*((enum anonymous$7 *)path)) == VAL_ARRAY))
      break;

    if(!((signed int)*((enum anonymous$7 *)path) >> 4 == 2))
      break;

    struct _value *neko_select_file$$1$$2$$p = (&((struct anonymous$4 *)path)->ptr)[(signed long int)0];
    struct _buffer *neko_select_file$$1$$2$$b;
    neko_select_file$$1$$2$$b=neko_alloc_buffer((const char *)(void *)0);
    path = (&((struct anonymous$4 *)path)->ptr)[(signed long int)1];
    neko_val_buffer(neko_select_file$$1$$2$$b, neko_select_file$$1$$2$$p);
    neko_val_buffer(neko_select_file$$1$$2$$b, ff);
    neko_select_file$$1$$2$$p=neko_buffer_to_string(neko_select_file$$1$$2$$b);
    signed int return_value_stat$3;
    return_value_stat$3=stat(&((struct anonymous$5 *)neko_select_file$$1$$2$$p)->c, &s);
    if(return_value_stat$3 == 0)
      return neko_select_file$$1$$2$$p;

  }
  return ff;
}

// neko_set_stack_base
// file vm/alloc.c line 426
void neko_set_stack_base(void *s)
{
  ;
}

// neko_setup_trap
// file vm/interp.c line 575
void neko_setup_trap(struct _neko_vm *vm)
{
  vm->sp = vm->sp - (signed long int)6;
  signed int return_value_neko_stack_expand$2;
  struct _value *return_value_neko_alloc_string$1;
  if(vm->csp >= vm->sp)
  {
    return_value_neko_stack_expand$2=neko_stack_expand(vm->sp, vm->csp, vm);
    if(return_value_neko_stack_expand$2 == 0)
    {
      return_value_neko_alloc_string$1=neko_alloc_string("Stack Overflow");
      neko_val_throw(return_value_neko_alloc_string$1);
    }

  }

  vm->sp[(signed long int)0] = (signed long int)(struct _value *)(signed long int)((signed int)(signed long int)(vm->csp - vm->spmin) << 1 | 1);
  vm->sp[(signed long int)1] = (signed long int)vm->vthis;
  vm->sp[(signed long int)2] = (signed long int)vm->env;
  vm->sp[(signed long int)3] = (signed long int)vm->jit_val | (signed long int)1;
  vm->sp[(signed long int)4] = (signed long int)val_null;
  vm->sp[(signed long int)5] = (signed long int)(struct _value *)(signed long int)((signed int)(signed long int)vm->trap << 1 | 1);
  vm->trap = vm->spmax - vm->sp;
}

// neko_stack_expand
// file vm/others.c line 348
signed int neko_stack_expand(signed long int *sp, signed long int *csp, struct _neko_vm *vm)
{
  signed int i;
  signed int size = (signed int)((unsigned long int)((signed long int)vm->spmax - (signed long int)vm->spmin) / sizeof(signed long int) /*8ul*/  << 1);
  signed long int *nsp;
  if(size >= 262145)
  {
    vm->sp = sp;
    vm->csp = csp;
    return 0;
  }

  else
  {
    char *return_value_neko_alloc$1;
    return_value_neko_alloc$1=neko_alloc((unsigned int)((unsigned long int)size * sizeof(signed long int) /*8ul*/ ));
    nsp = (signed long int *)return_value_neko_alloc$1;
    i = (signed int)((unsigned long int)((signed long int)(csp + (signed long int)1) - (signed long int)vm->spmin) / sizeof(signed long int) /*8ul*/ );
    memcpy((void *)nsp, (const void *)vm->spmin, sizeof(signed long int) /*8ul*/  * (unsigned long int)i);
    vm->csp = (nsp + (signed long int)i) - (signed long int)1;
    i = (signed int)((unsigned long int)((signed long int)vm->spmax - (signed long int)sp) / sizeof(signed long int) /*8ul*/ );
    memcpy((void *)((nsp + (signed long int)size) - (signed long int)i), (const void *)sp, sizeof(signed long int) /*8ul*/  * (unsigned long int)i);
    vm->sp = (nsp + (signed long int)size) - (signed long int)i;
    vm->spmin = nsp;
    vm->spmax = nsp + (signed long int)size;
    return 1;
  }
}

// neko_stats_build
// file vm/stats.c line 183
struct _value * neko_stats_build(struct _neko_vm *vm)
{
  struct _value *v = val_null;
  struct _statinfos *s = list;
  _Bool tmp_if_expr$2;
  signed int return_value_memcmp$1;
  while(!(s == ((struct _statinfos *)NULL)))
  {
    struct _statinfos *s2 = s->next;
    struct _statinfos *prev = s;
    while(!(s2 == ((struct _statinfos *)NULL)))
    {
      if(s2->ksize == s->ksize)
      {
        return_value_memcmp$1=memcmp((const void *)s->kind, (const void *)s2->kind, (unsigned long int)s->ksize);
        tmp_if_expr$2 = return_value_memcmp$1 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        s->nerrors = s->nerrors + s2->nerrors;
        s->ncalls = s->ncalls + s2->ncalls;
        s->totaltime = s->totaltime + s2->totaltime;
        s->subtime = s->subtime + s2->subtime;
        prev->next = s2->next;
        free((void *)s2);
        s2 = prev->next;
      }

      else
      {
        prev = s2;
        s2 = s2->next;
      }
    }
    s = s->next;
  }
  list=sort(list);
  s = list;
  while(!(s == ((struct _statinfos *)NULL)))
  {
    struct _value *tmp;
    tmp=neko_alloc_array((unsigned int)6);
    (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)0]=neko_alloc_string(s->kind);
    (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)s->totaltime << 1 | 1);
    (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)2] = (struct _value *)(signed long int)((signed int)(s->totaltime - s->subtime) << 1 | 1);
    (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)3] = (struct _value *)(signed long int)((signed int)s->ncalls << 1 | 1);
    (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)4] = (struct _value *)(signed long int)((signed int)s->nerrors << 1 | 1);
    (&((struct anonymous$4 *)tmp)->ptr)[(signed long int)5] = v;
    v = tmp;
    s = s->next;
  }
  return v;
}

// neko_stats_measure
// file vm/stats.c line 79
void neko_stats_measure(struct _neko_vm *vm, const char *kind, signed int start)
{
  signed int ksize;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(kind);
  ksize = (signed int)return_value_strlen$1;
  struct _statinfos *s;
  signed int return_value_memcmp$2;
  signed int return_value_memcmp$4;
  if(!(start == 0))
  {
    signed int time;
    time=precise_timer();
    s = list;
    while(!(s == ((struct _statinfos *)NULL)))
    {
      if(ksize == s->ksize)
      {
        if(s->starttime == 0)
        {
          return_value_memcmp$2=memcmp((const void *)kind, (const void *)s->kind, (unsigned long int)ksize);
          if(return_value_memcmp$2 == 0)
            break;

        }

      }

      s = s->next;
    }
    if(s == ((struct _statinfos *)NULL))
    {
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct _statinfos) /*48ul*/ );
      s = (struct _statinfos *)return_value_malloc$3;
      s->kind=strdup(kind);
      s->ksize = ksize;
      s->ncalls = 0;
      s->nerrors = 0;
      s->totaltime = 0;
      s->subtime = 0;
      s->next = list;
      list = s;
    }

    s->ncalls = s->ncalls + 1;
    s->stack = stack;
    stack = s;
    s->starttime = time;
  }

  else
  {
    s = stack;
    while(!(s == ((struct _statinfos *)NULL)))
    {
      struct _statinfos *next;
      if(ksize == s->ksize)
      {
        return_value_memcmp$4=memcmp((const void *)kind, (const void *)s->kind, (unsigned long int)ksize);
        if(return_value_memcmp$4 == 0)
          break;

      }

      next = s->stack;
      s->nerrors = s->nerrors + 1;
      s->starttime = 0;
      s = next;
    }
    if(!(s == ((struct _statinfos *)NULL)))
    {
      signed int delta;
      signed int return_value_precise_timer$5;
      return_value_precise_timer$5=precise_timer();
      delta = return_value_precise_timer$5 - s->starttime;
      s->totaltime = s->totaltime + delta;
      stack = s->stack;
      if(!(stack == ((struct _statinfos *)NULL)))
        stack->subtime = stack->subtime + delta;

      s->starttime = 0;
    }

    else
      stack = (struct _statinfos *)(void *)0;
  }
}

// neko_string_reader
// file vm/module.c line 621
signed int neko_string_reader(void *p, void *buf, signed int size)
{
  struct anonymous$20 *sp = (struct anonymous$20 *)p;
  signed int delta;
  signed int tmp_if_expr$1;
  if(sp->len >= size)
    tmp_if_expr$1 = size;

  else
    tmp_if_expr$1 = sp->len;
  delta = tmp_if_expr$1;
  memcpy(buf, (const void *)sp->p, (unsigned long int)delta);
  sp->p = sp->p + (signed long int)delta;
  sp->len = sp->len - delta;
  return delta;
}

// neko_thread_blocking
// file vm/threads.c line 181
void neko_thread_blocking(void (*f)(void *), void *p)
{
  struct _value *return_value_neko_alloc_string$4;
  static signed int (*end)() = (signed int (*)())(void *)0;
  static signed int (*start)() = (signed int (*)())(void *)0;
  static void (*do_blocking)(void (*)(void *), void *) = (void (*)(void (*)(void *), void *))(void *)0;
  if(!(do_blocking == ((void (*)(void (*)(void *), void *))NULL)))
    do_blocking(f, p);

  else
    if(!(start == ((signed int (*)())NULL)))
    {
      start();
      f(p);
      end();
    }

    else
    {
      void *neko_thread_blocking$$1$$2$$self;
      neko_thread_blocking$$1$$2$$self=GC_dlopen((const char *)(void *)0, 0);
      void *return_value_dlsym$1;
      return_value_dlsym$1=dlsym(neko_thread_blocking$$1$$2$$self, "GC_do_blocking");
      do_blocking = (void (*)(void (*)(void *), void *))return_value_dlsym$1;
      if(do_blocking == ((void (*)(void (*)(void *), void *))NULL))
      {
        void *return_value_dlsym$2;
        return_value_dlsym$2=dlsym(neko_thread_blocking$$1$$2$$self, "GC_start_blocking");
        start = (signed int (*)())return_value_dlsym$2;
        void *return_value_dlsym$3;
        return_value_dlsym$3=dlsym(neko_thread_blocking$$1$$2$$self, "GC_end_blocking");
        end = (signed int (*)())return_value_dlsym$3;
        if(end == ((signed int (*)())NULL) || start == ((signed int (*)())NULL))
        {
          return_value_neko_alloc_string$4=neko_alloc_string("Could not init GC blocking API");
          neko_val_throw(return_value_neko_alloc_string$4);
        }

      }

      neko_thread_blocking(f, p);
    }
}

// neko_thread_create
// file vm/threads.c line 128
signed int neko_thread_create(void (*init)(void *), void (*main)(void *), void *param, void **handle)
{
  struct anonymous$23 p;
  p.init = init;
  p.main = main;
  p.param = param;
  union pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, 1);
  pthread_mutex_init(&p.lock, (const union anonymous$21 *)(void *)0);
  pthread_mutex_lock(&p.lock);
  signed int return_value_GC_pthread_create$1;
  return_value_GC_pthread_create$1=GC_pthread_create((unsigned long int *)handle, &attr, ThreadMain, (void *)&p);
  if(!(return_value_GC_pthread_create$1 == 0))
  {
    pthread_attr_destroy(&attr);
    pthread_mutex_destroy(&p.lock);
    return 0;
  }

  else
  {
    pthread_mutex_lock(&p.lock);
    pthread_attr_destroy(&attr);
    pthread_mutex_destroy(&p.lock);
    return 1;
  }
}

// neko_thread_register
// file vm/threads.c line 211
signed int neko_thread_register(signed int t)
{
  static signed int (*get_sb)(char (*)[64l]) = (signed int (*)(char (*)[64l]))(void *)0;
  static signed int (*my_thread)(char (*)[64l]) = (signed int (*)(char (*)[64l]))(void *)0;
  static signed int (*unreg_my_thread)() = (signed int (*)())(void *)0;
  if(t == 0 && !(unreg_my_thread == ((signed int (*)())NULL)))
  {
    signed int return_value;
    return_value=unreg_my_thread();
    return (signed int)(return_value == 0);
  }

  else
    if(!(my_thread == ((signed int (*)(char (*)[64l]))NULL)))
    {
      char sb[64l];
      signed int r;
      signed int return_value_1;
      return_value_1=get_sb(&sb);
      if(!(return_value_1 == 0))
        return 0;

      r=my_thread(&sb);
      return (signed int)(r == 0 || r == 1);
    }

    else
    {
      void *neko_thread_register$$1$$3$$self;
      neko_thread_register$$1$$3$$self=GC_dlopen((const char *)(void *)0, 0);
      void *return_value_dlsym$1;
      return_value_dlsym$1=dlsym(neko_thread_register$$1$$3$$self, "GC_register_my_thread");
      my_thread = (signed int (*)(char (*)[64l]))return_value_dlsym$1;
      void *return_value_dlsym$2;
      return_value_dlsym$2=dlsym(neko_thread_register$$1$$3$$self, "GC_get_stack_base");
      get_sb = (signed int (*)(char (*)[64l]))return_value_dlsym$2;
      void *return_value_dlsym$3;
      return_value_dlsym$3=dlsym(neko_thread_register$$1$$3$$self, "GC_unregister_my_thread");
      unreg_my_thread = (signed int (*)())return_value_dlsym$3;
      if(my_thread == ((signed int (*)(char (*)[64l]))NULL))
        my_thread = do_nothing;

      if(get_sb == ((signed int (*)(char (*)[64l]))NULL))
        get_sb = do_nothing;

      if(unreg_my_thread == ((signed int (*)())NULL))
        unreg_my_thread = (signed int (*)())do_nothing;

      signed int return_value_neko_thread_register$4;
      return_value_neko_thread_register$4=neko_thread_register(t);
      return return_value_neko_thread_register$4;
    }
}

// neko_val_buffer
// file vm/neko.h line 425
void neko_val_buffer(struct _buffer *b, struct _value *v)
{
  val_buffer_rec(b, v, (struct vlist *)(void *)0);
}

// neko_val_call0
// file vm/callback.c line 145
struct _value * neko_val_call0(struct _value *f)
{
  struct _value *return_value_neko_val_callN$1;
  return_value_neko_val_callN$1=neko_val_callN(f, (struct _value **)(void *)0, 0);
  return return_value_neko_val_callN$1;
}

// neko_val_call1
// file vm/neko.h line 404
struct _value * neko_val_call1(struct _value *f, struct _value *v)
{
  struct _value *return_value_neko_val_callN$1;
  return_value_neko_val_callN$1=neko_val_callN(f, &v, 1);
  return return_value_neko_val_callN$1;
}

// neko_val_call2
// file vm/neko.h line 405
struct _value * neko_val_call2(struct _value *f, struct _value *v1, struct _value *v2)
{
  struct _value *args[2l] = { v1, v2 };
  struct _value *return_value_neko_val_callN$1;
  return_value_neko_val_callN$1=neko_val_callN(f, args, 2);
  return return_value_neko_val_callN$1;
}

// neko_val_call3
// file vm/callback.c line 158
struct _value * neko_val_call3(struct _value *f, struct _value *arg1, struct _value *arg2, struct _value *arg3)
{
  struct _value *args[3l] = { arg1, arg2, arg3 };
  struct _value *return_value_neko_val_callN$1;
  return_value_neko_val_callN$1=neko_val_callN(f, args, 3);
  return return_value_neko_val_callN$1;
}

// neko_val_callEx
// file vm/neko.h line 412
struct _value * neko_val_callEx(struct _value *vthis, struct _value *f, struct _value **args, signed int nargs, struct _value **exc)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get$1;
  struct _value *old_this = vm->vthis;
  struct _value *old_env = vm->env;
  struct _value *ret = val_null;
  struct __jmp_buf_tag oldjmp[1l];
  if(!(vthis == ((struct _value *)NULL)))
    vm->vthis = vthis;

  if(!(exc == ((struct _value **)NULL)))
  {
    memcpy((void *)&oldjmp, (const void *)&vm->start, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
    signed int return_value__setjmp$2;
    return_value__setjmp$2=_setjmp(vm->start);
    if(!(return_value__setjmp$2 == 0))
    {
      *exc = vm->vthis;
      neko_process_trap(vm);
      vm->vthis = old_this;
      vm->env = old_env;
      memcpy((void *)&vm->start, (const void *)&oldjmp, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
      return val_null;
    }

    neko_setup_trap(vm);
  }

  struct _value *return_value_neko_alloc_string$3;
  if(!((unsigned long int)&vm >= (unsigned long int)vm->c_stack_max))
  {
    return_value_neko_alloc_string$3=neko_alloc_string("C Stack Overflow");
    neko_val_throw(return_value_neko_alloc_string$3);
  }

  struct _value *return_value_neko_alloc_string$4;
  if(!((1 & (signed int)f) == 0))
  {
    return_value_neko_alloc_string$4=neko_alloc_string("Invalid call");
    neko_val_throw(return_value_neko_alloc_string$4);
  }

  struct _value *return_value_neko_alloc_string$5;
  struct _value *return_value;
  struct _value *return_value_neko_alloc_string$6;
  _Bool tmp_if_expr$9;
  signed int return_value_neko_stack_expand$8;
  struct _value *return_value_neko_alloc_string$10;
  struct _value *return_value_neko_alloc_string$11;
  if((signed int)*((enum anonymous$7 *)f) == VAL_PRIMITIVE)
  {
    vm->env = ((struct anonymous$8 *)f)->env;
    if(nargs == ((struct anonymous$8 *)f)->nargs)
    {
      if(nargs >= 6)
      {
        return_value_neko_alloc_string$5=neko_alloc_string("Too many arguments for a call");
        _neko_failure(return_value_neko_alloc_string$5, "vm/callback.c", 72);
      }

      switch(nargs)
      {
        case 0:
          ret=((struct _value * (*)())((struct anonymous$8 *)f)->addr)();
        case 1:
          ret=((struct _value * (*)(struct _value *))((struct anonymous$8 *)f)->addr)(args[(signed long int)0]);
        case 2:
          ret=((struct _value * (*)(struct _value *, struct _value *))((struct anonymous$8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1]);
        case 3:
          ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *))((struct anonymous$8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1], args[(signed long int)2]);
        case 4:
          ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *, struct _value *))((struct anonymous$8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1], args[(signed long int)2], args[(signed long int)3]);
        case 5:
          ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *, struct _value *, struct _value *))((struct anonymous$8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1], args[(signed long int)2], args[(signed long int)3], args[(signed long int)4]);
      }
    }

    else
      if(((struct anonymous$8 *)f)->nargs == -1)
      {
        return_value=((struct _value * (*)(struct _value **, signed int))((struct anonymous$8 *)f)->addr)(args, nargs);
        ret = (struct _value *)return_value;
      }

      else
      {
        return_value_neko_alloc_string$6=neko_alloc_string("Invalid call");
        neko_val_throw(return_value_neko_alloc_string$6);
      }
    if(ret == ((struct _value *)NULL))
      neko_val_throw((struct _value *)((struct anonymous$8 *)f)->module);

  }

  else
    if((15 & (signed int)*((enum anonymous$7 *)f)) == VAL_FUNCTION)
    {
      if(nargs == ((struct anonymous$8 *)f)->nargs)
      {
        signed int n;
        if(vm->csp + 4l >= vm->sp + -((signed long int)nargs))
        {
          return_value_neko_stack_expand$8=neko_stack_expand(vm->sp, vm->csp, vm);
          tmp_if_expr$9 = !(return_value_neko_stack_expand$8 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
        {
          if(!(exc == ((struct _value **)NULL)))
          {
            neko_process_trap(vm);
            memcpy((void *)&vm->start, (const void *)&oldjmp, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
          }

          struct _value *return_value_neko_alloc_string$7;
          return_value_neko_alloc_string$7=neko_alloc_string("Stack Overflow");
          _neko_failure(return_value_neko_alloc_string$7, "vm/callback.c", 107);
        }

        else
        {
          n = 0;
          for( ; !(n >= nargs); n = n + 1)
          {
            vm->sp = vm->sp - 1l;
            *vm->sp = (signed long int)args[(signed long int)n];
          }
          vm->env = ((struct anonymous$8 *)f)->env;
          if((signed int)*((enum anonymous$7 *)f) == VAL_FUNCTION)
          {
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)callback_return;
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)0;
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)0;
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)0;
            ret=neko_interp(vm, ((struct anonymous$8 *)f)->module, (signed long int)val_null, (signed long int *)((struct anonymous$8 *)f)->addr);
          }

          else
          {
            struct _neko_module *m = (struct _neko_module *)((struct anonymous$8 *)f)->module;
            ret=((struct _value * (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, ((struct anonymous$8 *)f)->addr, val_null, m);
          }
        }
      }

      else
      {
        return_value_neko_alloc_string$10=neko_alloc_string("Invalid call");
        neko_val_throw(return_value_neko_alloc_string$10);
      }
    }

    else
    {
      return_value_neko_alloc_string$11=neko_alloc_string("Invalid call");
      neko_val_throw(return_value_neko_alloc_string$11);
    }
  if(!(exc == ((struct _value **)NULL)))
  {
    neko_process_trap(vm);
    memcpy((void *)&vm->start, (const void *)&oldjmp, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
  }

  vm->vthis = old_this;
  vm->env = old_env;
  return ret;
}

// neko_val_callN
// file vm/neko.h line 407
struct _value * neko_val_callN(struct _value *f, struct _value **args, signed int nargs)
{
  struct _value *return_value_neko_val_callEx$1;
  return_value_neko_val_callEx$1=neko_val_callEx((struct _value *)(void *)0, f, args, nargs, (struct _value **)(void *)0);
  return return_value_neko_val_callEx$1;
}

// neko_val_compare
// file vm/neko.h line 427
signed int neko_val_compare(struct _value *a, struct _value *b)
{
  char tmp_buf[32l];
  signed int tmp_if_expr$1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr$1 = VAL_INT;

  else
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)a) & (1 << 4) - 1;
  signed int tmp_if_expr$2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr$2 = VAL_INT;

  else
    tmp_if_expr$2 = (signed int)*((enum anonymous$7 *)b) & (1 << 4) - 1;
  signed int return_value_icmp$3;
  signed int return_value_icmp$4;
  signed int return_value_icmp$5;
  signed int return_value_icmp$6;
  signed int return_value_fcmp$7;
  signed int return_value_fcmp$8;
  signed int return_value_sprintf$9;
  signed int return_value_scmp$10;
  signed int return_value_sprintf$11;
  signed int return_value_scmp$12;
  signed int return_value_fcmp$13;
  signed int return_value_fcmp$14;
  signed int return_value_fcmp$15;
  signed int return_value_sprintf$16;
  signed int return_value_scmp$17;
  signed int return_value_sprintf$18;
  signed int return_value_scmp$19;
  signed int return_value_sprintf$20;
  signed int return_value_scmp$21;
  signed int return_value_sprintf$22;
  signed int return_value_scmp$23;
  signed int return_value_scmp$24;
  signed int return_value_scmp$25;
  signed int return_value_scmp$26;
  if(!((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 65535))
  {
    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 2303)
      goto __CPROVER_DUMP_L6;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 65288)
      goto __CPROVER_DUMP_L7;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 2056)
      goto __CPROVER_DUMP_L8;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 65281)
      goto __CPROVER_DUMP_L9;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 2049)
      goto __CPROVER_DUMP_L10;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 65283)
      goto __CPROVER_DUMP_L11;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 2051)
      goto __CPROVER_DUMP_L12;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 511)
      goto __CPROVER_DUMP_L13;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 264)
      goto __CPROVER_DUMP_L14;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 257)
      goto __CPROVER_DUMP_L15;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 259)
      goto __CPROVER_DUMP_L16;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 1023)
      goto __CPROVER_DUMP_L17;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 776)
      goto __CPROVER_DUMP_L18;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 769)
      goto __CPROVER_DUMP_L19;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 770)
      goto __CPROVER_DUMP_L20;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 515)
      goto __CPROVER_DUMP_L21;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 771)
      goto __CPROVER_DUMP_L22;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 514)
      goto __CPROVER_DUMP_L23;

    if((tmp_if_expr$1 << 8 | tmp_if_expr$2) == 1028)
      goto __CPROVER_DUMP_L24;

  }

  else
  {
    return_value_icmp$3=icmp((signed int)(signed long int)a >> 1, (signed int)(signed long int)b >> 1);
    return return_value_icmp$3;

  __CPROVER_DUMP_L6:
    ;
    return_value_icmp$4=icmp(((struct anonymous$26 *)a)->i, (signed int)(signed long int)b >> 1);
    return return_value_icmp$4;

  __CPROVER_DUMP_L7:
    ;
    return_value_icmp$5=icmp((signed int)(signed long int)a >> 1, ((struct anonymous$26 *)b)->i);
    return return_value_icmp$5;

  __CPROVER_DUMP_L8:
    ;
    return_value_icmp$6=icmp(((struct anonymous$26 *)a)->i, ((struct anonymous$26 *)b)->i);
    return return_value_icmp$6;

  __CPROVER_DUMP_L9:
    ;
    return_value_fcmp$7=fcmp((double)((signed int)(signed long int)a >> 1), ((struct anonymous$25 *)b)->f);
    return return_value_fcmp$7;

  __CPROVER_DUMP_L10:
    ;
    return_value_fcmp$8=fcmp((double)((struct anonymous$26 *)a)->i, ((struct anonymous$25 *)b)->f);
    return return_value_fcmp$8;

  __CPROVER_DUMP_L11:
    ;
    return_value_sprintf$9=sprintf(tmp_buf, "%d", (signed int)(signed long int)a >> 1);
    return_value_scmp$10=scmp(tmp_buf, return_value_sprintf$9, &((struct anonymous$5 *)b)->c, (signed int)*((enum anonymous$7 *)b) >> 4);
    return return_value_scmp$10;

  __CPROVER_DUMP_L12:
    ;
    return_value_sprintf$11=sprintf(tmp_buf, "%d", ((struct anonymous$26 *)a)->i);
    return_value_scmp$12=scmp(tmp_buf, return_value_sprintf$11, &((struct anonymous$5 *)b)->c, (signed int)*((enum anonymous$7 *)b) >> 4);
    return return_value_scmp$12;

  __CPROVER_DUMP_L13:
    ;
    return_value_fcmp$13=fcmp(((struct anonymous$25 *)a)->f, (double)((signed int)(signed long int)b >> 1));
    return return_value_fcmp$13;

  __CPROVER_DUMP_L14:
    ;
    return_value_fcmp$14=fcmp(((struct anonymous$25 *)a)->f, (double)((struct anonymous$26 *)b)->i);
    return return_value_fcmp$14;

  __CPROVER_DUMP_L15:
    ;
    return_value_fcmp$15=fcmp(((struct anonymous$25 *)a)->f, ((struct anonymous$25 *)b)->f);
    return return_value_fcmp$15;

  __CPROVER_DUMP_L16:
    ;
    return_value_sprintf$16=sprintf(tmp_buf, "%.15g", ((struct anonymous$25 *)a)->f);
    return_value_scmp$17=scmp(tmp_buf, return_value_sprintf$16, &((struct anonymous$5 *)b)->c, (signed int)*((enum anonymous$7 *)b) >> 4);
    return return_value_scmp$17;

  __CPROVER_DUMP_L17:
    ;
    return_value_sprintf$18=sprintf(tmp_buf, "%d", (signed int)(signed long int)b >> 1);
    return_value_scmp$19=scmp(&((struct anonymous$5 *)a)->c, (signed int)*((enum anonymous$7 *)a) >> 4, tmp_buf, return_value_sprintf$18);
    return return_value_scmp$19;

  __CPROVER_DUMP_L18:
    ;
    return_value_sprintf$20=sprintf(tmp_buf, "%d", ((struct anonymous$26 *)b)->i);
    return_value_scmp$21=scmp(&((struct anonymous$5 *)a)->c, (signed int)*((enum anonymous$7 *)a) >> 4, tmp_buf, return_value_sprintf$20);
    return return_value_scmp$21;

  __CPROVER_DUMP_L19:
    ;
    return_value_sprintf$22=sprintf(tmp_buf, "%.15g", ((struct anonymous$25 *)b)->f);
    return_value_scmp$23=scmp(&((struct anonymous$5 *)a)->c, (signed int)*((enum anonymous$7 *)a) >> 4, tmp_buf, return_value_sprintf$22);
    return return_value_scmp$23;

  __CPROVER_DUMP_L20:
    ;
    return_value_scmp$24=scmp(&((struct anonymous$5 *)a)->c, (signed int)*((enum anonymous$7 *)a) >> 4, b == val_true ? "true" : "false", b == val_true ? 4 : 5);
    return return_value_scmp$24;

  __CPROVER_DUMP_L21:
    ;
    return_value_scmp$25=scmp(a == val_true ? "true" : "false", a == val_true ? 4 : 5, &((struct anonymous$5 *)b)->c, (signed int)*((enum anonymous$7 *)b) >> 4);
    return return_value_scmp$25;

  __CPROVER_DUMP_L22:
    ;
    return_value_scmp$26=scmp(&((struct anonymous$5 *)a)->c, (signed int)*((enum anonymous$7 *)a) >> 4, &((struct anonymous$5 *)b)->c, (signed int)*((enum anonymous$7 *)b) >> 4);
    return return_value_scmp$26;

  __CPROVER_DUMP_L23:
    ;
    return a == b ? 0 : (a == val_true ? 1 : -1);

  __CPROVER_DUMP_L24:
    ;
    if(a == b)
      return 0;

    struct _value *tmp;
    tmp=neko_val_field(a, id_compare);
    if(tmp == val_null)
      return 0xFE;

    a=neko_val_callEx(a, tmp, &b, 1, (struct _value **)(void *)0);
    if(!((1 & (signed int)a) == 0))
      return (signed int)(signed long int)a >> 1;

    return 0xFE;
  }
  if(a == b)
    return 0;

  else
    return 0xFE;
}

// neko_val_field
// file vm/neko.h line 394
struct _value * neko_val_field(struct _value *_o, signed int id)
{
  struct _value **f;
  struct _vobject *o = (struct _vobject *)_o;
  do
  {
    f=otable_find$link2(&o->table, id);
    if(!(f == ((struct _value **)NULL)))
      return *f;

    o = o->proto;
  }
  while(!(o == ((struct _vobject *)NULL)));
  return val_null;
}

// neko_val_field_name
// file vm/neko.h line 398
struct _value * neko_val_field_name(signed int id)
{
  struct _value *return_value_otable_get$1;
  return_value_otable_get$1=otable_get(&neko_fields[(signed long int)(id & 63)], id);
  return return_value_otable_get$1;
}

// neko_val_gc
// file vm/alloc.c line 348
void neko_val_gc(struct _value *v, void (*f)(struct _value *))
{
  _Bool tmp_if_expr$2;
  if((1 & (signed int)v) == 0)
    tmp_if_expr$2 = (signed int)*((enum anonymous$7 *)v) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  struct _value *return_value_neko_alloc_string$1;
  if(!tmp_if_expr$2)
  {
    return_value_neko_alloc_string$1=neko_alloc_string("val_gc");
    _neko_failure(return_value_neko_alloc_string$1, "vm/alloc.c", 350);
  }

  if(!(f == ((void (*)(struct _value *))NULL)))
    GC_register_finalizer_no_order((void *)v, (void (*)(void *, void *))__on_finalize, (void *)f, ((void (**)(void *, void *))NULL), ((void **)NULL));

  else
    GC_register_finalizer_no_order((void *)v, (void (*)(void *, void *))(void *)0, (void *)0, ((void (**)(void *, void *))NULL), ((void **)NULL));
}

// neko_val_hash
// file vm/neko.h line 432
signed int neko_val_hash(struct _value *v)
{
  signed int h = 0;
  hash_rec(v, &h, (struct vlist *)(void *)0);
  return (signed int)((unsigned int)h & (unsigned int)0x3FFFFFFF);
}

// neko_val_id
// file vm/neko.h line 393
signed int neko_val_id(const char *name)
{
  struct _objtable *t;
  struct _value *fdata;
  signed int f;
  struct _value *acc = (struct _value *)(signed long int)((signed int)0 << 1 | 1);
  const char *oname = name;
  for( ; !(*name == 0); name = name + 1l)
    acc = (struct _value *)(signed long int)((signed int)(223 * ((signed int)(signed long int)acc >> 1) + (signed int)*((unsigned char *)name)) << 1 | 1);
  f = (signed int)(signed long int)acc >> 1;
  t = &neko_fields[(signed long int)(f & 63)];
  fdata=otable_get(t, f);
  if(fdata == val_null)
  {
    signed int min;
    signed int max;
    signed int mid;
    signed int cid;
    struct anonymous$3 *c;
    neko_lock_acquire(neko_fields_lock);
    min = 0;
    max = t->count;
    c = t->cells;
    while(!(min >= max))
    {
      mid = min + max >> 1;
      cid = (c + (signed long int)mid)->id;
      if(!(cid >= f))
        min = mid + 1;

      else
        if(!(f >= cid))
          max = mid;

        else
        {
          fdata = (c + (signed long int)mid)->v;
          break;
        }
    }
    if(fdata == val_null)
    {
      struct anonymous$3 *c2;
      char *return_value_neko_alloc$1;
      return_value_neko_alloc$1=neko_alloc((unsigned int)(sizeof(struct anonymous$3) /*16ul*/  * (unsigned long int)(t->count + 1)));
      c2 = (struct anonymous$3 *)return_value_neko_alloc$1;
      mid = min + max >> 1;
      min = 0;
      for( ; !(min >= mid); min = min + 1)
        c2[(signed long int)min] = c[(signed long int)min];
      (c2 + (signed long int)min)->id = f;
      (c2 + (signed long int)min)->v=neko_copy_string(oname, name - oname);
      max = t->count;
      for( ; !(min >= max); min = min + 1)
        c2[(signed long int)(min + 1)] = c[(signed long int)min];
      t->cells = c2;
      t->count = t->count + 1;
    }

    neko_lock_release(neko_fields_lock);
  }

  signed int return_value_scmp$3;
  if(!(fdata == val_null))
  {
    return_value_scmp$3=scmp(&((struct anonymous$5 *)fdata)->c, (signed int)*((enum anonymous$7 *)fdata) >> 4, oname, (signed int)(name - oname));
    if(!(return_value_scmp$3 == 0))
    {
      struct _buffer *b;
      b=neko_alloc_buffer("Field conflict between ");
      neko_val_buffer(b, fdata);
      neko_buffer_append(b, " and ");
      neko_buffer_append(b, oname);
      struct _value *return_value_neko_buffer_to_string$2;
      return_value_neko_buffer_to_string$2=neko_buffer_to_string(b);
      _neko_failure(return_value_neko_buffer_to_string$2, "vm/others.c", 442);
    }

  }

  return f;
}

// neko_val_iter_fields
// file vm/others.c line 465
void neko_val_iter_fields(struct _value *o, void (*f)(struct _value *, signed int, void *), void *p)
{
  otable_iter(&((struct _vobject *)o)->table, f, p);
}

// neko_val_ocall0
// file vm/neko.h line 408
struct _value * neko_val_ocall0(struct _value *o, signed int f)
{
  struct _value *return_value_neko_val_ocallN$1;
  return_value_neko_val_ocallN$1=neko_val_ocallN(o, f, (struct _value **)(void *)0, 0);
  return return_value_neko_val_ocallN$1;
}

// neko_val_ocall1
// file vm/callback.c line 167
struct _value * neko_val_ocall1(struct _value *o, signed int f, struct _value *arg)
{
  struct _value *return_value_neko_val_ocallN$1;
  return_value_neko_val_ocallN$1=neko_val_ocallN(o, f, &arg, 1);
  return return_value_neko_val_ocallN$1;
}

// neko_val_ocall2
// file vm/callback.c line 171
struct _value * neko_val_ocall2(struct _value *o, signed int f, struct _value *arg1, struct _value *arg2)
{
  struct _value *args[2l] = { arg1, arg2 };
  struct _value *return_value_neko_val_ocallN$1;
  return_value_neko_val_ocallN$1=neko_val_ocallN(o, f, args, 2);
  return return_value_neko_val_ocallN$1;
}

// neko_val_ocallN
// file vm/neko.h line 411
struct _value * neko_val_ocallN(struct _value *o, signed int f, struct _value **args, signed int nargs)
{
  struct _value *return_value_neko_val_field$1;
  return_value_neko_val_field$1=neko_val_field(o, f);
  struct _value *return_value_neko_val_callEx$2;
  return_value_neko_val_callEx$2=neko_val_callEx(o, return_value_neko_val_field$1, args, nargs, (struct _value **)(void *)0);
  return return_value_neko_val_callEx$2;
}

// neko_val_print
// file vm/neko.h line 428
void neko_val_print(struct _value *v)
{
  struct _neko_vm *vm;
  _Bool tmp_if_expr$1;
  if((1 & (signed int)v) == 0)
    tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)v) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(!tmp_if_expr$1)
  {
    struct _buffer *b;
    b=neko_alloc_buffer((const char *)(void *)0);
    neko_val_buffer(b, v);
    v=neko_buffer_to_string(b);
  }

  void *return_value_neko_local_get$2;
  return_value_neko_local_get$2=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get$2;
  vm->print(&((struct anonymous$5 *)v)->c, (signed int)*((enum anonymous$7 *)v) >> 4, vm->print_param);
}

// neko_val_rethrow
// file vm/neko.h line 431
void neko_val_rethrow(struct _value *v)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get$1;
  vm->vthis = v;
  if(*((char **)vm->start) == jit_handle_trap)
    ((void (*)(struct _neko_vm *))jit_handle_trap)(vm);

  else
    longjmp(vm->start, 1);
}

// neko_val_this
// file vm/callback.c line 176
struct _value * neko_val_this()
{
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  return (struct _value *)((struct _neko_vm *)return_value_neko_local_get$1)->vthis;
}

// neko_val_throw
// file vm/neko.h line 430
void neko_val_throw(struct _value *v)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get$1;
  vm->exc_stack=neko_alloc_array((unsigned int)0);
  vm->vthis = v;
  if(*((char **)vm->start) == jit_handle_trap)
    ((void (*)(struct _neko_vm *))jit_handle_trap)(vm);

  else
    longjmp(vm->start, 1);
}

// neko_vm_alloc
// file vm/neko_vm.h line 44
struct _neko_vm * neko_vm_alloc(void *custom)
{
  struct _neko_vm *vm;
  char *return_value_neko_alloc$1;
  return_value_neko_alloc$1=neko_alloc((unsigned int)sizeof(struct _neko_vm) /*440ul*/ );
  vm = (struct _neko_vm *)return_value_neko_alloc$1;
  struct rlimit st;
  signed int stack_size;
  signed int return_value_getrlimit$2;
  return_value_getrlimit$2=getrlimit((enum __rlimit_resource)RLIMIT_STACK, &st);
  if(st.rlim_cur == 18446744073709551615ul || !(return_value_getrlimit$2 == 0))
    stack_size = 8192 << 10;

  else
    stack_size = (signed int)st.rlim_cur;
  char *return_value_neko_alloc$3;
  return_value_neko_alloc$3=neko_alloc((unsigned int)((unsigned long int)(1 << 8) * sizeof(signed long int) /*8ul*/ ));
  vm->spmin = (signed long int *)return_value_neko_alloc$3;
  vm->print = default_printer;
  vm->print_param = (void *)stdout;
  vm->clist = (struct _custom_list *)(void *)0;
  vm->c_stack_max = (void *)((signed long int)&vm - (signed long int)(stack_size - 0x10000));
  vm->exc_stack=neko_alloc_array((unsigned int)0);
  vm->spmax = vm->spmin + (signed long int)(1 << 8);
  vm->sp = vm->spmax;
  vm->csp = vm->spmin - (signed long int)1;
  vm->vthis = val_null;
  vm->env=neko_alloc_array((unsigned int)0);
  vm->jit_val = (void *)0;
  vm->run_jit = 0;
  vm->resolver = (struct _value *)(void *)0;
  vm->trusted_code = 0;
  vm->fstats = (void (*)(struct _neko_vm *, const char *, signed int))(void *)0;
  vm->pstats = (void (*)(struct _neko_vm *, const char *, signed int))(void *)0;
  return vm;
}

// neko_vm_current
// file vm/interp.c line 160
struct _neko_vm * neko_vm_current()
{
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  return (struct _neko_vm *)return_value_neko_local_get$1;
}

// neko_vm_custom
// file vm/interp.c line 164
void * neko_vm_custom(struct _neko_vm *vm, struct anonymous *k)
{
  struct _custom_list *c = vm->clist;
  for( ; !(c == ((struct _custom_list *)NULL)); c = c->next)
    if(c->tag == k)
      return c->custom;

  return (void *)0;
}

// neko_vm_dump_stack
// file vm/interp.c line 547
void neko_vm_dump_stack(struct _neko_vm *vm)
{
  signed long int *cspup = vm->csp;
  signed long int *csp = vm->spmin - (signed long int)1;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  while(!(csp == cspup))
  {
    struct _neko_module *m = (struct _neko_module *)csp[(signed long int)4];
    printf("Called from ");
    if(!(m == ((struct _neko_module *)NULL)))
    {
      printf("%s ", &((struct anonymous$5 *)m->name)->c);
      if(!(m->dbgidxs == ((struct _neko_debug *)NULL)))
      {
        signed int ppc = (signed int)((((signed long int **)csp)[(signed long int)1] - (signed long int)2) - m->code);
        signed int idx;
        signed int return_value_bitcount$1;
        return_value_bitcount$1=bitcount((m->dbgidxs + (signed long int)(ppc >> 5))->bits >> 31 - (ppc & 31));
        idx = (m->dbgidxs + (signed long int)(ppc >> 5))->base + return_value_bitcount$1;
        struct _value *s = (&((struct anonymous$4 *)m->dbgtbl)->ptr)[(signed long int)idx];
        if((1 & (signed int)s) == 0)
          tmp_if_expr$7 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
          printf("%s", &((struct anonymous$5 *)s)->c);

        else
        {
          if((1 & (signed int)s) == 0)
            tmp_if_expr$2 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          if(tmp_if_expr$2)
            tmp_if_expr$3 = (signed int)*((enum anonymous$7 *)s) >> 4 == 2 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
          {
            if((1 & (signed int)((struct anonymous$4 *)s)->ptr) == 0)
              tmp_if_expr$4 = ((signed int)*((enum anonymous$7 *)(&((struct anonymous$4 *)s)->ptr)[(signed long int)0]) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$5 = (_Bool)0;
          if(tmp_if_expr$5)
            tmp_if_expr$6 = ((signed int)(signed long int)(&((struct anonymous$4 *)s)->ptr)[(signed long int)1] & 1) != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
            printf("file %s line %d", &((struct anonymous$5 *)(&((struct anonymous$4 *)s)->ptr)[(signed long int)0])->c, (signed int)(signed long int)(&((struct anonymous$4 *)s)->ptr)[(signed long int)1] >> 1);

          else
            printf("???");
        }
      }

    }

    else
      printf("a C function");
    csp = csp + (signed long int)4;
    printf("\n");
  }
  fflush(stdout);
}

// neko_vm_execute
// file vm/interp.c line 229
struct _value * neko_vm_execute(struct _neko_vm *vm, void *_m)
{
  unsigned int i;
  struct _neko_module *m = (struct _neko_module *)_m;
  struct _value *old_env = vm->env;
  struct _value *ret;
  struct _value *old_this = vm->vthis;
  neko_vm_select(vm);
  i = (unsigned int)0;
  for( ; !(i >= m->nfields); i = i + 1u)
    neko_val_id(&((struct anonymous$5 *)m->fields[(signed long int)i])->c);
  vm->env=neko_alloc_array((unsigned int)0);
  vm->vthis = val_null;
  ret=neko_interp(vm, (void *)m, (signed long int)val_null, m->code);
  vm->env = old_env;
  vm->vthis = old_this;
  return ret;
}

// neko_vm_jit
// file vm/neko_vm.h line 52
signed int neko_vm_jit(struct _neko_vm *vm, signed int enable_jit)
{
  if(!(enable_jit >= 0))
    return vm->run_jit;

  else
  {
    if(!(enable_jit == 0))
      vm->run_jit=neko_can_jit();

    else
      vm->run_jit = 0;
    return vm->run_jit;
  }
}

// neko_vm_redirect
// file vm/interp.c line 210
void neko_vm_redirect(struct _neko_vm *vm, void (*print)(const char *, signed int, void *), void *param)
{
  struct anonymous$24 *p;
  if(print == ((void (*)(const char *, signed int, void *))NULL))
  {
    if(!(vm->print == redirected_print))
      goto __CPROVER_DUMP_L3;

    p = (struct anonymous$24 *)vm->print_param;
    vm->print = p->prev;
    vm->print_param = p->prev_param;
  }

  else
  {
    char *return_value_neko_alloc$1;
    return_value_neko_alloc$1=neko_alloc((unsigned int)sizeof(struct anonymous$24) /*32ul*/ );
    p = (struct anonymous$24 *)return_value_neko_alloc$1;
    p->prev = vm->print;
    p->prev_param = vm->print_param;
    p->cur = print;
    p->cur_param = param;
    vm->print = redirected_print;
    vm->print_param = (void *)p;
  }

__CPROVER_DUMP_L3:
  ;
}

// neko_vm_select
// file vm/neko_vm.h line 51
void neko_vm_select(struct _neko_vm *vm)
{
  neko_local_set(neko_vm_context, (void *)vm);
}

// neko_vm_set_custom
// file vm/interp.c line 174
void neko_vm_set_custom(struct _neko_vm *vm, struct anonymous *k, void *v)
{
  struct _custom_list *c = vm->clist;
  struct _custom_list *prev = (struct _custom_list *)(void *)0;
  for( ; !(c == ((struct _custom_list *)NULL)); c = c->next)
  {
    if(c->tag == k)
    {
      if(!(v == NULL))
      {
        c->custom = v;
        goto __CPROVER_DUMP_L7;
      }

      if(prev == ((struct _custom_list *)NULL))
        vm->clist = c->next;

      else
        prev->next = c->next;
      goto __CPROVER_DUMP_L7;
    }

    prev = c;
  }
  char *return_value_neko_alloc$1;
  return_value_neko_alloc$1=neko_alloc((unsigned int)sizeof(struct _custom_list) /*24ul*/ );
  c = (struct _custom_list *)return_value_neko_alloc$1;
  c->tag = k;
  c->custom = v;
  c->next = vm->clist;
  vm->clist = c;

__CPROVER_DUMP_L7:
  ;
}

// neko_vm_set_stats
// file vm/neko_vm.h line 56
void neko_vm_set_stats(struct _neko_vm *vm, void (*fstats)(struct _neko_vm *, const char *, signed int), void (*pstats)(struct _neko_vm *, const char *, signed int))
{
  vm->fstats = fstats;
  vm->pstats = pstats;
}

// neko_vm_trusted
// file vm/interp.c line 145
signed int neko_vm_trusted(struct _neko_vm *vm, signed int t)
{
  signed int old = vm->trusted_code;
  vm->trusted_code = t;
  return old;
}

// null_warn_proc
// file vm/alloc.c line 111
static void null_warn_proc(char *msg, signed int arg)
{
  ;
}

// open_module
// file vm/load.c line 169
static void open_module(struct _value *path, const char *mname, signed int (**r)(void *, void *, signed int), void **p)
{
  struct _IO_FILE *f;
  struct _value *fname;
  char *ext;
  ext=strrchr(mname, 46);
  _Bool tmp_if_expr$1;
  if(!(ext == ((char *)NULL)))
    tmp_if_expr$1 = (signed int)ext[(signed long int)1] == 110 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (signed int)ext[(signed long int)2] == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    fname=neko_select_file(path, mname, "");

  else
    fname=neko_select_file(path, mname, ".n");
  f=fopen(&((struct anonymous$5 *)fname)->c, "rb");
  if(f == ((struct _IO_FILE *)NULL))
  {
    struct _buffer *b;
    b=neko_alloc_buffer("Module not found : ");
    neko_buffer_append(b, mname);
    struct _value *return_value_neko_buffer_to_string$3;
    return_value_neko_buffer_to_string$3=neko_buffer_to_string(b);
    _neko_failure(return_value_neko_buffer_to_string$3, "vm/load.c", 181);
  }

  *r = neko_file_reader;
  *p = (void *)f;
}

// otable_copy
// file vm/objtable.h line 80
void otable_copy(struct _objtable *t, struct _objtable *target)
{
  target->count = t->count;
  char *return_value_neko_alloc$1;
  return_value_neko_alloc$1=neko_alloc((unsigned int)(sizeof(struct anonymous$3) /*16ul*/  * (unsigned long int)t->count));
  target->cells = (struct anonymous$3 *)return_value_neko_alloc$1;
  memcpy((void *)target->cells, (const void *)t->cells, sizeof(struct anonymous$3) /*16ul*/  * (unsigned long int)t->count);
}

// otable_find
// file vm/objtable.h line 31
static inline struct _value ** otable_find(struct _objtable *t, signed int id)
{
  signed int min;
  signed int max;
  signed int mid;
  struct anonymous$3 *c;
  signed int cid;
  min = 0;
  max = t->count;
  c = t->cells;
  while(!(min >= max))
  {
    mid = min + max >> 1;
    cid = (c + (signed long int)mid)->id;
    if(!(cid >= id))
      min = mid + 1;

    else
      if(!(id >= cid))
        max = mid;

      else
        return &(c + (signed long int)mid)->v;
  }
  return (struct _value **)(void *)0;
}

// otable_find$link1
// file vm/objtable.h line 31
static inline struct _value ** otable_find$link1(struct _objtable *t$link1, signed int id$link1)
{
  signed int min$link1;
  signed int max$link1;
  signed int mid$link1;
  struct anonymous$3 *c$link1;
  signed int cid$link1;
  min$link1 = 0;
  max$link1 = t$link1->count;
  c$link1 = t$link1->cells;
  while(!(min$link1 >= max$link1))
  {
    mid$link1 = min$link1 + max$link1 >> 1;
    cid$link1 = (c$link1 + (signed long int)mid$link1)->id;
    if(!(cid$link1 >= id$link1))
      min$link1 = mid$link1 + 1;

    else
      if(!(id$link1 >= cid$link1))
        max$link1 = mid$link1;

      else
        return &(c$link1 + (signed long int)mid$link1)->v;
  }
  return (struct _value **)(void *)0;
}

// otable_find$link2
// file vm/objtable.h line 31
static inline struct _value ** otable_find$link2(struct _objtable *t$link2, signed int id$link2)
{
  signed int min$link2;
  signed int max$link2;
  signed int mid$link2;
  struct anonymous$3 *c$link2;
  signed int cid$link2;
  min$link2 = 0;
  max$link2 = t$link2->count;
  c$link2 = t$link2->cells;
  while(!(min$link2 >= max$link2))
  {
    mid$link2 = min$link2 + max$link2 >> 1;
    cid$link2 = (c$link2 + (signed long int)mid$link2)->id;
    if(!(cid$link2 >= id$link2))
      min$link2 = mid$link2 + 1;

    else
      if(!(id$link2 >= cid$link2))
        max$link2 = mid$link2;

      else
        return &(c$link2 + (signed long int)mid$link2)->v;
  }
  return (struct _value **)(void *)0;
}

// otable_get
// file vm/objtable.h line 53
static inline struct _value * otable_get(struct _objtable *t, signed int id)
{
  signed int min;
  signed int max;
  signed int mid;
  struct anonymous$3 *c;
  signed int cid;
  min = 0;
  max = t->count;
  c = t->cells;
  while(!(min >= max))
  {
    mid = min + max >> 1;
    cid = (c + (signed long int)mid)->id;
    if(!(cid >= id))
      min = mid + 1;

    else
      if(!(id >= cid))
        max = mid;

      else
        return (c + (signed long int)mid)->v;
  }
  return val_null;
}

// otable_init
// file vm/objtable.h line 26
static inline void otable_init(struct _objtable *t)
{
  t->count = 0;
  t->cells = (struct anonymous$3 *)(void *)0;
}

// otable_iter
// file vm/objtable.h line 81
void otable_iter(struct _objtable *t, void (*f)(struct _value *, signed int, void *), void *p)
{
  signed int i;
  signed int n = t->count;
  struct anonymous$3 *c = t->cells;
  i = 0;
  if(!(i >= n))
  {
    f((c + (signed long int)i)->v, (c + (signed long int)i)->id, p);
    i = i + 1;
  }

}

// otable_optimize
// file vm/objtable.c line 53
void otable_optimize(struct _objtable *t)
{
  signed int max = t->count;
  signed int i;
  signed int cur = 0;
  struct anonymous$3 *c = t->cells;
  i = 0;
  signed int tmp_post$1;
  for( ; !(i >= max); i = i + 1)
  {
    struct _value *v = (c + (signed long int)i)->v;
    if(!(v == val_null))
    {
      tmp_post$1 = cur;
      cur = cur + 1;
      c[(signed long int)tmp_post$1] = c[(signed long int)i];
    }

  }
  i = cur;
  for( ; !(i >= max); i = i + 1)
    (c + (signed long int)i)->v = (struct _value *)(void *)0;
  t->count = cur;
}

// otable_remove
// file vm/objtable.h line 76
signed int otable_remove(struct _objtable *t, signed int id)
{
  signed int min = 0;
  signed int max = t->count;
  signed int mid;
  signed int cid;
  struct anonymous$3 *c = t->cells;
  if(max == 0)
    return 0;

  else
  {
    while(!(min >= max))
    {
      mid = min + max >> 1;
      cid = (c + (signed long int)mid)->id;
      if(!(cid >= id))
        min = mid + 1;

      else
        if(!(id >= cid))
          max = mid;

        else
        {
          t->count = t->count - 1;
          for( ; !(mid >= t->count); mid = mid + 1)
            c[(signed long int)mid] = c[(signed long int)(mid + 1)];
          (c + (signed long int)mid)->v = val_null;
          return 1;
        }
    }
    return 0;
  }
}

// otable_replace
// file vm/objtable.h line 75
void otable_replace(struct _objtable *t, signed int id, struct _value *data)
{
  signed int min = 0;
  signed int max = t->count;
  signed int mid;
  signed int cid;
  struct anonymous$3 *c = t->cells;
  while(!(min >= max))
  {
    mid = min + max >> 1;
    cid = (c + (signed long int)mid)->id;
    if(!(cid >= id))
      min = mid + 1;

    else
      if(!(id >= cid))
        max = mid;

      else
      {
        (c + (signed long int)mid)->v = data;
        goto __CPROVER_DUMP_L10;
      }
  }
  mid = min + max >> 1;
  char *return_value_neko_alloc$1;
  return_value_neko_alloc$1=neko_alloc((unsigned int)(sizeof(struct anonymous$3) /*16ul*/  * (unsigned long int)(t->count + 1)));
  c = (struct anonymous$3 *)return_value_neko_alloc$1;
  min = 0;
  for( ; !(min >= mid); min = min + 1)
    c[(signed long int)min] = t->cells[(signed long int)min];
  (c + (signed long int)mid)->id = id;
  (c + (signed long int)mid)->v = data;
  for( ; !(min >= t->count); min = min + 1)
    c[(signed long int)(min + 1)] = t->cells[(signed long int)min];
  t->cells = c;
  t->count = t->count + 1;

__CPROVER_DUMP_L10:
  ;
}

// precise_timer
// file vm/stats.c line 49
static signed int precise_timer()
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  static signed int base_sec;
  if(init_done == 0)
  {
    init_done = 1;
    base_sec = (signed int)tv.tv_sec;
  }

  return (signed int)((tv.tv_sec - (signed long int)base_sec) * (signed long int)1000000 + tv.tv_usec);
}

// read_bytecode
// file vm/main.c line 150
static struct _value * read_bytecode(struct _value *str, struct _value *pos, struct _value *len)
{
  unsigned long int rlen;
  rlen=fread((void *)(&((struct anonymous$5 *)str)->c + (signed long int)((signed int)(signed long int)pos >> 1)), (unsigned long int)1, (unsigned long int)((signed int)(signed long int)len >> 1), self);
  return (struct _value *)(signed long int)((signed int)rlen << 1 | 1);
}

// read_debug_infos
// file vm/module.c line 244
static void * read_debug_infos(signed int (*r)(void *, void *, signed int), void *p, char *tmp, struct _neko_module *m)
{
  unsigned int i;
  signed int curline = 0;
  struct _value *curfile;
  unsigned int npos;
  unsigned int nfiles;
  unsigned char c;
  unsigned char c2;
  struct _value *files;
  struct _value *positions;
  struct _value *pp;
  struct _neko_debug *bits;
  signed int pos_index = -1;
  signed int lot_of_files = 0;
  signed int return_value;
  return_value=r(p, (void *)&c, 1);
  signed int tmp_post$3;
  if(return_value == -1)
  {
    free((void *)tmp);
    return (void *)0;
  }

  else
  {
    if((signed int)c >= 0x80)
    {
      signed int return_value_1;
      return_value_1=r(p, (void *)&c2, 1);
      if(return_value_1 == -1)
      {
        free((void *)tmp);
        return (void *)0;
      }

      nfiles = (unsigned int)(((signed int)c & 0x7F) << 8 | (signed int)c2);
      lot_of_files = 1;
    }

    else
      nfiles = (unsigned int)c;
    if(nfiles == 0u)
    {
      free((void *)tmp);
      return (void *)0;
    }

    else
    {
      files=neko_alloc_array(nfiles);
      i = (unsigned int)0;
      if(!(i >= nfiles))
      {
        signed int return_value_read_string$1;
        return_value_read_string$1=read_string(r, p, tmp);
        if(return_value_read_string$1 == -1)
        {
          free((void *)tmp);
          return (void *)0;
        }

        (&((struct anonymous$4 *)files)->ptr)[(signed long int)i]=neko_alloc_string(tmp);
        i = i + 1u;
      }

      read_long(r, p, &npos);
      if(!(npos == m->codesize))
      {
        free((void *)tmp);
        return (void *)0;
      }

      else
      {
        curfile = (&((struct anonymous$4 *)files)->ptr)[(signed long int)0];
        positions=neko_alloc_array((unsigned int)2 + npos / (unsigned int)20);
        char *return_value_neko_alloc_private$2;
        return_value_neko_alloc_private$2=neko_alloc_private((unsigned int)(sizeof(struct _neko_debug) /*8ul*/  * (unsigned long int)(npos + (unsigned int)31 >> 5)));
        bits = (struct _neko_debug *)return_value_neko_alloc_private$2;
        m->dbgidxs = bits;
        bits = bits - 1l;
        i = (unsigned int)0;
        pp = (struct _value *)(void *)0;
        if(!(i >= npos))
        {
          signed int return_value_2;
          return_value_2=r(p, (void *)&c, 1);
          if(return_value_2 == -1)
          {
            free((void *)tmp);
            return (void *)0;
          }

          if(!((1 & (signed int)c) == 0))
          {
            c = c >> 1;
            if(!(lot_of_files == 0))
            {
              signed int return_value_3;
              return_value_3=r(p, (void *)&c2, 1);
              if(return_value_3 == -1)
              {
                free((void *)tmp);
                return (void *)0;
              }

              nfiles = (unsigned int)((signed int)c << 8 | (signed int)c2);
            }

            else
              nfiles = (unsigned int)c;
            if(nfiles >= (unsigned int)((signed int)*((enum anonymous$7 *)files) >> 4))
            {
              free((void *)tmp);
              return (void *)0;
            }

            curfile = (&((struct anonymous$4 *)files)->ptr)[(signed long int)nfiles];
            pp = (struct _value *)(void *)0;
          }

          else
            if(!((2 & (signed int)c) == 0))
            {
              signed int delta = (signed int)c >> 6;
              signed int count = (signed int)c >> 2 & 15;
              if(!(npos >= i + (unsigned int)count))
              {
                free((void *)tmp);
                return (void *)0;
              }

              if(pp == ((struct _value *)NULL))
              {
                pp=neko_alloc_array((unsigned int)2);
                (&((struct anonymous$4 *)pp)->ptr)[(signed long int)0] = curfile;
                (&((struct anonymous$4 *)pp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)curline << 1 | 1);
                pos_index = pos_index + 1;
                append_array(&positions, pos_index, pp);
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(1 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
                count = count - 1;
              }

              tmp_post$3 = count;
              count = count - 1;
              if(!(tmp_post$3 == 0))
              {
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(0 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
              }

              if(!(delta == 0))
              {
                curline = curline + delta;
                pp = (struct _value *)(void *)0;
              }

            }

            else
              if(!((4 & (signed int)c) == 0))
              {
                curline = curline + ((signed int)c >> 3);
                pp=neko_alloc_array((unsigned int)2);
                (&((struct anonymous$4 *)pp)->ptr)[(signed long int)0] = curfile;
                (&((struct anonymous$4 *)pp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)curline << 1 | 1);
                pos_index = pos_index + 1;
                append_array(&positions, pos_index, pp);
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(1 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
              }

              else
              {
                unsigned char b2;
                unsigned char b3;
                signed int return_value_4;
                return_value_4=r(p, (void *)&b2, 1);
                if(return_value_4 == -1)
                {
                  free((void *)tmp);
                  return (void *)0;
                }

                signed int return_value_5;
                return_value_5=r(p, (void *)&b3, 1);
                if(return_value_5 == -1)
                {
                  free((void *)tmp);
                  return (void *)0;
                }

                curline = (signed int)c >> 3 | (signed int)b2 << 5 | (signed int)b3 << 13;
                pp=neko_alloc_array((unsigned int)2);
                (&((struct anonymous$4 *)pp)->ptr)[(signed long int)0] = curfile;
                (&((struct anonymous$4 *)pp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)curline << 1 | 1);
                pos_index = pos_index + 1;
                append_array(&positions, pos_index, pp);
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(1 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
              }
        }

        pos_index = pos_index + 1;
        m->dbgtbl=neko_alloc_array((unsigned int)pos_index);
        memcpy((void *)&((struct anonymous$4 *)m->dbgtbl)->ptr, (const void *)&((struct anonymous$4 *)positions)->ptr, (unsigned long int)pos_index * sizeof(struct _value *) /*8ul*/ );
        return (void *)m;
      }
    }
  }
}

// read_long
// file vm/module.c line 68
static void read_long(signed int (*r)(void *, void *, signed int), void *p, unsigned int *i)
{
  unsigned char c[4l];
  signed int n;
  r(p, (void *)c, 4);
  n = (signed int)c[(signed long int)0] | (signed int)c[(signed long int)1] << 8 | (signed int)c[(signed long int)2] << 16 | (signed int)c[(signed long int)3] << 24;
  *i = (unsigned int)n;
}

// read_short
// file vm/module.c line 76
static void read_short(signed int (*r)(void *, void *, signed int), void *p, unsigned short int *i)
{
  unsigned char c[2l];
  signed int n;
  r(p, (void *)c, 2);
  n = (signed int)c[(signed long int)0] | (signed int)c[(signed long int)1] << 8;
  *i = (unsigned short int)n;
}

// read_string
// file vm/module.c line 108
static signed int read_string(signed int (*r)(void *, void *, signed int), void *p, char *buf)
{
  signed int i = 0;
  char c;
  signed int tmp_post$1;
  if(!(i >= 0x100))
  {
    signed int return_value;
    return_value=r(p, (void *)&c, 1);
    if(return_value == -1)
      return -1;

    tmp_post$1 = i;
    i = i + 1;
    buf[(signed long int)tmp_post$1] = c;
    if((signed int)c == 0)
      return i;

  }

  return -1;
}

// redirected_print
// file vm/interp.c line 205
static void redirected_print(const char *s, signed int size, void *_p)
{
  struct anonymous$24 *p = (struct anonymous$24 *)_p;
  p->cur(s, size, p->cur_param);
}

// report
// file vm/main.c line 120
static void report(struct _neko_vm *vm, struct _value *exc, signed int isexc)
{
  signed int i;
  struct _buffer *b;
  b=neko_alloc_buffer((const char *)(void *)0);
  struct _value *st;
  st=neko_exc_stack(vm);
  i = 0;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  for( ; !(i >= (signed int)*((enum anonymous$7 *)st) >> 4); i = i + 1)
  {
    struct _value *s = (&((struct anonymous$4 *)st)->ptr)[(signed long int)i];
    neko_buffer_append(b, "Called from ");
    if(s == val_null)
      neko_buffer_append(b, "a C function");

    else
    {
      if((1 & (signed int)s) == 0)
        tmp_if_expr$6 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
      {
        neko_buffer_append(b, &((struct anonymous$5 *)s)->c);
        neko_buffer_append(b, " (no debug available)");
      }

      else
      {
        if((1 & (signed int)s) == 0)
          tmp_if_expr$1 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (signed int)*((enum anonymous$7 *)s) >> 4 == 2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          if((1 & (signed int)((struct anonymous$4 *)s)->ptr) == 0)
            tmp_if_expr$3 = ((signed int)*((enum anonymous$7 *)(&((struct anonymous$4 *)s)->ptr)[(signed long int)0]) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = ((signed int)(signed long int)(&((struct anonymous$4 *)s)->ptr)[(signed long int)1] & 1) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          neko_val_buffer(b, (&((struct anonymous$4 *)s)->ptr)[(signed long int)0]);
          neko_buffer_append(b, " line ");
          neko_val_buffer(b, (&((struct anonymous$4 *)s)->ptr)[(signed long int)1]);
        }

        else
          neko_val_buffer(b, s);
      }
    }
    neko_buffer_append_char(b, (char)10);
  }
  if(!(isexc == 0))
    neko_buffer_append(b, "Uncaught exception - ");

  neko_val_buffer(b, exc);
  struct _value *return_value_neko_buffer_to_string$7;
  return_value_neko_buffer_to_string$7=neko_buffer_to_string(b);
  fprintf(stderr, "%s\n", &((struct anonymous$5 *)return_value_neko_buffer_to_string$7)->c);
}

// scmp
// file vm/others.c line 48
static inline signed int scmp(const char *s1, signed int l1, const char *s2, signed int l2)
{
  signed int r;
  r=memcmp((const void *)s1, (const void *)s2, (unsigned long int)(l1 < l2 ? l1 : l2));
  signed int tmp_if_expr$2;
  signed int return_value_icmp$1;
  if(!(r == 0))
    tmp_if_expr$2 = r;

  else
  {
    return_value_icmp$1=icmp(l1, l2);
    tmp_if_expr$2 = return_value_icmp$1;
  }
  return tmp_if_expr$2;
}

// sort
// file vm/stats.c line 138
static struct _statinfos * sort(struct _statinfos *list)
{
  struct _statinfos *p;
  struct _statinfos *q;
  struct _statinfos *e;
  struct _statinfos *tail;
  signed int insize;
  signed int nmerges;
  signed int psize;
  signed int qsize;
  signed int i;
  insize = 1;
  signed int return_value_cmp$1;
  for( ; !(list == ((struct _statinfos *)NULL)); insize = insize * 2)
  {
    p = list;
    list = (struct _statinfos *)(void *)0;
    tail = (struct _statinfos *)(void *)0;
    nmerges = 0;
    for( ; !(p == ((struct _statinfos *)NULL)); p = q)
    {
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      i = 0;
      for( ; !(i >= insize); i = i + 1)
      {
        psize = psize + 1;
        q = q->next;
        if(q == ((struct _statinfos *)NULL))
          break;

      }
      qsize = insize;
      while(psize >= 1 || qsize >= 1 && !(q == ((struct _statinfos *)NULL)))
      {
        if(psize == 0)
        {
          e = q;
          q = q->next;
          qsize = qsize - 1;
        }

        else
          if(q == ((struct _statinfos *)NULL) || qsize == 0)
          {
            e = p;
            p = p->next;
            psize = psize - 1;
          }

          else
          {
            return_value_cmp$1=cmp(p, q);
            if(!(return_value_cmp$1 >= 1))
            {
              e = p;
              p = p->next;
              psize = psize - 1;
            }

            else
            {
              e = q;
              q = q->next;
              qsize = qsize - 1;
            }
          }
        if(!(tail == ((struct _statinfos *)NULL)))
          tail->next = e;

        else
          list = e;
        tail = e;
      }
    }
    tail->next = (struct _statinfos *)(void *)0;
    if(!(nmerges >= 2))
      return list;

  }
  return (struct _statinfos *)(void *)0;
}

// stats_proxy
// file vm/load.c line 327
static struct _value * stats_proxy(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5, struct _value *p6)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get$1;
  struct _value *env = vm->env;
  struct _value *ret;
  if(!(vm->pstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
    vm->pstats(vm, &((struct anonymous$5 *)(&((struct anonymous$4 *)env)->ptr)[(signed long int)0])->c, 1);

  ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *, struct _value *, struct _value *, struct _value *))((signed long int)(&((struct anonymous$4 *)vm->env)->ptr)[(signed long int)1] & (signed long int)~1))(p1, p2, p3, p4, p5, p6);
  if(!(vm->pstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
    vm->pstats(vm, &((struct anonymous$5 *)(&((struct anonymous$4 *)env)->ptr)[(signed long int)0])->c, 0);

  return ret;
}

// val_buffer_fields
// file vm/others.c line 219
static void val_buffer_fields(struct _value *v, signed int f, void *_l)
{
  struct vlist2 *l = (struct vlist2 *)_l;
  if(!(l->prev == 0))
    neko_buffer_append_sub(l->b, ", ", (signed long int)2);

  else
  {
    neko_buffer_append_sub(l->b, " ", (signed long int)1);
    l->prev = 1;
  }
  struct _value *return_value_neko_val_field_name$1;
  return_value_neko_val_field_name$1=neko_val_field_name(f);
  neko_val_buffer(l->b, return_value_neko_val_field_name$1);
  neko_buffer_append_sub(l->b, " => ", (signed long int)4);
  val_buffer_rec(l->b, v, (struct vlist *)l);
}

// val_buffer_rec
// file vm/others.c line 232
static void val_buffer_rec(struct _buffer *b, struct _value *v, struct vlist *stack)
{
  char buf[32l];
  signed int i;
  signed int l;
  struct vlist *val_buffer_rec$$1$$vtmp = stack;
  for( ; !(val_buffer_rec$$1$$vtmp == ((struct vlist *)NULL)); val_buffer_rec$$1$$vtmp = val_buffer_rec$$1$$vtmp->next)
    if(val_buffer_rec$$1$$vtmp->v == v)
    {
      neko_buffer_append_sub(b, "...", (signed long int)3);
      goto __CPROVER_DUMP_L30;
    }

  signed int tmp_if_expr$1;
  if(!((1 & (signed int)v) == 0))
    tmp_if_expr$1 = VAL_INT;

  else
    tmp_if_expr$1 = (signed int)*((enum anonymous$7 *)v) & (1 << 4) - 1;
  signed int return_value_sprintf$2;
  signed int return_value_sprintf$3;
  signed int return_value_sprintf$4;
  struct _value *s;
  _Bool tmp_if_expr$5;
  signed int return_value_sprintf$6;
  switch(tmp_if_expr$1)
  {
    case VAL_INT:
    {
      return_value_sprintf$2=sprintf(buf, "%d", (signed int)(signed long int)v >> 1);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf$2);
      break;
    }
    case VAL_STRING:
    {
      neko_buffer_append_sub(b, &((struct anonymous$5 *)v)->c, (signed long int)((signed int)*((enum anonymous$7 *)v) >> 4));
      break;
    }
    case VAL_FLOAT:
    {
      return_value_sprintf$3=sprintf(buf, "%.15g", ((struct anonymous$25 *)v)->f);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf$3);
      break;
    }
    case VAL_NULL:
    {
      neko_buffer_append_sub(b, "null", (signed long int)4);
      break;
    }
    case VAL_BOOL:
    {
      if(v == val_true)
        neko_buffer_append_sub(b, "true", (signed long int)4);

      else
        neko_buffer_append_sub(b, "false", (signed long int)5);
      break;
    }
    case VAL_FUNCTION:
    {
      return_value_sprintf$4=sprintf(buf, "#function:%d", ((struct anonymous$8 *)v)->nargs);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf$4);
      break;
    }
    case VAL_OBJECT:
    {
      s=neko_val_field(v, id_string);
      if(!(s == val_null))
        s=neko_val_callEx(v, s, (struct _value **)(void *)0, 0, (struct _value **)(void *)0);

      if((1 & (signed int)s) == 0)
        tmp_if_expr$5 = ((signed int)*((enum anonymous$7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        neko_buffer_append_sub(b, &((struct anonymous$5 *)s)->c, (signed long int)((signed int)*((enum anonymous$7 *)s) >> 4));

      else
      {
        struct vlist2 vtmp;
        vtmp.v = v;
        vtmp.next = stack;
        vtmp.b = b;
        vtmp.prev = 0;
        neko_buffer_append_sub(b, "{", (signed long int)1);
        neko_val_iter_fields(v, val_buffer_fields, (void *)&vtmp);
        if(!(vtmp.prev == 0))
          neko_buffer_append_sub(b, " }", (signed long int)2);

        else
          neko_buffer_append_sub(b, "}", (signed long int)1);
      }
      break;
    }
    case VAL_ARRAY:
    {
      neko_buffer_append_sub(b, "[", (signed long int)1);
      l = (signed int)*((enum anonymous$7 *)v) >> 4;
      struct vlist val_buffer_rec$$1$$2$$2$$vtmp;
      val_buffer_rec$$1$$2$$2$$vtmp.v = v;
      val_buffer_rec$$1$$2$$2$$vtmp.next = stack;
      i = 0;
      for( ; !(i >= l); i = i + 1)
      {
        struct _value *vi = (&((struct anonymous$4 *)v)->ptr)[(signed long int)i];
        val_buffer_rec(b, vi, &val_buffer_rec$$1$$2$$2$$vtmp);
        if(!(i == l + -1))
          neko_buffer_append_sub(b, ",", (signed long int)1);

      }
      neko_buffer_append_sub(b, "]", (signed long int)1);
      break;
    }
    case VAL_INT32:
    {
      return_value_sprintf$6=sprintf(buf, "%d", ((struct anonymous$26 *)v)->i);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf$6);
      break;
    }
    case VAL_ABSTRACT:
    {
      neko_buffer_append_sub(b, "#abstract", (signed long int)9);
      break;
    }
    default:
      neko_buffer_append_sub(b, "#unknown", (signed long int)8);
  }

__CPROVER_DUMP_L30:
  ;
}

// varargs_callback
// file vm/builtins.c line 583
static struct _value * varargs_callback(struct _value **args, signed int nargs)
{
  struct _value *f;
  void *return_value_neko_local_get$1;
  return_value_neko_local_get$1=neko_local_get(neko_vm_context);
  f = ((struct _neko_vm *)return_value_neko_local_get$1)->env;
  struct _value *a;
  a=neko_alloc_array((unsigned int)nargs);
  signed int i = 0;
  for( ; !(i >= nargs); i = i + 1)
    (&((struct anonymous$4 *)a)->ptr)[(signed long int)i] = args[(signed long int)i];
  struct _value *return_value_neko_val_call1$2;
  return_value_neko_val_call1$2=neko_val_call1(f, a);
  return return_value_neko_val_call1$2;
}

