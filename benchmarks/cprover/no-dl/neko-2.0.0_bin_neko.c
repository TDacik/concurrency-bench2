// #anon_enum_VAL_INT=255_VAL_NULL=0_VAL_FLOAT=1_VAL_BOOL=2_VAL_STRING=3_VAL_OBJECT=4_VAL_ARRAY=5_VAL_FUNCTION=6_VAL_ABSTRACT=7_VAL_INT32=8_VAL_PRIMITIVE=22_VAL_JITFUN=38_VAL_32_BITS=-1
// file vm/neko.h line 99
enum anonymous_7 { VAL_INT=255, VAL_NULL=0, VAL_FLOAT=1, VAL_BOOL=2, VAL_STRING=3, VAL_OBJECT=4, VAL_ARRAY=5, VAL_FUNCTION=6, VAL_ABSTRACT=7, VAL_INT32=8, VAL_PRIMITIVE=22, VAL_JITFUN=38, VAL_32_BITS=-1 };

// tag-#anon#ST[*{*{SYM#tag-hcell#}_SYM#tag-hcell#_}_*{SYM#tag-hcell#}_SYM#tag-hcell#__'cells'||S32'ncells'||S32'nitems'|]
// file vm/neko.h line 189
struct anonymous_0;

// tag-#anon#ST[*{S8}_S8_'p'||S32'len'||U32'_pad0'|]
// file vm/neko_mod.h line 50
struct anonymous_20;

// tag-#anon#ST[*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'init'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'main'||*{V}_V_'param'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'|]
// file vm/threads.c line 80
struct anonymous_23;

// tag-#anon#ST[*{V(*{cS8}_cS8_|S32|*{V}_V_)->V}_V(*{cS8}_cS8_|S32|*{V}_V_)->V_'prev'||*{V}_V_'prev_param'||*{V(*{cS8}_cS8_|S32|*{V}_V_)->V}_V(*{cS8}_cS8_|S32|*{V}_V_)->V_'cur'||*{V}_V_'cur_param'|]
// file vm/interp.c line 198
struct anonymous_24;

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_17;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_15;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_10;

// tag-#anon#ST[EN#anon_enum_VAL_INT=255_VAL_NULL=0_VAL_FLOAT=1_VAL_BOOL=2_VAL_STRING=3_VAL_OBJECT=4_VAL_ARRAY=5_VAL_FUNCTION=6_VAL_ABSTRACT=7_VAL_INT32=8_VAL_PRIMITIVE=22_VAL_JITFUN=38_VAL_32_BITS=-1#{S32}_S32_'t'||F64'f'|]
// file vm/neko.h line 141
struct anonymous_25;

// tag-#anon#ST[EN#anon_enum_VAL_INT=255_VAL_NULL=0_VAL_FLOAT=1_VAL_BOOL=2_VAL_STRING=3_VAL_OBJECT=4_VAL_ARRAY=5_VAL_FUNCTION=6_VAL_ABSTRACT=7_VAL_INT32=8_VAL_PRIMITIVE=22_VAL_JITFUN=38_VAL_32_BITS=-1#{S32}_S32_'t'||S32'i'|]
// file vm/neko.h line 146
struct anonymous_26;

// tag-#anon#ST[EN#anon_enum_VAL_INT=255_VAL_NULL=0_VAL_FLOAT=1_VAL_BOOL=2_VAL_STRING=3_VAL_OBJECT=4_VAL_ARRAY=5_VAL_FUNCTION=6_VAL_ABSTRACT=7_VAL_INT32=8_VAL_PRIMITIVE=22_VAL_JITFUN=38_VAL_32_BITS=-1#{S32}_S32_'t'||S32'nargs'||*{V}_V_'addr'||*{SYM#tag-_value#}_SYM#tag-_value#_'env'||*{V}_V_'module'|]
// file vm/neko.h line 158
struct anonymous_8;

// tag-#anon#ST[EN#anon_enum_VAL_INT=255_VAL_NULL=0_VAL_FLOAT=1_VAL_BOOL=2_VAL_STRING=3_VAL_OBJECT=4_VAL_ARRAY=5_VAL_FUNCTION=6_VAL_ABSTRACT=7_VAL_INT32=8_VAL_PRIMITIVE=22_VAL_JITFUN=38_VAL_32_BITS=-1#{S32}_S32_'t'||S8'c'||U24'_pad0'|]
// file vm/neko.h line 166
struct anonymous_5;

// tag-#anon#ST[EN#anon_enum_VAL_INT=255_VAL_NULL=0_VAL_FLOAT=1_VAL_BOOL=2_VAL_STRING=3_VAL_OBJECT=4_VAL_ARRAY=5_VAL_FUNCTION=6_VAL_ABSTRACT=7_VAL_INT32=8_VAL_PRIMITIVE=22_VAL_JITFUN=38_VAL_32_BITS=-1#{S32}_S32_'t'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'__zero'|]#}_SYM#tag-#anon#ST[S32'__zero'|]#_'kind'||*{V}_V_'data'|]
// file vm/neko.h line 176
struct anonymous_6;

// tag-#anon#ST[EN#anon_enum_VAL_INT=255_VAL_NULL=0_VAL_FLOAT=1_VAL_BOOL=2_VAL_STRING=3_VAL_OBJECT=4_VAL_ARRAY=5_VAL_FUNCTION=6_VAL_ABSTRACT=7_VAL_INT32=8_VAL_PRIMITIVE=22_VAL_JITFUN=38_VAL_32_BITS=-1#{S32}_S32_'t'||U32'_pad0'||*{SYM#tag-_value#}_SYM#tag-_value#_'ptr'|]
// file vm/neko.h line 171
struct anonymous_4;

// tag-#anon#ST[S32'__zero'|]
// file vm/neko.h line 121
struct anonymous;

// tag-#anon#ST[S32'id'||U32'_pad0'||*{SYM#tag-_value#}_SYM#tag-_value#_'v'|]
// file vm/neko.h line 124
struct anonymous_3;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_11;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_13;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_19;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_12;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_16;

// tag-#anon#ST[U32'l'||U32'h'|]
// file vm/builtins.c line 645
struct anonymous_1;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_9;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_18;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_21;

// tag-#anon#UN[F64'd'||SYM#tag-#anon#ST[U32'l'||U32'h'|]#'i'|]
// file vm/builtins.c line 643
union anonymous_2;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_22;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_buffer
// file vm/neko.h line 119
struct _buffer;

// tag-_custom_list
// file vm/vm.h line 34
struct _custom_list;

// tag-_klist
// file vm/alloc.c line 61
struct _klist;

// tag-_liblist
// file vm/load.c line 191
struct _liblist;

// tag-_mt_local
// file vm/neko.h line 195
struct _mt_local;

// tag-_mt_lock
// file vm/neko.h line 196
struct _mt_lock;

// tag-_neko_debug
// file vm/neko_mod.h line 26
struct _neko_debug;

// tag-_neko_module
// file vm/neko_mod.h line 31
struct _neko_module;

// tag-_neko_vm
// file vm/neko_vm.h line 29
struct _neko_vm;

// tag-_objtable
// file vm/neko.h line 129
struct _objtable;

// tag-_statinfos
// file vm/stats.c line 33
struct _statinfos;

// tag-_stringitem
// file vm/others.c line 113
struct _stringitem;

// tag-_value
// file vm/neko.h line 115
struct _value;

// tag-_vobject
// file vm/neko.h line 152
struct _vobject;

// tag-hcell
// file vm/neko.h line 182
struct hcell;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-vlist
// file vm/others.c line 205
struct vlist;

// tag-vlist2
// file vm/others.c line 210
struct vlist2;

// tag-vparam
// file vm/hash.c line 29
struct vparam;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// GC_clear_roots
// file /usr/include/gc/gc.h line 510
extern void GC_clear_roots(void);
// GC_collect_a_little
// file /usr/include/gc/gc.h line 726
extern signed int GC_collect_a_little(void);
// GC_dlopen
// file /usr/include/gc/gc_pthread_redirects.h line 38
extern void * GC_dlopen(const char *, signed int);
// GC_free
// file /usr/include/gc/gc.h line 435
extern void GC_free(void *);
// GC_gcollect
// file /usr/include/gc/gc.h line 542
extern void GC_gcollect(void);
// GC_get_free_bytes
// file /usr/include/gc/gc.h line 594
extern unsigned long int GC_get_free_bytes(void);
// GC_get_heap_size
// file /usr/include/gc/gc.h line 589
extern unsigned long int GC_get_heap_size(void);
// GC_init
// file /usr/include/gc/gc.h line 396
extern void GC_init(void);
// GC_malloc
// file /usr/include/gc/gc.h line 412
extern void * GC_malloc(unsigned long int);
// GC_malloc_atomic
// file /usr/include/gc/gc.h line 414
extern void * GC_malloc_atomic(unsigned long int);
// GC_malloc_atomic_ignore_off_page
// file /usr/include/gc/gc.h line 745
extern void * GC_malloc_atomic_ignore_off_page(unsigned long int);
// GC_malloc_ignore_off_page
// file /usr/include/gc/gc.h line 743
extern void * GC_malloc_ignore_off_page(unsigned long int);
// GC_malloc_uncollectable
// file /usr/include/gc/gc.h line 419
extern void * GC_malloc_uncollectable(unsigned long int);
// GC_pthread_create
// file /usr/include/gc/gc_pthread_redirects.h line 52
extern signed int GC_pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// GC_register_finalizer_no_order
// file /usr/include/gc/gc.h line 983
extern void GC_register_finalizer_no_order(void *, void (*)(void *, void *), void *, void (**)(void *, void *), void **);
// GC_set_warn_proc
// file /usr/include/gc/gc.h line 1157
extern void GC_set_warn_proc(void (*)(char *, unsigned long int));
// ThreadMain
// file vm/threads.c line 110
static void * ThreadMain(void *_p);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __on_finalize
// file vm/alloc.c line 344
static void __on_finalize(struct _value *v, void *f);
// _neko_failure
// file vm/neko.h line 435
void _neko_failure(struct _value *msg, const char *file, signed int line);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// add_rec
// file vm/builtins.c line 796
static void add_rec(struct hcell **cc, signed int size, struct hcell *c);
// append_array
// file vm/module.c line 224
static void append_array(struct _value **arr, signed int pos, struct _value *v);
// apply1
// file vm/alloc.c line 249
static struct _value * apply1(struct _value *p1);
// apply2
// file vm/alloc.c line 257
static struct _value * apply2(struct _value *p1, struct _value *p2);
// apply3
// file vm/alloc.c line 266
static struct _value * apply3(struct _value *p1, struct _value *p2, struct _value *p3);
// apply4
// file vm/alloc.c line 276
static struct _value * apply4(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4);
// apply5
// file vm/alloc.c line 287
static struct _value * apply5(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// bitcount
// file vm/interp.c line 501
static signed int bitcount(unsigned int k);
// buffer_append_new
// file vm/others.c line 136
static void buffer_append_new(struct _buffer *b, const char *s, signed int len);
// builtin_ablit
// file vm/builtins.c line 131
static struct _value * builtin_ablit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l);
// builtin_aconcat
// file vm/builtins.c line 153
static struct _value * builtin_aconcat(struct _value *arrs);
// builtin_acopy
// file vm/builtins.c line 81
static struct _value * builtin_acopy(struct _value *a);
// builtin_amake
// file vm/builtins.c line 66
static struct _value * builtin_amake(struct _value *size);
// builtin_apply
// file vm/builtins.c line 556
static struct _value * builtin_apply(struct _value **args, signed int nargs);
// builtin_array
// file vm/builtins.c line 54
static struct _value * builtin_array(struct _value **args, signed int nargs);
// builtin_asize
// file vm/builtins.c line 95
static struct _value * builtin_asize(struct _value *a);
// builtin_asub
// file vm/builtins.c line 107
static struct _value * builtin_asub(struct _value *a, struct _value *p, struct _value *l);
// builtin_call
// file vm/builtins.c line 489
static struct _value * builtin_call(struct _value *f, struct _value *ctx, struct _value *args);
// builtin_callstack
// file vm/builtins.c line 1197
static struct _value * builtin_callstack();
// builtin_closure
// file vm/builtins.c line 530
static struct _value * builtin_closure(struct _value **args, signed int nargs);
// builtin_compare
// file vm/builtins.c line 1157
static struct _value * builtin_compare(struct _value *a, struct _value *b);
// builtin_excstack
// file vm/builtins.c line 1189
static struct _value * builtin_excstack();
// builtin_fasthash
// file vm/builtins.c line 422
static struct _value * builtin_fasthash(struct _value *f);
// builtin_field
// file vm/builtins.c line 439
static struct _value * builtin_field(struct _value *f);
// builtin_float
// file vm/builtins.c line 732
static struct _value * builtin_float(struct _value *f);
// builtin_getkind
// file vm/builtins.c line 749
static struct _value * builtin_getkind(struct _value *v);
// builtin_hadd
// file vm/builtins.c line 995
static struct _value * builtin_hadd(struct _value *vh, struct _value *key, struct _value *val);
// builtin_hash
// file vm/builtins.c line 413
static struct _value * builtin_hash(struct _value *f);
// builtin_hcount
// file vm/builtins.c line 1042
static struct _value * builtin_hcount(struct _value *vh);
// builtin_hget
// file vm/builtins.c line 838
static struct _value * builtin_hget(struct _value *vh, struct _value *key, struct _value *cmp);
// builtin_hiter
// file vm/builtins.c line 1021
static struct _value * builtin_hiter(struct _value *vh, struct _value *f);
// builtin_hkey
// file vm/builtins.c line 771
static struct _value * builtin_hkey(struct _value *v);
// builtin_hmem
// file vm/builtins.c line 870
static struct _value * builtin_hmem(struct _value *vh, struct _value *key, struct _value *cmp);
// builtin_hnew
// file vm/builtins.c line 781
static struct _value * builtin_hnew(struct _value *size);
// builtin_hremove
// file vm/builtins.c line 902
static struct _value * builtin_hremove(struct _value *vh, struct _value *key, struct _value *cmp);
// builtin_hresize
// file vm/builtins.c line 810
static struct _value * builtin_hresize(struct _value *vh, struct _value *size);
// builtin_hset
// file vm/builtins.c line 949
static struct _value * builtin_hset(struct _value *vh, struct _value *key, struct _value *val, struct _value *cmp);
// builtin_hsize
// file vm/builtins.c line 1051
static struct _value * builtin_hsize(struct _value *vh);
// builtin_iadd
// file vm/builtins.c line 613
static struct _value * builtin_iadd(struct _value *a, struct _value *b);
// builtin_idiv
// file vm/builtins.c line 637
static struct _value * builtin_idiv(struct _value *a, struct _value *b);
// builtin_imult
// file vm/builtins.c line 629
static struct _value * builtin_imult(struct _value *a, struct _value *b);
// builtin_int
// file vm/builtins.c line 689
static struct _value * builtin_int(struct _value *f);
// builtin_isinfinite
// file vm/builtins.c line 672
static struct _value * builtin_isinfinite(struct _value *f);
// builtin_iskind
// file vm/builtins.c line 760
static struct _value * builtin_iskind(struct _value *v, struct _value *k);
// builtin_isnan
// file vm/builtins.c line 655
static struct _value * builtin_isnan(struct _value *f);
// builtin_istrue
// file vm/builtins.c line 1098
static struct _value * builtin_istrue(struct _value *f);
// builtin_isub
// file vm/builtins.c line 621
static struct _value * builtin_isub(struct _value *a, struct _value *b);
// builtin_nargs
// file vm/builtins.c line 480
static struct _value * builtin_nargs(struct _value *f);
// builtin_new
// file vm/builtins.c line 329
static struct _value * builtin_new(struct _value *o);
// builtin_not
// file vm/builtins.c line 1106
static struct _value * builtin_not(struct _value *f);
// builtin_objcall
// file vm/builtins.c line 362
static struct _value * builtin_objcall(struct _value *o, struct _value *f, struct _value *args);
// builtin_objfield
// file vm/builtins.c line 374
static struct _value * builtin_objfield(struct _value *o, struct _value *f);
// builtin_objfields
// file vm/builtins.c line 397
static struct _value * builtin_objfields(struct _value *o);
// builtin_objfields_rec
// file vm/builtins.c line 389
static void builtin_objfields_rec(struct _value *d, signed int id, void *a);
// builtin_objget
// file vm/builtins.c line 339
static struct _value * builtin_objget(struct _value *o, struct _value *f);
// builtin_objgetproto
// file vm/builtins.c line 463
static struct _value * builtin_objgetproto(struct _value *o);
// builtin_objremove
// file vm/builtins.c line 383
static struct _value * builtin_objremove(struct _value *o, struct _value *f);
// builtin_objset
// file vm/builtins.c line 350
static struct _value * builtin_objset(struct _value *o, struct _value *f, struct _value *v);
// builtin_objsetproto
// file vm/builtins.c line 448
static struct _value * builtin_objsetproto(struct _value *o, struct _value *p);
// builtin_pcompare
// file vm/builtins.c line 1166
static struct _value * builtin_pcompare(struct _value *a, struct _value *b);
// builtin_print
// file vm/builtins.c line 1062
static struct _value * builtin_print(struct _value **args, signed int nargs);
// builtin_rethrow
// file vm/builtins.c line 1089
static struct _value * builtin_rethrow(struct _value *v);
// builtin_sblit
// file vm/builtins.c line 279
static struct _value * builtin_sblit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l);
// builtin_scopy
// file vm/builtins.c line 213
static struct _value * builtin_scopy(struct _value *s);
// builtin_setresolver
// file vm/builtins.c line 1213
static struct _value * builtin_setresolver(struct _value *f);
// builtin_sfind
// file vm/builtins.c line 302
static struct _value * builtin_sfind(struct _value *src, struct _value *pos, struct _value *pat);
// builtin_sget
// file vm/builtins.c line 241
static struct _value * builtin_sget(struct _value *s, struct _value *p);
// builtin_smake
// file vm/builtins.c line 192
static struct _value * builtin_smake(struct _value *l);
// builtin_sset
// file vm/builtins.c line 258
static struct _value * builtin_sset(struct _value *s, struct _value *p, struct _value *c);
// builtin_ssize
// file vm/builtins.c line 204
static struct _value * builtin_ssize(struct _value *s);
// builtin_ssub
// file vm/builtins.c line 225
static struct _value * builtin_ssub(struct _value *s, struct _value *p, struct _value *l);
// builtin_string
// file vm/builtins.c line 182
static struct _value * builtin_string(struct _value *v);
// builtin_throw
// file vm/builtins.c line 1080
static struct _value * builtin_throw(struct _value *v);
// builtin_typeof
// file vm/builtins.c line 1127
static struct _value * builtin_typeof(struct _value *v);
// builtin_varargs
// file vm/builtins.c line 599
static struct _value * builtin_varargs(struct _value *f);
// builtin_version
// file vm/builtins.c line 1205
static struct _value * builtin_version();
// clean_c_stack
// file vm/threads.c line 103
static signed int clean_c_stack(signed int n, void *f);
// close_module
// file vm/load.c line 187
static void close_module(void *p);
// closure_callback
// file vm/builtins.c line 502
static struct _value * closure_callback(struct _value **args, signed int nargs);
// cmp
// file vm/stats.c line 133
static signed int cmp(struct _statinfos *a, struct _statinfos *b);
// default_printer
// file vm/interp.c line 86
static void default_printer(const char *s, signed int len, void *out);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_nothing
// file vm/threads.c line 175
static signed int do_nothing(char (*sb)[64l]);
// executable_path
// file vm/main.c line 56
static char * executable_path();
// execute_file
// file vm/main.c line 196
static signed int execute_file(struct _neko_vm *vm, char *file, struct _value *mload);
// failure_to_string
// file vm/others.c line 499
static struct _value * failure_to_string();
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcmp
// file vm/others.c line 44
static inline signed int fcmp(double a, double b);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fmod
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 187
extern double fmod(double, double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_builtin
// file vm/module.c line 121
static struct _value * get_builtin(struct _neko_module *m, signed int id);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// handle_signal
// file vm/main.c line 214
static void handle_signal(signed int signal);
// hash_obj_rec
// file vm/hash.c line 106
static void hash_obj_rec(struct _value *v, signed int f, void *_p);
// hash_rec
// file vm/hash.c line 39
static void hash_rec(struct _value *v, signed int *h, struct vlist *l);
// icmp
// file vm/others.c line 40
static inline signed int icmp(signed int a, signed int b);
// init_path
// file vm/load.c line 265
static struct _value * init_path(const char *path);
// jit_run
// file vm/interp.c line 265
static signed long int jit_run(struct _neko_vm *vm, struct anonymous_8 *acc);
// load_primitive
// file vm/load.c line 199
static void * load_primitive(const char *prim, signed int nargs, struct _value *path, struct _liblist **libs);
// load_primitive::1::ptr_object
//
struct _value * ptr_object();
// loader_loadmodule
// file vm/load.c line 371
static struct _value * loader_loadmodule(struct _value *mname, struct _value *vthis);
// loader_loadmodule::1::1::r_object
//
signed int r_object(void *, void *, signed int);
// loader_loadprim
// file vm/load.c line 337
static struct _value * loader_loadprim(struct _value *prim, struct _value *nargs);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// neko_alloc
// file vm/alloc.c line 164
char * neko_alloc(unsigned int nbytes);
// neko_alloc_abstract
// file vm/alloc.c line 215
struct _value * neko_alloc_abstract(struct anonymous *k, void *data);
// neko_alloc_apply
// file vm/alloc.c line 299
extern struct _value * neko_alloc_apply(signed int nargs, struct _value *env);
// neko_alloc_array
// file vm/neko.h line 400
struct _value * neko_alloc_array(unsigned int n);
// neko_alloc_buffer
// file vm/neko.h line 420
struct _buffer * neko_alloc_buffer(const char *init);
// neko_alloc_empty_string
// file vm/alloc.c line 172
struct _value * neko_alloc_empty_string(unsigned int size);
// neko_alloc_field
// file vm/neko.h line 396
void neko_alloc_field(struct _value *obj, signed int f, struct _value *v);
// neko_alloc_float
// file vm/alloc.c line 190
struct _value * neko_alloc_float(double f);
// neko_alloc_function
// file vm/neko.h line 418
struct _value * neko_alloc_function(void *c_prim, unsigned int nargs, const char *name);
// neko_alloc_int32
// file vm/alloc.c line 197
struct _value * neko_alloc_int32(signed int i);
// neko_alloc_local
// file vm/neko.h line 438
struct _mt_local * neko_alloc_local();
// neko_alloc_lock
// file vm/neko.h line 443
struct _mt_lock * neko_alloc_lock();
// neko_alloc_module_function
// file vm/alloc.c line 236
struct _value * neko_alloc_module_function(void *m, signed long int pos, signed int nargs);
// neko_alloc_object
// file vm/alloc.c line 316
struct _value * neko_alloc_object(struct _value *cpy);
// neko_alloc_private
// file vm/alloc.c line 168
char * neko_alloc_private(unsigned int nbytes);
// neko_alloc_root
// file vm/alloc.c line 357
struct _value ** neko_alloc_root(unsigned int nvals);
// neko_alloc_string
// file vm/neko.h line 388
struct _value * neko_alloc_string(const char *str);
// neko_append_int
// file vm/others.c line 323
struct _value * neko_append_int(struct _neko_vm *vm, struct _value *str, signed int x, signed int way);
// neko_append_strings
// file vm/others.c line 339
struct _value * neko_append_strings(struct _value *s1, struct _value *s2);
// neko_buffer_append
// file vm/neko.h line 421
void neko_buffer_append(struct _buffer *b, const char *s);
// neko_buffer_append_char
// file vm/neko.h line 423
void neko_buffer_append_char(struct _buffer *b, char c);
// neko_buffer_append_sub
// file vm/neko.h line 422
void neko_buffer_append_sub(struct _buffer *b, const char *s, signed long int _len);
// neko_buffer_to_string
// file vm/neko.h line 424
struct _value * neko_buffer_to_string(struct _buffer *b);
// neko_call_stack
// file vm/neko_vm.h line 47
struct _value * neko_call_stack(struct _neko_vm *vm);
// neko_can_jit
// file vm/jit_x86.c line 2778
signed int neko_can_jit();
// neko_check_stack
// file vm/module.c line 138
static signed int neko_check_stack(struct _neko_module *m, unsigned char *tmp, unsigned int i, signed int stack, signed int istack);
// neko_copy_string
// file vm/alloc.c line 333
struct _value * neko_copy_string(const char *str, signed long int strlen);
// neko_default_loader
// file vm/neko_vm.h line 54
struct _value * neko_default_loader(char **argv, signed int argc);
// neko_exc_stack
// file vm/neko_vm.h line 46
struct _value * neko_exc_stack(struct _neko_vm *vm);
// neko_execute_self
// file vm/main.c line 165
signed int neko_execute_self(struct _neko_vm *vm, struct _value *mload);
// neko_file_reader
// file vm/neko_mod.h line 60
signed int neko_file_reader(void *p, void *buf, signed int size);
// neko_flush_stack
// file vm/interp.c line 510
static struct _value * neko_flush_stack(signed long int *cspup, signed long int *csp, struct _value *old);
// neko_free_jit
// file vm/jit_x86.c line 2775
void neko_free_jit();
// neko_free_local
// file vm/neko.h line 441
void neko_free_local(struct _mt_local *l);
// neko_free_lock
// file vm/neko.h line 447
void neko_free_lock(struct _mt_lock *l);
// neko_free_root
// file vm/alloc.c line 361
void neko_free_root(struct _value **v);
// neko_gc_init
// file vm/alloc.c line 119
void neko_gc_init();
// neko_gc_loop
// file vm/alloc.c line 151
void neko_gc_loop();
// neko_gc_major
// file vm/alloc.c line 155
void neko_gc_major();
// neko_gc_stats
// file vm/alloc.c line 159
void neko_gc_stats(signed int *heap, signed int *free);
// neko_get_ttable
// file vm/vm.h line 70
extern signed long int * neko_get_ttable();
// neko_global_free
// file vm/neko_vm.h line 36
void neko_global_free();
// neko_global_init
// file vm/neko_vm.h line 35
void neko_global_init();
// neko_has_embedded_module
// file vm/main.c line 98
signed int neko_has_embedded_module(struct _neko_vm *vm);
// neko_init_builtins
// file vm/builtins.c line 1227
void neko_init_builtins();
// neko_init_jit
// file vm/jit_x86.c line 2772
void neko_init_jit();
// neko_interp
// file vm/vm.h line 69
extern struct _value * neko_interp(struct _neko_vm *vm, void *_m, signed long int acc, signed long int *pc);
// neko_interp_loop
// file vm/interp.c line 613
signed long int neko_interp_loop(struct _neko_vm *vm, struct _neko_module *m, signed long int _acc, signed long int *_pc);
// neko_is_big_endian
// file vm/module.c line 100
signed int neko_is_big_endian();
// neko_kind_share
// file vm/alloc.c line 430
void neko_kind_share(struct anonymous **k, const char *name);
// neko_local_get
// file vm/neko.h line 439
void * neko_local_get(struct _mt_local *l);
// neko_local_set
// file vm/neko.h line 440
void neko_local_set(struct _mt_local *l, void *v);
// neko_lock_acquire
// file vm/neko.h line 444
void neko_lock_acquire(struct _mt_lock *l);
// neko_lock_release
// file vm/neko.h line 446
void neko_lock_release(struct _mt_lock *l);
// neko_lock_try
// file vm/threads.c line 327
signed int neko_lock_try(struct _mt_lock *l);
// neko_module_jit
// file vm/jit_x86.c line 2782
void neko_module_jit(struct _neko_module *m);
// neko_process_trap
// file vm/interp.c line 588
void neko_process_trap(struct _neko_vm *vm);
// neko_read_module
// file vm/neko_mod.h line 59
struct _neko_module * neko_read_module(signed int (*r)(void *, void *, signed int), void *p, struct _value *loader);
// neko_read_module::r_object
//
signed int r_object(void *, void *, signed int);
// neko_select_file
// file vm/load.c line 138
struct _value * neko_select_file(struct _value *path, const char *file, const char *ext);
// neko_set_stack_base
// file vm/alloc.c line 426
void neko_set_stack_base(void *s);
// neko_setup_trap
// file vm/interp.c line 575
void neko_setup_trap(struct _neko_vm *vm);
// neko_stack_expand
// file vm/others.c line 348
signed int neko_stack_expand(signed long int *sp, signed long int *csp, struct _neko_vm *vm);
// neko_stats_build
// file vm/stats.c line 183
struct _value * neko_stats_build(struct _neko_vm *vm);
// neko_stats_measure
// file vm/stats.c line 79
void neko_stats_measure(struct _neko_vm *vm, const char *kind, signed int start);
// neko_string_reader
// file vm/module.c line 621
signed int neko_string_reader(void *p, void *buf, signed int size);
// neko_thread_blocking
// file vm/threads.c line 181
void neko_thread_blocking(void (*f)(void *), void *p);
// neko_thread_blocking::1::do_blocking_object
//
void do_blocking_object(void (*)(void *), void *);
// neko_thread_blocking::1::end_object
//
signed int end_object();
// neko_thread_blocking::1::start_object
//
signed int start_object();
// neko_thread_blocking::f_object
//
void f_object(void *);
// neko_thread_create
// file vm/threads.c line 128
signed int neko_thread_create(void (*init)(void *), void (*main)(void *), void *param, void **handle);
// neko_thread_create::init_object
//
void init_object(void *);
// neko_thread_create::main_object
//
void main_object(void *);
// neko_thread_register
// file vm/threads.c line 211
signed int neko_thread_register(signed int t);
// neko_thread_register::1::get_sb_object
//
signed int get_sb_object(char (*)[64l]);
// neko_thread_register::1::my_thread_object
//
signed int my_thread_object(char (*)[64l]);
// neko_thread_register::1::unreg_my_thread_object
//
signed int unreg_my_thread_object();
// neko_val_buffer
// file vm/neko.h line 425
void neko_val_buffer(struct _buffer *b, struct _value *v);
// neko_val_call0
// file vm/callback.c line 145
struct _value * neko_val_call0(struct _value *f);
// neko_val_call1
// file vm/neko.h line 404
struct _value * neko_val_call1(struct _value *f, struct _value *v);
// neko_val_call2
// file vm/neko.h line 405
struct _value * neko_val_call2(struct _value *f, struct _value *v1, struct _value *v2);
// neko_val_call3
// file vm/callback.c line 158
struct _value * neko_val_call3(struct _value *f, struct _value *arg1, struct _value *arg2, struct _value *arg3);
// neko_val_callEx
// file vm/neko.h line 412
struct _value * neko_val_callEx(struct _value *vthis, struct _value *f, struct _value **args, signed int nargs, struct _value **exc);
// neko_val_callN
// file vm/neko.h line 407
struct _value * neko_val_callN(struct _value *f, struct _value **args, signed int nargs);
// neko_val_compare
// file vm/neko.h line 427
signed int neko_val_compare(struct _value *a, struct _value *b);
// neko_val_field
// file vm/neko.h line 394
struct _value * neko_val_field(struct _value *_o, signed int id);
// neko_val_field_name
// file vm/neko.h line 398
struct _value * neko_val_field_name(signed int id);
// neko_val_gc
// file vm/alloc.c line 348
void neko_val_gc(struct _value *v, void (*f)(struct _value *));
// neko_val_gc::f_object
//
void f_object(struct _value *);
// neko_val_hash
// file vm/neko.h line 432
signed int neko_val_hash(struct _value *v);
// neko_val_id
// file vm/neko.h line 393
signed int neko_val_id(const char *name);
// neko_val_iter_fields
// file vm/others.c line 465
void neko_val_iter_fields(struct _value *o, void (*f)(struct _value *, signed int, void *), void *p);
// neko_val_iter_fields::f_object
//
void f_object(struct _value *, signed int, void *);
// neko_val_ocall0
// file vm/neko.h line 408
struct _value * neko_val_ocall0(struct _value *o, signed int f);
// neko_val_ocall1
// file vm/callback.c line 167
struct _value * neko_val_ocall1(struct _value *o, signed int f, struct _value *arg);
// neko_val_ocall2
// file vm/callback.c line 171
struct _value * neko_val_ocall2(struct _value *o, signed int f, struct _value *arg1, struct _value *arg2);
// neko_val_ocallN
// file vm/neko.h line 411
struct _value * neko_val_ocallN(struct _value *o, signed int f, struct _value **args, signed int nargs);
// neko_val_print
// file vm/neko.h line 428
void neko_val_print(struct _value *v);
// neko_val_rethrow
// file vm/neko.h line 431
void neko_val_rethrow(struct _value *v);
// neko_val_this
// file vm/callback.c line 176
struct _value * neko_val_this();
// neko_val_throw
// file vm/neko.h line 430
void neko_val_throw(struct _value *v);
// neko_vm_alloc
// file vm/neko_vm.h line 44
struct _neko_vm * neko_vm_alloc(void *custom);
// neko_vm_current
// file vm/interp.c line 160
struct _neko_vm * neko_vm_current();
// neko_vm_custom
// file vm/interp.c line 164
void * neko_vm_custom(struct _neko_vm *vm, struct anonymous *k);
// neko_vm_dump_stack
// file vm/interp.c line 547
void neko_vm_dump_stack(struct _neko_vm *vm);
// neko_vm_execute
// file vm/interp.c line 229
struct _value * neko_vm_execute(struct _neko_vm *vm, void *_m);
// neko_vm_jit
// file vm/neko_vm.h line 52
signed int neko_vm_jit(struct _neko_vm *vm, signed int enable_jit);
// neko_vm_redirect
// file vm/interp.c line 210
void neko_vm_redirect(struct _neko_vm *vm, void (*print)(const char *, signed int, void *), void *param);
// neko_vm_redirect::print_object
//
void print_object(const char *, signed int, void *);
// neko_vm_select
// file vm/neko_vm.h line 51
void neko_vm_select(struct _neko_vm *vm);
// neko_vm_set_custom
// file vm/interp.c line 174
void neko_vm_set_custom(struct _neko_vm *vm, struct anonymous *k, void *v);
// neko_vm_set_stats
// file vm/neko_vm.h line 56
void neko_vm_set_stats(struct _neko_vm *vm, void (*fstats)(struct _neko_vm *, const char *, signed int), void (*pstats)(struct _neko_vm *, const char *, signed int));
// neko_vm_set_stats::fstats_object
//
void fstats_object(struct _neko_vm *, const char *, signed int);
// neko_vm_set_stats::pstats_object
//
void pstats_object(struct _neko_vm *, const char *, signed int);
// neko_vm_trusted
// file vm/interp.c line 145
signed int neko_vm_trusted(struct _neko_vm *vm, signed int t);
// null_warn_proc
// file vm/alloc.c line 111
static void null_warn_proc(char *msg, signed int arg);
// open_module
// file vm/load.c line 169
static void open_module(struct _value *path, const char *mname, signed int (**r)(void *, void *, signed int), void **p);
// open_module::r_object_object
//
signed int r_object_object(void *, void *, signed int);
// otable_copy
// file vm/objtable.h line 80
void otable_copy(struct _objtable *t, struct _objtable *target);
// otable_find
// file vm/objtable.h line 31
static inline struct _value ** otable_find(struct _objtable *t, signed int id);
// otable_find_link1
// file vm/objtable.h line 31
static inline struct _value ** otable_find_link1(struct _objtable *t_link1, signed int id_link1);
// otable_find_link2
// file vm/objtable.h line 31
static inline struct _value ** otable_find_link2(struct _objtable *t_link2, signed int id_link2);
// otable_get
// file vm/objtable.h line 53
static inline struct _value * otable_get(struct _objtable *t, signed int id);
// otable_init
// file vm/objtable.h line 26
static inline void otable_init(struct _objtable *t);
// otable_iter
// file vm/objtable.h line 81
void otable_iter(struct _objtable *t, void (*f)(struct _value *, signed int, void *), void *p);
// otable_iter::f_object
//
void f_object(struct _value *, signed int, void *);
// otable_optimize
// file vm/objtable.c line 53
void otable_optimize(struct _objtable *t);
// otable_remove
// file vm/objtable.h line 76
signed int otable_remove(struct _objtable *t, signed int id);
// otable_replace
// file vm/objtable.h line 75
void otable_replace(struct _objtable *t, signed int id, struct _value *data);
// precise_timer
// file vm/stats.c line 49
static signed int precise_timer();
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_key_delete
// file /usr/include/pthread.h line 1118
extern signed int pthread_key_delete(unsigned int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_22 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_22 *, const union anonymous_21 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_22 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_22 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_22 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous_21 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous_21 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous_21 *, signed int);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// read_bytecode
// file vm/main.c line 150
static struct _value * read_bytecode(struct _value *str, struct _value *pos, struct _value *len);
// read_debug_infos
// file vm/module.c line 244
static void * read_debug_infos(signed int (*r)(void *, void *, signed int), void *p, char *tmp, struct _neko_module *m);
// read_debug_infos::r_object
//
signed int r_object(void *, void *, signed int);
// read_long
// file vm/module.c line 68
static void read_long(signed int (*r)(void *, void *, signed int), void *p, unsigned int *i);
// read_long::r_object
//
signed int r_object(void *, void *, signed int);
// read_short
// file vm/module.c line 76
static void read_short(signed int (*r)(void *, void *, signed int), void *p, unsigned short int *i);
// read_short::r_object
//
signed int r_object(void *, void *, signed int);
// read_string
// file vm/module.c line 108
static signed int read_string(signed int (*r)(void *, void *, signed int), void *p, char *buf);
// read_string::r_object
//
signed int r_object(void *, void *, signed int);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// redirected_print
// file vm/interp.c line 205
static void redirected_print(const char *s, signed int size, void *_p);
// report
// file vm/main.c line 120
static void report(struct _neko_vm *vm, struct _value *exc, signed int isexc);
// scmp
// file vm/others.c line 48
static inline signed int scmp(const char *s1, signed int l1, const char *s2, signed int l2);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_10 *);
// sort
// file vm/stats.c line 138
static struct _statinfos * sort(struct _statinfos *list);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stats_proxy
// file vm/load.c line 327
static struct _value * stats_proxy(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5, struct _value *p6);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// val_buffer_fields
// file vm/others.c line 219
static void val_buffer_fields(struct _value *v, signed int f, void *_l);
// val_buffer_rec
// file vm/others.c line 232
static void val_buffer_rec(struct _buffer *b, struct _value *v, struct vlist *stack);
// varargs_callback
// file vm/builtins.c line 583
static struct _value * varargs_callback(struct _value **args, signed int nargs);

struct anonymous_0
{
  // cells
  struct hcell **cells;
  // ncells
  signed int ncells;
  // nitems
  signed int nitems;
};

struct anonymous_20
{
  // p
  char *p;
  // len
  signed int len;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_22
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_23
{
  // init
  void (*init)(void *);
  // main
  void (*main)(void *);
  // param
  void *param;
  // lock
  union anonymous_22 lock;
};

struct anonymous_24
{
  // prev
  void (*prev)(const char *, signed int, void *);
  // prev_param
  void *prev_param;
  // cur
  void (*cur)(const char *, signed int, void *);
  // cur_param
  void *cur_param;
};

struct anonymous_17
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_15
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_10
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_25
{
  // t
  enum anonymous_7 t;
  // f
  double f;
};

struct anonymous_26
{
  // t
  enum anonymous_7 t;
  // i
  signed int i;
};

struct anonymous_8
{
  // t
  enum anonymous_7 t;
  // nargs
  signed int nargs;
  // addr
  void *addr;
  // env
  struct _value *env;
  // module
  void *module;
};

struct anonymous_5
{
  // t
  enum anonymous_7 t;
  // c
  char c;
};

struct anonymous_6
{
  // t
  enum anonymous_7 t;
  // kind
  struct anonymous *kind;
  // data
  void *data;
};

struct anonymous_4
{
  // t
  enum anonymous_7 t;
  // ptr
  struct _value *ptr;
};

struct anonymous
{
  // __zero
  signed int __zero;
};

struct anonymous_3
{
  // id
  signed int id;
  // v
  struct _value *v;
};

struct anonymous_11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_13
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_12
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_16
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_18
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_11 _kill;
  // _timer
  struct anonymous_12 _timer;
  // _rt
  struct anonymous_13 _rt;
  // _sigchld
  struct anonymous_14 _sigchld;
  // _sigfault
  struct anonymous_15 _sigfault;
  // _sigpoll
  struct anonymous_16 _sigpoll;
  // _sigsys
  struct anonymous_17 _sigsys;
};

struct anonymous_19
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_18 _sifields;
};

struct anonymous_1
{
  // l
  unsigned int l;
  // h
  unsigned int h;
};

union anonymous_9
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_19 *, void *);
};

union anonymous_21
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_2
{
  // d
  double d;
  // i
  struct anonymous_1 i;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_10 __saved_mask;
};

struct _buffer
{
  // totlen
  signed int totlen;
  // blen
  signed int blen;
  // data
  struct _stringitem *data;
};

struct _custom_list
{
  // tag
  struct anonymous *tag;
  // custom
  void *custom;
  // next
  struct _custom_list *next;
};

struct _klist
{
  // name
  const char *name;
  // k
  struct anonymous *k;
  // next
  struct _klist *next;
};

struct _liblist
{
  // name
  char *name;
  // handle
  void *handle;
  // next
  struct _liblist *next;
};

struct _mt_local
{
  // key
  unsigned int key;
};

struct _mt_lock
{
  // lock
  union anonymous_22 lock;
};

struct _neko_debug
{
  // base
  signed int base;
  // bits
  unsigned int bits;
};

struct _neko_module
{
  // jit
  void *jit;
  // nglobals
  unsigned int nglobals;
  // nfields
  unsigned int nfields;
  // codesize
  unsigned int codesize;
  // name
  struct _value *name;
  // globals
  struct _value **globals;
  // fields
  struct _value **fields;
  // loader
  struct _value *loader;
  // exports
  struct _value *exports;
  // dbgtbl
  struct _value *dbgtbl;
  // dbgidxs
  struct _neko_debug *dbgidxs;
  // code
  signed long int *code;
  // jit_gc
  struct _value *jit_gc;
};

struct _neko_vm
{
  // sp
  signed long int *sp;
  // csp
  signed long int *csp;
  // env
  struct _value *env;
  // vthis
  struct _value *vthis;
  // spmin
  signed long int *spmin;
  // spmax
  signed long int *spmax;
  // trap
  signed long int trap;
  // jit_val
  void *jit_val;
  // start
  struct __jmp_buf_tag start[1l];
  // c_stack_max
  void *c_stack_max;
  // run_jit
  signed int run_jit;
  // exc_stack
  struct _value *exc_stack;
  // print
  void (*print)(const char *, signed int, void *);
  // print_param
  void *print_param;
  // clist
  struct _custom_list *clist;
  // resolver
  struct _value *resolver;
  // tmp
  char tmp[100l];
  // trusted_code
  signed int trusted_code;
  // fstats
  void (*fstats)(struct _neko_vm *, const char *, signed int);
  // pstats
  void (*pstats)(struct _neko_vm *, const char *, signed int);
};

struct _objtable
{
  // count
  signed int count;
  // cells
  struct anonymous_3 *cells;
};

struct _statinfos
{
  // kind
  const char *kind;
  // ksize
  signed int ksize;
  // ncalls
  signed int ncalls;
  // nerrors
  signed int nerrors;
  // subtime
  signed int subtime;
  // totaltime
  signed int totaltime;
  // starttime
  signed int starttime;
  // stack
  struct _statinfos *stack;
  // next
  struct _statinfos *next;
};

struct _stringitem
{
  // str
  char *str;
  // size
  signed int size;
  // len
  signed int len;
  // next
  struct _stringitem *next;
};

struct _value
{
  // t
  enum anonymous_7 t;
};

struct _vobject
{
  // t
  enum anonymous_7 t;
  // table
  struct _objtable table;
  // proto
  struct _vobject *proto;
};

struct hcell
{
  // hkey
  signed int hkey;
  // key
  struct _value *key;
  // val
  struct _value *val;
  // next
  struct hcell *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_9 __sigaction_handler;
  // sa_mask
  struct anonymous_10 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct vlist
{
  // v
  struct _value *v;
  // next
  struct vlist *next;
};

struct vlist2
{
  // v
  struct _value *v;
  // next
  struct vlist *next;
  // b
  struct _buffer *b;
  // prev
  signed int prev;
};

struct vparam
{
  // h
  signed int *h;
  // l
  struct vlist l;
};


// GC_all_interior_pointers
// file /usr/include/gc/gc.h line 143
extern signed int GC_all_interior_pointers;
// GC_java_finalization
// file /usr/include/gc/gc.h line 169
extern signed int GC_java_finalization;
// GC_no_dls
// file /usr/include/gc/gc.h line 257
extern signed int GC_no_dls;
// NEKO_TYPEOF
// file vm/interp.c line 74
struct _value *NEKO_TYPEOF[9l] = { (struct _value *)(signed long int)((signed int)0 << 1 | 1),
    (struct _value *)(signed long int)((signed int)2 << 1 | 1),
    (struct _value *)(signed long int)((signed int)3 << 1 | 1),
    (struct _value *)(signed long int)((signed int)4 << 1 | 1),
    (struct _value *)(signed long int)((signed int)5 << 1 | 1),
    (struct _value *)(signed long int)((signed int)6 << 1 | 1),
    (struct _value *)(signed long int)((signed int)7 << 1 | 1),
    (struct _value *)(signed long int)((signed int)8 << 1 | 1),
    (struct _value *)(signed long int)((signed int)1 << 1 | 1) };
// __kind_k_hash
// file vm/others.c line 31
signed long int __kind_k_hash = (signed long int)0;
// __kind_k_loader_libs
// file vm/load.c line 36
signed long int __kind_k_loader_libs = (signed long int)0;
// __kind_k_old_int32
// file vm/builtins.c line 37
signed long int __kind_k_old_int32 = (signed long int)0;
// __kind_neko_k_kind
// file vm/builtins.c line 36
signed long int __kind_neko_k_kind = (signed long int)0;
// __kind_neko_kind_module
// file vm/module.c line 31
signed long int __kind_neko_kind_module = (signed long int)0;
// apply_string
// file vm/alloc.c line 68
static struct _value **apply_string = (struct _value **)(void *)0;
// callback_return
// file vm/alloc.c line 69
signed long int *callback_return;
// op_last
// file vm/alloc.c line 67
static signed long int op_last = (signed long int)67;
// callback_return
// file vm/alloc.c line 69
signed long int *callback_return = &op_last;
// empty_array
// file vm/alloc.c line 80
static struct anonymous_4 empty_array = { .t=(enum anonymous_7)VAL_ARRAY, .ptr=(struct _value *)(void *)0 };
// empty_string
// file vm/alloc.c line 81
static struct anonymous_5 empty_string = { .t=(enum anonymous_7)VAL_STRING, .c=(char)0 };
// id_add
// file vm/alloc.c line 91
signed int id_add;
// id_cache
// file vm/alloc.c line 87
signed int id_cache;
// id_compare
// file vm/alloc.c line 83
signed int id_compare;
// id_div
// file vm/alloc.c line 91
signed int id_div;
// id_exports
// file vm/alloc.c line 86
signed int id_exports;
// id_get
// file vm/alloc.c line 90
signed int id_get;
// id_loader
// file vm/alloc.c line 85
signed int id_loader;
// id_loader_libs
// file vm/alloc.c line 89
signed int id_loader_libs;
// id_mod
// file vm/alloc.c line 91
signed int id_mod;
// id_mult
// file vm/alloc.c line 91
signed int id_mult;
// id_path
// file vm/alloc.c line 88
signed int id_path;
// id_radd
// file vm/alloc.c line 91
signed int id_radd;
// id_rdiv
// file vm/alloc.c line 91
signed int id_rdiv;
// id_rmod
// file vm/alloc.c line 91
signed int id_rmod;
// id_rmult
// file vm/alloc.c line 91
signed int id_rmult;
// id_rsub
// file vm/alloc.c line 91
signed int id_rsub;
// id_set
// file vm/alloc.c line 90
signed int id_set;
// id_string
// file vm/alloc.c line 84
signed int id_string;
// id_sub
// file vm/alloc.c line 91
signed int id_sub;
// init_done
// file vm/stats.c line 47
static signed int init_done = 0;
// jit_boot_seq
// file vm/jit_x86.c line 2769
char *jit_boot_seq = (char *)(void *)0;
// jit_handle_trap
// file vm/jit_x86.c line 2770
char *jit_handle_trap;
// jit_handle_trap
// file vm/jit_x86.c line 2770
char *jit_handle_trap = (char *)&jit_boot_seq;
// k_loader_libs
// file vm/load.c line 36
struct anonymous *k_loader_libs;
// k_loader_libs
// file vm/load.c line 36
struct anonymous *k_loader_libs = (struct anonymous *)&__kind_k_loader_libs;
// k_old_int32
// file vm/builtins.c line 37
struct anonymous *k_old_int32;
// k_old_int32
// file vm/builtins.c line 37
struct anonymous *k_old_int32 = (struct anonymous *)&__kind_k_old_int32;
// kind_names
// file vm/alloc.c line 82
static struct _klist **kind_names = (struct _klist **)(void *)0;
// list
// file vm/stats.c line 45
static struct _statinfos *list = (struct _statinfos *)(void *)0;
// neko_builtins
// file vm/alloc.c line 70
struct _value **neko_builtins = (struct _value **)(void *)0;
// neko_fields
// file vm/alloc.c line 71
struct _objtable *neko_fields = (struct _objtable *)(void *)0;
// neko_fields_lock
// file vm/alloc.c line 72
struct _mt_lock *neko_fields_lock = (struct _mt_lock *)(void *)0;
// neko_id_module
// file vm/alloc.c line 92
signed int neko_id_module;
// neko_k_hash
// file vm/others.c line 31
struct anonymous *neko_k_hash;
// neko_k_hash
// file vm/others.c line 31
struct anonymous *neko_k_hash = (struct anonymous *)&__kind_k_hash;
// neko_k_kind
// file vm/builtins.c line 36
struct anonymous *neko_k_kind;
// neko_k_kind
// file vm/builtins.c line 36
struct anonymous *neko_k_kind = (struct anonymous *)&__kind_neko_k_kind;
// neko_kind_module
// file vm/module.c line 31
struct anonymous *neko_kind_module;
// neko_kind_module
// file vm/module.c line 31
struct anonymous *neko_kind_module = (struct anonymous *)&__kind_neko_kind_module;
// neko_vm_context
// file vm/alloc.c line 73
struct _mt_local *neko_vm_context = (struct _mt_local *)(void *)0;
// parameter_table
// file vm/opcodes.h line 103
static signed int parameter_table[67l] = { 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1 };
// self
// file vm/main.c line 50
static struct _IO_FILE *self;
// stack
// file vm/stats.c line 46
static struct _statinfos *stack = (struct _statinfos *)(void *)0;
// stack_table
// file vm/opcodes.h line 177
static signed int stack_table[68l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, -2, -1, 0, 1, -0xFF, -0xFF, -0xFF, 0, 0, 0, 6, -6, 0, -0xFF, -0xFF, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, 0, 0, -0xFF, 0, 0, 0, 0, -1, 0, 0, -0xFF, 0, 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// t_false
// file vm/alloc.c line 76
static enum anonymous_7 t_false = (enum anonymous_7)VAL_BOOL;
// t_null
// file vm/alloc.c line 74
static enum anonymous_7 t_null = (enum anonymous_7)VAL_NULL;
// t_true
// file vm/alloc.c line 75
static enum anonymous_7 t_true = (enum anonymous_7)VAL_BOOL;
// val_false
// file vm/alloc.c line 79
struct _value *val_false;
// val_false
// file vm/alloc.c line 79
struct _value *val_false = (struct _value *)&t_false;
// val_null
// file vm/alloc.c line 77
struct _value *val_null;
// val_null
// file vm/alloc.c line 77
struct _value *val_null = (struct _value *)&t_null;
// val_true
// file vm/alloc.c line 78
struct _value *val_true;
// val_true
// file vm/alloc.c line 78
struct _value *val_true = (struct _value *)&t_true;

// ThreadMain
// file vm/threads.c line 110
static void * ThreadMain(void *_p)
{
  struct anonymous_23 *lp = (struct anonymous_23 *)_p;
  struct anonymous_23 p = *lp;
  p.init(p.param);
  pthread_mutex_unlock(&lp->lock);
  clean_c_stack(40, (void *)clean_c_stack);
  p.main(p.param);
  return NULL;
}

// __on_finalize
// file vm/alloc.c line 344
static void __on_finalize(struct _value *v, void *f)
{
  ((void (*)(struct _value *))f)(v);
}

// _neko_failure
// file vm/neko.h line 435
void _neko_failure(struct _value *msg, const char *file, signed int line)
{
  char *fname;
  fname=strrchr(file, 47);
  char *fname2;
  fname2=strrchr(file, 92);
  struct _value *o;
  o=neko_alloc_object((struct _value *)(void *)0);
  if(!(fname >= fname2))
    fname = fname2;

  signed int return_value_neko_val_id_1;
  return_value_neko_val_id_1=neko_val_id("msg");
  neko_alloc_field(o, return_value_neko_val_id_1, msg);
  signed int return_value_neko_val_id_2;
  return_value_neko_val_id_2=neko_val_id("file");
  struct _value *return_value_neko_alloc_string_3;
  return_value_neko_alloc_string_3=neko_alloc_string(fname != ((char *)NULL) ? fname + (signed long int)1 : file);
  neko_alloc_field(o, return_value_neko_val_id_2, return_value_neko_alloc_string_3);
  signed int return_value_neko_val_id_4;
  return_value_neko_val_id_4=neko_val_id("line");
  neko_alloc_field(o, return_value_neko_val_id_4, (struct _value *)(signed long int)((signed int)line << 1 | 1));
  struct _value *return_value_neko_alloc_function_5;
  return_value_neko_alloc_function_5=neko_alloc_function((void *)failure_to_string, (unsigned int)0, "failure_to_string");
  neko_alloc_field(o, id_string, return_value_neko_alloc_function_5);
  neko_val_throw(o);
}

// add_rec
// file vm/builtins.c line 796
static void add_rec(struct hcell **cc, signed int size, struct hcell *c)
{
  signed int k;
  if(!(c == ((struct hcell *)NULL)))
  {
    add_rec(cc, size, c->next);
    k = c->hkey % size;
    c->next = cc[(signed long int)k];
    cc[(signed long int)k] = c;
  }

}

// append_array
// file vm/module.c line 224
static void append_array(struct _value **arr, signed int pos, struct _value *v)
{
  signed int len = (signed int)*((enum anonymous_7 *)*arr) >> 4;
  if(pos >= len)
  {
    struct _value *a2;
    a2=neko_alloc_array((unsigned int)((len * 3) / 2));
    memcpy((void *)&((struct anonymous_4 *)a2)->ptr, (const void *)&((struct anonymous_4 *)*arr)->ptr, (unsigned long int)len * sizeof(struct _value *) /*8ul*/ );
    *arr = a2;
  }

  (&((struct anonymous_4 *)*arr)->ptr)[(signed long int)pos] = v;
}

// apply1
// file vm/alloc.c line 249
static struct _value * apply1(struct _value *p1)
{
  struct _value *env;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get_1)->env;
  struct _value **a = &((struct anonymous_4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous_7 *)env) >> 4) - 1;
  a[(signed long int)(n - 1)] = p1;
  struct _value *return_value_neko_val_callN_2;
  return_value_neko_val_callN_2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN_2;
}

// apply2
// file vm/alloc.c line 257
static struct _value * apply2(struct _value *p1, struct _value *p2)
{
  struct _value *env;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get_1)->env;
  struct _value **a = &((struct anonymous_4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous_7 *)env) >> 4) - 1;
  a[(signed long int)(n - 2)] = p1;
  a[(signed long int)(n - 1)] = p2;
  struct _value *return_value_neko_val_callN_2;
  return_value_neko_val_callN_2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN_2;
}

// apply3
// file vm/alloc.c line 266
static struct _value * apply3(struct _value *p1, struct _value *p2, struct _value *p3)
{
  struct _value *env;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get_1)->env;
  struct _value **a = &((struct anonymous_4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous_7 *)env) >> 4) - 1;
  a[(signed long int)(n - 3)] = p1;
  a[(signed long int)(n - 2)] = p2;
  a[(signed long int)(n - 1)] = p3;
  struct _value *return_value_neko_val_callN_2;
  return_value_neko_val_callN_2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN_2;
}

// apply4
// file vm/alloc.c line 276
static struct _value * apply4(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4)
{
  struct _value *env;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get_1)->env;
  struct _value **a = &((struct anonymous_4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous_7 *)env) >> 4) - 1;
  a[(signed long int)(n - 4)] = p1;
  a[(signed long int)(n - 3)] = p2;
  a[(signed long int)(n - 2)] = p3;
  a[(signed long int)(n - 1)] = p4;
  struct _value *return_value_neko_val_callN_2;
  return_value_neko_val_callN_2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN_2;
}

// apply5
// file vm/alloc.c line 287
static struct _value * apply5(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5)
{
  struct _value *env;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get_1)->env;
  struct _value **a = &((struct anonymous_4 *)env)->ptr + (signed long int)1;
  signed int n = ((signed int)*((enum anonymous_7 *)env) >> 4) - 1;
  a[(signed long int)(n - 4)] = p1;
  a[(signed long int)(n - 3)] = p2;
  a[(signed long int)(n - 2)] = p3;
  a[(signed long int)(n - 1)] = p4;
  a[(signed long int)(n - 1)] = p5;
  struct _value *return_value_neko_val_callN_2;
  return_value_neko_val_callN_2=neko_val_callN(a[(signed long int)-1], a, n);
  return return_value_neko_val_callN_2;
}

// bitcount
// file vm/interp.c line 501
static signed int bitcount(unsigned int k)
{
  signed int b = 0;
  for( ; !(k == 0u); k = k & k - (unsigned int)1)
    b = b + 1;
  return b;
}

// buffer_append_new
// file vm/others.c line 136
static void buffer_append_new(struct _buffer *b, const char *s, signed int len)
{
  signed int size;
  struct _stringitem *it;
  for( ; b->totlen >= b->blen << 2; b->blen = b->blen << 1)
    ;
  signed int tmp_if_expr_1;
  if(!(len >= b->blen))
    tmp_if_expr_1 = b->blen;

  else
    tmp_if_expr_1 = len;
  size = tmp_if_expr_1;
  char *return_value_neko_alloc_2;
  return_value_neko_alloc_2=neko_alloc((unsigned int)sizeof(struct _stringitem) /*24ul*/ );
  it = (struct _stringitem *)return_value_neko_alloc_2;
  it->str=neko_alloc_private((unsigned int)size);
  memcpy((void *)it->str, (const void *)s, (unsigned long int)len);
  it->size = size;
  it->len = len;
  it->next = b->data;
  b->data = it;
}

// builtin_ablit
// file vm/builtins.c line 131
static struct _value * builtin_ablit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l)
{
  signed int dpp;
  signed int spp;
  signed int ll;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)dst) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)dst) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)dp) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)src) == 0)
        tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)src) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        return (struct _value *)(void *)0;

      else
        if((1 & (signed int)sp) == 0)
          return (struct _value *)(void *)0;

        else
          if((1 & (signed int)l) == 0)
            return (struct _value *)(void *)0;

          else
          {
            dpp = (signed int)(signed long int)dp >> 1;
            spp = (signed int)(signed long int)sp >> 1;
            ll = (signed int)(signed long int)l >> 1;
            if(!(dpp + ll >= 0) || !(ll + spp >= 0) || !(dpp >= 0) || !(ll >= 0) || !(spp >= 0))
              tmp_if_expr_3 = (_Bool)1;

            else
              tmp_if_expr_3 = dpp + ll > (signed int)*((enum anonymous_7 *)dst) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_3)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = spp + ll > (signed int)*((enum anonymous_7 *)src) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
              return (struct _value *)(void *)0;

            else
            {
              memmove((void *)(&((struct anonymous_4 *)dst)->ptr + (signed long int)dpp), (const void *)(&((struct anonymous_4 *)src)->ptr + (signed long int)spp), (unsigned long int)ll * sizeof(struct _value *) /*8ul*/ );
              return val_null;
            }
          }
    }
}

// builtin_aconcat
// file vm/builtins.c line 153
static struct _value * builtin_aconcat(struct _value *arrs)
{
  signed int tot = 0;
  signed int len;
  signed int i;
  struct _value *all;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)arrs) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)arrs) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  signed int tmp_post_3;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    len = (signed int)*((enum anonymous_7 *)arrs) >> 4;
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      struct _value *a = (&((struct anonymous_4 *)arrs)->ptr)[(signed long int)i];
      if((1 & (signed int)a) == 0)
        tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        return (struct _value *)(void *)0;

      tot = tot + ((signed int)*((enum anonymous_7 *)a) >> 4);
    }
    all=neko_alloc_array((unsigned int)tot);
    tot = 0;
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      struct _value *builtin_aconcat__1__2__1__a = (&((struct anonymous_4 *)arrs)->ptr)[(signed long int)i];
      signed int j;
      signed int max = (signed int)*((enum anonymous_7 *)builtin_aconcat__1__2__1__a) >> 4;
      j = 0;
      for( ; !(j >= max); j = j + 1)
      {
        tmp_post_3 = tot;
        tot = tot + 1;
        (&((struct anonymous_4 *)all)->ptr)[(signed long int)tmp_post_3] = (&((struct anonymous_4 *)builtin_aconcat__1__2__1__a)->ptr)[(signed long int)j];
      }
    }
    return all;
  }
}

// builtin_acopy
// file vm/builtins.c line 81
static struct _value * builtin_acopy(struct _value *a)
{
  signed int i;
  struct _value *a2;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)a) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    a2=neko_alloc_array((unsigned int)((signed int)*((enum anonymous_7 *)a) >> 4));
    i = 0;
    for( ; !(i >= (signed int)*((enum anonymous_7 *)a) >> 4); i = i + 1)
      (&((struct anonymous_4 *)a2)->ptr)[(signed long int)i] = (&((struct anonymous_4 *)a)->ptr)[(signed long int)i];
    return a2;
  }
}

// builtin_amake
// file vm/builtins.c line 66
static struct _value * builtin_amake(struct _value *size)
{
  struct _value *a;
  signed int i;
  signed int s;
  if((1 & (signed int)size) == 0)
    return (struct _value *)(void *)0;

  else
  {
    s = (signed int)(signed long int)size >> 1;
    a=neko_alloc_array((unsigned int)s);
    i = 0;
    for( ; !(i >= s); i = i + 1)
      (&((struct anonymous_4 *)a)->ptr)[(signed long int)i] = val_null;
    return a;
  }
}

// builtin_apply
// file vm/builtins.c line 556
static struct _value * builtin_apply(struct _value **args, signed int nargs)
{
  struct _value *f;
  struct _value *env;
  signed int fargs;
  signed int i;
  nargs = nargs - 1;
  args = args + 1l;
  _Bool tmp_if_expr_1;
  struct _value *return_value_neko_val_callN_2;
  signed int tmp_post_3;
  if(!(nargs >= 0))
    return (struct _value *)(void *)0;

  else
  {
    f = args[(signed long int)-1];
    if((1 & (signed int)f) == 0)
      tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      return (struct _value *)(void *)0;

    else
      if(nargs == 0)
        return f;

      else
      {
        fargs = ((struct anonymous_8 *)f)->nargs;
        if(fargs == -1 || fargs == nargs)
        {
          return_value_neko_val_callN_2=neko_val_callN(f, args, nargs);
          return return_value_neko_val_callN_2;
        }

        else
          if(!(fargs >= nargs))
            return (struct _value *)(void *)0;

          else
          {
            env=neko_alloc_array((unsigned int)(fargs + 1));
            (&((struct anonymous_4 *)env)->ptr)[(signed long int)0] = f;
            i = 0;
            for( ; !(i >= nargs); i = i + 1)
              (&((struct anonymous_4 *)env)->ptr)[(signed long int)(i + 1)] = args[(signed long int)i];
            do
            {
              tmp_post_3 = i;
              i = i + 1;
              if(tmp_post_3 >= fargs)
                break;

              (&((struct anonymous_4 *)env)->ptr)[(signed long int)i] = val_null;
            }
            while((_Bool)1);
            struct _value *return_value_neko_alloc_apply_4;
            return_value_neko_alloc_apply_4=neko_alloc_apply(fargs - nargs, env);
            return return_value_neko_alloc_apply_4;
          }
      }
  }
}

// builtin_array
// file vm/builtins.c line 54
static struct _value * builtin_array(struct _value **args, signed int nargs)
{
  struct _value *a;
  a=neko_alloc_array((unsigned int)nargs);
  signed int i = 0;
  for( ; !(i >= nargs); i = i + 1)
    (&((struct anonymous_4 *)a)->ptr)[(signed long int)i] = args[(signed long int)i];
  return a;
}

// builtin_asize
// file vm/builtins.c line 95
static struct _value * builtin_asize(struct _value *a)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)a) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((signed int)*((enum anonymous_7 *)a) >> 4) << 1 | 1);
}

// builtin_asub
// file vm/builtins.c line 107
static struct _value * builtin_asub(struct _value *a, struct _value *p, struct _value *l)
{
  struct _value *a2;
  signed int i;
  signed int pp;
  signed int ll;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)a) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)a) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)l) == 0)
        return (struct _value *)(void *)0;

      else
      {
        pp = (signed int)(signed long int)p >> 1;
        ll = (signed int)(signed long int)l >> 1;
        if(!(ll + pp >= 0) || !(ll >= 0) || !(pp >= 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = pp + ll > (signed int)*((enum anonymous_7 *)a) >> 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          return (struct _value *)(void *)0;

        else
        {
          a2=neko_alloc_array((unsigned int)ll);
          i = 0;
          for( ; !(i >= ll); i = i + 1)
            (&((struct anonymous_4 *)a2)->ptr)[(signed long int)i] = (&((struct anonymous_4 *)a)->ptr)[(signed long int)(pp + i)];
          return a2;
        }
      }
}

// builtin_call
// file vm/builtins.c line 489
static struct _value * builtin_call(struct _value *f, struct _value *ctx, struct _value *args)
{
  struct _value *old;
  struct _value *ret;
  struct _neko_vm *vm;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)args) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)args) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    void *return_value_neko_local_get_2;
    return_value_neko_local_get_2=neko_local_get(neko_vm_context);
    vm = (struct _neko_vm *)return_value_neko_local_get_2;
    old = vm->vthis;
    vm->vthis = ctx;
    ret=neko_val_callN(f, &((struct anonymous_4 *)args)->ptr, (signed int)*((enum anonymous_7 *)args) >> 4);
    vm->vthis = old;
    return ret;
  }
}

// builtin_callstack
// file vm/builtins.c line 1197
static struct _value * builtin_callstack()
{
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  struct _value *return_value_neko_call_stack_2;
  return_value_neko_call_stack_2=neko_call_stack((struct _neko_vm *)return_value_neko_local_get_1);
  return return_value_neko_call_stack_2;
}

// builtin_closure
// file vm/builtins.c line 530
static struct _value * builtin_closure(struct _value **args, signed int nargs)
{
  struct _value *f;
  struct _value *env;
  signed int fargs;
  struct _value *return_value_neko_alloc_string_1;
  if(!(nargs >= 2))
  {
    return_value_neko_alloc_string_1=neko_alloc_string("Invalid closure arguments number");
    _neko_failure(return_value_neko_alloc_string_1, "vm/builtins.c", 535);
  }

  f = args[(signed long int)0];
  _Bool tmp_if_expr_2;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  struct _value *return_value_neko_alloc_string_3;
  if(!tmp_if_expr_2)
    return (struct _value *)(void *)0;

  else
  {
    fargs = ((struct anonymous_8 *)f)->nargs;
    if(!(fargs == -1) && !(fargs >= nargs + -2))
    {
      return_value_neko_alloc_string_3=neko_alloc_string("Invalid closure arguments number");
      _neko_failure(return_value_neko_alloc_string_3, "vm/builtins.c", 541);
    }

    env=neko_alloc_array((unsigned int)nargs);
    memcpy((void *)&((struct anonymous_4 *)env)->ptr, (const void *)args, (unsigned long int)nargs * sizeof(struct _value *) /*8ul*/ );
    f=neko_alloc_function((void *)closure_callback, (unsigned int)-1, "closure_callback");
    ((struct anonymous_8 *)f)->env = env;
    return f;
  }
}

// builtin_compare
// file vm/builtins.c line 1157
static struct _value * builtin_compare(struct _value *a, struct _value *b)
{
  signed int r;
  r=neko_val_compare(a, b);
  return r == 0xFE ? val_null : (struct _value *)(signed long int)((signed int)r << 1 | 1);
}

// builtin_excstack
// file vm/builtins.c line 1189
static struct _value * builtin_excstack()
{
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  return ((struct _neko_vm *)return_value_neko_local_get_1)->exc_stack;
}

// builtin_fasthash
// file vm/builtins.c line 422
static struct _value * builtin_fasthash(struct _value *f)
{
  struct _value *acc = (struct _value *)(signed long int)((signed int)0 << 1 | 1);
  unsigned char *name;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    name = (unsigned char *)&((struct anonymous_5 *)f)->c;
    for( ; !(*name == 0); name = name + 1l)
      acc = (struct _value *)(signed long int)((signed int)(223 * ((signed int)(signed long int)acc >> 1) + (signed int)*name) << 1 | 1);
    return acc;
  }
}

// builtin_field
// file vm/builtins.c line 439
static struct _value * builtin_field(struct _value *f)
{
  if((1 & (signed int)f) == 0)
    return (struct _value *)(void *)0;

  else
  {
    struct _value *return_value_neko_val_field_name_1;
    return_value_neko_val_field_name_1=neko_val_field_name((signed int)(signed long int)f >> 1);
    return return_value_neko_val_field_name_1;
  }
}

// builtin_float
// file vm/builtins.c line 732
static struct _value * builtin_float(struct _value *f)
{
  struct _value *tmp_if_expr_3;
  struct _value *return_value_neko_alloc_float_2;
  if((1 & (signed int)f) == 0)
  {
    if((15 & (signed int)*((enum anonymous_7 *)f)) == VAL_STRING)
    {
      char *c = &((struct anonymous_5 *)f)->c;
      char *end;
      double builtin_float__1__1__f;
      double return_value_strtod_1;
      return_value_strtod_1=strtod(c, &end);
      builtin_float__1__1__f = (double)return_value_strtod_1;
      if(c == end)
        tmp_if_expr_3 = val_null;

      else
      {
        return_value_neko_alloc_float_2=neko_alloc_float(builtin_float__1__1__f);
        tmp_if_expr_3 = return_value_neko_alloc_float_2;
      }
      return tmp_if_expr_3;
    }

  }

  _Bool tmp_if_expr_7;
  if(!((1 & (signed int)f) == 0))
    tmp_if_expr_7 = (_Bool)1;

  else
    tmp_if_expr_7 = (signed int)*((enum anonymous_7 *)f) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_8;
  if(tmp_if_expr_7)
    tmp_if_expr_8 = (_Bool)1;

  else
    tmp_if_expr_8 = (signed int)*((enum anonymous_7 *)f) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
  double tmp_if_expr_5;
  double tmp_if_expr_4;
  struct _value *return_value_neko_alloc_float_6;
  if(tmp_if_expr_8)
  {
    if(!((1 & (signed int)f) == 0))
      tmp_if_expr_5 = (double)((signed int)(signed long int)f >> 1);

    else
    {
      if((signed int)*((enum anonymous_7 *)f) == VAL_FLOAT)
        tmp_if_expr_4 = ((struct anonymous_25 *)f)->f;

      else
        tmp_if_expr_4 = (double)((struct anonymous_26 *)f)->i;
      tmp_if_expr_5 = tmp_if_expr_4;
    }
    return_value_neko_alloc_float_6=neko_alloc_float(tmp_if_expr_5);
    return return_value_neko_alloc_float_6;
  }

  else
    return val_null;
}

// builtin_getkind
// file vm/builtins.c line 749
static struct _value * builtin_getkind(struct _value *v)
{
  struct _value *return_value_neko_alloc_abstract_1;
  _Bool tmp_if_expr_2;
  if((1 & (signed int)v) == 0)
  {
    if(!((signed int)*((enum anonymous_7 *)v) == VAL_INT32))
      goto __CPROVER_DUMP_L1;

    return_value_neko_alloc_abstract_1=neko_alloc_abstract(neko_k_kind, (void *)k_old_int32);
    return return_value_neko_alloc_abstract_1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if((1 & (signed int)v) == 0)
      tmp_if_expr_2 = (signed int)*((enum anonymous_7 *)v) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      return (struct _value *)(void *)0;

    else
    {
      struct _value *return_value_neko_alloc_abstract_3;
      return_value_neko_alloc_abstract_3=neko_alloc_abstract(neko_k_kind, (void *)((struct anonymous_6 *)v)->kind);
      return return_value_neko_alloc_abstract_3;
    }
  }
}

// builtin_hadd
// file vm/builtins.c line 995
static struct _value * builtin_hadd(struct _value *vh, struct _value *key, struct _value *val)
{
  struct anonymous_0 *h;
  struct hcell *c;
  signed int hkey;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(!tmp_if_expr_2)
    return (struct _value *)(void *)0;

  else
  {
    h = (struct anonymous_0 *)((struct anonymous_6 *)vh)->data;
    hkey=neko_val_hash(key);
    if(!(hkey >= 0))
      return (struct _value *)(void *)0;

    else
    {
      if(h->nitems >= h->ncells << 1)
        builtin_hresize(vh, (struct _value *)(signed long int)((signed int)(h->ncells << 1) << 1 | 1));

      char *return_value_neko_alloc_3;
      return_value_neko_alloc_3=neko_alloc((unsigned int)sizeof(struct hcell) /*32ul*/ );
      c = (struct hcell *)return_value_neko_alloc_3;
      c->hkey = hkey;
      c->key = key;
      c->val = val;
      hkey = hkey % h->ncells;
      c->next = h->cells[(signed long int)hkey];
      h->cells[(signed long int)hkey] = c;
      h->nitems = h->nitems + 1;
      return val_null;
    }
  }
}

// builtin_hash
// file vm/builtins.c line 413
static struct _value * builtin_hash(struct _value *f)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    signed int return_value_neko_val_id_2;
    return_value_neko_val_id_2=neko_val_id(&((struct anonymous_5 *)f)->c);
    return (struct _value *)(signed long int)((signed int)return_value_neko_val_id_2 << 1 | 1);
  }
}

// builtin_hcount
// file vm/builtins.c line 1042
static struct _value * builtin_hcount(struct _value *vh)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(!tmp_if_expr_2)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((struct anonymous_0 *)((struct anonymous_6 *)vh)->data)->nitems << 1 | 1);
}

// builtin_hget
// file vm/builtins.c line 838
static struct _value * builtin_hget(struct _value *vh, struct _value *key, struct _value *cmp)
{
  struct anonymous_0 *h;
  struct hcell *c;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous_8 *)cmp)->nargs == 2))
        tmp_if_expr_2 = ((struct anonymous_8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr_4 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(!tmp_if_expr_5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous_0 *)((struct anonymous_6 *)vh)->data;
      signed int return_value_neko_val_hash_6;
      return_value_neko_val_hash_6=neko_val_hash(key);
      c = h->cells[(signed long int)(return_value_neko_val_hash_6 % h->ncells)];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare_7;
          return_value_neko_val_compare_7=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare_7 == 0)
            return c->val;

          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2_8;
          return_value_neko_val_call2_8=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2_8 == (struct _value *)1l)
            return c->val;

          c = c->next;
        }
      return val_null;
    }
  }
}

// builtin_hiter
// file vm/builtins.c line 1021
static struct _value * builtin_hiter(struct _value *vh, struct _value *f)
{
  signed int i;
  struct hcell *c;
  struct anonymous_0 *h;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(!(((struct anonymous_8 *)f)->nargs == 2))
      tmp_if_expr_2 = ((struct anonymous_8 *)f)->nargs != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_3)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)vh) == 0)
      tmp_if_expr_4 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(!tmp_if_expr_5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous_0 *)((struct anonymous_6 *)vh)->data;
      i = 0;
      for( ; !(i >= h->ncells); i = i + 1)
      {
        c = h->cells[(signed long int)i];
        for( ; !(c == ((struct hcell *)NULL)); c = c->next)
          neko_val_call2(f, c->key, c->val);
      }
      return val_null;
    }
  }
}

// builtin_hkey
// file vm/builtins.c line 771
static struct _value * builtin_hkey(struct _value *v)
{
  signed int return_value_neko_val_hash_1;
  return_value_neko_val_hash_1=neko_val_hash(v);
  return (struct _value *)(signed long int)((signed int)return_value_neko_val_hash_1 << 1 | 1);
}

// builtin_hmem
// file vm/builtins.c line 870
static struct _value * builtin_hmem(struct _value *vh, struct _value *key, struct _value *cmp)
{
  struct anonymous_0 *h;
  struct hcell *c;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous_8 *)cmp)->nargs == 2))
        tmp_if_expr_2 = ((struct anonymous_8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr_4 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(!tmp_if_expr_5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous_0 *)((struct anonymous_6 *)vh)->data;
      signed int return_value_neko_val_hash_6;
      return_value_neko_val_hash_6=neko_val_hash(key);
      c = h->cells[(signed long int)(return_value_neko_val_hash_6 % h->ncells)];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare_7;
          return_value_neko_val_compare_7=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare_7 == 0)
            return val_true;

          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2_8;
          return_value_neko_val_call2_8=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2_8 == (struct _value *)1l)
            return val_true;

          c = c->next;
        }
      return val_false;
    }
  }
}

// builtin_hnew
// file vm/builtins.c line 781
static struct _value * builtin_hnew(struct _value *size)
{
  struct anonymous_0 *h;
  signed int i;
  if((1 & (signed int)size) == 0)
    return (struct _value *)(void *)0;

  else
  {
    char *return_value_neko_alloc_1;
    return_value_neko_alloc_1=neko_alloc((unsigned int)sizeof(struct anonymous_0) /*16ul*/ );
    h = (struct anonymous_0 *)return_value_neko_alloc_1;
    h->nitems = 0;
    h->ncells = (signed int)(signed long int)size >> 1;
    if(!(h->ncells >= 1))
      h->ncells = 7;

    char *return_value_neko_alloc_2;
    return_value_neko_alloc_2=neko_alloc((unsigned int)(sizeof(struct hcell *) /*8ul*/  * (unsigned long int)h->ncells));
    h->cells = (struct hcell **)return_value_neko_alloc_2;
    i = 0;
    for( ; !(i >= h->ncells); i = i + 1)
      h->cells[(signed long int)i] = (struct hcell *)(void *)0;
    struct _value *return_value_neko_alloc_abstract_3;
    return_value_neko_alloc_abstract_3=neko_alloc_abstract(neko_k_hash, (void *)h);
    return return_value_neko_alloc_abstract_3;
  }
}

// builtin_hremove
// file vm/builtins.c line 902
static struct _value * builtin_hremove(struct _value *vh, struct _value *key, struct _value *cmp)
{
  struct anonymous_0 *h;
  struct hcell *c;
  struct hcell *prev = (struct hcell *)(void *)0;
  signed int hkey;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous_8 *)cmp)->nargs == 2))
        tmp_if_expr_2 = ((struct anonymous_8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr_4 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(!tmp_if_expr_5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous_0 *)((struct anonymous_6 *)vh)->data;
      signed int return_value_neko_val_hash_6;
      return_value_neko_val_hash_6=neko_val_hash(key);
      hkey = return_value_neko_val_hash_6 % h->ncells;
      c = h->cells[(signed long int)hkey];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare_7;
          return_value_neko_val_compare_7=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare_7 == 0)
          {
            if(prev == ((struct hcell *)NULL))
              h->cells[(signed long int)hkey] = c->next;

            else
              prev->next = c->next;
            h->nitems = h->nitems - 1;
            return val_true;
          }

          prev = c;
          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2_8;
          return_value_neko_val_call2_8=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2_8 == (struct _value *)1l)
          {
            if(prev == ((struct hcell *)NULL))
              h->cells[(signed long int)hkey] = c->next;

            else
              prev->next = c->next;
            h->nitems = h->nitems - 1;
            return val_true;
          }

          prev = c;
          c = c->next;
        }
      return val_false;
    }
  }
}

// builtin_hresize
// file vm/builtins.c line 810
static struct _value * builtin_hresize(struct _value *vh, struct _value *size)
{
  struct anonymous_0 *h;
  struct hcell **cc;
  signed int nsize;
  signed int i;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(!tmp_if_expr_2)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)size) == 0)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous_0 *)((struct anonymous_6 *)vh)->data;
      nsize = (signed int)(signed long int)size >> 1;
      if(!(nsize >= 1))
        nsize = 7;

      char *return_value_neko_alloc_3;
      return_value_neko_alloc_3=neko_alloc((unsigned int)(sizeof(struct hcell *) /*8ul*/  * (unsigned long int)nsize));
      cc = (struct hcell **)return_value_neko_alloc_3;
      memset((void *)cc, 0, sizeof(struct hcell *) /*8ul*/  * (unsigned long int)nsize);
      i = 0;
      for( ; !(i >= h->ncells); i = i + 1)
        add_rec(cc, nsize, h->cells[(signed long int)i]);
      h->cells = cc;
      h->ncells = nsize;
      return val_null;
    }
}

// builtin_hset
// file vm/builtins.c line 949
static struct _value * builtin_hset(struct _value *vh, struct _value *key, struct _value *val, struct _value *cmp)
{
  struct anonymous_0 *h;
  struct hcell *c;
  signed int hkey;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(cmp == val_null))
  {
    if((1 & (signed int)cmp) == 0)
      tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)cmp) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if(!(((struct anonymous_8 *)cmp)->nargs == 2))
        tmp_if_expr_2 = ((struct anonymous_8 *)cmp)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_3)
      goto __CPROVER_DUMP_L7;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((1 & (signed int)vh) == 0)
      tmp_if_expr_4 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(!tmp_if_expr_5)
      return (struct _value *)(void *)0;

    else
    {
      h = (struct anonymous_0 *)((struct anonymous_6 *)vh)->data;
      hkey=neko_val_hash(key);
      c = h->cells[(signed long int)(hkey % h->ncells)];
      if(cmp == val_null)
        while(!(c == ((struct hcell *)NULL)))
        {
          signed int return_value_neko_val_compare_6;
          return_value_neko_val_compare_6=neko_val_compare(key, c->key);
          if(return_value_neko_val_compare_6 == 0)
          {
            c->val = val;
            return val_false;
          }

          c = c->next;
        }

      else
        while(!(c == ((struct hcell *)NULL)))
        {
          struct _value *return_value_neko_val_call2_7;
          return_value_neko_val_call2_7=neko_val_call2(cmp, key, c->key);
          if(return_value_neko_val_call2_7 == (struct _value *)1l)
          {
            c->val = val;
            return val_false;
          }

          c = c->next;
        }
      if(h->nitems >= h->ncells << 1)
        builtin_hresize(vh, (struct _value *)(signed long int)((signed int)(h->ncells << 1) << 1 | 1));

      char *return_value_neko_alloc_8;
      return_value_neko_alloc_8=neko_alloc((unsigned int)sizeof(struct hcell) /*32ul*/ );
      c = (struct hcell *)return_value_neko_alloc_8;
      c->hkey = hkey;
      c->key = key;
      c->val = val;
      hkey = hkey % h->ncells;
      c->next = h->cells[(signed long int)hkey];
      h->cells[(signed long int)hkey] = c;
      h->nitems = h->nitems + 1;
      return val_true;
    }
  }
}

// builtin_hsize
// file vm/builtins.c line 1051
static struct _value * builtin_hsize(struct _value *vh)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)vh) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)vh) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ((struct anonymous_6 *)vh)->kind == neko_k_hash ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(!tmp_if_expr_2)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((struct anonymous_0 *)((struct anonymous_6 *)vh)->data)->ncells << 1 | 1);
}

// builtin_iadd
// file vm/builtins.c line 613
static struct _value * builtin_iadd(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr_1 = (signed int)(signed long int)a >> 1;

  else
    tmp_if_expr_1 = ((struct anonymous_26 *)a)->i;
  signed int tmp_if_expr_2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr_2 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr_2 = ((struct anonymous_26 *)b)->i;
  struct _value *tmp_if_expr_8;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  struct _value *return_value_neko_alloc_int32_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  if(!((1073741824u + (unsigned int)tmp_if_expr_1 + (unsigned int)tmp_if_expr_2 & 0x80000000) == 0u))
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr_3 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr_3 = ((struct anonymous_26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr_4 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr_4 = ((struct anonymous_26 *)b)->i;
    return_value_neko_alloc_int32_5=neko_alloc_int32(tmp_if_expr_3 + tmp_if_expr_4);
    tmp_if_expr_8 = return_value_neko_alloc_int32_5;
  }

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr_6 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr_6 = ((struct anonymous_26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr_7 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr_7 = ((struct anonymous_26 *)b)->i;
    tmp_if_expr_8 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_6 + tmp_if_expr_7) << 1 | 1);
  }
  return tmp_if_expr_8;
}

// builtin_idiv
// file vm/builtins.c line 637
static struct _value * builtin_idiv(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr_1 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr_1 = ((struct anonymous_26 *)b)->i;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  struct _value *tmp_if_expr_9;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  struct _value *return_value_neko_alloc_int32_6;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  if(tmp_if_expr_1 == 0)
    return (struct _value *)(void *)0;

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr_2 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr_2 = ((struct anonymous_26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr_3 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr_3 = ((struct anonymous_26 *)b)->i;
    if(!((1073741824u + (unsigned int)(tmp_if_expr_2 / tmp_if_expr_3) & 0x80000000) == 0u))
    {
      if(!((1 & (signed int)a) == 0))
        tmp_if_expr_4 = (signed int)(signed long int)a >> 1;

      else
        tmp_if_expr_4 = ((struct anonymous_26 *)a)->i;
      if(!((1 & (signed int)b) == 0))
        tmp_if_expr_5 = (signed int)(signed long int)b >> 1;

      else
        tmp_if_expr_5 = ((struct anonymous_26 *)b)->i;
      return_value_neko_alloc_int32_6=neko_alloc_int32(tmp_if_expr_4 / tmp_if_expr_5);
      tmp_if_expr_9 = return_value_neko_alloc_int32_6;
    }

    else
    {
      if(!((1 & (signed int)a) == 0))
        tmp_if_expr_7 = (signed int)(signed long int)a >> 1;

      else
        tmp_if_expr_7 = ((struct anonymous_26 *)a)->i;
      if(!((1 & (signed int)b) == 0))
        tmp_if_expr_8 = (signed int)(signed long int)b >> 1;

      else
        tmp_if_expr_8 = ((struct anonymous_26 *)b)->i;
      tmp_if_expr_9 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_7 / tmp_if_expr_8) << 1 | 1);
    }
    return tmp_if_expr_9;
  }
}

// builtin_imult
// file vm/builtins.c line 629
static struct _value * builtin_imult(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr_1 = (signed int)(signed long int)a >> 1;

  else
    tmp_if_expr_1 = ((struct anonymous_26 *)a)->i;
  signed int tmp_if_expr_2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr_2 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr_2 = ((struct anonymous_26 *)b)->i;
  struct _value *tmp_if_expr_8;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  struct _value *return_value_neko_alloc_int32_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  if(!(((unsigned int)tmp_if_expr_1 * (unsigned int)tmp_if_expr_2 + 1073741824u & 0x80000000) == 0u))
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr_3 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr_3 = ((struct anonymous_26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr_4 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr_4 = ((struct anonymous_26 *)b)->i;
    return_value_neko_alloc_int32_5=neko_alloc_int32(tmp_if_expr_3 * tmp_if_expr_4);
    tmp_if_expr_8 = return_value_neko_alloc_int32_5;
  }

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr_6 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr_6 = ((struct anonymous_26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr_7 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr_7 = ((struct anonymous_26 *)b)->i;
    tmp_if_expr_8 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_6 * tmp_if_expr_7) << 1 | 1);
  }
  return tmp_if_expr_8;
}

// builtin_int
// file vm/builtins.c line 689
static struct _value * builtin_int(struct _value *f)
{
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)f) == 0))
    tmp_if_expr_1 = VAL_INT;

  else
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1;
  double return_value_fmod_2;
  char *c;
  char *end;
  signed int h;
  _Bool tmp_if_expr_6;
  char *tmp_post_3;
  struct _value *tmp_if_expr_5;
  struct _value *return_value_neko_alloc_int32_4;
  signed long int return_value_strtol_7;
  struct _value *tmp_if_expr_10;
  struct _value *tmp_if_expr_9;
  struct _value *return_value_neko_alloc_int32_8;
  switch(tmp_if_expr_1)
  {
    case VAL_FLOAT:
    {
      return_value_fmod_2=fmod(((struct anonymous_25 *)f)->f, 4294967296.0);
      return (struct _value *)(signed long int)((signed int)(unsigned int)return_value_fmod_2 << 1 | 1);
    }
    case VAL_STRING:
    {
      c = &((struct anonymous_5 *)f)->c;
      if((signed int)*((enum anonymous_7 *)f) >> 4 >= 2)
      {
        if((signed int)*c == 48)
        {
          if((signed int)c[1l] == 120)
            tmp_if_expr_6 = (_Bool)1;

          else
            tmp_if_expr_6 = (signed int)c[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_6)
          {
            h = 0;
            c = c + (signed long int)2;
            while(!(*c == 0))
            {
              char k;
              tmp_post_3 = c;
              c = c + 1l;
              k = *tmp_post_3;
              if((signed int)k >= 48 && !((signed int)k >= 58))
                h = h << 4 | (signed int)k - 48;

              else
                if((signed int)k >= 65 && !((signed int)k >= 71))
                  h = h << 4 | ((signed int)k - 65) + 10;

                else
                  if((signed int)k >= 97 && !((signed int)k >= 103))
                    h = h << 4 | ((signed int)k - 97) + 10;

                  else
                    return val_null;
            }
            if(!((1073741824u + (unsigned int)h & 0x80000000) == 0u))
            {
              return_value_neko_alloc_int32_4=neko_alloc_int32(h);
              tmp_if_expr_5 = return_value_neko_alloc_int32_4;
            }

            else
              tmp_if_expr_5 = (struct _value *)(signed long int)((signed int)h << 1 | 1);
            return tmp_if_expr_5;
          }

        }

      }

      return_value_strtol_7=strtol(c, &end, 10);
      h = (signed int)return_value_strtol_7;
      if(c == end)
        tmp_if_expr_10 = val_null;

      else
      {
        if(!((1073741824u + (unsigned int)h & 0x80000000) == 0u))
        {
          return_value_neko_alloc_int32_8=neko_alloc_int32(h);
          tmp_if_expr_9 = return_value_neko_alloc_int32_8;
        }

        else
          tmp_if_expr_9 = (struct _value *)(signed long int)((signed int)h << 1 | 1);
        tmp_if_expr_10 = tmp_if_expr_9;
      }
      return tmp_if_expr_10;
    }
    case VAL_INT:

    case VAL_INT32:
      return f;
    default:
      return val_null;
  }
}

// builtin_isinfinite
// file vm/builtins.c line 672
static struct _value * builtin_isinfinite(struct _value *f)
{
  union anonymous_2 q;
  unsigned int h;
  unsigned int l;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)f) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return val_false;

  else
  {
    q.d = ((struct anonymous_25 *)f)->f;
    h = q.i.h;
    l = q.i.l;
    l = l | h & (unsigned int)0xFFFFF;
    h = h & (unsigned int)0x7FF00000;
    return h == (unsigned int)0x7FF00000 && l == (unsigned int)0 ? val_true : val_false;
  }
}

// builtin_iskind
// file vm/builtins.c line 760
static struct _value * builtin_iskind(struct _value *v, struct _value *k)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)k) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)k) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ((struct anonymous_6 *)k)->kind == neko_k_kind ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  struct _value *tmp_if_expr_6;
  struct _value *tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  if(!tmp_if_expr_2)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)v) == 0)
      tmp_if_expr_3 = (signed int)*((enum anonymous_7 *)v) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_6 = ((struct anonymous_6 *)v)->kind == (struct anonymous *)((struct anonymous_6 *)k)->data ? val_true : val_false;

    else
    {
      if((struct anonymous *)((struct anonymous_6 *)k)->data == k_old_int32)
      {
        if((1 & (signed int)v) == 0)
          tmp_if_expr_4 = (signed int)*((enum anonymous_7 *)v) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        tmp_if_expr_5 = tmp_if_expr_4 ? val_true : val_false;
      }

      else
        tmp_if_expr_5 = val_false;
      tmp_if_expr_6 = tmp_if_expr_5;
    }
    return tmp_if_expr_6;
  }
}

// builtin_isnan
// file vm/builtins.c line 655
static struct _value * builtin_isnan(struct _value *f)
{
  union anonymous_2 q;
  unsigned int h;
  unsigned int l;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)f) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return val_false;

  else
  {
    q.d = ((struct anonymous_25 *)f)->f;
    h = q.i.h;
    l = q.i.l;
    l = l | h & (unsigned int)0xFFFFF;
    h = h & (unsigned int)0x7FF00000;
    return h == (unsigned int)0x7FF00000 && l != (unsigned int)0 ? val_true : val_false;
  }
}

// builtin_istrue
// file vm/builtins.c line 1098
static struct _value * builtin_istrue(struct _value *f)
{
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(f == val_false) && !(f == val_null) && !(f == (struct _value *)1l))
  {
    if(!((1 & (signed int)f) == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)f) != VAL_INT32 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = ((struct anonymous_26 *)f)->i != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return tmp_if_expr_3 ? val_true : val_false;
}

// builtin_isub
// file vm/builtins.c line 621
static struct _value * builtin_isub(struct _value *a, struct _value *b)
{
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr_1 = (signed int)(signed long int)a >> 1;

  else
    tmp_if_expr_1 = ((struct anonymous_26 *)a)->i;
  signed int tmp_if_expr_2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr_2 = (signed int)(signed long int)b >> 1;

  else
    tmp_if_expr_2 = ((struct anonymous_26 *)b)->i;
  struct _value *tmp_if_expr_8;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  struct _value *return_value_neko_alloc_int32_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  if(!((1073741824u + (unsigned int)tmp_if_expr_1 + -((unsigned int)tmp_if_expr_2) & 0x80000000) == 0u))
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr_3 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr_3 = ((struct anonymous_26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr_4 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr_4 = ((struct anonymous_26 *)b)->i;
    return_value_neko_alloc_int32_5=neko_alloc_int32(tmp_if_expr_3 - tmp_if_expr_4);
    tmp_if_expr_8 = return_value_neko_alloc_int32_5;
  }

  else
  {
    if(!((1 & (signed int)a) == 0))
      tmp_if_expr_6 = (signed int)(signed long int)a >> 1;

    else
      tmp_if_expr_6 = ((struct anonymous_26 *)a)->i;
    if(!((1 & (signed int)b) == 0))
      tmp_if_expr_7 = (signed int)(signed long int)b >> 1;

    else
      tmp_if_expr_7 = ((struct anonymous_26 *)b)->i;
    tmp_if_expr_8 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_6 - tmp_if_expr_7) << 1 | 1);
  }
  return tmp_if_expr_8;
}

// builtin_nargs
// file vm/builtins.c line 480
static struct _value * builtin_nargs(struct _value *f)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((struct anonymous_8 *)f)->nargs << 1 | 1);
}

// builtin_new
// file vm/builtins.c line 329
static struct _value * builtin_new(struct _value *o)
{
  _Bool tmp_if_expr_1;
  if(!(o == val_null))
  {
    if((1 & (signed int)o) == 0)
      tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      goto __CPROVER_DUMP_L3;

    return (struct _value *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    struct _value *return_value_neko_alloc_object_2;
    return_value_neko_alloc_object_2=neko_alloc_object(o);
    return return_value_neko_alloc_object_2;
  }
}

// builtin_not
// file vm/builtins.c line 1106
static struct _value * builtin_not(struct _value *f)
{
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(f == val_false || f == val_null || f == (struct _value *)1l)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if((1 & (signed int)f) == 0)
      tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)f) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = ((struct anonymous_26 *)f)->i == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr_3 ? val_true : val_false;
}

// builtin_objcall
// file vm/builtins.c line 362
static struct _value * builtin_objcall(struct _value *o, struct _value *f, struct _value *args)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    return val_null;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)args) == 0)
        tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)args) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        return (struct _value *)(void *)0;

      else
      {
        struct _value *return_value_neko_val_ocallN_3;
        return_value_neko_val_ocallN_3=neko_val_ocallN(o, (signed int)(signed long int)f >> 1, &((struct anonymous_4 *)args)->ptr, (signed int)*((enum anonymous_7 *)args) >> 4);
        return return_value_neko_val_ocallN_3;
      }
    }
}

// builtin_objfield
// file vm/builtins.c line 374
static struct _value * builtin_objfield(struct _value *o, struct _value *f)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  struct _value **return_value_otable_find_2;
  if((1 & (signed int)f) == 0)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)o) == 0)
      tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      return_value_otable_find_2=otable_find(&((struct _vobject *)o)->table, (signed int)(signed long int)f >> 1);
      tmp_if_expr_3 = return_value_otable_find_2 != (struct _value **)(void *)0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    return tmp_if_expr_3 ? val_true : val_false;
  }
}

// builtin_objfields
// file vm/builtins.c line 397
static struct _value * builtin_objfields(struct _value *o)
{
  struct _value *a;
  struct _value **aptr;
  struct _objtable *t;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    t = &((struct _vobject *)o)->table;
    a=neko_alloc_array((unsigned int)t->count);
    aptr = &((struct anonymous_4 *)a)->ptr;
    otable_iter(t, builtin_objfields_rec, (void *)&aptr);
    return a;
  }
}

// builtin_objfields_rec
// file vm/builtins.c line 389
static void builtin_objfields_rec(struct _value *d, signed int id, void *a)
{
  struct _value **tmp_post_1 = *((struct _value ***)a);
  *((struct _value ***)a) = *((struct _value ***)a) + 1l;
  *tmp_post_1 = (struct _value *)(signed long int)((signed int)id << 1 | 1);
}

// builtin_objget
// file vm/builtins.c line 339
static struct _value * builtin_objget(struct _value *o, struct _value *f)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return val_null;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      struct _value *return_value_neko_val_field_2;
      return_value_neko_val_field_2=neko_val_field(o, (signed int)(signed long int)f >> 1);
      return return_value_neko_val_field_2;
    }
}

// builtin_objgetproto
// file vm/builtins.c line 463
static struct _value * builtin_objgetproto(struct _value *o)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    o = (struct _value *)((struct _vobject *)o)->proto;
    if(o == ((struct _value *)NULL))
      return val_null;

    else
      return o;
  }
}

// builtin_objremove
// file vm/builtins.c line 383
static struct _value * builtin_objremove(struct _value *o, struct _value *f)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      signed int return_value_otable_remove_2;
      return_value_otable_remove_2=otable_remove(&((struct _vobject *)o)->table, (signed int)(signed long int)f >> 1);
      return return_value_otable_remove_2 != 0 ? val_true : val_false;
    }
}

// builtin_objset
// file vm/builtins.c line 350
static struct _value * builtin_objset(struct _value *o, struct _value *f, struct _value *v)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return val_null;

  else
    if((1 & (signed int)f) == 0)
      return (struct _value *)(void *)0;

    else
    {
      neko_alloc_field(o, (signed int)(signed long int)f >> 1, v);
      return v;
    }
}

// builtin_objsetproto
// file vm/builtins.c line 448
static struct _value * builtin_objsetproto(struct _value *o, struct _value *p)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    if(p == val_null)
      ((struct _vobject *)o)->proto = (struct _vobject *)(void *)0;

    else
    {
      if((1 & (signed int)p) == 0)
        tmp_if_expr_2 = (signed int)*((enum anonymous_7 *)p) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        return (struct _value *)(void *)0;

      ((struct _vobject *)o)->proto = (struct _vobject *)p;
    }
    return val_null;
  }
}

// builtin_pcompare
// file vm/builtins.c line 1166
static struct _value * builtin_pcompare(struct _value *a, struct _value *b)
{
  signed long int ia = (signed long int)a;
  signed long int ib = (signed long int)b;
  if(!(ib >= ia))
    return (struct _value *)(signed long int)((signed int)1 << 1 | 1);

  else
    if(!(ia >= ib))
      return (struct _value *)(signed long int)((signed int)-1 << 1 | 1);

    else
      return (struct _value *)(signed long int)((signed int)0 << 1 | 1);
}

// builtin_print
// file vm/builtins.c line 1062
static struct _value * builtin_print(struct _value **args, signed int nargs)
{
  struct _buffer *b;
  signed int i;
  if(nargs == 1)
  {
    if(!((1 & (signed int)*args) == 0))
      goto __CPROVER_DUMP_L1;

    if(!((15 & (signed int)*((enum anonymous_7 *)*args)) == VAL_STRING))
      goto __CPROVER_DUMP_L1;

    neko_val_print(*args);
    return neko_builtins[(signed long int)1];
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    b=neko_alloc_buffer((const char *)(void *)0);
    i = 0;
    for( ; !(i >= nargs); i = i + 1)
      neko_val_buffer(b, args[(signed long int)i]);
    struct _value *return_value_neko_buffer_to_string_1;
    return_value_neko_buffer_to_string_1=neko_buffer_to_string(b);
    neko_val_print(return_value_neko_buffer_to_string_1);
    return neko_builtins[(signed long int)1];
  }
}

// builtin_rethrow
// file vm/builtins.c line 1089
static struct _value * builtin_rethrow(struct _value *v)
{
  neko_val_rethrow(v);
  return val_null;
}

// builtin_sblit
// file vm/builtins.c line 279
static struct _value * builtin_sblit(struct _value *dst, struct _value *dp, struct _value *src, struct _value *sp, struct _value *l)
{
  signed int dpp;
  signed int spp;
  signed int ll;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)dst) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)dst) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)dp) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)src) == 0)
        tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)src) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        return (struct _value *)(void *)0;

      else
        if((1 & (signed int)sp) == 0)
          return (struct _value *)(void *)0;

        else
          if((1 & (signed int)l) == 0)
            return (struct _value *)(void *)0;

          else
          {
            dpp = (signed int)(signed long int)dp >> 1;
            spp = (signed int)(signed long int)sp >> 1;
            ll = (signed int)(signed long int)l >> 1;
            if(!(dpp + ll >= 0) || !(ll + spp >= 0) || !(dpp >= 0) || !(ll >= 0) || !(spp >= 0))
              tmp_if_expr_3 = (_Bool)1;

            else
              tmp_if_expr_3 = dpp + ll > (signed int)*((enum anonymous_7 *)dst) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_3)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = spp + ll > (signed int)*((enum anonymous_7 *)src) >> 4 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
              return (struct _value *)(void *)0;

            else
            {
              memmove((void *)(&((struct anonymous_5 *)dst)->c + (signed long int)dpp), (const void *)(&((struct anonymous_5 *)src)->c + (signed long int)spp), (unsigned long int)ll);
              return val_null;
            }
          }
    }
}

// builtin_scopy
// file vm/builtins.c line 213
static struct _value * builtin_scopy(struct _value *s)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    struct _value *return_value_neko_copy_string_2;
    return_value_neko_copy_string_2=neko_copy_string(&((struct anonymous_5 *)s)->c, (signed long int)((signed int)*((enum anonymous_7 *)s) >> 4));
    return return_value_neko_copy_string_2;
  }
}

// builtin_setresolver
// file vm/builtins.c line 1213
static struct _value * builtin_setresolver(struct _value *f)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(f == val_null)
    vm->resolver = (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)f) == 0)
      tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if(!(((struct anonymous_8 *)f)->nargs == 2))
        tmp_if_expr_3 = ((struct anonymous_8 *)f)->nargs != -1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      return (struct _value *)(void *)0;

    vm->resolver = f;
  }
  return val_null;
}

// builtin_sfind
// file vm/builtins.c line 302
static struct _value * builtin_sfind(struct _value *src, struct _value *pos, struct _value *pat)
{
  signed int p;
  signed int l;
  signed int l2;
  const char *ptr;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)src) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)src) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)pos) == 0)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)pat) == 0)
        tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)pat) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        return (struct _value *)(void *)0;

      else
      {
        p = (signed int)(signed long int)pos >> 1;
        l = (signed int)*((enum anonymous_7 *)src) >> 4;
        l2 = (signed int)*((enum anonymous_7 *)pat) >> 4;
        if(p >= l || !(p >= 0))
          return (struct _value *)(void *)0;

        else
        {
          ptr = &((struct anonymous_5 *)src)->c + (signed long int)p;
          while(l + -p >= l2)
          {
            signed int return_value_memcmp_3;
            return_value_memcmp_3=memcmp((const void *)ptr, (const void *)&((struct anonymous_5 *)pat)->c, (unsigned long int)l2);
            if(return_value_memcmp_3 == 0)
              return (struct _value *)(signed long int)((signed int)p << 1 | 1);

            p = p + 1;
            ptr = ptr + 1l;
          }
          return val_null;
        }
      }
    }
}

// builtin_sget
// file vm/builtins.c line 241
static struct _value * builtin_sget(struct _value *s, struct _value *p)
{
  signed int pp;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
    {
      pp = (signed int)(signed long int)p >> 1;
      if(!(pp >= 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = pp >= (signed int)*((enum anonymous_7 *)s) >> 4 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        return val_null;

      else
        return (struct _value *)(signed long int)((signed int)(unsigned char)(&((struct anonymous_5 *)s)->c)[(signed long int)pp] << 1 | 1);
    }
}

// builtin_smake
// file vm/builtins.c line 192
static struct _value * builtin_smake(struct _value *l)
{
  struct _value *v;
  if((1 & (signed int)l) == 0)
    return (struct _value *)(void *)0;

  else
  {
    v=neko_alloc_empty_string((unsigned int)((signed int)(signed long int)l >> 1));
    memset((void *)&((struct anonymous_5 *)v)->c, 0, (unsigned long int)((signed int)(signed long int)l >> 1));
    return v;
  }
}

// builtin_sset
// file vm/builtins.c line 258
static struct _value * builtin_sset(struct _value *s, struct _value *p, struct _value *c)
{
  signed int pp;
  unsigned char cc;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)c) == 0)
        return (struct _value *)(void *)0;

      else
      {
        pp = (signed int)(signed long int)p >> 1;
        if(!(pp >= 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = pp >= (signed int)*((enum anonymous_7 *)s) >> 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          return val_null;

        else
        {
          cc = (unsigned char)((signed int)(signed long int)c >> 1);
          (&((struct anonymous_5 *)s)->c)[(signed long int)pp] = (char)cc;
          return (struct _value *)(signed long int)((signed int)cc << 1 | 1);
        }
      }
}

// builtin_ssize
// file vm/builtins.c line 204
static struct _value * builtin_ssize(struct _value *s)
{
  _Bool tmp_if_expr_1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    return (struct _value *)(signed long int)((signed int)((signed int)*((enum anonymous_7 *)s) >> 4) << 1 | 1);
}

// builtin_ssub
// file vm/builtins.c line 225
static struct _value * builtin_ssub(struct _value *s, struct _value *p, struct _value *l)
{
  signed int pp;
  signed int ll;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)s) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
    if((1 & (signed int)p) == 0)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)l) == 0)
        return (struct _value *)(void *)0;

      else
      {
        pp = (signed int)(signed long int)p >> 1;
        ll = (signed int)(signed long int)l >> 1;
        if(!(ll + pp >= 0) || !(ll >= 0) || !(pp >= 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = pp + ll > (signed int)*((enum anonymous_7 *)s) >> 4 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          return (struct _value *)(void *)0;

        else
        {
          struct _value *return_value_neko_copy_string_3;
          return_value_neko_copy_string_3=neko_copy_string(&((struct anonymous_5 *)s)->c + (signed long int)pp, (signed long int)ll);
          return return_value_neko_copy_string_3;
        }
      }
}

// builtin_string
// file vm/builtins.c line 182
static struct _value * builtin_string(struct _value *v)
{
  struct _buffer *b;
  b=neko_alloc_buffer((const char *)(void *)0);
  neko_val_buffer(b, v);
  struct _value *return_value_neko_buffer_to_string_1;
  return_value_neko_buffer_to_string_1=neko_buffer_to_string(b);
  return return_value_neko_buffer_to_string_1;
}

// builtin_throw
// file vm/builtins.c line 1080
static struct _value * builtin_throw(struct _value *v)
{
  neko_val_throw(v);
  return val_null;
}

// builtin_typeof
// file vm/builtins.c line 1127
static struct _value * builtin_typeof(struct _value *v)
{
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)v) == 0))
    tmp_if_expr_1 = VAL_INT;

  else
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)v) & (1 << 4) - 1;
  switch(tmp_if_expr_1)
  {
    case VAL_INT:

    case VAL_INT32:
      return (struct _value *)(signed long int)((signed int)1 << 1 | 1);
    case VAL_NULL:
      return (struct _value *)(signed long int)((signed int)0 << 1 | 1);
    case VAL_FLOAT:
      return (struct _value *)(signed long int)((signed int)2 << 1 | 1);
    case VAL_BOOL:
      return (struct _value *)(signed long int)((signed int)3 << 1 | 1);
    case VAL_STRING:
      return (struct _value *)(signed long int)((signed int)4 << 1 | 1);
    case VAL_OBJECT:
      return (struct _value *)(signed long int)((signed int)5 << 1 | 1);
    case VAL_ARRAY:
      return (struct _value *)(signed long int)((signed int)6 << 1 | 1);
    case VAL_FUNCTION:
      return (struct _value *)(signed long int)((signed int)7 << 1 | 1);
    case VAL_ABSTRACT:
      return (struct _value *)(signed long int)((signed int)8 << 1 | 1);
    default:
      return (struct _value *)(void *)0;
  }
}

// builtin_varargs
// file vm/builtins.c line 599
static struct _value * builtin_varargs(struct _value *f)
{
  struct _value *fvar;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)f) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)f) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(!(((struct anonymous_8 *)f)->nargs == 1))
      tmp_if_expr_2 = ((struct anonymous_8 *)f)->nargs != -1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return (struct _value *)(void *)0;

  else
  {
    fvar=neko_alloc_function((void *)varargs_callback, (unsigned int)-1, "varargs");
    ((struct anonymous_8 *)fvar)->env = f;
    return fvar;
  }
}

// builtin_version
// file vm/builtins.c line 1205
static struct _value * builtin_version()
{
  return (struct _value *)(signed long int)((signed int)200 << 1 | 1);
}

// clean_c_stack
// file vm/threads.c line 103
static signed int clean_c_stack(signed int n, void *f)
{
  char buf[256l];
  memset((void *)buf, n, sizeof(char [256l]) /*256ul*/ );
  if(n == 0)
    return (signed int)buf[0l];

  else
  {
    signed int return_value;
    return_value=((signed int (*)(signed int, void *))f)(n - 1, f);
    return return_value != 0 ? 1 : 0;
  }
}

// close_module
// file vm/load.c line 187
static void close_module(void *p)
{
  fclose((struct _IO_FILE *)p);
}

// closure_callback
// file vm/builtins.c line 502
static struct _value * closure_callback(struct _value **args, signed int nargs)
{
  struct _value *env;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  env = ((struct _neko_vm *)return_value_neko_local_get_1)->env;
  signed int cargs = ((signed int)*((enum anonymous_7 *)env) >> 4) - 2;
  struct _value **a = &((struct anonymous_4 *)env)->ptr;
  struct _value *f = a[(signed long int)0];
  struct _value *o = a[(signed long int)1];
  signed int fargs = ((struct anonymous_8 *)f)->nargs;
  signed int i;
  if(!(fargs == cargs + nargs) && !(fargs == -1))
    return val_null;

  else
  {
    if(nargs == 0)
      a = &((struct anonymous_4 *)env)->ptr + (signed long int)2;

    else
      if(cargs == 0)
        a = args;

      else
      {
        char *return_value_neko_alloc_2;
        return_value_neko_alloc_2=neko_alloc((unsigned int)(sizeof(struct _value *) /*8ul*/  * (unsigned long int)(nargs + cargs)));
        a = (struct _value **)return_value_neko_alloc_2;
        i = 0;
        for( ; !(i >= cargs); i = i + 1)
          a[(signed long int)i] = (&((struct anonymous_4 *)env)->ptr)[(signed long int)(i + 2)];
        i = 0;
        for( ; !(i >= nargs); i = i + 1)
          a[(signed long int)(i + cargs)] = args[(signed long int)i];
      }
    struct _value *return_value_neko_val_callEx_3;
    return_value_neko_val_callEx_3=neko_val_callEx(o, f, a, nargs + cargs, (struct _value **)(void *)0);
    return return_value_neko_val_callEx_3;
  }
}

// cmp
// file vm/stats.c line 133
static signed int cmp(struct _statinfos *a, struct _statinfos *b)
{
  signed int delta = a->totaltime - b->totaltime;
  if(delta == 0)
    return b->ncalls - a->ncalls;

  else
    return delta;
}

// default_printer
// file vm/interp.c line 86
static void default_printer(const char *s, signed int len, void *out)
{
  while(len >= 1)
  {
    signed int p;
    unsigned long int return_value_fwrite_1;
    return_value_fwrite_1=fwrite((const void *)s, (unsigned long int)1, (unsigned long int)len, (struct _IO_FILE *)out);
    p = (signed int)return_value_fwrite_1;
    if(!(p >= 1))
    {
      fputs("[ABORTED]", (struct _IO_FILE *)out);
      break;
    }

    len = len - p;
    s = s + (signed long int)p;
  }
  fflush((struct _IO_FILE *)out);
}

// do_nothing
// file vm/threads.c line 175
static signed int do_nothing(char (*sb)[64l])
{
  return -1;
}

// executable_path
// file vm/main.c line 56
static char * executable_path()
{
  signed int length;
  signed long int return_value_readlink_1;
  static char path[1024l];
  return_value_readlink_1=readlink("/proc/self/exe", path, sizeof(char [1024l]) /*1024ul*/ );
  length = (signed int)return_value_readlink_1;
  if(length >= 1024 || !(length >= 0))
  {
    char *p;
    p=getenv("   ");
    if(p == ((char *)NULL))
      p=getenv("_");

    return p;
  }

  path[(signed long int)length] = (char)0;
  return path;
}

// execute_file
// file vm/main.c line 196
static signed int execute_file(struct _neko_vm *vm, char *file, struct _value *mload)
{
  struct _value *args[2l];
  struct _value *return_value_neko_alloc_string_1;
  return_value_neko_alloc_string_1=neko_alloc_string(file);
  args[0] = return_value_neko_alloc_string_1;
  args[1] = mload;
  struct _value *exc = (struct _value *)(void *)0;
  signed int return_value_neko_val_id_2;
  return_value_neko_val_id_2=neko_val_id("loadmodule");
  struct _value *return_value_neko_val_field_3;
  return_value_neko_val_field_3=neko_val_field(mload, return_value_neko_val_id_2);
  neko_val_callEx(mload, return_value_neko_val_field_3, args, 2, &exc);
  if(!(exc == ((struct _value *)NULL)))
  {
    report(vm, exc, 1);
    return 1;
  }

  else
    return 0;
}

// failure_to_string
// file vm/others.c line 499
static struct _value * failure_to_string()
{
  struct _value *o;
  o=neko_val_this();
  struct _buffer *b;
  b=neko_alloc_buffer((const char *)(void *)0);
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    signed int return_value_neko_val_id_2;
    return_value_neko_val_id_2=neko_val_id("file");
    struct _value *return_value_neko_val_field_3;
    return_value_neko_val_field_3=neko_val_field(o, return_value_neko_val_id_2);
    neko_val_buffer(b, return_value_neko_val_field_3);
    neko_buffer_append(b, "(");
    signed int return_value_neko_val_id_4;
    return_value_neko_val_id_4=neko_val_id("line");
    struct _value *return_value_neko_val_field_5;
    return_value_neko_val_field_5=neko_val_field(o, return_value_neko_val_id_4);
    neko_val_buffer(b, return_value_neko_val_field_5);
    neko_buffer_append(b, ") : ");
    signed int return_value_neko_val_id_6;
    return_value_neko_val_id_6=neko_val_id("msg");
    struct _value *return_value_neko_val_field_7;
    return_value_neko_val_field_7=neko_val_field(o, return_value_neko_val_id_6);
    neko_val_buffer(b, return_value_neko_val_field_7);
    struct _value *return_value_neko_buffer_to_string_8;
    return_value_neko_buffer_to_string_8=neko_buffer_to_string(b);
    return return_value_neko_buffer_to_string_8;
  }
}

// fcmp
// file vm/others.c line 44
static inline signed int fcmp(double a, double b)
{
  return IEEE_FLOAT_EQUAL(a, b) ? 0 : (a < b ? -1 : 1);
}

// get_builtin
// file vm/module.c line 121
static struct _value * get_builtin(struct _neko_module *m, signed int id)
{
  struct _value *f;
  f=neko_val_field(*neko_builtins, id);
  signed int return_value_neko_val_id_2;
  if(f == val_null)
  {
    unsigned int i = (unsigned int)0;
    for( ; !(i >= m->nfields); i = i + 1u)
    {
      return_value_neko_val_id_2=neko_val_id(&((struct anonymous_5 *)m->fields[(signed long int)i])->c);
      if(return_value_neko_val_id_2 == id)
      {
        struct _buffer *b;
        b=neko_alloc_buffer("Builtin not found : ");
        neko_val_buffer(b, m->fields[(signed long int)i]);
        struct _value *return_value_neko_buffer_to_string_1;
        return_value_neko_buffer_to_string_1=neko_buffer_to_string(b);
        _neko_failure(return_value_neko_buffer_to_string_1, "vm/module.c", 129);
      }

    }
    struct _value *return_value_neko_alloc_string_3;
    return_value_neko_alloc_string_3=neko_alloc_string("Builtin not found");
    _neko_failure(return_value_neko_alloc_string_3, "vm/module.c", 131);
  }

  return f;
}

// handle_signal
// file vm/main.c line 214
static void handle_signal(signed int signal)
{
  struct _value *return_value_neko_alloc_string_1;
  return_value_neko_alloc_string_1=neko_alloc_string("Segmentation fault");
  neko_val_throw(return_value_neko_alloc_string_1);
}

// hash_obj_rec
// file vm/hash.c line 106
static void hash_obj_rec(struct _value *v, signed int f, void *_p)
{
  struct vparam *p = (struct vparam *)_p;
  signed int *h = p->h;
  *h = *h * 65599 + (signed int)f;
  hash_rec(v, h, &p->l);
}

// hash_rec
// file vm/hash.c line 39
static void hash_rec(struct _value *v, signed int *h, struct vlist *l)
{
  enum anonymous_7 t;
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)v) == 0))
    tmp_if_expr_1 = VAL_INT;

  else
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)v) & (1 << 4) - 1;
  t = (enum anonymous_7)tmp_if_expr_1;
  switch((signed int)t)
  {
    case VAL_INT:
    {
      *h = *h * 65599 + ((signed int)(signed long int)v >> 1);
      goto __CPROVER_DUMP_L21;
    }
    case VAL_INT32:
    {
      *h = *h * 65599 + ((struct anonymous_26 *)v)->i;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_NULL:
    {
      *h = *h * 19 + 0;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_FLOAT:
    {
      signed int hash_rec__1__1__1__k = (signed int)sizeof(double) /*8ul*/ ;
      for( ; !(hash_rec__1__1__1__k == 0); *h = *h * 19 + (signed int)(&((struct anonymous_5 *)v)->c)[(signed long int)hash_rec__1__1__1__k])
        hash_rec__1__1__1__k = hash_rec__1__1__1__k - 1;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_BOOL:
    {
      *h = *h * 19 + (signed int)(v == val_true);
      goto __CPROVER_DUMP_L21;
    }
    case VAL_STRING:
    {
      signed int hash_rec__1__1__2__k = (signed int)*((enum anonymous_7 *)v) >> 4;
      for( ; !(hash_rec__1__1__2__k == 0); *h = *h * 19 + (signed int)(&((struct anonymous_5 *)v)->c)[(signed long int)hash_rec__1__1__2__k])
        hash_rec__1__1__2__k = hash_rec__1__1__2__k - 1;
      goto __CPROVER_DUMP_L21;
    }
    case VAL_OBJECT:

    case VAL_ARRAY:
    {
      struct vlist *tmp = l;
      signed int k = 0;
      for( ; !(tmp == ((struct vlist *)NULL)); tmp = tmp->next)
      {
        if(tmp->v == v)
        {
          *h = *h * 19 + k;
          goto __CPROVER_DUMP_L22;
        }

        k = k + 1;
      }
      if((signed int)t == VAL_OBJECT)
      {
        struct vparam p;
        p.h = h;
        p.l.v = v;
        p.l.next = l;
        neko_val_iter_fields(v, hash_obj_rec, (void *)&p);
        v = (struct _value *)((struct _vobject *)v)->proto;
        if(!(v == ((struct _value *)NULL)))
          hash_rec(v, h, &p.l);

      }

      else
      {
        struct vlist cur;
        signed int hash_rec__1__1__5__k = (signed int)*((enum anonymous_7 *)v) >> 4;
        cur.v = v;
        cur.next = l;
        while(!(hash_rec__1__1__5__k == 0))
        {
          hash_rec__1__1__5__k = hash_rec__1__1__5__k - 1;
          hash_rec((&((struct anonymous_4 *)v)->ptr)[(signed long int)hash_rec__1__1__5__k], h, &cur);
        }
      }
    }
    default:

      __CPROVER_DUMP_L21:
        ;
  }

__CPROVER_DUMP_L22:
  ;
}

// icmp
// file vm/others.c line 40
static inline signed int icmp(signed int a, signed int b)
{
  return a == b ? 0 : (a < b ? -1 : 1);
}

// init_path
// file vm/load.c line 265
static struct _value * init_path(const char *path)
{
  struct _value *l = val_null;
  struct _value *tmp;
  char *p;
  char *p2;
  char *allocated = (char *)(void *)0;
  if(path == ((const char *)NULL))
  {
    allocated=strdup("/usr/local/lib/neko:/usr/lib/neko:/usr/local/bin:/usr/bin");
    path = allocated;
  }

  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_6;
  while((_Bool)1)
  {
    if(!(*path == 0))
      tmp_if_expr_1 = (signed int)path[(signed long int)1] == 58 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      p=strchr(path + (signed long int)2, 58);
      p2=strchr(path + (signed long int)2, 59);
    }

    else
    {
      p=strchr(path, 58);
      p2=strchr(path, 59);
    }
    if(p == ((char *)NULL) || !(p2 == ((char *)NULL)) && !(p2 >= p))
      p = p2;

    if(!(p == ((char *)NULL)))
      *p = (char)0;

    tmp=neko_alloc_array((unsigned int)2);
    if(!(p == ((char *)NULL)))
      tmp_if_expr_2 = (signed int)p[(signed long int)-1] != 47 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (signed int)p[(signed long int)-1] != 92 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      if(p == ((char *)NULL))
      {
        return_value_strlen_4=strlen(path);
        tmp_if_expr_5 = (signed int)path[(signed long int)(return_value_strlen_4 - (unsigned long int)1)] != 47 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
      {
        return_value_strlen_6=strlen(path);
        tmp_if_expr_7 = (signed int)path[(signed long int)(return_value_strlen_6 - (unsigned long int)1)] != 92 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_7 = (_Bool)0;
      tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
    {
      struct _buffer *b;
      b=neko_alloc_buffer(path);
      char c = (char)47;
      neko_buffer_append_sub(b, &c, (signed long int)1);
      (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)0]=neko_buffer_to_string(b);
    }

    else
      (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)0]=neko_alloc_string(path);
    (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)1] = l;
    l = tmp;
    if(!(p == ((char *)NULL)))
      *p = (char)(p == p2 ? 59 : 58);

    else
      break;
    path = p + (signed long int)1;
  }
  if(!(allocated == ((char *)NULL)))
    free((void *)allocated);

  return l;
}

// jit_run
// file vm/interp.c line 265
static signed long int jit_run(struct _neko_vm *vm, struct anonymous_8 *acc)
{
  struct _neko_module *m = (struct _neko_module *)acc->module;
  signed long int return_value;
  return_value=((signed long int (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, acc->addr, (struct _value *)acc, m);
  return return_value;
}

// load_primitive
// file vm/load.c line 199
static void * load_primitive(const char *prim, signed int nargs, struct _value *path, struct _liblist **libs)
{
  char *pos;
  pos=strchr(prim, 64);
  signed int len;
  struct _liblist *l;
  struct _value * (*ptr)();
  struct _value *return_value;
  char *tmp_post_7;
  if(pos == ((char *)NULL))
    return (void *)0;

  else
  {
    l = *libs;
    *pos = (char)0;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(prim);
    len = (signed int)return_value_strlen_1 + 1;
    while(!(l == ((struct _liblist *)NULL)))
    {
      signed int return_value_memcmp_2;
      return_value_memcmp_2=memcmp((const void *)l->name, (const void *)prim, (unsigned long int)len);
      if(return_value_memcmp_2 == 0)
        break;

      l = l->next;
    }
    if(l == ((struct _liblist *)NULL))
    {
      void *h;
      struct _value *pname;
      pname=neko_select_file(path, prim, ".ndll");
      pname = pname;
      h=dlopen(&((struct anonymous_5 *)pname)->c, 0x00001);
      if(h == NULL)
      {
        struct _buffer *b;
        b=neko_alloc_buffer("Failed to load library : ");
        neko_val_buffer(b, pname);
        neko_buffer_append(b, " (");
        char *return_value_dlerror_3;
        return_value_dlerror_3=dlerror();
        neko_buffer_append(b, return_value_dlerror_3);
        neko_buffer_append(b, ")");
        *pos = (char)64;
        struct _value *return_value_neko_buffer_to_string_4;
        return_value_neko_buffer_to_string_4=neko_buffer_to_string(b);
        _neko_failure(return_value_neko_buffer_to_string_4, "vm/load.c", 237);
      }

      char *return_value_neko_alloc_5;
      return_value_neko_alloc_5=neko_alloc((unsigned int)sizeof(struct _liblist) /*24ul*/ );
      l = (struct _liblist *)return_value_neko_alloc_5;
      l->handle = h;
      l->name=neko_alloc_private((unsigned int)len);
      memcpy((void *)l->name, (const void *)prim, (unsigned long int)len);
      l->next = *libs;
      *libs = l;
      void *return_value_dlsym_6;
      return_value_dlsym_6=dlsym(l->handle, "__neko_entry_point");
      ptr = (struct _value * (*)())return_value_dlsym_6;
      if(!(ptr == ((struct _value * (*)())NULL)))
      {
        return_value=ptr();
        ((struct _value * (*)())return_value)();
      }

    }

    tmp_post_7 = pos;
    pos = pos + 1l;
    *tmp_post_7 = (char)64;
    char buf[100l];
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(pos);
    if(return_value_strlen_8 >= 91ul)
      return (void *)0;

    else
    {
      if(nargs == -1)
        sprintf(buf, "%s__MULT", pos);

      else
        sprintf(buf, "%s__%d", pos, nargs);
      void *return_value_dlsym_9;
      return_value_dlsym_9=dlsym(l->handle, buf);
      ptr = (struct _value * (*)())return_value_dlsym_9;
      if(ptr == ((struct _value * (*)())NULL))
        return (void *)0;

      else
      {
        struct _value *return_value_1;
        return_value_1=ptr();
        return (void *)return_value_1;
      }
    }
  }
}

// loader_loadmodule
// file vm/load.c line 371
static struct _value * loader_loadmodule(struct _value *mname, struct _value *vthis)
{
  struct _value *o;
  o=neko_val_this();
  struct _value *cache;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)mname) == 0)
      tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)mname) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      return (struct _value *)(void *)0;

    else
    {
      if((1 & (signed int)vthis) == 0)
        tmp_if_expr_3 = (signed int)*((enum anonymous_7 *)vthis) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        return (struct _value *)(void *)0;

      else
      {
        cache=neko_val_field(o, id_cache);
        if((1 & (signed int)cache) == 0)
          tmp_if_expr_4 = (signed int)*((enum anonymous_7 *)cache) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          return (struct _value *)(void *)0;

        else
        {
          signed int (*r)(void *, void *, signed int);
          void *p;
          struct _neko_module *m;
          struct _neko_vm *vm;
          void *return_value_neko_local_get_5;
          return_value_neko_local_get_5=neko_local_get(neko_vm_context);
          vm = (struct _neko_vm *)return_value_neko_local_get_5;
          signed int mid;
          mid=neko_val_id(&((struct anonymous_5 *)mname)->c);
          struct _value *mv;
          mv=neko_val_field(cache, mid);
          if((1 & (signed int)mv) == 0)
          {
            if(!((signed int)*((enum anonymous_7 *)mv) == VAL_ABSTRACT))
              goto __CPROVER_DUMP_L13;

            if(!(((struct anonymous_6 *)mv)->kind == neko_kind_module))
              goto __CPROVER_DUMP_L13;

            m = (struct _neko_module *)((struct anonymous_6 *)mv)->data;
            return m->exports;
          }

          else
          {

          __CPROVER_DUMP_L13:
            ;
            struct _value *return_value_neko_val_field_6;
            return_value_neko_val_field_6=neko_val_field(o, id_path);
            open_module(return_value_neko_val_field_6, &((struct anonymous_5 *)mname)->c, &r, &p);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, "neko_read_module", 1);

            m=neko_read_module(r, p, vthis);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, "neko_read_module", 0);

            close_module(p);
            if(m == ((struct _neko_module *)NULL))
            {
              struct _buffer *b;
              b=neko_alloc_buffer("Invalid module : ");
              neko_val_buffer(b, mname);
              struct _value *return_value_neko_buffer_to_string_7;
              return_value_neko_buffer_to_string_7=neko_buffer_to_string(b);
              _neko_failure(return_value_neko_buffer_to_string_7, "vm/load.c", 398);
            }

            m->name=neko_alloc_string(&((struct anonymous_5 *)mname)->c);
            mv=neko_alloc_abstract(neko_kind_module, (void *)m);
            neko_alloc_field(cache, mid, mv);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, &((struct anonymous_5 *)mname)->c, 1);

            struct _neko_vm *return_value_neko_vm_current_8;
            return_value_neko_vm_current_8=neko_vm_current();
            neko_vm_execute(return_value_neko_vm_current_8, (void *)m);
            if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
              vm->fstats(vm, &((struct anonymous_5 *)mname)->c, 0);

            return m->exports;
          }
        }
      }
    }
  }
}

// loader_loadprim
// file vm/load.c line 337
static struct _value * loader_loadprim(struct _value *prim, struct _value *nargs)
{
  struct _value *o;
  o=neko_val_this();
  struct _value *libs;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)o) == 0)
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)o) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!tmp_if_expr_1)
    return (struct _value *)(void *)0;

  else
  {
    if((1 & (signed int)prim) == 0)
      tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)prim) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      return (struct _value *)(void *)0;

    else
      if((1 & (signed int)nargs) == 0)
        return (struct _value *)(void *)0;

      else
      {
        libs=neko_val_field(o, id_loader_libs);
        if((1 & (signed int)libs) == 0)
          tmp_if_expr_3 = (signed int)*((enum anonymous_7 *)libs) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = ((struct anonymous_6 *)libs)->kind == k_loader_libs ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          return (struct _value *)(void *)0;

        else
          if((signed int)nargs >> 1 >= 10 || !((signed int)nargs >> 1 >= -1))
            return (struct _value *)(void *)0;

          else
          {
            struct _neko_vm *vm;
            void *return_value_neko_local_get_5;
            return_value_neko_local_get_5=neko_local_get(neko_vm_context);
            vm = (struct _neko_vm *)return_value_neko_local_get_5;
            void *ptr;
            struct _value *return_value_neko_val_field_6;
            return_value_neko_val_field_6=neko_val_field(o, id_path);
            ptr=load_primitive(&((struct anonymous_5 *)prim)->c, (signed int)(signed long int)nargs >> 1, return_value_neko_val_field_6, (struct _liblist **)(void *)&((struct anonymous_6 *)libs)->data);
            struct anonymous_8 *f;
            if(ptr == NULL)
            {
              struct _buffer *b;
              b=neko_alloc_buffer("Primitive not found : ");
              neko_val_buffer(b, prim);
              neko_buffer_append(b, "(");
              neko_val_buffer(b, nargs);
              neko_buffer_append(b, ")");
              struct _value *return_value_neko_buffer_to_string_7;
              return_value_neko_buffer_to_string_7=neko_buffer_to_string(b);
              _neko_failure(return_value_neko_buffer_to_string_7, "vm/load.c", 357);
            }

            struct _value *return_value_neko_copy_string_8;
            return_value_neko_copy_string_8=neko_copy_string(&((struct anonymous_5 *)prim)->c, (signed long int)((signed int)*((enum anonymous_7 *)prim) >> 4));
            struct _value *return_value_neko_alloc_function_9;
            return_value_neko_alloc_function_9=neko_alloc_function(ptr, (unsigned int)((signed int)(signed long int)nargs >> 1), &((struct anonymous_5 *)return_value_neko_copy_string_8)->c);
            f = (struct anonymous_8 *)return_value_neko_alloc_function_9;
            if(!(vm->pstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
            {
              if(!((signed int)nargs >> 1 >= 7))
              {
                struct _value *env;
                env=neko_alloc_array((unsigned int)2);
                (&((struct anonymous_4 *)env)->ptr)[(signed long int)0] = (struct _value *)f->module;
                (&((struct anonymous_4 *)env)->ptr)[(signed long int)1] = (struct _value *)((signed long int)f->addr | (signed long int)1);
                f->addr = (void *)stats_proxy;
                f->env = env;
              }

            }

            return (struct _value *)f;
          }
      }
  }
}

// main
// file vm/main.c line 219
signed int main(signed int argc, char **argv)
{
  struct _neko_vm *vm;
  struct _value *mload;
  signed int r;
  neko_global_init();
  vm=neko_vm_alloc((void *)0);
  neko_vm_select(vm);
  signed int return_value_neko_has_embedded_module_7;
  return_value_neko_has_embedded_module_7=neko_has_embedded_module(vm);
  unsigned long int return_value_strlen_5;
  if(return_value_neko_has_embedded_module_7 == 0)
  {
    signed int jit = 1;
    signed int stats = 0;
    while(argc >= 2)
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(argv[(signed long int)1], "-interp");
      if(return_value_strcmp_1 == 0)
      {
        argc = argc - 1;
        argv = argv + 1l;
        jit = 0;
      }

      else
      {
        signed int return_value_strcmp_2;
        return_value_strcmp_2=strcmp(argv[(signed long int)1], "-stats");
        if(return_value_strcmp_2 == 0)
        {
          argc = argc - 1;
          argv = argv + 1l;
          stats = 1;
          neko_vm_set_stats(vm, neko_stats_measure, neko_stats_measure);
          neko_stats_measure(vm, "total", 1);
        }

        else
        {
          signed int return_value_strcmp_3;
          return_value_strcmp_3=strcmp(argv[(signed long int)1], "-version");
          if(return_value_strcmp_3 == 0)
          {
            argc = argc - 1;
            argv = argv + 1l;
            printf("%d.%d.%d", 200 / 100, (200 / 10) % 10, 200 % 10);
            return 0;
          }

          break;
        }
      }
    }
    if(!(jit == 0))
    {
      struct sigaction act;
      act.__sigaction_handler.sa_sigaction = (void (*)(signed int, struct anonymous_19 *, void *))(void *)0;
      act.__sigaction_handler.sa_handler = handle_signal;
      act.sa_flags = 0;
      sigemptyset(&act.sa_mask);
      sigaction(11, &act, (struct sigaction *)(void *)0);
    }

    neko_vm_jit(vm, jit);
    if(argc == 1)
    {
      printf("NekoVM %d.%d.%d (c)2005-2013 Haxe Foundation\n  Usage : neko <file>\n", 200 / 100, (200 / 10) % 10, 200 % 10);
      mload = (struct _value *)(void *)0;
      r = 1;
    }

    else
    {
      mload=neko_default_loader(argv + (signed long int)2, argc - 2);
      r=execute_file(vm, argv[(signed long int)1], mload);
    }
    if(!(stats == 0))
    {
      struct _value *v;
      neko_stats_measure(vm, "total", 0);
      v=neko_stats_build(vm);
      struct _value *return_value_neko_alloc_string_4;
      return_value_neko_alloc_string_4=neko_alloc_string("TOT\tTIME\tCOUNT\tNAME\n");
      neko_val_print(return_value_neko_alloc_string_4);
      while(!(v == val_null))
      {
        char buf[256l];
        struct _value **s = &((struct anonymous_4 *)v)->ptr;
        signed int errors = (signed int)(signed long int)s[(signed long int)4] >> 1;
        sprintf(buf, "%d\t%d\t%d\t%s%c", (signed int)(signed long int)s[(signed long int)1] >> 1, (signed int)(signed long int)s[(signed long int)2] >> 1, (signed int)(signed long int)s[(signed long int)3] >> 1, &((struct anonymous_5 *)s[(signed long int)0])->c, errors != 0 ? 32 : 10);
        if(!(errors == 0))
        {
          return_value_strlen_5=strlen(buf);
          sprintf(buf + (signed long int)return_value_strlen_5, "ERRORS=%d\n", errors);
        }

        struct _value *return_value_neko_alloc_string_6;
        return_value_neko_alloc_string_6=neko_alloc_string(buf);
        neko_val_print(return_value_neko_alloc_string_6);
        v = s[(signed long int)5];
      }
    }

  }

  else
  {
    mload=neko_default_loader(argv + (signed long int)1, argc - 1);
    r=neko_execute_self(vm, mload);
  }
  signed int return_value_neko_val_id_9;
  struct _value *return_value_neko_val_field_10;
  signed int return_value_neko_val_id_8;
  if(!(mload == ((struct _value *)NULL)))
  {
    return_value_neko_val_id_9=neko_val_id("dump_prof");
    return_value_neko_val_field_10=neko_val_field(mload, return_value_neko_val_id_9);
    if(!(return_value_neko_val_field_10 == val_null))
    {
      return_value_neko_val_id_8=neko_val_id("dump_prof");
      neko_val_ocall0(mload, return_value_neko_val_id_8);
    }

  }

  vm = (struct _neko_vm *)(void *)0;
  mload = (struct _value *)(void *)0;
  neko_vm_select((struct _neko_vm *)(void *)0);
  neko_global_free();
  return r;
}

// neko_alloc
// file vm/alloc.c line 164
char * neko_alloc(unsigned int nbytes)
{
  void *tmp_if_expr_3;
  void *return_value_GC_malloc_ignore_off_page_1;
  void *return_value_GC_malloc_2;
  if(nbytes >= 257u)
  {
    return_value_GC_malloc_ignore_off_page_1=GC_malloc_ignore_off_page((unsigned long int)nbytes);
    tmp_if_expr_3 = return_value_GC_malloc_ignore_off_page_1;
  }

  else
  {
    return_value_GC_malloc_2=GC_malloc((unsigned long int)nbytes);
    tmp_if_expr_3 = return_value_GC_malloc_2;
  }
  return (char *)tmp_if_expr_3;
}

// neko_alloc_abstract
// file vm/alloc.c line 215
struct _value * neko_alloc_abstract(struct anonymous *k, void *data)
{
  struct anonymous_6 *v;
  void *return_value_GC_malloc_1;
  return_value_GC_malloc_1=GC_malloc(sizeof(struct anonymous_6) /*24ul*/ );
  v = (struct anonymous_6 *)return_value_GC_malloc_1;
  v->t = (enum anonymous_7)VAL_ABSTRACT;
  v->kind = k;
  v->data = data;
  return (struct _value *)v;
}

// neko_alloc_apply
// file vm/alloc.c line 299
extern struct _value * neko_alloc_apply(signed int nargs, struct _value *env)
{
  struct anonymous_8 *v;
  void *return_value_GC_malloc_1;
  return_value_GC_malloc_1=GC_malloc(sizeof(struct anonymous_8) /*32ul*/ );
  v = (struct anonymous_8 *)return_value_GC_malloc_1;
  v->t = (enum anonymous_7)VAL_PRIMITIVE;
  struct _value *return_value_neko_alloc_string_2;
  switch(nargs)
  {
    case 1:
    {
      v->addr = (void *)apply1;
      break;
    }
    case 2:
    {
      v->addr = (void *)apply2;
      break;
    }
    case 3:
    {
      v->addr = (void *)apply3;
      break;
    }
    case 4:
    {
      v->addr = (void *)apply4;
      break;
    }
    case 5:
    {
      v->addr = (void *)apply5;
      break;
    }
    default:
    {
      return_value_neko_alloc_string_2=neko_alloc_string("Too many apply arguments");
      _neko_failure(return_value_neko_alloc_string_2, "vm/alloc.c", 308);
    }
  }
  v->nargs = nargs;
  v->env = env;
  v->module = (void *)*apply_string;
  return (struct _value *)v;
}

// neko_alloc_array
// file vm/neko.h line 400
struct _value * neko_alloc_array(unsigned int n)
{
  struct _value *v;
  struct _value *return_value_neko_alloc_string_1;
  void *tmp_if_expr_4;
  void *return_value_GC_malloc_ignore_off_page_2;
  void *return_value_GC_malloc_3;
  if(n == 0u)
    return (struct _value *)(void *)&empty_array;

  else
  {
    if(n >= 268435456u)
    {
      return_value_neko_alloc_string_1=neko_alloc_string("max_array_size reached");
      _neko_failure(return_value_neko_alloc_string_1, "vm/alloc.c", 209);
    }

    if(sizeof(struct _value *) /*8ul*/  * (unsigned long int)(n + 4294967295u) + sizeof(struct anonymous_4) /*16ul*/  >= 257ul)
    {
      return_value_GC_malloc_ignore_off_page_2=GC_malloc_ignore_off_page(sizeof(struct anonymous_4) /*16ul*/  + (unsigned long int)(n - (unsigned int)1) * sizeof(struct _value *) /*8ul*/ );
      tmp_if_expr_4 = return_value_GC_malloc_ignore_off_page_2;
    }

    else
    {
      return_value_GC_malloc_3=GC_malloc(sizeof(struct anonymous_4) /*16ul*/  + (unsigned long int)(n - (unsigned int)1) * sizeof(struct _value *) /*8ul*/ );
      tmp_if_expr_4 = return_value_GC_malloc_3;
    }
    v = (struct _value *)tmp_if_expr_4;
    v->t = (enum anonymous_7)((unsigned int)VAL_ARRAY | n << 4);
    return v;
  }
}

// neko_alloc_buffer
// file vm/neko.h line 420
struct _buffer * neko_alloc_buffer(const char *init)
{
  struct _buffer *b;
  char *return_value_neko_alloc_1;
  return_value_neko_alloc_1=neko_alloc((unsigned int)sizeof(struct _buffer) /*16ul*/ );
  b = (struct _buffer *)return_value_neko_alloc_1;
  b->totlen = 0;
  b->blen = 16;
  b->data = (struct _stringitem *)(void *)0;
  if(!(init == ((const char *)NULL)))
    neko_buffer_append(b, init);

  return b;
}

// neko_alloc_empty_string
// file vm/alloc.c line 172
struct _value * neko_alloc_empty_string(unsigned int size)
{
  struct anonymous_5 *s;
  struct _value *return_value_neko_alloc_string_1;
  void *tmp_if_expr_4;
  void *return_value_GC_malloc_atomic_ignore_off_page_2;
  void *return_value_GC_malloc_atomic_3;
  if(size == 0u)
    return (struct _value *)&empty_string;

  else
  {
    if(size >= 268435456u)
    {
      return_value_neko_alloc_string_1=neko_alloc_string("max_string_size reached");
      _neko_failure(return_value_neko_alloc_string_1, "vm/alloc.c", 177);
    }

    if(sizeof(struct anonymous_5) /*8ul*/  + (unsigned long int)size >= 257ul)
    {
      return_value_GC_malloc_atomic_ignore_off_page_2=GC_malloc_atomic_ignore_off_page((unsigned long int)size + sizeof(struct anonymous_5) /*8ul*/ );
      tmp_if_expr_4 = return_value_GC_malloc_atomic_ignore_off_page_2;
    }

    else
    {
      return_value_GC_malloc_atomic_3=GC_malloc_atomic((unsigned long int)size + sizeof(struct anonymous_5) /*8ul*/ );
      tmp_if_expr_4 = return_value_GC_malloc_atomic_3;
    }
    s = (struct anonymous_5 *)tmp_if_expr_4;
    s->t = (enum anonymous_7)((unsigned int)VAL_STRING | size << 4);
    (&s->c)[(signed long int)size] = (char)0;
    return (struct _value *)s;
  }
}

// neko_alloc_field
// file vm/neko.h line 396
void neko_alloc_field(struct _value *obj, signed int f, struct _value *v)
{
  otable_replace(&((struct _vobject *)obj)->table, f, v);
}

// neko_alloc_float
// file vm/alloc.c line 190
struct _value * neko_alloc_float(double f)
{
  struct anonymous_25 *v;
  void *return_value_GC_malloc_atomic_1;
  return_value_GC_malloc_atomic_1=GC_malloc_atomic(sizeof(struct anonymous_25) /*12ul*/ );
  v = (struct anonymous_25 *)return_value_GC_malloc_atomic_1;
  v->t = (enum anonymous_7)VAL_FLOAT;
  v->f = f;
  return (struct _value *)v;
}

// neko_alloc_function
// file vm/neko.h line 418
struct _value * neko_alloc_function(void *c_prim, unsigned int nargs, const char *name)
{
  struct anonymous_8 *v;
  struct _value *return_value_neko_alloc_string_1;
  if(c_prim == NULL)
  {
    return_value_neko_alloc_string_1=neko_alloc_string("alloc_function");
    _neko_failure(return_value_neko_alloc_string_1, "vm/alloc.c", 226);
  }

  void *return_value_GC_malloc_2;
  return_value_GC_malloc_2=GC_malloc(sizeof(struct anonymous_8) /*32ul*/ );
  v = (struct anonymous_8 *)return_value_GC_malloc_2;
  v->t = (enum anonymous_7)VAL_PRIMITIVE;
  v->addr = c_prim;
  v->nargs = (signed int)nargs;
  v->env=neko_alloc_array((unsigned int)0);
  struct _value *return_value_neko_alloc_string_3;
  return_value_neko_alloc_string_3=neko_alloc_string(name);
  v->module = (void *)return_value_neko_alloc_string_3;
  return (struct _value *)v;
}

// neko_alloc_int32
// file vm/alloc.c line 197
struct _value * neko_alloc_int32(signed int i)
{
  struct anonymous_26 *v;
  void *return_value_GC_malloc_atomic_1;
  return_value_GC_malloc_atomic_1=GC_malloc_atomic(sizeof(struct anonymous_26) /*8ul*/ );
  v = (struct anonymous_26 *)return_value_GC_malloc_atomic_1;
  v->t = (enum anonymous_7)VAL_INT32;
  v->i = i;
  return (struct _value *)v;
}

// neko_alloc_local
// file vm/neko.h line 438
struct _mt_local * neko_alloc_local()
{
  struct _mt_local *l;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _mt_local) /*4ul*/ );
  l = (struct _mt_local *)return_value_malloc_1;
  pthread_key_create(&l->key, (void (*)(void *))(void *)0);
  return l;
}

// neko_alloc_lock
// file vm/neko.h line 443
struct _mt_lock * neko_alloc_lock()
{
  struct _mt_lock *l;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _mt_lock) /*40ul*/ );
  l = (struct _mt_lock *)return_value_malloc_1;
  union anonymous_21 a;
  pthread_mutexattr_init(&a);
  pthread_mutexattr_settype(&a, 1);
  pthread_mutex_init(&l->lock, &a);
  pthread_mutexattr_destroy(&a);
  return l;
}

// neko_alloc_module_function
// file vm/alloc.c line 236
struct _value * neko_alloc_module_function(void *m, signed long int pos, signed int nargs)
{
  struct anonymous_8 *v;
  struct _value *return_value_neko_alloc_string_1;
  if(!(nargs == -1) && !(nargs >= 0))
  {
    return_value_neko_alloc_string_1=neko_alloc_string("alloc_module_function");
    _neko_failure(return_value_neko_alloc_string_1, "vm/alloc.c", 239);
  }

  void *return_value_GC_malloc_2;
  return_value_GC_malloc_2=GC_malloc(sizeof(struct anonymous_8) /*32ul*/ );
  v = (struct anonymous_8 *)return_value_GC_malloc_2;
  v->t = (enum anonymous_7)VAL_FUNCTION;
  v->addr = (void *)pos;
  v->nargs = nargs;
  v->env=neko_alloc_array((unsigned int)0);
  v->module = m;
  return (struct _value *)v;
}

// neko_alloc_object
// file vm/alloc.c line 316
struct _value * neko_alloc_object(struct _value *cpy)
{
  struct _vobject *v;
  _Bool tmp_if_expr_2;
  struct _value *return_value_neko_alloc_string_1;
  if(!(cpy == ((struct _value *)NULL)) && !(cpy == val_null))
  {
    if((1 & (signed int)cpy) == 0)
      tmp_if_expr_2 = (signed int)*((enum anonymous_7 *)cpy) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
    {
      return_value_neko_alloc_string_1=neko_alloc_string("_new");
      neko_val_throw(return_value_neko_alloc_string_1);
    }

  }

  void *return_value_GC_malloc_3;
  return_value_GC_malloc_3=GC_malloc(sizeof(struct _vobject) /*32ul*/ );
  v = (struct _vobject *)return_value_GC_malloc_3;
  v->t = (enum anonymous_7)VAL_OBJECT;
  if(cpy == ((struct _value *)NULL) || cpy == val_null)
  {
    v->proto = (struct _vobject *)(void *)0;
    otable_init(&v->table);
  }

  else
  {
    v->proto = ((struct _vobject *)cpy)->proto;
    otable_copy(&((struct _vobject *)cpy)->table, &v->table);
  }
  return (struct _value *)v;
}

// neko_alloc_private
// file vm/alloc.c line 168
char * neko_alloc_private(unsigned int nbytes)
{
  void *tmp_if_expr_3;
  void *return_value_GC_malloc_atomic_ignore_off_page_1;
  void *return_value_GC_malloc_atomic_2;
  if(nbytes >= 257u)
  {
    return_value_GC_malloc_atomic_ignore_off_page_1=GC_malloc_atomic_ignore_off_page((unsigned long int)nbytes);
    tmp_if_expr_3 = return_value_GC_malloc_atomic_ignore_off_page_1;
  }

  else
  {
    return_value_GC_malloc_atomic_2=GC_malloc_atomic((unsigned long int)nbytes);
    tmp_if_expr_3 = return_value_GC_malloc_atomic_2;
  }
  return (char *)tmp_if_expr_3;
}

// neko_alloc_root
// file vm/alloc.c line 357
struct _value ** neko_alloc_root(unsigned int nvals)
{
  void *return_value_GC_malloc_uncollectable_1;
  return_value_GC_malloc_uncollectable_1=GC_malloc_uncollectable((unsigned long int)nvals * sizeof(struct _value *) /*8ul*/ );
  return (struct _value **)return_value_GC_malloc_uncollectable_1;
}

// neko_alloc_string
// file vm/neko.h line 388
struct _value * neko_alloc_string(const char *str)
{
  if(str == ((const char *)NULL))
    return val_null;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(str);
    struct _value *return_value_neko_copy_string_2;
    return_value_neko_copy_string_2=neko_copy_string(str, (signed long int)return_value_strlen_1);
    return return_value_neko_copy_string_2;
  }
}

// neko_append_int
// file vm/others.c line 323
struct _value * neko_append_int(struct _neko_vm *vm, struct _value *str, signed int x, signed int way)
{
  signed int len;
  signed int len2;
  struct _value *v;
  len = (signed int)*((enum anonymous_7 *)str) >> 4;
  len2=sprintf(vm->tmp, "%d", x);
  v=neko_alloc_empty_string((unsigned int)(len + len2));
  if(!(way == 0))
  {
    memcpy((void *)(char *)&((struct anonymous_5 *)v)->c, (const void *)&((struct anonymous_5 *)str)->c, (unsigned long int)len);
    memcpy((void *)((char *)&((struct anonymous_5 *)v)->c + (signed long int)len), (const void *)vm->tmp, (unsigned long int)(len2 + 1));
  }

  else
  {
    memcpy((void *)(char *)&((struct anonymous_5 *)v)->c, (const void *)vm->tmp, (unsigned long int)len2);
    memcpy((void *)((char *)&((struct anonymous_5 *)v)->c + (signed long int)len2), (const void *)&((struct anonymous_5 *)str)->c, (unsigned long int)(len + 1));
  }
  return v;
}

// neko_append_strings
// file vm/others.c line 339
struct _value * neko_append_strings(struct _value *s1, struct _value *s2)
{
  signed int len1 = (signed int)*((enum anonymous_7 *)s1) >> 4;
  signed int len2 = (signed int)*((enum anonymous_7 *)s2) >> 4;
  struct _value *v;
  v=neko_alloc_empty_string((unsigned int)(len1 + len2));
  memcpy((void *)(char *)&((struct anonymous_5 *)v)->c, (const void *)&((struct anonymous_5 *)s1)->c, (unsigned long int)len1);
  memcpy((void *)((char *)&((struct anonymous_5 *)v)->c + (signed long int)len1), (const void *)&((struct anonymous_5 *)s2)->c, (unsigned long int)(len2 + 1));
  return v;
}

// neko_buffer_append
// file vm/neko.h line 421
void neko_buffer_append(struct _buffer *b, const char *s)
{
  if(!(s == ((const char *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    neko_buffer_append_sub(b, s, (signed long int)return_value_strlen_1);
  }

}

// neko_buffer_append_char
// file vm/neko.h line 423
void neko_buffer_append_char(struct _buffer *b, char c)
{
  struct _stringitem *it;
  b->totlen = b->totlen + 1;
  it = b->data;
  signed int tmp_post_1;
  if(!(it == ((struct _stringitem *)NULL)))
  {
    if(it->len == it->size)
      goto __CPROVER_DUMP_L1;

    tmp_post_1 = it->len;
    it->len = it->len + 1;
    it->str[(signed long int)tmp_post_1] = c;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    buffer_append_new(b, &c, 1);
  }
}

// neko_buffer_append_sub
// file vm/neko.h line 422
void neko_buffer_append_sub(struct _buffer *b, const char *s, signed long int _len)
{
  struct _stringitem *it;
  signed int len = (signed int)_len;
  if(!(s == ((const char *)NULL)) && len >= 1)
  {
    b->totlen = b->totlen + len;
    it = b->data;
    if(!(it == ((struct _stringitem *)NULL)))
    {
      signed int neko_buffer_append_sub__1__1__free = it->size - it->len;
      if(neko_buffer_append_sub__1__1__free >= len)
      {
        memcpy((void *)(it->str + (signed long int)it->len), (const void *)s, (unsigned long int)len);
        it->len = it->len + len;
        goto __CPROVER_DUMP_L5;
      }

      else
      {
        memcpy((void *)(it->str + (signed long int)it->len), (const void *)s, (unsigned long int)neko_buffer_append_sub__1__1__free);
        it->len = it->len + neko_buffer_append_sub__1__1__free;
        s = s + (signed long int)neko_buffer_append_sub__1__1__free;
        len = len - neko_buffer_append_sub__1__1__free;
      }
    }

    buffer_append_new(b, s, len);
  }


__CPROVER_DUMP_L5:
  ;
}

// neko_buffer_to_string
// file vm/neko.h line 424
struct _value * neko_buffer_to_string(struct _buffer *b)
{
  struct _value *v;
  v=neko_alloc_empty_string((unsigned int)b->totlen);
  struct _stringitem *it = b->data;
  char *s = (char *)&((struct anonymous_5 *)v)->c + (signed long int)b->totlen;
  while(!(it == ((struct _stringitem *)NULL)))
  {
    struct _stringitem *tmp;
    s = s - (signed long int)it->len;
    memcpy((void *)s, (const void *)it->str, (unsigned long int)it->len);
    tmp = it->next;
    it = tmp;
  }
  return v;
}

// neko_call_stack
// file vm/neko_vm.h line 47
struct _value * neko_call_stack(struct _neko_vm *vm)
{
  struct _value *return_value_neko_flush_stack_1;
  return_value_neko_flush_stack_1=neko_flush_stack(vm->csp, vm->spmin - (signed long int)1, (struct _value *)(void *)0);
  return return_value_neko_flush_stack_1;
}

// neko_can_jit
// file vm/jit_x86.c line 2778
signed int neko_can_jit()
{
  return 0;
}

// neko_check_stack
// file vm/module.c line 138
static signed int neko_check_stack(struct _neko_module *m, unsigned char *tmp, unsigned int i, signed int stack, signed int istack)
{
  unsigned int itmp;
  _Bool tmp_if_expr_3;
  while((_Bool)1)
  {
    signed int c = (signed int)m->code[(signed long int)i];
    signed int s = stack_table[(signed long int)c];
    if(tmp[(signed long int)i] == 255)
      tmp[(signed long int)i] = (unsigned char)stack;

    else
      if(!((signed int)tmp[(signed long int)i] == stack))
        return 0;

      else
        return 1;
    if(s == 0xFF)
      stack = stack + (signed int)m->code[(signed long int)(i + (unsigned int)1)];

    else
      if(s == -255)
        stack = stack - (signed int)m->code[(signed long int)(i + (unsigned int)1)];

      else
        stack = stack + s;
    if(stack >= 128 || !(stack >= istack))
      return 0;

    switch(c)
    {
      case 23:

      case 24:

      case 25:

      case 26:
      {
        itmp = (unsigned int)(signed int)((signed long int *)m->code[(signed long int)(i + (unsigned int)1)] - m->code);
        if(tmp[(signed long int)itmp] == 255)
        {
          if(c == 26)
            stack = stack - s;

          signed int return_value_neko_check_stack_1;
          return_value_neko_check_stack_1=neko_check_stack(m, tmp, itmp, stack, istack);
          if(return_value_neko_check_stack_1 == 0)
            return 0;

          if(c == 26)
            stack = stack + s;

        }

        else
          if(!((signed int)tmp[(signed long int)itmp] == stack))
            return 0;

        if(c == 23)
          return 1;

        goto __CPROVER_DUMP_L37;
      }
      case 56:
      {
        itmp = (unsigned int)(signed int)m->code[(signed long int)(i + (unsigned int)1)];
        i = i + itmp;
        while(itmp >= 1u)
        {
          itmp = itmp - (unsigned int)2;
          if(!(m->code[(signed long int)(i + -itmp)] == 23l))
            return 0;

          signed int return_value_neko_check_stack_2;
          return_value_neko_check_stack_2=neko_check_stack(m, tmp, i - itmp, stack, istack);
          if(return_value_neko_check_stack_2 == 0)
            return 0;

        }
        goto __CPROVER_DUMP_L37;
      }
      case 5:

      case 12:
      {
        if(m->code[(signed long int)(1u + i)] >= (signed long int)stack)
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 58:
      {
        if(!(stack >= 1))
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 59:
      {
        if(!(stack >= 2))
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 67:
      {
        if(!(stack == 0))
          return 0;

        return 1;
      }
      case 28:
      {
        if(!(m->code[(signed long int)(1u + i)] == (signed long int)stack))
          return 0;

        return 1;
      }
      case 22:
      {
        stack = stack - 1;
        if(!(stack >= istack))
          return 0;

        goto __CPROVER_DUMP_L37;
      }
      case 63:
      {
        if(!((signed long int)stack + -(7l & m->code[(signed long int)(1u + i)]) >= (signed long int)istack))
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = m->code[(signed long int)(i + (unsigned int)1)] >> 3 != (signed long int)stack ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
          return 0;

        return 1;
      }
      default:
      {

      __CPROVER_DUMP_L37:
        ;
        i = i + (unsigned int)(parameter_table[(signed long int)c] != 0 ? 2 : 1);
      }
    }
  }
  return 1;
}

// neko_copy_string
// file vm/alloc.c line 333
struct _value * neko_copy_string(const char *str, signed long int strlen)
{
  struct _value *v;
  v=neko_alloc_empty_string((unsigned int)strlen);
  char *c = (char *)&((struct anonymous_5 *)v)->c;
  memcpy((void *)c, (const void *)str, (unsigned long int)strlen);
  return v;
}

// neko_default_loader
// file vm/neko_vm.h line 54
struct _value * neko_default_loader(char **argv, signed int argc)
{
  struct _value *o;
  o=neko_alloc_object((struct _value *)(void *)0);
  struct _value *args;
  args=neko_alloc_array((unsigned int)argc);
  signed int i = 0;
  for( ; !(i >= argc); i = i + 1)
    (&((struct anonymous_4 *)args)->ptr)[(signed long int)i]=neko_alloc_string(argv[(signed long int)i]);
  char *return_value_getenv_1;
  return_value_getenv_1=getenv("NEKOPATH");
  struct _value *return_value_init_path_2;
  return_value_init_path_2=init_path(return_value_getenv_1);
  neko_alloc_field(o, id_path, return_value_init_path_2);
  struct _value *return_value_neko_alloc_object_3;
  return_value_neko_alloc_object_3=neko_alloc_object((struct _value *)(void *)0);
  neko_alloc_field(o, id_cache, return_value_neko_alloc_object_3);
  struct _value *return_value_neko_alloc_abstract_4;
  return_value_neko_alloc_abstract_4=neko_alloc_abstract(k_loader_libs, (void *)0);
  neko_alloc_field(o, id_loader_libs, return_value_neko_alloc_abstract_4);
  signed int return_value_neko_val_id_5;
  return_value_neko_val_id_5=neko_val_id("args");
  neko_alloc_field(o, return_value_neko_val_id_5, args);
  signed int return_value_neko_val_id_6;
  return_value_neko_val_id_6=neko_val_id("loadprim");
  struct _value *return_value_neko_alloc_function_7;
  return_value_neko_alloc_function_7=neko_alloc_function((void *)loader_loadprim, (unsigned int)2, "loadprim");
  neko_alloc_field(o, return_value_neko_val_id_6, return_value_neko_alloc_function_7);
  signed int return_value_neko_val_id_8;
  return_value_neko_val_id_8=neko_val_id("loadmodule");
  struct _value *return_value_neko_alloc_function_9;
  return_value_neko_alloc_function_9=neko_alloc_function((void *)loader_loadmodule, (unsigned int)2, "loadmodule");
  neko_alloc_field(o, return_value_neko_val_id_8, return_value_neko_alloc_function_9);
  return o;
}

// neko_exc_stack
// file vm/neko_vm.h line 46
struct _value * neko_exc_stack(struct _neko_vm *vm)
{
  return vm->exc_stack;
}

// neko_execute_self
// file vm/main.c line 165
signed int neko_execute_self(struct _neko_vm *vm, struct _value *mload)
{
  struct _value *args[2l];
  struct _value *return_value_neko_alloc_string_1;
  return_value_neko_alloc_string_1=neko_alloc_string("std@module_read");
  args[0] = return_value_neko_alloc_string_1;
  args[1] = (struct _value *)(signed long int)((signed int)2 << 1 | 1);
  struct _value *args2[2l];
  struct _value *return_value_neko_alloc_string_2;
  return_value_neko_alloc_string_2=neko_alloc_string("std@module_exec");
  args2[0] = return_value_neko_alloc_string_2;
  args2[1] = (struct _value *)(signed long int)((signed int)1 << 1 | 1);
  struct _value *args3[2l];
  struct _value *return_value_neko_alloc_function_3;
  return_value_neko_alloc_function_3=neko_alloc_function((void *)read_bytecode, (unsigned int)3, "boot_read_bytecode");
  args3[0] = return_value_neko_alloc_function_3;
  args3[1] = mload;
  struct _value *exc = (struct _value *)(void *)0;
  struct _value *module_read;
  struct _value *module_exec;
  struct _value *module_val;
  signed int return_value_neko_val_id_4;
  return_value_neko_val_id_4=neko_val_id("loadprim");
  struct _value *return_value_neko_val_field_5;
  return_value_neko_val_field_5=neko_val_field(mload, return_value_neko_val_id_4);
  module_read=neko_val_callEx(mload, return_value_neko_val_field_5, args, 2, &exc);
  if(!(exc == ((struct _value *)NULL)))
  {
    report(vm, exc, 1);
    return 1;
  }

  else
  {
    signed int return_value_neko_val_id_6;
    return_value_neko_val_id_6=neko_val_id("loadprim");
    struct _value *return_value_neko_val_field_7;
    return_value_neko_val_field_7=neko_val_field(mload, return_value_neko_val_id_6);
    module_exec=neko_val_callEx(mload, return_value_neko_val_field_7, args2, 2, &exc);
    if(!(exc == ((struct _value *)NULL)))
    {
      report(vm, exc, 1);
      return 1;
    }

    else
    {
      module_val=neko_val_callEx(val_null, module_read, args3, 2, &exc);
      fclose(self);
      if(!(exc == ((struct _value *)NULL)))
      {
        report(vm, exc, 1);
        return 1;
      }

      else
      {
        signed int return_value_neko_val_id_8;
        return_value_neko_val_id_8=neko_val_id("cache");
        struct _value *return_value_neko_val_field_9;
        return_value_neko_val_field_9=neko_val_field(mload, return_value_neko_val_id_8);
        signed int return_value_neko_val_id_10;
        return_value_neko_val_id_10=neko_val_id("_self");
        neko_alloc_field(return_value_neko_val_field_9, return_value_neko_val_id_10, module_val);
        neko_val_callEx(val_null, module_exec, &module_val, 1, &exc);
        if(!(exc == ((struct _value *)NULL)))
        {
          report(vm, exc, 1);
          return 1;
        }

        else
          return 0;
      }
    }
  }
}

// neko_file_reader
// file vm/neko_mod.h line 60
signed int neko_file_reader(void *p, void *buf, signed int size)
{
  signed int len = 0;
  unsigned long int return_value_fread_1;
  signed int return_value_ferror_3;
  signed int *return_value___errno_location_2;
  while(size >= 1)
  {
    signed int l;
    do
    {

    fread_again:
      ;
      return_value_fread_1=fread(buf, (unsigned long int)1, (unsigned long int)size, (struct _IO_FILE *)p);
      l = (signed int)return_value_fread_1;
      if(l >= 1)
        goto __CPROVER_DUMP_L4;

      return_value_ferror_3=ferror((struct _IO_FILE *)p);
      if(return_value_ferror_3 == 0)
        break;

      return_value___errno_location_2=__errno_location();
    }
    while(*return_value___errno_location_2 == 4);
    return len;

  __CPROVER_DUMP_L4:
    ;
    size = size - l;
    len = len + l;
    buf = (void *)((char *)buf + (signed long int)l);
  }
  return len;
}

// neko_flush_stack
// file vm/interp.c line 510
static struct _value * neko_flush_stack(signed long int *cspup, signed long int *csp, struct _value *old)
{
  signed int ncalls = (signed int)((cspup - csp) / (signed long int)4);
  struct _value *stack_trace;
  signed int tmp_if_expr_1;
  if(old == ((struct _value *)NULL))
    tmp_if_expr_1 = 0;

  else
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)old) >> 4;
  stack_trace=neko_alloc_array((unsigned int)(ncalls + tmp_if_expr_1));
  struct _value **st = &((struct anonymous_4 *)stack_trace)->ptr;
  struct _neko_module *m;
  while(!(csp == cspup))
  {
    m = (struct _neko_module *)csp[(signed long int)4];
    if(!(m == ((struct _neko_module *)NULL)))
    {
      if(!(m->dbgidxs == ((struct _neko_debug *)NULL)))
      {
        unsigned int ppc = (unsigned int)((((signed long int **)csp)[(signed long int)1] - (signed long int)2) - m->code);
        if(!(ppc >= m->codesize))
        {
          signed int idx;
          signed int return_value_bitcount_2;
          return_value_bitcount_2=bitcount((m->dbgidxs + (signed long int)(ppc >> 5))->bits >> (unsigned int)31 - (ppc & (unsigned int)31));
          idx = (m->dbgidxs + (signed long int)(ppc >> 5))->base + return_value_bitcount_2;
          *st = (&((struct anonymous_4 *)m->dbgtbl)->ptr)[(signed long int)idx];
        }

        else
          *st = m->name;
      }

      else
        *st = m->name;
    }

    else
      *st = val_null;
    st = st + 1l;
    if(!(old == ((struct _value *)NULL)))
    {
      csp = csp + 1l;
      *csp = (signed long int)0;
      csp = csp + 1l;
      *csp = (signed long int)0;
      csp = csp + 1l;
      *csp = (signed long int)0;
      csp = csp + 1l;
      *csp = (signed long int)0;
    }

    else
      csp = csp + (signed long int)4;
  }
  signed int tmp_post_3;
  struct _value **tmp_post_4;
  struct _value **tmp_post_5;
  if(!(old == ((struct _value *)NULL)))
  {
    struct _value **oldst = &((struct anonymous_4 *)old)->ptr;
    ncalls = (signed int)*((enum anonymous_7 *)old) >> 4;
    do
    {
      tmp_post_3 = ncalls;
      ncalls = ncalls - 1;
      if(tmp_post_3 == 0)
        break;

      tmp_post_4 = st;
      st = st + 1l;
      tmp_post_5 = oldst;
      oldst = oldst + 1l;
      *tmp_post_4 = *tmp_post_5;
    }
    while((_Bool)1);
  }

  return stack_trace;
}

// neko_free_jit
// file vm/jit_x86.c line 2775
void neko_free_jit()
{
  ;
}

// neko_free_local
// file vm/neko.h line 441
void neko_free_local(struct _mt_local *l)
{
  pthread_key_delete(l->key);
  free((void *)l);
}

// neko_free_lock
// file vm/neko.h line 447
void neko_free_lock(struct _mt_lock *l)
{
  pthread_mutex_destroy(&l->lock);
  free((void *)l);
}

// neko_free_root
// file vm/alloc.c line 361
void neko_free_root(struct _value **v)
{
  GC_free((void *)v);
}

// neko_gc_init
// file vm/alloc.c line 119
void neko_gc_init()
{
  GC_set_warn_proc((void (*)(char *, unsigned long int))(void *)null_warn_proc);
  GC_all_interior_pointers = 0;
  GC_java_finalization = 1;
  GC_init();
  GC_no_dls = 1;
  GC_clear_roots();
}

// neko_gc_loop
// file vm/alloc.c line 151
void neko_gc_loop()
{
  GC_collect_a_little();
}

// neko_gc_major
// file vm/alloc.c line 155
void neko_gc_major()
{
  GC_gcollect();
}

// neko_gc_stats
// file vm/alloc.c line 159
void neko_gc_stats(signed int *heap, signed int *free)
{
  unsigned long int return_value_GC_get_heap_size_1;
  return_value_GC_get_heap_size_1=GC_get_heap_size();
  *heap = (signed int)return_value_GC_get_heap_size_1;
  unsigned long int return_value_GC_get_free_bytes_2;
  return_value_GC_get_free_bytes_2=GC_get_free_bytes();
  *free = (signed int)return_value_GC_get_free_bytes_2;
}

// neko_get_ttable
// file vm/vm.h line 70
extern signed long int * neko_get_ttable()
{
  signed long int return_value_neko_interp_loop_1;
  return_value_neko_interp_loop_1=neko_interp_loop((struct _neko_vm *)(void *)0, (struct _neko_module *)(void *)0, (signed long int)0, (signed long int *)(void *)0);
  return (signed long int *)return_value_neko_interp_loop_1;
}

// neko_global_free
// file vm/neko_vm.h line 36
void neko_global_free()
{
  neko_free_jit();
  neko_free_root((struct _value **)kind_names);
  neko_free_root(apply_string);
  neko_free_root(neko_builtins);
  neko_free_root((struct _value **)neko_fields);
  apply_string = (struct _value **)(void *)0;
  neko_free_local(neko_vm_context);
  neko_free_lock(neko_fields_lock);
  neko_gc_major();
}

// neko_global_init
// file vm/neko_vm.h line 35
void neko_global_init()
{
  signed long int *return_value_neko_get_ttable_1;
  return_value_neko_get_ttable_1=neko_get_ttable();
  op_last = return_value_neko_get_ttable_1[(signed long int)67];
  empty_array.ptr = val_null;
  neko_gc_init();
  neko_vm_context=neko_alloc_local();
  neko_fields_lock=neko_alloc_lock();
  struct _value **return_value_neko_alloc_root_2;
  return_value_neko_alloc_root_2=neko_alloc_root((unsigned int)(((unsigned long int)(63 + 1) * sizeof(struct _objtable) /*16ul*/ ) / sizeof(struct _value *) /*8ul*/ ));
  neko_fields = (struct _objtable *)return_value_neko_alloc_root_2;
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    otable_init(&neko_fields[(signed long int)i]);
  neko_init_builtins();
  struct _value **return_value_neko_alloc_root_3;
  return_value_neko_alloc_root_3=neko_alloc_root((unsigned int)1);
  kind_names = (struct _klist **)return_value_neko_alloc_root_3;
  *kind_names = (struct _klist *)(void *)0;
  id_loader=neko_val_id("loader");
  id_exports=neko_val_id("exports");
  id_cache=neko_val_id("cache");
  id_path=neko_val_id("path");
  id_loader_libs=neko_val_id("__libs");
  neko_id_module=neko_val_id("__module");
  id_compare=neko_val_id("__compare");
  id_string=neko_val_id("__string");
  id_add=neko_val_id("__add");
  id_radd=neko_val_id("__radd");
  id_sub=neko_val_id("__sub");
  id_rsub=neko_val_id("__rsub");
  id_mult=neko_val_id("__mult");
  id_rmult=neko_val_id("__rmult");
  id_div=neko_val_id("__div");
  id_rdiv=neko_val_id("__rdiv");
  id_mod=neko_val_id("__mod");
  id_rmod=neko_val_id("__rmod");
  id_get=neko_val_id("__get");
  id_set=neko_val_id("__set");
  apply_string=neko_alloc_root((unsigned int)1);
  *apply_string=neko_alloc_string("apply");
  neko_init_jit();
}

// neko_has_embedded_module
// file vm/main.c line 98
signed int neko_has_embedded_module(struct _neko_vm *vm)
{
  char *exe;
  exe=executable_path();
  unsigned char id[8l];
  signed int pos;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(exe == ((char *)NULL))
    return 0;

  else
  {
    self=fopen(exe, "rb");
    if(self == ((struct _IO_FILE *)NULL))
      return 0;

    else
    {
      fseek(self, (signed long int)-8, 2);
      unsigned long int return_value_fread_1;
      return_value_fread_1=fread((void *)id, (unsigned long int)1, (unsigned long int)8, self);
      if(!(return_value_fread_1 == 8ul))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)id[(signed long int)0] != 78 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)id[(signed long int)1] != 69 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)id[(signed long int)2] != 75 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)id[(signed long int)3] != 79 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        fclose(self);
        return 0;
      }

      else
      {
        pos = (signed int)id[(signed long int)4] | (signed int)id[(signed long int)5] << 8 | (signed int)id[(signed long int)6] << 16;
        fseek(self, (signed long int)pos, 0);
        if((1 & (signed int)id[7l]) == 0)
          neko_vm_jit(vm, 1);

        return 1;
      }
    }
  }
}

// neko_init_builtins
// file vm/builtins.c line 1227
void neko_init_builtins()
{
  neko_builtins=neko_alloc_root((unsigned int)2);
  neko_builtins[(signed long int)0]=neko_alloc_object((struct _value *)(void *)0);
  neko_builtins[(signed long int)1]=neko_alloc_function((void *)builtin_print, (unsigned int)-1, "_print");
  signed int return_value_neko_val_id_1;
  return_value_neko_val_id_1=neko_val_id("print");
  struct _value *return_value_neko_alloc_function_2;
  return_value_neko_alloc_function_2=neko_alloc_function((void *)builtin_print, (unsigned int)-1, "_print");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_1, return_value_neko_alloc_function_2);
  signed int return_value_neko_val_id_3;
  return_value_neko_val_id_3=neko_val_id("array");
  struct _value *return_value_neko_alloc_function_4;
  return_value_neko_alloc_function_4=neko_alloc_function((void *)builtin_array, (unsigned int)-1, "_array");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_3, return_value_neko_alloc_function_4);
  signed int return_value_neko_val_id_5;
  return_value_neko_val_id_5=neko_val_id("amake");
  struct _value *return_value_neko_alloc_function_6;
  return_value_neko_alloc_function_6=neko_alloc_function((void *)builtin_amake, (unsigned int)1, "_amake");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_5, return_value_neko_alloc_function_6);
  signed int return_value_neko_val_id_7;
  return_value_neko_val_id_7=neko_val_id("acopy");
  struct _value *return_value_neko_alloc_function_8;
  return_value_neko_alloc_function_8=neko_alloc_function((void *)builtin_acopy, (unsigned int)1, "_acopy");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_7, return_value_neko_alloc_function_8);
  signed int return_value_neko_val_id_9;
  return_value_neko_val_id_9=neko_val_id("asize");
  struct _value *return_value_neko_alloc_function_10;
  return_value_neko_alloc_function_10=neko_alloc_function((void *)builtin_asize, (unsigned int)1, "_asize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_9, return_value_neko_alloc_function_10);
  signed int return_value_neko_val_id_11;
  return_value_neko_val_id_11=neko_val_id("asub");
  struct _value *return_value_neko_alloc_function_12;
  return_value_neko_alloc_function_12=neko_alloc_function((void *)builtin_asub, (unsigned int)3, "_asub");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_11, return_value_neko_alloc_function_12);
  signed int return_value_neko_val_id_13;
  return_value_neko_val_id_13=neko_val_id("ablit");
  struct _value *return_value_neko_alloc_function_14;
  return_value_neko_alloc_function_14=neko_alloc_function((void *)builtin_ablit, (unsigned int)5, "_ablit");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_13, return_value_neko_alloc_function_14);
  signed int return_value_neko_val_id_15;
  return_value_neko_val_id_15=neko_val_id("aconcat");
  struct _value *return_value_neko_alloc_function_16;
  return_value_neko_alloc_function_16=neko_alloc_function((void *)builtin_aconcat, (unsigned int)1, "_aconcat");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_15, return_value_neko_alloc_function_16);
  signed int return_value_neko_val_id_17;
  return_value_neko_val_id_17=neko_val_id("smake");
  struct _value *return_value_neko_alloc_function_18;
  return_value_neko_alloc_function_18=neko_alloc_function((void *)builtin_smake, (unsigned int)1, "_smake");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_17, return_value_neko_alloc_function_18);
  signed int return_value_neko_val_id_19;
  return_value_neko_val_id_19=neko_val_id("ssize");
  struct _value *return_value_neko_alloc_function_20;
  return_value_neko_alloc_function_20=neko_alloc_function((void *)builtin_ssize, (unsigned int)1, "_ssize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_19, return_value_neko_alloc_function_20);
  signed int return_value_neko_val_id_21;
  return_value_neko_val_id_21=neko_val_id("scopy");
  struct _value *return_value_neko_alloc_function_22;
  return_value_neko_alloc_function_22=neko_alloc_function((void *)builtin_scopy, (unsigned int)1, "_scopy");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_21, return_value_neko_alloc_function_22);
  signed int return_value_neko_val_id_23;
  return_value_neko_val_id_23=neko_val_id("ssub");
  struct _value *return_value_neko_alloc_function_24;
  return_value_neko_alloc_function_24=neko_alloc_function((void *)builtin_ssub, (unsigned int)3, "_ssub");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_23, return_value_neko_alloc_function_24);
  signed int return_value_neko_val_id_25;
  return_value_neko_val_id_25=neko_val_id("sget");
  struct _value *return_value_neko_alloc_function_26;
  return_value_neko_alloc_function_26=neko_alloc_function((void *)builtin_sget, (unsigned int)2, "_sget");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_25, return_value_neko_alloc_function_26);
  signed int return_value_neko_val_id_27;
  return_value_neko_val_id_27=neko_val_id("sset");
  struct _value *return_value_neko_alloc_function_28;
  return_value_neko_alloc_function_28=neko_alloc_function((void *)builtin_sset, (unsigned int)3, "_sset");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_27, return_value_neko_alloc_function_28);
  signed int return_value_neko_val_id_29;
  return_value_neko_val_id_29=neko_val_id("sblit");
  struct _value *return_value_neko_alloc_function_30;
  return_value_neko_alloc_function_30=neko_alloc_function((void *)builtin_sblit, (unsigned int)5, "_sblit");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_29, return_value_neko_alloc_function_30);
  signed int return_value_neko_val_id_31;
  return_value_neko_val_id_31=neko_val_id("sfind");
  struct _value *return_value_neko_alloc_function_32;
  return_value_neko_alloc_function_32=neko_alloc_function((void *)builtin_sfind, (unsigned int)3, "_sfind");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_31, return_value_neko_alloc_function_32);
  signed int return_value_neko_val_id_33;
  return_value_neko_val_id_33=neko_val_id("new");
  struct _value *return_value_neko_alloc_function_34;
  return_value_neko_alloc_function_34=neko_alloc_function((void *)builtin_new, (unsigned int)1, "_new");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_33, return_value_neko_alloc_function_34);
  signed int return_value_neko_val_id_35;
  return_value_neko_val_id_35=neko_val_id("objget");
  struct _value *return_value_neko_alloc_function_36;
  return_value_neko_alloc_function_36=neko_alloc_function((void *)builtin_objget, (unsigned int)2, "_objget");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_35, return_value_neko_alloc_function_36);
  signed int return_value_neko_val_id_37;
  return_value_neko_val_id_37=neko_val_id("objset");
  struct _value *return_value_neko_alloc_function_38;
  return_value_neko_alloc_function_38=neko_alloc_function((void *)builtin_objset, (unsigned int)3, "_objset");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_37, return_value_neko_alloc_function_38);
  signed int return_value_neko_val_id_39;
  return_value_neko_val_id_39=neko_val_id("objcall");
  struct _value *return_value_neko_alloc_function_40;
  return_value_neko_alloc_function_40=neko_alloc_function((void *)builtin_objcall, (unsigned int)3, "_objcall");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_39, return_value_neko_alloc_function_40);
  signed int return_value_neko_val_id_41;
  return_value_neko_val_id_41=neko_val_id("objfield");
  struct _value *return_value_neko_alloc_function_42;
  return_value_neko_alloc_function_42=neko_alloc_function((void *)builtin_objfield, (unsigned int)2, "_objfield");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_41, return_value_neko_alloc_function_42);
  signed int return_value_neko_val_id_43;
  return_value_neko_val_id_43=neko_val_id("objremove");
  struct _value *return_value_neko_alloc_function_44;
  return_value_neko_alloc_function_44=neko_alloc_function((void *)builtin_objremove, (unsigned int)2, "_objremove");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_43, return_value_neko_alloc_function_44);
  signed int return_value_neko_val_id_45;
  return_value_neko_val_id_45=neko_val_id("objfields");
  struct _value *return_value_neko_alloc_function_46;
  return_value_neko_alloc_function_46=neko_alloc_function((void *)builtin_objfields, (unsigned int)1, "_objfields");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_45, return_value_neko_alloc_function_46);
  signed int return_value_neko_val_id_47;
  return_value_neko_val_id_47=neko_val_id("hash");
  struct _value *return_value_neko_alloc_function_48;
  return_value_neko_alloc_function_48=neko_alloc_function((void *)builtin_hash, (unsigned int)1, "_hash");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_47, return_value_neko_alloc_function_48);
  signed int return_value_neko_val_id_49;
  return_value_neko_val_id_49=neko_val_id("fasthash");
  struct _value *return_value_neko_alloc_function_50;
  return_value_neko_alloc_function_50=neko_alloc_function((void *)builtin_fasthash, (unsigned int)1, "_fasthash");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_49, return_value_neko_alloc_function_50);
  signed int return_value_neko_val_id_51;
  return_value_neko_val_id_51=neko_val_id("field");
  struct _value *return_value_neko_alloc_function_52;
  return_value_neko_alloc_function_52=neko_alloc_function((void *)builtin_field, (unsigned int)1, "_field");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_51, return_value_neko_alloc_function_52);
  signed int return_value_neko_val_id_53;
  return_value_neko_val_id_53=neko_val_id("objsetproto");
  struct _value *return_value_neko_alloc_function_54;
  return_value_neko_alloc_function_54=neko_alloc_function((void *)builtin_objsetproto, (unsigned int)2, "_objsetproto");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_53, return_value_neko_alloc_function_54);
  signed int return_value_neko_val_id_55;
  return_value_neko_val_id_55=neko_val_id("objgetproto");
  struct _value *return_value_neko_alloc_function_56;
  return_value_neko_alloc_function_56=neko_alloc_function((void *)builtin_objgetproto, (unsigned int)1, "_objgetproto");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_55, return_value_neko_alloc_function_56);
  signed int return_value_neko_val_id_57;
  return_value_neko_val_id_57=neko_val_id("int");
  struct _value *return_value_neko_alloc_function_58;
  return_value_neko_alloc_function_58=neko_alloc_function((void *)builtin_int, (unsigned int)1, "_int");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_57, return_value_neko_alloc_function_58);
  signed int return_value_neko_val_id_59;
  return_value_neko_val_id_59=neko_val_id("float");
  struct _value *return_value_neko_alloc_function_60;
  return_value_neko_alloc_function_60=neko_alloc_function((void *)builtin_float, (unsigned int)1, "_float");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_59, return_value_neko_alloc_function_60);
  signed int return_value_neko_val_id_61;
  return_value_neko_val_id_61=neko_val_id("string");
  struct _value *return_value_neko_alloc_function_62;
  return_value_neko_alloc_function_62=neko_alloc_function((void *)builtin_string, (unsigned int)1, "_string");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_61, return_value_neko_alloc_function_62);
  signed int return_value_neko_val_id_63;
  return_value_neko_val_id_63=neko_val_id("typeof");
  struct _value *return_value_neko_alloc_function_64;
  return_value_neko_alloc_function_64=neko_alloc_function((void *)builtin_typeof, (unsigned int)1, "_typeof");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_63, return_value_neko_alloc_function_64);
  signed int return_value_neko_val_id_65;
  return_value_neko_val_id_65=neko_val_id("closure");
  struct _value *return_value_neko_alloc_function_66;
  return_value_neko_alloc_function_66=neko_alloc_function((void *)builtin_closure, (unsigned int)-1, "_closure");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_65, return_value_neko_alloc_function_66);
  signed int return_value_neko_val_id_67;
  return_value_neko_val_id_67=neko_val_id("apply");
  struct _value *return_value_neko_alloc_function_68;
  return_value_neko_alloc_function_68=neko_alloc_function((void *)builtin_apply, (unsigned int)-1, "_apply");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_67, return_value_neko_alloc_function_68);
  signed int return_value_neko_val_id_69;
  return_value_neko_val_id_69=neko_val_id("varargs");
  struct _value *return_value_neko_alloc_function_70;
  return_value_neko_alloc_function_70=neko_alloc_function((void *)builtin_varargs, (unsigned int)1, "_varargs");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_69, return_value_neko_alloc_function_70);
  signed int return_value_neko_val_id_71;
  return_value_neko_val_id_71=neko_val_id("compare");
  struct _value *return_value_neko_alloc_function_72;
  return_value_neko_alloc_function_72=neko_alloc_function((void *)builtin_compare, (unsigned int)2, "_compare");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_71, return_value_neko_alloc_function_72);
  signed int return_value_neko_val_id_73;
  return_value_neko_val_id_73=neko_val_id("pcompare");
  struct _value *return_value_neko_alloc_function_74;
  return_value_neko_alloc_function_74=neko_alloc_function((void *)builtin_pcompare, (unsigned int)2, "_pcompare");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_73, return_value_neko_alloc_function_74);
  signed int return_value_neko_val_id_75;
  return_value_neko_val_id_75=neko_val_id("not");
  struct _value *return_value_neko_alloc_function_76;
  return_value_neko_alloc_function_76=neko_alloc_function((void *)builtin_not, (unsigned int)1, "_not");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_75, return_value_neko_alloc_function_76);
  signed int return_value_neko_val_id_77;
  return_value_neko_val_id_77=neko_val_id("throw");
  struct _value *return_value_neko_alloc_function_78;
  return_value_neko_alloc_function_78=neko_alloc_function((void *)builtin_throw, (unsigned int)1, "_throw");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_77, return_value_neko_alloc_function_78);
  signed int return_value_neko_val_id_79;
  return_value_neko_val_id_79=neko_val_id("rethrow");
  struct _value *return_value_neko_alloc_function_80;
  return_value_neko_alloc_function_80=neko_alloc_function((void *)builtin_rethrow, (unsigned int)1, "_rethrow");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_79, return_value_neko_alloc_function_80);
  signed int return_value_neko_val_id_81;
  return_value_neko_val_id_81=neko_val_id("nargs");
  struct _value *return_value_neko_alloc_function_82;
  return_value_neko_alloc_function_82=neko_alloc_function((void *)builtin_nargs, (unsigned int)1, "_nargs");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_81, return_value_neko_alloc_function_82);
  signed int return_value_neko_val_id_83;
  return_value_neko_val_id_83=neko_val_id("call");
  struct _value *return_value_neko_alloc_function_84;
  return_value_neko_alloc_function_84=neko_alloc_function((void *)builtin_call, (unsigned int)3, "_call");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_83, return_value_neko_alloc_function_84);
  signed int return_value_neko_val_id_85;
  return_value_neko_val_id_85=neko_val_id("isnan");
  struct _value *return_value_neko_alloc_function_86;
  return_value_neko_alloc_function_86=neko_alloc_function((void *)builtin_isnan, (unsigned int)1, "_isnan");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_85, return_value_neko_alloc_function_86);
  signed int return_value_neko_val_id_87;
  return_value_neko_val_id_87=neko_val_id("isinfinite");
  struct _value *return_value_neko_alloc_function_88;
  return_value_neko_alloc_function_88=neko_alloc_function((void *)builtin_isinfinite, (unsigned int)1, "_isinfinite");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_87, return_value_neko_alloc_function_88);
  signed int return_value_neko_val_id_89;
  return_value_neko_val_id_89=neko_val_id("istrue");
  struct _value *return_value_neko_alloc_function_90;
  return_value_neko_alloc_function_90=neko_alloc_function((void *)builtin_istrue, (unsigned int)1, "_istrue");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_89, return_value_neko_alloc_function_90);
  signed int return_value_neko_val_id_91;
  return_value_neko_val_id_91=neko_val_id("getkind");
  struct _value *return_value_neko_alloc_function_92;
  return_value_neko_alloc_function_92=neko_alloc_function((void *)builtin_getkind, (unsigned int)1, "_getkind");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_91, return_value_neko_alloc_function_92);
  signed int return_value_neko_val_id_93;
  return_value_neko_val_id_93=neko_val_id("iskind");
  struct _value *return_value_neko_alloc_function_94;
  return_value_neko_alloc_function_94=neko_alloc_function((void *)builtin_iskind, (unsigned int)2, "_iskind");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_93, return_value_neko_alloc_function_94);
  signed int return_value_neko_val_id_95;
  return_value_neko_val_id_95=neko_val_id("hnew");
  struct _value *return_value_neko_alloc_function_96;
  return_value_neko_alloc_function_96=neko_alloc_function((void *)builtin_hnew, (unsigned int)1, "_hnew");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_95, return_value_neko_alloc_function_96);
  signed int return_value_neko_val_id_97;
  return_value_neko_val_id_97=neko_val_id("hget");
  struct _value *return_value_neko_alloc_function_98;
  return_value_neko_alloc_function_98=neko_alloc_function((void *)builtin_hget, (unsigned int)3, "_hget");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_97, return_value_neko_alloc_function_98);
  signed int return_value_neko_val_id_99;
  return_value_neko_val_id_99=neko_val_id("hmem");
  struct _value *return_value_neko_alloc_function_100;
  return_value_neko_alloc_function_100=neko_alloc_function((void *)builtin_hmem, (unsigned int)3, "_hmem");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_99, return_value_neko_alloc_function_100);
  signed int return_value_neko_val_id_101;
  return_value_neko_val_id_101=neko_val_id("hset");
  struct _value *return_value_neko_alloc_function_102;
  return_value_neko_alloc_function_102=neko_alloc_function((void *)builtin_hset, (unsigned int)4, "_hset");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_101, return_value_neko_alloc_function_102);
  signed int return_value_neko_val_id_103;
  return_value_neko_val_id_103=neko_val_id("hadd");
  struct _value *return_value_neko_alloc_function_104;
  return_value_neko_alloc_function_104=neko_alloc_function((void *)builtin_hadd, (unsigned int)3, "_hadd");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_103, return_value_neko_alloc_function_104);
  signed int return_value_neko_val_id_105;
  return_value_neko_val_id_105=neko_val_id("hremove");
  struct _value *return_value_neko_alloc_function_106;
  return_value_neko_alloc_function_106=neko_alloc_function((void *)builtin_hremove, (unsigned int)3, "_hremove");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_105, return_value_neko_alloc_function_106);
  signed int return_value_neko_val_id_107;
  return_value_neko_val_id_107=neko_val_id("hresize");
  struct _value *return_value_neko_alloc_function_108;
  return_value_neko_alloc_function_108=neko_alloc_function((void *)builtin_hresize, (unsigned int)2, "_hresize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_107, return_value_neko_alloc_function_108);
  signed int return_value_neko_val_id_109;
  return_value_neko_val_id_109=neko_val_id("hkey");
  struct _value *return_value_neko_alloc_function_110;
  return_value_neko_alloc_function_110=neko_alloc_function((void *)builtin_hkey, (unsigned int)1, "_hkey");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_109, return_value_neko_alloc_function_110);
  signed int return_value_neko_val_id_111;
  return_value_neko_val_id_111=neko_val_id("hcount");
  struct _value *return_value_neko_alloc_function_112;
  return_value_neko_alloc_function_112=neko_alloc_function((void *)builtin_hcount, (unsigned int)1, "_hcount");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_111, return_value_neko_alloc_function_112);
  signed int return_value_neko_val_id_113;
  return_value_neko_val_id_113=neko_val_id("hsize");
  struct _value *return_value_neko_alloc_function_114;
  return_value_neko_alloc_function_114=neko_alloc_function((void *)builtin_hsize, (unsigned int)1, "_hsize");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_113, return_value_neko_alloc_function_114);
  signed int return_value_neko_val_id_115;
  return_value_neko_val_id_115=neko_val_id("hiter");
  struct _value *return_value_neko_alloc_function_116;
  return_value_neko_alloc_function_116=neko_alloc_function((void *)builtin_hiter, (unsigned int)2, "_hiter");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_115, return_value_neko_alloc_function_116);
  signed int return_value_neko_val_id_117;
  return_value_neko_val_id_117=neko_val_id("iadd");
  struct _value *return_value_neko_alloc_function_118;
  return_value_neko_alloc_function_118=neko_alloc_function((void *)builtin_iadd, (unsigned int)2, "_iadd");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_117, return_value_neko_alloc_function_118);
  signed int return_value_neko_val_id_119;
  return_value_neko_val_id_119=neko_val_id("isub");
  struct _value *return_value_neko_alloc_function_120;
  return_value_neko_alloc_function_120=neko_alloc_function((void *)builtin_isub, (unsigned int)2, "_isub");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_119, return_value_neko_alloc_function_120);
  signed int return_value_neko_val_id_121;
  return_value_neko_val_id_121=neko_val_id("imult");
  struct _value *return_value_neko_alloc_function_122;
  return_value_neko_alloc_function_122=neko_alloc_function((void *)builtin_imult, (unsigned int)2, "_imult");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_121, return_value_neko_alloc_function_122);
  signed int return_value_neko_val_id_123;
  return_value_neko_val_id_123=neko_val_id("idiv");
  struct _value *return_value_neko_alloc_function_124;
  return_value_neko_alloc_function_124=neko_alloc_function((void *)builtin_idiv, (unsigned int)2, "_idiv");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_123, return_value_neko_alloc_function_124);
  signed int return_value_neko_val_id_125;
  return_value_neko_val_id_125=neko_val_id("excstack");
  struct _value *return_value_neko_alloc_function_126;
  return_value_neko_alloc_function_126=neko_alloc_function((void *)builtin_excstack, (unsigned int)0, "_excstack");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_125, return_value_neko_alloc_function_126);
  signed int return_value_neko_val_id_127;
  return_value_neko_val_id_127=neko_val_id("callstack");
  struct _value *return_value_neko_alloc_function_128;
  return_value_neko_alloc_function_128=neko_alloc_function((void *)builtin_callstack, (unsigned int)0, "_callstack");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_127, return_value_neko_alloc_function_128);
  signed int return_value_neko_val_id_129;
  return_value_neko_val_id_129=neko_val_id("version");
  struct _value *return_value_neko_alloc_function_130;
  return_value_neko_alloc_function_130=neko_alloc_function((void *)builtin_version, (unsigned int)0, "_version");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_129, return_value_neko_alloc_function_130);
  signed int return_value_neko_val_id_131;
  return_value_neko_val_id_131=neko_val_id("setresolver");
  struct _value *return_value_neko_alloc_function_132;
  return_value_neko_alloc_function_132=neko_alloc_function((void *)builtin_setresolver, (unsigned int)1, "_setresolver");
  neko_alloc_field(neko_builtins[(signed long int)0], return_value_neko_val_id_131, return_value_neko_alloc_function_132);
}

// neko_init_jit
// file vm/jit_x86.c line 2772
void neko_init_jit()
{
  ;
}

// neko_interp
// file vm/vm.h line 69
extern struct _value * neko_interp(struct _neko_vm *vm, void *_m, signed long int acc, signed long int *pc)
{
  signed long int *sp;
  signed long int *csp;
  signed long int *trap;
  signed long int init_sp = vm->spmax - vm->sp;
  struct _neko_module *m = (struct _neko_module *)_m;
  struct __jmp_buf_tag old[1l];
  memcpy((void *)&old, (const void *)&vm->start, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
  signed int return_value__setjmp_4;
  return_value__setjmp_4=_setjmp(vm->start);
  _Bool tmp_if_expr_1;
  signed long int *tmp_post_3;
  _Bool tmp_if_expr_5;
  if(!(return_value__setjmp_4 == 0))
  {
    acc = (signed long int)vm->vthis;
    if(vm->trap == 0l)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = vm->trap <= init_sp ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      char **tmp;
      memcpy((void *)&vm->start, (const void *)&old, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
      tmp = (char **)vm->start;
      if(*tmp == jit_handle_trap)
        ((void (*)(struct _neko_vm *))jit_handle_trap)(vm);

      else
        longjmp(vm->start, 1);
    }

    trap = vm->spmax - vm->trap;
    if(!(trap >= vm->sp))
    {
      vm->trap = (signed long int)0;
      struct _value *return_value_neko_alloc_string_2;
      return_value_neko_alloc_string_2=neko_alloc_string("Invalid Trap");
      neko_val_throw(return_value_neko_alloc_string_2);
    }

    csp = vm->spmin + (signed long int)((signed int)(signed long int)trap[(signed long int)0] >> 1);
    vm->exc_stack=neko_flush_stack(vm->csp, csp, vm->exc_stack);
    vm->csp = csp;
    vm->vthis = (struct _value *)trap[(signed long int)1];
    vm->env = (struct _value *)trap[(signed long int)2];
    pc = (signed long int *)(trap[(signed long int)3] & (signed long int)~1);
    m = (struct _neko_module *)(signed long int *)(trap[(signed long int)4] & (signed long int)~1);
    sp = trap + (signed long int)6;
    vm->trap = (signed long int)((signed int)(signed long int)trap[(signed long int)5] >> 1);
    for( ; !(vm->sp >= sp); *tmp_post_3 = (signed long int)0)
    {
      tmp_post_3 = vm->sp;
      vm->sp = vm->sp + 1l;
    }
    if(!((1 & (signed int)m) == 0))
      goto __CPROVER_DUMP_L9;

    if(!((signed int)*((enum anonymous_7 *)m) == VAL_ABSTRACT))
      goto __CPROVER_DUMP_L9;

    if(!(((struct anonymous_6 *)m)->kind == neko_kind_module))
      goto __CPROVER_DUMP_L9;

    m = (struct _neko_module *)((struct anonymous_6 *)m)->data;
    pc = (signed long int *)(((signed long int)pc >> 1) + (signed long int)m->jit);
    acc=((signed long int (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, (void *)pc, (struct _value *)acc, m);
    return (struct _value *)acc;
  }

  else
  {

  __CPROVER_DUMP_L9:
    ;
    if(!(m->jit == NULL))
      tmp_if_expr_5 = m->code == pc ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      acc=((signed long int (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, m->jit, (struct _value *)acc, m);

    else
      acc=neko_interp_loop(vm, m, acc, pc);
    memcpy((void *)&vm->start, (const void *)&old, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
    return (struct _value *)acc;
  }
}

// neko_interp_loop
// file vm/interp.c line 613
signed long int neko_interp_loop(struct _neko_vm *vm, struct _neko_module *m, signed long int _acc, signed long int *_pc)
{
  signed long int acc = _acc;
  signed long int *pc = _pc;
  signed long int *tmp_post_1;
  signed long int *tmp_post_2;
  struct _value *return_value_neko_alloc_int32_3;
  signed long int *tmp_post_4;
  signed long int *tmp_post_5;
  struct _value *return_value_neko_alloc_string_6;
  signed long int *tmp_post_9;
  _Bool tmp_if_expr_17;
  struct _value *return_value_neko_alloc_string_11;
  struct _value *return_value_neko_alloc_string_14;
  _Bool tmp_if_expr_37;
  _Bool tmp_if_expr_36;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_35;
  struct _value *return_value_neko_alloc_string_19;
  struct _value *return_value_neko_alloc_string_22;
  signed long int *tmp_post_25;
  signed long int *tmp_post_26;
  signed long int *tmp_post_27;
  signed long int *tmp_post_28;
  _Bool tmp_if_expr_32;
  _Bool tmp_if_expr_34;
  _Bool tmp_if_expr_33;
  struct _value *return_value_neko_alloc_string_29;
  signed long int *tmp_post_38;
  _Bool tmp_if_expr_53;
  _Bool tmp_if_expr_52;
  struct _value *return_value_neko_alloc_string_39;
  struct _value *return_value_neko_alloc_string_42;
  signed long int *tmp_post_45;
  signed long int *tmp_post_46;
  signed long int *tmp_post_47;
  signed long int *tmp_post_48;
  struct _value *return_value_neko_alloc_string_49;
  _Bool tmp_if_expr_68;
  _Bool tmp_if_expr_67;
  struct _value *return_value_neko_alloc_string_54;
  struct _value *return_value_neko_alloc_string_57;
  signed long int *tmp_post_60;
  signed long int *tmp_post_61;
  signed long int *tmp_post_62;
  signed long int *tmp_post_63;
  struct _value *return_value_neko_alloc_string_64;
  _Bool tmp_if_expr_85;
  _Bool tmp_if_expr_69;
  _Bool tmp_if_expr_84;
  signed long int *tmp_post_70;
  struct _value *return_value_neko_alloc_string_71;
  struct _value *return_value_neko_alloc_string_74;
  signed long int *tmp_post_77;
  signed long int *tmp_post_78;
  signed long int *tmp_post_79;
  signed long int *tmp_post_80;
  struct _value *return_value_neko_alloc_string_81;
  signed long int *tmp_post_86;
  signed long int *tmp_post_87;
  signed long int *tmp_post_88;
  struct _value *return_value_neko_alloc_string_89;
  signed long int *tmp_post_92;
  _Bool tmp_if_expr_99;
  struct _value *return_value_neko_alloc_string_93;
  struct _value *return_value_neko_alloc_string_96;
  signed long int *tmp_post_100;
  _Bool tmp_if_expr_117;
  _Bool tmp_if_expr_118;
  _Bool tmp_if_expr_116;
  struct _value *return_value_neko_alloc_string_101;
  struct _value *return_value_neko_alloc_string_104;
  signed long int *tmp_post_106;
  signed long int *tmp_post_107;
  signed long int *tmp_post_108;
  signed long int *tmp_post_109;
  _Bool tmp_if_expr_113;
  _Bool tmp_if_expr_115;
  _Bool tmp_if_expr_114;
  struct _value *return_value_neko_alloc_string_110;
  signed long int *tmp_post_119;
  signed long int *tmp_post_120;
  _Bool tmp_if_expr_134;
  _Bool tmp_if_expr_133;
  struct _value *return_value_neko_alloc_string_121;
  struct _value *return_value_neko_alloc_string_124;
  signed long int *tmp_post_126;
  signed long int *tmp_post_127;
  signed long int *tmp_post_128;
  signed long int *tmp_post_129;
  struct _value *return_value_neko_alloc_string_130;
  signed long int *tmp_post_135;
  struct _value *return_value_neko_alloc_string_136;
  signed long int *tmp_post_138;
  signed int tmp_post_139;
  signed long int *tmp_post_140;
  _Bool tmp_if_expr_144;
  struct _value *return_value_neko_alloc_string_141;
  struct _value *return_value_neko_alloc_string_145;
  signed int tmp_post_148;
  signed int tmp_post_149;
  signed long int *tmp_post_150;
  signed long int *tmp_post_151;
  signed int tmp_post_153;
  signed long int *tmp_post_154;
  signed long int *tmp_post_155;
  signed long int *tmp_post_156;
  signed long int *tmp_post_157;
  signed long int *tmp_post_158;
  struct _value *return_value_neko_alloc_string_159;
  _Bool tmp_if_expr_193;
  struct _value *return_value_neko_alloc_string_162;
  struct _value *return_value_neko_alloc_string_164;
  signed long int *tmp_post_166;
  signed long int *tmp_post_167;
  signed long int *tmp_post_168;
  signed long int *tmp_post_169;
  struct _value *return_value_neko_alloc_string_170;
  signed long int *tmp_post_172;
  signed long int *tmp_post_173;
  signed long int *tmp_post_174;
  signed long int *tmp_post_175;
  struct _value *return_value_neko_alloc_string_176;
  signed int tmp_post_179;
  signed long int *tmp_post_180;
  struct _value *return_value_neko_alloc_string_181;
  signed long int *tmp_post_183;
  signed long int *tmp_post_184;
  signed long int *tmp_post_185;
  signed long int *tmp_post_186;
  struct _value *return_value_neko_alloc_string_187;
  struct _value *return_value_neko_alloc_string_190;
  struct _value *return_value_neko_alloc_string_194;
  _Bool tmp_if_expr_228;
  struct _value *return_value_neko_alloc_string_197;
  struct _value *return_value_neko_alloc_string_199;
  signed long int *tmp_post_201;
  signed long int *tmp_post_202;
  signed long int *tmp_post_203;
  signed long int *tmp_post_204;
  struct _value *return_value_neko_alloc_string_205;
  signed long int *tmp_post_207;
  signed long int *tmp_post_208;
  signed long int *tmp_post_209;
  signed long int *tmp_post_210;
  struct _value *return_value_neko_alloc_string_211;
  signed int tmp_post_214;
  signed long int *tmp_post_215;
  struct _value *return_value_neko_alloc_string_216;
  signed long int *tmp_post_218;
  signed long int *tmp_post_219;
  signed long int *tmp_post_220;
  signed long int *tmp_post_221;
  struct _value *return_value_neko_alloc_string_222;
  struct _value *return_value_neko_alloc_string_225;
  signed long int *tmp_post_229;
  struct _value *return_value_neko_alloc_string_230;
  _Bool tmp_if_expr_264;
  struct _value *return_value_neko_alloc_string_233;
  struct _value *return_value_neko_alloc_string_235;
  signed long int *tmp_post_237;
  signed long int *tmp_post_238;
  signed long int *tmp_post_239;
  signed long int *tmp_post_240;
  struct _value *return_value_neko_alloc_string_241;
  signed long int *tmp_post_243;
  signed long int *tmp_post_244;
  signed long int *tmp_post_245;
  signed long int *tmp_post_246;
  struct _value *return_value_neko_alloc_string_247;
  signed int tmp_post_250;
  signed long int *tmp_post_251;
  struct _value *return_value_neko_alloc_string_252;
  signed long int *tmp_post_254;
  signed long int *tmp_post_255;
  signed long int *tmp_post_256;
  signed long int *tmp_post_257;
  struct _value *return_value_neko_alloc_string_258;
  struct _value *return_value_neko_alloc_string_261;
  struct _value *return_value_neko_alloc_string_265;
  struct _value *return_value_neko_alloc_string_267;
  signed int tmp_post_270;
  signed long int *tmp_post_271;
  signed long int *tmp_post_272;
  signed int tmp_post_273;
  signed long int *tmp_post_274;
  signed long int *tmp_post_275;
  signed long int *tmp_post_276;
  signed long int *tmp_post_277;
  signed long int *tmp_post_278;
  signed long int *tmp_post_279;
  signed int tmp_post_281;
  signed long int *tmp_post_282;
  _Bool tmp_if_expr_286;
  struct _value *return_value_neko_alloc_string_283;
  signed long int *tmp_post_288;
  signed long int *tmp_post_289;
  signed long int *tmp_post_290;
  signed long int *tmp_post_291;
  _Bool tmp_if_expr_352;
  struct _value *tmp_if_expr_293;
  struct _value *return_value_neko_alloc_int32_292;
  struct _value *return_value_neko_alloc_float_294;
  struct _value *tmp_if_expr_296;
  struct _value *return_value_neko_alloc_int32_295;
  struct _value *return_value_neko_append_int_297;
  struct _value *return_value_neko_alloc_string_298;
  struct _value *return_value_neko_alloc_string_301;
  signed long int *tmp_post_304;
  signed long int *tmp_post_305;
  signed long int *tmp_post_306;
  signed long int *tmp_post_307;
  struct _value *return_value_neko_alloc_string_308;
  struct _value *return_value_neko_alloc_float_311;
  struct _value *tmp_if_expr_313;
  struct _value *return_value_neko_alloc_int32_312;
  struct _value *return_value_neko_append_int_314;
  struct _value *return_value_neko_alloc_string_315;
  struct _value *return_value_neko_alloc_string_318;
  signed long int *tmp_post_321;
  signed long int *tmp_post_322;
  signed long int *tmp_post_323;
  signed long int *tmp_post_324;
  struct _value *return_value_neko_alloc_string_325;
  struct _value *return_value_neko_alloc_float_328;
  struct _value *return_value_neko_alloc_float_329;
  struct _value *tmp_if_expr_331;
  struct _value *return_value_neko_alloc_int32_330;
  struct _value *return_value_neko_alloc_float_332;
  struct _value *return_value_neko_alloc_string_333;
  signed long int *tmp_post_336;
  signed long int *tmp_post_337;
  signed long int *tmp_post_338;
  signed long int *tmp_post_339;
  struct _value *return_value_neko_alloc_string_340;
  signed long int *tmp_post_343;
  signed long int *tmp_post_344;
  signed long int *tmp_post_345;
  signed long int *tmp_post_346;
  _Bool tmp_if_expr_351;
  struct _value *return_value_neko_alloc_string_348;
  signed long int *tmp_post_353;
  _Bool tmp_if_expr_413;
  struct _value *tmp_if_expr_355;
  struct _value *return_value_neko_alloc_int32_354;
  struct _value *return_value_neko_alloc_float_356;
  struct _value *tmp_if_expr_358;
  struct _value *return_value_neko_alloc_int32_357;
  struct _value *return_value_neko_alloc_string_359;
  struct _value *return_value_neko_alloc_string_362;
  signed long int *tmp_post_365;
  signed long int *tmp_post_366;
  signed long int *tmp_post_367;
  signed long int *tmp_post_368;
  struct _value *return_value_neko_alloc_string_369;
  struct _value *return_value_neko_alloc_float_372;
  struct _value *tmp_if_expr_374;
  struct _value *return_value_neko_alloc_int32_373;
  struct _value *return_value_neko_alloc_string_375;
  struct _value *return_value_neko_alloc_string_378;
  signed long int *tmp_post_381;
  signed long int *tmp_post_382;
  signed long int *tmp_post_383;
  signed long int *tmp_post_384;
  struct _value *return_value_neko_alloc_string_385;
  struct _value *return_value_neko_alloc_float_388;
  struct _value *return_value_neko_alloc_float_389;
  struct _value *tmp_if_expr_391;
  struct _value *return_value_neko_alloc_int32_390;
  struct _value *return_value_neko_alloc_float_392;
  struct _value *return_value_neko_alloc_string_393;
  signed long int *tmp_post_396;
  signed long int *tmp_post_397;
  signed long int *tmp_post_398;
  signed long int *tmp_post_399;
  struct _value *return_value_neko_alloc_string_400;
  struct _value *return_value_neko_alloc_string_403;
  signed long int *tmp_post_406;
  signed long int *tmp_post_407;
  signed long int *tmp_post_408;
  signed long int *tmp_post_409;
  struct _value *return_value_neko_alloc_string_410;
  signed long int *tmp_post_414;
  _Bool tmp_if_expr_474;
  struct _value *tmp_if_expr_416;
  struct _value *return_value_neko_alloc_int32_415;
  struct _value *return_value_neko_alloc_float_417;
  struct _value *tmp_if_expr_419;
  struct _value *return_value_neko_alloc_int32_418;
  struct _value *return_value_neko_alloc_string_420;
  struct _value *return_value_neko_alloc_string_423;
  signed long int *tmp_post_426;
  signed long int *tmp_post_427;
  signed long int *tmp_post_428;
  signed long int *tmp_post_429;
  struct _value *return_value_neko_alloc_string_430;
  struct _value *return_value_neko_alloc_float_433;
  struct _value *tmp_if_expr_435;
  struct _value *return_value_neko_alloc_int32_434;
  struct _value *return_value_neko_alloc_string_436;
  struct _value *return_value_neko_alloc_string_439;
  signed long int *tmp_post_442;
  signed long int *tmp_post_443;
  signed long int *tmp_post_444;
  signed long int *tmp_post_445;
  struct _value *return_value_neko_alloc_string_446;
  struct _value *return_value_neko_alloc_float_449;
  struct _value *return_value_neko_alloc_float_450;
  struct _value *tmp_if_expr_452;
  struct _value *return_value_neko_alloc_int32_451;
  struct _value *return_value_neko_alloc_float_453;
  struct _value *return_value_neko_alloc_string_454;
  signed long int *tmp_post_457;
  signed long int *tmp_post_458;
  signed long int *tmp_post_459;
  signed long int *tmp_post_460;
  struct _value *return_value_neko_alloc_string_461;
  struct _value *return_value_neko_alloc_string_464;
  signed long int *tmp_post_467;
  signed long int *tmp_post_468;
  signed long int *tmp_post_469;
  signed long int *tmp_post_470;
  struct _value *return_value_neko_alloc_string_471;
  signed long int *tmp_post_475;
  _Bool tmp_if_expr_503;
  _Bool tmp_if_expr_504;
  _Bool tmp_if_expr_507;
  _Bool tmp_if_expr_505;
  _Bool tmp_if_expr_506;
  double tmp_if_expr_477;
  double tmp_if_expr_476;
  double tmp_if_expr_479;
  double tmp_if_expr_478;
  struct _value *return_value_neko_alloc_float_480;
  _Bool tmp_if_expr_502;
  struct _value *return_value_neko_alloc_string_481;
  signed long int *tmp_post_484;
  signed long int *tmp_post_485;
  signed long int *tmp_post_486;
  signed long int *tmp_post_487;
  _Bool tmp_if_expr_501;
  struct _value *return_value_neko_alloc_string_488;
  struct _value *return_value_neko_alloc_string_491;
  signed long int *tmp_post_494;
  signed long int *tmp_post_495;
  signed long int *tmp_post_496;
  signed long int *tmp_post_497;
  struct _value *return_value_neko_alloc_string_498;
  signed long int *tmp_post_508;
  _Bool tmp_if_expr_515;
  _Bool tmp_if_expr_513;
  _Bool tmp_if_expr_514;
  _Bool tmp_if_expr_512;
  struct _value *return_value_neko_alloc_string_509;
  _Bool tmp_if_expr_580;
  struct _value *tmp_if_expr_517;
  struct _value *return_value_neko_alloc_int32_516;
  double return_value_fmod_518;
  struct _value *return_value_neko_alloc_float_519;
  struct _value *tmp_if_expr_521;
  struct _value *return_value_neko_alloc_int32_520;
  struct _value *return_value_neko_alloc_string_522;
  struct _value *return_value_neko_alloc_string_525;
  signed long int *tmp_post_528;
  signed long int *tmp_post_529;
  signed long int *tmp_post_530;
  signed long int *tmp_post_531;
  struct _value *return_value_neko_alloc_string_532;
  double return_value_fmod_535;
  struct _value *return_value_neko_alloc_float_536;
  struct _value *tmp_if_expr_538;
  struct _value *return_value_neko_alloc_int32_537;
  struct _value *return_value_neko_alloc_string_539;
  struct _value *return_value_neko_alloc_string_542;
  signed long int *tmp_post_545;
  signed long int *tmp_post_546;
  signed long int *tmp_post_547;
  signed long int *tmp_post_548;
  struct _value *return_value_neko_alloc_string_549;
  double return_value_fmod_552;
  struct _value *return_value_neko_alloc_float_553;
  double return_value_fmod_554;
  struct _value *return_value_neko_alloc_float_555;
  struct _value *tmp_if_expr_557;
  struct _value *return_value_neko_alloc_int32_556;
  double return_value_fmod_558;
  struct _value *return_value_neko_alloc_float_559;
  struct _value *return_value_neko_alloc_string_560;
  signed long int *tmp_post_563;
  signed long int *tmp_post_564;
  signed long int *tmp_post_565;
  signed long int *tmp_post_566;
  struct _value *return_value_neko_alloc_string_567;
  struct _value *return_value_neko_alloc_string_570;
  signed long int *tmp_post_573;
  signed long int *tmp_post_574;
  signed long int *tmp_post_575;
  signed long int *tmp_post_576;
  struct _value *return_value_neko_alloc_string_577;
  signed long int *tmp_post_581;
  _Bool tmp_if_expr_598;
  struct _value *tmp_if_expr_583;
  struct _value *return_value_neko_alloc_int32_582;
  _Bool tmp_if_expr_595;
  _Bool tmp_if_expr_597;
  _Bool tmp_if_expr_596;
  signed int tmp_if_expr_584;
  signed int tmp_if_expr_585;
  struct _value *tmp_if_expr_591;
  signed int tmp_if_expr_586;
  signed int tmp_if_expr_587;
  struct _value *return_value_neko_alloc_int32_588;
  signed int tmp_if_expr_589;
  signed int tmp_if_expr_590;
  struct _value *return_value_neko_alloc_string_592;
  signed long int *tmp_post_599;
  _Bool tmp_if_expr_616;
  struct _value *tmp_if_expr_601;
  struct _value *return_value_neko_alloc_int32_600;
  _Bool tmp_if_expr_613;
  _Bool tmp_if_expr_615;
  _Bool tmp_if_expr_614;
  signed int tmp_if_expr_602;
  signed int tmp_if_expr_603;
  struct _value *tmp_if_expr_609;
  signed int tmp_if_expr_604;
  signed int tmp_if_expr_605;
  struct _value *return_value_neko_alloc_int32_606;
  signed int tmp_if_expr_607;
  signed int tmp_if_expr_608;
  struct _value *return_value_neko_alloc_string_610;
  signed long int *tmp_post_617;
  _Bool tmp_if_expr_634;
  struct _value *tmp_if_expr_619;
  struct _value *return_value_neko_alloc_int32_618;
  _Bool tmp_if_expr_631;
  _Bool tmp_if_expr_633;
  _Bool tmp_if_expr_632;
  signed int tmp_if_expr_620;
  signed int tmp_if_expr_621;
  struct _value *tmp_if_expr_627;
  signed int tmp_if_expr_622;
  signed int tmp_if_expr_623;
  struct _value *return_value_neko_alloc_int32_624;
  signed int tmp_if_expr_625;
  signed int tmp_if_expr_626;
  struct _value *return_value_neko_alloc_string_628;
  signed long int *tmp_post_635;
  _Bool tmp_if_expr_652;
  struct _value *tmp_if_expr_637;
  struct _value *return_value_neko_alloc_int32_636;
  _Bool tmp_if_expr_649;
  _Bool tmp_if_expr_651;
  _Bool tmp_if_expr_650;
  signed int tmp_if_expr_638;
  signed int tmp_if_expr_639;
  struct _value *tmp_if_expr_645;
  signed int tmp_if_expr_640;
  signed int tmp_if_expr_641;
  struct _value *return_value_neko_alloc_int32_642;
  signed int tmp_if_expr_643;
  signed int tmp_if_expr_644;
  struct _value *return_value_neko_alloc_string_646;
  signed long int *tmp_post_653;
  _Bool tmp_if_expr_670;
  struct _value *tmp_if_expr_655;
  struct _value *return_value_neko_alloc_int32_654;
  _Bool tmp_if_expr_667;
  _Bool tmp_if_expr_669;
  _Bool tmp_if_expr_668;
  signed int tmp_if_expr_656;
  signed int tmp_if_expr_657;
  struct _value *tmp_if_expr_663;
  signed int tmp_if_expr_658;
  signed int tmp_if_expr_659;
  struct _value *return_value_neko_alloc_int32_660;
  signed int tmp_if_expr_661;
  signed int tmp_if_expr_662;
  struct _value *return_value_neko_alloc_string_664;
  signed long int *tmp_post_671;
  _Bool tmp_if_expr_688;
  struct _value *tmp_if_expr_673;
  struct _value *return_value_neko_alloc_int32_672;
  _Bool tmp_if_expr_685;
  _Bool tmp_if_expr_687;
  _Bool tmp_if_expr_686;
  signed int tmp_if_expr_674;
  signed int tmp_if_expr_675;
  struct _value *tmp_if_expr_681;
  signed int tmp_if_expr_676;
  signed int tmp_if_expr_677;
  struct _value *return_value_neko_alloc_int32_678;
  signed int tmp_if_expr_679;
  signed int tmp_if_expr_680;
  struct _value *return_value_neko_alloc_string_682;
  signed long int *tmp_post_689;
  signed int return_value_neko_val_compare_690;
  signed long int *tmp_post_691;
  signed int return_value_neko_val_compare_692;
  signed long int *tmp_post_693;
  signed int return_value_neko_val_compare_694;
  signed long int *tmp_post_695;
  signed int return_value_neko_val_compare_696;
  signed long int *tmp_post_697;
  signed int return_value_neko_val_compare_698;
  signed long int *tmp_post_699;
  signed int return_value_neko_val_compare_700;
  signed long int *tmp_post_701;
  struct _value *tmp_if_expr_702;
  signed int return_value_neko_val_compare_703;
  signed long int *tmp_post_704;
  struct _value *tmp_if_expr_705;
  signed long int *tmp_post_706;
  _Bool tmp_if_expr_711;
  struct _value *return_value_neko_alloc_string_708;
  struct _value *return_value_neko_alloc_object_712;
  _Bool tmp_if_expr_713;
  static void *instructions[68l] = { &&LabelAccNull, &&LabelAccTrue, &&LabelAccFalse, &&LabelAccThis, &&LabelAccInt, &&LabelAccStack, &&LabelAccGlobal, &&LabelAccEnv, &&LabelAccField, &&LabelAccArray, &&LabelAccIndex, &&LabelAccBuiltin, &&LabelSetStack, &&LabelSetGlobal, &&LabelSetEnv, &&LabelSetField, &&LabelSetArray, &&LabelSetIndex, &&LabelSetThis, &&LabelPush, &&LabelPop, &&LabelCall, &&LabelObjCall, &&LabelJump, &&LabelJumpIf, &&LabelJumpIfNot, &&LabelTrap, &&LabelEndTrap, &&LabelRet, &&LabelMakeEnv, &&LabelMakeArray, &&LabelBool, &&LabelIsNull, &&LabelIsNotNull, &&LabelAdd, &&LabelSub, &&LabelMult, &&LabelDiv, &&LabelMod, &&LabelShl, &&LabelShr, &&LabelUShr, &&LabelOr, &&LabelAnd, &&LabelXor, &&LabelEq, &&LabelNeq, &&LabelGt, &&LabelGte, &&LabelLt, &&LabelLte, &&LabelNot, &&LabelTypeOf, &&LabelCompare, &&LabelHash, &&LabelNew, &&LabelJumpTable, &&LabelApply, &&LabelAccStack0, &&LabelAccStack1, &&LabelAccIndex0, &&LabelAccIndex1, &&LabelPhysCompare, &&LabelTailCall, &&LabelLoop, &&LabelMakeArray2, &&LabelAccInt32, &&LabelLast };
  if(m == ((struct _neko_module *)NULL))
    return (signed long int)instructions;

  else
  {
    signed long int *sp = vm->sp;
    signed long int *csp = vm->csp;
    *pc++;
    if(!(*pc++ == &&id_mod_next2))
    {
      if(!(*pc++ == &&id_mod_next))
      {
        if(!(*pc++ == &&div_next))
        {
          if(!(*pc++ == &&id_mult_next2))
          {
            if(!(*pc++ == &&id_mult_next))
            {
              if(!(*pc++ == &&id_sub_next2))
              {
                if(!(*pc++ == &&id_sub_next))
                {
                  if(!(*pc++ == &&add_3))
                  {
                    if(!(*pc++ == &&add_2))
                    {
                      if(!(*pc++ == &&add_next))
                      {
                        if(!(*pc++ == &&do_call))
                        {
                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(!(*pc++ == &&LabelAccInt32))
                          {
                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(!(*pc++ == &&LabelAccInt))
                            {
                              if(!(*pc++ == &&LabelAccThis))
                              {
                                if(!(*pc++ == &&LabelAccFalse))
                                {
                                  if(!(*pc++ == &&LabelAccTrue))
                                  {
                                    if(!(*pc++ == &&LabelAccNull))
                                    {
                                      if(*pc++ == &&end)
                                        goto end;

                                    }

                                    do
                                    {

                                    LabelAccNull:
                                      ;
                                      acc = (signed long int)val_null;
                                      *pc++;
                                      if(*pc++ == &&id_mod_next2)
                                        goto id_mod_next2;

                                      if(*pc++ == &&id_mod_next)
                                        goto id_mod_next;

                                      if(*pc++ == &&div_next)
                                        goto div_next;

                                      if(*pc++ == &&id_mult_next2)
                                        goto id_mult_next2;

                                      if(*pc++ == &&id_mult_next)
                                        goto id_mult_next;

                                      if(*pc++ == &&id_sub_next2)
                                        goto id_sub_next2;

                                      if(*pc++ == &&id_sub_next)
                                        goto id_sub_next;

                                      if(*pc++ == &&add_3)
                                        goto add_3;

                                      if(*pc++ == &&add_2)
                                        goto add_2;

                                      if(*pc++ == &&add_next)
                                        goto add_next;

                                      if(*pc++ == &&do_call)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelLast)
                                        goto LabelLast;

                                      if(*pc++ == &&LabelAccInt32)
                                        goto LabelAccInt32;

                                      if(*pc++ == &&LabelMakeArray2)
                                        goto LabelMakeArray2;

                                      if(*pc++ == &&LabelLoop)
                                        goto LabelLoop;

                                      if(*pc++ == &&LabelTailCall)
                                        goto LabelTailCall;

                                      if(*pc++ == &&LabelPhysCompare)
                                        goto LabelPhysCompare;

                                      if(*pc++ == &&LabelAccIndex1)
                                        goto LabelAccIndex1;

                                      if(*pc++ == &&LabelAccIndex0)
                                        goto LabelAccIndex0;

                                      if(*pc++ == &&LabelAccStack1)
                                        goto LabelAccStack1;

                                      if(*pc++ == &&LabelAccStack0)
                                        goto LabelAccStack0;

                                      if(*pc++ == &&LabelApply)
                                        goto LabelApply;

                                      if(*pc++ == &&LabelJumpTable)
                                        goto LabelJumpTable;

                                      if(*pc++ == &&LabelNew)
                                        goto LabelNew;

                                      if(*pc++ == &&LabelHash)
                                        goto LabelHash;

                                      if(*pc++ == &&LabelCompare)
                                        goto LabelCompare;

                                      if(*pc++ == &&LabelTypeOf)
                                        goto LabelTypeOf;

                                      if(*pc++ == &&LabelNot)
                                        goto LabelNot;

                                      if(*pc++ == &&LabelLte)
                                        goto LabelLte;

                                      if(*pc++ == &&LabelLt)
                                        goto LabelLt;

                                      if(*pc++ == &&LabelGte)
                                        goto LabelGte;

                                      if(*pc++ == &&LabelGt)
                                        goto LabelGt;

                                      if(*pc++ == &&LabelNeq)
                                        goto LabelNeq;

                                      if(*pc++ == &&LabelEq)
                                        goto LabelEq;

                                      if(*pc++ == &&LabelXor)
                                        goto LabelXor;

                                      if(*pc++ == &&LabelAnd)
                                        goto LabelAnd;

                                      if(*pc++ == &&LabelOr)
                                        goto LabelOr;

                                      if(*pc++ == &&LabelUShr)
                                        goto LabelUShr;

                                      if(*pc++ == &&LabelShr)
                                        goto LabelShr;

                                      if(*pc++ == &&LabelShl)
                                        goto LabelShl;

                                      if(*pc++ == &&LabelMod)
                                        goto LabelMod;

                                      if(*pc++ == &&LabelDiv)
                                        goto LabelDiv;

                                      if(*pc++ == &&LabelMult)
                                        goto LabelMult;

                                      if(*pc++ == &&LabelSub)
                                        goto LabelSub;

                                      if(*pc++ == &&LabelAdd)
                                        goto LabelAdd;

                                      if(*pc++ == &&LabelIsNotNull)
                                        goto LabelIsNotNull;

                                      if(*pc++ == &&LabelIsNull)
                                        goto LabelIsNull;

                                      if(*pc++ == &&LabelBool)
                                        goto LabelBool;

                                      if(*pc++ == &&LabelMakeArray)
                                        goto LabelMakeArray;

                                      if(*pc++ == &&LabelMakeEnv)
                                        goto LabelMakeEnv;

                                      if(*pc++ == &&LabelRet)
                                        goto LabelRet;

                                      if(*pc++ == &&LabelEndTrap)
                                        goto LabelEndTrap;

                                      if(*pc++ == &&LabelTrap)
                                        goto LabelTrap;

                                      if(*pc++ == &&LabelJumpIfNot)
                                        goto LabelJumpIfNot;

                                      if(*pc++ == &&LabelJumpIf)
                                        goto LabelJumpIf;

                                      if(*pc++ == &&LabelJump)
                                        goto LabelJump;

                                      if(*pc++ == &&LabelObjCall)
                                        goto LabelObjCall;

                                      if(*pc++ == &&LabelCall)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelPop)
                                        goto LabelPop;

                                      if(*pc++ == &&LabelPush)
                                        goto LabelPush;

                                      if(*pc++ == &&LabelSetThis)
                                        goto LabelSetThis;

                                      if(*pc++ == &&LabelSetIndex)
                                        goto LabelSetIndex;

                                      if(*pc++ == &&LabelSetArray)
                                        goto LabelSetArray;

                                      if(*pc++ == &&LabelSetField)
                                        goto LabelSetField;

                                      if(*pc++ == &&LabelSetEnv)
                                        goto LabelSetEnv;

                                      if(*pc++ == &&LabelSetGlobal)
                                        goto LabelSetGlobal;

                                      if(*pc++ == &&LabelSetStack)
                                        goto LabelSetStack;

                                      if(*pc++ == &&LabelAccBuiltin)
                                        goto LabelAccBuiltin;

                                      if(*pc++ == &&LabelAccIndex)
                                        goto LabelAccIndex;

                                      if(*pc++ == &&LabelAccArray)
                                        goto LabelAccArray;

                                      if(*pc++ == &&LabelAccField)
                                        goto LabelAccField;

                                      if(*pc++ == &&LabelAccEnv)
                                        goto LabelAccEnv;

                                      if(*pc++ == &&LabelAccGlobal)
                                        goto LabelAccGlobal;

                                      if(*pc++ == &&LabelAccStack)
                                        goto LabelAccStack;

                                      if(*pc++ == &&LabelAccInt)
                                        goto LabelAccInt;

                                      if(*pc++ == &&LabelAccThis)
                                        goto LabelAccThis;

                                      if(*pc++ == &&LabelAccFalse)
                                        goto LabelAccFalse;

                                      if(*pc++ == &&LabelAccTrue)
                                        goto LabelAccTrue;

                                    }
                                    while(*pc++ == &&LabelAccNull);
                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelAccTrue:
                                    ;
                                    acc = (signed long int)val_true;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                    if(*pc++ == &&LabelAccStack0)
                                      goto LabelAccStack0;

                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                    if(*pc++ == &&LabelSetThis)
                                      goto LabelSetThis;

                                    if(*pc++ == &&LabelSetIndex)
                                      goto LabelSetIndex;

                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                    if(*pc++ == &&LabelAccField)
                                      goto LabelAccField;

                                    if(*pc++ == &&LabelAccEnv)
                                      goto LabelAccEnv;

                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                  }
                                  while(*pc++ == &&LabelAccTrue);
                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelAccFalse:
                                  ;
                                  acc = (signed long int)val_false;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                }
                                while(*pc++ == &&LabelAccFalse);
                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelAccThis:
                                ;
                                acc = (signed long int)vm->vthis;
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                                if(*pc++ == &&LabelAccIndex0)
                                  goto LabelAccIndex0;

                                if(*pc++ == &&LabelAccStack1)
                                  goto LabelAccStack1;

                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                                if(*pc++ == &&LabelShr)
                                  goto LabelShr;

                                if(*pc++ == &&LabelShl)
                                  goto LabelShl;

                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                                if(*pc++ == &&LabelPop)
                                  goto LabelPop;

                                if(*pc++ == &&LabelPush)
                                  goto LabelPush;

                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(*pc++ == &&LabelAccArray)
                                  goto LabelAccArray;

                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                              }
                              while(*pc++ == &&LabelAccThis);
                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelAccInt:
                              ;
                              tmp_post_1 = pc;
                              pc = pc + 1l;
                              acc = *tmp_post_1;
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                            }
                            while(*pc++ == &&LabelAccInt);
                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelAccInt32:
                            ;
                            tmp_post_2 = pc;
                            pc = pc + 1l;
                            return_value_neko_alloc_int32_3=neko_alloc_int32((signed int)*tmp_post_2);
                            acc = (signed long int)return_value_neko_alloc_int32_3;
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                          }
                          while(*pc++ == &&LabelAccInt32);
                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(!(*pc++ == &&LabelTailCall))
                          {
                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(!(*pc++ == &&LabelAccIndex1))
                            {
                              if(!(*pc++ == &&LabelAccIndex0))
                              {
                                if(!(*pc++ == &&LabelAccStack1))
                                {
                                  if(!(*pc++ == &&LabelAccStack0))
                                  {
                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                    if(*pc++ == &&LabelSetThis)
                                      goto LabelSetThis;

                                    if(*pc++ == &&LabelSetIndex)
                                      goto LabelSetIndex;

                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                    if(*pc++ == &&LabelAccField)
                                      goto LabelAccField;

                                    if(*pc++ == &&LabelAccEnv)
                                      goto LabelAccEnv;

                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                    if(*pc++ == &&LabelAccTrue)
                                      goto LabelAccTrue;

                                    if(*pc++ == &&LabelAccNull)
                                      goto LabelAccNull;

                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelAccStack0:
                                    ;
                                    acc = *sp;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                  }
                                  while(*pc++ == &&LabelAccStack0);
                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelAccStack1:
                                  ;
                                  acc = sp[(signed long int)1];
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                }
                                while(*pc++ == &&LabelAccStack1);
                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                                if(*pc++ == &&LabelShr)
                                  goto LabelShr;

                                if(*pc++ == &&LabelShl)
                                  goto LabelShl;

                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                                if(*pc++ == &&LabelPop)
                                  goto LabelPop;

                                if(*pc++ == &&LabelPush)
                                  goto LabelPush;

                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(!(*pc++ == &&LabelAccArray))
                                {
                                  if(!(*pc++ == &&LabelAccField))
                                  {
                                    if(!(*pc++ == &&LabelAccEnv))
                                    {
                                      if(!(*pc++ == &&LabelAccGlobal))
                                      {
                                        if(!(*pc++ == &&LabelAccStack))
                                        {
                                          if(*pc++ == &&LabelAccInt)
                                            goto LabelAccInt;

                                          if(*pc++ == &&LabelAccThis)
                                            goto LabelAccThis;

                                          if(*pc++ == &&LabelAccFalse)
                                            goto LabelAccFalse;

                                          if(*pc++ == &&LabelAccTrue)
                                            goto LabelAccTrue;

                                          if(*pc++ == &&LabelAccNull)
                                            goto LabelAccNull;

                                          if(*pc++ == &&end)
                                            goto end;

                                        }

                                        do
                                        {

                                        LabelAccStack:
                                          ;
                                          tmp_post_4 = pc;
                                          pc = pc + 1l;
                                          acc = sp[*tmp_post_4];
                                          *pc++;
                                          if(*pc++ == &&id_mod_next2)
                                            goto id_mod_next2;

                                          if(*pc++ == &&id_mod_next)
                                            goto id_mod_next;

                                          if(*pc++ == &&div_next)
                                            goto div_next;

                                          if(*pc++ == &&id_mult_next2)
                                            goto id_mult_next2;

                                          if(*pc++ == &&id_mult_next)
                                            goto id_mult_next;

                                          if(*pc++ == &&id_sub_next2)
                                            goto id_sub_next2;

                                          if(*pc++ == &&id_sub_next)
                                            goto id_sub_next;

                                          if(*pc++ == &&add_3)
                                            goto add_3;

                                          if(*pc++ == &&add_2)
                                            goto add_2;

                                          if(*pc++ == &&add_next)
                                            goto add_next;

                                          if(*pc++ == &&do_call)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelLast)
                                            goto LabelLast;

                                          if(*pc++ == &&LabelAccInt32)
                                            goto LabelAccInt32;

                                          if(*pc++ == &&LabelMakeArray2)
                                            goto LabelMakeArray2;

                                          if(*pc++ == &&LabelLoop)
                                            goto LabelLoop;

                                          if(*pc++ == &&LabelTailCall)
                                            goto LabelTailCall;

                                          if(*pc++ == &&LabelPhysCompare)
                                            goto LabelPhysCompare;

                                          if(*pc++ == &&LabelAccIndex1)
                                            goto LabelAccIndex1;

                                          if(*pc++ == &&LabelAccIndex0)
                                            goto LabelAccIndex0;

                                          if(*pc++ == &&LabelAccStack1)
                                            goto LabelAccStack1;

                                          if(*pc++ == &&LabelAccStack0)
                                            goto LabelAccStack0;

                                          if(*pc++ == &&LabelApply)
                                            goto LabelApply;

                                          if(*pc++ == &&LabelJumpTable)
                                            goto LabelJumpTable;

                                          if(*pc++ == &&LabelNew)
                                            goto LabelNew;

                                          if(*pc++ == &&LabelHash)
                                            goto LabelHash;

                                          if(*pc++ == &&LabelCompare)
                                            goto LabelCompare;

                                          if(*pc++ == &&LabelTypeOf)
                                            goto LabelTypeOf;

                                          if(*pc++ == &&LabelNot)
                                            goto LabelNot;

                                          if(*pc++ == &&LabelLte)
                                            goto LabelLte;

                                          if(*pc++ == &&LabelLt)
                                            goto LabelLt;

                                          if(*pc++ == &&LabelGte)
                                            goto LabelGte;

                                          if(*pc++ == &&LabelGt)
                                            goto LabelGt;

                                          if(*pc++ == &&LabelNeq)
                                            goto LabelNeq;

                                          if(*pc++ == &&LabelEq)
                                            goto LabelEq;

                                          if(*pc++ == &&LabelXor)
                                            goto LabelXor;

                                          if(*pc++ == &&LabelAnd)
                                            goto LabelAnd;

                                          if(*pc++ == &&LabelOr)
                                            goto LabelOr;

                                          if(*pc++ == &&LabelUShr)
                                            goto LabelUShr;

                                          if(*pc++ == &&LabelShr)
                                            goto LabelShr;

                                          if(*pc++ == &&LabelShl)
                                            goto LabelShl;

                                          if(*pc++ == &&LabelMod)
                                            goto LabelMod;

                                          if(*pc++ == &&LabelDiv)
                                            goto LabelDiv;

                                          if(*pc++ == &&LabelMult)
                                            goto LabelMult;

                                          if(*pc++ == &&LabelSub)
                                            goto LabelSub;

                                          if(*pc++ == &&LabelAdd)
                                            goto LabelAdd;

                                          if(*pc++ == &&LabelIsNotNull)
                                            goto LabelIsNotNull;

                                          if(*pc++ == &&LabelIsNull)
                                            goto LabelIsNull;

                                          if(*pc++ == &&LabelBool)
                                            goto LabelBool;

                                          if(*pc++ == &&LabelMakeArray)
                                            goto LabelMakeArray;

                                          if(*pc++ == &&LabelMakeEnv)
                                            goto LabelMakeEnv;

                                          if(*pc++ == &&LabelRet)
                                            goto LabelRet;

                                          if(*pc++ == &&LabelEndTrap)
                                            goto LabelEndTrap;

                                          if(*pc++ == &&LabelTrap)
                                            goto LabelTrap;

                                          if(*pc++ == &&LabelJumpIfNot)
                                            goto LabelJumpIfNot;

                                          if(*pc++ == &&LabelJumpIf)
                                            goto LabelJumpIf;

                                          if(*pc++ == &&LabelJump)
                                            goto LabelJump;

                                          if(*pc++ == &&LabelObjCall)
                                            goto LabelObjCall;

                                          if(*pc++ == &&LabelCall)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelPop)
                                            goto LabelPop;

                                          if(*pc++ == &&LabelPush)
                                            goto LabelPush;

                                          if(*pc++ == &&LabelSetThis)
                                            goto LabelSetThis;

                                          if(*pc++ == &&LabelSetIndex)
                                            goto LabelSetIndex;

                                          if(*pc++ == &&LabelSetArray)
                                            goto LabelSetArray;

                                          if(*pc++ == &&LabelSetField)
                                            goto LabelSetField;

                                          if(*pc++ == &&LabelSetEnv)
                                            goto LabelSetEnv;

                                          if(*pc++ == &&LabelSetGlobal)
                                            goto LabelSetGlobal;

                                          if(*pc++ == &&LabelSetStack)
                                            goto LabelSetStack;

                                          if(*pc++ == &&LabelAccBuiltin)
                                            goto LabelAccBuiltin;

                                          if(*pc++ == &&LabelAccIndex)
                                            goto LabelAccIndex;

                                          if(*pc++ == &&LabelAccArray)
                                            goto LabelAccArray;

                                          if(*pc++ == &&LabelAccField)
                                            goto LabelAccField;

                                          if(*pc++ == &&LabelAccEnv)
                                            goto LabelAccEnv;

                                          if(*pc++ == &&LabelAccGlobal)
                                            goto LabelAccGlobal;

                                        }
                                        while(*pc++ == &&LabelAccStack);
                                        if(*pc++ == &&LabelAccInt)
                                          goto LabelAccInt;

                                        if(*pc++ == &&LabelAccThis)
                                          goto LabelAccThis;

                                        if(*pc++ == &&LabelAccFalse)
                                          goto LabelAccFalse;

                                        if(*pc++ == &&LabelAccTrue)
                                          goto LabelAccTrue;

                                        if(*pc++ == &&LabelAccNull)
                                          goto LabelAccNull;

                                        if(*pc++ == &&end)
                                          goto end;

                                      }

                                      do
                                      {

                                      LabelAccGlobal:
                                        ;
                                        tmp_post_5 = pc;
                                        pc = pc + 1l;
                                        acc = *((signed long int *)*tmp_post_5);
                                        *pc++;
                                        if(*pc++ == &&id_mod_next2)
                                          goto id_mod_next2;

                                        if(*pc++ == &&id_mod_next)
                                          goto id_mod_next;

                                        if(*pc++ == &&div_next)
                                          goto div_next;

                                        if(*pc++ == &&id_mult_next2)
                                          goto id_mult_next2;

                                        if(*pc++ == &&id_mult_next)
                                          goto id_mult_next;

                                        if(*pc++ == &&id_sub_next2)
                                          goto id_sub_next2;

                                        if(*pc++ == &&id_sub_next)
                                          goto id_sub_next;

                                        if(*pc++ == &&add_3)
                                          goto add_3;

                                        if(*pc++ == &&add_2)
                                          goto add_2;

                                        if(*pc++ == &&add_next)
                                          goto add_next;

                                        if(*pc++ == &&do_call)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelLast)
                                          goto LabelLast;

                                        if(*pc++ == &&LabelAccInt32)
                                          goto LabelAccInt32;

                                        if(*pc++ == &&LabelMakeArray2)
                                          goto LabelMakeArray2;

                                        if(*pc++ == &&LabelLoop)
                                          goto LabelLoop;

                                        if(*pc++ == &&LabelTailCall)
                                          goto LabelTailCall;

                                        if(*pc++ == &&LabelPhysCompare)
                                          goto LabelPhysCompare;

                                        if(*pc++ == &&LabelAccIndex1)
                                          goto LabelAccIndex1;

                                        if(*pc++ == &&LabelAccIndex0)
                                          goto LabelAccIndex0;

                                        if(*pc++ == &&LabelAccStack1)
                                          goto LabelAccStack1;

                                        if(*pc++ == &&LabelAccStack0)
                                          goto LabelAccStack0;

                                        if(*pc++ == &&LabelApply)
                                          goto LabelApply;

                                        if(*pc++ == &&LabelJumpTable)
                                          goto LabelJumpTable;

                                        if(*pc++ == &&LabelNew)
                                          goto LabelNew;

                                        if(*pc++ == &&LabelHash)
                                          goto LabelHash;

                                        if(*pc++ == &&LabelCompare)
                                          goto LabelCompare;

                                        if(*pc++ == &&LabelTypeOf)
                                          goto LabelTypeOf;

                                        if(*pc++ == &&LabelNot)
                                          goto LabelNot;

                                        if(*pc++ == &&LabelLte)
                                          goto LabelLte;

                                        if(*pc++ == &&LabelLt)
                                          goto LabelLt;

                                        if(*pc++ == &&LabelGte)
                                          goto LabelGte;

                                        if(*pc++ == &&LabelGt)
                                          goto LabelGt;

                                        if(*pc++ == &&LabelNeq)
                                          goto LabelNeq;

                                        if(*pc++ == &&LabelEq)
                                          goto LabelEq;

                                        if(*pc++ == &&LabelXor)
                                          goto LabelXor;

                                        if(*pc++ == &&LabelAnd)
                                          goto LabelAnd;

                                        if(*pc++ == &&LabelOr)
                                          goto LabelOr;

                                        if(*pc++ == &&LabelUShr)
                                          goto LabelUShr;

                                        if(*pc++ == &&LabelShr)
                                          goto LabelShr;

                                        if(*pc++ == &&LabelShl)
                                          goto LabelShl;

                                        if(*pc++ == &&LabelMod)
                                          goto LabelMod;

                                        if(*pc++ == &&LabelDiv)
                                          goto LabelDiv;

                                        if(*pc++ == &&LabelMult)
                                          goto LabelMult;

                                        if(*pc++ == &&LabelSub)
                                          goto LabelSub;

                                        if(*pc++ == &&LabelAdd)
                                          goto LabelAdd;

                                        if(*pc++ == &&LabelIsNotNull)
                                          goto LabelIsNotNull;

                                        if(*pc++ == &&LabelIsNull)
                                          goto LabelIsNull;

                                        if(*pc++ == &&LabelBool)
                                          goto LabelBool;

                                        if(*pc++ == &&LabelMakeArray)
                                          goto LabelMakeArray;

                                        if(*pc++ == &&LabelMakeEnv)
                                          goto LabelMakeEnv;

                                        if(*pc++ == &&LabelRet)
                                          goto LabelRet;

                                        if(*pc++ == &&LabelEndTrap)
                                          goto LabelEndTrap;

                                        if(*pc++ == &&LabelTrap)
                                          goto LabelTrap;

                                        if(*pc++ == &&LabelJumpIfNot)
                                          goto LabelJumpIfNot;

                                        if(*pc++ == &&LabelJumpIf)
                                          goto LabelJumpIf;

                                        if(*pc++ == &&LabelJump)
                                          goto LabelJump;

                                        if(*pc++ == &&LabelObjCall)
                                          goto LabelObjCall;

                                        if(*pc++ == &&LabelCall)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelPop)
                                          goto LabelPop;

                                        if(*pc++ == &&LabelPush)
                                          goto LabelPush;

                                        if(*pc++ == &&LabelSetThis)
                                          goto LabelSetThis;

                                        if(*pc++ == &&LabelSetIndex)
                                          goto LabelSetIndex;

                                        if(*pc++ == &&LabelSetArray)
                                          goto LabelSetArray;

                                        if(*pc++ == &&LabelSetField)
                                          goto LabelSetField;

                                        if(*pc++ == &&LabelSetEnv)
                                          goto LabelSetEnv;

                                        if(*pc++ == &&LabelSetGlobal)
                                          goto LabelSetGlobal;

                                        if(*pc++ == &&LabelSetStack)
                                          goto LabelSetStack;

                                        if(*pc++ == &&LabelAccBuiltin)
                                          goto LabelAccBuiltin;

                                        if(*pc++ == &&LabelAccIndex)
                                          goto LabelAccIndex;

                                        if(*pc++ == &&LabelAccArray)
                                          goto LabelAccArray;

                                        if(*pc++ == &&LabelAccField)
                                          goto LabelAccField;

                                        if(*pc++ == &&LabelAccEnv)
                                          goto LabelAccEnv;

                                      }
                                      while(*pc++ == &&LabelAccGlobal);
                                      if(*pc++ == &&LabelAccStack)
                                        goto LabelAccStack;

                                      if(*pc++ == &&LabelAccInt)
                                        goto LabelAccInt;

                                      if(*pc++ == &&LabelAccThis)
                                        goto LabelAccThis;

                                      if(*pc++ == &&LabelAccFalse)
                                        goto LabelAccFalse;

                                      if(*pc++ == &&LabelAccTrue)
                                        goto LabelAccTrue;

                                      if(*pc++ == &&LabelAccNull)
                                        goto LabelAccNull;

                                      if(*pc++ == &&end)
                                        goto end;

                                    }


                                  LabelAccEnv:
                                    ;
                                    while((_Bool)1)
                                    {
                                      if(*pc >= (signed long int)((signed int)*((enum anonymous_7 *)vm->env) >> 4))
                                      {
                                        pc = pc + 1l;
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand_7;
                                          return_value_neko_stack_expand_7=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand_7 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string_6=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string_6);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string_8;
                                        return_value_neko_alloc_string_8=neko_alloc_string("Reading Outside Env");
                                        neko_val_throw(return_value_neko_alloc_string_8);
                                      }

                                      tmp_post_9 = pc;
                                      pc = pc + 1l;
                                      acc = (signed long int)(&((struct anonymous_4 *)vm->env)->ptr)[*tmp_post_9];
                                      *pc++;
                                      if(*pc++ == &&id_mod_next2)
                                        goto id_mod_next2;

                                      if(*pc++ == &&id_mod_next)
                                        goto id_mod_next;

                                      if(*pc++ == &&div_next)
                                        goto div_next;

                                      if(*pc++ == &&id_mult_next2)
                                        goto id_mult_next2;

                                      if(*pc++ == &&id_mult_next)
                                        goto id_mult_next;

                                      if(*pc++ == &&id_sub_next2)
                                        goto id_sub_next2;

                                      if(*pc++ == &&id_sub_next)
                                        goto id_sub_next;

                                      if(*pc++ == &&add_3)
                                        goto add_3;

                                      if(*pc++ == &&add_2)
                                        goto add_2;

                                      if(*pc++ == &&add_next)
                                        goto add_next;

                                      if(*pc++ == &&do_call)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelLast)
                                        goto LabelLast;

                                      if(*pc++ == &&LabelAccInt32)
                                        goto LabelAccInt32;

                                      if(*pc++ == &&LabelMakeArray2)
                                        goto LabelMakeArray2;

                                      if(*pc++ == &&LabelLoop)
                                        goto LabelLoop;

                                      if(*pc++ == &&LabelTailCall)
                                        goto LabelTailCall;

                                      if(*pc++ == &&LabelPhysCompare)
                                        goto LabelPhysCompare;

                                      if(*pc++ == &&LabelAccIndex1)
                                        goto LabelAccIndex1;

                                      if(*pc++ == &&LabelAccIndex0)
                                        goto LabelAccIndex0;

                                      if(*pc++ == &&LabelAccStack1)
                                        goto LabelAccStack1;

                                      if(*pc++ == &&LabelAccStack0)
                                        goto LabelAccStack0;

                                      if(*pc++ == &&LabelApply)
                                        goto LabelApply;

                                      if(*pc++ == &&LabelJumpTable)
                                        goto LabelJumpTable;

                                      if(*pc++ == &&LabelNew)
                                        goto LabelNew;

                                      if(*pc++ == &&LabelHash)
                                        goto LabelHash;

                                      if(*pc++ == &&LabelCompare)
                                        goto LabelCompare;

                                      if(*pc++ == &&LabelTypeOf)
                                        goto LabelTypeOf;

                                      if(*pc++ == &&LabelNot)
                                        goto LabelNot;

                                      if(*pc++ == &&LabelLte)
                                        goto LabelLte;

                                      if(*pc++ == &&LabelLt)
                                        goto LabelLt;

                                      if(*pc++ == &&LabelGte)
                                        goto LabelGte;

                                      if(*pc++ == &&LabelGt)
                                        goto LabelGt;

                                      if(*pc++ == &&LabelNeq)
                                        goto LabelNeq;

                                      if(*pc++ == &&LabelEq)
                                        goto LabelEq;

                                      if(*pc++ == &&LabelXor)
                                        goto LabelXor;

                                      if(*pc++ == &&LabelAnd)
                                        goto LabelAnd;

                                      if(*pc++ == &&LabelOr)
                                        goto LabelOr;

                                      if(*pc++ == &&LabelUShr)
                                        goto LabelUShr;

                                      if(*pc++ == &&LabelShr)
                                        goto LabelShr;

                                      if(*pc++ == &&LabelShl)
                                        goto LabelShl;

                                      if(*pc++ == &&LabelMod)
                                        goto LabelMod;

                                      if(*pc++ == &&LabelDiv)
                                        goto LabelDiv;

                                      if(*pc++ == &&LabelMult)
                                        goto LabelMult;

                                      if(*pc++ == &&LabelSub)
                                        goto LabelSub;

                                      if(*pc++ == &&LabelAdd)
                                        goto LabelAdd;

                                      if(*pc++ == &&LabelIsNotNull)
                                        goto LabelIsNotNull;

                                      if(*pc++ == &&LabelIsNull)
                                        goto LabelIsNull;

                                      if(*pc++ == &&LabelBool)
                                        goto LabelBool;

                                      if(*pc++ == &&LabelMakeArray)
                                        goto LabelMakeArray;

                                      if(*pc++ == &&LabelMakeEnv)
                                        goto LabelMakeEnv;

                                      if(*pc++ == &&LabelRet)
                                        goto LabelRet;

                                      if(*pc++ == &&LabelEndTrap)
                                        goto LabelEndTrap;

                                      if(*pc++ == &&LabelTrap)
                                        goto LabelTrap;

                                      if(*pc++ == &&LabelJumpIfNot)
                                        goto LabelJumpIfNot;

                                      if(*pc++ == &&LabelJumpIf)
                                        goto LabelJumpIf;

                                      if(*pc++ == &&LabelJump)
                                        goto LabelJump;

                                      if(*pc++ == &&LabelObjCall)
                                        goto LabelObjCall;

                                      if(*pc++ == &&LabelCall)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelPop)
                                        goto LabelPop;

                                      if(*pc++ == &&LabelPush)
                                        goto LabelPush;

                                      if(*pc++ == &&LabelSetThis)
                                        goto LabelSetThis;

                                      if(*pc++ == &&LabelSetIndex)
                                        goto LabelSetIndex;

                                      if(*pc++ == &&LabelSetArray)
                                        goto LabelSetArray;

                                      if(*pc++ == &&LabelSetField)
                                        goto LabelSetField;

                                      if(*pc++ == &&LabelSetEnv)
                                        goto LabelSetEnv;

                                      if(*pc++ == &&LabelSetGlobal)
                                        goto LabelSetGlobal;

                                      if(*pc++ == &&LabelSetStack)
                                        goto LabelSetStack;

                                      if(*pc++ == &&LabelAccBuiltin)
                                        goto LabelAccBuiltin;

                                      if(*pc++ == &&LabelAccIndex)
                                        goto LabelAccIndex;

                                      if(*pc++ == &&LabelAccArray)
                                        goto LabelAccArray;

                                      if(*pc++ == &&LabelAccField)
                                        goto LabelAccField;

                                      if(!(*pc++ == &&LabelAccEnv))
                                        break;

                                    }
                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                    if(*pc++ == &&LabelAccTrue)
                                      goto LabelAccTrue;

                                    if(*pc++ == &&LabelAccNull)
                                      goto LabelAccNull;

                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelAccField:
                                    ;
                                    if((1 & (signed int)acc) == 0)
                                      tmp_if_expr_17 = (signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr_17 = (_Bool)0;
                                    if(tmp_if_expr_17)
                                    {
                                      struct _value **f;
                                      struct _value *old = (struct _value *)acc;
                                      struct _value *tacc = (struct _value *)acc;
                                      do
                                      {
                                        f=otable_find_link1(&((struct _vobject *)acc)->table, (signed int)*pc);
                                        if(!(f == ((struct _value **)NULL)))
                                          break;

                                        acc = (signed long int)((struct _vobject *)tacc)->proto;
                                        tacc = (struct _value *)acc;
                                      }
                                      while(!(acc == 0l));
                                      if(!(f == ((struct _value **)NULL)))
                                        acc = (signed long int)*f;

                                      else
                                        if(!(vm->resolver == ((struct _value *)NULL)))
                                        {
                                          vm->sp = sp;
                                          vm->csp = csp;
                                          struct _value *return_value_neko_val_call2_10;
                                          return_value_neko_val_call2_10=neko_val_call2(vm->resolver, old, (struct _value *)(signed long int)((signed int)*pc << 1 | 1));
                                          acc = (signed long int)return_value_neko_val_call2_10;
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                          acc = (signed long int)val_null;
                                    }

                                    else
                                    {
                                      struct _value *v;
                                      v=neko_val_field_name((signed int)*pc);
                                      struct _buffer *b;
                                      if(v == val_null)
                                      {
                                        pc = pc + 1l;
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand_12;
                                          return_value_neko_stack_expand_12=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand_12 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string_11=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string_11);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string_13;
                                        return_value_neko_alloc_string_13=neko_alloc_string("Invalid field access");
                                        neko_val_throw(return_value_neko_alloc_string_13);
                                      }

                                      b=neko_alloc_buffer("Invalid field access : ");
                                      neko_val_buffer(b, v);
                                      pc = pc + 1l;
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_15;
                                        return_value_neko_stack_expand_15=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_15 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_14=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_14);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_buffer_to_string_16;
                                      return_value_neko_buffer_to_string_16=neko_buffer_to_string(b);
                                      neko_val_throw(return_value_neko_buffer_to_string_16);
                                    }
                                    pc = pc + 1l;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                    if(*pc++ == &&LabelAccStack0)
                                      goto LabelAccStack0;

                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                    if(*pc++ == &&LabelSetThis)
                                      goto LabelSetThis;

                                    if(*pc++ == &&LabelSetIndex)
                                      goto LabelSetIndex;

                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                  }
                                  while(*pc++ == &&LabelAccField);
                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelAccArray:
                                  ;
                                  if(!((1 & (signed int)acc) == 0))
                                  {
                                    if((1 & (signed int)*sp) == 0)
                                      tmp_if_expr_36 = ((signed int)*((enum anonymous_7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr_36 = (_Bool)0;
                                    tmp_if_expr_37 = tmp_if_expr_36 ? (_Bool)1 : (_Bool)0;
                                  }

                                  else
                                    tmp_if_expr_37 = (_Bool)0;
                                  if(tmp_if_expr_37)
                                  {
                                    signed int k = (signed int)(signed long int)acc >> 1;
                                    if(!(k >= 0))
                                      tmp_if_expr_18 = (_Bool)1;

                                    else
                                      tmp_if_expr_18 = k >= (signed int)*((enum anonymous_7 *)*sp) >> 4 ? (_Bool)1 : (_Bool)0;
                                    if(tmp_if_expr_18)
                                      acc = (signed long int)val_null;

                                    else
                                      acc = (signed long int)(&((struct anonymous_4 *)*sp)->ptr)[(signed long int)k];
                                  }

                                  else
                                  {
                                    if((1 & (signed int)*sp) == 0)
                                      tmp_if_expr_35 = (signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                    else
                                      tmp_if_expr_35 = (_Bool)0;
                                    if(tmp_if_expr_35)
                                    {
                                      struct _value *_o = (struct _value *)*sp;
                                      struct _value *_arg = (struct _value *)acc;
                                      struct _value *_f;
                                      _f=neko_val_field(_o, id_get);
                                      if(_f == val_null)
                                      {
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand_20;
                                          return_value_neko_stack_expand_20=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand_20 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string_19=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string_19);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string_21;
                                        return_value_neko_alloc_string_21=neko_alloc_string("Unsupported operation");
                                        neko_val_throw(return_value_neko_alloc_string_21);
                                      }

                                      else
                                      {
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand_23;
                                          return_value_neko_stack_expand_23=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand_23 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string_22=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string_22);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_val_callEx_24;
                                        return_value_neko_val_callEx_24=neko_val_callEx(_o, _f, &_arg, 1, (struct _value **)(void *)0);
                                        acc = (signed long int)return_value_neko_val_callEx_24;
                                        sp = vm->sp;
                                        csp = vm->csp;
                                        m = (struct _neko_module *)*csp;
                                        tmp_post_25 = csp;
                                        csp = csp - 1l;
                                        *tmp_post_25 = (signed long int)0;
                                        vm->vthis = (struct _value *)*csp;
                                        tmp_post_26 = csp;
                                        csp = csp - 1l;
                                        *tmp_post_26 = (signed long int)0;
                                        vm->env = (struct _value *)*csp;
                                        tmp_post_27 = csp;
                                        csp = csp - 1l;
                                        *tmp_post_27 = (signed long int)0;
                                        tmp_post_28 = csp;
                                        csp = csp - 1l;
                                        *tmp_post_28 = (signed long int)0;
                                      }
                                    }

                                    else
                                    {
                                      if((1 & (signed int)acc) == 0)
                                        tmp_if_expr_32 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

                                      else
                                        tmp_if_expr_32 = (_Bool)0;
                                      if(tmp_if_expr_32)
                                      {
                                        if((1 & (signed int)*sp) == 0)
                                          tmp_if_expr_33 = ((signed int)*((enum anonymous_7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr_33 = (_Bool)0;
                                        tmp_if_expr_34 = tmp_if_expr_33 ? (_Bool)1 : (_Bool)0;
                                      }

                                      else
                                        tmp_if_expr_34 = (_Bool)0;
                                      if(tmp_if_expr_34)
                                        acc = (signed long int)val_null;

                                      else
                                      {
                                        if(csp + 4l >= sp)
                                        {
                                          signed int return_value_neko_stack_expand_30;
                                          return_value_neko_stack_expand_30=neko_stack_expand(sp, csp, vm);
                                          if(!(return_value_neko_stack_expand_30 == 0))
                                          {
                                            sp = vm->sp;
                                            csp = vm->csp;
                                          }

                                          else
                                          {
                                            return_value_neko_alloc_string_29=neko_alloc_string("Stack Overflow");
                                            neko_val_throw(return_value_neko_alloc_string_29);
                                          }
                                        }

                                        csp = csp + 1l;
                                        *csp = (signed long int)pc;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->env;
                                        csp = csp + 1l;
                                        *csp = (signed long int)vm->vthis;
                                        csp = csp + 1l;
                                        *csp = (signed long int)m;
                                        vm->sp = sp;
                                        vm->csp = csp;
                                        struct _value *return_value_neko_alloc_string_31;
                                        return_value_neko_alloc_string_31=neko_alloc_string("Invalid array access");
                                        neko_val_throw(return_value_neko_alloc_string_31);
                                      }
                                    }
                                  }
                                  tmp_post_38 = sp;
                                  sp = sp + 1l;
                                  *tmp_post_38 = (signed long int)0;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                }
                                while(*pc++ == &&LabelAccArray);
                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                                if(*pc++ == &&LabelAccThis)
                                  goto LabelAccThis;

                                if(*pc++ == &&LabelAccFalse)
                                  goto LabelAccFalse;

                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelAccIndex0:
                                ;
                                if((1 & (signed int)acc) == 0)
                                  tmp_if_expr_53 = ((signed int)*((enum anonymous_7 *)acc) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr_53 = (_Bool)0;
                                if(tmp_if_expr_53)
                                {
                                  if(!((signed int)*((enum anonymous_7 *)acc) >> 4 == 0))
                                    acc = (signed long int)*(&((struct anonymous_4 *)acc)->ptr);

                                  else
                                    acc = (signed long int)val_null;
                                }

                                else
                                {
                                  if((1 & (signed int)acc) == 0)
                                    tmp_if_expr_52 = (signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr_52 = (_Bool)0;
                                  if(tmp_if_expr_52)
                                  {
                                    struct _value *neko_interp_loop__1__1__1__8___o = (struct _value *)acc;
                                    struct _value *neko_interp_loop__1__1__1__8___arg = (struct _value *)(signed long int)((signed int)0 << 1 | 1);
                                    struct _value *neko_interp_loop__1__1__1__8___f;
                                    neko_interp_loop__1__1__1__8___f=neko_val_field(neko_interp_loop__1__1__1__8___o, id_get);
                                    if(neko_interp_loop__1__1__1__8___f == val_null)
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_40;
                                        return_value_neko_stack_expand_40=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_40 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_39=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_39);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string_41;
                                      return_value_neko_alloc_string_41=neko_alloc_string("Unsupported operation");
                                      neko_val_throw(return_value_neko_alloc_string_41);
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_43;
                                        return_value_neko_stack_expand_43=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_43 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_42=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_42);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_val_callEx_44;
                                      return_value_neko_val_callEx_44=neko_val_callEx(neko_interp_loop__1__1__1__8___o, neko_interp_loop__1__1__1__8___f, &neko_interp_loop__1__1__1__8___arg, 1, (struct _value **)(void *)0);
                                      acc = (signed long int)return_value_neko_val_callEx_44;
                                      sp = vm->sp;
                                      csp = vm->csp;
                                      m = (struct _neko_module *)*csp;
                                      tmp_post_45 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_45 = (signed long int)0;
                                      vm->vthis = (struct _value *)*csp;
                                      tmp_post_46 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_46 = (signed long int)0;
                                      vm->env = (struct _value *)*csp;
                                      tmp_post_47 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_47 = (signed long int)0;
                                      tmp_post_48 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_48 = (signed long int)0;
                                    }
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_50;
                                      return_value_neko_stack_expand_50=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_50 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_49=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_49);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_51;
                                    return_value_neko_alloc_string_51=neko_alloc_string("Invalid array access");
                                    neko_val_throw(return_value_neko_alloc_string_51);
                                  }
                                }
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                              }
                              while(*pc++ == &&LabelAccIndex0);
                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelAccIndex1:
                              ;
                              if((1 & (signed int)acc) == 0)
                                tmp_if_expr_68 = ((signed int)*((enum anonymous_7 *)acc) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr_68 = (_Bool)0;
                              if(tmp_if_expr_68)
                              {
                                if((signed int)*((enum anonymous_7 *)acc) >> 4 >= 2)
                                  acc = (signed long int)(&((struct anonymous_4 *)acc)->ptr)[(signed long int)1];

                                else
                                  acc = (signed long int)val_null;
                              }

                              else
                              {
                                if((1 & (signed int)acc) == 0)
                                  tmp_if_expr_67 = (signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr_67 = (_Bool)0;
                                if(tmp_if_expr_67)
                                {
                                  struct _value *neko_interp_loop__1__1__1__11___o = (struct _value *)acc;
                                  struct _value *neko_interp_loop__1__1__1__11___arg = (struct _value *)(signed long int)((signed int)1 << 1 | 1);
                                  struct _value *neko_interp_loop__1__1__1__11___f;
                                  neko_interp_loop__1__1__1__11___f=neko_val_field(neko_interp_loop__1__1__1__11___o, id_get);
                                  if(neko_interp_loop__1__1__1__11___f == val_null)
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_55;
                                      return_value_neko_stack_expand_55=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_55 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_54=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_54);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_56;
                                    return_value_neko_alloc_string_56=neko_alloc_string("Unsupported operation");
                                    neko_val_throw(return_value_neko_alloc_string_56);
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_58;
                                      return_value_neko_stack_expand_58=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_58 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_57=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_57);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_val_callEx_59;
                                    return_value_neko_val_callEx_59=neko_val_callEx(neko_interp_loop__1__1__1__11___o, neko_interp_loop__1__1__1__11___f, &neko_interp_loop__1__1__1__11___arg, 1, (struct _value **)(void *)0);
                                    acc = (signed long int)return_value_neko_val_callEx_59;
                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_60 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_60 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_61 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_61 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_62 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_62 = (signed long int)0;
                                    tmp_post_63 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_63 = (signed long int)0;
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_65;
                                    return_value_neko_stack_expand_65=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_65 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_64=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_64);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string_66;
                                  return_value_neko_alloc_string_66=neko_alloc_string("Invalid array access");
                                  neko_val_throw(return_value_neko_alloc_string_66);
                                }
                              }
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                            }
                            while(*pc++ == &&LabelAccIndex1);
                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(!(*pc++ == &&LabelApply))
                            {
                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(!(*pc++ == &&LabelPop))
                              {
                                if(!(*pc++ == &&LabelPush))
                                {
                                  if(!(*pc++ == &&LabelSetThis))
                                  {
                                    if(!(*pc++ == &&LabelSetIndex))
                                    {
                                      if(!(*pc++ == &&LabelSetArray))
                                      {
                                        if(!(*pc++ == &&LabelSetField))
                                        {
                                          if(!(*pc++ == &&LabelSetEnv))
                                          {
                                            if(!(*pc++ == &&LabelSetGlobal))
                                            {
                                              if(!(*pc++ == &&LabelSetStack))
                                              {
                                                if(!(*pc++ == &&LabelAccBuiltin))
                                                {
                                                  if(!(*pc++ == &&LabelAccIndex))
                                                  {
                                                    if(*pc++ == &&LabelAccArray)
                                                      goto LabelAccArray;

                                                    if(*pc++ == &&LabelAccField)
                                                      goto LabelAccField;

                                                    if(*pc++ == &&LabelAccEnv)
                                                      goto LabelAccEnv;

                                                    if(*pc++ == &&LabelAccGlobal)
                                                      goto LabelAccGlobal;

                                                    if(*pc++ == &&LabelAccStack)
                                                      goto LabelAccStack;

                                                    if(*pc++ == &&LabelAccInt)
                                                      goto LabelAccInt;

                                                    if(*pc++ == &&LabelAccThis)
                                                      goto LabelAccThis;

                                                    if(*pc++ == &&LabelAccFalse)
                                                      goto LabelAccFalse;

                                                    if(*pc++ == &&LabelAccTrue)
                                                      goto LabelAccTrue;

                                                    if(*pc++ == &&LabelAccNull)
                                                      goto LabelAccNull;

                                                    if(*pc++ == &&end)
                                                      goto end;

                                                  }

                                                  do
                                                  {

                                                  LabelAccIndex:
                                                    ;
                                                    if((1 & (signed int)acc) == 0)
                                                      tmp_if_expr_85 = ((signed int)*((enum anonymous_7 *)acc) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                                    else
                                                      tmp_if_expr_85 = (_Bool)0;
                                                    if(tmp_if_expr_85)
                                                    {
                                                      if(!(*pc >= 0l))
                                                        tmp_if_expr_69 = (_Bool)1;

                                                      else
                                                        tmp_if_expr_69 = *pc >= (signed long int)((signed int)*((enum anonymous_7 *)acc) >> 4) ? (_Bool)1 : (_Bool)0;
                                                      if(tmp_if_expr_69)
                                                        acc = (signed long int)val_null;

                                                      else
                                                        acc = (signed long int)(&((struct anonymous_4 *)acc)->ptr)[*pc];
                                                      pc = pc + 1l;
                                                    }

                                                    else
                                                    {
                                                      if((1 & (signed int)acc) == 0)
                                                        tmp_if_expr_84 = (signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                                      else
                                                        tmp_if_expr_84 = (_Bool)0;
                                                      if(tmp_if_expr_84)
                                                      {
                                                        struct _value *neko_interp_loop__1__1__1__14___o = (struct _value *)acc;
                                                        struct _value *neko_interp_loop__1__1__1__14___arg;
                                                        tmp_post_70 = pc;
                                                        pc = pc + 1l;
                                                        neko_interp_loop__1__1__1__14___arg = (struct _value *)(signed long int)((signed int)*tmp_post_70 << 1 | 1);
                                                        struct _value *neko_interp_loop__1__1__1__14___f;
                                                        neko_interp_loop__1__1__1__14___f=neko_val_field(neko_interp_loop__1__1__1__14___o, id_get);
                                                        if(neko_interp_loop__1__1__1__14___f == val_null)
                                                        {
                                                          if(csp + 4l >= sp)
                                                          {
                                                            signed int return_value_neko_stack_expand_72;
                                                            return_value_neko_stack_expand_72=neko_stack_expand(sp, csp, vm);
                                                            if(!(return_value_neko_stack_expand_72 == 0))
                                                            {
                                                              sp = vm->sp;
                                                              csp = vm->csp;
                                                            }

                                                            else
                                                            {
                                                              return_value_neko_alloc_string_71=neko_alloc_string("Stack Overflow");
                                                              neko_val_throw(return_value_neko_alloc_string_71);
                                                            }
                                                          }

                                                          csp = csp + 1l;
                                                          *csp = (signed long int)pc;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->env;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->vthis;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)m;
                                                          vm->sp = sp;
                                                          vm->csp = csp;
                                                          struct _value *return_value_neko_alloc_string_73;
                                                          return_value_neko_alloc_string_73=neko_alloc_string("Unsupported operation");
                                                          neko_val_throw(return_value_neko_alloc_string_73);
                                                        }

                                                        else
                                                        {
                                                          if(csp + 4l >= sp)
                                                          {
                                                            signed int return_value_neko_stack_expand_75;
                                                            return_value_neko_stack_expand_75=neko_stack_expand(sp, csp, vm);
                                                            if(!(return_value_neko_stack_expand_75 == 0))
                                                            {
                                                              sp = vm->sp;
                                                              csp = vm->csp;
                                                            }

                                                            else
                                                            {
                                                              return_value_neko_alloc_string_74=neko_alloc_string("Stack Overflow");
                                                              neko_val_throw(return_value_neko_alloc_string_74);
                                                            }
                                                          }

                                                          csp = csp + 1l;
                                                          *csp = (signed long int)pc;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->env;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)vm->vthis;
                                                          csp = csp + 1l;
                                                          *csp = (signed long int)m;
                                                          vm->sp = sp;
                                                          vm->csp = csp;
                                                          struct _value *return_value_neko_val_callEx_76;
                                                          return_value_neko_val_callEx_76=neko_val_callEx(neko_interp_loop__1__1__1__14___o, neko_interp_loop__1__1__1__14___f, &neko_interp_loop__1__1__1__14___arg, 1, (struct _value **)(void *)0);
                                                          acc = (signed long int)return_value_neko_val_callEx_76;
                                                          sp = vm->sp;
                                                          csp = vm->csp;
                                                          m = (struct _neko_module *)*csp;
                                                          tmp_post_77 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post_77 = (signed long int)0;
                                                          vm->vthis = (struct _value *)*csp;
                                                          tmp_post_78 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post_78 = (signed long int)0;
                                                          vm->env = (struct _value *)*csp;
                                                          tmp_post_79 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post_79 = (signed long int)0;
                                                          tmp_post_80 = csp;
                                                          csp = csp - 1l;
                                                          *tmp_post_80 = (signed long int)0;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        pc = pc + 1l;
                                                        if(csp + 4l >= sp)
                                                        {
                                                          signed int return_value_neko_stack_expand_82;
                                                          return_value_neko_stack_expand_82=neko_stack_expand(sp, csp, vm);
                                                          if(!(return_value_neko_stack_expand_82 == 0))
                                                          {
                                                            sp = vm->sp;
                                                            csp = vm->csp;
                                                          }

                                                          else
                                                          {
                                                            return_value_neko_alloc_string_81=neko_alloc_string("Stack Overflow");
                                                            neko_val_throw(return_value_neko_alloc_string_81);
                                                          }
                                                        }

                                                        csp = csp + 1l;
                                                        *csp = (signed long int)pc;
                                                        csp = csp + 1l;
                                                        *csp = (signed long int)vm->env;
                                                        csp = csp + 1l;
                                                        *csp = (signed long int)vm->vthis;
                                                        csp = csp + 1l;
                                                        *csp = (signed long int)m;
                                                        vm->sp = sp;
                                                        vm->csp = csp;
                                                        struct _value *return_value_neko_alloc_string_83;
                                                        return_value_neko_alloc_string_83=neko_alloc_string("Invalid array access");
                                                        neko_val_throw(return_value_neko_alloc_string_83);
                                                      }
                                                    }
                                                    *pc++;
                                                    if(*pc++ == &&id_mod_next2)
                                                      goto id_mod_next2;

                                                    if(*pc++ == &&id_mod_next)
                                                      goto id_mod_next;

                                                    if(*pc++ == &&div_next)
                                                      goto div_next;

                                                    if(*pc++ == &&id_mult_next2)
                                                      goto id_mult_next2;

                                                    if(*pc++ == &&id_mult_next)
                                                      goto id_mult_next;

                                                    if(*pc++ == &&id_sub_next2)
                                                      goto id_sub_next2;

                                                    if(*pc++ == &&id_sub_next)
                                                      goto id_sub_next;

                                                    if(*pc++ == &&add_3)
                                                      goto add_3;

                                                    if(*pc++ == &&add_2)
                                                      goto add_2;

                                                    if(*pc++ == &&add_next)
                                                      goto add_next;

                                                    if(*pc++ == &&do_call)
                                                      goto LabelCall;

                                                    if(*pc++ == &&LabelLast)
                                                      goto LabelLast;

                                                    if(*pc++ == &&LabelAccInt32)
                                                      goto LabelAccInt32;

                                                    if(*pc++ == &&LabelMakeArray2)
                                                      goto LabelMakeArray2;

                                                    if(*pc++ == &&LabelLoop)
                                                      goto LabelLoop;

                                                    if(*pc++ == &&LabelTailCall)
                                                      goto LabelTailCall;

                                                    if(*pc++ == &&LabelPhysCompare)
                                                      goto LabelPhysCompare;

                                                    if(*pc++ == &&LabelAccIndex1)
                                                      goto LabelAccIndex1;

                                                    if(*pc++ == &&LabelAccIndex0)
                                                      goto LabelAccIndex0;

                                                    if(*pc++ == &&LabelAccStack1)
                                                      goto LabelAccStack1;

                                                    if(*pc++ == &&LabelAccStack0)
                                                      goto LabelAccStack0;

                                                    if(*pc++ == &&LabelApply)
                                                      goto LabelApply;

                                                    if(*pc++ == &&LabelJumpTable)
                                                      goto LabelJumpTable;

                                                    if(*pc++ == &&LabelNew)
                                                      goto LabelNew;

                                                    if(*pc++ == &&LabelHash)
                                                      goto LabelHash;

                                                    if(*pc++ == &&LabelCompare)
                                                      goto LabelCompare;

                                                    if(*pc++ == &&LabelTypeOf)
                                                      goto LabelTypeOf;

                                                    if(*pc++ == &&LabelNot)
                                                      goto LabelNot;

                                                    if(*pc++ == &&LabelLte)
                                                      goto LabelLte;

                                                    if(*pc++ == &&LabelLt)
                                                      goto LabelLt;

                                                    if(*pc++ == &&LabelGte)
                                                      goto LabelGte;

                                                    if(*pc++ == &&LabelGt)
                                                      goto LabelGt;

                                                    if(*pc++ == &&LabelNeq)
                                                      goto LabelNeq;

                                                    if(*pc++ == &&LabelEq)
                                                      goto LabelEq;

                                                    if(*pc++ == &&LabelXor)
                                                      goto LabelXor;

                                                    if(*pc++ == &&LabelAnd)
                                                      goto LabelAnd;

                                                    if(*pc++ == &&LabelOr)
                                                      goto LabelOr;

                                                    if(*pc++ == &&LabelUShr)
                                                      goto LabelUShr;

                                                    if(*pc++ == &&LabelShr)
                                                      goto LabelShr;

                                                    if(*pc++ == &&LabelShl)
                                                      goto LabelShl;

                                                    if(*pc++ == &&LabelMod)
                                                      goto LabelMod;

                                                    if(*pc++ == &&LabelDiv)
                                                      goto LabelDiv;

                                                    if(*pc++ == &&LabelMult)
                                                      goto LabelMult;

                                                    if(*pc++ == &&LabelSub)
                                                      goto LabelSub;

                                                    if(*pc++ == &&LabelAdd)
                                                      goto LabelAdd;

                                                    if(*pc++ == &&LabelIsNotNull)
                                                      goto LabelIsNotNull;

                                                    if(*pc++ == &&LabelIsNull)
                                                      goto LabelIsNull;

                                                    if(*pc++ == &&LabelBool)
                                                      goto LabelBool;

                                                    if(*pc++ == &&LabelMakeArray)
                                                      goto LabelMakeArray;

                                                    if(*pc++ == &&LabelMakeEnv)
                                                      goto LabelMakeEnv;

                                                    if(*pc++ == &&LabelRet)
                                                      goto LabelRet;

                                                    if(*pc++ == &&LabelEndTrap)
                                                      goto LabelEndTrap;

                                                    if(*pc++ == &&LabelTrap)
                                                      goto LabelTrap;

                                                    if(*pc++ == &&LabelJumpIfNot)
                                                      goto LabelJumpIfNot;

                                                    if(*pc++ == &&LabelJumpIf)
                                                      goto LabelJumpIf;

                                                    if(*pc++ == &&LabelJump)
                                                      goto LabelJump;

                                                    if(*pc++ == &&LabelObjCall)
                                                      goto LabelObjCall;

                                                    if(*pc++ == &&LabelCall)
                                                      goto LabelCall;

                                                    if(*pc++ == &&LabelPop)
                                                      goto LabelPop;

                                                    if(*pc++ == &&LabelPush)
                                                      goto LabelPush;

                                                    if(*pc++ == &&LabelSetThis)
                                                      goto LabelSetThis;

                                                    if(*pc++ == &&LabelSetIndex)
                                                      goto LabelSetIndex;

                                                    if(*pc++ == &&LabelSetArray)
                                                      goto LabelSetArray;

                                                    if(*pc++ == &&LabelSetField)
                                                      goto LabelSetField;

                                                    if(*pc++ == &&LabelSetEnv)
                                                      goto LabelSetEnv;

                                                    if(*pc++ == &&LabelSetGlobal)
                                                      goto LabelSetGlobal;

                                                    if(*pc++ == &&LabelSetStack)
                                                      goto LabelSetStack;

                                                    if(*pc++ == &&LabelAccBuiltin)
                                                      goto LabelAccBuiltin;

                                                  }
                                                  while(*pc++ == &&LabelAccIndex);
                                                  if(*pc++ == &&LabelAccArray)
                                                    goto LabelAccArray;

                                                  if(*pc++ == &&LabelAccField)
                                                    goto LabelAccField;

                                                  if(*pc++ == &&LabelAccEnv)
                                                    goto LabelAccEnv;

                                                  if(*pc++ == &&LabelAccGlobal)
                                                    goto LabelAccGlobal;

                                                  if(*pc++ == &&LabelAccStack)
                                                    goto LabelAccStack;

                                                  if(*pc++ == &&LabelAccInt)
                                                    goto LabelAccInt;

                                                  if(*pc++ == &&LabelAccThis)
                                                    goto LabelAccThis;

                                                  if(*pc++ == &&LabelAccFalse)
                                                    goto LabelAccFalse;

                                                  if(*pc++ == &&LabelAccTrue)
                                                    goto LabelAccTrue;

                                                  if(*pc++ == &&LabelAccNull)
                                                    goto LabelAccNull;

                                                  if(*pc++ == &&end)
                                                    goto end;

                                                }

                                                do
                                                {

                                                LabelAccBuiltin:
                                                  ;
                                                  tmp_post_86 = pc;
                                                  pc = pc + 1l;
                                                  acc = *tmp_post_86;
                                                  *pc++;
                                                  if(*pc++ == &&id_mod_next2)
                                                    goto id_mod_next2;

                                                  if(*pc++ == &&id_mod_next)
                                                    goto id_mod_next;

                                                  if(*pc++ == &&div_next)
                                                    goto div_next;

                                                  if(*pc++ == &&id_mult_next2)
                                                    goto id_mult_next2;

                                                  if(*pc++ == &&id_mult_next)
                                                    goto id_mult_next;

                                                  if(*pc++ == &&id_sub_next2)
                                                    goto id_sub_next2;

                                                  if(*pc++ == &&id_sub_next)
                                                    goto id_sub_next;

                                                  if(*pc++ == &&add_3)
                                                    goto add_3;

                                                  if(*pc++ == &&add_2)
                                                    goto add_2;

                                                  if(*pc++ == &&add_next)
                                                    goto add_next;

                                                  if(*pc++ == &&do_call)
                                                    goto LabelCall;

                                                  if(*pc++ == &&LabelLast)
                                                    goto LabelLast;

                                                  if(*pc++ == &&LabelAccInt32)
                                                    goto LabelAccInt32;

                                                  if(*pc++ == &&LabelMakeArray2)
                                                    goto LabelMakeArray2;

                                                  if(*pc++ == &&LabelLoop)
                                                    goto LabelLoop;

                                                  if(*pc++ == &&LabelTailCall)
                                                    goto LabelTailCall;

                                                  if(*pc++ == &&LabelPhysCompare)
                                                    goto LabelPhysCompare;

                                                  if(*pc++ == &&LabelAccIndex1)
                                                    goto LabelAccIndex1;

                                                  if(*pc++ == &&LabelAccIndex0)
                                                    goto LabelAccIndex0;

                                                  if(*pc++ == &&LabelAccStack1)
                                                    goto LabelAccStack1;

                                                  if(*pc++ == &&LabelAccStack0)
                                                    goto LabelAccStack0;

                                                  if(*pc++ == &&LabelApply)
                                                    goto LabelApply;

                                                  if(*pc++ == &&LabelJumpTable)
                                                    goto LabelJumpTable;

                                                  if(*pc++ == &&LabelNew)
                                                    goto LabelNew;

                                                  if(*pc++ == &&LabelHash)
                                                    goto LabelHash;

                                                  if(*pc++ == &&LabelCompare)
                                                    goto LabelCompare;

                                                  if(*pc++ == &&LabelTypeOf)
                                                    goto LabelTypeOf;

                                                  if(*pc++ == &&LabelNot)
                                                    goto LabelNot;

                                                  if(*pc++ == &&LabelLte)
                                                    goto LabelLte;

                                                  if(*pc++ == &&LabelLt)
                                                    goto LabelLt;

                                                  if(*pc++ == &&LabelGte)
                                                    goto LabelGte;

                                                  if(*pc++ == &&LabelGt)
                                                    goto LabelGt;

                                                  if(*pc++ == &&LabelNeq)
                                                    goto LabelNeq;

                                                  if(*pc++ == &&LabelEq)
                                                    goto LabelEq;

                                                  if(*pc++ == &&LabelXor)
                                                    goto LabelXor;

                                                  if(*pc++ == &&LabelAnd)
                                                    goto LabelAnd;

                                                  if(*pc++ == &&LabelOr)
                                                    goto LabelOr;

                                                  if(*pc++ == &&LabelUShr)
                                                    goto LabelUShr;

                                                  if(*pc++ == &&LabelShr)
                                                    goto LabelShr;

                                                  if(*pc++ == &&LabelShl)
                                                    goto LabelShl;

                                                  if(*pc++ == &&LabelMod)
                                                    goto LabelMod;

                                                  if(*pc++ == &&LabelDiv)
                                                    goto LabelDiv;

                                                  if(*pc++ == &&LabelMult)
                                                    goto LabelMult;

                                                  if(*pc++ == &&LabelSub)
                                                    goto LabelSub;

                                                  if(*pc++ == &&LabelAdd)
                                                    goto LabelAdd;

                                                  if(*pc++ == &&LabelIsNotNull)
                                                    goto LabelIsNotNull;

                                                  if(*pc++ == &&LabelIsNull)
                                                    goto LabelIsNull;

                                                  if(*pc++ == &&LabelBool)
                                                    goto LabelBool;

                                                  if(*pc++ == &&LabelMakeArray)
                                                    goto LabelMakeArray;

                                                  if(*pc++ == &&LabelMakeEnv)
                                                    goto LabelMakeEnv;

                                                  if(*pc++ == &&LabelRet)
                                                    goto LabelRet;

                                                  if(*pc++ == &&LabelEndTrap)
                                                    goto LabelEndTrap;

                                                  if(*pc++ == &&LabelTrap)
                                                    goto LabelTrap;

                                                  if(*pc++ == &&LabelJumpIfNot)
                                                    goto LabelJumpIfNot;

                                                  if(*pc++ == &&LabelJumpIf)
                                                    goto LabelJumpIf;

                                                  if(*pc++ == &&LabelJump)
                                                    goto LabelJump;

                                                  if(*pc++ == &&LabelObjCall)
                                                    goto LabelObjCall;

                                                  if(*pc++ == &&LabelCall)
                                                    goto LabelCall;

                                                  if(*pc++ == &&LabelPop)
                                                    goto LabelPop;

                                                  if(*pc++ == &&LabelPush)
                                                    goto LabelPush;

                                                  if(*pc++ == &&LabelSetThis)
                                                    goto LabelSetThis;

                                                  if(*pc++ == &&LabelSetIndex)
                                                    goto LabelSetIndex;

                                                  if(*pc++ == &&LabelSetArray)
                                                    goto LabelSetArray;

                                                  if(*pc++ == &&LabelSetField)
                                                    goto LabelSetField;

                                                  if(*pc++ == &&LabelSetEnv)
                                                    goto LabelSetEnv;

                                                  if(*pc++ == &&LabelSetGlobal)
                                                    goto LabelSetGlobal;

                                                  if(*pc++ == &&LabelSetStack)
                                                    goto LabelSetStack;

                                                }
                                                while(*pc++ == &&LabelAccBuiltin);
                                                if(*pc++ == &&LabelAccIndex)
                                                  goto LabelAccIndex;

                                                if(*pc++ == &&LabelAccArray)
                                                  goto LabelAccArray;

                                                if(*pc++ == &&LabelAccField)
                                                  goto LabelAccField;

                                                if(*pc++ == &&LabelAccEnv)
                                                  goto LabelAccEnv;

                                                if(*pc++ == &&LabelAccGlobal)
                                                  goto LabelAccGlobal;

                                                if(*pc++ == &&LabelAccStack)
                                                  goto LabelAccStack;

                                                if(*pc++ == &&LabelAccInt)
                                                  goto LabelAccInt;

                                                if(*pc++ == &&LabelAccThis)
                                                  goto LabelAccThis;

                                                if(*pc++ == &&LabelAccFalse)
                                                  goto LabelAccFalse;

                                                if(*pc++ == &&LabelAccTrue)
                                                  goto LabelAccTrue;

                                                if(*pc++ == &&LabelAccNull)
                                                  goto LabelAccNull;

                                                if(*pc++ == &&end)
                                                  goto end;

                                              }

                                              do
                                              {

                                              LabelSetStack:
                                                ;
                                                tmp_post_87 = pc;
                                                pc = pc + 1l;
                                                sp[*tmp_post_87] = acc;
                                                *pc++;
                                                if(*pc++ == &&id_mod_next2)
                                                  goto id_mod_next2;

                                                if(*pc++ == &&id_mod_next)
                                                  goto id_mod_next;

                                                if(*pc++ == &&div_next)
                                                  goto div_next;

                                                if(*pc++ == &&id_mult_next2)
                                                  goto id_mult_next2;

                                                if(*pc++ == &&id_mult_next)
                                                  goto id_mult_next;

                                                if(*pc++ == &&id_sub_next2)
                                                  goto id_sub_next2;

                                                if(*pc++ == &&id_sub_next)
                                                  goto id_sub_next;

                                                if(*pc++ == &&add_3)
                                                  goto add_3;

                                                if(*pc++ == &&add_2)
                                                  goto add_2;

                                                if(*pc++ == &&add_next)
                                                  goto add_next;

                                                if(*pc++ == &&do_call)
                                                  goto LabelCall;

                                                if(*pc++ == &&LabelLast)
                                                  goto LabelLast;

                                                if(*pc++ == &&LabelAccInt32)
                                                  goto LabelAccInt32;

                                                if(*pc++ == &&LabelMakeArray2)
                                                  goto LabelMakeArray2;

                                                if(*pc++ == &&LabelLoop)
                                                  goto LabelLoop;

                                                if(*pc++ == &&LabelTailCall)
                                                  goto LabelTailCall;

                                                if(*pc++ == &&LabelPhysCompare)
                                                  goto LabelPhysCompare;

                                                if(*pc++ == &&LabelAccIndex1)
                                                  goto LabelAccIndex1;

                                                if(*pc++ == &&LabelAccIndex0)
                                                  goto LabelAccIndex0;

                                                if(*pc++ == &&LabelAccStack1)
                                                  goto LabelAccStack1;

                                                if(*pc++ == &&LabelAccStack0)
                                                  goto LabelAccStack0;

                                                if(*pc++ == &&LabelApply)
                                                  goto LabelApply;

                                                if(*pc++ == &&LabelJumpTable)
                                                  goto LabelJumpTable;

                                                if(*pc++ == &&LabelNew)
                                                  goto LabelNew;

                                                if(*pc++ == &&LabelHash)
                                                  goto LabelHash;

                                                if(*pc++ == &&LabelCompare)
                                                  goto LabelCompare;

                                                if(*pc++ == &&LabelTypeOf)
                                                  goto LabelTypeOf;

                                                if(*pc++ == &&LabelNot)
                                                  goto LabelNot;

                                                if(*pc++ == &&LabelLte)
                                                  goto LabelLte;

                                                if(*pc++ == &&LabelLt)
                                                  goto LabelLt;

                                                if(*pc++ == &&LabelGte)
                                                  goto LabelGte;

                                                if(*pc++ == &&LabelGt)
                                                  goto LabelGt;

                                                if(*pc++ == &&LabelNeq)
                                                  goto LabelNeq;

                                                if(*pc++ == &&LabelEq)
                                                  goto LabelEq;

                                                if(*pc++ == &&LabelXor)
                                                  goto LabelXor;

                                                if(*pc++ == &&LabelAnd)
                                                  goto LabelAnd;

                                                if(*pc++ == &&LabelOr)
                                                  goto LabelOr;

                                                if(*pc++ == &&LabelUShr)
                                                  goto LabelUShr;

                                                if(*pc++ == &&LabelShr)
                                                  goto LabelShr;

                                                if(*pc++ == &&LabelShl)
                                                  goto LabelShl;

                                                if(*pc++ == &&LabelMod)
                                                  goto LabelMod;

                                                if(*pc++ == &&LabelDiv)
                                                  goto LabelDiv;

                                                if(*pc++ == &&LabelMult)
                                                  goto LabelMult;

                                                if(*pc++ == &&LabelSub)
                                                  goto LabelSub;

                                                if(*pc++ == &&LabelAdd)
                                                  goto LabelAdd;

                                                if(*pc++ == &&LabelIsNotNull)
                                                  goto LabelIsNotNull;

                                                if(*pc++ == &&LabelIsNull)
                                                  goto LabelIsNull;

                                                if(*pc++ == &&LabelBool)
                                                  goto LabelBool;

                                                if(*pc++ == &&LabelMakeArray)
                                                  goto LabelMakeArray;

                                                if(*pc++ == &&LabelMakeEnv)
                                                  goto LabelMakeEnv;

                                                if(*pc++ == &&LabelRet)
                                                  goto LabelRet;

                                                if(*pc++ == &&LabelEndTrap)
                                                  goto LabelEndTrap;

                                                if(*pc++ == &&LabelTrap)
                                                  goto LabelTrap;

                                                if(*pc++ == &&LabelJumpIfNot)
                                                  goto LabelJumpIfNot;

                                                if(*pc++ == &&LabelJumpIf)
                                                  goto LabelJumpIf;

                                                if(*pc++ == &&LabelJump)
                                                  goto LabelJump;

                                                if(*pc++ == &&LabelObjCall)
                                                  goto LabelObjCall;

                                                if(*pc++ == &&LabelCall)
                                                  goto LabelCall;

                                                if(*pc++ == &&LabelPop)
                                                  goto LabelPop;

                                                if(*pc++ == &&LabelPush)
                                                  goto LabelPush;

                                                if(*pc++ == &&LabelSetThis)
                                                  goto LabelSetThis;

                                                if(*pc++ == &&LabelSetIndex)
                                                  goto LabelSetIndex;

                                                if(*pc++ == &&LabelSetArray)
                                                  goto LabelSetArray;

                                                if(*pc++ == &&LabelSetField)
                                                  goto LabelSetField;

                                                if(*pc++ == &&LabelSetEnv)
                                                  goto LabelSetEnv;

                                                if(*pc++ == &&LabelSetGlobal)
                                                  goto LabelSetGlobal;

                                              }
                                              while(*pc++ == &&LabelSetStack);
                                              if(*pc++ == &&LabelAccBuiltin)
                                                goto LabelAccBuiltin;

                                              if(*pc++ == &&LabelAccIndex)
                                                goto LabelAccIndex;

                                              if(*pc++ == &&LabelAccArray)
                                                goto LabelAccArray;

                                              if(*pc++ == &&LabelAccField)
                                                goto LabelAccField;

                                              if(*pc++ == &&LabelAccEnv)
                                                goto LabelAccEnv;

                                              if(*pc++ == &&LabelAccGlobal)
                                                goto LabelAccGlobal;

                                              if(*pc++ == &&LabelAccStack)
                                                goto LabelAccStack;

                                              if(*pc++ == &&LabelAccInt)
                                                goto LabelAccInt;

                                              if(*pc++ == &&LabelAccThis)
                                                goto LabelAccThis;

                                              if(*pc++ == &&LabelAccFalse)
                                                goto LabelAccFalse;

                                              if(*pc++ == &&LabelAccTrue)
                                                goto LabelAccTrue;

                                              if(*pc++ == &&LabelAccNull)
                                                goto LabelAccNull;

                                              if(*pc++ == &&end)
                                                goto end;

                                            }

                                            do
                                            {

                                            LabelSetGlobal:
                                              ;
                                              tmp_post_88 = pc;
                                              pc = pc + 1l;
                                              *((signed long int *)*tmp_post_88) = acc;
                                              *pc++;
                                              if(*pc++ == &&id_mod_next2)
                                                goto id_mod_next2;

                                              if(*pc++ == &&id_mod_next)
                                                goto id_mod_next;

                                              if(*pc++ == &&div_next)
                                                goto div_next;

                                              if(*pc++ == &&id_mult_next2)
                                                goto id_mult_next2;

                                              if(*pc++ == &&id_mult_next)
                                                goto id_mult_next;

                                              if(*pc++ == &&id_sub_next2)
                                                goto id_sub_next2;

                                              if(*pc++ == &&id_sub_next)
                                                goto id_sub_next;

                                              if(*pc++ == &&add_3)
                                                goto add_3;

                                              if(*pc++ == &&add_2)
                                                goto add_2;

                                              if(*pc++ == &&add_next)
                                                goto add_next;

                                              if(*pc++ == &&do_call)
                                                goto LabelCall;

                                              if(*pc++ == &&LabelLast)
                                                goto LabelLast;

                                              if(*pc++ == &&LabelAccInt32)
                                                goto LabelAccInt32;

                                              if(*pc++ == &&LabelMakeArray2)
                                                goto LabelMakeArray2;

                                              if(*pc++ == &&LabelLoop)
                                                goto LabelLoop;

                                              if(*pc++ == &&LabelTailCall)
                                                goto LabelTailCall;

                                              if(*pc++ == &&LabelPhysCompare)
                                                goto LabelPhysCompare;

                                              if(*pc++ == &&LabelAccIndex1)
                                                goto LabelAccIndex1;

                                              if(*pc++ == &&LabelAccIndex0)
                                                goto LabelAccIndex0;

                                              if(*pc++ == &&LabelAccStack1)
                                                goto LabelAccStack1;

                                              if(*pc++ == &&LabelAccStack0)
                                                goto LabelAccStack0;

                                              if(*pc++ == &&LabelApply)
                                                goto LabelApply;

                                              if(*pc++ == &&LabelJumpTable)
                                                goto LabelJumpTable;

                                              if(*pc++ == &&LabelNew)
                                                goto LabelNew;

                                              if(*pc++ == &&LabelHash)
                                                goto LabelHash;

                                              if(*pc++ == &&LabelCompare)
                                                goto LabelCompare;

                                              if(*pc++ == &&LabelTypeOf)
                                                goto LabelTypeOf;

                                              if(*pc++ == &&LabelNot)
                                                goto LabelNot;

                                              if(*pc++ == &&LabelLte)
                                                goto LabelLte;

                                              if(*pc++ == &&LabelLt)
                                                goto LabelLt;

                                              if(*pc++ == &&LabelGte)
                                                goto LabelGte;

                                              if(*pc++ == &&LabelGt)
                                                goto LabelGt;

                                              if(*pc++ == &&LabelNeq)
                                                goto LabelNeq;

                                              if(*pc++ == &&LabelEq)
                                                goto LabelEq;

                                              if(*pc++ == &&LabelXor)
                                                goto LabelXor;

                                              if(*pc++ == &&LabelAnd)
                                                goto LabelAnd;

                                              if(*pc++ == &&LabelOr)
                                                goto LabelOr;

                                              if(*pc++ == &&LabelUShr)
                                                goto LabelUShr;

                                              if(*pc++ == &&LabelShr)
                                                goto LabelShr;

                                              if(*pc++ == &&LabelShl)
                                                goto LabelShl;

                                              if(*pc++ == &&LabelMod)
                                                goto LabelMod;

                                              if(*pc++ == &&LabelDiv)
                                                goto LabelDiv;

                                              if(*pc++ == &&LabelMult)
                                                goto LabelMult;

                                              if(*pc++ == &&LabelSub)
                                                goto LabelSub;

                                              if(*pc++ == &&LabelAdd)
                                                goto LabelAdd;

                                              if(*pc++ == &&LabelIsNotNull)
                                                goto LabelIsNotNull;

                                              if(*pc++ == &&LabelIsNull)
                                                goto LabelIsNull;

                                              if(*pc++ == &&LabelBool)
                                                goto LabelBool;

                                              if(*pc++ == &&LabelMakeArray)
                                                goto LabelMakeArray;

                                              if(*pc++ == &&LabelMakeEnv)
                                                goto LabelMakeEnv;

                                              if(*pc++ == &&LabelRet)
                                                goto LabelRet;

                                              if(*pc++ == &&LabelEndTrap)
                                                goto LabelEndTrap;

                                              if(*pc++ == &&LabelTrap)
                                                goto LabelTrap;

                                              if(*pc++ == &&LabelJumpIfNot)
                                                goto LabelJumpIfNot;

                                              if(*pc++ == &&LabelJumpIf)
                                                goto LabelJumpIf;

                                              if(*pc++ == &&LabelJump)
                                                goto LabelJump;

                                              if(*pc++ == &&LabelObjCall)
                                                goto LabelObjCall;

                                              if(*pc++ == &&LabelCall)
                                                goto LabelCall;

                                              if(*pc++ == &&LabelPop)
                                                goto LabelPop;

                                              if(*pc++ == &&LabelPush)
                                                goto LabelPush;

                                              if(*pc++ == &&LabelSetThis)
                                                goto LabelSetThis;

                                              if(*pc++ == &&LabelSetIndex)
                                                goto LabelSetIndex;

                                              if(*pc++ == &&LabelSetArray)
                                                goto LabelSetArray;

                                              if(*pc++ == &&LabelSetField)
                                                goto LabelSetField;

                                              if(*pc++ == &&LabelSetEnv)
                                                goto LabelSetEnv;

                                            }
                                            while(*pc++ == &&LabelSetGlobal);
                                            if(*pc++ == &&LabelSetStack)
                                              goto LabelSetStack;

                                            if(*pc++ == &&LabelAccBuiltin)
                                              goto LabelAccBuiltin;

                                            if(*pc++ == &&LabelAccIndex)
                                              goto LabelAccIndex;

                                            if(*pc++ == &&LabelAccArray)
                                              goto LabelAccArray;

                                            if(*pc++ == &&LabelAccField)
                                              goto LabelAccField;

                                            if(*pc++ == &&LabelAccEnv)
                                              goto LabelAccEnv;

                                            if(*pc++ == &&LabelAccGlobal)
                                              goto LabelAccGlobal;

                                            if(*pc++ == &&LabelAccStack)
                                              goto LabelAccStack;

                                            if(*pc++ == &&LabelAccInt)
                                              goto LabelAccInt;

                                            if(*pc++ == &&LabelAccThis)
                                              goto LabelAccThis;

                                            if(*pc++ == &&LabelAccFalse)
                                              goto LabelAccFalse;

                                            if(*pc++ == &&LabelAccTrue)
                                              goto LabelAccTrue;

                                            if(*pc++ == &&LabelAccNull)
                                              goto LabelAccNull;

                                            if(*pc++ == &&end)
                                              goto end;

                                          }


                                        LabelSetEnv:
                                          ;
                                          while((_Bool)1)
                                          {
                                            if(*pc >= (signed long int)((signed int)*((enum anonymous_7 *)vm->env) >> 4))
                                            {
                                              pc = pc + 1l;
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand_90;
                                                return_value_neko_stack_expand_90=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand_90 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string_89=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string_89);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string_91;
                                              return_value_neko_alloc_string_91=neko_alloc_string("Writing Outside Env");
                                              neko_val_throw(return_value_neko_alloc_string_91);
                                            }

                                            tmp_post_92 = pc;
                                            pc = pc + 1l;
                                            (&((struct anonymous_4 *)vm->env)->ptr)[*tmp_post_92] = (struct _value *)acc;
                                            *pc++;
                                            if(*pc++ == &&id_mod_next2)
                                              goto id_mod_next2;

                                            if(*pc++ == &&id_mod_next)
                                              goto id_mod_next;

                                            if(*pc++ == &&div_next)
                                              goto div_next;

                                            if(*pc++ == &&id_mult_next2)
                                              goto id_mult_next2;

                                            if(*pc++ == &&id_mult_next)
                                              goto id_mult_next;

                                            if(*pc++ == &&id_sub_next2)
                                              goto id_sub_next2;

                                            if(*pc++ == &&id_sub_next)
                                              goto id_sub_next;

                                            if(*pc++ == &&add_3)
                                              goto add_3;

                                            if(*pc++ == &&add_2)
                                              goto add_2;

                                            if(*pc++ == &&add_next)
                                              goto add_next;

                                            if(*pc++ == &&do_call)
                                              goto LabelCall;

                                            if(*pc++ == &&LabelLast)
                                              goto LabelLast;

                                            if(*pc++ == &&LabelAccInt32)
                                              goto LabelAccInt32;

                                            if(*pc++ == &&LabelMakeArray2)
                                              goto LabelMakeArray2;

                                            if(*pc++ == &&LabelLoop)
                                              goto LabelLoop;

                                            if(*pc++ == &&LabelTailCall)
                                              goto LabelTailCall;

                                            if(*pc++ == &&LabelPhysCompare)
                                              goto LabelPhysCompare;

                                            if(*pc++ == &&LabelAccIndex1)
                                              goto LabelAccIndex1;

                                            if(*pc++ == &&LabelAccIndex0)
                                              goto LabelAccIndex0;

                                            if(*pc++ == &&LabelAccStack1)
                                              goto LabelAccStack1;

                                            if(*pc++ == &&LabelAccStack0)
                                              goto LabelAccStack0;

                                            if(*pc++ == &&LabelApply)
                                              goto LabelApply;

                                            if(*pc++ == &&LabelJumpTable)
                                              goto LabelJumpTable;

                                            if(*pc++ == &&LabelNew)
                                              goto LabelNew;

                                            if(*pc++ == &&LabelHash)
                                              goto LabelHash;

                                            if(*pc++ == &&LabelCompare)
                                              goto LabelCompare;

                                            if(*pc++ == &&LabelTypeOf)
                                              goto LabelTypeOf;

                                            if(*pc++ == &&LabelNot)
                                              goto LabelNot;

                                            if(*pc++ == &&LabelLte)
                                              goto LabelLte;

                                            if(*pc++ == &&LabelLt)
                                              goto LabelLt;

                                            if(*pc++ == &&LabelGte)
                                              goto LabelGte;

                                            if(*pc++ == &&LabelGt)
                                              goto LabelGt;

                                            if(*pc++ == &&LabelNeq)
                                              goto LabelNeq;

                                            if(*pc++ == &&LabelEq)
                                              goto LabelEq;

                                            if(*pc++ == &&LabelXor)
                                              goto LabelXor;

                                            if(*pc++ == &&LabelAnd)
                                              goto LabelAnd;

                                            if(*pc++ == &&LabelOr)
                                              goto LabelOr;

                                            if(*pc++ == &&LabelUShr)
                                              goto LabelUShr;

                                            if(*pc++ == &&LabelShr)
                                              goto LabelShr;

                                            if(*pc++ == &&LabelShl)
                                              goto LabelShl;

                                            if(*pc++ == &&LabelMod)
                                              goto LabelMod;

                                            if(*pc++ == &&LabelDiv)
                                              goto LabelDiv;

                                            if(*pc++ == &&LabelMult)
                                              goto LabelMult;

                                            if(*pc++ == &&LabelSub)
                                              goto LabelSub;

                                            if(*pc++ == &&LabelAdd)
                                              goto LabelAdd;

                                            if(*pc++ == &&LabelIsNotNull)
                                              goto LabelIsNotNull;

                                            if(*pc++ == &&LabelIsNull)
                                              goto LabelIsNull;

                                            if(*pc++ == &&LabelBool)
                                              goto LabelBool;

                                            if(*pc++ == &&LabelMakeArray)
                                              goto LabelMakeArray;

                                            if(*pc++ == &&LabelMakeEnv)
                                              goto LabelMakeEnv;

                                            if(*pc++ == &&LabelRet)
                                              goto LabelRet;

                                            if(*pc++ == &&LabelEndTrap)
                                              goto LabelEndTrap;

                                            if(*pc++ == &&LabelTrap)
                                              goto LabelTrap;

                                            if(*pc++ == &&LabelJumpIfNot)
                                              goto LabelJumpIfNot;

                                            if(*pc++ == &&LabelJumpIf)
                                              goto LabelJumpIf;

                                            if(*pc++ == &&LabelJump)
                                              goto LabelJump;

                                            if(*pc++ == &&LabelObjCall)
                                              goto LabelObjCall;

                                            if(*pc++ == &&LabelCall)
                                              goto LabelCall;

                                            if(*pc++ == &&LabelPop)
                                              goto LabelPop;

                                            if(*pc++ == &&LabelPush)
                                              goto LabelPush;

                                            if(*pc++ == &&LabelSetThis)
                                              goto LabelSetThis;

                                            if(*pc++ == &&LabelSetIndex)
                                              goto LabelSetIndex;

                                            if(*pc++ == &&LabelSetArray)
                                              goto LabelSetArray;

                                            if(*pc++ == &&LabelSetField)
                                              goto LabelSetField;

                                            if(!(*pc++ == &&LabelSetEnv))
                                              break;

                                          }
                                          if(*pc++ == &&LabelSetGlobal)
                                            goto LabelSetGlobal;

                                          if(*pc++ == &&LabelSetStack)
                                            goto LabelSetStack;

                                          if(*pc++ == &&LabelAccBuiltin)
                                            goto LabelAccBuiltin;

                                          if(*pc++ == &&LabelAccIndex)
                                            goto LabelAccIndex;

                                          if(*pc++ == &&LabelAccArray)
                                            goto LabelAccArray;

                                          if(*pc++ == &&LabelAccField)
                                            goto LabelAccField;

                                          if(*pc++ == &&LabelAccEnv)
                                            goto LabelAccEnv;

                                          if(*pc++ == &&LabelAccGlobal)
                                            goto LabelAccGlobal;

                                          if(*pc++ == &&LabelAccStack)
                                            goto LabelAccStack;

                                          if(*pc++ == &&LabelAccInt)
                                            goto LabelAccInt;

                                          if(*pc++ == &&LabelAccThis)
                                            goto LabelAccThis;

                                          if(*pc++ == &&LabelAccFalse)
                                            goto LabelAccFalse;

                                          if(*pc++ == &&LabelAccTrue)
                                            goto LabelAccTrue;

                                          if(*pc++ == &&LabelAccNull)
                                            goto LabelAccNull;

                                          if(*pc++ == &&end)
                                            goto end;

                                        }

                                        do
                                        {

                                        LabelSetField:
                                          ;
                                          if((1 & (signed int)*sp) == 0)
                                            tmp_if_expr_99 = (signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                          else
                                            tmp_if_expr_99 = (_Bool)0;
                                          if(tmp_if_expr_99)
                                            otable_replace(&((struct _vobject *)*sp)->table, (signed int)*pc, (struct _value *)acc);

                                          else
                                          {
                                            struct _value *neko_interp_loop__1__1__1__18__v;
                                            neko_interp_loop__1__1__1__18__v=neko_val_field_name((signed int)*pc);
                                            struct _buffer *neko_interp_loop__1__1__1__18__b;
                                            if(neko_interp_loop__1__1__1__18__v == val_null)
                                            {
                                              pc = pc + 1l;
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand_94;
                                                return_value_neko_stack_expand_94=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand_94 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string_93=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string_93);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string_95;
                                              return_value_neko_alloc_string_95=neko_alloc_string("Invalid field access");
                                              neko_val_throw(return_value_neko_alloc_string_95);
                                            }

                                            neko_interp_loop__1__1__1__18__b=neko_alloc_buffer("Invalid field access : ");
                                            neko_val_buffer(neko_interp_loop__1__1__1__18__b, neko_interp_loop__1__1__1__18__v);
                                            pc = pc + 1l;
                                            if(csp + 4l >= sp)
                                            {
                                              signed int return_value_neko_stack_expand_97;
                                              return_value_neko_stack_expand_97=neko_stack_expand(sp, csp, vm);
                                              if(!(return_value_neko_stack_expand_97 == 0))
                                              {
                                                sp = vm->sp;
                                                csp = vm->csp;
                                              }

                                              else
                                              {
                                                return_value_neko_alloc_string_96=neko_alloc_string("Stack Overflow");
                                                neko_val_throw(return_value_neko_alloc_string_96);
                                              }
                                            }

                                            csp = csp + 1l;
                                            *csp = (signed long int)pc;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->env;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->vthis;
                                            csp = csp + 1l;
                                            *csp = (signed long int)m;
                                            vm->sp = sp;
                                            vm->csp = csp;
                                            struct _value *return_value_neko_buffer_to_string_98;
                                            return_value_neko_buffer_to_string_98=neko_buffer_to_string(neko_interp_loop__1__1__1__18__b);
                                            neko_val_throw(return_value_neko_buffer_to_string_98);
                                          }
                                          tmp_post_100 = sp;
                                          sp = sp + 1l;
                                          *tmp_post_100 = (signed long int)0;
                                          pc = pc + 1l;
                                          *pc++;
                                          if(*pc++ == &&id_mod_next2)
                                            goto id_mod_next2;

                                          if(*pc++ == &&id_mod_next)
                                            goto id_mod_next;

                                          if(*pc++ == &&div_next)
                                            goto div_next;

                                          if(*pc++ == &&id_mult_next2)
                                            goto id_mult_next2;

                                          if(*pc++ == &&id_mult_next)
                                            goto id_mult_next;

                                          if(*pc++ == &&id_sub_next2)
                                            goto id_sub_next2;

                                          if(*pc++ == &&id_sub_next)
                                            goto id_sub_next;

                                          if(*pc++ == &&add_3)
                                            goto add_3;

                                          if(*pc++ == &&add_2)
                                            goto add_2;

                                          if(*pc++ == &&add_next)
                                            goto add_next;

                                          if(*pc++ == &&do_call)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelLast)
                                            goto LabelLast;

                                          if(*pc++ == &&LabelAccInt32)
                                            goto LabelAccInt32;

                                          if(*pc++ == &&LabelMakeArray2)
                                            goto LabelMakeArray2;

                                          if(*pc++ == &&LabelLoop)
                                            goto LabelLoop;

                                          if(*pc++ == &&LabelTailCall)
                                            goto LabelTailCall;

                                          if(*pc++ == &&LabelPhysCompare)
                                            goto LabelPhysCompare;

                                          if(*pc++ == &&LabelAccIndex1)
                                            goto LabelAccIndex1;

                                          if(*pc++ == &&LabelAccIndex0)
                                            goto LabelAccIndex0;

                                          if(*pc++ == &&LabelAccStack1)
                                            goto LabelAccStack1;

                                          if(*pc++ == &&LabelAccStack0)
                                            goto LabelAccStack0;

                                          if(*pc++ == &&LabelApply)
                                            goto LabelApply;

                                          if(*pc++ == &&LabelJumpTable)
                                            goto LabelJumpTable;

                                          if(*pc++ == &&LabelNew)
                                            goto LabelNew;

                                          if(*pc++ == &&LabelHash)
                                            goto LabelHash;

                                          if(*pc++ == &&LabelCompare)
                                            goto LabelCompare;

                                          if(*pc++ == &&LabelTypeOf)
                                            goto LabelTypeOf;

                                          if(*pc++ == &&LabelNot)
                                            goto LabelNot;

                                          if(*pc++ == &&LabelLte)
                                            goto LabelLte;

                                          if(*pc++ == &&LabelLt)
                                            goto LabelLt;

                                          if(*pc++ == &&LabelGte)
                                            goto LabelGte;

                                          if(*pc++ == &&LabelGt)
                                            goto LabelGt;

                                          if(*pc++ == &&LabelNeq)
                                            goto LabelNeq;

                                          if(*pc++ == &&LabelEq)
                                            goto LabelEq;

                                          if(*pc++ == &&LabelXor)
                                            goto LabelXor;

                                          if(*pc++ == &&LabelAnd)
                                            goto LabelAnd;

                                          if(*pc++ == &&LabelOr)
                                            goto LabelOr;

                                          if(*pc++ == &&LabelUShr)
                                            goto LabelUShr;

                                          if(*pc++ == &&LabelShr)
                                            goto LabelShr;

                                          if(*pc++ == &&LabelShl)
                                            goto LabelShl;

                                          if(*pc++ == &&LabelMod)
                                            goto LabelMod;

                                          if(*pc++ == &&LabelDiv)
                                            goto LabelDiv;

                                          if(*pc++ == &&LabelMult)
                                            goto LabelMult;

                                          if(*pc++ == &&LabelSub)
                                            goto LabelSub;

                                          if(*pc++ == &&LabelAdd)
                                            goto LabelAdd;

                                          if(*pc++ == &&LabelIsNotNull)
                                            goto LabelIsNotNull;

                                          if(*pc++ == &&LabelIsNull)
                                            goto LabelIsNull;

                                          if(*pc++ == &&LabelBool)
                                            goto LabelBool;

                                          if(*pc++ == &&LabelMakeArray)
                                            goto LabelMakeArray;

                                          if(*pc++ == &&LabelMakeEnv)
                                            goto LabelMakeEnv;

                                          if(*pc++ == &&LabelRet)
                                            goto LabelRet;

                                          if(*pc++ == &&LabelEndTrap)
                                            goto LabelEndTrap;

                                          if(*pc++ == &&LabelTrap)
                                            goto LabelTrap;

                                          if(*pc++ == &&LabelJumpIfNot)
                                            goto LabelJumpIfNot;

                                          if(*pc++ == &&LabelJumpIf)
                                            goto LabelJumpIf;

                                          if(*pc++ == &&LabelJump)
                                            goto LabelJump;

                                          if(*pc++ == &&LabelObjCall)
                                            goto LabelObjCall;

                                          if(*pc++ == &&LabelCall)
                                            goto LabelCall;

                                          if(*pc++ == &&LabelPop)
                                            goto LabelPop;

                                          if(*pc++ == &&LabelPush)
                                            goto LabelPush;

                                          if(*pc++ == &&LabelSetThis)
                                            goto LabelSetThis;

                                          if(*pc++ == &&LabelSetIndex)
                                            goto LabelSetIndex;

                                          if(*pc++ == &&LabelSetArray)
                                            goto LabelSetArray;

                                        }
                                        while(*pc++ == &&LabelSetField);
                                        if(*pc++ == &&LabelSetEnv)
                                          goto LabelSetEnv;

                                        if(*pc++ == &&LabelSetGlobal)
                                          goto LabelSetGlobal;

                                        if(*pc++ == &&LabelSetStack)
                                          goto LabelSetStack;

                                        if(*pc++ == &&LabelAccBuiltin)
                                          goto LabelAccBuiltin;

                                        if(*pc++ == &&LabelAccIndex)
                                          goto LabelAccIndex;

                                        if(*pc++ == &&LabelAccArray)
                                          goto LabelAccArray;

                                        if(*pc++ == &&LabelAccField)
                                          goto LabelAccField;

                                        if(*pc++ == &&LabelAccEnv)
                                          goto LabelAccEnv;

                                        if(*pc++ == &&LabelAccGlobal)
                                          goto LabelAccGlobal;

                                        if(*pc++ == &&LabelAccStack)
                                          goto LabelAccStack;

                                        if(*pc++ == &&LabelAccInt)
                                          goto LabelAccInt;

                                        if(*pc++ == &&LabelAccThis)
                                          goto LabelAccThis;

                                        if(*pc++ == &&LabelAccFalse)
                                          goto LabelAccFalse;

                                        if(*pc++ == &&LabelAccTrue)
                                          goto LabelAccTrue;

                                        if(*pc++ == &&LabelAccNull)
                                          goto LabelAccNull;

                                        if(*pc++ == &&end)
                                          goto end;

                                      }

                                      do
                                      {

                                      LabelSetArray:
                                        ;
                                        if((1 & (signed int)*sp) == 0)
                                          tmp_if_expr_117 = ((signed int)*((enum anonymous_7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr_117 = (_Bool)0;
                                        if(tmp_if_expr_117)
                                          tmp_if_expr_118 = ((signed int)(signed long int)sp[(signed long int)1] & 1) != 0 ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr_118 = (_Bool)0;
                                        if(tmp_if_expr_118)
                                        {
                                          signed int neko_interp_loop__1__1__1__19__k = (signed int)(signed long int)sp[(signed long int)1] >> 1;
                                          if(neko_interp_loop__1__1__1__19__k >= 0)
                                          {
                                            if(!(neko_interp_loop__1__1__1__19__k >= (signed int)*((enum anonymous_7 *)*sp) >> 4))
                                              (&((struct anonymous_4 *)*sp)->ptr)[(signed long int)neko_interp_loop__1__1__1__19__k] = (struct _value *)acc;

                                          }

                                        }

                                        else
                                        {
                                          if((1 & (signed int)*sp) == 0)
                                            tmp_if_expr_116 = (signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                          else
                                            tmp_if_expr_116 = (_Bool)0;
                                          if(tmp_if_expr_116)
                                          {
                                            struct _value *args[2l] = { (struct _value *)sp[(signed long int)1],
    (struct _value *)acc };
                                            struct _value *neko_interp_loop__1__1__1__20__f;
                                            neko_interp_loop__1__1__1__20__f=neko_val_field((struct _value *)*sp, id_set);
                                            if(neko_interp_loop__1__1__1__20__f == val_null)
                                            {
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand_102;
                                                return_value_neko_stack_expand_102=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand_102 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string_101=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string_101);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string_103;
                                              return_value_neko_alloc_string_103=neko_alloc_string("Unsupported operation");
                                              neko_val_throw(return_value_neko_alloc_string_103);
                                            }

                                            if(csp + 4l >= sp)
                                            {
                                              signed int return_value_neko_stack_expand_105;
                                              return_value_neko_stack_expand_105=neko_stack_expand(sp, csp, vm);
                                              if(!(return_value_neko_stack_expand_105 == 0))
                                              {
                                                sp = vm->sp;
                                                csp = vm->csp;
                                              }

                                              else
                                              {
                                                return_value_neko_alloc_string_104=neko_alloc_string("Stack Overflow");
                                                neko_val_throw(return_value_neko_alloc_string_104);
                                              }
                                            }

                                            csp = csp + 1l;
                                            *csp = (signed long int)pc;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->env;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->vthis;
                                            csp = csp + 1l;
                                            *csp = (signed long int)m;
                                            vm->sp = sp;
                                            vm->csp = csp;
                                            neko_val_callEx((struct _value *)*sp, neko_interp_loop__1__1__1__20__f, args, 2, (struct _value **)(void *)0);
                                            sp = vm->sp;
                                            csp = vm->csp;
                                            m = (struct _neko_module *)*csp;
                                            tmp_post_106 = csp;
                                            csp = csp - 1l;
                                            *tmp_post_106 = (signed long int)0;
                                            vm->vthis = (struct _value *)*csp;
                                            tmp_post_107 = csp;
                                            csp = csp - 1l;
                                            *tmp_post_107 = (signed long int)0;
                                            vm->env = (struct _value *)*csp;
                                            tmp_post_108 = csp;
                                            csp = csp - 1l;
                                            *tmp_post_108 = (signed long int)0;
                                            tmp_post_109 = csp;
                                            csp = csp - 1l;
                                            *tmp_post_109 = (signed long int)0;
                                            acc = (signed long int)args[(signed long int)1];
                                          }

                                          else
                                          {
                                            if((1 & (signed int)sp[1l]) == 0)
                                              tmp_if_expr_113 = (signed int)*((enum anonymous_7 *)sp[(signed long int)1]) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

                                            else
                                              tmp_if_expr_113 = (_Bool)0;
                                            if(tmp_if_expr_113)
                                            {
                                              if((1 & (signed int)*sp) == 0)
                                                tmp_if_expr_114 = ((signed int)*((enum anonymous_7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                              else
                                                tmp_if_expr_114 = (_Bool)0;
                                              tmp_if_expr_115 = tmp_if_expr_114 ? (_Bool)1 : (_Bool)0;
                                            }

                                            else
                                              tmp_if_expr_115 = (_Bool)0;
                                            if(!tmp_if_expr_115)
                                            {
                                              if(csp + 4l >= sp)
                                              {
                                                signed int return_value_neko_stack_expand_111;
                                                return_value_neko_stack_expand_111=neko_stack_expand(sp, csp, vm);
                                                if(!(return_value_neko_stack_expand_111 == 0))
                                                {
                                                  sp = vm->sp;
                                                  csp = vm->csp;
                                                }

                                                else
                                                {
                                                  return_value_neko_alloc_string_110=neko_alloc_string("Stack Overflow");
                                                  neko_val_throw(return_value_neko_alloc_string_110);
                                                }
                                              }

                                              csp = csp + 1l;
                                              *csp = (signed long int)pc;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->env;
                                              csp = csp + 1l;
                                              *csp = (signed long int)vm->vthis;
                                              csp = csp + 1l;
                                              *csp = (signed long int)m;
                                              vm->sp = sp;
                                              vm->csp = csp;
                                              struct _value *return_value_neko_alloc_string_112;
                                              return_value_neko_alloc_string_112=neko_alloc_string("Invalid array access");
                                              neko_val_throw(return_value_neko_alloc_string_112);
                                            }

                                          }
                                        }
                                        tmp_post_119 = sp;
                                        sp = sp + 1l;
                                        *tmp_post_119 = (signed long int)0;
                                        tmp_post_120 = sp;
                                        sp = sp + 1l;
                                        *tmp_post_120 = (signed long int)0;
                                        *pc++;
                                        if(*pc++ == &&id_mod_next2)
                                          goto id_mod_next2;

                                        if(*pc++ == &&id_mod_next)
                                          goto id_mod_next;

                                        if(*pc++ == &&div_next)
                                          goto div_next;

                                        if(*pc++ == &&id_mult_next2)
                                          goto id_mult_next2;

                                        if(*pc++ == &&id_mult_next)
                                          goto id_mult_next;

                                        if(*pc++ == &&id_sub_next2)
                                          goto id_sub_next2;

                                        if(*pc++ == &&id_sub_next)
                                          goto id_sub_next;

                                        if(*pc++ == &&add_3)
                                          goto add_3;

                                        if(*pc++ == &&add_2)
                                          goto add_2;

                                        if(*pc++ == &&add_next)
                                          goto add_next;

                                        if(*pc++ == &&do_call)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelLast)
                                          goto LabelLast;

                                        if(*pc++ == &&LabelAccInt32)
                                          goto LabelAccInt32;

                                        if(*pc++ == &&LabelMakeArray2)
                                          goto LabelMakeArray2;

                                        if(*pc++ == &&LabelLoop)
                                          goto LabelLoop;

                                        if(*pc++ == &&LabelTailCall)
                                          goto LabelTailCall;

                                        if(*pc++ == &&LabelPhysCompare)
                                          goto LabelPhysCompare;

                                        if(*pc++ == &&LabelAccIndex1)
                                          goto LabelAccIndex1;

                                        if(*pc++ == &&LabelAccIndex0)
                                          goto LabelAccIndex0;

                                        if(*pc++ == &&LabelAccStack1)
                                          goto LabelAccStack1;

                                        if(*pc++ == &&LabelAccStack0)
                                          goto LabelAccStack0;

                                        if(*pc++ == &&LabelApply)
                                          goto LabelApply;

                                        if(*pc++ == &&LabelJumpTable)
                                          goto LabelJumpTable;

                                        if(*pc++ == &&LabelNew)
                                          goto LabelNew;

                                        if(*pc++ == &&LabelHash)
                                          goto LabelHash;

                                        if(*pc++ == &&LabelCompare)
                                          goto LabelCompare;

                                        if(*pc++ == &&LabelTypeOf)
                                          goto LabelTypeOf;

                                        if(*pc++ == &&LabelNot)
                                          goto LabelNot;

                                        if(*pc++ == &&LabelLte)
                                          goto LabelLte;

                                        if(*pc++ == &&LabelLt)
                                          goto LabelLt;

                                        if(*pc++ == &&LabelGte)
                                          goto LabelGte;

                                        if(*pc++ == &&LabelGt)
                                          goto LabelGt;

                                        if(*pc++ == &&LabelNeq)
                                          goto LabelNeq;

                                        if(*pc++ == &&LabelEq)
                                          goto LabelEq;

                                        if(*pc++ == &&LabelXor)
                                          goto LabelXor;

                                        if(*pc++ == &&LabelAnd)
                                          goto LabelAnd;

                                        if(*pc++ == &&LabelOr)
                                          goto LabelOr;

                                        if(*pc++ == &&LabelUShr)
                                          goto LabelUShr;

                                        if(*pc++ == &&LabelShr)
                                          goto LabelShr;

                                        if(*pc++ == &&LabelShl)
                                          goto LabelShl;

                                        if(*pc++ == &&LabelMod)
                                          goto LabelMod;

                                        if(*pc++ == &&LabelDiv)
                                          goto LabelDiv;

                                        if(*pc++ == &&LabelMult)
                                          goto LabelMult;

                                        if(*pc++ == &&LabelSub)
                                          goto LabelSub;

                                        if(*pc++ == &&LabelAdd)
                                          goto LabelAdd;

                                        if(*pc++ == &&LabelIsNotNull)
                                          goto LabelIsNotNull;

                                        if(*pc++ == &&LabelIsNull)
                                          goto LabelIsNull;

                                        if(*pc++ == &&LabelBool)
                                          goto LabelBool;

                                        if(*pc++ == &&LabelMakeArray)
                                          goto LabelMakeArray;

                                        if(*pc++ == &&LabelMakeEnv)
                                          goto LabelMakeEnv;

                                        if(*pc++ == &&LabelRet)
                                          goto LabelRet;

                                        if(*pc++ == &&LabelEndTrap)
                                          goto LabelEndTrap;

                                        if(*pc++ == &&LabelTrap)
                                          goto LabelTrap;

                                        if(*pc++ == &&LabelJumpIfNot)
                                          goto LabelJumpIfNot;

                                        if(*pc++ == &&LabelJumpIf)
                                          goto LabelJumpIf;

                                        if(*pc++ == &&LabelJump)
                                          goto LabelJump;

                                        if(*pc++ == &&LabelObjCall)
                                          goto LabelObjCall;

                                        if(*pc++ == &&LabelCall)
                                          goto LabelCall;

                                        if(*pc++ == &&LabelPop)
                                          goto LabelPop;

                                        if(*pc++ == &&LabelPush)
                                          goto LabelPush;

                                        if(*pc++ == &&LabelSetThis)
                                          goto LabelSetThis;

                                        if(*pc++ == &&LabelSetIndex)
                                          goto LabelSetIndex;

                                      }
                                      while(*pc++ == &&LabelSetArray);
                                      if(*pc++ == &&LabelSetField)
                                        goto LabelSetField;

                                      if(*pc++ == &&LabelSetEnv)
                                        goto LabelSetEnv;

                                      if(*pc++ == &&LabelSetGlobal)
                                        goto LabelSetGlobal;

                                      if(*pc++ == &&LabelSetStack)
                                        goto LabelSetStack;

                                      if(*pc++ == &&LabelAccBuiltin)
                                        goto LabelAccBuiltin;

                                      if(*pc++ == &&LabelAccIndex)
                                        goto LabelAccIndex;

                                      if(*pc++ == &&LabelAccArray)
                                        goto LabelAccArray;

                                      if(*pc++ == &&LabelAccField)
                                        goto LabelAccField;

                                      if(*pc++ == &&LabelAccEnv)
                                        goto LabelAccEnv;

                                      if(*pc++ == &&LabelAccGlobal)
                                        goto LabelAccGlobal;

                                      if(*pc++ == &&LabelAccStack)
                                        goto LabelAccStack;

                                      if(*pc++ == &&LabelAccInt)
                                        goto LabelAccInt;

                                      if(*pc++ == &&LabelAccThis)
                                        goto LabelAccThis;

                                      if(*pc++ == &&LabelAccFalse)
                                        goto LabelAccFalse;

                                      if(*pc++ == &&LabelAccTrue)
                                        goto LabelAccTrue;

                                      if(*pc++ == &&LabelAccNull)
                                        goto LabelAccNull;

                                      if(*pc++ == &&end)
                                        goto end;

                                    }

                                    do
                                    {

                                    LabelSetIndex:
                                      ;
                                      if((1 & (signed int)*sp) == 0)
                                        tmp_if_expr_134 = ((signed int)*((enum anonymous_7 *)*sp) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

                                      else
                                        tmp_if_expr_134 = (_Bool)0;
                                      if(tmp_if_expr_134)
                                      {
                                        if(*pc >= 0l)
                                        {
                                          if(!(*pc >= (signed long int)((signed int)*((enum anonymous_7 *)*sp) >> 4)))
                                            (&((struct anonymous_4 *)*sp)->ptr)[*pc] = (struct _value *)acc;

                                        }

                                      }

                                      else
                                      {
                                        if((1 & (signed int)*sp) == 0)
                                          tmp_if_expr_133 = (signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

                                        else
                                          tmp_if_expr_133 = (_Bool)0;
                                        if(tmp_if_expr_133)
                                        {
                                          struct _value *neko_interp_loop__1__1__1__24__args[2l] = { (struct _value *)(signed long int)((signed int)*pc << 1 | 1),
    (struct _value *)acc };
                                          struct _value *neko_interp_loop__1__1__1__24__f;
                                          neko_interp_loop__1__1__1__24__f=neko_val_field((struct _value *)*sp, id_set);
                                          if(neko_interp_loop__1__1__1__24__f == val_null)
                                          {
                                            pc = pc + 1l;
                                            if(csp + 4l >= sp)
                                            {
                                              signed int return_value_neko_stack_expand_122;
                                              return_value_neko_stack_expand_122=neko_stack_expand(sp, csp, vm);
                                              if(!(return_value_neko_stack_expand_122 == 0))
                                              {
                                                sp = vm->sp;
                                                csp = vm->csp;
                                              }

                                              else
                                              {
                                                return_value_neko_alloc_string_121=neko_alloc_string("Stack Overflow");
                                                neko_val_throw(return_value_neko_alloc_string_121);
                                              }
                                            }

                                            csp = csp + 1l;
                                            *csp = (signed long int)pc;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->env;
                                            csp = csp + 1l;
                                            *csp = (signed long int)vm->vthis;
                                            csp = csp + 1l;
                                            *csp = (signed long int)m;
                                            vm->sp = sp;
                                            vm->csp = csp;
                                            struct _value *return_value_neko_alloc_string_123;
                                            return_value_neko_alloc_string_123=neko_alloc_string("Unsupported operation");
                                            neko_val_throw(return_value_neko_alloc_string_123);
                                          }

                                          if(csp + 4l >= sp)
                                          {
                                            signed int return_value_neko_stack_expand_125;
                                            return_value_neko_stack_expand_125=neko_stack_expand(sp, csp, vm);
                                            if(!(return_value_neko_stack_expand_125 == 0))
                                            {
                                              sp = vm->sp;
                                              csp = vm->csp;
                                            }

                                            else
                                            {
                                              return_value_neko_alloc_string_124=neko_alloc_string("Stack Overflow");
                                              neko_val_throw(return_value_neko_alloc_string_124);
                                            }
                                          }

                                          csp = csp + 1l;
                                          *csp = (signed long int)pc;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->env;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->vthis;
                                          csp = csp + 1l;
                                          *csp = (signed long int)m;
                                          vm->sp = sp;
                                          vm->csp = csp;
                                          neko_val_callEx((struct _value *)*sp, neko_interp_loop__1__1__1__24__f, neko_interp_loop__1__1__1__24__args, 2, (struct _value **)(void *)0);
                                          sp = vm->sp;
                                          csp = vm->csp;
                                          m = (struct _neko_module *)*csp;
                                          tmp_post_126 = csp;
                                          csp = csp - 1l;
                                          *tmp_post_126 = (signed long int)0;
                                          vm->vthis = (struct _value *)*csp;
                                          tmp_post_127 = csp;
                                          csp = csp - 1l;
                                          *tmp_post_127 = (signed long int)0;
                                          vm->env = (struct _value *)*csp;
                                          tmp_post_128 = csp;
                                          csp = csp - 1l;
                                          *tmp_post_128 = (signed long int)0;
                                          tmp_post_129 = csp;
                                          csp = csp - 1l;
                                          *tmp_post_129 = (signed long int)0;
                                          acc = (signed long int)neko_interp_loop__1__1__1__24__args[(signed long int)1];
                                        }

                                        else
                                        {
                                          pc = pc + 1l;
                                          if(csp + 4l >= sp)
                                          {
                                            signed int return_value_neko_stack_expand_131;
                                            return_value_neko_stack_expand_131=neko_stack_expand(sp, csp, vm);
                                            if(!(return_value_neko_stack_expand_131 == 0))
                                            {
                                              sp = vm->sp;
                                              csp = vm->csp;
                                            }

                                            else
                                            {
                                              return_value_neko_alloc_string_130=neko_alloc_string("Stack Overflow");
                                              neko_val_throw(return_value_neko_alloc_string_130);
                                            }
                                          }

                                          csp = csp + 1l;
                                          *csp = (signed long int)pc;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->env;
                                          csp = csp + 1l;
                                          *csp = (signed long int)vm->vthis;
                                          csp = csp + 1l;
                                          *csp = (signed long int)m;
                                          vm->sp = sp;
                                          vm->csp = csp;
                                          struct _value *return_value_neko_alloc_string_132;
                                          return_value_neko_alloc_string_132=neko_alloc_string("Invalid array access");
                                          neko_val_throw(return_value_neko_alloc_string_132);
                                        }
                                      }
                                      pc = pc + 1l;
                                      tmp_post_135 = sp;
                                      sp = sp + 1l;
                                      *tmp_post_135 = (signed long int)0;
                                      *pc++;
                                      if(*pc++ == &&id_mod_next2)
                                        goto id_mod_next2;

                                      if(*pc++ == &&id_mod_next)
                                        goto id_mod_next;

                                      if(*pc++ == &&div_next)
                                        goto div_next;

                                      if(*pc++ == &&id_mult_next2)
                                        goto id_mult_next2;

                                      if(*pc++ == &&id_mult_next)
                                        goto id_mult_next;

                                      if(*pc++ == &&id_sub_next2)
                                        goto id_sub_next2;

                                      if(*pc++ == &&id_sub_next)
                                        goto id_sub_next;

                                      if(*pc++ == &&add_3)
                                        goto add_3;

                                      if(*pc++ == &&add_2)
                                        goto add_2;

                                      if(*pc++ == &&add_next)
                                        goto add_next;

                                      if(*pc++ == &&do_call)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelLast)
                                        goto LabelLast;

                                      if(*pc++ == &&LabelAccInt32)
                                        goto LabelAccInt32;

                                      if(*pc++ == &&LabelMakeArray2)
                                        goto LabelMakeArray2;

                                      if(*pc++ == &&LabelLoop)
                                        goto LabelLoop;

                                      if(*pc++ == &&LabelTailCall)
                                        goto LabelTailCall;

                                      if(*pc++ == &&LabelPhysCompare)
                                        goto LabelPhysCompare;

                                      if(*pc++ == &&LabelAccIndex1)
                                        goto LabelAccIndex1;

                                      if(*pc++ == &&LabelAccIndex0)
                                        goto LabelAccIndex0;

                                      if(*pc++ == &&LabelAccStack1)
                                        goto LabelAccStack1;

                                      if(*pc++ == &&LabelAccStack0)
                                        goto LabelAccStack0;

                                      if(*pc++ == &&LabelApply)
                                        goto LabelApply;

                                      if(*pc++ == &&LabelJumpTable)
                                        goto LabelJumpTable;

                                      if(*pc++ == &&LabelNew)
                                        goto LabelNew;

                                      if(*pc++ == &&LabelHash)
                                        goto LabelHash;

                                      if(*pc++ == &&LabelCompare)
                                        goto LabelCompare;

                                      if(*pc++ == &&LabelTypeOf)
                                        goto LabelTypeOf;

                                      if(*pc++ == &&LabelNot)
                                        goto LabelNot;

                                      if(*pc++ == &&LabelLte)
                                        goto LabelLte;

                                      if(*pc++ == &&LabelLt)
                                        goto LabelLt;

                                      if(*pc++ == &&LabelGte)
                                        goto LabelGte;

                                      if(*pc++ == &&LabelGt)
                                        goto LabelGt;

                                      if(*pc++ == &&LabelNeq)
                                        goto LabelNeq;

                                      if(*pc++ == &&LabelEq)
                                        goto LabelEq;

                                      if(*pc++ == &&LabelXor)
                                        goto LabelXor;

                                      if(*pc++ == &&LabelAnd)
                                        goto LabelAnd;

                                      if(*pc++ == &&LabelOr)
                                        goto LabelOr;

                                      if(*pc++ == &&LabelUShr)
                                        goto LabelUShr;

                                      if(*pc++ == &&LabelShr)
                                        goto LabelShr;

                                      if(*pc++ == &&LabelShl)
                                        goto LabelShl;

                                      if(*pc++ == &&LabelMod)
                                        goto LabelMod;

                                      if(*pc++ == &&LabelDiv)
                                        goto LabelDiv;

                                      if(*pc++ == &&LabelMult)
                                        goto LabelMult;

                                      if(*pc++ == &&LabelSub)
                                        goto LabelSub;

                                      if(*pc++ == &&LabelAdd)
                                        goto LabelAdd;

                                      if(*pc++ == &&LabelIsNotNull)
                                        goto LabelIsNotNull;

                                      if(*pc++ == &&LabelIsNull)
                                        goto LabelIsNull;

                                      if(*pc++ == &&LabelBool)
                                        goto LabelBool;

                                      if(*pc++ == &&LabelMakeArray)
                                        goto LabelMakeArray;

                                      if(*pc++ == &&LabelMakeEnv)
                                        goto LabelMakeEnv;

                                      if(*pc++ == &&LabelRet)
                                        goto LabelRet;

                                      if(*pc++ == &&LabelEndTrap)
                                        goto LabelEndTrap;

                                      if(*pc++ == &&LabelTrap)
                                        goto LabelTrap;

                                      if(*pc++ == &&LabelJumpIfNot)
                                        goto LabelJumpIfNot;

                                      if(*pc++ == &&LabelJumpIf)
                                        goto LabelJumpIf;

                                      if(*pc++ == &&LabelJump)
                                        goto LabelJump;

                                      if(*pc++ == &&LabelObjCall)
                                        goto LabelObjCall;

                                      if(*pc++ == &&LabelCall)
                                        goto LabelCall;

                                      if(*pc++ == &&LabelPop)
                                        goto LabelPop;

                                      if(*pc++ == &&LabelPush)
                                        goto LabelPush;

                                      if(*pc++ == &&LabelSetThis)
                                        goto LabelSetThis;

                                    }
                                    while(*pc++ == &&LabelSetIndex);
                                    if(*pc++ == &&LabelSetArray)
                                      goto LabelSetArray;

                                    if(*pc++ == &&LabelSetField)
                                      goto LabelSetField;

                                    if(*pc++ == &&LabelSetEnv)
                                      goto LabelSetEnv;

                                    if(*pc++ == &&LabelSetGlobal)
                                      goto LabelSetGlobal;

                                    if(*pc++ == &&LabelSetStack)
                                      goto LabelSetStack;

                                    if(*pc++ == &&LabelAccBuiltin)
                                      goto LabelAccBuiltin;

                                    if(*pc++ == &&LabelAccIndex)
                                      goto LabelAccIndex;

                                    if(*pc++ == &&LabelAccArray)
                                      goto LabelAccArray;

                                    if(*pc++ == &&LabelAccField)
                                      goto LabelAccField;

                                    if(*pc++ == &&LabelAccEnv)
                                      goto LabelAccEnv;

                                    if(*pc++ == &&LabelAccGlobal)
                                      goto LabelAccGlobal;

                                    if(*pc++ == &&LabelAccStack)
                                      goto LabelAccStack;

                                    if(*pc++ == &&LabelAccInt)
                                      goto LabelAccInt;

                                    if(*pc++ == &&LabelAccThis)
                                      goto LabelAccThis;

                                    if(*pc++ == &&LabelAccFalse)
                                      goto LabelAccFalse;

                                    if(*pc++ == &&LabelAccTrue)
                                      goto LabelAccTrue;

                                    if(*pc++ == &&LabelAccNull)
                                      goto LabelAccNull;

                                    if(*pc++ == &&end)
                                      goto end;

                                  }

                                  do
                                  {

                                  LabelSetThis:
                                    ;
                                    vm->vthis = (struct _value *)acc;
                                    *pc++;
                                    if(*pc++ == &&id_mod_next2)
                                      goto id_mod_next2;

                                    if(*pc++ == &&id_mod_next)
                                      goto id_mod_next;

                                    if(*pc++ == &&div_next)
                                      goto div_next;

                                    if(*pc++ == &&id_mult_next2)
                                      goto id_mult_next2;

                                    if(*pc++ == &&id_mult_next)
                                      goto id_mult_next;

                                    if(*pc++ == &&id_sub_next2)
                                      goto id_sub_next2;

                                    if(*pc++ == &&id_sub_next)
                                      goto id_sub_next;

                                    if(*pc++ == &&add_3)
                                      goto add_3;

                                    if(*pc++ == &&add_2)
                                      goto add_2;

                                    if(*pc++ == &&add_next)
                                      goto add_next;

                                    if(*pc++ == &&do_call)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelLast)
                                      goto LabelLast;

                                    if(*pc++ == &&LabelAccInt32)
                                      goto LabelAccInt32;

                                    if(*pc++ == &&LabelMakeArray2)
                                      goto LabelMakeArray2;

                                    if(*pc++ == &&LabelLoop)
                                      goto LabelLoop;

                                    if(*pc++ == &&LabelTailCall)
                                      goto LabelTailCall;

                                    if(*pc++ == &&LabelPhysCompare)
                                      goto LabelPhysCompare;

                                    if(*pc++ == &&LabelAccIndex1)
                                      goto LabelAccIndex1;

                                    if(*pc++ == &&LabelAccIndex0)
                                      goto LabelAccIndex0;

                                    if(*pc++ == &&LabelAccStack1)
                                      goto LabelAccStack1;

                                    if(*pc++ == &&LabelAccStack0)
                                      goto LabelAccStack0;

                                    if(*pc++ == &&LabelApply)
                                      goto LabelApply;

                                    if(*pc++ == &&LabelJumpTable)
                                      goto LabelJumpTable;

                                    if(*pc++ == &&LabelNew)
                                      goto LabelNew;

                                    if(*pc++ == &&LabelHash)
                                      goto LabelHash;

                                    if(*pc++ == &&LabelCompare)
                                      goto LabelCompare;

                                    if(*pc++ == &&LabelTypeOf)
                                      goto LabelTypeOf;

                                    if(*pc++ == &&LabelNot)
                                      goto LabelNot;

                                    if(*pc++ == &&LabelLte)
                                      goto LabelLte;

                                    if(*pc++ == &&LabelLt)
                                      goto LabelLt;

                                    if(*pc++ == &&LabelGte)
                                      goto LabelGte;

                                    if(*pc++ == &&LabelGt)
                                      goto LabelGt;

                                    if(*pc++ == &&LabelNeq)
                                      goto LabelNeq;

                                    if(*pc++ == &&LabelEq)
                                      goto LabelEq;

                                    if(*pc++ == &&LabelXor)
                                      goto LabelXor;

                                    if(*pc++ == &&LabelAnd)
                                      goto LabelAnd;

                                    if(*pc++ == &&LabelOr)
                                      goto LabelOr;

                                    if(*pc++ == &&LabelUShr)
                                      goto LabelUShr;

                                    if(*pc++ == &&LabelShr)
                                      goto LabelShr;

                                    if(*pc++ == &&LabelShl)
                                      goto LabelShl;

                                    if(*pc++ == &&LabelMod)
                                      goto LabelMod;

                                    if(*pc++ == &&LabelDiv)
                                      goto LabelDiv;

                                    if(*pc++ == &&LabelMult)
                                      goto LabelMult;

                                    if(*pc++ == &&LabelSub)
                                      goto LabelSub;

                                    if(*pc++ == &&LabelAdd)
                                      goto LabelAdd;

                                    if(*pc++ == &&LabelIsNotNull)
                                      goto LabelIsNotNull;

                                    if(*pc++ == &&LabelIsNull)
                                      goto LabelIsNull;

                                    if(*pc++ == &&LabelBool)
                                      goto LabelBool;

                                    if(*pc++ == &&LabelMakeArray)
                                      goto LabelMakeArray;

                                    if(*pc++ == &&LabelMakeEnv)
                                      goto LabelMakeEnv;

                                    if(*pc++ == &&LabelRet)
                                      goto LabelRet;

                                    if(*pc++ == &&LabelEndTrap)
                                      goto LabelEndTrap;

                                    if(*pc++ == &&LabelTrap)
                                      goto LabelTrap;

                                    if(*pc++ == &&LabelJumpIfNot)
                                      goto LabelJumpIfNot;

                                    if(*pc++ == &&LabelJumpIf)
                                      goto LabelJumpIf;

                                    if(*pc++ == &&LabelJump)
                                      goto LabelJump;

                                    if(*pc++ == &&LabelObjCall)
                                      goto LabelObjCall;

                                    if(*pc++ == &&LabelCall)
                                      goto LabelCall;

                                    if(*pc++ == &&LabelPop)
                                      goto LabelPop;

                                    if(*pc++ == &&LabelPush)
                                      goto LabelPush;

                                  }
                                  while(*pc++ == &&LabelSetThis);
                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelPush:
                                  ;
                                  sp = sp - 1l;
                                  if(csp >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_137;
                                    return_value_neko_stack_expand_137=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_137 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_136=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_136);
                                    }
                                  }

                                  *sp = acc;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                  if(*pc++ == &&LabelShl)
                                    goto LabelShl;

                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                }
                                while(*pc++ == &&LabelPush);
                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(*pc++ == &&LabelAccArray)
                                  goto LabelAccArray;

                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                                if(*pc++ == &&LabelAccThis)
                                  goto LabelAccThis;

                                if(*pc++ == &&LabelAccFalse)
                                  goto LabelAccFalse;

                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelPop:
                                ;
                                signed int tmp;
                                tmp_post_138 = pc;
                                pc = pc + 1l;
                                tmp = (signed int)*tmp_post_138;
                                do
                                {
                                  tmp_post_139 = tmp;
                                  tmp = tmp - 1;
                                  if(!(tmp_post_139 >= 1))
                                    break;

                                  tmp_post_140 = sp;
                                  sp = sp + 1l;
                                  *tmp_post_140 = (signed long int)0;
                                }
                                while((_Bool)1);
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                                if(*pc++ == &&LabelAccIndex0)
                                  goto LabelAccIndex0;

                                if(*pc++ == &&LabelAccStack1)
                                  goto LabelAccStack1;

                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                                if(*pc++ == &&LabelShr)
                                  goto LabelShr;

                                if(*pc++ == &&LabelShl)
                                  goto LabelShl;

                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                              }
                              while(*pc++ == &&LabelPop);
                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelApply:
                              ;
                              if((1 & (signed int)acc) == 0)
                                tmp_if_expr_144 = ((signed int)*((enum anonymous_7 *)acc) & (1 << 4) - 1) == VAL_FUNCTION ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr_144 = (_Bool)0;
                              if(!tmp_if_expr_144)
                              {
                                pc = pc + 1l;
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand_142;
                                  return_value_neko_stack_expand_142=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand_142 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string_141=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string_141);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                vm->sp = sp;
                                vm->csp = csp;
                                struct _value *return_value_neko_alloc_string_143;
                                return_value_neko_alloc_string_143=neko_alloc_string("_apply");
                                neko_val_throw(return_value_neko_alloc_string_143);
                              }

                              signed int fargs = ((struct anonymous_8 *)acc)->nargs;
                              if(fargs == -1 || (signed long int)fargs == *pc)
                                goto LabelCall;

                              if(!((signed long int)fargs >= *pc))
                              {
                                pc = pc + 1l;
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand_146;
                                  return_value_neko_stack_expand_146=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand_146 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string_145=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string_145);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                vm->sp = sp;
                                vm->csp = csp;
                                struct _value *return_value_neko_alloc_string_147;
                                return_value_neko_alloc_string_147=neko_alloc_string("_apply");
                                neko_val_throw(return_value_neko_alloc_string_147);
                              }

                              signed int i = fargs;
                              struct _value *env;
                              env=neko_alloc_array((unsigned int)(fargs + 1));
                              (&((struct anonymous_4 *)env)->ptr)[(signed long int)0] = (struct _value *)acc;
                              for( ; !(*pc >= (signed long int)i); (&((struct anonymous_4 *)env)->ptr)[(signed long int)tmp_post_148] = val_null)
                              {
                                tmp_post_148 = i;
                                i = i - 1;
                              }
                              for( ; !(i == 0); *tmp_post_150 = (signed long int)0)
                              {
                                tmp_post_149 = i;
                                i = i - 1;
                                (&((struct anonymous_4 *)env)->ptr)[(signed long int)tmp_post_149] = (struct _value *)*sp;
                                tmp_post_150 = sp;
                                sp = sp + 1l;
                              }
                              tmp_post_151 = pc;
                              pc = pc + 1l;
                              struct _value *return_value_neko_alloc_apply_152;
                              return_value_neko_alloc_apply_152=neko_alloc_apply((signed int)((signed long int)fargs - *tmp_post_151), env);
                              acc = (signed long int)return_value_neko_alloc_apply_152;
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                            }
                            while(*pc++ == &&LabelApply);
                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelTailCall:
                            ;
                            signed int neko_interp_loop__1__1__1__30__stack = (signed int)(*pc >> 3);
                            signed int nargs = (signed int)(*pc & (signed long int)7);
                            signed int neko_interp_loop__1__1__1__30__i = nargs;
                            struct _value *cur_this = vm->vthis;
                            neko_interp_loop__1__1__1__30__stack = neko_interp_loop__1__1__1__30__stack - nargs;
                            sp = sp + (signed long int)nargs;
                            for( ; neko_interp_loop__1__1__1__30__i >= 1; neko_interp_loop__1__1__1__30__i = neko_interp_loop__1__1__1__30__i - 1)
                            {
                              sp = sp - 1l;
                              sp[(signed long int)neko_interp_loop__1__1__1__30__stack] = *sp;
                            }
                            do
                            {
                              tmp_post_153 = neko_interp_loop__1__1__1__30__stack;
                              neko_interp_loop__1__1__1__30__stack = neko_interp_loop__1__1__1__30__stack - 1;
                              if(!(tmp_post_153 >= 1))
                                break;

                              tmp_post_154 = sp;
                              sp = sp + 1l;
                              *tmp_post_154 = (signed long int)0;
                            }
                            while((_Bool)1);
                            m = (struct _neko_module *)*csp;
                            tmp_post_155 = csp;
                            csp = csp - 1l;
                            *tmp_post_155 = (signed long int)0;
                            vm->vthis = (struct _value *)*csp;
                            tmp_post_156 = csp;
                            csp = csp - 1l;
                            *tmp_post_156 = (signed long int)0;
                            vm->env = (struct _value *)*csp;
                            tmp_post_157 = csp;
                            csp = csp - 1l;
                            *tmp_post_157 = (signed long int)0;
                            pc = (signed long int *)*csp;
                            tmp_post_158 = csp;
                            csp = csp - 1l;
                            *tmp_post_158 = (signed long int)0;
                            if(!((1l & acc) == 0l))
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_160;
                                return_value_neko_stack_expand_160=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_160 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_159=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_159);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string_161;
                              return_value_neko_alloc_string_161=neko_alloc_string("Invalid call");
                              neko_val_throw(return_value_neko_alloc_string_161);
                            }

                            else
                            {
                              if((signed int)*((enum anonymous_7 *)acc) == VAL_FUNCTION)
                                tmp_if_expr_193 = nargs == ((struct anonymous_8 *)acc)->nargs ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr_193 = (_Bool)0;
                              if(tmp_if_expr_193)
                              {
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand_163;
                                  return_value_neko_stack_expand_163=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand_163 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string_162=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string_162);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                m = (struct _neko_module *)((struct anonymous_8 *)acc)->module;
                                pc = (signed long int *)((struct anonymous_8 *)acc)->addr;
                                vm->vthis = cur_this;
                                vm->env = ((struct anonymous_8 *)acc)->env;
                              }

                              else
                                if((signed int)*((enum anonymous_7 *)acc) == VAL_PRIMITIVE)
                                {
                                  if(nargs == ((struct anonymous_8 *)acc)->nargs)
                                  {
                                    struct anonymous_8 *neko_interp_loop__1__1__1__30__4__1__f = (struct anonymous_8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_165;
                                      return_value_neko_stack_expand_165=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_165 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_164=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_164);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = cur_this;
                                    vm->env = ((struct anonymous_8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    switch(nargs)
                                    {
                                      case 0:
                                        acc=((signed long int (*)())((struct anonymous_8 *)acc)->addr)();
                                      case 1:
                                        acc=((signed long int (*)(signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)0]);
                                      case 2:
                                        acc=((signed long int (*)(signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)1], sp[(signed long int)0]);
                                      case 3:
                                        acc=((signed long int (*)(signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                      case 4:
                                        acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                      case 5:
                                        acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)4], sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    }
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop__1__1__1__30__4__1__f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_166 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_166 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_167 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_167 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_168 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_168 = (signed long int)0;
                                    tmp_post_169 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_169 = (signed long int)0;
                                  }

                                  else
                                    if(((struct anonymous_8 *)acc)->nargs == -1)
                                    {
                                      signed long int neko_interp_loop__1__1__1__30__4__2__args[5l];
                                      signed long int neko_interp_loop__1__1__1__30__4__2__tmp;
                                      struct anonymous_8 *neko_interp_loop__1__1__1__30__4__2__f = (struct anonymous_8 *)acc;
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_171;
                                        return_value_neko_stack_expand_171=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_171 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_170=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_170);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->vthis = cur_this;
                                      vm->env = ((struct anonymous_8 *)acc)->env;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      sp = sp + (signed long int)nargs;
                                      neko_interp_loop__1__1__1__30__4__2__tmp = (signed long int)0;
                                      for( ; !(neko_interp_loop__1__1__1__30__4__2__tmp >= (signed long int)nargs); neko_interp_loop__1__1__1__30__4__2__tmp = neko_interp_loop__1__1__1__30__4__2__tmp + 1l)
                                      {
                                        sp = sp - 1l;
                                        neko_interp_loop__1__1__1__30__4__2__args[neko_interp_loop__1__1__1__30__4__2__tmp] = *sp;
                                      }
                                      acc=((signed long int (*)(struct _value **, signed int))((struct anonymous_8 *)acc)->addr)((struct _value **)(void *)neko_interp_loop__1__1__1__30__4__2__args, (signed int)nargs);
                                      if(acc == 0l)
                                        neko_val_throw((struct _value *)neko_interp_loop__1__1__1__30__4__2__f->module);

                                      sp = vm->sp;
                                      csp = vm->csp;
                                      m = (struct _neko_module *)*csp;
                                      tmp_post_172 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_172 = (signed long int)0;
                                      vm->vthis = (struct _value *)*csp;
                                      tmp_post_173 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_173 = (signed long int)0;
                                      vm->env = (struct _value *)*csp;
                                      tmp_post_174 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_174 = (signed long int)0;
                                      tmp_post_175 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_175 = (signed long int)0;
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_177;
                                        return_value_neko_stack_expand_177=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_177 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_176=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_176);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string_178;
                                      return_value_neko_alloc_string_178=neko_alloc_string("Invalid call");
                                      neko_val_throw(return_value_neko_alloc_string_178);
                                    }
                                  signed int neko_interp_loop__1__1__1__30__4__4__tmp = (signed int)nargs;
                                  do
                                  {
                                    tmp_post_179 = neko_interp_loop__1__1__1__30__4__4__tmp;
                                    neko_interp_loop__1__1__1__30__4__4__tmp = neko_interp_loop__1__1__1__30__4__4__tmp - 1;
                                    if(!(tmp_post_179 >= 1))
                                      break;

                                    tmp_post_180 = sp;
                                    sp = sp + 1l;
                                    *tmp_post_180 = (signed long int)0;
                                  }
                                  while((_Bool)1);
                                }

                                else
                                  if((signed int)*((enum anonymous_7 *)acc) == VAL_JITFUN)
                                  {
                                    if(nargs == ((struct anonymous_8 *)acc)->nargs)
                                    {
                                      struct anonymous_8 *neko_interp_loop__1__1__1__30__5__1__f = (struct anonymous_8 *)acc;
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_182;
                                        return_value_neko_stack_expand_182=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_182 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_181=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_181);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->vthis = cur_this;
                                      vm->env = ((struct anonymous_8 *)acc)->env;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      acc=jit_run(vm, (struct anonymous_8 *)acc);
                                      if(acc == 0l)
                                        neko_val_throw((struct _value *)neko_interp_loop__1__1__1__30__5__1__f->module);

                                      sp = vm->sp;
                                      csp = vm->csp;
                                      m = (struct _neko_module *)*csp;
                                      tmp_post_183 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_183 = (signed long int)0;
                                      vm->vthis = (struct _value *)*csp;
                                      tmp_post_184 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_184 = (signed long int)0;
                                      vm->env = (struct _value *)*csp;
                                      tmp_post_185 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_185 = (signed long int)0;
                                      tmp_post_186 = csp;
                                      csp = csp - 1l;
                                      *tmp_post_186 = (signed long int)0;
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_188;
                                        return_value_neko_stack_expand_188=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_188 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_187=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_187);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string_189;
                                      return_value_neko_alloc_string_189=neko_alloc_string("Invalid call");
                                      neko_val_throw(return_value_neko_alloc_string_189);
                                    }
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_191;
                                      return_value_neko_stack_expand_191=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_191 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_190=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_190);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_192;
                                    return_value_neko_alloc_string_192=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string_192);
                                  }
                            }
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                          }
                          while(*pc++ == &&LabelTailCall);
                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(!(*pc++ == &&LabelCall))
                          {
                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                        }

                        do
                        {

                        LabelCall:

                          do_call:
                            ;
                          pc = pc + 1l;
                          if(!((1l & acc) == 0l))
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand_195;
                              return_value_neko_stack_expand_195=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand_195 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string_194=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string_194);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string_196;
                            return_value_neko_alloc_string_196=neko_alloc_string("Invalid call");
                            neko_val_throw(return_value_neko_alloc_string_196);
                          }

                          else
                          {
                            if((signed int)*((enum anonymous_7 *)acc) == VAL_FUNCTION)
                              tmp_if_expr_228 = pc[(signed long int)-1] == (signed long int)((struct anonymous_8 *)acc)->nargs ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr_228 = (_Bool)0;
                            if(tmp_if_expr_228)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_198;
                                return_value_neko_stack_expand_198=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_198 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_197=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_197);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              m = (struct _neko_module *)((struct anonymous_8 *)acc)->module;
                              pc = (signed long int *)((struct anonymous_8 *)acc)->addr;
                              vm->vthis = vm->vthis;
                              vm->env = ((struct anonymous_8 *)acc)->env;
                            }

                            else
                              if((signed int)*((enum anonymous_7 *)acc) == VAL_PRIMITIVE)
                              {
                                if(pc[-1l] == (signed long int)((struct anonymous_8 *)acc)->nargs)
                                {
                                  struct anonymous_8 *neko_interp_loop__1__1__1__33__1__f = (struct anonymous_8 *)acc;
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_200;
                                    return_value_neko_stack_expand_200=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_200 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_199=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_199);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->vthis = vm->vthis;
                                  vm->env = ((struct anonymous_8 *)acc)->env;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  switch(pc[(signed long int)-1])
                                  {
                                    case (signed long int)0:
                                      acc=((signed long int (*)())((struct anonymous_8 *)acc)->addr)();
                                    case (signed long int)1:
                                      acc=((signed long int (*)(signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)0]);
                                    case (signed long int)2:
                                      acc=((signed long int (*)(signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)3:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)4:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)5:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)4], sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                  }
                                  if(acc == 0l)
                                    neko_val_throw((struct _value *)neko_interp_loop__1__1__1__33__1__f->module);

                                  sp = vm->sp;
                                  csp = vm->csp;
                                  m = (struct _neko_module *)*csp;
                                  tmp_post_201 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_201 = (signed long int)0;
                                  vm->vthis = (struct _value *)*csp;
                                  tmp_post_202 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_202 = (signed long int)0;
                                  vm->env = (struct _value *)*csp;
                                  tmp_post_203 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_203 = (signed long int)0;
                                  tmp_post_204 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_204 = (signed long int)0;
                                }

                                else
                                  if(((struct anonymous_8 *)acc)->nargs == -1)
                                  {
                                    signed long int neko_interp_loop__1__1__1__33__2__args[5l];
                                    signed long int neko_interp_loop__1__1__1__33__2__tmp;
                                    struct anonymous_8 *neko_interp_loop__1__1__1__33__2__f = (struct anonymous_8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_206;
                                      return_value_neko_stack_expand_206=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_206 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_205=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_205);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vm->vthis;
                                    vm->env = ((struct anonymous_8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    sp = sp + pc[(signed long int)-1];
                                    neko_interp_loop__1__1__1__33__2__tmp = (signed long int)0;
                                    for( ; !(neko_interp_loop__1__1__1__33__2__tmp >= pc[-1l]); neko_interp_loop__1__1__1__33__2__tmp = neko_interp_loop__1__1__1__33__2__tmp + 1l)
                                    {
                                      sp = sp - 1l;
                                      neko_interp_loop__1__1__1__33__2__args[neko_interp_loop__1__1__1__33__2__tmp] = *sp;
                                    }
                                    acc=((signed long int (*)(struct _value **, signed int))((struct anonymous_8 *)acc)->addr)((struct _value **)(void *)neko_interp_loop__1__1__1__33__2__args, (signed int)pc[(signed long int)-1]);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop__1__1__1__33__2__f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_207 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_207 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_208 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_208 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_209 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_209 = (signed long int)0;
                                    tmp_post_210 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_210 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_212;
                                      return_value_neko_stack_expand_212=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_212 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_211=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_211);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_213;
                                    return_value_neko_alloc_string_213=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string_213);
                                  }
                                signed int neko_interp_loop__1__1__1__33__4__tmp = (signed int)pc[(signed long int)-1];
                                do
                                {
                                  tmp_post_214 = neko_interp_loop__1__1__1__33__4__tmp;
                                  neko_interp_loop__1__1__1__33__4__tmp = neko_interp_loop__1__1__1__33__4__tmp - 1;
                                  if(!(tmp_post_214 >= 1))
                                    break;

                                  tmp_post_215 = sp;
                                  sp = sp + 1l;
                                  *tmp_post_215 = (signed long int)0;
                                }
                                while((_Bool)1);
                              }

                              else
                                if((signed int)*((enum anonymous_7 *)acc) == VAL_JITFUN)
                                {
                                  if(pc[-1l] == (signed long int)((struct anonymous_8 *)acc)->nargs)
                                  {
                                    struct anonymous_8 *neko_interp_loop__1__1__1__34__1__f = (struct anonymous_8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_217;
                                      return_value_neko_stack_expand_217=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_217 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_216=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_216);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vm->vthis;
                                    vm->env = ((struct anonymous_8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    acc=jit_run(vm, (struct anonymous_8 *)acc);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop__1__1__1__34__1__f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_218 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_218 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_219 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_219 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_220 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_220 = (signed long int)0;
                                    tmp_post_221 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_221 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_223;
                                      return_value_neko_stack_expand_223=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_223 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_222=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_222);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_224;
                                    return_value_neko_alloc_string_224=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string_224);
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_226;
                                    return_value_neko_stack_expand_226=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_226 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_225=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_225);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string_227;
                                  return_value_neko_alloc_string_227=neko_alloc_string("Invalid call");
                                  neko_val_throw(return_value_neko_alloc_string_227);
                                }
                          }
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                        }
                        while(*pc++ == &&LabelCall);
                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelObjCall:
                          ;
                          struct _value *vtmp = (struct _value *)*sp;
                          tmp_post_229 = sp;
                          sp = sp + 1l;
                          *tmp_post_229 = (signed long int)0;
                          pc = pc + 1l;
                          if(!((1l & acc) == 0l))
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand_231;
                              return_value_neko_stack_expand_231=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand_231 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string_230=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string_230);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string_232;
                            return_value_neko_alloc_string_232=neko_alloc_string("Invalid call");
                            neko_val_throw(return_value_neko_alloc_string_232);
                          }

                          else
                          {
                            if((signed int)*((enum anonymous_7 *)acc) == VAL_FUNCTION)
                              tmp_if_expr_264 = pc[(signed long int)-1] == (signed long int)((struct anonymous_8 *)acc)->nargs ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr_264 = (_Bool)0;
                            if(tmp_if_expr_264)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_234;
                                return_value_neko_stack_expand_234=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_234 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_233=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_233);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              m = (struct _neko_module *)((struct anonymous_8 *)acc)->module;
                              pc = (signed long int *)((struct anonymous_8 *)acc)->addr;
                              vm->vthis = vtmp;
                              vm->env = ((struct anonymous_8 *)acc)->env;
                            }

                            else
                              if((signed int)*((enum anonymous_7 *)acc) == VAL_PRIMITIVE)
                              {
                                if(pc[-1l] == (signed long int)((struct anonymous_8 *)acc)->nargs)
                                {
                                  struct anonymous_8 *neko_interp_loop__1__1__1__36__3__1__f = (struct anonymous_8 *)acc;
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_236;
                                    return_value_neko_stack_expand_236=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_236 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_235=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_235);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->vthis = vtmp;
                                  vm->env = ((struct anonymous_8 *)acc)->env;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  switch(pc[(signed long int)-1])
                                  {
                                    case (signed long int)0:
                                      acc=((signed long int (*)())((struct anonymous_8 *)acc)->addr)();
                                    case (signed long int)1:
                                      acc=((signed long int (*)(signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)0]);
                                    case (signed long int)2:
                                      acc=((signed long int (*)(signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)3:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)4:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                    case (signed long int)5:
                                      acc=((signed long int (*)(signed long int, signed long int, signed long int, signed long int, signed long int))((struct anonymous_8 *)acc)->addr)(sp[(signed long int)4], sp[(signed long int)3], sp[(signed long int)2], sp[(signed long int)1], sp[(signed long int)0]);
                                  }
                                  if(acc == 0l)
                                    neko_val_throw((struct _value *)neko_interp_loop__1__1__1__36__3__1__f->module);

                                  sp = vm->sp;
                                  csp = vm->csp;
                                  m = (struct _neko_module *)*csp;
                                  tmp_post_237 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_237 = (signed long int)0;
                                  vm->vthis = (struct _value *)*csp;
                                  tmp_post_238 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_238 = (signed long int)0;
                                  vm->env = (struct _value *)*csp;
                                  tmp_post_239 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_239 = (signed long int)0;
                                  tmp_post_240 = csp;
                                  csp = csp - 1l;
                                  *tmp_post_240 = (signed long int)0;
                                }

                                else
                                  if(((struct anonymous_8 *)acc)->nargs == -1)
                                  {
                                    signed long int neko_interp_loop__1__1__1__36__3__2__args[5l];
                                    signed long int neko_interp_loop__1__1__1__36__3__2__tmp;
                                    struct anonymous_8 *neko_interp_loop__1__1__1__36__3__2__f = (struct anonymous_8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_242;
                                      return_value_neko_stack_expand_242=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_242 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_241=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_241);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vtmp;
                                    vm->env = ((struct anonymous_8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    sp = sp + pc[(signed long int)-1];
                                    neko_interp_loop__1__1__1__36__3__2__tmp = (signed long int)0;
                                    for( ; !(neko_interp_loop__1__1__1__36__3__2__tmp >= pc[-1l]); neko_interp_loop__1__1__1__36__3__2__tmp = neko_interp_loop__1__1__1__36__3__2__tmp + 1l)
                                    {
                                      sp = sp - 1l;
                                      neko_interp_loop__1__1__1__36__3__2__args[neko_interp_loop__1__1__1__36__3__2__tmp] = *sp;
                                    }
                                    acc=((signed long int (*)(struct _value **, signed int))((struct anonymous_8 *)acc)->addr)((struct _value **)(void *)neko_interp_loop__1__1__1__36__3__2__args, (signed int)pc[(signed long int)-1]);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop__1__1__1__36__3__2__f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_243 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_243 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_244 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_244 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_245 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_245 = (signed long int)0;
                                    tmp_post_246 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_246 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_248;
                                      return_value_neko_stack_expand_248=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_248 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_247=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_247);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_249;
                                    return_value_neko_alloc_string_249=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string_249);
                                  }
                                signed int neko_interp_loop__1__1__1__36__3__4__tmp = (signed int)pc[(signed long int)-1];
                                do
                                {
                                  tmp_post_250 = neko_interp_loop__1__1__1__36__3__4__tmp;
                                  neko_interp_loop__1__1__1__36__3__4__tmp = neko_interp_loop__1__1__1__36__3__4__tmp - 1;
                                  if(!(tmp_post_250 >= 1))
                                    break;

                                  tmp_post_251 = sp;
                                  sp = sp + 1l;
                                  *tmp_post_251 = (signed long int)0;
                                }
                                while((_Bool)1);
                              }

                              else
                                if((signed int)*((enum anonymous_7 *)acc) == VAL_JITFUN)
                                {
                                  if(pc[-1l] == (signed long int)((struct anonymous_8 *)acc)->nargs)
                                  {
                                    struct anonymous_8 *neko_interp_loop__1__1__1__36__4__1__f = (struct anonymous_8 *)acc;
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_253;
                                      return_value_neko_stack_expand_253=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_253 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_252=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_252);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->vthis = vtmp;
                                    vm->env = ((struct anonymous_8 *)acc)->env;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    acc=jit_run(vm, (struct anonymous_8 *)acc);
                                    if(acc == 0l)
                                      neko_val_throw((struct _value *)neko_interp_loop__1__1__1__36__4__1__f->module);

                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_254 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_254 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_255 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_255 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_256 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_256 = (signed long int)0;
                                    tmp_post_257 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_257 = (signed long int)0;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_259;
                                      return_value_neko_stack_expand_259=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_259 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_258=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_258);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_260;
                                    return_value_neko_alloc_string_260=neko_alloc_string("Invalid call");
                                    neko_val_throw(return_value_neko_alloc_string_260);
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_262;
                                    return_value_neko_stack_expand_262=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_262 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_261=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_261);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string_263;
                                  return_value_neko_alloc_string_263=neko_alloc_string("Invalid call");
                                  neko_val_throw(return_value_neko_alloc_string_263);
                                }
                          }
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                        }
                        while(*pc++ == &&LabelObjCall);
                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelJump:
                          ;
                          pc = (signed long int *)*pc;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                        }
                        while(*pc++ == &&LabelJump);
                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;


                      LabelJumpIf:
                        ;
                        while((_Bool)1)
                        {
                          if(acc == (signed long int)val_true)
                            pc = (signed long int *)*pc;

                          else
                            pc = pc + 1l;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(!(*pc++ == &&LabelJumpIf))
                            break;

                        }
                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;


                      LabelJumpIfNot:
                        ;
                        while((_Bool)1)
                        {
                          if(!(acc == (signed long int)val_true))
                            pc = (signed long int *)*pc;

                          else
                            pc = pc + 1l;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(!(*pc++ == &&LabelJumpIfNot))
                            break;

                        }
                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelTrap:
                          ;
                          sp = sp - (signed long int)6;
                          if(csp >= sp)
                          {
                            signed int return_value_neko_stack_expand_266;
                            return_value_neko_stack_expand_266=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand_266 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string_265=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string_265);
                            }
                          }

                          sp[(signed long int)0] = (signed long int)(struct _value *)(signed long int)((signed int)(signed long int)(csp - vm->spmin) << 1 | 1);
                          sp[(signed long int)1] = (signed long int)vm->vthis;
                          sp[(signed long int)2] = (signed long int)vm->env;
                          sp[(signed long int)3] = (signed long int)*pc | (signed long int)1;
                          sp[(signed long int)4] = (signed long int)m | (signed long int)1;
                          sp[(signed long int)5] = (signed long int)(struct _value *)(signed long int)((signed int)vm->trap << 1 | 1);
                          vm->trap = vm->spmax - sp;
                          pc = pc + 1l;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                        }
                        while(*pc++ == &&LabelTrap);
                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;


                      LabelEndTrap:
                        ;
                        while((_Bool)1)
                        {
                          if(!(vm->spmax + -vm->trap == sp))
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand_268;
                              return_value_neko_stack_expand_268=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand_268 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string_267=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string_267);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string_269;
                            return_value_neko_alloc_string_269=neko_alloc_string("Invalid End Trap");
                            neko_val_throw(return_value_neko_alloc_string_269);
                          }

                          vm->trap = (signed long int)((signed int)(signed long int)sp[(signed long int)5] >> 1);
                          signed int neko_interp_loop__1__1__1__39__tmp = (signed int)6;
                          do
                          {
                            tmp_post_270 = neko_interp_loop__1__1__1__39__tmp;
                            neko_interp_loop__1__1__1__39__tmp = neko_interp_loop__1__1__1__39__tmp - 1;
                            if(!(tmp_post_270 >= 1))
                              break;

                            tmp_post_271 = sp;
                            sp = sp + 1l;
                            *tmp_post_271 = (signed long int)0;
                          }
                          while((_Bool)1);
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(!(*pc++ == &&LabelEndTrap))
                            break;

                        }
                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelRet:
                          ;
                          signed int neko_interp_loop__1__1__1__40__tmp;
                          tmp_post_272 = pc;
                          pc = pc + 1l;
                          neko_interp_loop__1__1__1__40__tmp = (signed int)*tmp_post_272;
                          do
                          {
                            tmp_post_273 = neko_interp_loop__1__1__1__40__tmp;
                            neko_interp_loop__1__1__1__40__tmp = neko_interp_loop__1__1__1__40__tmp - 1;
                            if(!(tmp_post_273 >= 1))
                              break;

                            tmp_post_274 = sp;
                            sp = sp + 1l;
                            *tmp_post_274 = (signed long int)0;
                          }
                          while((_Bool)1);
                          m = (struct _neko_module *)*csp;
                          tmp_post_275 = csp;
                          csp = csp - 1l;
                          *tmp_post_275 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post_276 = csp;
                          csp = csp - 1l;
                          *tmp_post_276 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post_277 = csp;
                          csp = csp - 1l;
                          *tmp_post_277 = (signed long int)0;
                          pc = (signed long int *)*csp;
                          tmp_post_278 = csp;
                          csp = csp - 1l;
                          *tmp_post_278 = (signed long int)0;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                        }
                        while(*pc++ == &&LabelRet);
                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelMakeEnv:
                          ;
                          signed int n;
                          tmp_post_279 = pc;
                          pc = pc + 1l;
                          n = (signed int)*tmp_post_279;
                          signed long int neko_interp_loop__1__1__1__41__tmp;
                          struct _value *return_value_neko_alloc_array_280;
                          return_value_neko_alloc_array_280=neko_alloc_array((unsigned int)n);
                          neko_interp_loop__1__1__1__41__tmp = (signed long int)return_value_neko_alloc_array_280;
                          do
                          {
                            tmp_post_281 = n;
                            n = n - 1;
                            if(tmp_post_281 == 0)
                              break;

                            (&((struct anonymous_4 *)neko_interp_loop__1__1__1__41__tmp)->ptr)[(signed long int)n] = (struct _value *)*sp;
                            tmp_post_282 = sp;
                            sp = sp + 1l;
                            *tmp_post_282 = (signed long int)0;
                          }
                          while((_Bool)1);
                          if(!((1 & (signed int)acc) == 0))
                            tmp_if_expr_286 = (_Bool)1;

                          else
                            tmp_if_expr_286 = (signed int)*((enum anonymous_7 *)acc) != VAL_FUNCTION ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr_286)
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand_284;
                              return_value_neko_stack_expand_284=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand_284 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string_283=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string_283);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string_285;
                            return_value_neko_alloc_string_285=neko_alloc_string("Invalid environment");
                            neko_val_throw(return_value_neko_alloc_string_285);
                          }

                          struct _value *return_value_neko_alloc_module_function_287;
                          return_value_neko_alloc_module_function_287=neko_alloc_module_function(((struct anonymous_8 *)acc)->module, (signed long int)((struct anonymous_8 *)acc)->addr, ((struct anonymous_8 *)acc)->nargs);
                          acc = (signed long int)return_value_neko_alloc_module_function_287;
                          ((struct anonymous_8 *)acc)->env = (struct _value *)neko_interp_loop__1__1__1__41__tmp;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                        }
                        while(*pc++ == &&LabelMakeEnv);
                        if(*pc++ == &&LabelRet)
                          goto LabelRet;

                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelMakeArray:
                          ;
                          signed int neko_interp_loop__1__1__1__42__n;
                          tmp_post_288 = pc;
                          pc = pc + 1l;
                          neko_interp_loop__1__1__1__42__n = (signed int)*tmp_post_288;
                          struct _value *arr;
                          arr=neko_alloc_array((unsigned int)(neko_interp_loop__1__1__1__42__n + 1));
                          for( ; !(neko_interp_loop__1__1__1__42__n == 0); neko_interp_loop__1__1__1__42__n = neko_interp_loop__1__1__1__42__n - 1)
                          {
                            (&((struct anonymous_4 *)arr)->ptr)[(signed long int)neko_interp_loop__1__1__1__42__n] = (struct _value *)*sp;
                            tmp_post_289 = sp;
                            sp = sp + 1l;
                            *tmp_post_289 = (signed long int)0;
                          }
                          (&((struct anonymous_4 *)arr)->ptr)[(signed long int)0] = (struct _value *)acc;
                          acc = (signed long int)arr;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                        }
                        while(*pc++ == &&LabelMakeArray);
                        if(*pc++ == &&LabelMakeEnv)
                          goto LabelMakeEnv;

                        if(*pc++ == &&LabelRet)
                          goto LabelRet;

                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                        do
                        {

                        LabelMakeArray2:
                          ;
                          signed int neko_interp_loop__1__1__1__43__n;
                          tmp_post_290 = pc;
                          pc = pc + 1l;
                          neko_interp_loop__1__1__1__43__n = (signed int)*tmp_post_290;
                          struct _value *neko_interp_loop__1__1__1__43__arr;
                          neko_interp_loop__1__1__1__43__arr=neko_alloc_array((unsigned int)(neko_interp_loop__1__1__1__43__n + 1));
                          if(neko_interp_loop__1__1__1__43__n == 2)
                            neko_interp_loop__1__1__1__43__n = neko_interp_loop__1__1__1__43__n + 0;

                          (&((struct anonymous_4 *)neko_interp_loop__1__1__1__43__arr)->ptr)[(signed long int)neko_interp_loop__1__1__1__43__n] = (struct _value *)acc;
                          for( ; !(neko_interp_loop__1__1__1__43__n == 0); *tmp_post_291 = (signed long int)0)
                          {
                            neko_interp_loop__1__1__1__43__n = neko_interp_loop__1__1__1__43__n - 1;
                            (&((struct anonymous_4 *)neko_interp_loop__1__1__1__43__arr)->ptr)[(signed long int)neko_interp_loop__1__1__1__43__n] = (struct _value *)*sp;
                            tmp_post_291 = sp;
                            sp = sp + 1l;
                          }
                          acc = (signed long int)neko_interp_loop__1__1__1__43__arr;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                        }
                        while(*pc++ == &&LabelMakeArray2);
                        if(*pc++ == &&LabelLoop)
                          goto LabelLoop;

                        if(*pc++ == &&LabelTailCall)
                          goto LabelTailCall;

                        if(*pc++ == &&LabelPhysCompare)
                          goto LabelPhysCompare;

                        if(*pc++ == &&LabelAccIndex1)
                          goto LabelAccIndex1;

                        if(*pc++ == &&LabelAccIndex0)
                          goto LabelAccIndex0;

                        if(*pc++ == &&LabelAccStack1)
                          goto LabelAccStack1;

                        if(*pc++ == &&LabelAccStack0)
                          goto LabelAccStack0;

                        if(*pc++ == &&LabelApply)
                          goto LabelApply;

                        if(*pc++ == &&LabelJumpTable)
                          goto LabelJumpTable;

                        if(*pc++ == &&LabelNew)
                          goto LabelNew;

                        if(*pc++ == &&LabelHash)
                          goto LabelHash;

                        if(*pc++ == &&LabelCompare)
                          goto LabelCompare;

                        if(*pc++ == &&LabelTypeOf)
                          goto LabelTypeOf;

                        if(!(*pc++ == &&LabelNot))
                        {
                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                          if(*pc++ == &&LabelAnd)
                            goto LabelAnd;

                          if(*pc++ == &&LabelOr)
                            goto LabelOr;

                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(!(*pc++ == &&LabelBool))
                          {
                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelBool:
                            ;
                            acc = acc == (signed long int)val_false || acc == (signed long int)val_null || acc == (signed long int)1 ? (signed long int)val_false : (signed long int)val_true;
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                          }
                          while(*pc++ == &&LabelBool);
                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(*pc++ == &&LabelCall)
                            goto LabelCall;

                          if(*pc++ == &&LabelPop)
                            goto LabelPop;

                          if(*pc++ == &&LabelPush)
                            goto LabelPush;

                          if(*pc++ == &&LabelSetThis)
                            goto LabelSetThis;

                          if(*pc++ == &&LabelSetIndex)
                            goto LabelSetIndex;

                          if(*pc++ == &&LabelSetArray)
                            goto LabelSetArray;

                          if(*pc++ == &&LabelSetField)
                            goto LabelSetField;

                          if(*pc++ == &&LabelSetEnv)
                            goto LabelSetEnv;

                          if(*pc++ == &&LabelSetGlobal)
                            goto LabelSetGlobal;

                          if(*pc++ == &&LabelSetStack)
                            goto LabelSetStack;

                          if(*pc++ == &&LabelAccBuiltin)
                            goto LabelAccBuiltin;

                          if(*pc++ == &&LabelAccIndex)
                            goto LabelAccIndex;

                          if(*pc++ == &&LabelAccArray)
                            goto LabelAccArray;

                          if(*pc++ == &&LabelAccField)
                            goto LabelAccField;

                          if(*pc++ == &&LabelAccEnv)
                            goto LabelAccEnv;

                          if(*pc++ == &&LabelAccGlobal)
                            goto LabelAccGlobal;

                          if(*pc++ == &&LabelAccStack)
                            goto LabelAccStack;

                          if(*pc++ == &&LabelAccInt)
                            goto LabelAccInt;

                          if(*pc++ == &&LabelAccThis)
                            goto LabelAccThis;

                          if(*pc++ == &&LabelAccFalse)
                            goto LabelAccFalse;

                          if(*pc++ == &&LabelAccTrue)
                            goto LabelAccTrue;

                          if(*pc++ == &&LabelAccNull)
                            goto LabelAccNull;

                          if(*pc++ == &&end)
                            goto end;

                        }

                        do
                        {

                        LabelNot:
                          ;
                          acc = acc == (signed long int)val_false || acc == (signed long int)val_null || acc == (signed long int)1 ? (signed long int)val_true : (signed long int)val_false;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                        }
                        while(*pc++ == &&LabelNot);
                        if(*pc++ == &&LabelLte)
                          goto LabelLte;

                        if(*pc++ == &&LabelLt)
                          goto LabelLt;

                        if(*pc++ == &&LabelGte)
                          goto LabelGte;

                        if(*pc++ == &&LabelGt)
                          goto LabelGt;

                        if(*pc++ == &&LabelNeq)
                          goto LabelNeq;

                        if(*pc++ == &&LabelEq)
                          goto LabelEq;

                        if(*pc++ == &&LabelXor)
                          goto LabelXor;

                        if(*pc++ == &&LabelAnd)
                          goto LabelAnd;

                        if(*pc++ == &&LabelOr)
                          goto LabelOr;

                        if(*pc++ == &&LabelUShr)
                          goto LabelUShr;

                        if(*pc++ == &&LabelShr)
                          goto LabelShr;

                        if(*pc++ == &&LabelShl)
                          goto LabelShl;

                        if(*pc++ == &&LabelMod)
                          goto LabelMod;

                        if(*pc++ == &&LabelDiv)
                          goto LabelDiv;

                        if(*pc++ == &&LabelMult)
                          goto LabelMult;

                        if(*pc++ == &&LabelSub)
                          goto LabelSub;

                        if(!(*pc++ == &&LabelAdd))
                        {
                          if(!(*pc++ == &&LabelIsNotNull))
                          {
                            if(!(*pc++ == &&LabelIsNull))
                            {
                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelIsNull:
                              ;
                              acc = (signed long int)(acc == (signed long int)val_null ? val_true : val_false);
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                              if(*pc++ == &&LabelUShr)
                                goto LabelUShr;

                              if(*pc++ == &&LabelShr)
                                goto LabelShr;

                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                            }
                            while(*pc++ == &&LabelIsNull);
                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelIsNotNull:
                            ;
                            acc = (signed long int)(acc == (signed long int)val_null ? val_false : val_true);
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                            if(*pc++ == &&LabelOr)
                              goto LabelOr;

                            if(*pc++ == &&LabelUShr)
                              goto LabelUShr;

                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                          }
                          while(*pc++ == &&LabelIsNotNull);
                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(*pc++ == &&LabelCall)
                            goto LabelCall;

                          if(*pc++ == &&LabelPop)
                            goto LabelPop;

                          if(*pc++ == &&LabelPush)
                            goto LabelPush;

                          if(*pc++ == &&LabelSetThis)
                            goto LabelSetThis;

                          if(*pc++ == &&LabelSetIndex)
                            goto LabelSetIndex;

                          if(*pc++ == &&LabelSetArray)
                            goto LabelSetArray;

                          if(*pc++ == &&LabelSetField)
                            goto LabelSetField;

                          if(*pc++ == &&LabelSetEnv)
                            goto LabelSetEnv;

                          if(*pc++ == &&LabelSetGlobal)
                            goto LabelSetGlobal;

                          if(*pc++ == &&LabelSetStack)
                            goto LabelSetStack;

                          if(*pc++ == &&LabelAccBuiltin)
                            goto LabelAccBuiltin;

                          if(*pc++ == &&LabelAccIndex)
                            goto LabelAccIndex;

                          if(*pc++ == &&LabelAccArray)
                            goto LabelAccArray;

                          if(*pc++ == &&LabelAccField)
                            goto LabelAccField;

                          if(*pc++ == &&LabelAccEnv)
                            goto LabelAccEnv;

                          if(*pc++ == &&LabelAccGlobal)
                            goto LabelAccGlobal;

                          if(*pc++ == &&LabelAccStack)
                            goto LabelAccStack;

                          if(*pc++ == &&LabelAccInt)
                            goto LabelAccInt;

                          if(*pc++ == &&LabelAccThis)
                            goto LabelAccThis;

                          if(*pc++ == &&LabelAccFalse)
                            goto LabelAccFalse;

                          if(*pc++ == &&LabelAccTrue)
                            goto LabelAccTrue;

                          if(*pc++ == &&LabelAccNull)
                            goto LabelAccNull;

                          if(*pc++ == &&end)
                            goto end;

                        }


                      LabelAdd:
                        ;
                        if(!((1l & acc) == 0l))
                          tmp_if_expr_352 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr_352 = (_Bool)0;
                        if(tmp_if_expr_352)
                        {
                          if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + (unsigned int)((signed int)acc >> 1) & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32_292=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) + ((signed int)(signed long int)acc >> 1));
                            tmp_if_expr_293 = return_value_neko_alloc_int32_292;
                          }

                          else
                            tmp_if_expr_293 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) + ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                          acc = (signed long int)tmp_if_expr_293;
                          goto __CPROVER_DUMP_L546;
                        }

                        if(!((1l & acc) == 0l))
                        {
                          if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                          {
                            return_value_neko_alloc_float_294=neko_alloc_float(((struct anonymous_25 *)*sp)->f + (double)((signed int)(signed long int)acc >> 1));
                            acc = (signed long int)return_value_neko_alloc_float_294;
                          }

                          else
                            if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                            {
                              if(!((1073741824u + (unsigned int)((signed int)acc >> 1) + (unsigned int)((struct anonymous_26 *)*sp)->i & 0x80000000) == 0u))
                              {
                                return_value_neko_alloc_int32_295=neko_alloc_int32(((struct anonymous_26 *)*sp)->i + ((signed int)(signed long int)acc >> 1));
                                tmp_if_expr_296 = return_value_neko_alloc_int32_295;
                              }

                              else
                                tmp_if_expr_296 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i + ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                              acc = (signed long int)tmp_if_expr_296;
                            }

                            else
                              if((15 & (signed int)*((enum anonymous_7 *)*sp)) == VAL_STRING)
                              {
                                return_value_neko_append_int_297=neko_append_int(vm, (struct _value *)*sp, (signed int)(signed long int)acc >> 1, 1);
                                acc = (signed long int)return_value_neko_append_int_297;
                              }

                              else
                                if((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT)
                                {
                                  struct _value *neko_interp_loop__1__1__1__44__1___o = (struct _value *)*sp;
                                  struct _value *neko_interp_loop__1__1__1__44__1___arg = (struct _value *)acc;
                                  struct _value *neko_interp_loop__1__1__1__44__1___f;
                                  neko_interp_loop__1__1__1__44__1___f=neko_val_field(neko_interp_loop__1__1__1__44__1___o, id_add);
                                  if(neko_interp_loop__1__1__1__44__1___f == val_null)
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_299;
                                      return_value_neko_stack_expand_299=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_299 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_298=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_298);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_300;
                                    return_value_neko_alloc_string_300=neko_alloc_string("Unsupported operation");
                                    neko_val_throw(return_value_neko_alloc_string_300);
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_302;
                                      return_value_neko_stack_expand_302=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_302 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_301=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_301);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_val_callEx_303;
                                    return_value_neko_val_callEx_303=neko_val_callEx(neko_interp_loop__1__1__1__44__1___o, neko_interp_loop__1__1__1__44__1___f, &neko_interp_loop__1__1__1__44__1___arg, 1, (struct _value **)(void *)0);
                                    acc = (signed long int)return_value_neko_val_callEx_303;
                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_304 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_304 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_305 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_305 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_306 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_306 = (signed long int)0;
                                    tmp_post_307 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_307 = (signed long int)0;
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_309;
                                    return_value_neko_stack_expand_309=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_309 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_308=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_308);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string_310;
                                  return_value_neko_alloc_string_310=neko_alloc_string("Invalid operation (+)");
                                  neko_val_throw(return_value_neko_alloc_string_310);
                                }
                          goto __CPROVER_DUMP_L546;
                        }

                        if(!((1l & *sp) == 0l))
                        {
                          if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
                          {
                            return_value_neko_alloc_float_311=neko_alloc_float((double)((signed int)(signed long int)*sp >> 1) + ((struct anonymous_25 *)acc)->f);
                            acc = (signed long int)return_value_neko_alloc_float_311;
                          }

                          else
                            if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
                            {
                              if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + (unsigned int)((struct anonymous_26 *)acc)->i & 0x80000000) == 0u))
                              {
                                return_value_neko_alloc_int32_312=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) + ((struct anonymous_26 *)acc)->i);
                                tmp_if_expr_313 = return_value_neko_alloc_int32_312;
                              }

                              else
                                tmp_if_expr_313 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) + ((struct anonymous_26 *)acc)->i) << 1 | 1);
                              acc = (signed long int)tmp_if_expr_313;
                            }

                            else
                              if((15 & (signed int)*((enum anonymous_7 *)acc)) == VAL_STRING)
                              {
                                return_value_neko_append_int_314=neko_append_int(vm, (struct _value *)acc, (signed int)(signed long int)*sp >> 1, 0);
                                acc = (signed long int)return_value_neko_append_int_314;
                              }

                              else
                                if((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT)
                                {
                                  struct _value *neko_interp_loop__1__1__1__45__1___o = (struct _value *)acc;
                                  struct _value *neko_interp_loop__1__1__1__45__1___arg = (struct _value *)*sp;
                                  struct _value *neko_interp_loop__1__1__1__45__1___f;
                                  neko_interp_loop__1__1__1__45__1___f=neko_val_field(neko_interp_loop__1__1__1__45__1___o, id_radd);
                                  if(neko_interp_loop__1__1__1__45__1___f == val_null)
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_316;
                                      return_value_neko_stack_expand_316=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_316 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_315=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_315);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_317;
                                    return_value_neko_alloc_string_317=neko_alloc_string("Unsupported operation");
                                    neko_val_throw(return_value_neko_alloc_string_317);
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_319;
                                      return_value_neko_stack_expand_319=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_319 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_318=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_318);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_val_callEx_320;
                                    return_value_neko_val_callEx_320=neko_val_callEx(neko_interp_loop__1__1__1__45__1___o, neko_interp_loop__1__1__1__45__1___f, &neko_interp_loop__1__1__1__45__1___arg, 1, (struct _value **)(void *)0);
                                    acc = (signed long int)return_value_neko_val_callEx_320;
                                    sp = vm->sp;
                                    csp = vm->csp;
                                    m = (struct _neko_module *)*csp;
                                    tmp_post_321 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_321 = (signed long int)0;
                                    vm->vthis = (struct _value *)*csp;
                                    tmp_post_322 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_322 = (signed long int)0;
                                    vm->env = (struct _value *)*csp;
                                    tmp_post_323 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_323 = (signed long int)0;
                                    tmp_post_324 = csp;
                                    csp = csp - 1l;
                                    *tmp_post_324 = (signed long int)0;
                                  }
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_326;
                                    return_value_neko_stack_expand_326=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_326 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_325=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_325);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string_327;
                                  return_value_neko_alloc_string_327=neko_alloc_string("Invalid operation (+)");
                                  neko_val_throw(return_value_neko_alloc_string_327);
                                }
                          goto __CPROVER_DUMP_L546;
                        }

                        if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
                        {
                          if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                          {
                            return_value_neko_alloc_float_328=neko_alloc_float(((struct anonymous_25 *)*sp)->f + ((struct anonymous_25 *)acc)->f);
                            acc = (signed long int)return_value_neko_alloc_float_328;
                          }

                          else
                            if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                            {
                              return_value_neko_alloc_float_329=neko_alloc_float((double)((struct anonymous_26 *)*sp)->i + ((struct anonymous_25 *)acc)->f);
                              acc = (signed long int)return_value_neko_alloc_float_329;
                            }

                            else
                              goto add_next;
                          goto __CPROVER_DUMP_L546;
                        }

                        if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
                        {
                          if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                          {
                            if(!((1073741824u + (unsigned int)((struct anonymous_26 *)*sp)->i + (unsigned int)((struct anonymous_26 *)acc)->i & 0x80000000) == 0u))
                            {
                              return_value_neko_alloc_int32_330=neko_alloc_int32(((struct anonymous_26 *)*sp)->i + ((struct anonymous_26 *)acc)->i);
                              tmp_if_expr_331 = return_value_neko_alloc_int32_330;
                            }

                            else
                              tmp_if_expr_331 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i + ((struct anonymous_26 *)acc)->i) << 1 | 1);
                            acc = (signed long int)tmp_if_expr_331;
                          }

                          else
                            if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                            {
                              return_value_neko_alloc_float_332=neko_alloc_float(((struct anonymous_25 *)*sp)->f + (double)((struct anonymous_26 *)acc)->i);
                              acc = (signed long int)return_value_neko_alloc_float_332;
                            }

                            else
                              goto add_next;
                          goto __CPROVER_DUMP_L546;
                        }

                      }


                    add_next:
                      ;
                      if((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT)
                      {
                        struct _value *neko_interp_loop__1__1__1__48__1___o = (struct _value *)*sp;
                        struct _value *neko_interp_loop__1__1__1__48__1___arg = (struct _value *)acc;
                        struct _value *neko_interp_loop__1__1__1__48__1___f;
                        neko_interp_loop__1__1__1__48__1___f=neko_val_field(neko_interp_loop__1__1__1__48__1___o, id_add);
                        if(neko_interp_loop__1__1__1__48__1___f == val_null)
                          goto add_2;

                        else
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand_334;
                            return_value_neko_stack_expand_334=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand_334 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string_333=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string_333);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_val_callEx_335;
                          return_value_neko_val_callEx_335=neko_val_callEx(neko_interp_loop__1__1__1__48__1___o, neko_interp_loop__1__1__1__48__1___f, &neko_interp_loop__1__1__1__48__1___arg, 1, (struct _value **)(void *)0);
                          acc = (signed long int)return_value_neko_val_callEx_335;
                          sp = vm->sp;
                          csp = vm->csp;
                          m = (struct _neko_module *)*csp;
                          tmp_post_336 = csp;
                          csp = csp - 1l;
                          *tmp_post_336 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post_337 = csp;
                          csp = csp - 1l;
                          *tmp_post_337 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post_338 = csp;
                          csp = csp - 1l;
                          *tmp_post_338 = (signed long int)0;
                          tmp_post_339 = csp;
                          csp = csp - 1l;
                          *tmp_post_339 = (signed long int)0;
                        }
                        goto __CPROVER_DUMP_L546;
                      }

                    }


                  add_2:
                    ;
                    if(!((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT))
                      goto add_3;

                    struct _value *neko_interp_loop__1__1__1__48__2__1___o = (struct _value *)acc;
                    struct _value *neko_interp_loop__1__1__1__48__2__1___arg = (struct _value *)*sp;
                    struct _value *neko_interp_loop__1__1__1__48__2__1___f;
                    neko_interp_loop__1__1__1__48__2__1___f=neko_val_field(neko_interp_loop__1__1__1__48__2__1___o, id_radd);
                    if(neko_interp_loop__1__1__1__48__2__1___f == val_null)
                      goto add_3;

                    else
                    {
                      if(csp + 4l >= sp)
                      {
                        signed int return_value_neko_stack_expand_341;
                        return_value_neko_stack_expand_341=neko_stack_expand(sp, csp, vm);
                        if(!(return_value_neko_stack_expand_341 == 0))
                        {
                          sp = vm->sp;
                          csp = vm->csp;
                        }

                        else
                        {
                          return_value_neko_alloc_string_340=neko_alloc_string("Stack Overflow");
                          neko_val_throw(return_value_neko_alloc_string_340);
                        }
                      }

                      csp = csp + 1l;
                      *csp = (signed long int)pc;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->env;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->vthis;
                      csp = csp + 1l;
                      *csp = (signed long int)m;
                      vm->sp = sp;
                      vm->csp = csp;
                      struct _value *return_value_neko_val_callEx_342;
                      return_value_neko_val_callEx_342=neko_val_callEx(neko_interp_loop__1__1__1__48__2__1___o, neko_interp_loop__1__1__1__48__2__1___f, &neko_interp_loop__1__1__1__48__2__1___arg, 1, (struct _value **)(void *)0);
                      acc = (signed long int)return_value_neko_val_callEx_342;
                      sp = vm->sp;
                      csp = vm->csp;
                      m = (struct _neko_module *)*csp;
                      tmp_post_343 = csp;
                      csp = csp - 1l;
                      *tmp_post_343 = (signed long int)0;
                      vm->vthis = (struct _value *)*csp;
                      tmp_post_344 = csp;
                      csp = csp - 1l;
                      *tmp_post_344 = (signed long int)0;
                      vm->env = (struct _value *)*csp;
                      tmp_post_345 = csp;
                      csp = csp - 1l;
                      *tmp_post_345 = (signed long int)0;
                      tmp_post_346 = csp;
                      csp = csp - 1l;
                      *tmp_post_346 = (signed long int)0;
                    }
                  }

                  else
                  {

                  add_3:
                    ;
                    if((15 & (signed int)*((enum anonymous_7 *)acc)) == VAL_STRING)
                      tmp_if_expr_351 = (_Bool)1;

                    else
                      tmp_if_expr_351 = ((signed int)*((enum anonymous_7 *)*sp) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_351)
                    {
                      struct _buffer *neko_interp_loop__1__1__1__48__2__2__1__b;
                      neko_interp_loop__1__1__1__48__2__2__1__b=neko_alloc_buffer((const char *)(void *)0);
                      vm->sp = sp;
                      vm->csp = csp;
                      neko_val_buffer(neko_interp_loop__1__1__1__48__2__2__1__b, (struct _value *)*sp);
                      neko_val_buffer(neko_interp_loop__1__1__1__48__2__2__1__b, (struct _value *)acc);
                      sp = vm->sp;
                      csp = vm->csp;
                      struct _value *return_value_neko_buffer_to_string_347;
                      return_value_neko_buffer_to_string_347=neko_buffer_to_string(neko_interp_loop__1__1__1__48__2__2__1__b);
                      acc = (signed long int)return_value_neko_buffer_to_string_347;
                    }

                    else
                    {
                      if(csp + 4l >= sp)
                      {
                        signed int return_value_neko_stack_expand_349;
                        return_value_neko_stack_expand_349=neko_stack_expand(sp, csp, vm);
                        if(!(return_value_neko_stack_expand_349 == 0))
                        {
                          sp = vm->sp;
                          csp = vm->csp;
                        }

                        else
                        {
                          return_value_neko_alloc_string_348=neko_alloc_string("Stack Overflow");
                          neko_val_throw(return_value_neko_alloc_string_348);
                        }
                      }

                      csp = csp + 1l;
                      *csp = (signed long int)pc;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->env;
                      csp = csp + 1l;
                      *csp = (signed long int)vm->vthis;
                      csp = csp + 1l;
                      *csp = (signed long int)m;
                      vm->sp = sp;
                      vm->csp = csp;
                      struct _value *return_value_neko_alloc_string_350;
                      return_value_neko_alloc_string_350=neko_alloc_string("Invalid operation (+)");
                      neko_val_throw(return_value_neko_alloc_string_350);
                    }
                  }

                __CPROVER_DUMP_L546:
                  ;
                  tmp_post_353 = sp;
                  sp = sp + 1l;
                  *tmp_post_353 = (signed long int)0;
                  *pc++;
                  if(*pc++ == &&id_mod_next2)
                    goto id_mod_next2;

                  if(*pc++ == &&id_mod_next)
                    goto id_mod_next;

                  if(*pc++ == &&div_next)
                    goto div_next;

                  if(*pc++ == &&id_mult_next2)
                    goto id_mult_next2;

                  if(*pc++ == &&id_mult_next)
                    goto id_mult_next;

                  if(*pc++ == &&id_sub_next2)
                    goto id_sub_next2;

                  if(!(*pc++ == &&id_sub_next))
                  {
                    if(*pc++ == &&add_3)
                      goto add_3;

                    if(*pc++ == &&add_2)
                      goto add_2;

                    if(*pc++ == &&add_next)
                      goto add_next;

                    if(*pc++ == &&do_call)
                      goto LabelCall;

                    if(*pc++ == &&LabelLast)
                      goto LabelLast;

                    if(*pc++ == &&LabelAccInt32)
                      goto LabelAccInt32;

                    if(*pc++ == &&LabelMakeArray2)
                      goto LabelMakeArray2;

                    if(*pc++ == &&LabelLoop)
                      goto LabelLoop;

                    if(*pc++ == &&LabelTailCall)
                      goto LabelTailCall;

                    if(*pc++ == &&LabelPhysCompare)
                      goto LabelPhysCompare;

                    if(*pc++ == &&LabelAccIndex1)
                      goto LabelAccIndex1;

                    if(*pc++ == &&LabelAccIndex0)
                      goto LabelAccIndex0;

                    if(*pc++ == &&LabelAccStack1)
                      goto LabelAccStack1;

                    if(*pc++ == &&LabelAccStack0)
                      goto LabelAccStack0;

                    if(*pc++ == &&LabelApply)
                      goto LabelApply;

                    if(*pc++ == &&LabelJumpTable)
                      goto LabelJumpTable;

                    if(*pc++ == &&LabelNew)
                      goto LabelNew;

                    if(*pc++ == &&LabelHash)
                      goto LabelHash;

                    if(*pc++ == &&LabelCompare)
                      goto LabelCompare;

                    if(*pc++ == &&LabelTypeOf)
                      goto LabelTypeOf;

                    if(*pc++ == &&LabelNot)
                      goto LabelNot;

                    if(*pc++ == &&LabelLte)
                      goto LabelLte;

                    if(*pc++ == &&LabelLt)
                      goto LabelLt;

                    if(*pc++ == &&LabelGte)
                      goto LabelGte;

                    if(*pc++ == &&LabelGt)
                      goto LabelGt;

                    if(*pc++ == &&LabelNeq)
                      goto LabelNeq;

                    if(*pc++ == &&LabelEq)
                      goto LabelEq;

                    if(*pc++ == &&LabelXor)
                      goto LabelXor;

                    if(*pc++ == &&LabelAnd)
                      goto LabelAnd;

                    if(*pc++ == &&LabelOr)
                      goto LabelOr;

                    if(*pc++ == &&LabelUShr)
                      goto LabelUShr;

                    if(*pc++ == &&LabelShr)
                      goto LabelShr;

                    if(*pc++ == &&LabelShl)
                      goto LabelShl;

                    if(*pc++ == &&LabelMod)
                      goto LabelMod;

                    if(*pc++ == &&LabelDiv)
                      goto LabelDiv;

                    if(*pc++ == &&LabelMult)
                      goto LabelMult;

                    if(!(*pc++ == &&LabelSub))
                    {
                      if(*pc++ == &&LabelAdd)
                        goto LabelAdd;

                      if(*pc++ == &&LabelIsNotNull)
                        goto LabelIsNotNull;

                      if(*pc++ == &&LabelIsNull)
                        goto LabelIsNull;

                      if(*pc++ == &&LabelBool)
                        goto LabelBool;

                      if(*pc++ == &&LabelMakeArray)
                        goto LabelMakeArray;

                      if(*pc++ == &&LabelMakeEnv)
                        goto LabelMakeEnv;

                      if(*pc++ == &&LabelRet)
                        goto LabelRet;

                      if(*pc++ == &&LabelEndTrap)
                        goto LabelEndTrap;

                      if(*pc++ == &&LabelTrap)
                        goto LabelTrap;

                      if(*pc++ == &&LabelJumpIfNot)
                        goto LabelJumpIfNot;

                      if(*pc++ == &&LabelJumpIf)
                        goto LabelJumpIf;

                      if(*pc++ == &&LabelJump)
                        goto LabelJump;

                      if(*pc++ == &&LabelObjCall)
                        goto LabelObjCall;

                      if(*pc++ == &&LabelCall)
                        goto LabelCall;

                      if(*pc++ == &&LabelPop)
                        goto LabelPop;

                      if(*pc++ == &&LabelPush)
                        goto LabelPush;

                      if(*pc++ == &&LabelSetThis)
                        goto LabelSetThis;

                      if(*pc++ == &&LabelSetIndex)
                        goto LabelSetIndex;

                      if(*pc++ == &&LabelSetArray)
                        goto LabelSetArray;

                      if(*pc++ == &&LabelSetField)
                        goto LabelSetField;

                      if(*pc++ == &&LabelSetEnv)
                        goto LabelSetEnv;

                      if(*pc++ == &&LabelSetGlobal)
                        goto LabelSetGlobal;

                      if(*pc++ == &&LabelSetStack)
                        goto LabelSetStack;

                      if(*pc++ == &&LabelAccBuiltin)
                        goto LabelAccBuiltin;

                      if(*pc++ == &&LabelAccIndex)
                        goto LabelAccIndex;

                      if(*pc++ == &&LabelAccArray)
                        goto LabelAccArray;

                      if(*pc++ == &&LabelAccField)
                        goto LabelAccField;

                      if(*pc++ == &&LabelAccEnv)
                        goto LabelAccEnv;

                      if(*pc++ == &&LabelAccGlobal)
                        goto LabelAccGlobal;

                      if(*pc++ == &&LabelAccStack)
                        goto LabelAccStack;

                      if(*pc++ == &&LabelAccInt)
                        goto LabelAccInt;

                      if(*pc++ == &&LabelAccThis)
                        goto LabelAccThis;

                      if(*pc++ == &&LabelAccFalse)
                        goto LabelAccFalse;

                      if(*pc++ == &&LabelAccTrue)
                        goto LabelAccTrue;

                      if(*pc++ == &&LabelAccNull)
                        goto LabelAccNull;

                      if(*pc++ == &&end)
                        goto end;

                    }


                  LabelSub:
                    ;
                    if(!((1l & acc) == 0l))
                      tmp_if_expr_413 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_413 = (_Bool)0;
                    if(tmp_if_expr_413)
                    {
                      if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + -((unsigned int)((signed int)acc >> 1)) & 0x80000000) == 0u))
                      {
                        return_value_neko_alloc_int32_354=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) - ((signed int)(signed long int)acc >> 1));
                        tmp_if_expr_355 = return_value_neko_alloc_int32_354;
                      }

                      else
                        tmp_if_expr_355 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) - ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                      acc = (signed long int)tmp_if_expr_355;
                      goto __CPROVER_DUMP_L627;
                    }

                    if(!((1l & acc) == 0l))
                    {
                      if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                      {
                        return_value_neko_alloc_float_356=neko_alloc_float(((struct anonymous_25 *)*sp)->f - (double)((signed int)(signed long int)acc >> 1));
                        acc = (signed long int)return_value_neko_alloc_float_356;
                      }

                      else
                        if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                        {
                          if(!((1073741824u + (unsigned int)((struct anonymous_26 *)*sp)->i + -((unsigned int)((signed int)acc >> 1)) & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32_357=neko_alloc_int32(((struct anonymous_26 *)*sp)->i - ((signed int)(signed long int)acc >> 1));
                            tmp_if_expr_358 = return_value_neko_alloc_int32_357;
                          }

                          else
                            tmp_if_expr_358 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i - ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                          acc = (signed long int)tmp_if_expr_358;
                        }

                        else
                          if((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT)
                          {
                            struct _value *neko_interp_loop__1__1__1__49__1___o = (struct _value *)*sp;
                            struct _value *neko_interp_loop__1__1__1__49__1___arg = (struct _value *)acc;
                            struct _value *neko_interp_loop__1__1__1__49__1___f;
                            neko_interp_loop__1__1__1__49__1___f=neko_val_field(neko_interp_loop__1__1__1__49__1___o, id_sub);
                            if(neko_interp_loop__1__1__1__49__1___f == val_null)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_360;
                                return_value_neko_stack_expand_360=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_360 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_359=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_359);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string_361;
                              return_value_neko_alloc_string_361=neko_alloc_string("Unsupported operation");
                              neko_val_throw(return_value_neko_alloc_string_361);
                            }

                            else
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_363;
                                return_value_neko_stack_expand_363=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_363 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_362=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_362);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_val_callEx_364;
                              return_value_neko_val_callEx_364=neko_val_callEx(neko_interp_loop__1__1__1__49__1___o, neko_interp_loop__1__1__1__49__1___f, &neko_interp_loop__1__1__1__49__1___arg, 1, (struct _value **)(void *)0);
                              acc = (signed long int)return_value_neko_val_callEx_364;
                              sp = vm->sp;
                              csp = vm->csp;
                              m = (struct _neko_module *)*csp;
                              tmp_post_365 = csp;
                              csp = csp - 1l;
                              *tmp_post_365 = (signed long int)0;
                              vm->vthis = (struct _value *)*csp;
                              tmp_post_366 = csp;
                              csp = csp - 1l;
                              *tmp_post_366 = (signed long int)0;
                              vm->env = (struct _value *)*csp;
                              tmp_post_367 = csp;
                              csp = csp - 1l;
                              *tmp_post_367 = (signed long int)0;
                              tmp_post_368 = csp;
                              csp = csp - 1l;
                              *tmp_post_368 = (signed long int)0;
                            }
                          }

                          else
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand_370;
                              return_value_neko_stack_expand_370=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand_370 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string_369=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string_369);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string_371;
                            return_value_neko_alloc_string_371=neko_alloc_string("Invalid operation (-)");
                            neko_val_throw(return_value_neko_alloc_string_371);
                          }
                      goto __CPROVER_DUMP_L627;
                    }

                    if(!((1l & *sp) == 0l))
                    {
                      if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
                      {
                        return_value_neko_alloc_float_372=neko_alloc_float((double)((signed int)(signed long int)*sp >> 1) - ((struct anonymous_25 *)acc)->f);
                        acc = (signed long int)return_value_neko_alloc_float_372;
                      }

                      else
                        if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
                        {
                          if(!((1073741824u + (unsigned int)((signed int)*sp >> 1) + -((unsigned int)((struct anonymous_26 *)acc)->i) & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32_373=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) - ((struct anonymous_26 *)acc)->i);
                            tmp_if_expr_374 = return_value_neko_alloc_int32_373;
                          }

                          else
                            tmp_if_expr_374 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) - ((struct anonymous_26 *)acc)->i) << 1 | 1);
                          acc = (signed long int)tmp_if_expr_374;
                        }

                        else
                          if((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT)
                          {
                            struct _value *neko_interp_loop__1__1__1__50__1___o = (struct _value *)acc;
                            struct _value *neko_interp_loop__1__1__1__50__1___arg = (struct _value *)*sp;
                            struct _value *neko_interp_loop__1__1__1__50__1___f;
                            neko_interp_loop__1__1__1__50__1___f=neko_val_field(neko_interp_loop__1__1__1__50__1___o, id_rsub);
                            if(neko_interp_loop__1__1__1__50__1___f == val_null)
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_376;
                                return_value_neko_stack_expand_376=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_376 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_375=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_375);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string_377;
                              return_value_neko_alloc_string_377=neko_alloc_string("Unsupported operation");
                              neko_val_throw(return_value_neko_alloc_string_377);
                            }

                            else
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_379;
                                return_value_neko_stack_expand_379=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_379 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_378=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_378);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_val_callEx_380;
                              return_value_neko_val_callEx_380=neko_val_callEx(neko_interp_loop__1__1__1__50__1___o, neko_interp_loop__1__1__1__50__1___f, &neko_interp_loop__1__1__1__50__1___arg, 1, (struct _value **)(void *)0);
                              acc = (signed long int)return_value_neko_val_callEx_380;
                              sp = vm->sp;
                              csp = vm->csp;
                              m = (struct _neko_module *)*csp;
                              tmp_post_381 = csp;
                              csp = csp - 1l;
                              *tmp_post_381 = (signed long int)0;
                              vm->vthis = (struct _value *)*csp;
                              tmp_post_382 = csp;
                              csp = csp - 1l;
                              *tmp_post_382 = (signed long int)0;
                              vm->env = (struct _value *)*csp;
                              tmp_post_383 = csp;
                              csp = csp - 1l;
                              *tmp_post_383 = (signed long int)0;
                              tmp_post_384 = csp;
                              csp = csp - 1l;
                              *tmp_post_384 = (signed long int)0;
                            }
                          }

                          else
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand_386;
                              return_value_neko_stack_expand_386=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand_386 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string_385=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string_385);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string_387;
                            return_value_neko_alloc_string_387=neko_alloc_string("Invalid operation (-)");
                            neko_val_throw(return_value_neko_alloc_string_387);
                          }
                      goto __CPROVER_DUMP_L627;
                    }

                    if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
                    {
                      if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                      {
                        return_value_neko_alloc_float_388=neko_alloc_float(((struct anonymous_25 *)*sp)->f - ((struct anonymous_25 *)acc)->f);
                        acc = (signed long int)return_value_neko_alloc_float_388;
                      }

                      else
                        if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                        {
                          return_value_neko_alloc_float_389=neko_alloc_float((double)((struct anonymous_26 *)*sp)->i - ((struct anonymous_25 *)acc)->f);
                          acc = (signed long int)return_value_neko_alloc_float_389;
                        }

                        else
                          goto id_sub_next;
                      goto __CPROVER_DUMP_L627;
                    }

                    if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
                    {
                      if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                      {
                        if(!((1073741824u + (unsigned int)((struct anonymous_26 *)*sp)->i + -((unsigned int)((struct anonymous_26 *)acc)->i) & 0x80000000) == 0u))
                        {
                          return_value_neko_alloc_int32_390=neko_alloc_int32(((struct anonymous_26 *)*sp)->i - ((struct anonymous_26 *)acc)->i);
                          tmp_if_expr_391 = return_value_neko_alloc_int32_390;
                        }

                        else
                          tmp_if_expr_391 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i - ((struct anonymous_26 *)acc)->i) << 1 | 1);
                        acc = (signed long int)tmp_if_expr_391;
                      }

                      else
                        if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                        {
                          return_value_neko_alloc_float_392=neko_alloc_float(((struct anonymous_25 *)*sp)->f - (double)((struct anonymous_26 *)acc)->i);
                          acc = (signed long int)return_value_neko_alloc_float_392;
                        }

                        else
                          goto id_sub_next;
                      goto __CPROVER_DUMP_L627;
                    }

                  }

                }


              id_sub_next:
                ;
                if(!((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT))
                  goto id_sub_next2;

                struct _value *neko_interp_loop__1__1__1__53__1___o = (struct _value *)*sp;
                struct _value *neko_interp_loop__1__1__1__53__1___arg = (struct _value *)acc;
                struct _value *neko_interp_loop__1__1__1__53__1___f;
                neko_interp_loop__1__1__1__53__1___f=neko_val_field(neko_interp_loop__1__1__1__53__1___o, id_sub);
                if(neko_interp_loop__1__1__1__53__1___f == val_null)
                  goto id_sub_next2;

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand_394;
                    return_value_neko_stack_expand_394=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand_394 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string_393=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string_393);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_val_callEx_395;
                  return_value_neko_val_callEx_395=neko_val_callEx(neko_interp_loop__1__1__1__53__1___o, neko_interp_loop__1__1__1__53__1___f, &neko_interp_loop__1__1__1__53__1___arg, 1, (struct _value **)(void *)0);
                  acc = (signed long int)return_value_neko_val_callEx_395;
                  sp = vm->sp;
                  csp = vm->csp;
                  m = (struct _neko_module *)*csp;
                  tmp_post_396 = csp;
                  csp = csp - 1l;
                  *tmp_post_396 = (signed long int)0;
                  vm->vthis = (struct _value *)*csp;
                  tmp_post_397 = csp;
                  csp = csp - 1l;
                  *tmp_post_397 = (signed long int)0;
                  vm->env = (struct _value *)*csp;
                  tmp_post_398 = csp;
                  csp = csp - 1l;
                  *tmp_post_398 = (signed long int)0;
                  tmp_post_399 = csp;
                  csp = csp - 1l;
                  *tmp_post_399 = (signed long int)0;
                }
              }

              else
              {

              id_sub_next2:
                ;
                if((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT)
                {
                  struct _value *neko_interp_loop__1__1__1__53__2__1___o = (struct _value *)acc;
                  struct _value *neko_interp_loop__1__1__1__53__2__1___arg = (struct _value *)*sp;
                  struct _value *neko_interp_loop__1__1__1__53__2__1___f;
                  neko_interp_loop__1__1__1__53__2__1___f=neko_val_field(neko_interp_loop__1__1__1__53__2__1___o, id_rsub);
                  if(neko_interp_loop__1__1__1__53__2__1___f == val_null)
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand_401;
                      return_value_neko_stack_expand_401=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand_401 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string_400=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string_400);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_alloc_string_402;
                    return_value_neko_alloc_string_402=neko_alloc_string("Unsupported operation");
                    neko_val_throw(return_value_neko_alloc_string_402);
                  }

                  else
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand_404;
                      return_value_neko_stack_expand_404=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand_404 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string_403=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string_403);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_val_callEx_405;
                    return_value_neko_val_callEx_405=neko_val_callEx(neko_interp_loop__1__1__1__53__2__1___o, neko_interp_loop__1__1__1__53__2__1___f, &neko_interp_loop__1__1__1__53__2__1___arg, 1, (struct _value **)(void *)0);
                    acc = (signed long int)return_value_neko_val_callEx_405;
                    sp = vm->sp;
                    csp = vm->csp;
                    m = (struct _neko_module *)*csp;
                    tmp_post_406 = csp;
                    csp = csp - 1l;
                    *tmp_post_406 = (signed long int)0;
                    vm->vthis = (struct _value *)*csp;
                    tmp_post_407 = csp;
                    csp = csp - 1l;
                    *tmp_post_407 = (signed long int)0;
                    vm->env = (struct _value *)*csp;
                    tmp_post_408 = csp;
                    csp = csp - 1l;
                    *tmp_post_408 = (signed long int)0;
                    tmp_post_409 = csp;
                    csp = csp - 1l;
                    *tmp_post_409 = (signed long int)0;
                  }
                }

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand_411;
                    return_value_neko_stack_expand_411=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand_411 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string_410=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string_410);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_alloc_string_412;
                  return_value_neko_alloc_string_412=neko_alloc_string("Invalid operation (-)");
                  neko_val_throw(return_value_neko_alloc_string_412);
                }
              }

            __CPROVER_DUMP_L627:
              ;
              tmp_post_414 = sp;
              sp = sp + 1l;
              *tmp_post_414 = (signed long int)0;
              *pc++;
              if(*pc++ == &&id_mod_next2)
                goto id_mod_next2;

              if(*pc++ == &&id_mod_next)
                goto id_mod_next;

              if(*pc++ == &&div_next)
                goto div_next;

              if(*pc++ == &&id_mult_next2)
                goto id_mult_next2;

              if(!(*pc++ == &&id_mult_next))
              {
                if(*pc++ == &&id_sub_next2)
                  goto id_sub_next2;

                if(*pc++ == &&id_sub_next)
                  goto id_sub_next;

                if(*pc++ == &&add_3)
                  goto add_3;

                if(*pc++ == &&add_2)
                  goto add_2;

                if(*pc++ == &&add_next)
                  goto add_next;

                if(*pc++ == &&do_call)
                  goto LabelCall;

                if(*pc++ == &&LabelLast)
                  goto LabelLast;

                if(*pc++ == &&LabelAccInt32)
                  goto LabelAccInt32;

                if(*pc++ == &&LabelMakeArray2)
                  goto LabelMakeArray2;

                if(*pc++ == &&LabelLoop)
                  goto LabelLoop;

                if(*pc++ == &&LabelTailCall)
                  goto LabelTailCall;

                if(*pc++ == &&LabelPhysCompare)
                  goto LabelPhysCompare;

                if(*pc++ == &&LabelAccIndex1)
                  goto LabelAccIndex1;

                if(*pc++ == &&LabelAccIndex0)
                  goto LabelAccIndex0;

                if(*pc++ == &&LabelAccStack1)
                  goto LabelAccStack1;

                if(*pc++ == &&LabelAccStack0)
                  goto LabelAccStack0;

                if(*pc++ == &&LabelApply)
                  goto LabelApply;

                if(*pc++ == &&LabelJumpTable)
                  goto LabelJumpTable;

                if(*pc++ == &&LabelNew)
                  goto LabelNew;

                if(*pc++ == &&LabelHash)
                  goto LabelHash;

                if(*pc++ == &&LabelCompare)
                  goto LabelCompare;

                if(*pc++ == &&LabelTypeOf)
                  goto LabelTypeOf;

                if(*pc++ == &&LabelNot)
                  goto LabelNot;

                if(*pc++ == &&LabelLte)
                  goto LabelLte;

                if(*pc++ == &&LabelLt)
                  goto LabelLt;

                if(*pc++ == &&LabelGte)
                  goto LabelGte;

                if(*pc++ == &&LabelGt)
                  goto LabelGt;

                if(*pc++ == &&LabelNeq)
                  goto LabelNeq;

                if(*pc++ == &&LabelEq)
                  goto LabelEq;

                if(*pc++ == &&LabelXor)
                  goto LabelXor;

                if(*pc++ == &&LabelAnd)
                  goto LabelAnd;

                if(*pc++ == &&LabelOr)
                  goto LabelOr;

                if(*pc++ == &&LabelUShr)
                  goto LabelUShr;

                if(*pc++ == &&LabelShr)
                  goto LabelShr;

                if(*pc++ == &&LabelShl)
                  goto LabelShl;

                if(*pc++ == &&LabelMod)
                  goto LabelMod;

                if(*pc++ == &&LabelDiv)
                  goto LabelDiv;

                if(!(*pc++ == &&LabelMult))
                {
                  if(*pc++ == &&LabelSub)
                    goto LabelSub;

                  if(*pc++ == &&LabelAdd)
                    goto LabelAdd;

                  if(*pc++ == &&LabelIsNotNull)
                    goto LabelIsNotNull;

                  if(*pc++ == &&LabelIsNull)
                    goto LabelIsNull;

                  if(*pc++ == &&LabelBool)
                    goto LabelBool;

                  if(*pc++ == &&LabelMakeArray)
                    goto LabelMakeArray;

                  if(*pc++ == &&LabelMakeEnv)
                    goto LabelMakeEnv;

                  if(*pc++ == &&LabelRet)
                    goto LabelRet;

                  if(*pc++ == &&LabelEndTrap)
                    goto LabelEndTrap;

                  if(*pc++ == &&LabelTrap)
                    goto LabelTrap;

                  if(*pc++ == &&LabelJumpIfNot)
                    goto LabelJumpIfNot;

                  if(*pc++ == &&LabelJumpIf)
                    goto LabelJumpIf;

                  if(*pc++ == &&LabelJump)
                    goto LabelJump;

                  if(*pc++ == &&LabelObjCall)
                    goto LabelObjCall;

                  if(*pc++ == &&LabelCall)
                    goto LabelCall;

                  if(*pc++ == &&LabelPop)
                    goto LabelPop;

                  if(*pc++ == &&LabelPush)
                    goto LabelPush;

                  if(*pc++ == &&LabelSetThis)
                    goto LabelSetThis;

                  if(*pc++ == &&LabelSetIndex)
                    goto LabelSetIndex;

                  if(*pc++ == &&LabelSetArray)
                    goto LabelSetArray;

                  if(*pc++ == &&LabelSetField)
                    goto LabelSetField;

                  if(*pc++ == &&LabelSetEnv)
                    goto LabelSetEnv;

                  if(*pc++ == &&LabelSetGlobal)
                    goto LabelSetGlobal;

                  if(*pc++ == &&LabelSetStack)
                    goto LabelSetStack;

                  if(*pc++ == &&LabelAccBuiltin)
                    goto LabelAccBuiltin;

                  if(*pc++ == &&LabelAccIndex)
                    goto LabelAccIndex;

                  if(*pc++ == &&LabelAccArray)
                    goto LabelAccArray;

                  if(*pc++ == &&LabelAccField)
                    goto LabelAccField;

                  if(*pc++ == &&LabelAccEnv)
                    goto LabelAccEnv;

                  if(*pc++ == &&LabelAccGlobal)
                    goto LabelAccGlobal;

                  if(*pc++ == &&LabelAccStack)
                    goto LabelAccStack;

                  if(*pc++ == &&LabelAccInt)
                    goto LabelAccInt;

                  if(*pc++ == &&LabelAccThis)
                    goto LabelAccThis;

                  if(*pc++ == &&LabelAccFalse)
                    goto LabelAccFalse;

                  if(*pc++ == &&LabelAccTrue)
                    goto LabelAccTrue;

                  if(*pc++ == &&LabelAccNull)
                    goto LabelAccNull;

                  if(*pc++ == &&end)
                    goto end;

                }


              LabelMult:
                ;
                if(!((1l & acc) == 0l))
                  tmp_if_expr_474 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_474 = (_Bool)0;
                if(tmp_if_expr_474)
                {
                  if(!(((unsigned int)((signed int)*sp >> 1) * (unsigned int)((signed int)acc >> 1) + 1073741824u & 0x80000000) == 0u))
                  {
                    return_value_neko_alloc_int32_415=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) * ((signed int)(signed long int)acc >> 1));
                    tmp_if_expr_416 = return_value_neko_alloc_int32_415;
                  }

                  else
                    tmp_if_expr_416 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) * ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                  acc = (signed long int)tmp_if_expr_416;
                  goto __CPROVER_DUMP_L708;
                }

                if(!((1l & acc) == 0l))
                {
                  if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                  {
                    return_value_neko_alloc_float_417=neko_alloc_float(((struct anonymous_25 *)*sp)->f * (double)((signed int)(signed long int)acc >> 1));
                    acc = (signed long int)return_value_neko_alloc_float_417;
                  }

                  else
                    if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                    {
                      if(!(((unsigned int)((signed int)acc >> 1) * (unsigned int)((struct anonymous_26 *)*sp)->i + 1073741824u & 0x80000000) == 0u))
                      {
                        return_value_neko_alloc_int32_418=neko_alloc_int32(((struct anonymous_26 *)*sp)->i * ((signed int)(signed long int)acc >> 1));
                        tmp_if_expr_419 = return_value_neko_alloc_int32_418;
                      }

                      else
                        tmp_if_expr_419 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i * ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                      acc = (signed long int)tmp_if_expr_419;
                    }

                    else
                      if((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT)
                      {
                        struct _value *neko_interp_loop__1__1__1__54__1___o = (struct _value *)*sp;
                        struct _value *neko_interp_loop__1__1__1__54__1___arg = (struct _value *)acc;
                        struct _value *neko_interp_loop__1__1__1__54__1___f;
                        neko_interp_loop__1__1__1__54__1___f=neko_val_field(neko_interp_loop__1__1__1__54__1___o, id_mult);
                        if(neko_interp_loop__1__1__1__54__1___f == val_null)
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand_421;
                            return_value_neko_stack_expand_421=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand_421 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string_420=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string_420);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_alloc_string_422;
                          return_value_neko_alloc_string_422=neko_alloc_string("Unsupported operation");
                          neko_val_throw(return_value_neko_alloc_string_422);
                        }

                        else
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand_424;
                            return_value_neko_stack_expand_424=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand_424 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string_423=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string_423);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_val_callEx_425;
                          return_value_neko_val_callEx_425=neko_val_callEx(neko_interp_loop__1__1__1__54__1___o, neko_interp_loop__1__1__1__54__1___f, &neko_interp_loop__1__1__1__54__1___arg, 1, (struct _value **)(void *)0);
                          acc = (signed long int)return_value_neko_val_callEx_425;
                          sp = vm->sp;
                          csp = vm->csp;
                          m = (struct _neko_module *)*csp;
                          tmp_post_426 = csp;
                          csp = csp - 1l;
                          *tmp_post_426 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post_427 = csp;
                          csp = csp - 1l;
                          *tmp_post_427 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post_428 = csp;
                          csp = csp - 1l;
                          *tmp_post_428 = (signed long int)0;
                          tmp_post_429 = csp;
                          csp = csp - 1l;
                          *tmp_post_429 = (signed long int)0;
                        }
                      }

                      else
                      {
                        if(csp + 4l >= sp)
                        {
                          signed int return_value_neko_stack_expand_431;
                          return_value_neko_stack_expand_431=neko_stack_expand(sp, csp, vm);
                          if(!(return_value_neko_stack_expand_431 == 0))
                          {
                            sp = vm->sp;
                            csp = vm->csp;
                          }

                          else
                          {
                            return_value_neko_alloc_string_430=neko_alloc_string("Stack Overflow");
                            neko_val_throw(return_value_neko_alloc_string_430);
                          }
                        }

                        csp = csp + 1l;
                        *csp = (signed long int)pc;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->env;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->vthis;
                        csp = csp + 1l;
                        *csp = (signed long int)m;
                        vm->sp = sp;
                        vm->csp = csp;
                        struct _value *return_value_neko_alloc_string_432;
                        return_value_neko_alloc_string_432=neko_alloc_string("Invalid operation (*)");
                        neko_val_throw(return_value_neko_alloc_string_432);
                      }
                  goto __CPROVER_DUMP_L708;
                }

                if(!((1l & *sp) == 0l))
                {
                  if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
                  {
                    return_value_neko_alloc_float_433=neko_alloc_float((double)((signed int)(signed long int)*sp >> 1) * ((struct anonymous_25 *)acc)->f);
                    acc = (signed long int)return_value_neko_alloc_float_433;
                  }

                  else
                    if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
                    {
                      if(!(((unsigned int)((signed int)*sp >> 1) * (unsigned int)((struct anonymous_26 *)acc)->i + 1073741824u & 0x80000000) == 0u))
                      {
                        return_value_neko_alloc_int32_434=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) * ((struct anonymous_26 *)acc)->i);
                        tmp_if_expr_435 = return_value_neko_alloc_int32_434;
                      }

                      else
                        tmp_if_expr_435 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) * ((struct anonymous_26 *)acc)->i) << 1 | 1);
                      acc = (signed long int)tmp_if_expr_435;
                    }

                    else
                      if((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT)
                      {
                        struct _value *neko_interp_loop__1__1__1__55__1___o = (struct _value *)acc;
                        struct _value *neko_interp_loop__1__1__1__55__1___arg = (struct _value *)*sp;
                        struct _value *neko_interp_loop__1__1__1__55__1___f;
                        neko_interp_loop__1__1__1__55__1___f=neko_val_field(neko_interp_loop__1__1__1__55__1___o, id_rmult);
                        if(neko_interp_loop__1__1__1__55__1___f == val_null)
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand_437;
                            return_value_neko_stack_expand_437=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand_437 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string_436=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string_436);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_alloc_string_438;
                          return_value_neko_alloc_string_438=neko_alloc_string("Unsupported operation");
                          neko_val_throw(return_value_neko_alloc_string_438);
                        }

                        else
                        {
                          if(csp + 4l >= sp)
                          {
                            signed int return_value_neko_stack_expand_440;
                            return_value_neko_stack_expand_440=neko_stack_expand(sp, csp, vm);
                            if(!(return_value_neko_stack_expand_440 == 0))
                            {
                              sp = vm->sp;
                              csp = vm->csp;
                            }

                            else
                            {
                              return_value_neko_alloc_string_439=neko_alloc_string("Stack Overflow");
                              neko_val_throw(return_value_neko_alloc_string_439);
                            }
                          }

                          csp = csp + 1l;
                          *csp = (signed long int)pc;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->env;
                          csp = csp + 1l;
                          *csp = (signed long int)vm->vthis;
                          csp = csp + 1l;
                          *csp = (signed long int)m;
                          vm->sp = sp;
                          vm->csp = csp;
                          struct _value *return_value_neko_val_callEx_441;
                          return_value_neko_val_callEx_441=neko_val_callEx(neko_interp_loop__1__1__1__55__1___o, neko_interp_loop__1__1__1__55__1___f, &neko_interp_loop__1__1__1__55__1___arg, 1, (struct _value **)(void *)0);
                          acc = (signed long int)return_value_neko_val_callEx_441;
                          sp = vm->sp;
                          csp = vm->csp;
                          m = (struct _neko_module *)*csp;
                          tmp_post_442 = csp;
                          csp = csp - 1l;
                          *tmp_post_442 = (signed long int)0;
                          vm->vthis = (struct _value *)*csp;
                          tmp_post_443 = csp;
                          csp = csp - 1l;
                          *tmp_post_443 = (signed long int)0;
                          vm->env = (struct _value *)*csp;
                          tmp_post_444 = csp;
                          csp = csp - 1l;
                          *tmp_post_444 = (signed long int)0;
                          tmp_post_445 = csp;
                          csp = csp - 1l;
                          *tmp_post_445 = (signed long int)0;
                        }
                      }

                      else
                      {
                        if(csp + 4l >= sp)
                        {
                          signed int return_value_neko_stack_expand_447;
                          return_value_neko_stack_expand_447=neko_stack_expand(sp, csp, vm);
                          if(!(return_value_neko_stack_expand_447 == 0))
                          {
                            sp = vm->sp;
                            csp = vm->csp;
                          }

                          else
                          {
                            return_value_neko_alloc_string_446=neko_alloc_string("Stack Overflow");
                            neko_val_throw(return_value_neko_alloc_string_446);
                          }
                        }

                        csp = csp + 1l;
                        *csp = (signed long int)pc;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->env;
                        csp = csp + 1l;
                        *csp = (signed long int)vm->vthis;
                        csp = csp + 1l;
                        *csp = (signed long int)m;
                        vm->sp = sp;
                        vm->csp = csp;
                        struct _value *return_value_neko_alloc_string_448;
                        return_value_neko_alloc_string_448=neko_alloc_string("Invalid operation (*)");
                        neko_val_throw(return_value_neko_alloc_string_448);
                      }
                  goto __CPROVER_DUMP_L708;
                }

                if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
                {
                  if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                  {
                    return_value_neko_alloc_float_449=neko_alloc_float(((struct anonymous_25 *)*sp)->f * ((struct anonymous_25 *)acc)->f);
                    acc = (signed long int)return_value_neko_alloc_float_449;
                  }

                  else
                    if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                    {
                      return_value_neko_alloc_float_450=neko_alloc_float((double)((struct anonymous_26 *)*sp)->i * ((struct anonymous_25 *)acc)->f);
                      acc = (signed long int)return_value_neko_alloc_float_450;
                    }

                    else
                      goto id_mult_next;
                  goto __CPROVER_DUMP_L708;
                }

                if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
                {
                  if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
                  {
                    if(!(((unsigned int)((struct anonymous_26 *)*sp)->i * (unsigned int)((struct anonymous_26 *)acc)->i + 1073741824u & 0x80000000) == 0u))
                    {
                      return_value_neko_alloc_int32_451=neko_alloc_int32(((struct anonymous_26 *)*sp)->i * ((struct anonymous_26 *)acc)->i);
                      tmp_if_expr_452 = return_value_neko_alloc_int32_451;
                    }

                    else
                      tmp_if_expr_452 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i * ((struct anonymous_26 *)acc)->i) << 1 | 1);
                    acc = (signed long int)tmp_if_expr_452;
                  }

                  else
                    if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                    {
                      return_value_neko_alloc_float_453=neko_alloc_float(((struct anonymous_25 *)*sp)->f * (double)((struct anonymous_26 *)acc)->i);
                      acc = (signed long int)return_value_neko_alloc_float_453;
                    }

                    else
                      goto id_mult_next;
                  goto __CPROVER_DUMP_L708;
                }

              }

            }


          id_mult_next:
            ;
            if(!((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT))
              goto id_mult_next2;

            struct _value *neko_interp_loop__1__1__1__58__1___o = (struct _value *)*sp;
            struct _value *neko_interp_loop__1__1__1__58__1___arg = (struct _value *)acc;
            struct _value *neko_interp_loop__1__1__1__58__1___f;
            neko_interp_loop__1__1__1__58__1___f=neko_val_field(neko_interp_loop__1__1__1__58__1___o, id_mult);
            if(neko_interp_loop__1__1__1__58__1___f == val_null)
              goto id_mult_next2;

            else
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand_455;
                return_value_neko_stack_expand_455=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand_455 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string_454=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string_454);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_val_callEx_456;
              return_value_neko_val_callEx_456=neko_val_callEx(neko_interp_loop__1__1__1__58__1___o, neko_interp_loop__1__1__1__58__1___f, &neko_interp_loop__1__1__1__58__1___arg, 1, (struct _value **)(void *)0);
              acc = (signed long int)return_value_neko_val_callEx_456;
              sp = vm->sp;
              csp = vm->csp;
              m = (struct _neko_module *)*csp;
              tmp_post_457 = csp;
              csp = csp - 1l;
              *tmp_post_457 = (signed long int)0;
              vm->vthis = (struct _value *)*csp;
              tmp_post_458 = csp;
              csp = csp - 1l;
              *tmp_post_458 = (signed long int)0;
              vm->env = (struct _value *)*csp;
              tmp_post_459 = csp;
              csp = csp - 1l;
              *tmp_post_459 = (signed long int)0;
              tmp_post_460 = csp;
              csp = csp - 1l;
              *tmp_post_460 = (signed long int)0;
            }
          }

          else
          {

          id_mult_next2:
            ;
            if((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT)
            {
              struct _value *neko_interp_loop__1__1__1__58__2__1___o = (struct _value *)acc;
              struct _value *neko_interp_loop__1__1__1__58__2__1___arg = (struct _value *)*sp;
              struct _value *neko_interp_loop__1__1__1__58__2__1___f;
              neko_interp_loop__1__1__1__58__2__1___f=neko_val_field(neko_interp_loop__1__1__1__58__2__1___o, id_rmult);
              if(neko_interp_loop__1__1__1__58__2__1___f == val_null)
              {
                if(csp + 4l >= sp)
                {
                  signed int return_value_neko_stack_expand_462;
                  return_value_neko_stack_expand_462=neko_stack_expand(sp, csp, vm);
                  if(!(return_value_neko_stack_expand_462 == 0))
                  {
                    sp = vm->sp;
                    csp = vm->csp;
                  }

                  else
                  {
                    return_value_neko_alloc_string_461=neko_alloc_string("Stack Overflow");
                    neko_val_throw(return_value_neko_alloc_string_461);
                  }
                }

                csp = csp + 1l;
                *csp = (signed long int)pc;
                csp = csp + 1l;
                *csp = (signed long int)vm->env;
                csp = csp + 1l;
                *csp = (signed long int)vm->vthis;
                csp = csp + 1l;
                *csp = (signed long int)m;
                vm->sp = sp;
                vm->csp = csp;
                struct _value *return_value_neko_alloc_string_463;
                return_value_neko_alloc_string_463=neko_alloc_string("Unsupported operation");
                neko_val_throw(return_value_neko_alloc_string_463);
              }

              else
              {
                if(csp + 4l >= sp)
                {
                  signed int return_value_neko_stack_expand_465;
                  return_value_neko_stack_expand_465=neko_stack_expand(sp, csp, vm);
                  if(!(return_value_neko_stack_expand_465 == 0))
                  {
                    sp = vm->sp;
                    csp = vm->csp;
                  }

                  else
                  {
                    return_value_neko_alloc_string_464=neko_alloc_string("Stack Overflow");
                    neko_val_throw(return_value_neko_alloc_string_464);
                  }
                }

                csp = csp + 1l;
                *csp = (signed long int)pc;
                csp = csp + 1l;
                *csp = (signed long int)vm->env;
                csp = csp + 1l;
                *csp = (signed long int)vm->vthis;
                csp = csp + 1l;
                *csp = (signed long int)m;
                vm->sp = sp;
                vm->csp = csp;
                struct _value *return_value_neko_val_callEx_466;
                return_value_neko_val_callEx_466=neko_val_callEx(neko_interp_loop__1__1__1__58__2__1___o, neko_interp_loop__1__1__1__58__2__1___f, &neko_interp_loop__1__1__1__58__2__1___arg, 1, (struct _value **)(void *)0);
                acc = (signed long int)return_value_neko_val_callEx_466;
                sp = vm->sp;
                csp = vm->csp;
                m = (struct _neko_module *)*csp;
                tmp_post_467 = csp;
                csp = csp - 1l;
                *tmp_post_467 = (signed long int)0;
                vm->vthis = (struct _value *)*csp;
                tmp_post_468 = csp;
                csp = csp - 1l;
                *tmp_post_468 = (signed long int)0;
                vm->env = (struct _value *)*csp;
                tmp_post_469 = csp;
                csp = csp - 1l;
                *tmp_post_469 = (signed long int)0;
                tmp_post_470 = csp;
                csp = csp - 1l;
                *tmp_post_470 = (signed long int)0;
              }
            }

            else
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand_472;
                return_value_neko_stack_expand_472=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand_472 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string_471=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string_471);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_alloc_string_473;
              return_value_neko_alloc_string_473=neko_alloc_string("Invalid operation (*)");
              neko_val_throw(return_value_neko_alloc_string_473);
            }
          }

        __CPROVER_DUMP_L708:
          ;
          tmp_post_475 = sp;
          sp = sp + 1l;
          *tmp_post_475 = (signed long int)0;
          *pc++;
          if(*pc++ == &&id_mod_next2)
            goto id_mod_next2;

          if(*pc++ == &&id_mod_next)
            goto id_mod_next;

          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

          if(*pc++ == &&LabelPhysCompare)
            goto LabelPhysCompare;

          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

          if(*pc++ == &&LabelJumpTable)
            goto LabelJumpTable;

          if(*pc++ == &&LabelNew)
            goto LabelNew;

          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(*pc++ == &&LabelCompare)
            goto LabelCompare;

          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(*pc++ == &&LabelMod)
            goto LabelMod;

          if(!(*pc++ == &&LabelDiv))
          {
            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }


        LabelDiv:
          ;
          if(!((1 & (signed int)acc) == 0))
            tmp_if_expr_503 = (_Bool)1;

          else
            tmp_if_expr_503 = (signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_503)
            tmp_if_expr_504 = (_Bool)1;

          else
            tmp_if_expr_504 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_504)
          {
            if(!((1 & (signed int)*sp) == 0))
              tmp_if_expr_505 = (_Bool)1;

            else
              tmp_if_expr_505 = (signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_505)
              tmp_if_expr_506 = (_Bool)1;

            else
              tmp_if_expr_506 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_507 = tmp_if_expr_506 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_507 = (_Bool)0;
          if(tmp_if_expr_507)
          {
            if(!((1 & (signed int)*sp) == 0))
              tmp_if_expr_477 = (double)((signed int)(signed long int)*sp >> 1);

            else
            {
              if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
                tmp_if_expr_476 = ((struct anonymous_25 *)*sp)->f;

              else
                tmp_if_expr_476 = (double)((struct anonymous_26 *)*sp)->i;
              tmp_if_expr_477 = tmp_if_expr_476;
            }
            if(!((1 & (signed int)acc) == 0))
              tmp_if_expr_479 = (double)((signed int)(signed long int)acc >> 1);

            else
            {
              if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
                tmp_if_expr_478 = ((struct anonymous_25 *)acc)->f;

              else
                tmp_if_expr_478 = (double)((struct anonymous_26 *)acc)->i;
              tmp_if_expr_479 = tmp_if_expr_478;
            }
            return_value_neko_alloc_float_480=neko_alloc_float((double)tmp_if_expr_477 / tmp_if_expr_479);
            acc = (signed long int)return_value_neko_alloc_float_480;
            goto __CPROVER_DUMP_L755;
          }

          if((1 & (signed int)*sp) == 0)
            tmp_if_expr_502 = (signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_502 = (_Bool)0;
          if(!tmp_if_expr_502)
            goto div_next;

          struct _value *neko_interp_loop__1__1__1__59___o = (struct _value *)*sp;
          struct _value *neko_interp_loop__1__1__1__59___arg = (struct _value *)acc;
          struct _value *neko_interp_loop__1__1__1__59___f;
          neko_interp_loop__1__1__1__59___f=neko_val_field(neko_interp_loop__1__1__1__59___o, id_div);
          if(neko_interp_loop__1__1__1__59___f == val_null)
            goto div_next;

          else
          {
            if(csp + 4l >= sp)
            {
              signed int return_value_neko_stack_expand_482;
              return_value_neko_stack_expand_482=neko_stack_expand(sp, csp, vm);
              if(!(return_value_neko_stack_expand_482 == 0))
              {
                sp = vm->sp;
                csp = vm->csp;
              }

              else
              {
                return_value_neko_alloc_string_481=neko_alloc_string("Stack Overflow");
                neko_val_throw(return_value_neko_alloc_string_481);
              }
            }

            csp = csp + 1l;
            *csp = (signed long int)pc;
            csp = csp + 1l;
            *csp = (signed long int)vm->env;
            csp = csp + 1l;
            *csp = (signed long int)vm->vthis;
            csp = csp + 1l;
            *csp = (signed long int)m;
            vm->sp = sp;
            vm->csp = csp;
            struct _value *return_value_neko_val_callEx_483;
            return_value_neko_val_callEx_483=neko_val_callEx(neko_interp_loop__1__1__1__59___o, neko_interp_loop__1__1__1__59___f, &neko_interp_loop__1__1__1__59___arg, 1, (struct _value **)(void *)0);
            acc = (signed long int)return_value_neko_val_callEx_483;
            sp = vm->sp;
            csp = vm->csp;
            m = (struct _neko_module *)*csp;
            tmp_post_484 = csp;
            csp = csp - 1l;
            *tmp_post_484 = (signed long int)0;
            vm->vthis = (struct _value *)*csp;
            tmp_post_485 = csp;
            csp = csp - 1l;
            *tmp_post_485 = (signed long int)0;
            vm->env = (struct _value *)*csp;
            tmp_post_486 = csp;
            csp = csp - 1l;
            *tmp_post_486 = (signed long int)0;
            tmp_post_487 = csp;
            csp = csp - 1l;
            *tmp_post_487 = (signed long int)0;
          }
        }

        else
        {

        div_next:
          ;
          if((1 & (signed int)acc) == 0)
            tmp_if_expr_501 = (signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_501 = (_Bool)0;
          if(tmp_if_expr_501)
          {
            struct _value *neko_interp_loop__1__1__1__60__1___o = (struct _value *)acc;
            struct _value *neko_interp_loop__1__1__1__60__1___arg = (struct _value *)*sp;
            struct _value *neko_interp_loop__1__1__1__60__1___f;
            neko_interp_loop__1__1__1__60__1___f=neko_val_field(neko_interp_loop__1__1__1__60__1___o, id_rdiv);
            if(neko_interp_loop__1__1__1__60__1___f == val_null)
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand_489;
                return_value_neko_stack_expand_489=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand_489 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string_488=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string_488);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_alloc_string_490;
              return_value_neko_alloc_string_490=neko_alloc_string("Unsupported operation");
              neko_val_throw(return_value_neko_alloc_string_490);
            }

            else
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand_492;
                return_value_neko_stack_expand_492=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand_492 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string_491=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string_491);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_val_callEx_493;
              return_value_neko_val_callEx_493=neko_val_callEx(neko_interp_loop__1__1__1__60__1___o, neko_interp_loop__1__1__1__60__1___f, &neko_interp_loop__1__1__1__60__1___arg, 1, (struct _value **)(void *)0);
              acc = (signed long int)return_value_neko_val_callEx_493;
              sp = vm->sp;
              csp = vm->csp;
              m = (struct _neko_module *)*csp;
              tmp_post_494 = csp;
              csp = csp - 1l;
              *tmp_post_494 = (signed long int)0;
              vm->vthis = (struct _value *)*csp;
              tmp_post_495 = csp;
              csp = csp - 1l;
              *tmp_post_495 = (signed long int)0;
              vm->env = (struct _value *)*csp;
              tmp_post_496 = csp;
              csp = csp - 1l;
              *tmp_post_496 = (signed long int)0;
              tmp_post_497 = csp;
              csp = csp - 1l;
              *tmp_post_497 = (signed long int)0;
            }
          }

          else
          {
            if(csp + 4l >= sp)
            {
              signed int return_value_neko_stack_expand_499;
              return_value_neko_stack_expand_499=neko_stack_expand(sp, csp, vm);
              if(!(return_value_neko_stack_expand_499 == 0))
              {
                sp = vm->sp;
                csp = vm->csp;
              }

              else
              {
                return_value_neko_alloc_string_498=neko_alloc_string("Stack Overflow");
                neko_val_throw(return_value_neko_alloc_string_498);
              }
            }

            csp = csp + 1l;
            *csp = (signed long int)pc;
            csp = csp + 1l;
            *csp = (signed long int)vm->env;
            csp = csp + 1l;
            *csp = (signed long int)vm->vthis;
            csp = csp + 1l;
            *csp = (signed long int)m;
            vm->sp = sp;
            vm->csp = csp;
            struct _value *return_value_neko_alloc_string_500;
            return_value_neko_alloc_string_500=neko_alloc_string("Invalid operation (/)");
            neko_val_throw(return_value_neko_alloc_string_500);
          }
        }

      __CPROVER_DUMP_L755:
        ;
        tmp_post_508 = sp;
        sp = sp + 1l;
        *tmp_post_508 = (signed long int)0;
        *pc++;
        if(*pc++ == &&id_mod_next2)
          goto id_mod_next2;

        if(!(*pc++ == &&id_mod_next))
        {
          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

          if(*pc++ == &&LabelPhysCompare)
            goto LabelPhysCompare;

          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

          if(*pc++ == &&LabelJumpTable)
            goto LabelJumpTable;

          if(*pc++ == &&LabelNew)
            goto LabelNew;

          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(*pc++ == &&LabelCompare)
            goto LabelCompare;

          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(!(*pc++ == &&LabelMod))
          {
            if(*pc++ == &&LabelDiv)
              goto LabelDiv;

            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }


        LabelMod:
          ;
          if(acc == 1l)
            tmp_if_expr_515 = (_Bool)1;

          else
          {
            if((1 & (signed int)acc) == 0)
              tmp_if_expr_513 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_513 = (_Bool)0;
            if(tmp_if_expr_513)
              tmp_if_expr_514 = ((struct anonymous_26 *)acc)->i == 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_514 = (_Bool)0;
            tmp_if_expr_515 = tmp_if_expr_514 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_515)
          {
            if(!((1 & (signed int)*sp) == 0))
              tmp_if_expr_512 = (_Bool)1;

            else
              tmp_if_expr_512 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_512)
            {
              if(csp + 4l >= sp)
              {
                signed int return_value_neko_stack_expand_510;
                return_value_neko_stack_expand_510=neko_stack_expand(sp, csp, vm);
                if(!(return_value_neko_stack_expand_510 == 0))
                {
                  sp = vm->sp;
                  csp = vm->csp;
                }

                else
                {
                  return_value_neko_alloc_string_509=neko_alloc_string("Stack Overflow");
                  neko_val_throw(return_value_neko_alloc_string_509);
                }
              }

              csp = csp + 1l;
              *csp = (signed long int)pc;
              csp = csp + 1l;
              *csp = (signed long int)vm->env;
              csp = csp + 1l;
              *csp = (signed long int)vm->vthis;
              csp = csp + 1l;
              *csp = (signed long int)m;
              vm->sp = sp;
              vm->csp = csp;
              struct _value *return_value_neko_alloc_string_511;
              return_value_neko_alloc_string_511=neko_alloc_string("Invalid operation (%)");
              neko_val_throw(return_value_neko_alloc_string_511);
            }

          }

          if(!((1l & acc) == 0l))
            tmp_if_expr_580 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_580 = (_Bool)0;
          if(tmp_if_expr_580)
          {
            if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) % ((signed int)acc >> 1)) & 0x80000000) == 0u))
            {
              return_value_neko_alloc_int32_516=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) % ((signed int)(signed long int)acc >> 1));
              tmp_if_expr_517 = return_value_neko_alloc_int32_516;
            }

            else
              tmp_if_expr_517 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) % ((signed int)(signed long int)acc >> 1)) << 1 | 1);
            acc = (signed long int)tmp_if_expr_517;
            goto __CPROVER_DUMP_L849;
          }

          if(!((1l & acc) == 0l))
          {
            if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
            {
              return_value_fmod_518=fmod(((struct anonymous_25 *)*sp)->f, (double)((signed int)(signed long int)acc >> 1));
              return_value_neko_alloc_float_519=neko_alloc_float(return_value_fmod_518);
              acc = (signed long int)return_value_neko_alloc_float_519;
            }

            else
              if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
              {
                if(!((1073741824u + (unsigned int)(((struct anonymous_26 *)*sp)->i % ((signed int)acc >> 1)) & 0x80000000) == 0u))
                {
                  return_value_neko_alloc_int32_520=neko_alloc_int32(((struct anonymous_26 *)*sp)->i % ((signed int)(signed long int)acc >> 1));
                  tmp_if_expr_521 = return_value_neko_alloc_int32_520;
                }

                else
                  tmp_if_expr_521 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i % ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                acc = (signed long int)tmp_if_expr_521;
              }

              else
                if((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT)
                {
                  struct _value *neko_interp_loop__1__1__1__62__1___o = (struct _value *)*sp;
                  struct _value *neko_interp_loop__1__1__1__62__1___arg = (struct _value *)acc;
                  struct _value *neko_interp_loop__1__1__1__62__1___f;
                  neko_interp_loop__1__1__1__62__1___f=neko_val_field(neko_interp_loop__1__1__1__62__1___o, id_mod);
                  if(neko_interp_loop__1__1__1__62__1___f == val_null)
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand_523;
                      return_value_neko_stack_expand_523=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand_523 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string_522=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string_522);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_alloc_string_524;
                    return_value_neko_alloc_string_524=neko_alloc_string("Unsupported operation");
                    neko_val_throw(return_value_neko_alloc_string_524);
                  }

                  else
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand_526;
                      return_value_neko_stack_expand_526=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand_526 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string_525=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string_525);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_val_callEx_527;
                    return_value_neko_val_callEx_527=neko_val_callEx(neko_interp_loop__1__1__1__62__1___o, neko_interp_loop__1__1__1__62__1___f, &neko_interp_loop__1__1__1__62__1___arg, 1, (struct _value **)(void *)0);
                    acc = (signed long int)return_value_neko_val_callEx_527;
                    sp = vm->sp;
                    csp = vm->csp;
                    m = (struct _neko_module *)*csp;
                    tmp_post_528 = csp;
                    csp = csp - 1l;
                    *tmp_post_528 = (signed long int)0;
                    vm->vthis = (struct _value *)*csp;
                    tmp_post_529 = csp;
                    csp = csp - 1l;
                    *tmp_post_529 = (signed long int)0;
                    vm->env = (struct _value *)*csp;
                    tmp_post_530 = csp;
                    csp = csp - 1l;
                    *tmp_post_530 = (signed long int)0;
                    tmp_post_531 = csp;
                    csp = csp - 1l;
                    *tmp_post_531 = (signed long int)0;
                  }
                }

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand_533;
                    return_value_neko_stack_expand_533=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand_533 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string_532=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string_532);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_alloc_string_534;
                  return_value_neko_alloc_string_534=neko_alloc_string("Invalid operation (%)");
                  neko_val_throw(return_value_neko_alloc_string_534);
                }
            goto __CPROVER_DUMP_L849;
          }

          if(!((1l & *sp) == 0l))
          {
            if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
            {
              return_value_fmod_535=fmod((double)((signed int)(signed long int)*sp >> 1), ((struct anonymous_25 *)acc)->f);
              return_value_neko_alloc_float_536=neko_alloc_float(return_value_fmod_535);
              acc = (signed long int)return_value_neko_alloc_float_536;
            }

            else
              if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
              {
                if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) % ((struct anonymous_26 *)acc)->i) & 0x80000000) == 0u))
                {
                  return_value_neko_alloc_int32_537=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) % ((struct anonymous_26 *)acc)->i);
                  tmp_if_expr_538 = return_value_neko_alloc_int32_537;
                }

                else
                  tmp_if_expr_538 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) % ((struct anonymous_26 *)acc)->i) << 1 | 1);
                acc = (signed long int)tmp_if_expr_538;
              }

              else
                if((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT)
                {
                  struct _value *neko_interp_loop__1__1__1__63__1___o = (struct _value *)acc;
                  struct _value *neko_interp_loop__1__1__1__63__1___arg = (struct _value *)*sp;
                  struct _value *neko_interp_loop__1__1__1__63__1___f;
                  neko_interp_loop__1__1__1__63__1___f=neko_val_field(neko_interp_loop__1__1__1__63__1___o, id_rmod);
                  if(neko_interp_loop__1__1__1__63__1___f == val_null)
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand_540;
                      return_value_neko_stack_expand_540=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand_540 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string_539=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string_539);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_alloc_string_541;
                    return_value_neko_alloc_string_541=neko_alloc_string("Unsupported operation");
                    neko_val_throw(return_value_neko_alloc_string_541);
                  }

                  else
                  {
                    if(csp + 4l >= sp)
                    {
                      signed int return_value_neko_stack_expand_543;
                      return_value_neko_stack_expand_543=neko_stack_expand(sp, csp, vm);
                      if(!(return_value_neko_stack_expand_543 == 0))
                      {
                        sp = vm->sp;
                        csp = vm->csp;
                      }

                      else
                      {
                        return_value_neko_alloc_string_542=neko_alloc_string("Stack Overflow");
                        neko_val_throw(return_value_neko_alloc_string_542);
                      }
                    }

                    csp = csp + 1l;
                    *csp = (signed long int)pc;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->env;
                    csp = csp + 1l;
                    *csp = (signed long int)vm->vthis;
                    csp = csp + 1l;
                    *csp = (signed long int)m;
                    vm->sp = sp;
                    vm->csp = csp;
                    struct _value *return_value_neko_val_callEx_544;
                    return_value_neko_val_callEx_544=neko_val_callEx(neko_interp_loop__1__1__1__63__1___o, neko_interp_loop__1__1__1__63__1___f, &neko_interp_loop__1__1__1__63__1___arg, 1, (struct _value **)(void *)0);
                    acc = (signed long int)return_value_neko_val_callEx_544;
                    sp = vm->sp;
                    csp = vm->csp;
                    m = (struct _neko_module *)*csp;
                    tmp_post_545 = csp;
                    csp = csp - 1l;
                    *tmp_post_545 = (signed long int)0;
                    vm->vthis = (struct _value *)*csp;
                    tmp_post_546 = csp;
                    csp = csp - 1l;
                    *tmp_post_546 = (signed long int)0;
                    vm->env = (struct _value *)*csp;
                    tmp_post_547 = csp;
                    csp = csp - 1l;
                    *tmp_post_547 = (signed long int)0;
                    tmp_post_548 = csp;
                    csp = csp - 1l;
                    *tmp_post_548 = (signed long int)0;
                  }
                }

                else
                {
                  if(csp + 4l >= sp)
                  {
                    signed int return_value_neko_stack_expand_550;
                    return_value_neko_stack_expand_550=neko_stack_expand(sp, csp, vm);
                    if(!(return_value_neko_stack_expand_550 == 0))
                    {
                      sp = vm->sp;
                      csp = vm->csp;
                    }

                    else
                    {
                      return_value_neko_alloc_string_549=neko_alloc_string("Stack Overflow");
                      neko_val_throw(return_value_neko_alloc_string_549);
                    }
                  }

                  csp = csp + 1l;
                  *csp = (signed long int)pc;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->env;
                  csp = csp + 1l;
                  *csp = (signed long int)vm->vthis;
                  csp = csp + 1l;
                  *csp = (signed long int)m;
                  vm->sp = sp;
                  vm->csp = csp;
                  struct _value *return_value_neko_alloc_string_551;
                  return_value_neko_alloc_string_551=neko_alloc_string("Invalid operation (%)");
                  neko_val_throw(return_value_neko_alloc_string_551);
                }
            goto __CPROVER_DUMP_L849;
          }

          if((signed int)*((enum anonymous_7 *)acc) == VAL_FLOAT)
          {
            if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
            {
              return_value_fmod_552=fmod(((struct anonymous_25 *)*sp)->f, ((struct anonymous_25 *)acc)->f);
              return_value_neko_alloc_float_553=neko_alloc_float(return_value_fmod_552);
              acc = (signed long int)return_value_neko_alloc_float_553;
            }

            else
              if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
              {
                return_value_fmod_554=fmod((double)((struct anonymous_26 *)*sp)->i, ((struct anonymous_25 *)acc)->f);
                return_value_neko_alloc_float_555=neko_alloc_float(return_value_fmod_554);
                acc = (signed long int)return_value_neko_alloc_float_555;
              }

              else
                goto id_mod_next;
            goto __CPROVER_DUMP_L849;
          }

          if((signed int)*((enum anonymous_7 *)acc) == VAL_INT32)
          {
            if((signed int)*((enum anonymous_7 *)*sp) == VAL_INT32)
            {
              if(!((1073741824u + (unsigned int)(((struct anonymous_26 *)*sp)->i % ((struct anonymous_26 *)acc)->i) & 0x80000000) == 0u))
              {
                return_value_neko_alloc_int32_556=neko_alloc_int32(((struct anonymous_26 *)*sp)->i % ((struct anonymous_26 *)acc)->i);
                tmp_if_expr_557 = return_value_neko_alloc_int32_556;
              }

              else
                tmp_if_expr_557 = (struct _value *)(signed long int)((signed int)(((struct anonymous_26 *)*sp)->i % ((struct anonymous_26 *)acc)->i) << 1 | 1);
              acc = (signed long int)tmp_if_expr_557;
            }

            else
              if((signed int)*((enum anonymous_7 *)*sp) == VAL_FLOAT)
              {
                return_value_fmod_558=fmod(((struct anonymous_25 *)*sp)->f, (double)((struct anonymous_26 *)acc)->i);
                return_value_neko_alloc_float_559=neko_alloc_float(return_value_fmod_558);
                acc = (signed long int)return_value_neko_alloc_float_559;
              }

              else
                goto id_mod_next;
            goto __CPROVER_DUMP_L849;
          }

        }

      }


    id_mod_next:
      ;
      if(!((signed int)*((enum anonymous_7 *)*sp) == VAL_OBJECT))
        goto id_mod_next2;

      struct _value *neko_interp_loop__1__1__1__66__1___o = (struct _value *)*sp;
      struct _value *neko_interp_loop__1__1__1__66__1___arg = (struct _value *)acc;
      struct _value *neko_interp_loop__1__1__1__66__1___f;
      neko_interp_loop__1__1__1__66__1___f=neko_val_field(neko_interp_loop__1__1__1__66__1___o, id_mod);
      if(neko_interp_loop__1__1__1__66__1___f == val_null)
        goto id_mod_next2;

      else
      {
        if(csp + 4l >= sp)
        {
          signed int return_value_neko_stack_expand_561;
          return_value_neko_stack_expand_561=neko_stack_expand(sp, csp, vm);
          if(!(return_value_neko_stack_expand_561 == 0))
          {
            sp = vm->sp;
            csp = vm->csp;
          }

          else
          {
            return_value_neko_alloc_string_560=neko_alloc_string("Stack Overflow");
            neko_val_throw(return_value_neko_alloc_string_560);
          }
        }

        csp = csp + 1l;
        *csp = (signed long int)pc;
        csp = csp + 1l;
        *csp = (signed long int)vm->env;
        csp = csp + 1l;
        *csp = (signed long int)vm->vthis;
        csp = csp + 1l;
        *csp = (signed long int)m;
        vm->sp = sp;
        vm->csp = csp;
        struct _value *return_value_neko_val_callEx_562;
        return_value_neko_val_callEx_562=neko_val_callEx(neko_interp_loop__1__1__1__66__1___o, neko_interp_loop__1__1__1__66__1___f, &neko_interp_loop__1__1__1__66__1___arg, 1, (struct _value **)(void *)0);
        acc = (signed long int)return_value_neko_val_callEx_562;
        sp = vm->sp;
        csp = vm->csp;
        m = (struct _neko_module *)*csp;
        tmp_post_563 = csp;
        csp = csp - 1l;
        *tmp_post_563 = (signed long int)0;
        vm->vthis = (struct _value *)*csp;
        tmp_post_564 = csp;
        csp = csp - 1l;
        *tmp_post_564 = (signed long int)0;
        vm->env = (struct _value *)*csp;
        tmp_post_565 = csp;
        csp = csp - 1l;
        *tmp_post_565 = (signed long int)0;
        tmp_post_566 = csp;
        csp = csp - 1l;
        *tmp_post_566 = (signed long int)0;
      }
    }

    else
    {

    id_mod_next2:
      ;
      if((signed int)*((enum anonymous_7 *)acc) == VAL_OBJECT)
      {
        struct _value *neko_interp_loop__1__1__1__66__2__1___o = (struct _value *)acc;
        struct _value *neko_interp_loop__1__1__1__66__2__1___arg = (struct _value *)*sp;
        struct _value *neko_interp_loop__1__1__1__66__2__1___f;
        neko_interp_loop__1__1__1__66__2__1___f=neko_val_field(neko_interp_loop__1__1__1__66__2__1___o, id_rmod);
        if(neko_interp_loop__1__1__1__66__2__1___f == val_null)
        {
          if(csp + 4l >= sp)
          {
            signed int return_value_neko_stack_expand_568;
            return_value_neko_stack_expand_568=neko_stack_expand(sp, csp, vm);
            if(!(return_value_neko_stack_expand_568 == 0))
            {
              sp = vm->sp;
              csp = vm->csp;
            }

            else
            {
              return_value_neko_alloc_string_567=neko_alloc_string("Stack Overflow");
              neko_val_throw(return_value_neko_alloc_string_567);
            }
          }

          csp = csp + 1l;
          *csp = (signed long int)pc;
          csp = csp + 1l;
          *csp = (signed long int)vm->env;
          csp = csp + 1l;
          *csp = (signed long int)vm->vthis;
          csp = csp + 1l;
          *csp = (signed long int)m;
          vm->sp = sp;
          vm->csp = csp;
          struct _value *return_value_neko_alloc_string_569;
          return_value_neko_alloc_string_569=neko_alloc_string("Unsupported operation");
          neko_val_throw(return_value_neko_alloc_string_569);
        }

        else
        {
          if(csp + 4l >= sp)
          {
            signed int return_value_neko_stack_expand_571;
            return_value_neko_stack_expand_571=neko_stack_expand(sp, csp, vm);
            if(!(return_value_neko_stack_expand_571 == 0))
            {
              sp = vm->sp;
              csp = vm->csp;
            }

            else
            {
              return_value_neko_alloc_string_570=neko_alloc_string("Stack Overflow");
              neko_val_throw(return_value_neko_alloc_string_570);
            }
          }

          csp = csp + 1l;
          *csp = (signed long int)pc;
          csp = csp + 1l;
          *csp = (signed long int)vm->env;
          csp = csp + 1l;
          *csp = (signed long int)vm->vthis;
          csp = csp + 1l;
          *csp = (signed long int)m;
          vm->sp = sp;
          vm->csp = csp;
          struct _value *return_value_neko_val_callEx_572;
          return_value_neko_val_callEx_572=neko_val_callEx(neko_interp_loop__1__1__1__66__2__1___o, neko_interp_loop__1__1__1__66__2__1___f, &neko_interp_loop__1__1__1__66__2__1___arg, 1, (struct _value **)(void *)0);
          acc = (signed long int)return_value_neko_val_callEx_572;
          sp = vm->sp;
          csp = vm->csp;
          m = (struct _neko_module *)*csp;
          tmp_post_573 = csp;
          csp = csp - 1l;
          *tmp_post_573 = (signed long int)0;
          vm->vthis = (struct _value *)*csp;
          tmp_post_574 = csp;
          csp = csp - 1l;
          *tmp_post_574 = (signed long int)0;
          vm->env = (struct _value *)*csp;
          tmp_post_575 = csp;
          csp = csp - 1l;
          *tmp_post_575 = (signed long int)0;
          tmp_post_576 = csp;
          csp = csp - 1l;
          *tmp_post_576 = (signed long int)0;
        }
      }

      else
      {
        if(csp + 4l >= sp)
        {
          signed int return_value_neko_stack_expand_578;
          return_value_neko_stack_expand_578=neko_stack_expand(sp, csp, vm);
          if(!(return_value_neko_stack_expand_578 == 0))
          {
            sp = vm->sp;
            csp = vm->csp;
          }

          else
          {
            return_value_neko_alloc_string_577=neko_alloc_string("Stack Overflow");
            neko_val_throw(return_value_neko_alloc_string_577);
          }
        }

        csp = csp + 1l;
        *csp = (signed long int)pc;
        csp = csp + 1l;
        *csp = (signed long int)vm->env;
        csp = csp + 1l;
        *csp = (signed long int)vm->vthis;
        csp = csp + 1l;
        *csp = (signed long int)m;
        vm->sp = sp;
        vm->csp = csp;
        struct _value *return_value_neko_alloc_string_579;
        return_value_neko_alloc_string_579=neko_alloc_string("Invalid operation (%)");
        neko_val_throw(return_value_neko_alloc_string_579);
      }
    }

  __CPROVER_DUMP_L849:
    ;
    tmp_post_581 = sp;
    sp = sp + 1l;
    *tmp_post_581 = (signed long int)0;
    *pc++;
    if(*pc++ == &&id_mod_next2)
      goto id_mod_next2;

    if(*pc++ == &&id_mod_next)
      goto id_mod_next;

    if(*pc++ == &&div_next)
      goto div_next;

    if(*pc++ == &&id_mult_next2)
      goto id_mult_next2;

    if(*pc++ == &&id_mult_next)
      goto id_mult_next;

    if(*pc++ == &&id_sub_next2)
      goto id_sub_next2;

    if(*pc++ == &&id_sub_next)
      goto id_sub_next;

    if(*pc++ == &&add_3)
      goto add_3;

    if(*pc++ == &&add_2)
      goto add_2;

    if(*pc++ == &&add_next)
      goto add_next;

    if(*pc++ == &&do_call)
      goto LabelCall;

    if(!(*pc++ == &&LabelLast))
    {
      if(*pc++ == &&LabelAccInt32)
        goto LabelAccInt32;

      if(*pc++ == &&LabelMakeArray2)
        goto LabelMakeArray2;

      if(!(*pc++ == &&LabelLoop))
      {
        if(*pc++ == &&LabelTailCall)
          goto LabelTailCall;

        if(!(*pc++ == &&LabelPhysCompare))
        {
          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

          if(*pc++ == &&LabelJumpTable)
            goto LabelJumpTable;

          if(*pc++ == &&LabelNew)
            goto LabelNew;

          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(!(*pc++ == &&LabelCompare))
          {
            if(!(*pc++ == &&LabelTypeOf))
            {
              if(*pc++ == &&LabelNot)
                goto LabelNot;

              if(!(*pc++ == &&LabelLte))
              {
                if(!(*pc++ == &&LabelLt))
                {
                  if(*pc++ == &&LabelGte)
                    goto LabelGte;

                  if(*pc++ == &&LabelGt)
                    goto LabelGt;

                  if(!(*pc++ == &&LabelNeq))
                  {
                    if(!(*pc++ == &&LabelEq))
                    {
                      if(!(*pc++ == &&LabelXor))
                      {
                        if(!(*pc++ == &&LabelAnd))
                        {
                          if(!(*pc++ == &&LabelOr))
                          {
                            if(!(*pc++ == &&LabelUShr))
                            {
                              if(!(*pc++ == &&LabelShr))
                              {
                                if(!(*pc++ == &&LabelShl))
                                {
                                  if(*pc++ == &&LabelMod)
                                    goto LabelMod;

                                  if(*pc++ == &&LabelDiv)
                                    goto LabelDiv;

                                  if(*pc++ == &&LabelMult)
                                    goto LabelMult;

                                  if(*pc++ == &&LabelSub)
                                    goto LabelSub;

                                  if(*pc++ == &&LabelAdd)
                                    goto LabelAdd;

                                  if(*pc++ == &&LabelIsNotNull)
                                    goto LabelIsNotNull;

                                  if(*pc++ == &&LabelIsNull)
                                    goto LabelIsNull;

                                  if(*pc++ == &&LabelBool)
                                    goto LabelBool;

                                  if(*pc++ == &&LabelMakeArray)
                                    goto LabelMakeArray;

                                  if(*pc++ == &&LabelMakeEnv)
                                    goto LabelMakeEnv;

                                  if(*pc++ == &&LabelRet)
                                    goto LabelRet;

                                  if(*pc++ == &&LabelEndTrap)
                                    goto LabelEndTrap;

                                  if(*pc++ == &&LabelTrap)
                                    goto LabelTrap;

                                  if(*pc++ == &&LabelJumpIfNot)
                                    goto LabelJumpIfNot;

                                  if(*pc++ == &&LabelJumpIf)
                                    goto LabelJumpIf;

                                  if(*pc++ == &&LabelJump)
                                    goto LabelJump;

                                  if(*pc++ == &&LabelObjCall)
                                    goto LabelObjCall;

                                  if(*pc++ == &&LabelCall)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelPop)
                                    goto LabelPop;

                                  if(*pc++ == &&LabelPush)
                                    goto LabelPush;

                                  if(*pc++ == &&LabelSetThis)
                                    goto LabelSetThis;

                                  if(*pc++ == &&LabelSetIndex)
                                    goto LabelSetIndex;

                                  if(*pc++ == &&LabelSetArray)
                                    goto LabelSetArray;

                                  if(*pc++ == &&LabelSetField)
                                    goto LabelSetField;

                                  if(*pc++ == &&LabelSetEnv)
                                    goto LabelSetEnv;

                                  if(*pc++ == &&LabelSetGlobal)
                                    goto LabelSetGlobal;

                                  if(*pc++ == &&LabelSetStack)
                                    goto LabelSetStack;

                                  if(*pc++ == &&LabelAccBuiltin)
                                    goto LabelAccBuiltin;

                                  if(*pc++ == &&LabelAccIndex)
                                    goto LabelAccIndex;

                                  if(*pc++ == &&LabelAccArray)
                                    goto LabelAccArray;

                                  if(*pc++ == &&LabelAccField)
                                    goto LabelAccField;

                                  if(*pc++ == &&LabelAccEnv)
                                    goto LabelAccEnv;

                                  if(*pc++ == &&LabelAccGlobal)
                                    goto LabelAccGlobal;

                                  if(*pc++ == &&LabelAccStack)
                                    goto LabelAccStack;

                                  if(*pc++ == &&LabelAccInt)
                                    goto LabelAccInt;

                                  if(*pc++ == &&LabelAccThis)
                                    goto LabelAccThis;

                                  if(*pc++ == &&LabelAccFalse)
                                    goto LabelAccFalse;

                                  if(*pc++ == &&LabelAccTrue)
                                    goto LabelAccTrue;

                                  if(*pc++ == &&LabelAccNull)
                                    goto LabelAccNull;

                                  if(*pc++ == &&end)
                                    goto end;

                                }

                                do
                                {

                                LabelShl:
                                  ;
                                  if(!((1l & acc) == 0l))
                                    tmp_if_expr_598 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                                  else
                                    tmp_if_expr_598 = (_Bool)0;
                                  if(tmp_if_expr_598)
                                  {
                                    if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) << ((signed int)acc >> 1)) & 0x80000000) == 0u))
                                    {
                                      return_value_neko_alloc_int32_582=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) << ((signed int)(signed long int)acc >> 1));
                                      tmp_if_expr_583 = return_value_neko_alloc_int32_582;
                                    }

                                    else
                                      tmp_if_expr_583 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) << ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                                    acc = (signed long int)tmp_if_expr_583;
                                  }

                                  else
                                  {
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr_595 = (_Bool)1;

                                    else
                                      tmp_if_expr_595 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                    if(tmp_if_expr_595)
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr_596 = (_Bool)1;

                                      else
                                        tmp_if_expr_596 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                      tmp_if_expr_597 = tmp_if_expr_596 ? (_Bool)1 : (_Bool)0;
                                    }

                                    else
                                      tmp_if_expr_597 = (_Bool)0;
                                    if(tmp_if_expr_597)
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr_584 = (signed int)(signed long int)*sp >> 1;

                                      else
                                        tmp_if_expr_584 = ((struct anonymous_26 *)*sp)->i;
                                      if(!((1 & (signed int)acc) == 0))
                                        tmp_if_expr_585 = (signed int)(signed long int)acc >> 1;

                                      else
                                        tmp_if_expr_585 = ((struct anonymous_26 *)acc)->i;
                                      if(!((1073741824u + (unsigned int)(tmp_if_expr_584 << tmp_if_expr_585) & 0x80000000) == 0u))
                                      {
                                        if(!((1 & (signed int)*sp) == 0))
                                          tmp_if_expr_586 = (signed int)(signed long int)*sp >> 1;

                                        else
                                          tmp_if_expr_586 = ((struct anonymous_26 *)*sp)->i;
                                        if(!((1 & (signed int)acc) == 0))
                                          tmp_if_expr_587 = (signed int)(signed long int)acc >> 1;

                                        else
                                          tmp_if_expr_587 = ((struct anonymous_26 *)acc)->i;
                                        return_value_neko_alloc_int32_588=neko_alloc_int32(tmp_if_expr_586 << tmp_if_expr_587);
                                        tmp_if_expr_591 = return_value_neko_alloc_int32_588;
                                      }

                                      else
                                      {
                                        if(!((1 & (signed int)*sp) == 0))
                                          tmp_if_expr_589 = (signed int)(signed long int)*sp >> 1;

                                        else
                                          tmp_if_expr_589 = ((struct anonymous_26 *)*sp)->i;
                                        if(!((1 & (signed int)acc) == 0))
                                          tmp_if_expr_590 = (signed int)(signed long int)acc >> 1;

                                        else
                                          tmp_if_expr_590 = ((struct anonymous_26 *)acc)->i;
                                        tmp_if_expr_591 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_589 << tmp_if_expr_590) << 1 | 1);
                                      }
                                      acc = (signed long int)tmp_if_expr_591;
                                    }

                                    else
                                    {
                                      if(csp + 4l >= sp)
                                      {
                                        signed int return_value_neko_stack_expand_593;
                                        return_value_neko_stack_expand_593=neko_stack_expand(sp, csp, vm);
                                        if(!(return_value_neko_stack_expand_593 == 0))
                                        {
                                          sp = vm->sp;
                                          csp = vm->csp;
                                        }

                                        else
                                        {
                                          return_value_neko_alloc_string_592=neko_alloc_string("Stack Overflow");
                                          neko_val_throw(return_value_neko_alloc_string_592);
                                        }
                                      }

                                      csp = csp + 1l;
                                      *csp = (signed long int)pc;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->env;
                                      csp = csp + 1l;
                                      *csp = (signed long int)vm->vthis;
                                      csp = csp + 1l;
                                      *csp = (signed long int)m;
                                      vm->sp = sp;
                                      vm->csp = csp;
                                      struct _value *return_value_neko_alloc_string_594;
                                      return_value_neko_alloc_string_594=neko_alloc_string("Invalid operation (<<)");
                                      neko_val_throw(return_value_neko_alloc_string_594);
                                    }
                                  }
                                  tmp_post_599 = sp;
                                  sp = sp + 1l;
                                  *tmp_post_599 = (signed long int)0;
                                  *pc++;
                                  if(*pc++ == &&id_mod_next2)
                                    goto id_mod_next2;

                                  if(*pc++ == &&id_mod_next)
                                    goto id_mod_next;

                                  if(*pc++ == &&div_next)
                                    goto div_next;

                                  if(*pc++ == &&id_mult_next2)
                                    goto id_mult_next2;

                                  if(*pc++ == &&id_mult_next)
                                    goto id_mult_next;

                                  if(*pc++ == &&id_sub_next2)
                                    goto id_sub_next2;

                                  if(*pc++ == &&id_sub_next)
                                    goto id_sub_next;

                                  if(*pc++ == &&add_3)
                                    goto add_3;

                                  if(*pc++ == &&add_2)
                                    goto add_2;

                                  if(*pc++ == &&add_next)
                                    goto add_next;

                                  if(*pc++ == &&do_call)
                                    goto LabelCall;

                                  if(*pc++ == &&LabelLast)
                                    goto LabelLast;

                                  if(*pc++ == &&LabelAccInt32)
                                    goto LabelAccInt32;

                                  if(*pc++ == &&LabelMakeArray2)
                                    goto LabelMakeArray2;

                                  if(*pc++ == &&LabelLoop)
                                    goto LabelLoop;

                                  if(*pc++ == &&LabelTailCall)
                                    goto LabelTailCall;

                                  if(*pc++ == &&LabelPhysCompare)
                                    goto LabelPhysCompare;

                                  if(*pc++ == &&LabelAccIndex1)
                                    goto LabelAccIndex1;

                                  if(*pc++ == &&LabelAccIndex0)
                                    goto LabelAccIndex0;

                                  if(*pc++ == &&LabelAccStack1)
                                    goto LabelAccStack1;

                                  if(*pc++ == &&LabelAccStack0)
                                    goto LabelAccStack0;

                                  if(*pc++ == &&LabelApply)
                                    goto LabelApply;

                                  if(*pc++ == &&LabelJumpTable)
                                    goto LabelJumpTable;

                                  if(*pc++ == &&LabelNew)
                                    goto LabelNew;

                                  if(*pc++ == &&LabelHash)
                                    goto LabelHash;

                                  if(*pc++ == &&LabelCompare)
                                    goto LabelCompare;

                                  if(*pc++ == &&LabelTypeOf)
                                    goto LabelTypeOf;

                                  if(*pc++ == &&LabelNot)
                                    goto LabelNot;

                                  if(*pc++ == &&LabelLte)
                                    goto LabelLte;

                                  if(*pc++ == &&LabelLt)
                                    goto LabelLt;

                                  if(*pc++ == &&LabelGte)
                                    goto LabelGte;

                                  if(*pc++ == &&LabelGt)
                                    goto LabelGt;

                                  if(*pc++ == &&LabelNeq)
                                    goto LabelNeq;

                                  if(*pc++ == &&LabelEq)
                                    goto LabelEq;

                                  if(*pc++ == &&LabelXor)
                                    goto LabelXor;

                                  if(*pc++ == &&LabelAnd)
                                    goto LabelAnd;

                                  if(*pc++ == &&LabelOr)
                                    goto LabelOr;

                                  if(*pc++ == &&LabelUShr)
                                    goto LabelUShr;

                                  if(*pc++ == &&LabelShr)
                                    goto LabelShr;

                                }
                                while(*pc++ == &&LabelShl);
                                if(*pc++ == &&LabelMod)
                                  goto LabelMod;

                                if(*pc++ == &&LabelDiv)
                                  goto LabelDiv;

                                if(*pc++ == &&LabelMult)
                                  goto LabelMult;

                                if(*pc++ == &&LabelSub)
                                  goto LabelSub;

                                if(*pc++ == &&LabelAdd)
                                  goto LabelAdd;

                                if(*pc++ == &&LabelIsNotNull)
                                  goto LabelIsNotNull;

                                if(*pc++ == &&LabelIsNull)
                                  goto LabelIsNull;

                                if(*pc++ == &&LabelBool)
                                  goto LabelBool;

                                if(*pc++ == &&LabelMakeArray)
                                  goto LabelMakeArray;

                                if(*pc++ == &&LabelMakeEnv)
                                  goto LabelMakeEnv;

                                if(*pc++ == &&LabelRet)
                                  goto LabelRet;

                                if(*pc++ == &&LabelEndTrap)
                                  goto LabelEndTrap;

                                if(*pc++ == &&LabelTrap)
                                  goto LabelTrap;

                                if(*pc++ == &&LabelJumpIfNot)
                                  goto LabelJumpIfNot;

                                if(*pc++ == &&LabelJumpIf)
                                  goto LabelJumpIf;

                                if(*pc++ == &&LabelJump)
                                  goto LabelJump;

                                if(*pc++ == &&LabelObjCall)
                                  goto LabelObjCall;

                                if(*pc++ == &&LabelCall)
                                  goto LabelCall;

                                if(*pc++ == &&LabelPop)
                                  goto LabelPop;

                                if(*pc++ == &&LabelPush)
                                  goto LabelPush;

                                if(*pc++ == &&LabelSetThis)
                                  goto LabelSetThis;

                                if(*pc++ == &&LabelSetIndex)
                                  goto LabelSetIndex;

                                if(*pc++ == &&LabelSetArray)
                                  goto LabelSetArray;

                                if(*pc++ == &&LabelSetField)
                                  goto LabelSetField;

                                if(*pc++ == &&LabelSetEnv)
                                  goto LabelSetEnv;

                                if(*pc++ == &&LabelSetGlobal)
                                  goto LabelSetGlobal;

                                if(*pc++ == &&LabelSetStack)
                                  goto LabelSetStack;

                                if(*pc++ == &&LabelAccBuiltin)
                                  goto LabelAccBuiltin;

                                if(*pc++ == &&LabelAccIndex)
                                  goto LabelAccIndex;

                                if(*pc++ == &&LabelAccArray)
                                  goto LabelAccArray;

                                if(*pc++ == &&LabelAccField)
                                  goto LabelAccField;

                                if(*pc++ == &&LabelAccEnv)
                                  goto LabelAccEnv;

                                if(*pc++ == &&LabelAccGlobal)
                                  goto LabelAccGlobal;

                                if(*pc++ == &&LabelAccStack)
                                  goto LabelAccStack;

                                if(*pc++ == &&LabelAccInt)
                                  goto LabelAccInt;

                                if(*pc++ == &&LabelAccThis)
                                  goto LabelAccThis;

                                if(*pc++ == &&LabelAccFalse)
                                  goto LabelAccFalse;

                                if(*pc++ == &&LabelAccTrue)
                                  goto LabelAccTrue;

                                if(*pc++ == &&LabelAccNull)
                                  goto LabelAccNull;

                                if(*pc++ == &&end)
                                  goto end;

                              }

                              do
                              {

                              LabelShr:
                                ;
                                if(!((1l & acc) == 0l))
                                  tmp_if_expr_616 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                                else
                                  tmp_if_expr_616 = (_Bool)0;
                                if(tmp_if_expr_616)
                                {
                                  if(!((1073741824u + (unsigned int)(((signed int)*sp >> 1) >> ((signed int)acc >> 1)) & 0x80000000) == 0u))
                                  {
                                    return_value_neko_alloc_int32_600=neko_alloc_int32(((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1));
                                    tmp_if_expr_601 = return_value_neko_alloc_int32_600;
                                  }

                                  else
                                    tmp_if_expr_601 = (struct _value *)(signed long int)((signed int)(((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                                  acc = (signed long int)tmp_if_expr_601;
                                }

                                else
                                {
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr_613 = (_Bool)1;

                                  else
                                    tmp_if_expr_613 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                  if(tmp_if_expr_613)
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr_614 = (_Bool)1;

                                    else
                                      tmp_if_expr_614 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                    tmp_if_expr_615 = tmp_if_expr_614 ? (_Bool)1 : (_Bool)0;
                                  }

                                  else
                                    tmp_if_expr_615 = (_Bool)0;
                                  if(tmp_if_expr_615)
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr_602 = (signed int)(signed long int)*sp >> 1;

                                    else
                                      tmp_if_expr_602 = ((struct anonymous_26 *)*sp)->i;
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr_603 = (signed int)(signed long int)acc >> 1;

                                    else
                                      tmp_if_expr_603 = ((struct anonymous_26 *)acc)->i;
                                    if(!((1073741824u + (unsigned int)(tmp_if_expr_602 >> tmp_if_expr_603) & 0x80000000) == 0u))
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr_604 = (signed int)(signed long int)*sp >> 1;

                                      else
                                        tmp_if_expr_604 = ((struct anonymous_26 *)*sp)->i;
                                      if(!((1 & (signed int)acc) == 0))
                                        tmp_if_expr_605 = (signed int)(signed long int)acc >> 1;

                                      else
                                        tmp_if_expr_605 = ((struct anonymous_26 *)acc)->i;
                                      return_value_neko_alloc_int32_606=neko_alloc_int32(tmp_if_expr_604 >> tmp_if_expr_605);
                                      tmp_if_expr_609 = return_value_neko_alloc_int32_606;
                                    }

                                    else
                                    {
                                      if(!((1 & (signed int)*sp) == 0))
                                        tmp_if_expr_607 = (signed int)(signed long int)*sp >> 1;

                                      else
                                        tmp_if_expr_607 = ((struct anonymous_26 *)*sp)->i;
                                      if(!((1 & (signed int)acc) == 0))
                                        tmp_if_expr_608 = (signed int)(signed long int)acc >> 1;

                                      else
                                        tmp_if_expr_608 = ((struct anonymous_26 *)acc)->i;
                                      tmp_if_expr_609 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_607 >> tmp_if_expr_608) << 1 | 1);
                                    }
                                    acc = (signed long int)tmp_if_expr_609;
                                  }

                                  else
                                  {
                                    if(csp + 4l >= sp)
                                    {
                                      signed int return_value_neko_stack_expand_611;
                                      return_value_neko_stack_expand_611=neko_stack_expand(sp, csp, vm);
                                      if(!(return_value_neko_stack_expand_611 == 0))
                                      {
                                        sp = vm->sp;
                                        csp = vm->csp;
                                      }

                                      else
                                      {
                                        return_value_neko_alloc_string_610=neko_alloc_string("Stack Overflow");
                                        neko_val_throw(return_value_neko_alloc_string_610);
                                      }
                                    }

                                    csp = csp + 1l;
                                    *csp = (signed long int)pc;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->env;
                                    csp = csp + 1l;
                                    *csp = (signed long int)vm->vthis;
                                    csp = csp + 1l;
                                    *csp = (signed long int)m;
                                    vm->sp = sp;
                                    vm->csp = csp;
                                    struct _value *return_value_neko_alloc_string_612;
                                    return_value_neko_alloc_string_612=neko_alloc_string("Invalid operation (>>)");
                                    neko_val_throw(return_value_neko_alloc_string_612);
                                  }
                                }
                                tmp_post_617 = sp;
                                sp = sp + 1l;
                                *tmp_post_617 = (signed long int)0;
                                *pc++;
                                if(*pc++ == &&id_mod_next2)
                                  goto id_mod_next2;

                                if(*pc++ == &&id_mod_next)
                                  goto id_mod_next;

                                if(*pc++ == &&div_next)
                                  goto div_next;

                                if(*pc++ == &&id_mult_next2)
                                  goto id_mult_next2;

                                if(*pc++ == &&id_mult_next)
                                  goto id_mult_next;

                                if(*pc++ == &&id_sub_next2)
                                  goto id_sub_next2;

                                if(*pc++ == &&id_sub_next)
                                  goto id_sub_next;

                                if(*pc++ == &&add_3)
                                  goto add_3;

                                if(*pc++ == &&add_2)
                                  goto add_2;

                                if(*pc++ == &&add_next)
                                  goto add_next;

                                if(*pc++ == &&do_call)
                                  goto LabelCall;

                                if(*pc++ == &&LabelLast)
                                  goto LabelLast;

                                if(*pc++ == &&LabelAccInt32)
                                  goto LabelAccInt32;

                                if(*pc++ == &&LabelMakeArray2)
                                  goto LabelMakeArray2;

                                if(*pc++ == &&LabelLoop)
                                  goto LabelLoop;

                                if(*pc++ == &&LabelTailCall)
                                  goto LabelTailCall;

                                if(*pc++ == &&LabelPhysCompare)
                                  goto LabelPhysCompare;

                                if(*pc++ == &&LabelAccIndex1)
                                  goto LabelAccIndex1;

                                if(*pc++ == &&LabelAccIndex0)
                                  goto LabelAccIndex0;

                                if(*pc++ == &&LabelAccStack1)
                                  goto LabelAccStack1;

                                if(*pc++ == &&LabelAccStack0)
                                  goto LabelAccStack0;

                                if(*pc++ == &&LabelApply)
                                  goto LabelApply;

                                if(*pc++ == &&LabelJumpTable)
                                  goto LabelJumpTable;

                                if(*pc++ == &&LabelNew)
                                  goto LabelNew;

                                if(*pc++ == &&LabelHash)
                                  goto LabelHash;

                                if(*pc++ == &&LabelCompare)
                                  goto LabelCompare;

                                if(*pc++ == &&LabelTypeOf)
                                  goto LabelTypeOf;

                                if(*pc++ == &&LabelNot)
                                  goto LabelNot;

                                if(*pc++ == &&LabelLte)
                                  goto LabelLte;

                                if(*pc++ == &&LabelLt)
                                  goto LabelLt;

                                if(*pc++ == &&LabelGte)
                                  goto LabelGte;

                                if(*pc++ == &&LabelGt)
                                  goto LabelGt;

                                if(*pc++ == &&LabelNeq)
                                  goto LabelNeq;

                                if(*pc++ == &&LabelEq)
                                  goto LabelEq;

                                if(*pc++ == &&LabelXor)
                                  goto LabelXor;

                                if(*pc++ == &&LabelAnd)
                                  goto LabelAnd;

                                if(*pc++ == &&LabelOr)
                                  goto LabelOr;

                                if(*pc++ == &&LabelUShr)
                                  goto LabelUShr;

                              }
                              while(*pc++ == &&LabelShr);
                              if(*pc++ == &&LabelShl)
                                goto LabelShl;

                              if(*pc++ == &&LabelMod)
                                goto LabelMod;

                              if(*pc++ == &&LabelDiv)
                                goto LabelDiv;

                              if(*pc++ == &&LabelMult)
                                goto LabelMult;

                              if(*pc++ == &&LabelSub)
                                goto LabelSub;

                              if(*pc++ == &&LabelAdd)
                                goto LabelAdd;

                              if(*pc++ == &&LabelIsNotNull)
                                goto LabelIsNotNull;

                              if(*pc++ == &&LabelIsNull)
                                goto LabelIsNull;

                              if(*pc++ == &&LabelBool)
                                goto LabelBool;

                              if(*pc++ == &&LabelMakeArray)
                                goto LabelMakeArray;

                              if(*pc++ == &&LabelMakeEnv)
                                goto LabelMakeEnv;

                              if(*pc++ == &&LabelRet)
                                goto LabelRet;

                              if(*pc++ == &&LabelEndTrap)
                                goto LabelEndTrap;

                              if(*pc++ == &&LabelTrap)
                                goto LabelTrap;

                              if(*pc++ == &&LabelJumpIfNot)
                                goto LabelJumpIfNot;

                              if(*pc++ == &&LabelJumpIf)
                                goto LabelJumpIf;

                              if(*pc++ == &&LabelJump)
                                goto LabelJump;

                              if(*pc++ == &&LabelObjCall)
                                goto LabelObjCall;

                              if(*pc++ == &&LabelCall)
                                goto LabelCall;

                              if(*pc++ == &&LabelPop)
                                goto LabelPop;

                              if(*pc++ == &&LabelPush)
                                goto LabelPush;

                              if(*pc++ == &&LabelSetThis)
                                goto LabelSetThis;

                              if(*pc++ == &&LabelSetIndex)
                                goto LabelSetIndex;

                              if(*pc++ == &&LabelSetArray)
                                goto LabelSetArray;

                              if(*pc++ == &&LabelSetField)
                                goto LabelSetField;

                              if(*pc++ == &&LabelSetEnv)
                                goto LabelSetEnv;

                              if(*pc++ == &&LabelSetGlobal)
                                goto LabelSetGlobal;

                              if(*pc++ == &&LabelSetStack)
                                goto LabelSetStack;

                              if(*pc++ == &&LabelAccBuiltin)
                                goto LabelAccBuiltin;

                              if(*pc++ == &&LabelAccIndex)
                                goto LabelAccIndex;

                              if(*pc++ == &&LabelAccArray)
                                goto LabelAccArray;

                              if(*pc++ == &&LabelAccField)
                                goto LabelAccField;

                              if(*pc++ == &&LabelAccEnv)
                                goto LabelAccEnv;

                              if(*pc++ == &&LabelAccGlobal)
                                goto LabelAccGlobal;

                              if(*pc++ == &&LabelAccStack)
                                goto LabelAccStack;

                              if(*pc++ == &&LabelAccInt)
                                goto LabelAccInt;

                              if(*pc++ == &&LabelAccThis)
                                goto LabelAccThis;

                              if(*pc++ == &&LabelAccFalse)
                                goto LabelAccFalse;

                              if(*pc++ == &&LabelAccTrue)
                                goto LabelAccTrue;

                              if(*pc++ == &&LabelAccNull)
                                goto LabelAccNull;

                              if(*pc++ == &&end)
                                goto end;

                            }

                            do
                            {

                            LabelUShr:
                              ;
                              if(!((1l & acc) == 0l))
                                tmp_if_expr_634 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr_634 = (_Bool)0;
                              if(tmp_if_expr_634)
                              {
                                if(!((1073741824u + ((unsigned int)((signed int)*sp >> 1) >> ((signed int)acc >> 1)) & 0x80000000) == 0u))
                                {
                                  return_value_neko_alloc_int32_618=neko_alloc_int32((signed int)((unsigned int)((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1)));
                                  tmp_if_expr_619 = return_value_neko_alloc_int32_618;
                                }

                                else
                                  tmp_if_expr_619 = (struct _value *)(signed long int)((signed int)((unsigned int)((signed int)(signed long int)*sp >> 1) >> ((signed int)(signed long int)acc >> 1)) << 1 | 1);
                                acc = (signed long int)tmp_if_expr_619;
                              }

                              else
                              {
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr_631 = (_Bool)1;

                                else
                                  tmp_if_expr_631 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr_631)
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr_632 = (_Bool)1;

                                  else
                                    tmp_if_expr_632 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                  tmp_if_expr_633 = tmp_if_expr_632 ? (_Bool)1 : (_Bool)0;
                                }

                                else
                                  tmp_if_expr_633 = (_Bool)0;
                                if(tmp_if_expr_633)
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr_620 = (signed int)(signed long int)*sp >> 1;

                                  else
                                    tmp_if_expr_620 = ((struct anonymous_26 *)*sp)->i;
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr_621 = (signed int)(signed long int)acc >> 1;

                                  else
                                    tmp_if_expr_621 = ((struct anonymous_26 *)acc)->i;
                                  if(!((1073741824u + ((unsigned int)tmp_if_expr_620 >> tmp_if_expr_621) & 0x80000000) == 0u))
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr_622 = (signed int)(signed long int)*sp >> 1;

                                    else
                                      tmp_if_expr_622 = ((struct anonymous_26 *)*sp)->i;
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr_623 = (signed int)(signed long int)acc >> 1;

                                    else
                                      tmp_if_expr_623 = ((struct anonymous_26 *)acc)->i;
                                    return_value_neko_alloc_int32_624=neko_alloc_int32((signed int)((unsigned int)tmp_if_expr_622 >> tmp_if_expr_623));
                                    tmp_if_expr_627 = return_value_neko_alloc_int32_624;
                                  }

                                  else
                                  {
                                    if(!((1 & (signed int)*sp) == 0))
                                      tmp_if_expr_625 = (signed int)(signed long int)*sp >> 1;

                                    else
                                      tmp_if_expr_625 = ((struct anonymous_26 *)*sp)->i;
                                    if(!((1 & (signed int)acc) == 0))
                                      tmp_if_expr_626 = (signed int)(signed long int)acc >> 1;

                                    else
                                      tmp_if_expr_626 = ((struct anonymous_26 *)acc)->i;
                                    tmp_if_expr_627 = (struct _value *)(signed long int)((signed int)((unsigned int)tmp_if_expr_625 >> tmp_if_expr_626) << 1 | 1);
                                  }
                                  acc = (signed long int)tmp_if_expr_627;
                                }

                                else
                                {
                                  if(csp + 4l >= sp)
                                  {
                                    signed int return_value_neko_stack_expand_629;
                                    return_value_neko_stack_expand_629=neko_stack_expand(sp, csp, vm);
                                    if(!(return_value_neko_stack_expand_629 == 0))
                                    {
                                      sp = vm->sp;
                                      csp = vm->csp;
                                    }

                                    else
                                    {
                                      return_value_neko_alloc_string_628=neko_alloc_string("Stack Overflow");
                                      neko_val_throw(return_value_neko_alloc_string_628);
                                    }
                                  }

                                  csp = csp + 1l;
                                  *csp = (signed long int)pc;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->env;
                                  csp = csp + 1l;
                                  *csp = (signed long int)vm->vthis;
                                  csp = csp + 1l;
                                  *csp = (signed long int)m;
                                  vm->sp = sp;
                                  vm->csp = csp;
                                  struct _value *return_value_neko_alloc_string_630;
                                  return_value_neko_alloc_string_630=neko_alloc_string("Invalid operation (>>>)");
                                  neko_val_throw(return_value_neko_alloc_string_630);
                                }
                              }
                              tmp_post_635 = sp;
                              sp = sp + 1l;
                              *tmp_post_635 = (signed long int)0;
                              *pc++;
                              if(*pc++ == &&id_mod_next2)
                                goto id_mod_next2;

                              if(*pc++ == &&id_mod_next)
                                goto id_mod_next;

                              if(*pc++ == &&div_next)
                                goto div_next;

                              if(*pc++ == &&id_mult_next2)
                                goto id_mult_next2;

                              if(*pc++ == &&id_mult_next)
                                goto id_mult_next;

                              if(*pc++ == &&id_sub_next2)
                                goto id_sub_next2;

                              if(*pc++ == &&id_sub_next)
                                goto id_sub_next;

                              if(*pc++ == &&add_3)
                                goto add_3;

                              if(*pc++ == &&add_2)
                                goto add_2;

                              if(*pc++ == &&add_next)
                                goto add_next;

                              if(*pc++ == &&do_call)
                                goto LabelCall;

                              if(*pc++ == &&LabelLast)
                                goto LabelLast;

                              if(*pc++ == &&LabelAccInt32)
                                goto LabelAccInt32;

                              if(*pc++ == &&LabelMakeArray2)
                                goto LabelMakeArray2;

                              if(*pc++ == &&LabelLoop)
                                goto LabelLoop;

                              if(*pc++ == &&LabelTailCall)
                                goto LabelTailCall;

                              if(*pc++ == &&LabelPhysCompare)
                                goto LabelPhysCompare;

                              if(*pc++ == &&LabelAccIndex1)
                                goto LabelAccIndex1;

                              if(*pc++ == &&LabelAccIndex0)
                                goto LabelAccIndex0;

                              if(*pc++ == &&LabelAccStack1)
                                goto LabelAccStack1;

                              if(*pc++ == &&LabelAccStack0)
                                goto LabelAccStack0;

                              if(*pc++ == &&LabelApply)
                                goto LabelApply;

                              if(*pc++ == &&LabelJumpTable)
                                goto LabelJumpTable;

                              if(*pc++ == &&LabelNew)
                                goto LabelNew;

                              if(*pc++ == &&LabelHash)
                                goto LabelHash;

                              if(*pc++ == &&LabelCompare)
                                goto LabelCompare;

                              if(*pc++ == &&LabelTypeOf)
                                goto LabelTypeOf;

                              if(*pc++ == &&LabelNot)
                                goto LabelNot;

                              if(*pc++ == &&LabelLte)
                                goto LabelLte;

                              if(*pc++ == &&LabelLt)
                                goto LabelLt;

                              if(*pc++ == &&LabelGte)
                                goto LabelGte;

                              if(*pc++ == &&LabelGt)
                                goto LabelGt;

                              if(*pc++ == &&LabelNeq)
                                goto LabelNeq;

                              if(*pc++ == &&LabelEq)
                                goto LabelEq;

                              if(*pc++ == &&LabelXor)
                                goto LabelXor;

                              if(*pc++ == &&LabelAnd)
                                goto LabelAnd;

                              if(*pc++ == &&LabelOr)
                                goto LabelOr;

                            }
                            while(*pc++ == &&LabelUShr);
                            if(*pc++ == &&LabelShr)
                              goto LabelShr;

                            if(*pc++ == &&LabelShl)
                              goto LabelShl;

                            if(*pc++ == &&LabelMod)
                              goto LabelMod;

                            if(*pc++ == &&LabelDiv)
                              goto LabelDiv;

                            if(*pc++ == &&LabelMult)
                              goto LabelMult;

                            if(*pc++ == &&LabelSub)
                              goto LabelSub;

                            if(*pc++ == &&LabelAdd)
                              goto LabelAdd;

                            if(*pc++ == &&LabelIsNotNull)
                              goto LabelIsNotNull;

                            if(*pc++ == &&LabelIsNull)
                              goto LabelIsNull;

                            if(*pc++ == &&LabelBool)
                              goto LabelBool;

                            if(*pc++ == &&LabelMakeArray)
                              goto LabelMakeArray;

                            if(*pc++ == &&LabelMakeEnv)
                              goto LabelMakeEnv;

                            if(*pc++ == &&LabelRet)
                              goto LabelRet;

                            if(*pc++ == &&LabelEndTrap)
                              goto LabelEndTrap;

                            if(*pc++ == &&LabelTrap)
                              goto LabelTrap;

                            if(*pc++ == &&LabelJumpIfNot)
                              goto LabelJumpIfNot;

                            if(*pc++ == &&LabelJumpIf)
                              goto LabelJumpIf;

                            if(*pc++ == &&LabelJump)
                              goto LabelJump;

                            if(*pc++ == &&LabelObjCall)
                              goto LabelObjCall;

                            if(*pc++ == &&LabelCall)
                              goto LabelCall;

                            if(*pc++ == &&LabelPop)
                              goto LabelPop;

                            if(*pc++ == &&LabelPush)
                              goto LabelPush;

                            if(*pc++ == &&LabelSetThis)
                              goto LabelSetThis;

                            if(*pc++ == &&LabelSetIndex)
                              goto LabelSetIndex;

                            if(*pc++ == &&LabelSetArray)
                              goto LabelSetArray;

                            if(*pc++ == &&LabelSetField)
                              goto LabelSetField;

                            if(*pc++ == &&LabelSetEnv)
                              goto LabelSetEnv;

                            if(*pc++ == &&LabelSetGlobal)
                              goto LabelSetGlobal;

                            if(*pc++ == &&LabelSetStack)
                              goto LabelSetStack;

                            if(*pc++ == &&LabelAccBuiltin)
                              goto LabelAccBuiltin;

                            if(*pc++ == &&LabelAccIndex)
                              goto LabelAccIndex;

                            if(*pc++ == &&LabelAccArray)
                              goto LabelAccArray;

                            if(*pc++ == &&LabelAccField)
                              goto LabelAccField;

                            if(*pc++ == &&LabelAccEnv)
                              goto LabelAccEnv;

                            if(*pc++ == &&LabelAccGlobal)
                              goto LabelAccGlobal;

                            if(*pc++ == &&LabelAccStack)
                              goto LabelAccStack;

                            if(*pc++ == &&LabelAccInt)
                              goto LabelAccInt;

                            if(*pc++ == &&LabelAccThis)
                              goto LabelAccThis;

                            if(*pc++ == &&LabelAccFalse)
                              goto LabelAccFalse;

                            if(*pc++ == &&LabelAccTrue)
                              goto LabelAccTrue;

                            if(*pc++ == &&LabelAccNull)
                              goto LabelAccNull;

                            if(*pc++ == &&end)
                              goto end;

                          }

                          do
                          {

                          LabelOr:
                            ;
                            if(!((1l & acc) == 0l))
                              tmp_if_expr_652 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr_652 = (_Bool)0;
                            if(tmp_if_expr_652)
                            {
                              if(!((((unsigned int)((signed int)*sp >> 1) | (unsigned int)((signed int)acc >> 1)) + 1073741824u & 0x80000000) == 0u))
                              {
                                return_value_neko_alloc_int32_636=neko_alloc_int32((signed int)(signed long int)*sp >> 1 | (signed int)(signed long int)acc >> 1);
                                tmp_if_expr_637 = return_value_neko_alloc_int32_636;
                              }

                              else
                                tmp_if_expr_637 = (struct _value *)(signed long int)((signed int)((signed int)(signed long int)*sp >> 1 | (signed int)(signed long int)acc >> 1) << 1 | 1);
                              acc = (signed long int)tmp_if_expr_637;
                            }

                            else
                            {
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr_649 = (_Bool)1;

                              else
                                tmp_if_expr_649 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                              if(tmp_if_expr_649)
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr_650 = (_Bool)1;

                                else
                                  tmp_if_expr_650 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                                tmp_if_expr_651 = tmp_if_expr_650 ? (_Bool)1 : (_Bool)0;
                              }

                              else
                                tmp_if_expr_651 = (_Bool)0;
                              if(tmp_if_expr_651)
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr_638 = (signed int)(signed long int)*sp >> 1;

                                else
                                  tmp_if_expr_638 = ((struct anonymous_26 *)*sp)->i;
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr_639 = (signed int)(signed long int)acc >> 1;

                                else
                                  tmp_if_expr_639 = ((struct anonymous_26 *)acc)->i;
                                if(!((((unsigned int)tmp_if_expr_638 | (unsigned int)tmp_if_expr_639) + 1073741824u & 0x80000000) == 0u))
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr_640 = (signed int)(signed long int)*sp >> 1;

                                  else
                                    tmp_if_expr_640 = ((struct anonymous_26 *)*sp)->i;
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr_641 = (signed int)(signed long int)acc >> 1;

                                  else
                                    tmp_if_expr_641 = ((struct anonymous_26 *)acc)->i;
                                  return_value_neko_alloc_int32_642=neko_alloc_int32(tmp_if_expr_640 | tmp_if_expr_641);
                                  tmp_if_expr_645 = return_value_neko_alloc_int32_642;
                                }

                                else
                                {
                                  if(!((1 & (signed int)*sp) == 0))
                                    tmp_if_expr_643 = (signed int)(signed long int)*sp >> 1;

                                  else
                                    tmp_if_expr_643 = ((struct anonymous_26 *)*sp)->i;
                                  if(!((1 & (signed int)acc) == 0))
                                    tmp_if_expr_644 = (signed int)(signed long int)acc >> 1;

                                  else
                                    tmp_if_expr_644 = ((struct anonymous_26 *)acc)->i;
                                  tmp_if_expr_645 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_643 | tmp_if_expr_644) << 1 | 1);
                                }
                                acc = (signed long int)tmp_if_expr_645;
                              }

                              else
                              {
                                if(csp + 4l >= sp)
                                {
                                  signed int return_value_neko_stack_expand_647;
                                  return_value_neko_stack_expand_647=neko_stack_expand(sp, csp, vm);
                                  if(!(return_value_neko_stack_expand_647 == 0))
                                  {
                                    sp = vm->sp;
                                    csp = vm->csp;
                                  }

                                  else
                                  {
                                    return_value_neko_alloc_string_646=neko_alloc_string("Stack Overflow");
                                    neko_val_throw(return_value_neko_alloc_string_646);
                                  }
                                }

                                csp = csp + 1l;
                                *csp = (signed long int)pc;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->env;
                                csp = csp + 1l;
                                *csp = (signed long int)vm->vthis;
                                csp = csp + 1l;
                                *csp = (signed long int)m;
                                vm->sp = sp;
                                vm->csp = csp;
                                struct _value *return_value_neko_alloc_string_648;
                                return_value_neko_alloc_string_648=neko_alloc_string("Invalid operation (|)");
                                neko_val_throw(return_value_neko_alloc_string_648);
                              }
                            }
                            tmp_post_653 = sp;
                            sp = sp + 1l;
                            *tmp_post_653 = (signed long int)0;
                            *pc++;
                            if(*pc++ == &&id_mod_next2)
                              goto id_mod_next2;

                            if(*pc++ == &&id_mod_next)
                              goto id_mod_next;

                            if(*pc++ == &&div_next)
                              goto div_next;

                            if(*pc++ == &&id_mult_next2)
                              goto id_mult_next2;

                            if(*pc++ == &&id_mult_next)
                              goto id_mult_next;

                            if(*pc++ == &&id_sub_next2)
                              goto id_sub_next2;

                            if(*pc++ == &&id_sub_next)
                              goto id_sub_next;

                            if(*pc++ == &&add_3)
                              goto add_3;

                            if(*pc++ == &&add_2)
                              goto add_2;

                            if(*pc++ == &&add_next)
                              goto add_next;

                            if(*pc++ == &&do_call)
                              goto LabelCall;

                            if(*pc++ == &&LabelLast)
                              goto LabelLast;

                            if(*pc++ == &&LabelAccInt32)
                              goto LabelAccInt32;

                            if(*pc++ == &&LabelMakeArray2)
                              goto LabelMakeArray2;

                            if(*pc++ == &&LabelLoop)
                              goto LabelLoop;

                            if(*pc++ == &&LabelTailCall)
                              goto LabelTailCall;

                            if(*pc++ == &&LabelPhysCompare)
                              goto LabelPhysCompare;

                            if(*pc++ == &&LabelAccIndex1)
                              goto LabelAccIndex1;

                            if(*pc++ == &&LabelAccIndex0)
                              goto LabelAccIndex0;

                            if(*pc++ == &&LabelAccStack1)
                              goto LabelAccStack1;

                            if(*pc++ == &&LabelAccStack0)
                              goto LabelAccStack0;

                            if(*pc++ == &&LabelApply)
                              goto LabelApply;

                            if(*pc++ == &&LabelJumpTable)
                              goto LabelJumpTable;

                            if(*pc++ == &&LabelNew)
                              goto LabelNew;

                            if(*pc++ == &&LabelHash)
                              goto LabelHash;

                            if(*pc++ == &&LabelCompare)
                              goto LabelCompare;

                            if(*pc++ == &&LabelTypeOf)
                              goto LabelTypeOf;

                            if(*pc++ == &&LabelNot)
                              goto LabelNot;

                            if(*pc++ == &&LabelLte)
                              goto LabelLte;

                            if(*pc++ == &&LabelLt)
                              goto LabelLt;

                            if(*pc++ == &&LabelGte)
                              goto LabelGte;

                            if(*pc++ == &&LabelGt)
                              goto LabelGt;

                            if(*pc++ == &&LabelNeq)
                              goto LabelNeq;

                            if(*pc++ == &&LabelEq)
                              goto LabelEq;

                            if(*pc++ == &&LabelXor)
                              goto LabelXor;

                            if(*pc++ == &&LabelAnd)
                              goto LabelAnd;

                          }
                          while(*pc++ == &&LabelOr);
                          if(*pc++ == &&LabelUShr)
                            goto LabelUShr;

                          if(*pc++ == &&LabelShr)
                            goto LabelShr;

                          if(*pc++ == &&LabelShl)
                            goto LabelShl;

                          if(*pc++ == &&LabelMod)
                            goto LabelMod;

                          if(*pc++ == &&LabelDiv)
                            goto LabelDiv;

                          if(*pc++ == &&LabelMult)
                            goto LabelMult;

                          if(*pc++ == &&LabelSub)
                            goto LabelSub;

                          if(*pc++ == &&LabelAdd)
                            goto LabelAdd;

                          if(*pc++ == &&LabelIsNotNull)
                            goto LabelIsNotNull;

                          if(*pc++ == &&LabelIsNull)
                            goto LabelIsNull;

                          if(*pc++ == &&LabelBool)
                            goto LabelBool;

                          if(*pc++ == &&LabelMakeArray)
                            goto LabelMakeArray;

                          if(*pc++ == &&LabelMakeEnv)
                            goto LabelMakeEnv;

                          if(*pc++ == &&LabelRet)
                            goto LabelRet;

                          if(*pc++ == &&LabelEndTrap)
                            goto LabelEndTrap;

                          if(*pc++ == &&LabelTrap)
                            goto LabelTrap;

                          if(*pc++ == &&LabelJumpIfNot)
                            goto LabelJumpIfNot;

                          if(*pc++ == &&LabelJumpIf)
                            goto LabelJumpIf;

                          if(*pc++ == &&LabelJump)
                            goto LabelJump;

                          if(*pc++ == &&LabelObjCall)
                            goto LabelObjCall;

                          if(*pc++ == &&LabelCall)
                            goto LabelCall;

                          if(*pc++ == &&LabelPop)
                            goto LabelPop;

                          if(*pc++ == &&LabelPush)
                            goto LabelPush;

                          if(*pc++ == &&LabelSetThis)
                            goto LabelSetThis;

                          if(*pc++ == &&LabelSetIndex)
                            goto LabelSetIndex;

                          if(*pc++ == &&LabelSetArray)
                            goto LabelSetArray;

                          if(*pc++ == &&LabelSetField)
                            goto LabelSetField;

                          if(*pc++ == &&LabelSetEnv)
                            goto LabelSetEnv;

                          if(*pc++ == &&LabelSetGlobal)
                            goto LabelSetGlobal;

                          if(*pc++ == &&LabelSetStack)
                            goto LabelSetStack;

                          if(*pc++ == &&LabelAccBuiltin)
                            goto LabelAccBuiltin;

                          if(*pc++ == &&LabelAccIndex)
                            goto LabelAccIndex;

                          if(*pc++ == &&LabelAccArray)
                            goto LabelAccArray;

                          if(*pc++ == &&LabelAccField)
                            goto LabelAccField;

                          if(*pc++ == &&LabelAccEnv)
                            goto LabelAccEnv;

                          if(*pc++ == &&LabelAccGlobal)
                            goto LabelAccGlobal;

                          if(*pc++ == &&LabelAccStack)
                            goto LabelAccStack;

                          if(*pc++ == &&LabelAccInt)
                            goto LabelAccInt;

                          if(*pc++ == &&LabelAccThis)
                            goto LabelAccThis;

                          if(*pc++ == &&LabelAccFalse)
                            goto LabelAccFalse;

                          if(*pc++ == &&LabelAccTrue)
                            goto LabelAccTrue;

                          if(*pc++ == &&LabelAccNull)
                            goto LabelAccNull;

                          if(*pc++ == &&end)
                            goto end;

                        }

                        do
                        {

                        LabelAnd:
                          ;
                          if(!((1l & acc) == 0l))
                            tmp_if_expr_670 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr_670 = (_Bool)0;
                          if(tmp_if_expr_670)
                          {
                            if(!((((unsigned int)((signed int)*sp >> 1) & (unsigned int)((signed int)acc >> 1)) + 1073741824u & 0x80000000) == 0u))
                            {
                              return_value_neko_alloc_int32_654=neko_alloc_int32((signed int)(signed long int)*sp >> 1 & (signed int)(signed long int)acc >> 1);
                              tmp_if_expr_655 = return_value_neko_alloc_int32_654;
                            }

                            else
                              tmp_if_expr_655 = (struct _value *)(signed long int)((signed int)((signed int)(signed long int)*sp >> 1 & (signed int)(signed long int)acc >> 1) << 1 | 1);
                            acc = (signed long int)tmp_if_expr_655;
                          }

                          else
                          {
                            if(!((1 & (signed int)acc) == 0))
                              tmp_if_expr_667 = (_Bool)1;

                            else
                              tmp_if_expr_667 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                            if(tmp_if_expr_667)
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr_668 = (_Bool)1;

                              else
                                tmp_if_expr_668 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                              tmp_if_expr_669 = tmp_if_expr_668 ? (_Bool)1 : (_Bool)0;
                            }

                            else
                              tmp_if_expr_669 = (_Bool)0;
                            if(tmp_if_expr_669)
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr_656 = (signed int)(signed long int)*sp >> 1;

                              else
                                tmp_if_expr_656 = ((struct anonymous_26 *)*sp)->i;
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr_657 = (signed int)(signed long int)acc >> 1;

                              else
                                tmp_if_expr_657 = ((struct anonymous_26 *)acc)->i;
                              if(!((((unsigned int)tmp_if_expr_656 & (unsigned int)tmp_if_expr_657) + 1073741824u & 0x80000000) == 0u))
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr_658 = (signed int)(signed long int)*sp >> 1;

                                else
                                  tmp_if_expr_658 = ((struct anonymous_26 *)*sp)->i;
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr_659 = (signed int)(signed long int)acc >> 1;

                                else
                                  tmp_if_expr_659 = ((struct anonymous_26 *)acc)->i;
                                return_value_neko_alloc_int32_660=neko_alloc_int32(tmp_if_expr_658 & tmp_if_expr_659);
                                tmp_if_expr_663 = return_value_neko_alloc_int32_660;
                              }

                              else
                              {
                                if(!((1 & (signed int)*sp) == 0))
                                  tmp_if_expr_661 = (signed int)(signed long int)*sp >> 1;

                                else
                                  tmp_if_expr_661 = ((struct anonymous_26 *)*sp)->i;
                                if(!((1 & (signed int)acc) == 0))
                                  tmp_if_expr_662 = (signed int)(signed long int)acc >> 1;

                                else
                                  tmp_if_expr_662 = ((struct anonymous_26 *)acc)->i;
                                tmp_if_expr_663 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_661 & tmp_if_expr_662) << 1 | 1);
                              }
                              acc = (signed long int)tmp_if_expr_663;
                            }

                            else
                            {
                              if(csp + 4l >= sp)
                              {
                                signed int return_value_neko_stack_expand_665;
                                return_value_neko_stack_expand_665=neko_stack_expand(sp, csp, vm);
                                if(!(return_value_neko_stack_expand_665 == 0))
                                {
                                  sp = vm->sp;
                                  csp = vm->csp;
                                }

                                else
                                {
                                  return_value_neko_alloc_string_664=neko_alloc_string("Stack Overflow");
                                  neko_val_throw(return_value_neko_alloc_string_664);
                                }
                              }

                              csp = csp + 1l;
                              *csp = (signed long int)pc;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->env;
                              csp = csp + 1l;
                              *csp = (signed long int)vm->vthis;
                              csp = csp + 1l;
                              *csp = (signed long int)m;
                              vm->sp = sp;
                              vm->csp = csp;
                              struct _value *return_value_neko_alloc_string_666;
                              return_value_neko_alloc_string_666=neko_alloc_string("Invalid operation (&)");
                              neko_val_throw(return_value_neko_alloc_string_666);
                            }
                          }
                          tmp_post_671 = sp;
                          sp = sp + 1l;
                          *tmp_post_671 = (signed long int)0;
                          *pc++;
                          if(*pc++ == &&id_mod_next2)
                            goto id_mod_next2;

                          if(*pc++ == &&id_mod_next)
                            goto id_mod_next;

                          if(*pc++ == &&div_next)
                            goto div_next;

                          if(*pc++ == &&id_mult_next2)
                            goto id_mult_next2;

                          if(*pc++ == &&id_mult_next)
                            goto id_mult_next;

                          if(*pc++ == &&id_sub_next2)
                            goto id_sub_next2;

                          if(*pc++ == &&id_sub_next)
                            goto id_sub_next;

                          if(*pc++ == &&add_3)
                            goto add_3;

                          if(*pc++ == &&add_2)
                            goto add_2;

                          if(*pc++ == &&add_next)
                            goto add_next;

                          if(*pc++ == &&do_call)
                            goto LabelCall;

                          if(*pc++ == &&LabelLast)
                            goto LabelLast;

                          if(*pc++ == &&LabelAccInt32)
                            goto LabelAccInt32;

                          if(*pc++ == &&LabelMakeArray2)
                            goto LabelMakeArray2;

                          if(*pc++ == &&LabelLoop)
                            goto LabelLoop;

                          if(*pc++ == &&LabelTailCall)
                            goto LabelTailCall;

                          if(*pc++ == &&LabelPhysCompare)
                            goto LabelPhysCompare;

                          if(*pc++ == &&LabelAccIndex1)
                            goto LabelAccIndex1;

                          if(*pc++ == &&LabelAccIndex0)
                            goto LabelAccIndex0;

                          if(*pc++ == &&LabelAccStack1)
                            goto LabelAccStack1;

                          if(*pc++ == &&LabelAccStack0)
                            goto LabelAccStack0;

                          if(*pc++ == &&LabelApply)
                            goto LabelApply;

                          if(*pc++ == &&LabelJumpTable)
                            goto LabelJumpTable;

                          if(*pc++ == &&LabelNew)
                            goto LabelNew;

                          if(*pc++ == &&LabelHash)
                            goto LabelHash;

                          if(*pc++ == &&LabelCompare)
                            goto LabelCompare;

                          if(*pc++ == &&LabelTypeOf)
                            goto LabelTypeOf;

                          if(*pc++ == &&LabelNot)
                            goto LabelNot;

                          if(*pc++ == &&LabelLte)
                            goto LabelLte;

                          if(*pc++ == &&LabelLt)
                            goto LabelLt;

                          if(*pc++ == &&LabelGte)
                            goto LabelGte;

                          if(*pc++ == &&LabelGt)
                            goto LabelGt;

                          if(*pc++ == &&LabelNeq)
                            goto LabelNeq;

                          if(*pc++ == &&LabelEq)
                            goto LabelEq;

                          if(*pc++ == &&LabelXor)
                            goto LabelXor;

                        }
                        while(*pc++ == &&LabelAnd);
                        if(*pc++ == &&LabelOr)
                          goto LabelOr;

                        if(*pc++ == &&LabelUShr)
                          goto LabelUShr;

                        if(*pc++ == &&LabelShr)
                          goto LabelShr;

                        if(*pc++ == &&LabelShl)
                          goto LabelShl;

                        if(*pc++ == &&LabelMod)
                          goto LabelMod;

                        if(*pc++ == &&LabelDiv)
                          goto LabelDiv;

                        if(*pc++ == &&LabelMult)
                          goto LabelMult;

                        if(*pc++ == &&LabelSub)
                          goto LabelSub;

                        if(*pc++ == &&LabelAdd)
                          goto LabelAdd;

                        if(*pc++ == &&LabelIsNotNull)
                          goto LabelIsNotNull;

                        if(*pc++ == &&LabelIsNull)
                          goto LabelIsNull;

                        if(*pc++ == &&LabelBool)
                          goto LabelBool;

                        if(*pc++ == &&LabelMakeArray)
                          goto LabelMakeArray;

                        if(*pc++ == &&LabelMakeEnv)
                          goto LabelMakeEnv;

                        if(*pc++ == &&LabelRet)
                          goto LabelRet;

                        if(*pc++ == &&LabelEndTrap)
                          goto LabelEndTrap;

                        if(*pc++ == &&LabelTrap)
                          goto LabelTrap;

                        if(*pc++ == &&LabelJumpIfNot)
                          goto LabelJumpIfNot;

                        if(*pc++ == &&LabelJumpIf)
                          goto LabelJumpIf;

                        if(*pc++ == &&LabelJump)
                          goto LabelJump;

                        if(*pc++ == &&LabelObjCall)
                          goto LabelObjCall;

                        if(*pc++ == &&LabelCall)
                          goto LabelCall;

                        if(*pc++ == &&LabelPop)
                          goto LabelPop;

                        if(*pc++ == &&LabelPush)
                          goto LabelPush;

                        if(*pc++ == &&LabelSetThis)
                          goto LabelSetThis;

                        if(*pc++ == &&LabelSetIndex)
                          goto LabelSetIndex;

                        if(*pc++ == &&LabelSetArray)
                          goto LabelSetArray;

                        if(*pc++ == &&LabelSetField)
                          goto LabelSetField;

                        if(*pc++ == &&LabelSetEnv)
                          goto LabelSetEnv;

                        if(*pc++ == &&LabelSetGlobal)
                          goto LabelSetGlobal;

                        if(*pc++ == &&LabelSetStack)
                          goto LabelSetStack;

                        if(*pc++ == &&LabelAccBuiltin)
                          goto LabelAccBuiltin;

                        if(*pc++ == &&LabelAccIndex)
                          goto LabelAccIndex;

                        if(*pc++ == &&LabelAccArray)
                          goto LabelAccArray;

                        if(*pc++ == &&LabelAccField)
                          goto LabelAccField;

                        if(*pc++ == &&LabelAccEnv)
                          goto LabelAccEnv;

                        if(*pc++ == &&LabelAccGlobal)
                          goto LabelAccGlobal;

                        if(*pc++ == &&LabelAccStack)
                          goto LabelAccStack;

                        if(*pc++ == &&LabelAccInt)
                          goto LabelAccInt;

                        if(*pc++ == &&LabelAccThis)
                          goto LabelAccThis;

                        if(*pc++ == &&LabelAccFalse)
                          goto LabelAccFalse;

                        if(*pc++ == &&LabelAccTrue)
                          goto LabelAccTrue;

                        if(*pc++ == &&LabelAccNull)
                          goto LabelAccNull;

                        if(*pc++ == &&end)
                          goto end;

                      }

                      do
                      {

                      LabelXor:
                        ;
                        if(!((1l & acc) == 0l))
                          tmp_if_expr_688 = (*sp & (signed long int)1) != 0l ? (_Bool)1 : (_Bool)0;

                        else
                          tmp_if_expr_688 = (_Bool)0;
                        if(tmp_if_expr_688)
                        {
                          if(!((((unsigned int)((signed int)*sp >> 1) ^ (unsigned int)((signed int)acc >> 1)) + 1073741824u & 0x80000000) == 0u))
                          {
                            return_value_neko_alloc_int32_672=neko_alloc_int32((signed int)(signed long int)*sp >> 1 ^ (signed int)(signed long int)acc >> 1);
                            tmp_if_expr_673 = return_value_neko_alloc_int32_672;
                          }

                          else
                            tmp_if_expr_673 = (struct _value *)(signed long int)((signed int)((signed int)(signed long int)*sp >> 1 ^ (signed int)(signed long int)acc >> 1) << 1 | 1);
                          acc = (signed long int)tmp_if_expr_673;
                        }

                        else
                        {
                          if(!((1 & (signed int)acc) == 0))
                            tmp_if_expr_685 = (_Bool)1;

                          else
                            tmp_if_expr_685 = (signed int)*((enum anonymous_7 *)acc) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr_685)
                          {
                            if(!((1 & (signed int)*sp) == 0))
                              tmp_if_expr_686 = (_Bool)1;

                            else
                              tmp_if_expr_686 = (signed int)*((enum anonymous_7 *)*sp) == VAL_INT32 ? (_Bool)1 : (_Bool)0;
                            tmp_if_expr_687 = tmp_if_expr_686 ? (_Bool)1 : (_Bool)0;
                          }

                          else
                            tmp_if_expr_687 = (_Bool)0;
                          if(tmp_if_expr_687)
                          {
                            if(!((1 & (signed int)*sp) == 0))
                              tmp_if_expr_674 = (signed int)(signed long int)*sp >> 1;

                            else
                              tmp_if_expr_674 = ((struct anonymous_26 *)*sp)->i;
                            if(!((1 & (signed int)acc) == 0))
                              tmp_if_expr_675 = (signed int)(signed long int)acc >> 1;

                            else
                              tmp_if_expr_675 = ((struct anonymous_26 *)acc)->i;
                            if(!((((unsigned int)tmp_if_expr_674 ^ (unsigned int)tmp_if_expr_675) + 1073741824u & 0x80000000) == 0u))
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr_676 = (signed int)(signed long int)*sp >> 1;

                              else
                                tmp_if_expr_676 = ((struct anonymous_26 *)*sp)->i;
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr_677 = (signed int)(signed long int)acc >> 1;

                              else
                                tmp_if_expr_677 = ((struct anonymous_26 *)acc)->i;
                              return_value_neko_alloc_int32_678=neko_alloc_int32(tmp_if_expr_676 ^ tmp_if_expr_677);
                              tmp_if_expr_681 = return_value_neko_alloc_int32_678;
                            }

                            else
                            {
                              if(!((1 & (signed int)*sp) == 0))
                                tmp_if_expr_679 = (signed int)(signed long int)*sp >> 1;

                              else
                                tmp_if_expr_679 = ((struct anonymous_26 *)*sp)->i;
                              if(!((1 & (signed int)acc) == 0))
                                tmp_if_expr_680 = (signed int)(signed long int)acc >> 1;

                              else
                                tmp_if_expr_680 = ((struct anonymous_26 *)acc)->i;
                              tmp_if_expr_681 = (struct _value *)(signed long int)((signed int)(tmp_if_expr_679 ^ tmp_if_expr_680) << 1 | 1);
                            }
                            acc = (signed long int)tmp_if_expr_681;
                          }

                          else
                          {
                            if(csp + 4l >= sp)
                            {
                              signed int return_value_neko_stack_expand_683;
                              return_value_neko_stack_expand_683=neko_stack_expand(sp, csp, vm);
                              if(!(return_value_neko_stack_expand_683 == 0))
                              {
                                sp = vm->sp;
                                csp = vm->csp;
                              }

                              else
                              {
                                return_value_neko_alloc_string_682=neko_alloc_string("Stack Overflow");
                                neko_val_throw(return_value_neko_alloc_string_682);
                              }
                            }

                            csp = csp + 1l;
                            *csp = (signed long int)pc;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->env;
                            csp = csp + 1l;
                            *csp = (signed long int)vm->vthis;
                            csp = csp + 1l;
                            *csp = (signed long int)m;
                            vm->sp = sp;
                            vm->csp = csp;
                            struct _value *return_value_neko_alloc_string_684;
                            return_value_neko_alloc_string_684=neko_alloc_string("Invalid operation (^)");
                            neko_val_throw(return_value_neko_alloc_string_684);
                          }
                        }
                        tmp_post_689 = sp;
                        sp = sp + 1l;
                        *tmp_post_689 = (signed long int)0;
                        *pc++;
                        if(*pc++ == &&id_mod_next2)
                          goto id_mod_next2;

                        if(*pc++ == &&id_mod_next)
                          goto id_mod_next;

                        if(*pc++ == &&div_next)
                          goto div_next;

                        if(*pc++ == &&id_mult_next2)
                          goto id_mult_next2;

                        if(*pc++ == &&id_mult_next)
                          goto id_mult_next;

                        if(*pc++ == &&id_sub_next2)
                          goto id_sub_next2;

                        if(*pc++ == &&id_sub_next)
                          goto id_sub_next;

                        if(*pc++ == &&add_3)
                          goto add_3;

                        if(*pc++ == &&add_2)
                          goto add_2;

                        if(*pc++ == &&add_next)
                          goto add_next;

                        if(*pc++ == &&do_call)
                          goto LabelCall;

                        if(*pc++ == &&LabelLast)
                          goto LabelLast;

                        if(*pc++ == &&LabelAccInt32)
                          goto LabelAccInt32;

                        if(*pc++ == &&LabelMakeArray2)
                          goto LabelMakeArray2;

                        if(*pc++ == &&LabelLoop)
                          goto LabelLoop;

                        if(*pc++ == &&LabelTailCall)
                          goto LabelTailCall;

                        if(*pc++ == &&LabelPhysCompare)
                          goto LabelPhysCompare;

                        if(*pc++ == &&LabelAccIndex1)
                          goto LabelAccIndex1;

                        if(*pc++ == &&LabelAccIndex0)
                          goto LabelAccIndex0;

                        if(*pc++ == &&LabelAccStack1)
                          goto LabelAccStack1;

                        if(*pc++ == &&LabelAccStack0)
                          goto LabelAccStack0;

                        if(*pc++ == &&LabelApply)
                          goto LabelApply;

                        if(*pc++ == &&LabelJumpTable)
                          goto LabelJumpTable;

                        if(*pc++ == &&LabelNew)
                          goto LabelNew;

                        if(*pc++ == &&LabelHash)
                          goto LabelHash;

                        if(*pc++ == &&LabelCompare)
                          goto LabelCompare;

                        if(*pc++ == &&LabelTypeOf)
                          goto LabelTypeOf;

                        if(*pc++ == &&LabelNot)
                          goto LabelNot;

                        if(*pc++ == &&LabelLte)
                          goto LabelLte;

                        if(*pc++ == &&LabelLt)
                          goto LabelLt;

                        if(*pc++ == &&LabelGte)
                          goto LabelGte;

                        if(*pc++ == &&LabelGt)
                          goto LabelGt;

                        if(*pc++ == &&LabelNeq)
                          goto LabelNeq;

                        if(*pc++ == &&LabelEq)
                          goto LabelEq;

                      }
                      while(*pc++ == &&LabelXor);
                      if(*pc++ == &&LabelAnd)
                        goto LabelAnd;

                      if(*pc++ == &&LabelOr)
                        goto LabelOr;

                      if(*pc++ == &&LabelUShr)
                        goto LabelUShr;

                      if(*pc++ == &&LabelShr)
                        goto LabelShr;

                      if(*pc++ == &&LabelShl)
                        goto LabelShl;

                      if(*pc++ == &&LabelMod)
                        goto LabelMod;

                      if(*pc++ == &&LabelDiv)
                        goto LabelDiv;

                      if(*pc++ == &&LabelMult)
                        goto LabelMult;

                      if(*pc++ == &&LabelSub)
                        goto LabelSub;

                      if(*pc++ == &&LabelAdd)
                        goto LabelAdd;

                      if(*pc++ == &&LabelIsNotNull)
                        goto LabelIsNotNull;

                      if(*pc++ == &&LabelIsNull)
                        goto LabelIsNull;

                      if(*pc++ == &&LabelBool)
                        goto LabelBool;

                      if(*pc++ == &&LabelMakeArray)
                        goto LabelMakeArray;

                      if(*pc++ == &&LabelMakeEnv)
                        goto LabelMakeEnv;

                      if(*pc++ == &&LabelRet)
                        goto LabelRet;

                      if(*pc++ == &&LabelEndTrap)
                        goto LabelEndTrap;

                      if(*pc++ == &&LabelTrap)
                        goto LabelTrap;

                      if(*pc++ == &&LabelJumpIfNot)
                        goto LabelJumpIfNot;

                      if(*pc++ == &&LabelJumpIf)
                        goto LabelJumpIf;

                      if(*pc++ == &&LabelJump)
                        goto LabelJump;

                      if(*pc++ == &&LabelObjCall)
                        goto LabelObjCall;

                      if(*pc++ == &&LabelCall)
                        goto LabelCall;

                      if(*pc++ == &&LabelPop)
                        goto LabelPop;

                      if(*pc++ == &&LabelPush)
                        goto LabelPush;

                      if(*pc++ == &&LabelSetThis)
                        goto LabelSetThis;

                      if(*pc++ == &&LabelSetIndex)
                        goto LabelSetIndex;

                      if(*pc++ == &&LabelSetArray)
                        goto LabelSetArray;

                      if(*pc++ == &&LabelSetField)
                        goto LabelSetField;

                      if(*pc++ == &&LabelSetEnv)
                        goto LabelSetEnv;

                      if(*pc++ == &&LabelSetGlobal)
                        goto LabelSetGlobal;

                      if(*pc++ == &&LabelSetStack)
                        goto LabelSetStack;

                      if(*pc++ == &&LabelAccBuiltin)
                        goto LabelAccBuiltin;

                      if(*pc++ == &&LabelAccIndex)
                        goto LabelAccIndex;

                      if(*pc++ == &&LabelAccArray)
                        goto LabelAccArray;

                      if(*pc++ == &&LabelAccField)
                        goto LabelAccField;

                      if(*pc++ == &&LabelAccEnv)
                        goto LabelAccEnv;

                      if(*pc++ == &&LabelAccGlobal)
                        goto LabelAccGlobal;

                      if(*pc++ == &&LabelAccStack)
                        goto LabelAccStack;

                      if(*pc++ == &&LabelAccInt)
                        goto LabelAccInt;

                      if(*pc++ == &&LabelAccThis)
                        goto LabelAccThis;

                      if(*pc++ == &&LabelAccFalse)
                        goto LabelAccFalse;

                      if(*pc++ == &&LabelAccTrue)
                        goto LabelAccTrue;

                      if(*pc++ == &&LabelAccNull)
                        goto LabelAccNull;

                      if(*pc++ == &&end)
                        goto end;

                    }

                    do
                    {

                    LabelEq:
                      ;
                      vm->sp = sp;
                      vm->csp = csp;
                      return_value_neko_val_compare_690=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                      acc = (signed long int)return_value_neko_val_compare_690;
                      sp = vm->sp;
                      csp = vm->csp;
                      tmp_post_691 = sp;
                      sp = sp + 1l;
                      *tmp_post_691 = (signed long int)0;
                      acc = (signed long int)(acc == (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                      *pc++;
                      if(*pc++ == &&id_mod_next2)
                        goto id_mod_next2;

                      if(*pc++ == &&id_mod_next)
                        goto id_mod_next;

                      if(*pc++ == &&div_next)
                        goto div_next;

                      if(*pc++ == &&id_mult_next2)
                        goto id_mult_next2;

                      if(*pc++ == &&id_mult_next)
                        goto id_mult_next;

                      if(*pc++ == &&id_sub_next2)
                        goto id_sub_next2;

                      if(*pc++ == &&id_sub_next)
                        goto id_sub_next;

                      if(*pc++ == &&add_3)
                        goto add_3;

                      if(*pc++ == &&add_2)
                        goto add_2;

                      if(*pc++ == &&add_next)
                        goto add_next;

                      if(*pc++ == &&do_call)
                        goto LabelCall;

                      if(*pc++ == &&LabelLast)
                        goto LabelLast;

                      if(*pc++ == &&LabelAccInt32)
                        goto LabelAccInt32;

                      if(*pc++ == &&LabelMakeArray2)
                        goto LabelMakeArray2;

                      if(*pc++ == &&LabelLoop)
                        goto LabelLoop;

                      if(*pc++ == &&LabelTailCall)
                        goto LabelTailCall;

                      if(*pc++ == &&LabelPhysCompare)
                        goto LabelPhysCompare;

                      if(*pc++ == &&LabelAccIndex1)
                        goto LabelAccIndex1;

                      if(*pc++ == &&LabelAccIndex0)
                        goto LabelAccIndex0;

                      if(*pc++ == &&LabelAccStack1)
                        goto LabelAccStack1;

                      if(*pc++ == &&LabelAccStack0)
                        goto LabelAccStack0;

                      if(*pc++ == &&LabelApply)
                        goto LabelApply;

                      if(*pc++ == &&LabelJumpTable)
                        goto LabelJumpTable;

                      if(*pc++ == &&LabelNew)
                        goto LabelNew;

                      if(*pc++ == &&LabelHash)
                        goto LabelHash;

                      if(*pc++ == &&LabelCompare)
                        goto LabelCompare;

                      if(*pc++ == &&LabelTypeOf)
                        goto LabelTypeOf;

                      if(*pc++ == &&LabelNot)
                        goto LabelNot;

                      if(*pc++ == &&LabelLte)
                        goto LabelLte;

                      if(*pc++ == &&LabelLt)
                        goto LabelLt;

                      if(*pc++ == &&LabelGte)
                        goto LabelGte;

                      if(*pc++ == &&LabelGt)
                        goto LabelGt;

                      if(*pc++ == &&LabelNeq)
                        goto LabelNeq;

                    }
                    while(*pc++ == &&LabelEq);
                    if(*pc++ == &&LabelXor)
                      goto LabelXor;

                    if(*pc++ == &&LabelAnd)
                      goto LabelAnd;

                    if(*pc++ == &&LabelOr)
                      goto LabelOr;

                    if(*pc++ == &&LabelUShr)
                      goto LabelUShr;

                    if(*pc++ == &&LabelShr)
                      goto LabelShr;

                    if(*pc++ == &&LabelShl)
                      goto LabelShl;

                    if(*pc++ == &&LabelMod)
                      goto LabelMod;

                    if(*pc++ == &&LabelDiv)
                      goto LabelDiv;

                    if(*pc++ == &&LabelMult)
                      goto LabelMult;

                    if(*pc++ == &&LabelSub)
                      goto LabelSub;

                    if(*pc++ == &&LabelAdd)
                      goto LabelAdd;

                    if(*pc++ == &&LabelIsNotNull)
                      goto LabelIsNotNull;

                    if(*pc++ == &&LabelIsNull)
                      goto LabelIsNull;

                    if(*pc++ == &&LabelBool)
                      goto LabelBool;

                    if(*pc++ == &&LabelMakeArray)
                      goto LabelMakeArray;

                    if(*pc++ == &&LabelMakeEnv)
                      goto LabelMakeEnv;

                    if(*pc++ == &&LabelRet)
                      goto LabelRet;

                    if(*pc++ == &&LabelEndTrap)
                      goto LabelEndTrap;

                    if(*pc++ == &&LabelTrap)
                      goto LabelTrap;

                    if(*pc++ == &&LabelJumpIfNot)
                      goto LabelJumpIfNot;

                    if(*pc++ == &&LabelJumpIf)
                      goto LabelJumpIf;

                    if(*pc++ == &&LabelJump)
                      goto LabelJump;

                    if(*pc++ == &&LabelObjCall)
                      goto LabelObjCall;

                    if(*pc++ == &&LabelCall)
                      goto LabelCall;

                    if(*pc++ == &&LabelPop)
                      goto LabelPop;

                    if(*pc++ == &&LabelPush)
                      goto LabelPush;

                    if(*pc++ == &&LabelSetThis)
                      goto LabelSetThis;

                    if(*pc++ == &&LabelSetIndex)
                      goto LabelSetIndex;

                    if(*pc++ == &&LabelSetArray)
                      goto LabelSetArray;

                    if(*pc++ == &&LabelSetField)
                      goto LabelSetField;

                    if(*pc++ == &&LabelSetEnv)
                      goto LabelSetEnv;

                    if(*pc++ == &&LabelSetGlobal)
                      goto LabelSetGlobal;

                    if(*pc++ == &&LabelSetStack)
                      goto LabelSetStack;

                    if(*pc++ == &&LabelAccBuiltin)
                      goto LabelAccBuiltin;

                    if(*pc++ == &&LabelAccIndex)
                      goto LabelAccIndex;

                    if(*pc++ == &&LabelAccArray)
                      goto LabelAccArray;

                    if(*pc++ == &&LabelAccField)
                      goto LabelAccField;

                    if(*pc++ == &&LabelAccEnv)
                      goto LabelAccEnv;

                    if(*pc++ == &&LabelAccGlobal)
                      goto LabelAccGlobal;

                    if(*pc++ == &&LabelAccStack)
                      goto LabelAccStack;

                    if(*pc++ == &&LabelAccInt)
                      goto LabelAccInt;

                    if(*pc++ == &&LabelAccThis)
                      goto LabelAccThis;

                    if(*pc++ == &&LabelAccFalse)
                      goto LabelAccFalse;

                    if(*pc++ == &&LabelAccTrue)
                      goto LabelAccTrue;

                    if(*pc++ == &&LabelAccNull)
                      goto LabelAccNull;

                    if(*pc++ == &&end)
                      goto end;

                  }

                  do
                  {

                  LabelNeq:
                    ;
                    vm->sp = sp;
                    vm->csp = csp;
                    return_value_neko_val_compare_692=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                    acc = (signed long int)(return_value_neko_val_compare_692 == 0 ? val_false : val_true);
                    sp = vm->sp;
                    csp = vm->csp;
                    tmp_post_693 = sp;
                    sp = sp + 1l;
                    *tmp_post_693 = (signed long int)0;
                    *pc++;
                    if(*pc++ == &&id_mod_next2)
                      goto id_mod_next2;

                    if(*pc++ == &&id_mod_next)
                      goto id_mod_next;

                    if(*pc++ == &&div_next)
                      goto div_next;

                    if(*pc++ == &&id_mult_next2)
                      goto id_mult_next2;

                    if(*pc++ == &&id_mult_next)
                      goto id_mult_next;

                    if(*pc++ == &&id_sub_next2)
                      goto id_sub_next2;

                    if(*pc++ == &&id_sub_next)
                      goto id_sub_next;

                    if(*pc++ == &&add_3)
                      goto add_3;

                    if(*pc++ == &&add_2)
                      goto add_2;

                    if(*pc++ == &&add_next)
                      goto add_next;

                    if(*pc++ == &&do_call)
                      goto LabelCall;

                    if(*pc++ == &&LabelLast)
                      goto LabelLast;

                    if(*pc++ == &&LabelAccInt32)
                      goto LabelAccInt32;

                    if(*pc++ == &&LabelMakeArray2)
                      goto LabelMakeArray2;

                    if(*pc++ == &&LabelLoop)
                      goto LabelLoop;

                    if(*pc++ == &&LabelTailCall)
                      goto LabelTailCall;

                    if(*pc++ == &&LabelPhysCompare)
                      goto LabelPhysCompare;

                    if(*pc++ == &&LabelAccIndex1)
                      goto LabelAccIndex1;

                    if(*pc++ == &&LabelAccIndex0)
                      goto LabelAccIndex0;

                    if(*pc++ == &&LabelAccStack1)
                      goto LabelAccStack1;

                    if(*pc++ == &&LabelAccStack0)
                      goto LabelAccStack0;

                    if(*pc++ == &&LabelApply)
                      goto LabelApply;

                    if(*pc++ == &&LabelJumpTable)
                      goto LabelJumpTable;

                    if(*pc++ == &&LabelNew)
                      goto LabelNew;

                    if(*pc++ == &&LabelHash)
                      goto LabelHash;

                    if(*pc++ == &&LabelCompare)
                      goto LabelCompare;

                    if(*pc++ == &&LabelTypeOf)
                      goto LabelTypeOf;

                    if(*pc++ == &&LabelNot)
                      goto LabelNot;

                    if(*pc++ == &&LabelLte)
                      goto LabelLte;

                    if(*pc++ == &&LabelLt)
                      goto LabelLt;

                    if(*pc++ == &&LabelGte)
                      goto LabelGte;

                    if(*pc++ == &&LabelGt)
                      goto LabelGt;

                  }
                  while(*pc++ == &&LabelNeq);
                  if(*pc++ == &&LabelEq)
                    goto LabelEq;

                  if(*pc++ == &&LabelXor)
                    goto LabelXor;

                  if(*pc++ == &&LabelAnd)
                    goto LabelAnd;

                  if(*pc++ == &&LabelOr)
                    goto LabelOr;

                  if(*pc++ == &&LabelUShr)
                    goto LabelUShr;

                  if(*pc++ == &&LabelShr)
                    goto LabelShr;

                  if(*pc++ == &&LabelShl)
                    goto LabelShl;

                  if(*pc++ == &&LabelMod)
                    goto LabelMod;

                  if(*pc++ == &&LabelDiv)
                    goto LabelDiv;

                  if(*pc++ == &&LabelMult)
                    goto LabelMult;

                  if(*pc++ == &&LabelSub)
                    goto LabelSub;

                  if(*pc++ == &&LabelAdd)
                    goto LabelAdd;

                  if(*pc++ == &&LabelIsNotNull)
                    goto LabelIsNotNull;

                  if(*pc++ == &&LabelIsNull)
                    goto LabelIsNull;

                  if(*pc++ == &&LabelBool)
                    goto LabelBool;

                  if(*pc++ == &&LabelMakeArray)
                    goto LabelMakeArray;

                  if(*pc++ == &&LabelMakeEnv)
                    goto LabelMakeEnv;

                  if(*pc++ == &&LabelRet)
                    goto LabelRet;

                  if(*pc++ == &&LabelEndTrap)
                    goto LabelEndTrap;

                  if(*pc++ == &&LabelTrap)
                    goto LabelTrap;

                  if(*pc++ == &&LabelJumpIfNot)
                    goto LabelJumpIfNot;

                  if(*pc++ == &&LabelJumpIf)
                    goto LabelJumpIf;

                  if(*pc++ == &&LabelJump)
                    goto LabelJump;

                  if(*pc++ == &&LabelObjCall)
                    goto LabelObjCall;

                  if(*pc++ == &&LabelCall)
                    goto LabelCall;

                  if(*pc++ == &&LabelPop)
                    goto LabelPop;

                  if(*pc++ == &&LabelPush)
                    goto LabelPush;

                  if(*pc++ == &&LabelSetThis)
                    goto LabelSetThis;

                  if(*pc++ == &&LabelSetIndex)
                    goto LabelSetIndex;

                  if(*pc++ == &&LabelSetArray)
                    goto LabelSetArray;

                  if(*pc++ == &&LabelSetField)
                    goto LabelSetField;

                  if(*pc++ == &&LabelSetEnv)
                    goto LabelSetEnv;

                  if(*pc++ == &&LabelSetGlobal)
                    goto LabelSetGlobal;

                  if(*pc++ == &&LabelSetStack)
                    goto LabelSetStack;

                  if(*pc++ == &&LabelAccBuiltin)
                    goto LabelAccBuiltin;

                  if(*pc++ == &&LabelAccIndex)
                    goto LabelAccIndex;

                  if(*pc++ == &&LabelAccArray)
                    goto LabelAccArray;

                  if(*pc++ == &&LabelAccField)
                    goto LabelAccField;

                  if(*pc++ == &&LabelAccEnv)
                    goto LabelAccEnv;

                  if(*pc++ == &&LabelAccGlobal)
                    goto LabelAccGlobal;

                  if(*pc++ == &&LabelAccStack)
                    goto LabelAccStack;

                  if(*pc++ == &&LabelAccInt)
                    goto LabelAccInt;

                  if(*pc++ == &&LabelAccThis)
                    goto LabelAccThis;

                  if(*pc++ == &&LabelAccFalse)
                    goto LabelAccFalse;

                  if(*pc++ == &&LabelAccTrue)
                    goto LabelAccTrue;

                  if(*pc++ == &&LabelAccNull)
                    goto LabelAccNull;

                  if(*pc++ == &&end)
                    goto end;

                }

                do
                {

                LabelLt:
                  ;
                  vm->sp = sp;
                  vm->csp = csp;
                  return_value_neko_val_compare_694=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                  acc = (signed long int)return_value_neko_val_compare_694;
                  sp = vm->sp;
                  csp = vm->csp;
                  tmp_post_695 = sp;
                  sp = sp + 1l;
                  *tmp_post_695 = (signed long int)0;
                  acc = (signed long int)(acc < (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                  *pc++;
                  if(*pc++ == &&id_mod_next2)
                    goto id_mod_next2;

                  if(*pc++ == &&id_mod_next)
                    goto id_mod_next;

                  if(*pc++ == &&div_next)
                    goto div_next;

                  if(*pc++ == &&id_mult_next2)
                    goto id_mult_next2;

                  if(*pc++ == &&id_mult_next)
                    goto id_mult_next;

                  if(*pc++ == &&id_sub_next2)
                    goto id_sub_next2;

                  if(*pc++ == &&id_sub_next)
                    goto id_sub_next;

                  if(*pc++ == &&add_3)
                    goto add_3;

                  if(*pc++ == &&add_2)
                    goto add_2;

                  if(*pc++ == &&add_next)
                    goto add_next;

                  if(*pc++ == &&do_call)
                    goto LabelCall;

                  if(*pc++ == &&LabelLast)
                    goto LabelLast;

                  if(*pc++ == &&LabelAccInt32)
                    goto LabelAccInt32;

                  if(*pc++ == &&LabelMakeArray2)
                    goto LabelMakeArray2;

                  if(*pc++ == &&LabelLoop)
                    goto LabelLoop;

                  if(*pc++ == &&LabelTailCall)
                    goto LabelTailCall;

                  if(*pc++ == &&LabelPhysCompare)
                    goto LabelPhysCompare;

                  if(*pc++ == &&LabelAccIndex1)
                    goto LabelAccIndex1;

                  if(*pc++ == &&LabelAccIndex0)
                    goto LabelAccIndex0;

                  if(*pc++ == &&LabelAccStack1)
                    goto LabelAccStack1;

                  if(*pc++ == &&LabelAccStack0)
                    goto LabelAccStack0;

                  if(*pc++ == &&LabelApply)
                    goto LabelApply;

                  if(*pc++ == &&LabelJumpTable)
                    goto LabelJumpTable;

                  if(*pc++ == &&LabelNew)
                    goto LabelNew;

                  if(*pc++ == &&LabelHash)
                    goto LabelHash;

                  if(*pc++ == &&LabelCompare)
                    goto LabelCompare;

                  if(*pc++ == &&LabelTypeOf)
                    goto LabelTypeOf;

                  if(*pc++ == &&LabelNot)
                    goto LabelNot;

                  if(*pc++ == &&LabelLte)
                    goto LabelLte;

                }
                while(*pc++ == &&LabelLt);
                if(*pc++ == &&LabelGte)
                  goto LabelGte;

                if(*pc++ == &&LabelGt)
                  goto LabelGt;

                if(*pc++ == &&LabelNeq)
                  goto LabelNeq;

                if(*pc++ == &&LabelEq)
                  goto LabelEq;

                if(*pc++ == &&LabelXor)
                  goto LabelXor;

                if(*pc++ == &&LabelAnd)
                  goto LabelAnd;

                if(*pc++ == &&LabelOr)
                  goto LabelOr;

                if(*pc++ == &&LabelUShr)
                  goto LabelUShr;

                if(*pc++ == &&LabelShr)
                  goto LabelShr;

                if(*pc++ == &&LabelShl)
                  goto LabelShl;

                if(*pc++ == &&LabelMod)
                  goto LabelMod;

                if(*pc++ == &&LabelDiv)
                  goto LabelDiv;

                if(*pc++ == &&LabelMult)
                  goto LabelMult;

                if(*pc++ == &&LabelSub)
                  goto LabelSub;

                if(*pc++ == &&LabelAdd)
                  goto LabelAdd;

                if(*pc++ == &&LabelIsNotNull)
                  goto LabelIsNotNull;

                if(*pc++ == &&LabelIsNull)
                  goto LabelIsNull;

                if(*pc++ == &&LabelBool)
                  goto LabelBool;

                if(*pc++ == &&LabelMakeArray)
                  goto LabelMakeArray;

                if(*pc++ == &&LabelMakeEnv)
                  goto LabelMakeEnv;

                if(*pc++ == &&LabelRet)
                  goto LabelRet;

                if(*pc++ == &&LabelEndTrap)
                  goto LabelEndTrap;

                if(*pc++ == &&LabelTrap)
                  goto LabelTrap;

                if(*pc++ == &&LabelJumpIfNot)
                  goto LabelJumpIfNot;

                if(*pc++ == &&LabelJumpIf)
                  goto LabelJumpIf;

                if(*pc++ == &&LabelJump)
                  goto LabelJump;

                if(*pc++ == &&LabelObjCall)
                  goto LabelObjCall;

                if(*pc++ == &&LabelCall)
                  goto LabelCall;

                if(*pc++ == &&LabelPop)
                  goto LabelPop;

                if(*pc++ == &&LabelPush)
                  goto LabelPush;

                if(*pc++ == &&LabelSetThis)
                  goto LabelSetThis;

                if(*pc++ == &&LabelSetIndex)
                  goto LabelSetIndex;

                if(*pc++ == &&LabelSetArray)
                  goto LabelSetArray;

                if(*pc++ == &&LabelSetField)
                  goto LabelSetField;

                if(*pc++ == &&LabelSetEnv)
                  goto LabelSetEnv;

                if(*pc++ == &&LabelSetGlobal)
                  goto LabelSetGlobal;

                if(*pc++ == &&LabelSetStack)
                  goto LabelSetStack;

                if(*pc++ == &&LabelAccBuiltin)
                  goto LabelAccBuiltin;

                if(*pc++ == &&LabelAccIndex)
                  goto LabelAccIndex;

                if(*pc++ == &&LabelAccArray)
                  goto LabelAccArray;

                if(*pc++ == &&LabelAccField)
                  goto LabelAccField;

                if(*pc++ == &&LabelAccEnv)
                  goto LabelAccEnv;

                if(*pc++ == &&LabelAccGlobal)
                  goto LabelAccGlobal;

                if(*pc++ == &&LabelAccStack)
                  goto LabelAccStack;

                if(*pc++ == &&LabelAccInt)
                  goto LabelAccInt;

                if(*pc++ == &&LabelAccThis)
                  goto LabelAccThis;

                if(*pc++ == &&LabelAccFalse)
                  goto LabelAccFalse;

                if(*pc++ == &&LabelAccTrue)
                  goto LabelAccTrue;

                if(*pc++ == &&LabelAccNull)
                  goto LabelAccNull;

                if(*pc++ == &&end)
                  goto end;

              }

              do
              {

              LabelLte:
                ;
                vm->sp = sp;
                vm->csp = csp;
                return_value_neko_val_compare_696=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                acc = (signed long int)return_value_neko_val_compare_696;
                sp = vm->sp;
                csp = vm->csp;
                tmp_post_697 = sp;
                sp = sp + 1l;
                *tmp_post_697 = (signed long int)0;
                acc = (signed long int)(acc <= (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                *pc++;
                if(*pc++ == &&id_mod_next2)
                  goto id_mod_next2;

                if(*pc++ == &&id_mod_next)
                  goto id_mod_next;

                if(*pc++ == &&div_next)
                  goto div_next;

                if(*pc++ == &&id_mult_next2)
                  goto id_mult_next2;

                if(*pc++ == &&id_mult_next)
                  goto id_mult_next;

                if(*pc++ == &&id_sub_next2)
                  goto id_sub_next2;

                if(*pc++ == &&id_sub_next)
                  goto id_sub_next;

                if(*pc++ == &&add_3)
                  goto add_3;

                if(*pc++ == &&add_2)
                  goto add_2;

                if(*pc++ == &&add_next)
                  goto add_next;

                if(*pc++ == &&do_call)
                  goto LabelCall;

                if(*pc++ == &&LabelLast)
                  goto LabelLast;

                if(*pc++ == &&LabelAccInt32)
                  goto LabelAccInt32;

                if(*pc++ == &&LabelMakeArray2)
                  goto LabelMakeArray2;

                if(*pc++ == &&LabelLoop)
                  goto LabelLoop;

                if(*pc++ == &&LabelTailCall)
                  goto LabelTailCall;

                if(*pc++ == &&LabelPhysCompare)
                  goto LabelPhysCompare;

                if(*pc++ == &&LabelAccIndex1)
                  goto LabelAccIndex1;

                if(*pc++ == &&LabelAccIndex0)
                  goto LabelAccIndex0;

                if(*pc++ == &&LabelAccStack1)
                  goto LabelAccStack1;

                if(*pc++ == &&LabelAccStack0)
                  goto LabelAccStack0;

                if(*pc++ == &&LabelApply)
                  goto LabelApply;

                if(*pc++ == &&LabelJumpTable)
                  goto LabelJumpTable;

                if(*pc++ == &&LabelNew)
                  goto LabelNew;

                if(*pc++ == &&LabelHash)
                  goto LabelHash;

                if(*pc++ == &&LabelCompare)
                  goto LabelCompare;

                if(*pc++ == &&LabelTypeOf)
                  goto LabelTypeOf;

                if(*pc++ == &&LabelNot)
                  goto LabelNot;

              }
              while(*pc++ == &&LabelLte);
              if(*pc++ == &&LabelLt)
                goto LabelLt;

              if(!(*pc++ == &&LabelGte))
              {
                if(!(*pc++ == &&LabelGt))
                {
                  if(*pc++ == &&LabelNeq)
                    goto LabelNeq;

                  if(*pc++ == &&LabelEq)
                    goto LabelEq;

                  if(*pc++ == &&LabelXor)
                    goto LabelXor;

                  if(*pc++ == &&LabelAnd)
                    goto LabelAnd;

                  if(*pc++ == &&LabelOr)
                    goto LabelOr;

                  if(*pc++ == &&LabelUShr)
                    goto LabelUShr;

                  if(*pc++ == &&LabelShr)
                    goto LabelShr;

                  if(*pc++ == &&LabelShl)
                    goto LabelShl;

                  if(*pc++ == &&LabelMod)
                    goto LabelMod;

                  if(*pc++ == &&LabelDiv)
                    goto LabelDiv;

                  if(*pc++ == &&LabelMult)
                    goto LabelMult;

                  if(*pc++ == &&LabelSub)
                    goto LabelSub;

                  if(*pc++ == &&LabelAdd)
                    goto LabelAdd;

                  if(*pc++ == &&LabelIsNotNull)
                    goto LabelIsNotNull;

                  if(*pc++ == &&LabelIsNull)
                    goto LabelIsNull;

                  if(*pc++ == &&LabelBool)
                    goto LabelBool;

                  if(*pc++ == &&LabelMakeArray)
                    goto LabelMakeArray;

                  if(*pc++ == &&LabelMakeEnv)
                    goto LabelMakeEnv;

                  if(*pc++ == &&LabelRet)
                    goto LabelRet;

                  if(*pc++ == &&LabelEndTrap)
                    goto LabelEndTrap;

                  if(*pc++ == &&LabelTrap)
                    goto LabelTrap;

                  if(*pc++ == &&LabelJumpIfNot)
                    goto LabelJumpIfNot;

                  if(*pc++ == &&LabelJumpIf)
                    goto LabelJumpIf;

                  if(*pc++ == &&LabelJump)
                    goto LabelJump;

                  if(*pc++ == &&LabelObjCall)
                    goto LabelObjCall;

                  if(*pc++ == &&LabelCall)
                    goto LabelCall;

                  if(*pc++ == &&LabelPop)
                    goto LabelPop;

                  if(*pc++ == &&LabelPush)
                    goto LabelPush;

                  if(*pc++ == &&LabelSetThis)
                    goto LabelSetThis;

                  if(*pc++ == &&LabelSetIndex)
                    goto LabelSetIndex;

                  if(*pc++ == &&LabelSetArray)
                    goto LabelSetArray;

                  if(*pc++ == &&LabelSetField)
                    goto LabelSetField;

                  if(*pc++ == &&LabelSetEnv)
                    goto LabelSetEnv;

                  if(*pc++ == &&LabelSetGlobal)
                    goto LabelSetGlobal;

                  if(*pc++ == &&LabelSetStack)
                    goto LabelSetStack;

                  if(*pc++ == &&LabelAccBuiltin)
                    goto LabelAccBuiltin;

                  if(*pc++ == &&LabelAccIndex)
                    goto LabelAccIndex;

                  if(*pc++ == &&LabelAccArray)
                    goto LabelAccArray;

                  if(*pc++ == &&LabelAccField)
                    goto LabelAccField;

                  if(*pc++ == &&LabelAccEnv)
                    goto LabelAccEnv;

                  if(*pc++ == &&LabelAccGlobal)
                    goto LabelAccGlobal;

                  if(*pc++ == &&LabelAccStack)
                    goto LabelAccStack;

                  if(*pc++ == &&LabelAccInt)
                    goto LabelAccInt;

                  if(*pc++ == &&LabelAccThis)
                    goto LabelAccThis;

                  if(*pc++ == &&LabelAccFalse)
                    goto LabelAccFalse;

                  if(*pc++ == &&LabelAccTrue)
                    goto LabelAccTrue;

                  if(*pc++ == &&LabelAccNull)
                    goto LabelAccNull;

                  if(*pc++ == &&end)
                    goto end;

                }

                do
                {

                LabelGt:
                  ;
                  vm->sp = sp;
                  vm->csp = csp;
                  return_value_neko_val_compare_698=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                  acc = (signed long int)return_value_neko_val_compare_698;
                  sp = vm->sp;
                  csp = vm->csp;
                  tmp_post_699 = sp;
                  sp = sp + 1l;
                  *tmp_post_699 = (signed long int)0;
                  acc = (signed long int)(acc > (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                  *pc++;
                  if(*pc++ == &&id_mod_next2)
                    goto id_mod_next2;

                  if(*pc++ == &&id_mod_next)
                    goto id_mod_next;

                  if(*pc++ == &&div_next)
                    goto div_next;

                  if(*pc++ == &&id_mult_next2)
                    goto id_mult_next2;

                  if(*pc++ == &&id_mult_next)
                    goto id_mult_next;

                  if(*pc++ == &&id_sub_next2)
                    goto id_sub_next2;

                  if(*pc++ == &&id_sub_next)
                    goto id_sub_next;

                  if(*pc++ == &&add_3)
                    goto add_3;

                  if(*pc++ == &&add_2)
                    goto add_2;

                  if(*pc++ == &&add_next)
                    goto add_next;

                  if(*pc++ == &&do_call)
                    goto LabelCall;

                  if(*pc++ == &&LabelLast)
                    goto LabelLast;

                  if(*pc++ == &&LabelAccInt32)
                    goto LabelAccInt32;

                  if(*pc++ == &&LabelMakeArray2)
                    goto LabelMakeArray2;

                  if(*pc++ == &&LabelLoop)
                    goto LabelLoop;

                  if(*pc++ == &&LabelTailCall)
                    goto LabelTailCall;

                  if(*pc++ == &&LabelPhysCompare)
                    goto LabelPhysCompare;

                  if(*pc++ == &&LabelAccIndex1)
                    goto LabelAccIndex1;

                  if(*pc++ == &&LabelAccIndex0)
                    goto LabelAccIndex0;

                  if(*pc++ == &&LabelAccStack1)
                    goto LabelAccStack1;

                  if(*pc++ == &&LabelAccStack0)
                    goto LabelAccStack0;

                  if(*pc++ == &&LabelApply)
                    goto LabelApply;

                  if(*pc++ == &&LabelJumpTable)
                    goto LabelJumpTable;

                  if(*pc++ == &&LabelNew)
                    goto LabelNew;

                  if(*pc++ == &&LabelHash)
                    goto LabelHash;

                  if(*pc++ == &&LabelCompare)
                    goto LabelCompare;

                  if(*pc++ == &&LabelTypeOf)
                    goto LabelTypeOf;

                  if(*pc++ == &&LabelNot)
                    goto LabelNot;

                  if(*pc++ == &&LabelLte)
                    goto LabelLte;

                  if(*pc++ == &&LabelLt)
                    goto LabelLt;

                  if(*pc++ == &&LabelGte)
                    goto LabelGte;

                }
                while(*pc++ == &&LabelGt);
                if(*pc++ == &&LabelNeq)
                  goto LabelNeq;

                if(*pc++ == &&LabelEq)
                  goto LabelEq;

                if(*pc++ == &&LabelXor)
                  goto LabelXor;

                if(*pc++ == &&LabelAnd)
                  goto LabelAnd;

                if(*pc++ == &&LabelOr)
                  goto LabelOr;

                if(*pc++ == &&LabelUShr)
                  goto LabelUShr;

                if(*pc++ == &&LabelShr)
                  goto LabelShr;

                if(*pc++ == &&LabelShl)
                  goto LabelShl;

                if(*pc++ == &&LabelMod)
                  goto LabelMod;

                if(*pc++ == &&LabelDiv)
                  goto LabelDiv;

                if(*pc++ == &&LabelMult)
                  goto LabelMult;

                if(*pc++ == &&LabelSub)
                  goto LabelSub;

                if(*pc++ == &&LabelAdd)
                  goto LabelAdd;

                if(*pc++ == &&LabelIsNotNull)
                  goto LabelIsNotNull;

                if(*pc++ == &&LabelIsNull)
                  goto LabelIsNull;

                if(*pc++ == &&LabelBool)
                  goto LabelBool;

                if(*pc++ == &&LabelMakeArray)
                  goto LabelMakeArray;

                if(*pc++ == &&LabelMakeEnv)
                  goto LabelMakeEnv;

                if(*pc++ == &&LabelRet)
                  goto LabelRet;

                if(*pc++ == &&LabelEndTrap)
                  goto LabelEndTrap;

                if(*pc++ == &&LabelTrap)
                  goto LabelTrap;

                if(*pc++ == &&LabelJumpIfNot)
                  goto LabelJumpIfNot;

                if(*pc++ == &&LabelJumpIf)
                  goto LabelJumpIf;

                if(*pc++ == &&LabelJump)
                  goto LabelJump;

                if(*pc++ == &&LabelObjCall)
                  goto LabelObjCall;

                if(*pc++ == &&LabelCall)
                  goto LabelCall;

                if(*pc++ == &&LabelPop)
                  goto LabelPop;

                if(*pc++ == &&LabelPush)
                  goto LabelPush;

                if(*pc++ == &&LabelSetThis)
                  goto LabelSetThis;

                if(*pc++ == &&LabelSetIndex)
                  goto LabelSetIndex;

                if(*pc++ == &&LabelSetArray)
                  goto LabelSetArray;

                if(*pc++ == &&LabelSetField)
                  goto LabelSetField;

                if(*pc++ == &&LabelSetEnv)
                  goto LabelSetEnv;

                if(*pc++ == &&LabelSetGlobal)
                  goto LabelSetGlobal;

                if(*pc++ == &&LabelSetStack)
                  goto LabelSetStack;

                if(*pc++ == &&LabelAccBuiltin)
                  goto LabelAccBuiltin;

                if(*pc++ == &&LabelAccIndex)
                  goto LabelAccIndex;

                if(*pc++ == &&LabelAccArray)
                  goto LabelAccArray;

                if(*pc++ == &&LabelAccField)
                  goto LabelAccField;

                if(*pc++ == &&LabelAccEnv)
                  goto LabelAccEnv;

                if(*pc++ == &&LabelAccGlobal)
                  goto LabelAccGlobal;

                if(*pc++ == &&LabelAccStack)
                  goto LabelAccStack;

                if(*pc++ == &&LabelAccInt)
                  goto LabelAccInt;

                if(*pc++ == &&LabelAccThis)
                  goto LabelAccThis;

                if(*pc++ == &&LabelAccFalse)
                  goto LabelAccFalse;

                if(*pc++ == &&LabelAccTrue)
                  goto LabelAccTrue;

                if(*pc++ == &&LabelAccNull)
                  goto LabelAccNull;

                if(*pc++ == &&end)
                  goto end;

              }

              do
              {

              LabelGte:
                ;
                vm->sp = sp;
                vm->csp = csp;
                return_value_neko_val_compare_700=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
                acc = (signed long int)return_value_neko_val_compare_700;
                sp = vm->sp;
                csp = vm->csp;
                tmp_post_701 = sp;
                sp = sp + 1l;
                *tmp_post_701 = (signed long int)0;
                acc = (signed long int)(acc >= (signed long int)0 && acc != (signed long int)0xFE ? val_true : val_false);
                *pc++;
                if(*pc++ == &&id_mod_next2)
                  goto id_mod_next2;

                if(*pc++ == &&id_mod_next)
                  goto id_mod_next;

                if(*pc++ == &&div_next)
                  goto div_next;

                if(*pc++ == &&id_mult_next2)
                  goto id_mult_next2;

                if(*pc++ == &&id_mult_next)
                  goto id_mult_next;

                if(*pc++ == &&id_sub_next2)
                  goto id_sub_next2;

                if(*pc++ == &&id_sub_next)
                  goto id_sub_next;

                if(*pc++ == &&add_3)
                  goto add_3;

                if(*pc++ == &&add_2)
                  goto add_2;

                if(*pc++ == &&add_next)
                  goto add_next;

                if(*pc++ == &&do_call)
                  goto LabelCall;

                if(*pc++ == &&LabelLast)
                  goto LabelLast;

                if(*pc++ == &&LabelAccInt32)
                  goto LabelAccInt32;

                if(*pc++ == &&LabelMakeArray2)
                  goto LabelMakeArray2;

                if(*pc++ == &&LabelLoop)
                  goto LabelLoop;

                if(*pc++ == &&LabelTailCall)
                  goto LabelTailCall;

                if(*pc++ == &&LabelPhysCompare)
                  goto LabelPhysCompare;

                if(*pc++ == &&LabelAccIndex1)
                  goto LabelAccIndex1;

                if(*pc++ == &&LabelAccIndex0)
                  goto LabelAccIndex0;

                if(*pc++ == &&LabelAccStack1)
                  goto LabelAccStack1;

                if(*pc++ == &&LabelAccStack0)
                  goto LabelAccStack0;

                if(*pc++ == &&LabelApply)
                  goto LabelApply;

                if(*pc++ == &&LabelJumpTable)
                  goto LabelJumpTable;

                if(*pc++ == &&LabelNew)
                  goto LabelNew;

                if(*pc++ == &&LabelHash)
                  goto LabelHash;

                if(*pc++ == &&LabelCompare)
                  goto LabelCompare;

                if(*pc++ == &&LabelTypeOf)
                  goto LabelTypeOf;

                if(*pc++ == &&LabelNot)
                  goto LabelNot;

                if(*pc++ == &&LabelLte)
                  goto LabelLte;

                if(*pc++ == &&LabelLt)
                  goto LabelLt;

              }
              while(*pc++ == &&LabelGte);
              if(*pc++ == &&LabelGt)
                goto LabelGt;

              if(*pc++ == &&LabelNeq)
                goto LabelNeq;

              if(*pc++ == &&LabelEq)
                goto LabelEq;

              if(*pc++ == &&LabelXor)
                goto LabelXor;

              if(*pc++ == &&LabelAnd)
                goto LabelAnd;

              if(*pc++ == &&LabelOr)
                goto LabelOr;

              if(*pc++ == &&LabelUShr)
                goto LabelUShr;

              if(*pc++ == &&LabelShr)
                goto LabelShr;

              if(*pc++ == &&LabelShl)
                goto LabelShl;

              if(*pc++ == &&LabelMod)
                goto LabelMod;

              if(*pc++ == &&LabelDiv)
                goto LabelDiv;

              if(*pc++ == &&LabelMult)
                goto LabelMult;

              if(*pc++ == &&LabelSub)
                goto LabelSub;

              if(*pc++ == &&LabelAdd)
                goto LabelAdd;

              if(*pc++ == &&LabelIsNotNull)
                goto LabelIsNotNull;

              if(*pc++ == &&LabelIsNull)
                goto LabelIsNull;

              if(*pc++ == &&LabelBool)
                goto LabelBool;

              if(*pc++ == &&LabelMakeArray)
                goto LabelMakeArray;

              if(*pc++ == &&LabelMakeEnv)
                goto LabelMakeEnv;

              if(*pc++ == &&LabelRet)
                goto LabelRet;

              if(*pc++ == &&LabelEndTrap)
                goto LabelEndTrap;

              if(*pc++ == &&LabelTrap)
                goto LabelTrap;

              if(*pc++ == &&LabelJumpIfNot)
                goto LabelJumpIfNot;

              if(*pc++ == &&LabelJumpIf)
                goto LabelJumpIf;

              if(*pc++ == &&LabelJump)
                goto LabelJump;

              if(*pc++ == &&LabelObjCall)
                goto LabelObjCall;

              if(*pc++ == &&LabelCall)
                goto LabelCall;

              if(*pc++ == &&LabelPop)
                goto LabelPop;

              if(*pc++ == &&LabelPush)
                goto LabelPush;

              if(*pc++ == &&LabelSetThis)
                goto LabelSetThis;

              if(*pc++ == &&LabelSetIndex)
                goto LabelSetIndex;

              if(*pc++ == &&LabelSetArray)
                goto LabelSetArray;

              if(*pc++ == &&LabelSetField)
                goto LabelSetField;

              if(*pc++ == &&LabelSetEnv)
                goto LabelSetEnv;

              if(*pc++ == &&LabelSetGlobal)
                goto LabelSetGlobal;

              if(*pc++ == &&LabelSetStack)
                goto LabelSetStack;

              if(*pc++ == &&LabelAccBuiltin)
                goto LabelAccBuiltin;

              if(*pc++ == &&LabelAccIndex)
                goto LabelAccIndex;

              if(*pc++ == &&LabelAccArray)
                goto LabelAccArray;

              if(*pc++ == &&LabelAccField)
                goto LabelAccField;

              if(*pc++ == &&LabelAccEnv)
                goto LabelAccEnv;

              if(*pc++ == &&LabelAccGlobal)
                goto LabelAccGlobal;

              if(*pc++ == &&LabelAccStack)
                goto LabelAccStack;

              if(*pc++ == &&LabelAccInt)
                goto LabelAccInt;

              if(*pc++ == &&LabelAccThis)
                goto LabelAccThis;

              if(*pc++ == &&LabelAccFalse)
                goto LabelAccFalse;

              if(*pc++ == &&LabelAccTrue)
                goto LabelAccTrue;

              if(*pc++ == &&LabelAccNull)
                goto LabelAccNull;

              if(*pc++ == &&end)
                goto end;

            }

            do
            {

            LabelTypeOf:
              ;
              if(!((1 & (signed int)acc) == 0))
                tmp_if_expr_702 = (struct _value *)(signed long int)((signed int)1 << 1 | 1);

              else
                tmp_if_expr_702 = NEKO_TYPEOF[(signed long int)((signed int)*((enum anonymous_7 *)acc) & (1 << 4) - 1)];
              acc = (signed long int)tmp_if_expr_702;
              *pc++;
              if(*pc++ == &&id_mod_next2)
                goto id_mod_next2;

              if(*pc++ == &&id_mod_next)
                goto id_mod_next;

              if(*pc++ == &&div_next)
                goto div_next;

              if(*pc++ == &&id_mult_next2)
                goto id_mult_next2;

              if(*pc++ == &&id_mult_next)
                goto id_mult_next;

              if(*pc++ == &&id_sub_next2)
                goto id_sub_next2;

              if(*pc++ == &&id_sub_next)
                goto id_sub_next;

              if(*pc++ == &&add_3)
                goto add_3;

              if(*pc++ == &&add_2)
                goto add_2;

              if(*pc++ == &&add_next)
                goto add_next;

              if(*pc++ == &&do_call)
                goto LabelCall;

              if(*pc++ == &&LabelLast)
                goto LabelLast;

              if(*pc++ == &&LabelAccInt32)
                goto LabelAccInt32;

              if(*pc++ == &&LabelMakeArray2)
                goto LabelMakeArray2;

              if(*pc++ == &&LabelLoop)
                goto LabelLoop;

              if(*pc++ == &&LabelTailCall)
                goto LabelTailCall;

              if(*pc++ == &&LabelPhysCompare)
                goto LabelPhysCompare;

              if(*pc++ == &&LabelAccIndex1)
                goto LabelAccIndex1;

              if(*pc++ == &&LabelAccIndex0)
                goto LabelAccIndex0;

              if(*pc++ == &&LabelAccStack1)
                goto LabelAccStack1;

              if(*pc++ == &&LabelAccStack0)
                goto LabelAccStack0;

              if(*pc++ == &&LabelApply)
                goto LabelApply;

              if(*pc++ == &&LabelJumpTable)
                goto LabelJumpTable;

              if(*pc++ == &&LabelNew)
                goto LabelNew;

              if(*pc++ == &&LabelHash)
                goto LabelHash;

              if(*pc++ == &&LabelCompare)
                goto LabelCompare;

            }
            while(*pc++ == &&LabelTypeOf);
            if(*pc++ == &&LabelNot)
              goto LabelNot;

            if(*pc++ == &&LabelLte)
              goto LabelLte;

            if(*pc++ == &&LabelLt)
              goto LabelLt;

            if(*pc++ == &&LabelGte)
              goto LabelGte;

            if(*pc++ == &&LabelGt)
              goto LabelGt;

            if(*pc++ == &&LabelNeq)
              goto LabelNeq;

            if(*pc++ == &&LabelEq)
              goto LabelEq;

            if(*pc++ == &&LabelXor)
              goto LabelXor;

            if(*pc++ == &&LabelAnd)
              goto LabelAnd;

            if(*pc++ == &&LabelOr)
              goto LabelOr;

            if(*pc++ == &&LabelUShr)
              goto LabelUShr;

            if(*pc++ == &&LabelShr)
              goto LabelShr;

            if(*pc++ == &&LabelShl)
              goto LabelShl;

            if(*pc++ == &&LabelMod)
              goto LabelMod;

            if(*pc++ == &&LabelDiv)
              goto LabelDiv;

            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }

          do
          {

          LabelCompare:
            ;
            vm->sp = sp;
            vm->csp = csp;
            return_value_neko_val_compare_703=neko_val_compare((struct _value *)*sp, (struct _value *)acc);
            acc = (signed long int)return_value_neko_val_compare_703;
            sp = vm->sp;
            csp = vm->csp;
            acc = (signed long int)(acc == (signed long int)0xFE ? val_null : (struct _value *)(signed long int)((signed int)acc << 1 | 1));
            tmp_post_704 = sp;
            sp = sp + 1l;
            *tmp_post_704 = (signed long int)0;
            *pc++;
            if(*pc++ == &&id_mod_next2)
              goto id_mod_next2;

            if(*pc++ == &&id_mod_next)
              goto id_mod_next;

            if(*pc++ == &&div_next)
              goto div_next;

            if(*pc++ == &&id_mult_next2)
              goto id_mult_next2;

            if(*pc++ == &&id_mult_next)
              goto id_mult_next;

            if(*pc++ == &&id_sub_next2)
              goto id_sub_next2;

            if(*pc++ == &&id_sub_next)
              goto id_sub_next;

            if(*pc++ == &&add_3)
              goto add_3;

            if(*pc++ == &&add_2)
              goto add_2;

            if(*pc++ == &&add_next)
              goto add_next;

            if(*pc++ == &&do_call)
              goto LabelCall;

            if(*pc++ == &&LabelLast)
              goto LabelLast;

            if(*pc++ == &&LabelAccInt32)
              goto LabelAccInt32;

            if(*pc++ == &&LabelMakeArray2)
              goto LabelMakeArray2;

            if(*pc++ == &&LabelLoop)
              goto LabelLoop;

            if(*pc++ == &&LabelTailCall)
              goto LabelTailCall;

            if(*pc++ == &&LabelPhysCompare)
              goto LabelPhysCompare;

            if(*pc++ == &&LabelAccIndex1)
              goto LabelAccIndex1;

            if(*pc++ == &&LabelAccIndex0)
              goto LabelAccIndex0;

            if(*pc++ == &&LabelAccStack1)
              goto LabelAccStack1;

            if(*pc++ == &&LabelAccStack0)
              goto LabelAccStack0;

            if(*pc++ == &&LabelApply)
              goto LabelApply;

            if(*pc++ == &&LabelJumpTable)
              goto LabelJumpTable;

            if(*pc++ == &&LabelNew)
              goto LabelNew;

            if(*pc++ == &&LabelHash)
              goto LabelHash;

          }
          while(*pc++ == &&LabelCompare);
          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(*pc++ == &&LabelMod)
            goto LabelMod;

          if(*pc++ == &&LabelDiv)
            goto LabelDiv;

          if(*pc++ == &&LabelMult)
            goto LabelMult;

          if(*pc++ == &&LabelSub)
            goto LabelSub;

          if(*pc++ == &&LabelAdd)
            goto LabelAdd;

          if(*pc++ == &&LabelIsNotNull)
            goto LabelIsNotNull;

          if(*pc++ == &&LabelIsNull)
            goto LabelIsNull;

          if(*pc++ == &&LabelBool)
            goto LabelBool;

          if(*pc++ == &&LabelMakeArray)
            goto LabelMakeArray;

          if(*pc++ == &&LabelMakeEnv)
            goto LabelMakeEnv;

          if(*pc++ == &&LabelRet)
            goto LabelRet;

          if(*pc++ == &&LabelEndTrap)
            goto LabelEndTrap;

          if(*pc++ == &&LabelTrap)
            goto LabelTrap;

          if(*pc++ == &&LabelJumpIfNot)
            goto LabelJumpIfNot;

          if(*pc++ == &&LabelJumpIf)
            goto LabelJumpIf;

          if(*pc++ == &&LabelJump)
            goto LabelJump;

          if(*pc++ == &&LabelObjCall)
            goto LabelObjCall;

          if(*pc++ == &&LabelCall)
            goto LabelCall;

          if(*pc++ == &&LabelPop)
            goto LabelPop;

          if(*pc++ == &&LabelPush)
            goto LabelPush;

          if(*pc++ == &&LabelSetThis)
            goto LabelSetThis;

          if(*pc++ == &&LabelSetIndex)
            goto LabelSetIndex;

          if(*pc++ == &&LabelSetArray)
            goto LabelSetArray;

          if(*pc++ == &&LabelSetField)
            goto LabelSetField;

          if(*pc++ == &&LabelSetEnv)
            goto LabelSetEnv;

          if(*pc++ == &&LabelSetGlobal)
            goto LabelSetGlobal;

          if(*pc++ == &&LabelSetStack)
            goto LabelSetStack;

          if(*pc++ == &&LabelAccBuiltin)
            goto LabelAccBuiltin;

          if(*pc++ == &&LabelAccIndex)
            goto LabelAccIndex;

          if(*pc++ == &&LabelAccArray)
            goto LabelAccArray;

          if(*pc++ == &&LabelAccField)
            goto LabelAccField;

          if(*pc++ == &&LabelAccEnv)
            goto LabelAccEnv;

          if(*pc++ == &&LabelAccGlobal)
            goto LabelAccGlobal;

          if(*pc++ == &&LabelAccStack)
            goto LabelAccStack;

          if(*pc++ == &&LabelAccInt)
            goto LabelAccInt;

          if(*pc++ == &&LabelAccThis)
            goto LabelAccThis;

          if(*pc++ == &&LabelAccFalse)
            goto LabelAccFalse;

          if(*pc++ == &&LabelAccTrue)
            goto LabelAccTrue;

          if(*pc++ == &&LabelAccNull)
            goto LabelAccNull;

          if(*pc++ == &&end)
            goto end;

        }

        do
        {

        LabelPhysCompare:
          ;
          if(!(acc >= *sp))
            tmp_if_expr_705 = (struct _value *)(signed long int)((signed int)1 << 1 | 1);

          else
            tmp_if_expr_705 = *sp < acc ? (struct _value *)(signed long int)((signed int)-1 << 1 | 1) : (struct _value *)(signed long int)((signed int)0 << 1 | 1);
          acc = (signed long int)tmp_if_expr_705;
          tmp_post_706 = sp;
          sp = sp + 1l;
          *tmp_post_706 = (signed long int)0;
          *pc++;
          if(*pc++ == &&id_mod_next2)
            goto id_mod_next2;

          if(*pc++ == &&id_mod_next)
            goto id_mod_next;

          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

        }
        while(*pc++ == &&LabelPhysCompare);
        if(*pc++ == &&LabelAccIndex1)
          goto LabelAccIndex1;

        if(*pc++ == &&LabelAccIndex0)
          goto LabelAccIndex0;

        if(*pc++ == &&LabelAccStack1)
          goto LabelAccStack1;

        if(*pc++ == &&LabelAccStack0)
          goto LabelAccStack0;

        if(*pc++ == &&LabelApply)
          goto LabelApply;

        if(!(*pc++ == &&LabelJumpTable))
        {
          if(!(*pc++ == &&LabelNew))
          {
            if(!(*pc++ == &&LabelHash))
            {
              if(*pc++ == &&LabelCompare)
                goto LabelCompare;

              if(*pc++ == &&LabelTypeOf)
                goto LabelTypeOf;

              if(*pc++ == &&LabelNot)
                goto LabelNot;

              if(*pc++ == &&LabelLte)
                goto LabelLte;

              if(*pc++ == &&LabelLt)
                goto LabelLt;

              if(*pc++ == &&LabelGte)
                goto LabelGte;

              if(*pc++ == &&LabelGt)
                goto LabelGt;

              if(*pc++ == &&LabelNeq)
                goto LabelNeq;

              if(*pc++ == &&LabelEq)
                goto LabelEq;

              if(*pc++ == &&LabelXor)
                goto LabelXor;

              if(*pc++ == &&LabelAnd)
                goto LabelAnd;

              if(*pc++ == &&LabelOr)
                goto LabelOr;

              if(*pc++ == &&LabelUShr)
                goto LabelUShr;

              if(*pc++ == &&LabelShr)
                goto LabelShr;

              if(*pc++ == &&LabelShl)
                goto LabelShl;

              if(*pc++ == &&LabelMod)
                goto LabelMod;

              if(*pc++ == &&LabelDiv)
                goto LabelDiv;

              if(*pc++ == &&LabelMult)
                goto LabelMult;

              if(*pc++ == &&LabelSub)
                goto LabelSub;

              if(*pc++ == &&LabelAdd)
                goto LabelAdd;

              if(*pc++ == &&LabelIsNotNull)
                goto LabelIsNotNull;

              if(*pc++ == &&LabelIsNull)
                goto LabelIsNull;

              if(*pc++ == &&LabelBool)
                goto LabelBool;

              if(*pc++ == &&LabelMakeArray)
                goto LabelMakeArray;

              if(*pc++ == &&LabelMakeEnv)
                goto LabelMakeEnv;

              if(*pc++ == &&LabelRet)
                goto LabelRet;

              if(*pc++ == &&LabelEndTrap)
                goto LabelEndTrap;

              if(*pc++ == &&LabelTrap)
                goto LabelTrap;

              if(*pc++ == &&LabelJumpIfNot)
                goto LabelJumpIfNot;

              if(*pc++ == &&LabelJumpIf)
                goto LabelJumpIf;

              if(*pc++ == &&LabelJump)
                goto LabelJump;

              if(*pc++ == &&LabelObjCall)
                goto LabelObjCall;

              if(*pc++ == &&LabelCall)
                goto LabelCall;

              if(*pc++ == &&LabelPop)
                goto LabelPop;

              if(*pc++ == &&LabelPush)
                goto LabelPush;

              if(*pc++ == &&LabelSetThis)
                goto LabelSetThis;

              if(*pc++ == &&LabelSetIndex)
                goto LabelSetIndex;

              if(*pc++ == &&LabelSetArray)
                goto LabelSetArray;

              if(*pc++ == &&LabelSetField)
                goto LabelSetField;

              if(*pc++ == &&LabelSetEnv)
                goto LabelSetEnv;

              if(*pc++ == &&LabelSetGlobal)
                goto LabelSetGlobal;

              if(*pc++ == &&LabelSetStack)
                goto LabelSetStack;

              if(*pc++ == &&LabelAccBuiltin)
                goto LabelAccBuiltin;

              if(*pc++ == &&LabelAccIndex)
                goto LabelAccIndex;

              if(*pc++ == &&LabelAccArray)
                goto LabelAccArray;

              if(*pc++ == &&LabelAccField)
                goto LabelAccField;

              if(*pc++ == &&LabelAccEnv)
                goto LabelAccEnv;

              if(*pc++ == &&LabelAccGlobal)
                goto LabelAccGlobal;

              if(*pc++ == &&LabelAccStack)
                goto LabelAccStack;

              if(*pc++ == &&LabelAccInt)
                goto LabelAccInt;

              if(*pc++ == &&LabelAccThis)
                goto LabelAccThis;

              if(*pc++ == &&LabelAccFalse)
                goto LabelAccFalse;

              if(*pc++ == &&LabelAccTrue)
                goto LabelAccTrue;

              if(*pc++ == &&LabelAccNull)
                goto LabelAccNull;

              if(*pc++ == &&end)
                goto end;

            }

            do
            {

            LabelHash:
              ;
              if((1 & (signed int)acc) == 0)
                tmp_if_expr_711 = ((signed int)*((enum anonymous_7 *)acc) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_711 = (_Bool)0;
              if(tmp_if_expr_711)
              {
                vm->sp = sp;
                vm->csp = csp;
                signed int return_value_neko_val_id_707;
                return_value_neko_val_id_707=neko_val_id(&((struct anonymous_5 *)acc)->c);
                acc = (signed long int)(struct _value *)(signed long int)((signed int)return_value_neko_val_id_707 << 1 | 1);
              }

              else
              {
                if(csp + 4l >= sp)
                {
                  signed int return_value_neko_stack_expand_709;
                  return_value_neko_stack_expand_709=neko_stack_expand(sp, csp, vm);
                  if(!(return_value_neko_stack_expand_709 == 0))
                  {
                    sp = vm->sp;
                    csp = vm->csp;
                  }

                  else
                  {
                    return_value_neko_alloc_string_708=neko_alloc_string("Stack Overflow");
                    neko_val_throw(return_value_neko_alloc_string_708);
                  }
                }

                csp = csp + 1l;
                *csp = (signed long int)pc;
                csp = csp + 1l;
                *csp = (signed long int)vm->env;
                csp = csp + 1l;
                *csp = (signed long int)vm->vthis;
                csp = csp + 1l;
                *csp = (signed long int)m;
                vm->sp = sp;
                vm->csp = csp;
                struct _value *return_value_neko_alloc_string_710;
                return_value_neko_alloc_string_710=neko_alloc_string("_hash");
                neko_val_throw(return_value_neko_alloc_string_710);
              }
              *pc++;
              if(*pc++ == &&id_mod_next2)
                goto id_mod_next2;

              if(*pc++ == &&id_mod_next)
                goto id_mod_next;

              if(*pc++ == &&div_next)
                goto div_next;

              if(*pc++ == &&id_mult_next2)
                goto id_mult_next2;

              if(*pc++ == &&id_mult_next)
                goto id_mult_next;

              if(*pc++ == &&id_sub_next2)
                goto id_sub_next2;

              if(*pc++ == &&id_sub_next)
                goto id_sub_next;

              if(*pc++ == &&add_3)
                goto add_3;

              if(*pc++ == &&add_2)
                goto add_2;

              if(*pc++ == &&add_next)
                goto add_next;

              if(*pc++ == &&do_call)
                goto LabelCall;

              if(*pc++ == &&LabelLast)
                goto LabelLast;

              if(*pc++ == &&LabelAccInt32)
                goto LabelAccInt32;

              if(*pc++ == &&LabelMakeArray2)
                goto LabelMakeArray2;

              if(*pc++ == &&LabelLoop)
                goto LabelLoop;

              if(*pc++ == &&LabelTailCall)
                goto LabelTailCall;

              if(*pc++ == &&LabelPhysCompare)
                goto LabelPhysCompare;

              if(*pc++ == &&LabelAccIndex1)
                goto LabelAccIndex1;

              if(*pc++ == &&LabelAccIndex0)
                goto LabelAccIndex0;

              if(*pc++ == &&LabelAccStack1)
                goto LabelAccStack1;

              if(*pc++ == &&LabelAccStack0)
                goto LabelAccStack0;

              if(*pc++ == &&LabelApply)
                goto LabelApply;

              if(*pc++ == &&LabelJumpTable)
                goto LabelJumpTable;

              if(*pc++ == &&LabelNew)
                goto LabelNew;

            }
            while(*pc++ == &&LabelHash);
            if(*pc++ == &&LabelCompare)
              goto LabelCompare;

            if(*pc++ == &&LabelTypeOf)
              goto LabelTypeOf;

            if(*pc++ == &&LabelNot)
              goto LabelNot;

            if(*pc++ == &&LabelLte)
              goto LabelLte;

            if(*pc++ == &&LabelLt)
              goto LabelLt;

            if(*pc++ == &&LabelGte)
              goto LabelGte;

            if(*pc++ == &&LabelGt)
              goto LabelGt;

            if(*pc++ == &&LabelNeq)
              goto LabelNeq;

            if(*pc++ == &&LabelEq)
              goto LabelEq;

            if(*pc++ == &&LabelXor)
              goto LabelXor;

            if(*pc++ == &&LabelAnd)
              goto LabelAnd;

            if(*pc++ == &&LabelOr)
              goto LabelOr;

            if(*pc++ == &&LabelUShr)
              goto LabelUShr;

            if(*pc++ == &&LabelShr)
              goto LabelShr;

            if(*pc++ == &&LabelShl)
              goto LabelShl;

            if(*pc++ == &&LabelMod)
              goto LabelMod;

            if(*pc++ == &&LabelDiv)
              goto LabelDiv;

            if(*pc++ == &&LabelMult)
              goto LabelMult;

            if(*pc++ == &&LabelSub)
              goto LabelSub;

            if(*pc++ == &&LabelAdd)
              goto LabelAdd;

            if(*pc++ == &&LabelIsNotNull)
              goto LabelIsNotNull;

            if(*pc++ == &&LabelIsNull)
              goto LabelIsNull;

            if(*pc++ == &&LabelBool)
              goto LabelBool;

            if(*pc++ == &&LabelMakeArray)
              goto LabelMakeArray;

            if(*pc++ == &&LabelMakeEnv)
              goto LabelMakeEnv;

            if(*pc++ == &&LabelRet)
              goto LabelRet;

            if(*pc++ == &&LabelEndTrap)
              goto LabelEndTrap;

            if(*pc++ == &&LabelTrap)
              goto LabelTrap;

            if(*pc++ == &&LabelJumpIfNot)
              goto LabelJumpIfNot;

            if(*pc++ == &&LabelJumpIf)
              goto LabelJumpIf;

            if(*pc++ == &&LabelJump)
              goto LabelJump;

            if(*pc++ == &&LabelObjCall)
              goto LabelObjCall;

            if(*pc++ == &&LabelCall)
              goto LabelCall;

            if(*pc++ == &&LabelPop)
              goto LabelPop;

            if(*pc++ == &&LabelPush)
              goto LabelPush;

            if(*pc++ == &&LabelSetThis)
              goto LabelSetThis;

            if(*pc++ == &&LabelSetIndex)
              goto LabelSetIndex;

            if(*pc++ == &&LabelSetArray)
              goto LabelSetArray;

            if(*pc++ == &&LabelSetField)
              goto LabelSetField;

            if(*pc++ == &&LabelSetEnv)
              goto LabelSetEnv;

            if(*pc++ == &&LabelSetGlobal)
              goto LabelSetGlobal;

            if(*pc++ == &&LabelSetStack)
              goto LabelSetStack;

            if(*pc++ == &&LabelAccBuiltin)
              goto LabelAccBuiltin;

            if(*pc++ == &&LabelAccIndex)
              goto LabelAccIndex;

            if(*pc++ == &&LabelAccArray)
              goto LabelAccArray;

            if(*pc++ == &&LabelAccField)
              goto LabelAccField;

            if(*pc++ == &&LabelAccEnv)
              goto LabelAccEnv;

            if(*pc++ == &&LabelAccGlobal)
              goto LabelAccGlobal;

            if(*pc++ == &&LabelAccStack)
              goto LabelAccStack;

            if(*pc++ == &&LabelAccInt)
              goto LabelAccInt;

            if(*pc++ == &&LabelAccThis)
              goto LabelAccThis;

            if(*pc++ == &&LabelAccFalse)
              goto LabelAccFalse;

            if(*pc++ == &&LabelAccTrue)
              goto LabelAccTrue;

            if(*pc++ == &&LabelAccNull)
              goto LabelAccNull;

            if(*pc++ == &&end)
              goto end;

          }

          do
          {

          LabelNew:
            ;
            vm->sp = sp;
            vm->csp = csp;
            return_value_neko_alloc_object_712=neko_alloc_object((struct _value *)acc);
            acc = (signed long int)return_value_neko_alloc_object_712;
            *pc++;
            if(*pc++ == &&id_mod_next2)
              goto id_mod_next2;

            if(*pc++ == &&id_mod_next)
              goto id_mod_next;

            if(*pc++ == &&div_next)
              goto div_next;

            if(*pc++ == &&id_mult_next2)
              goto id_mult_next2;

            if(*pc++ == &&id_mult_next)
              goto id_mult_next;

            if(*pc++ == &&id_sub_next2)
              goto id_sub_next2;

            if(*pc++ == &&id_sub_next)
              goto id_sub_next;

            if(*pc++ == &&add_3)
              goto add_3;

            if(*pc++ == &&add_2)
              goto add_2;

            if(*pc++ == &&add_next)
              goto add_next;

            if(*pc++ == &&do_call)
              goto LabelCall;

            if(*pc++ == &&LabelLast)
              goto LabelLast;

            if(*pc++ == &&LabelAccInt32)
              goto LabelAccInt32;

            if(*pc++ == &&LabelMakeArray2)
              goto LabelMakeArray2;

            if(*pc++ == &&LabelLoop)
              goto LabelLoop;

            if(*pc++ == &&LabelTailCall)
              goto LabelTailCall;

            if(*pc++ == &&LabelPhysCompare)
              goto LabelPhysCompare;

            if(*pc++ == &&LabelAccIndex1)
              goto LabelAccIndex1;

            if(*pc++ == &&LabelAccIndex0)
              goto LabelAccIndex0;

            if(*pc++ == &&LabelAccStack1)
              goto LabelAccStack1;

            if(*pc++ == &&LabelAccStack0)
              goto LabelAccStack0;

            if(*pc++ == &&LabelApply)
              goto LabelApply;

            if(*pc++ == &&LabelJumpTable)
              goto LabelJumpTable;

          }
          while(*pc++ == &&LabelNew);
          if(*pc++ == &&LabelHash)
            goto LabelHash;

          if(*pc++ == &&LabelCompare)
            goto LabelCompare;

          if(*pc++ == &&LabelTypeOf)
            goto LabelTypeOf;

          if(*pc++ == &&LabelNot)
            goto LabelNot;

          if(*pc++ == &&LabelLte)
            goto LabelLte;

          if(*pc++ == &&LabelLt)
            goto LabelLt;

          if(*pc++ == &&LabelGte)
            goto LabelGte;

          if(*pc++ == &&LabelGt)
            goto LabelGt;

          if(*pc++ == &&LabelNeq)
            goto LabelNeq;

          if(*pc++ == &&LabelEq)
            goto LabelEq;

          if(*pc++ == &&LabelXor)
            goto LabelXor;

          if(*pc++ == &&LabelAnd)
            goto LabelAnd;

          if(*pc++ == &&LabelOr)
            goto LabelOr;

          if(*pc++ == &&LabelUShr)
            goto LabelUShr;

          if(*pc++ == &&LabelShr)
            goto LabelShr;

          if(*pc++ == &&LabelShl)
            goto LabelShl;

          if(*pc++ == &&LabelMod)
            goto LabelMod;

          if(*pc++ == &&LabelDiv)
            goto LabelDiv;

          if(*pc++ == &&LabelMult)
            goto LabelMult;

          if(*pc++ == &&LabelSub)
            goto LabelSub;

          if(*pc++ == &&LabelAdd)
            goto LabelAdd;

          if(*pc++ == &&LabelIsNotNull)
            goto LabelIsNotNull;

          if(*pc++ == &&LabelIsNull)
            goto LabelIsNull;

          if(*pc++ == &&LabelBool)
            goto LabelBool;

          if(*pc++ == &&LabelMakeArray)
            goto LabelMakeArray;

          if(*pc++ == &&LabelMakeEnv)
            goto LabelMakeEnv;

          if(*pc++ == &&LabelRet)
            goto LabelRet;

          if(*pc++ == &&LabelEndTrap)
            goto LabelEndTrap;

          if(*pc++ == &&LabelTrap)
            goto LabelTrap;

          if(*pc++ == &&LabelJumpIfNot)
            goto LabelJumpIfNot;

          if(*pc++ == &&LabelJumpIf)
            goto LabelJumpIf;

          if(*pc++ == &&LabelJump)
            goto LabelJump;

          if(*pc++ == &&LabelObjCall)
            goto LabelObjCall;

          if(*pc++ == &&LabelCall)
            goto LabelCall;

          if(*pc++ == &&LabelPop)
            goto LabelPop;

          if(*pc++ == &&LabelPush)
            goto LabelPush;

          if(*pc++ == &&LabelSetThis)
            goto LabelSetThis;

          if(*pc++ == &&LabelSetIndex)
            goto LabelSetIndex;

          if(*pc++ == &&LabelSetArray)
            goto LabelSetArray;

          if(*pc++ == &&LabelSetField)
            goto LabelSetField;

          if(*pc++ == &&LabelSetEnv)
            goto LabelSetEnv;

          if(*pc++ == &&LabelSetGlobal)
            goto LabelSetGlobal;

          if(*pc++ == &&LabelSetStack)
            goto LabelSetStack;

          if(*pc++ == &&LabelAccBuiltin)
            goto LabelAccBuiltin;

          if(*pc++ == &&LabelAccIndex)
            goto LabelAccIndex;

          if(*pc++ == &&LabelAccArray)
            goto LabelAccArray;

          if(*pc++ == &&LabelAccField)
            goto LabelAccField;

          if(*pc++ == &&LabelAccEnv)
            goto LabelAccEnv;

          if(*pc++ == &&LabelAccGlobal)
            goto LabelAccGlobal;

          if(*pc++ == &&LabelAccStack)
            goto LabelAccStack;

          if(*pc++ == &&LabelAccInt)
            goto LabelAccInt;

          if(*pc++ == &&LabelAccThis)
            goto LabelAccThis;

          if(*pc++ == &&LabelAccFalse)
            goto LabelAccFalse;

          if(*pc++ == &&LabelAccTrue)
            goto LabelAccTrue;

          if(*pc++ == &&LabelAccNull)
            goto LabelAccNull;

          if(*pc++ == &&end)
            goto end;

        }

        do
        {

        LabelJumpTable:
          ;
          if(!((1 & (signed int)acc) == 0))
            tmp_if_expr_713 = (unsigned int)acc < (unsigned int)*pc ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_713 = (_Bool)0;
          if(tmp_if_expr_713)
            pc = pc + acc;

          else
            pc = pc + *pc + (signed long int)1;
          *pc++;
          if(*pc++ == &&id_mod_next2)
            goto id_mod_next2;

          if(*pc++ == &&id_mod_next)
            goto id_mod_next;

          if(*pc++ == &&div_next)
            goto div_next;

          if(*pc++ == &&id_mult_next2)
            goto id_mult_next2;

          if(*pc++ == &&id_mult_next)
            goto id_mult_next;

          if(*pc++ == &&id_sub_next2)
            goto id_sub_next2;

          if(*pc++ == &&id_sub_next)
            goto id_sub_next;

          if(*pc++ == &&add_3)
            goto add_3;

          if(*pc++ == &&add_2)
            goto add_2;

          if(*pc++ == &&add_next)
            goto add_next;

          if(*pc++ == &&do_call)
            goto LabelCall;

          if(*pc++ == &&LabelLast)
            goto LabelLast;

          if(*pc++ == &&LabelAccInt32)
            goto LabelAccInt32;

          if(*pc++ == &&LabelMakeArray2)
            goto LabelMakeArray2;

          if(*pc++ == &&LabelLoop)
            goto LabelLoop;

          if(*pc++ == &&LabelTailCall)
            goto LabelTailCall;

          if(*pc++ == &&LabelPhysCompare)
            goto LabelPhysCompare;

          if(*pc++ == &&LabelAccIndex1)
            goto LabelAccIndex1;

          if(*pc++ == &&LabelAccIndex0)
            goto LabelAccIndex0;

          if(*pc++ == &&LabelAccStack1)
            goto LabelAccStack1;

          if(*pc++ == &&LabelAccStack0)
            goto LabelAccStack0;

          if(*pc++ == &&LabelApply)
            goto LabelApply;

        }
        while(*pc++ == &&LabelJumpTable);
        if(*pc++ == &&LabelNew)
          goto LabelNew;

        if(*pc++ == &&LabelHash)
          goto LabelHash;

        if(*pc++ == &&LabelCompare)
          goto LabelCompare;

        if(*pc++ == &&LabelTypeOf)
          goto LabelTypeOf;

        if(*pc++ == &&LabelNot)
          goto LabelNot;

        if(*pc++ == &&LabelLte)
          goto LabelLte;

        if(*pc++ == &&LabelLt)
          goto LabelLt;

        if(*pc++ == &&LabelGte)
          goto LabelGte;

        if(*pc++ == &&LabelGt)
          goto LabelGt;

        if(*pc++ == &&LabelNeq)
          goto LabelNeq;

        if(*pc++ == &&LabelEq)
          goto LabelEq;

        if(*pc++ == &&LabelXor)
          goto LabelXor;

        if(*pc++ == &&LabelAnd)
          goto LabelAnd;

        if(*pc++ == &&LabelOr)
          goto LabelOr;

        if(*pc++ == &&LabelUShr)
          goto LabelUShr;

        if(*pc++ == &&LabelShr)
          goto LabelShr;

        if(*pc++ == &&LabelShl)
          goto LabelShl;

        if(*pc++ == &&LabelMod)
          goto LabelMod;

        if(*pc++ == &&LabelDiv)
          goto LabelDiv;

        if(*pc++ == &&LabelMult)
          goto LabelMult;

        if(*pc++ == &&LabelSub)
          goto LabelSub;

        if(*pc++ == &&LabelAdd)
          goto LabelAdd;

        if(*pc++ == &&LabelIsNotNull)
          goto LabelIsNotNull;

        if(*pc++ == &&LabelIsNull)
          goto LabelIsNull;

        if(*pc++ == &&LabelBool)
          goto LabelBool;

        if(*pc++ == &&LabelMakeArray)
          goto LabelMakeArray;

        if(*pc++ == &&LabelMakeEnv)
          goto LabelMakeEnv;

        if(*pc++ == &&LabelRet)
          goto LabelRet;

        if(*pc++ == &&LabelEndTrap)
          goto LabelEndTrap;

        if(*pc++ == &&LabelTrap)
          goto LabelTrap;

        if(*pc++ == &&LabelJumpIfNot)
          goto LabelJumpIfNot;

        if(*pc++ == &&LabelJumpIf)
          goto LabelJumpIf;

        if(*pc++ == &&LabelJump)
          goto LabelJump;

        if(*pc++ == &&LabelObjCall)
          goto LabelObjCall;

        if(*pc++ == &&LabelCall)
          goto LabelCall;

        if(*pc++ == &&LabelPop)
          goto LabelPop;

        if(*pc++ == &&LabelPush)
          goto LabelPush;

        if(*pc++ == &&LabelSetThis)
          goto LabelSetThis;

        if(*pc++ == &&LabelSetIndex)
          goto LabelSetIndex;

        if(*pc++ == &&LabelSetArray)
          goto LabelSetArray;

        if(*pc++ == &&LabelSetField)
          goto LabelSetField;

        if(*pc++ == &&LabelSetEnv)
          goto LabelSetEnv;

        if(*pc++ == &&LabelSetGlobal)
          goto LabelSetGlobal;

        if(*pc++ == &&LabelSetStack)
          goto LabelSetStack;

        if(*pc++ == &&LabelAccBuiltin)
          goto LabelAccBuiltin;

        if(*pc++ == &&LabelAccIndex)
          goto LabelAccIndex;

        if(*pc++ == &&LabelAccArray)
          goto LabelAccArray;

        if(*pc++ == &&LabelAccField)
          goto LabelAccField;

        if(*pc++ == &&LabelAccEnv)
          goto LabelAccEnv;

        if(*pc++ == &&LabelAccGlobal)
          goto LabelAccGlobal;

        if(*pc++ == &&LabelAccStack)
          goto LabelAccStack;

        if(*pc++ == &&LabelAccInt)
          goto LabelAccInt;

        if(*pc++ == &&LabelAccThis)
          goto LabelAccThis;

        if(*pc++ == &&LabelAccFalse)
          goto LabelAccFalse;

        if(*pc++ == &&LabelAccTrue)
          goto LabelAccTrue;

        if(*pc++ == &&LabelAccNull)
          goto LabelAccNull;

        if(*pc++ == &&end)
          goto end;

      }

      do
      {

      LabelLoop:
        ;
        *pc++;
        if(*pc++ == &&id_mod_next2)
          goto id_mod_next2;

        if(*pc++ == &&id_mod_next)
          goto id_mod_next;

        if(*pc++ == &&div_next)
          goto div_next;

        if(*pc++ == &&id_mult_next2)
          goto id_mult_next2;

        if(*pc++ == &&id_mult_next)
          goto id_mult_next;

        if(*pc++ == &&id_sub_next2)
          goto id_sub_next2;

        if(*pc++ == &&id_sub_next)
          goto id_sub_next;

        if(*pc++ == &&add_3)
          goto add_3;

        if(*pc++ == &&add_2)
          goto add_2;

        if(*pc++ == &&add_next)
          goto add_next;

        if(*pc++ == &&do_call)
          goto LabelCall;

        if(*pc++ == &&LabelLast)
          goto LabelLast;

        if(*pc++ == &&LabelAccInt32)
          goto LabelAccInt32;

        if(*pc++ == &&LabelMakeArray2)
          goto LabelMakeArray2;

      }
      while(*pc++ == &&LabelLoop);
      if(*pc++ == &&LabelTailCall)
        goto LabelTailCall;

      if(*pc++ == &&LabelPhysCompare)
        goto LabelPhysCompare;

      if(*pc++ == &&LabelAccIndex1)
        goto LabelAccIndex1;

      if(*pc++ == &&LabelAccIndex0)
        goto LabelAccIndex0;

      if(*pc++ == &&LabelAccStack1)
        goto LabelAccStack1;

      if(*pc++ == &&LabelAccStack0)
        goto LabelAccStack0;

      if(*pc++ == &&LabelApply)
        goto LabelApply;

      if(*pc++ == &&LabelJumpTable)
        goto LabelJumpTable;

      if(*pc++ == &&LabelNew)
        goto LabelNew;

      if(*pc++ == &&LabelHash)
        goto LabelHash;

      if(*pc++ == &&LabelCompare)
        goto LabelCompare;

      if(*pc++ == &&LabelTypeOf)
        goto LabelTypeOf;

      if(*pc++ == &&LabelNot)
        goto LabelNot;

      if(*pc++ == &&LabelLte)
        goto LabelLte;

      if(*pc++ == &&LabelLt)
        goto LabelLt;

      if(*pc++ == &&LabelGte)
        goto LabelGte;

      if(*pc++ == &&LabelGt)
        goto LabelGt;

      if(*pc++ == &&LabelNeq)
        goto LabelNeq;

      if(*pc++ == &&LabelEq)
        goto LabelEq;

      if(*pc++ == &&LabelXor)
        goto LabelXor;

      if(*pc++ == &&LabelAnd)
        goto LabelAnd;

      if(*pc++ == &&LabelOr)
        goto LabelOr;

      if(*pc++ == &&LabelUShr)
        goto LabelUShr;

      if(*pc++ == &&LabelShr)
        goto LabelShr;

      if(*pc++ == &&LabelShl)
        goto LabelShl;

      if(*pc++ == &&LabelMod)
        goto LabelMod;

      if(*pc++ == &&LabelDiv)
        goto LabelDiv;

      if(*pc++ == &&LabelMult)
        goto LabelMult;

      if(*pc++ == &&LabelSub)
        goto LabelSub;

      if(*pc++ == &&LabelAdd)
        goto LabelAdd;

      if(*pc++ == &&LabelIsNotNull)
        goto LabelIsNotNull;

      if(*pc++ == &&LabelIsNull)
        goto LabelIsNull;

      if(*pc++ == &&LabelBool)
        goto LabelBool;

      if(*pc++ == &&LabelMakeArray)
        goto LabelMakeArray;

      if(*pc++ == &&LabelMakeEnv)
        goto LabelMakeEnv;

      if(*pc++ == &&LabelRet)
        goto LabelRet;

      if(*pc++ == &&LabelEndTrap)
        goto LabelEndTrap;

      if(*pc++ == &&LabelTrap)
        goto LabelTrap;

      if(*pc++ == &&LabelJumpIfNot)
        goto LabelJumpIfNot;

      if(*pc++ == &&LabelJumpIf)
        goto LabelJumpIf;

      if(*pc++ == &&LabelJump)
        goto LabelJump;

      if(*pc++ == &&LabelObjCall)
        goto LabelObjCall;

      if(*pc++ == &&LabelCall)
        goto LabelCall;

      if(*pc++ == &&LabelPop)
        goto LabelPop;

      if(*pc++ == &&LabelPush)
        goto LabelPush;

      if(*pc++ == &&LabelSetThis)
        goto LabelSetThis;

      if(*pc++ == &&LabelSetIndex)
        goto LabelSetIndex;

      if(*pc++ == &&LabelSetArray)
        goto LabelSetArray;

      if(*pc++ == &&LabelSetField)
        goto LabelSetField;

      if(*pc++ == &&LabelSetEnv)
        goto LabelSetEnv;

      if(*pc++ == &&LabelSetGlobal)
        goto LabelSetGlobal;

      if(*pc++ == &&LabelSetStack)
        goto LabelSetStack;

      if(*pc++ == &&LabelAccBuiltin)
        goto LabelAccBuiltin;

      if(*pc++ == &&LabelAccIndex)
        goto LabelAccIndex;

      if(*pc++ == &&LabelAccArray)
        goto LabelAccArray;

      if(*pc++ == &&LabelAccField)
        goto LabelAccField;

      if(*pc++ == &&LabelAccEnv)
        goto LabelAccEnv;

      if(*pc++ == &&LabelAccGlobal)
        goto LabelAccGlobal;

      if(*pc++ == &&LabelAccStack)
        goto LabelAccStack;

      if(*pc++ == &&LabelAccInt)
        goto LabelAccInt;

      if(*pc++ == &&LabelAccThis)
        goto LabelAccThis;

      if(*pc++ == &&LabelAccFalse)
        goto LabelAccFalse;

      if(*pc++ == &&LabelAccTrue)
        goto LabelAccTrue;

      if(*pc++ == &&LabelAccNull)
        goto LabelAccNull;

      if(*pc++ == &&end)
        goto end;

    }


  LabelLast:
    ;
    goto end;

  end:
    ;
    vm->sp = sp;
    vm->csp = csp;
    return acc;
  }
}

// neko_is_big_endian
// file vm/module.c line 100
signed int neko_is_big_endian()
{
  return 0;
}

// neko_kind_share
// file vm/alloc.c line 430
void neko_kind_share(struct anonymous **k, const char *name)
{
  struct _klist *l = *kind_names;
  while(!(l == ((struct _klist *)NULL)))
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(l->name, name);
    if(return_value_strcmp_1 == 0)
    {
      *k = l->k;
      goto __CPROVER_DUMP_L4;
    }

    l = l->next;
  }
  char *return_value_neko_alloc_2;
  return_value_neko_alloc_2=neko_alloc((unsigned int)sizeof(struct _klist) /*24ul*/ );
  l = (struct _klist *)return_value_neko_alloc_2;
  l->k = *k;
  l->name = name;
  l->next = *kind_names;
  *kind_names = l;

__CPROVER_DUMP_L4:
  ;
}

// neko_local_get
// file vm/neko.h line 439
void * neko_local_get(struct _mt_local *l)
{
  if(l == ((struct _mt_local *)NULL))
    return (void *)0;

  else
  {
    void *return_value_pthread_getspecific_1;
    return_value_pthread_getspecific_1=pthread_getspecific(l->key);
    return return_value_pthread_getspecific_1;
  }
}

// neko_local_set
// file vm/neko.h line 440
void neko_local_set(struct _mt_local *l, void *v)
{
  pthread_setspecific(l->key, v);
}

// neko_lock_acquire
// file vm/neko.h line 444
void neko_lock_acquire(struct _mt_lock *l)
{
  pthread_mutex_lock(&l->lock);
}

// neko_lock_release
// file vm/neko.h line 446
void neko_lock_release(struct _mt_lock *l)
{
  pthread_mutex_unlock(&l->lock);
}

// neko_lock_try
// file vm/threads.c line 327
signed int neko_lock_try(struct _mt_lock *l)
{
  signed int return_value_pthread_mutex_trylock_1;
  return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&l->lock);
  return (signed int)(return_value_pthread_mutex_trylock_1 == 0);
}

// neko_module_jit
// file vm/jit_x86.c line 2782
void neko_module_jit(struct _neko_module *m)
{
  ;
}

// neko_process_trap
// file vm/interp.c line 588
void neko_process_trap(struct _neko_vm *vm)
{
  signed long int *sp;
  signed long int *trap;
  signed long int *tmp_post_1;
  if(!(vm->trap == 0l))
  {
    trap = vm->spmax - vm->trap;
    sp = vm->spmin + (signed long int)((signed int)(signed long int)trap[(signed long int)0] >> 1);
    vm->exc_stack=neko_flush_stack(vm->csp, sp, vm->exc_stack);
    vm->csp = sp;
    vm->vthis = (struct _value *)trap[(signed long int)1];
    vm->env = (struct _value *)trap[(signed long int)2];
    vm->jit_val = (void *)(signed long int *)(trap[(signed long int)3] & (signed long int)~1);
    sp = trap + (signed long int)6;
    vm->trap = (signed long int)((signed int)(signed long int)trap[(signed long int)5] >> 1);
    for( ; !(vm->sp >= sp); *tmp_post_1 = (signed long int)0)
    {
      tmp_post_1 = vm->sp;
      vm->sp = vm->sp + 1l;
    }
  }

}

// neko_read_module
// file vm/neko_mod.h line 59
struct _neko_module * neko_read_module(signed int (*r)(void *, void *, signed int), void *p, struct _value *loader)
{
  unsigned int i;
  unsigned int itmp;
  unsigned char t;
  unsigned short int stmp;
  char *tmp = (char *)(void *)0;
  unsigned char version = (unsigned char)1;
  struct _neko_module *m;
  char *return_value_neko_alloc_1;
  return_value_neko_alloc_1=neko_alloc((unsigned int)sizeof(struct _neko_module) /*96ul*/ );
  m = (struct _neko_module *)return_value_neko_alloc_1;
  struct _neko_vm *vm;
  void *return_value_neko_local_get_2;
  return_value_neko_local_get_2=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get_2;
  read_long(r, p, &itmp);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  unsigned int tmp_if_expr_7;
  signed int return_value_read_string_12;
  signed int return_value_1;
  signed int return_value_read_string_13;
  double return_value_atof_14;
  void *return_value_read_debug_infos_15;
  signed int return_value_2;
  unsigned int tmp_post_18;
  unsigned int tmp_post_19;
  unsigned int tmp_post_20;
  unsigned int tmp_post_21;
  unsigned int tmp_post_22;
  unsigned int tmp_post_23;
  unsigned int tmp_post_24;
  _Bool tmp_if_expr_25;
  _Bool tmp_if_expr_26;
  struct _value *return_value_get_builtin_27;
  struct _value *return_value_neko_alloc_string_28;
  struct _value *return_value_neko_alloc_string_29;
  _Bool tmp_if_expr_30;
  signed int return_value_neko_check_stack_32;
  signed int tmp_if_expr_35;
  _Bool tmp_if_expr_33;
  signed int return_value_neko_check_stack_34;
  if(!(itmp == 1330333006u))
  {
    free((void *)tmp);
    return (struct _neko_module *)(void *)0;
  }

  else
  {
    read_long(r, p, &m->nglobals);
    read_long(r, p, &m->nfields);
    read_long(r, p, &m->codesize);
    if(m->nglobals >= 65536u)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = m->nfields < (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = m->nfields > (unsigned int)0xFFFF ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = m->codesize < (unsigned int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = m->codesize > (unsigned int)0xFFFFF ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      free((void *)tmp);
      return (struct _neko_module *)(void *)0;
    }

    else
    {
      if(1u + m->codesize >= 257u)
        tmp_if_expr_7 = m->codesize + (unsigned int)1;

      else
        tmp_if_expr_7 = (unsigned int)0x100;
      void *return_value_malloc_8;
      return_value_malloc_8=malloc(sizeof(char) /*1ul*/  * (unsigned long int)tmp_if_expr_7);
      tmp = (char *)return_value_malloc_8;
      m->jit = (void *)0;
      m->jit_gc = (struct _value *)(void *)0;
      m->dbgtbl = val_null;
      m->dbgidxs = (struct _neko_debug *)(void *)0;
      char *return_value_neko_alloc_9;
      return_value_neko_alloc_9=neko_alloc((unsigned int)((unsigned long int)m->nglobals * sizeof(struct _value *) /*8ul*/ ));
      m->globals = (struct _value **)return_value_neko_alloc_9;
      char *return_value_neko_alloc_10;
      return_value_neko_alloc_10=neko_alloc((unsigned int)(sizeof(struct _value **) /*8ul*/  * (unsigned long int)m->nfields));
      m->fields = (struct _value **)return_value_neko_alloc_10;
      m->loader = loader;
      m->exports=neko_alloc_object((struct _value *)(void *)0);
      if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
        vm->fstats(vm, "neko_read_module_data", 1);

      struct _value *return_value_neko_alloc_abstract_11;
      return_value_neko_alloc_abstract_11=neko_alloc_abstract(neko_kind_module, (void *)m);
      neko_alloc_field(m->exports, neko_id_module, return_value_neko_alloc_abstract_11);
      i = (unsigned int)0;
      if(!(i >= m->nglobals))
      {
        signed int return_value;
        return_value=r(p, (void *)&t, 1);
        if(return_value == -1)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        if((signed int)t == 1)
        {
          return_value_read_string_12=read_string(r, p, tmp);
          if(return_value_read_string_12 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i] = val_null;
          read_long(r, p, &itmp);
          if((16777215u & itmp) >= m->codesize)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i]=neko_alloc_module_function((void *)m, (signed long int)(itmp & (unsigned int)0xFFFFFF), (signed int)(itmp >> 24));
          read_short(r, p, &stmp);
          m->globals[(signed long int)i]=neko_alloc_empty_string((unsigned int)stmp);
          return_value_1=r(p, (void *)&((struct anonymous_5 *)m->globals[(signed long int)i])->c, (signed int)stmp);
          if(return_value_1 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          return_value_read_string_13=read_string(r, p, tmp);
          if(return_value_read_string_13 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          return_value_atof_14=atof(tmp);
          m->globals[(signed long int)i]=neko_alloc_float(return_value_atof_14);
          return_value_read_debug_infos_15=read_debug_infos(r, p, tmp, m);
          if(return_value_read_debug_infos_15 == NULL)
          {
            tmp = (char *)(void *)0;
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i] = val_null;
          return_value_2=r(p, (void *)&version, 1);
          if(return_value_2 == -1)
          {
            free((void *)tmp);
            return (struct _neko_module *)(void *)0;
          }

          m->globals[(signed long int)i] = val_null;
        }

        free((void *)tmp);
        return (struct _neko_module *)(void *)0;
        i = i + 1u;
      }

      i = (unsigned int)0;
      for( ; !(i >= m->nfields); i = i + 1u)
      {
        signed int return_value_read_string_16;
        return_value_read_string_16=read_string(r, p, tmp);
        if(return_value_read_string_16 == -1)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        m->fields[(signed long int)i]=neko_alloc_string(tmp);
      }
      if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
      {
        vm->fstats(vm, "neko_read_module_data", 0);
        vm->fstats(vm, "neko_read_module_code", 1);
      }

      char *return_value_neko_alloc_private_17;
      return_value_neko_alloc_private_17=neko_alloc_private((unsigned int)(sizeof(signed long int) /*8ul*/  * (unsigned long int)(m->codesize + (unsigned int)1)));
      m->code = (signed long int *)return_value_neko_alloc_private_17;
      i = (unsigned int)0;
      if(!(i >= m->codesize))
      {
        signed int return_value_3;
        return_value_3=r(p, (void *)&t, 1);
        if(return_value_3 == -1)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        tmp[(signed long int)i] = (char)1;
        if((3 & (signed int)t) == 0)
        {
          tmp_post_18 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post_18] = (signed long int)((signed int)t >> 2);
          tmp_post_19 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post_19] = (signed long int)((signed int)t >> 3);
          tmp[(signed long int)i] = (char)0;
          tmp_post_20 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post_20] = (signed long int)((signed int)t >> 2 & 1);
          tmp_post_21 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post_21] = (signed long int)((signed int)t >> 2);
          if((signed int)t == 2)
          {
            signed int return_value_4;
            return_value_4=r(p, (void *)&t, 1);
            if(return_value_4 == -1)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i - (unsigned int)1)] = (signed long int)t;
          }

          else
          {
            signed int return_value_5;
            return_value_5=r(p, (void *)&t, 1);
            if(return_value_5 == -1)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            tmp[(signed long int)i] = (char)0;
            tmp_post_22 = i;
            i = i + 1u;
            m->code[(signed long int)tmp_post_22] = (signed long int)t;
          }
          tmp_post_23 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post_23] = (signed long int)((signed int)t >> 2);
          read_long(r, p, &itmp);
          tmp[(signed long int)i] = (char)0;
          tmp_post_24 = i;
          i = i + 1u;
          m->code[(signed long int)tmp_post_24] = (signed long int)(signed int)itmp;
        }

      }

      tmp[(signed long int)i] = (char)1;
      m->code[(signed long int)i] = (signed long int)67;
      if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
      {
        vm->fstats(vm, "neko_read_module_code", 0);
        vm->fstats(vm, "neko_read_module_check", 1);
      }

      i = (unsigned int)0;
      for( ; !(i >= m->codesize); i = i + 1u)
      {
        signed int c = (signed int)m->code[(signed long int)i];
        itmp = (unsigned int)m->code[(signed long int)(i + (unsigned int)1)];
        if(c >= 67)
          tmp_if_expr_25 = (_Bool)1;

        else
          tmp_if_expr_25 = (signed int)tmp[(signed long int)(i + (unsigned int)1)] == parameter_table[(signed long int)c] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_25)
        {
          free((void *)tmp);
          return (struct _neko_module *)(void *)0;
        }

        switch(m->code[(signed long int)i])
        {
          case (signed long int)6:

          case (signed long int)13:
          {
            if(itmp >= m->nglobals)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)(m->globals + (signed long int)itmp);
            break;
          }
          case (signed long int)23:

          case (signed long int)24:

          case (signed long int)25:

          case (signed long int)26:
          {
            itmp = itmp + i;
            if(!(m->codesize >= itmp))
              tmp_if_expr_26 = (_Bool)1;

            else
              tmp_if_expr_26 = !(tmp[(signed long int)itmp] != 0) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_26)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)(m->code + (signed long int)itmp);
            break;
          }
          case (signed long int)4:
          {
            if(!((1073741824u + (unsigned int)(signed int)itmp & 0x80000000) == 0u))
              m->code[(signed long int)i] = (signed long int)66;

            else
              m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)(struct _value *)(signed long int)((signed int)itmp << 1 | 1);
            break;
          }
          case (signed long int)10:
          {
            m->code[(signed long int)(i + (unsigned int)1)] = m->code[(signed long int)(i + (unsigned int)1)] + (signed long int)2;
            break;
          }
          case (signed long int)5:
          {
            m->code[(signed long int)(i + (unsigned int)1)] = m->code[(signed long int)(i + (unsigned int)1)] + (signed long int)2;
            itmp = (unsigned int)m->code[(signed long int)(i + (unsigned int)1)];
          }
          case (signed long int)12:
          {
            if(!((signed int)itmp >= 0))
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)28:

          case (signed long int)20:

          case (signed long int)7:

          case (signed long int)14:
          {
            if(!((signed int)itmp >= 0))
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)11:
          {
            signed int f = (signed int)(signed long int)itmp;
            if(f == id_loader)
              m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)loader;

            else
              if(f == id_exports)
                m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)m->exports;

              else
              {
                return_value_get_builtin_27=get_builtin(m, f);
                m->code[(signed long int)(i + (unsigned int)1)] = (signed long int)return_value_get_builtin_27;
              }
            break;
          }
          case (signed long int)21:

          case (signed long int)22:
          {
            if(itmp >= 6u)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)63:
          {
            if((7u & itmp) >= 6u)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)57:
          {
            if(itmp == 0u || itmp >= 5u)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            break;
          }
          case (signed long int)29:
          {
            if(itmp >= 256u)
            {
              return_value_neko_alloc_string_28=neko_alloc_string("Too much big environment");
              _neko_failure(return_value_neko_alloc_string_28, "vm/module.c", 537);
            }

            break;
          }
          case (signed long int)30:
          {
            if(itmp >= 65537u)
            {
              return_value_neko_alloc_string_29=neko_alloc_string("Too much big array");
              _neko_failure(return_value_neko_alloc_string_29, "vm/module.c", 541);
            }

            if((signed int)version >= 2)
              m->code[(signed long int)i] = (signed long int)65;

            break;
          }
          case (signed long int)56:
          {
            if(itmp >= 513u)
              tmp_if_expr_30 = (_Bool)1;

            else
              tmp_if_expr_30 = i + (unsigned int)1 + itmp * (unsigned int)2 >= m->codesize ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_30)
            {
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            m->code[(signed long int)(i + (unsigned int)1)] = m->code[(signed long int)(i + (unsigned int)1)] << 1;
          }
        }
        if(tmp[(signed long int)(1u + i)] == 0)
          i = i + 1u;

      }
      unsigned char *neko_read_module__1__9__stmp;
      void *return_value_malloc_31;
      return_value_malloc_31=malloc((unsigned long int)(m->codesize + (unsigned int)1));
      neko_read_module__1__9__stmp = (unsigned char *)return_value_malloc_31;
      unsigned int prev = (unsigned int)0;
      memset((void *)neko_read_module__1__9__stmp, (signed int)(unsigned char)-1, (unsigned long int)(m->codesize + (unsigned int)1));
      if(vm->trusted_code == 0)
      {
        return_value_neko_check_stack_32=neko_check_stack(m, neko_read_module__1__9__stmp, (unsigned int)0, 0, 0);
        if(!(return_value_neko_check_stack_32 == 0))
          goto __CPROVER_DUMP_L89;

        free((void *)neko_read_module__1__9__stmp);
        free((void *)tmp);
        return (struct _neko_module *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L89:
        ;
        i = (unsigned int)0;
        for( ; !(i >= m->nglobals); i = i + 1u)
        {
          struct anonymous_8 *neko_read_module__1__9__2__1__f = (struct anonymous_8 *)m->globals[(signed long int)i];
          if(!((1 & (signed int)neko_read_module__1__9__2__1__f) == 0))
            tmp_if_expr_35 = VAL_INT;

          else
            tmp_if_expr_35 = (signed int)*((enum anonymous_7 *)neko_read_module__1__9__2__1__f) & (1 << 4) - 1;
          if(tmp_if_expr_35 == VAL_FUNCTION)
          {
            itmp = (unsigned int)(signed long int)neko_read_module__1__9__2__1__f->addr;
            if(itmp >= m->codesize)
              tmp_if_expr_33 = (_Bool)1;

            else
              tmp_if_expr_33 = !(tmp[(signed long int)itmp] != 0) ? (_Bool)1 : (_Bool)0;
            if(!(itmp >= prev) || tmp_if_expr_33)
            {
              free((void *)neko_read_module__1__9__stmp);
              free((void *)tmp);
              return (struct _neko_module *)(void *)0;
            }

            if(vm->trusted_code == 0)
            {
              return_value_neko_check_stack_34=neko_check_stack(m, neko_read_module__1__9__stmp, itmp, neko_read_module__1__9__2__1__f->nargs, neko_read_module__1__9__2__1__f->nargs);
              if(return_value_neko_check_stack_34 == 0)
              {
                free((void *)neko_read_module__1__9__stmp);
                free((void *)tmp);
                return (struct _neko_module *)(void *)0;
              }

            }

            neko_read_module__1__9__2__1__f->addr = (void *)(m->code + (signed long int)itmp);
            prev = itmp;
          }

        }
        free((void *)neko_read_module__1__9__stmp);
        free((void *)tmp);
        if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
          vm->fstats(vm, "neko_read_module_check", 0);

        if(!(vm->run_jit == 0))
        {
          if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
            vm->fstats(vm, "neko_read_module_jit", 1);

          neko_module_jit(m);
          if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
            vm->fstats(vm, "neko_read_module_jit", 0);

        }

        signed long int *jtbl;
        jtbl=neko_get_ttable();
        if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
          vm->fstats(vm, "neko_read_module_thread", 1);

        i = (unsigned int)0;
        for( ; m->codesize >= i; i = i + 1u)
        {
          signed long int neko_read_module__1__11__1__1__c = m->code[(signed long int)i];
          m->code[(signed long int)i] = jtbl[neko_read_module__1__11__1__1__c];
          i = i + (unsigned int)parameter_table[neko_read_module__1__11__1__1__c];
        }
        if(!(vm->fstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
          vm->fstats(vm, "neko_read_module_thread", 0);

        return m;
      }
    }
  }
}

// neko_select_file
// file vm/load.c line 138
struct _value * neko_select_file(struct _value *path, const char *file, const char *ext)
{
  struct stat s;
  struct _value *ff;
  struct _buffer *b;
  b=neko_alloc_buffer(file);
  neko_buffer_append(b, ext);
  ff=neko_buffer_to_string(b);
  signed int return_value_stat_2;
  return_value_stat_2=stat(&((struct anonymous_5 *)ff)->c, &s);
  if(return_value_stat_2 == 0)
  {
    char *p;
    p=strchr(file, 47);
    if(p == ((char *)NULL))
      p=strchr(file, 92);

    if(!(p == ((char *)NULL)))
      return ff;

    b=neko_alloc_buffer("./");
    neko_buffer_append(b, file);
    neko_buffer_append(b, ext);
    struct _value *return_value_neko_buffer_to_string_1;
    return_value_neko_buffer_to_string_1=neko_buffer_to_string(b);
    return return_value_neko_buffer_to_string_1;
  }

  while((1 & (signed int)path) == 0)
  {
    if(!((15 & (signed int)*((enum anonymous_7 *)path)) == VAL_ARRAY))
      break;

    if(!((signed int)*((enum anonymous_7 *)path) >> 4 == 2))
      break;

    struct _value *neko_select_file__1__2__p = (&((struct anonymous_4 *)path)->ptr)[(signed long int)0];
    struct _buffer *neko_select_file__1__2__b;
    neko_select_file__1__2__b=neko_alloc_buffer((const char *)(void *)0);
    path = (&((struct anonymous_4 *)path)->ptr)[(signed long int)1];
    neko_val_buffer(neko_select_file__1__2__b, neko_select_file__1__2__p);
    neko_val_buffer(neko_select_file__1__2__b, ff);
    neko_select_file__1__2__p=neko_buffer_to_string(neko_select_file__1__2__b);
    signed int return_value_stat_3;
    return_value_stat_3=stat(&((struct anonymous_5 *)neko_select_file__1__2__p)->c, &s);
    if(return_value_stat_3 == 0)
      return neko_select_file__1__2__p;

  }
  return ff;
}

// neko_set_stack_base
// file vm/alloc.c line 426
void neko_set_stack_base(void *s)
{
  ;
}

// neko_setup_trap
// file vm/interp.c line 575
void neko_setup_trap(struct _neko_vm *vm)
{
  vm->sp = vm->sp - (signed long int)6;
  signed int return_value_neko_stack_expand_2;
  struct _value *return_value_neko_alloc_string_1;
  if(vm->csp >= vm->sp)
  {
    return_value_neko_stack_expand_2=neko_stack_expand(vm->sp, vm->csp, vm);
    if(return_value_neko_stack_expand_2 == 0)
    {
      return_value_neko_alloc_string_1=neko_alloc_string("Stack Overflow");
      neko_val_throw(return_value_neko_alloc_string_1);
    }

  }

  vm->sp[(signed long int)0] = (signed long int)(struct _value *)(signed long int)((signed int)(signed long int)(vm->csp - vm->spmin) << 1 | 1);
  vm->sp[(signed long int)1] = (signed long int)vm->vthis;
  vm->sp[(signed long int)2] = (signed long int)vm->env;
  vm->sp[(signed long int)3] = (signed long int)vm->jit_val | (signed long int)1;
  vm->sp[(signed long int)4] = (signed long int)val_null;
  vm->sp[(signed long int)5] = (signed long int)(struct _value *)(signed long int)((signed int)(signed long int)vm->trap << 1 | 1);
  vm->trap = vm->spmax - vm->sp;
}

// neko_stack_expand
// file vm/others.c line 348
signed int neko_stack_expand(signed long int *sp, signed long int *csp, struct _neko_vm *vm)
{
  signed int i;
  signed int size = (signed int)((unsigned long int)((signed long int)vm->spmax - (signed long int)vm->spmin) / sizeof(signed long int) /*8ul*/  << 1);
  signed long int *nsp;
  if(size >= 262145)
  {
    vm->sp = sp;
    vm->csp = csp;
    return 0;
  }

  else
  {
    char *return_value_neko_alloc_1;
    return_value_neko_alloc_1=neko_alloc((unsigned int)((unsigned long int)size * sizeof(signed long int) /*8ul*/ ));
    nsp = (signed long int *)return_value_neko_alloc_1;
    i = (signed int)((unsigned long int)((signed long int)(csp + (signed long int)1) - (signed long int)vm->spmin) / sizeof(signed long int) /*8ul*/ );
    memcpy((void *)nsp, (const void *)vm->spmin, sizeof(signed long int) /*8ul*/  * (unsigned long int)i);
    vm->csp = (nsp + (signed long int)i) - (signed long int)1;
    i = (signed int)((unsigned long int)((signed long int)vm->spmax - (signed long int)sp) / sizeof(signed long int) /*8ul*/ );
    memcpy((void *)((nsp + (signed long int)size) - (signed long int)i), (const void *)sp, sizeof(signed long int) /*8ul*/  * (unsigned long int)i);
    vm->sp = (nsp + (signed long int)size) - (signed long int)i;
    vm->spmin = nsp;
    vm->spmax = nsp + (signed long int)size;
    return 1;
  }
}

// neko_stats_build
// file vm/stats.c line 183
struct _value * neko_stats_build(struct _neko_vm *vm)
{
  struct _value *v = val_null;
  struct _statinfos *s = list;
  _Bool tmp_if_expr_2;
  signed int return_value_memcmp_1;
  while(!(s == ((struct _statinfos *)NULL)))
  {
    struct _statinfos *s2 = s->next;
    struct _statinfos *prev = s;
    while(!(s2 == ((struct _statinfos *)NULL)))
    {
      if(s2->ksize == s->ksize)
      {
        return_value_memcmp_1=memcmp((const void *)s->kind, (const void *)s2->kind, (unsigned long int)s->ksize);
        tmp_if_expr_2 = return_value_memcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        s->nerrors = s->nerrors + s2->nerrors;
        s->ncalls = s->ncalls + s2->ncalls;
        s->totaltime = s->totaltime + s2->totaltime;
        s->subtime = s->subtime + s2->subtime;
        prev->next = s2->next;
        free((void *)s2);
        s2 = prev->next;
      }

      else
      {
        prev = s2;
        s2 = s2->next;
      }
    }
    s = s->next;
  }
  list=sort(list);
  s = list;
  while(!(s == ((struct _statinfos *)NULL)))
  {
    struct _value *tmp;
    tmp=neko_alloc_array((unsigned int)6);
    (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)0]=neko_alloc_string(s->kind);
    (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)s->totaltime << 1 | 1);
    (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)2] = (struct _value *)(signed long int)((signed int)(s->totaltime - s->subtime) << 1 | 1);
    (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)3] = (struct _value *)(signed long int)((signed int)s->ncalls << 1 | 1);
    (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)4] = (struct _value *)(signed long int)((signed int)s->nerrors << 1 | 1);
    (&((struct anonymous_4 *)tmp)->ptr)[(signed long int)5] = v;
    v = tmp;
    s = s->next;
  }
  return v;
}

// neko_stats_measure
// file vm/stats.c line 79
void neko_stats_measure(struct _neko_vm *vm, const char *kind, signed int start)
{
  signed int ksize;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(kind);
  ksize = (signed int)return_value_strlen_1;
  struct _statinfos *s;
  signed int return_value_memcmp_2;
  signed int return_value_memcmp_4;
  if(!(start == 0))
  {
    signed int time;
    time=precise_timer();
    s = list;
    while(!(s == ((struct _statinfos *)NULL)))
    {
      if(ksize == s->ksize)
      {
        if(s->starttime == 0)
        {
          return_value_memcmp_2=memcmp((const void *)kind, (const void *)s->kind, (unsigned long int)ksize);
          if(return_value_memcmp_2 == 0)
            break;

        }

      }

      s = s->next;
    }
    if(s == ((struct _statinfos *)NULL))
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(struct _statinfos) /*48ul*/ );
      s = (struct _statinfos *)return_value_malloc_3;
      s->kind=strdup(kind);
      s->ksize = ksize;
      s->ncalls = 0;
      s->nerrors = 0;
      s->totaltime = 0;
      s->subtime = 0;
      s->next = list;
      list = s;
    }

    s->ncalls = s->ncalls + 1;
    s->stack = stack;
    stack = s;
    s->starttime = time;
  }

  else
  {
    s = stack;
    while(!(s == ((struct _statinfos *)NULL)))
    {
      struct _statinfos *next;
      if(ksize == s->ksize)
      {
        return_value_memcmp_4=memcmp((const void *)kind, (const void *)s->kind, (unsigned long int)ksize);
        if(return_value_memcmp_4 == 0)
          break;

      }

      next = s->stack;
      s->nerrors = s->nerrors + 1;
      s->starttime = 0;
      s = next;
    }
    if(!(s == ((struct _statinfos *)NULL)))
    {
      signed int delta;
      signed int return_value_precise_timer_5;
      return_value_precise_timer_5=precise_timer();
      delta = return_value_precise_timer_5 - s->starttime;
      s->totaltime = s->totaltime + delta;
      stack = s->stack;
      if(!(stack == ((struct _statinfos *)NULL)))
        stack->subtime = stack->subtime + delta;

      s->starttime = 0;
    }

    else
      stack = (struct _statinfos *)(void *)0;
  }
}

// neko_string_reader
// file vm/module.c line 621
signed int neko_string_reader(void *p, void *buf, signed int size)
{
  struct anonymous_20 *sp = (struct anonymous_20 *)p;
  signed int delta;
  signed int tmp_if_expr_1;
  if(sp->len >= size)
    tmp_if_expr_1 = size;

  else
    tmp_if_expr_1 = sp->len;
  delta = tmp_if_expr_1;
  memcpy(buf, (const void *)sp->p, (unsigned long int)delta);
  sp->p = sp->p + (signed long int)delta;
  sp->len = sp->len - delta;
  return delta;
}

// neko_thread_blocking
// file vm/threads.c line 181
void neko_thread_blocking(void (*f)(void *), void *p)
{
  struct _value *return_value_neko_alloc_string_4;
  static signed int (*end)() = (signed int (*)())(void *)0;
  static signed int (*start)() = (signed int (*)())(void *)0;
  static void (*do_blocking)(void (*)(void *), void *) = (void (*)(void (*)(void *), void *))(void *)0;
  if(!(do_blocking == ((void (*)(void (*)(void *), void *))NULL)))
    do_blocking(f, p);

  else
    if(!(start == ((signed int (*)())NULL)))
    {
      start();
      f(p);
      end();
    }

    else
    {
      void *neko_thread_blocking__1__2__self;
      neko_thread_blocking__1__2__self=GC_dlopen((const char *)(void *)0, 0);
      void *return_value_dlsym_1;
      return_value_dlsym_1=dlsym(neko_thread_blocking__1__2__self, "GC_do_blocking");
      do_blocking = (void (*)(void (*)(void *), void *))return_value_dlsym_1;
      if(do_blocking == ((void (*)(void (*)(void *), void *))NULL))
      {
        void *return_value_dlsym_2;
        return_value_dlsym_2=dlsym(neko_thread_blocking__1__2__self, "GC_start_blocking");
        start = (signed int (*)())return_value_dlsym_2;
        void *return_value_dlsym_3;
        return_value_dlsym_3=dlsym(neko_thread_blocking__1__2__self, "GC_end_blocking");
        end = (signed int (*)())return_value_dlsym_3;
        if(end == ((signed int (*)())NULL) || start == ((signed int (*)())NULL))
        {
          return_value_neko_alloc_string_4=neko_alloc_string("Could not init GC blocking API");
          neko_val_throw(return_value_neko_alloc_string_4);
        }

      }

      neko_thread_blocking(f, p);
    }
}

// neko_thread_create
// file vm/threads.c line 128
signed int neko_thread_create(void (*init)(void *), void (*main)(void *), void *param, void **handle)
{
  struct anonymous_23 p;
  p.init = init;
  p.main = main;
  p.param = param;
  union pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, 1);
  pthread_mutex_init(&p.lock, (const union anonymous_21 *)(void *)0);
  pthread_mutex_lock(&p.lock);
  signed int return_value_GC_pthread_create_1;
  return_value_GC_pthread_create_1=GC_pthread_create((unsigned long int *)handle, &attr, ThreadMain, (void *)&p);
  if(!(return_value_GC_pthread_create_1 == 0))
  {
    pthread_attr_destroy(&attr);
    pthread_mutex_destroy(&p.lock);
    return 0;
  }

  else
  {
    pthread_mutex_lock(&p.lock);
    pthread_attr_destroy(&attr);
    pthread_mutex_destroy(&p.lock);
    return 1;
  }
}

// neko_thread_register
// file vm/threads.c line 211
signed int neko_thread_register(signed int t)
{
  static signed int (*get_sb)(char (*)[64l]) = (signed int (*)(char (*)[64l]))(void *)0;
  static signed int (*my_thread)(char (*)[64l]) = (signed int (*)(char (*)[64l]))(void *)0;
  static signed int (*unreg_my_thread)() = (signed int (*)())(void *)0;
  if(t == 0 && !(unreg_my_thread == ((signed int (*)())NULL)))
  {
    signed int return_value;
    return_value=unreg_my_thread();
    return (signed int)(return_value == 0);
  }

  else
    if(!(my_thread == ((signed int (*)(char (*)[64l]))NULL)))
    {
      char sb[64l];
      signed int r;
      signed int return_value_1;
      return_value_1=get_sb(&sb);
      if(!(return_value_1 == 0))
        return 0;

      r=my_thread(&sb);
      return (signed int)(r == 0 || r == 1);
    }

    else
    {
      void *neko_thread_register__1__3__self;
      neko_thread_register__1__3__self=GC_dlopen((const char *)(void *)0, 0);
      void *return_value_dlsym_1;
      return_value_dlsym_1=dlsym(neko_thread_register__1__3__self, "GC_register_my_thread");
      my_thread = (signed int (*)(char (*)[64l]))return_value_dlsym_1;
      void *return_value_dlsym_2;
      return_value_dlsym_2=dlsym(neko_thread_register__1__3__self, "GC_get_stack_base");
      get_sb = (signed int (*)(char (*)[64l]))return_value_dlsym_2;
      void *return_value_dlsym_3;
      return_value_dlsym_3=dlsym(neko_thread_register__1__3__self, "GC_unregister_my_thread");
      unreg_my_thread = (signed int (*)())return_value_dlsym_3;
      if(my_thread == ((signed int (*)(char (*)[64l]))NULL))
        my_thread = do_nothing;

      if(get_sb == ((signed int (*)(char (*)[64l]))NULL))
        get_sb = do_nothing;

      if(unreg_my_thread == ((signed int (*)())NULL))
        unreg_my_thread = (signed int (*)())do_nothing;

      signed int return_value_neko_thread_register_4;
      return_value_neko_thread_register_4=neko_thread_register(t);
      return return_value_neko_thread_register_4;
    }
}

// neko_val_buffer
// file vm/neko.h line 425
void neko_val_buffer(struct _buffer *b, struct _value *v)
{
  val_buffer_rec(b, v, (struct vlist *)(void *)0);
}

// neko_val_call0
// file vm/callback.c line 145
struct _value * neko_val_call0(struct _value *f)
{
  struct _value *return_value_neko_val_callN_1;
  return_value_neko_val_callN_1=neko_val_callN(f, (struct _value **)(void *)0, 0);
  return return_value_neko_val_callN_1;
}

// neko_val_call1
// file vm/neko.h line 404
struct _value * neko_val_call1(struct _value *f, struct _value *v)
{
  struct _value *return_value_neko_val_callN_1;
  return_value_neko_val_callN_1=neko_val_callN(f, &v, 1);
  return return_value_neko_val_callN_1;
}

// neko_val_call2
// file vm/neko.h line 405
struct _value * neko_val_call2(struct _value *f, struct _value *v1, struct _value *v2)
{
  struct _value *args[2l] = { v1, v2 };
  struct _value *return_value_neko_val_callN_1;
  return_value_neko_val_callN_1=neko_val_callN(f, args, 2);
  return return_value_neko_val_callN_1;
}

// neko_val_call3
// file vm/callback.c line 158
struct _value * neko_val_call3(struct _value *f, struct _value *arg1, struct _value *arg2, struct _value *arg3)
{
  struct _value *args[3l] = { arg1, arg2, arg3 };
  struct _value *return_value_neko_val_callN_1;
  return_value_neko_val_callN_1=neko_val_callN(f, args, 3);
  return return_value_neko_val_callN_1;
}

// neko_val_callEx
// file vm/neko.h line 412
struct _value * neko_val_callEx(struct _value *vthis, struct _value *f, struct _value **args, signed int nargs, struct _value **exc)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get_1;
  struct _value *old_this = vm->vthis;
  struct _value *old_env = vm->env;
  struct _value *ret = val_null;
  struct __jmp_buf_tag oldjmp[1l];
  if(!(vthis == ((struct _value *)NULL)))
    vm->vthis = vthis;

  if(!(exc == ((struct _value **)NULL)))
  {
    memcpy((void *)&oldjmp, (const void *)&vm->start, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
    signed int return_value__setjmp_2;
    return_value__setjmp_2=_setjmp(vm->start);
    if(!(return_value__setjmp_2 == 0))
    {
      *exc = vm->vthis;
      neko_process_trap(vm);
      vm->vthis = old_this;
      vm->env = old_env;
      memcpy((void *)&vm->start, (const void *)&oldjmp, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
      return val_null;
    }

    neko_setup_trap(vm);
  }

  struct _value *return_value_neko_alloc_string_3;
  if(!((unsigned long int)&vm >= (unsigned long int)vm->c_stack_max))
  {
    return_value_neko_alloc_string_3=neko_alloc_string("C Stack Overflow");
    neko_val_throw(return_value_neko_alloc_string_3);
  }

  struct _value *return_value_neko_alloc_string_4;
  if(!((1 & (signed int)f) == 0))
  {
    return_value_neko_alloc_string_4=neko_alloc_string("Invalid call");
    neko_val_throw(return_value_neko_alloc_string_4);
  }

  struct _value *return_value_neko_alloc_string_5;
  struct _value *return_value;
  struct _value *return_value_neko_alloc_string_6;
  _Bool tmp_if_expr_9;
  signed int return_value_neko_stack_expand_8;
  struct _value *return_value_neko_alloc_string_10;
  struct _value *return_value_neko_alloc_string_11;
  if((signed int)*((enum anonymous_7 *)f) == VAL_PRIMITIVE)
  {
    vm->env = ((struct anonymous_8 *)f)->env;
    if(nargs == ((struct anonymous_8 *)f)->nargs)
    {
      if(nargs >= 6)
      {
        return_value_neko_alloc_string_5=neko_alloc_string("Too many arguments for a call");
        _neko_failure(return_value_neko_alloc_string_5, "vm/callback.c", 72);
      }

      switch(nargs)
      {
        case 0:
          ret=((struct _value * (*)())((struct anonymous_8 *)f)->addr)();
        case 1:
          ret=((struct _value * (*)(struct _value *))((struct anonymous_8 *)f)->addr)(args[(signed long int)0]);
        case 2:
          ret=((struct _value * (*)(struct _value *, struct _value *))((struct anonymous_8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1]);
        case 3:
          ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *))((struct anonymous_8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1], args[(signed long int)2]);
        case 4:
          ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *, struct _value *))((struct anonymous_8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1], args[(signed long int)2], args[(signed long int)3]);
        case 5:
          ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *, struct _value *, struct _value *))((struct anonymous_8 *)f)->addr)(args[(signed long int)0], args[(signed long int)1], args[(signed long int)2], args[(signed long int)3], args[(signed long int)4]);
      }
    }

    else
      if(((struct anonymous_8 *)f)->nargs == -1)
      {
        return_value=((struct _value * (*)(struct _value **, signed int))((struct anonymous_8 *)f)->addr)(args, nargs);
        ret = (struct _value *)return_value;
      }

      else
      {
        return_value_neko_alloc_string_6=neko_alloc_string("Invalid call");
        neko_val_throw(return_value_neko_alloc_string_6);
      }
    if(ret == ((struct _value *)NULL))
      neko_val_throw((struct _value *)((struct anonymous_8 *)f)->module);

  }

  else
    if((15 & (signed int)*((enum anonymous_7 *)f)) == VAL_FUNCTION)
    {
      if(nargs == ((struct anonymous_8 *)f)->nargs)
      {
        signed int n;
        if(vm->csp + 4l >= vm->sp + -((signed long int)nargs))
        {
          return_value_neko_stack_expand_8=neko_stack_expand(vm->sp, vm->csp, vm);
          tmp_if_expr_9 = !(return_value_neko_stack_expand_8 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
        {
          if(!(exc == ((struct _value **)NULL)))
          {
            neko_process_trap(vm);
            memcpy((void *)&vm->start, (const void *)&oldjmp, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
          }

          struct _value *return_value_neko_alloc_string_7;
          return_value_neko_alloc_string_7=neko_alloc_string("Stack Overflow");
          _neko_failure(return_value_neko_alloc_string_7, "vm/callback.c", 107);
        }

        else
        {
          n = 0;
          for( ; !(n >= nargs); n = n + 1)
          {
            vm->sp = vm->sp - 1l;
            *vm->sp = (signed long int)args[(signed long int)n];
          }
          vm->env = ((struct anonymous_8 *)f)->env;
          if((signed int)*((enum anonymous_7 *)f) == VAL_FUNCTION)
          {
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)callback_return;
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)0;
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)0;
            vm->csp = vm->csp + 1l;
            *vm->csp = (signed long int)0;
            ret=neko_interp(vm, ((struct anonymous_8 *)f)->module, (signed long int)val_null, (signed long int *)((struct anonymous_8 *)f)->addr);
          }

          else
          {
            struct _neko_module *m = (struct _neko_module *)((struct anonymous_8 *)f)->module;
            ret=((struct _value * (*)(struct _neko_vm *, void *, struct _value *, struct _neko_module *))jit_boot_seq)(vm, ((struct anonymous_8 *)f)->addr, val_null, m);
          }
        }
      }

      else
      {
        return_value_neko_alloc_string_10=neko_alloc_string("Invalid call");
        neko_val_throw(return_value_neko_alloc_string_10);
      }
    }

    else
    {
      return_value_neko_alloc_string_11=neko_alloc_string("Invalid call");
      neko_val_throw(return_value_neko_alloc_string_11);
    }
  if(!(exc == ((struct _value **)NULL)))
  {
    neko_process_trap(vm);
    memcpy((void *)&vm->start, (const void *)&oldjmp, sizeof(struct __jmp_buf_tag [1l]) /*200ul*/ );
  }

  vm->vthis = old_this;
  vm->env = old_env;
  return ret;
}

// neko_val_callN
// file vm/neko.h line 407
struct _value * neko_val_callN(struct _value *f, struct _value **args, signed int nargs)
{
  struct _value *return_value_neko_val_callEx_1;
  return_value_neko_val_callEx_1=neko_val_callEx((struct _value *)(void *)0, f, args, nargs, (struct _value **)(void *)0);
  return return_value_neko_val_callEx_1;
}

// neko_val_compare
// file vm/neko.h line 427
signed int neko_val_compare(struct _value *a, struct _value *b)
{
  char tmp_buf[32l];
  signed int tmp_if_expr_1;
  if(!((1 & (signed int)a) == 0))
    tmp_if_expr_1 = VAL_INT;

  else
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)a) & (1 << 4) - 1;
  signed int tmp_if_expr_2;
  if(!((1 & (signed int)b) == 0))
    tmp_if_expr_2 = VAL_INT;

  else
    tmp_if_expr_2 = (signed int)*((enum anonymous_7 *)b) & (1 << 4) - 1;
  signed int return_value_icmp_3;
  signed int return_value_icmp_4;
  signed int return_value_icmp_5;
  signed int return_value_icmp_6;
  signed int return_value_fcmp_7;
  signed int return_value_fcmp_8;
  signed int return_value_sprintf_9;
  signed int return_value_scmp_10;
  signed int return_value_sprintf_11;
  signed int return_value_scmp_12;
  signed int return_value_fcmp_13;
  signed int return_value_fcmp_14;
  signed int return_value_fcmp_15;
  signed int return_value_sprintf_16;
  signed int return_value_scmp_17;
  signed int return_value_sprintf_18;
  signed int return_value_scmp_19;
  signed int return_value_sprintf_20;
  signed int return_value_scmp_21;
  signed int return_value_sprintf_22;
  signed int return_value_scmp_23;
  signed int return_value_scmp_24;
  signed int return_value_scmp_25;
  signed int return_value_scmp_26;
  if(!((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 65535))
  {
    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 2303)
      goto __CPROVER_DUMP_L6;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 65288)
      goto __CPROVER_DUMP_L7;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 2056)
      goto __CPROVER_DUMP_L8;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 65281)
      goto __CPROVER_DUMP_L9;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 2049)
      goto __CPROVER_DUMP_L10;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 65283)
      goto __CPROVER_DUMP_L11;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 2051)
      goto __CPROVER_DUMP_L12;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 511)
      goto __CPROVER_DUMP_L13;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 264)
      goto __CPROVER_DUMP_L14;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 257)
      goto __CPROVER_DUMP_L15;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 259)
      goto __CPROVER_DUMP_L16;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 1023)
      goto __CPROVER_DUMP_L17;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 776)
      goto __CPROVER_DUMP_L18;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 769)
      goto __CPROVER_DUMP_L19;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 770)
      goto __CPROVER_DUMP_L20;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 515)
      goto __CPROVER_DUMP_L21;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 771)
      goto __CPROVER_DUMP_L22;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 514)
      goto __CPROVER_DUMP_L23;

    if((tmp_if_expr_1 << 8 | tmp_if_expr_2) == 1028)
      goto __CPROVER_DUMP_L24;

  }

  else
  {
    return_value_icmp_3=icmp((signed int)(signed long int)a >> 1, (signed int)(signed long int)b >> 1);
    return return_value_icmp_3;

  __CPROVER_DUMP_L6:
    ;
    return_value_icmp_4=icmp(((struct anonymous_26 *)a)->i, (signed int)(signed long int)b >> 1);
    return return_value_icmp_4;

  __CPROVER_DUMP_L7:
    ;
    return_value_icmp_5=icmp((signed int)(signed long int)a >> 1, ((struct anonymous_26 *)b)->i);
    return return_value_icmp_5;

  __CPROVER_DUMP_L8:
    ;
    return_value_icmp_6=icmp(((struct anonymous_26 *)a)->i, ((struct anonymous_26 *)b)->i);
    return return_value_icmp_6;

  __CPROVER_DUMP_L9:
    ;
    return_value_fcmp_7=fcmp((double)((signed int)(signed long int)a >> 1), ((struct anonymous_25 *)b)->f);
    return return_value_fcmp_7;

  __CPROVER_DUMP_L10:
    ;
    return_value_fcmp_8=fcmp((double)((struct anonymous_26 *)a)->i, ((struct anonymous_25 *)b)->f);
    return return_value_fcmp_8;

  __CPROVER_DUMP_L11:
    ;
    return_value_sprintf_9=sprintf(tmp_buf, "%d", (signed int)(signed long int)a >> 1);
    return_value_scmp_10=scmp(tmp_buf, return_value_sprintf_9, &((struct anonymous_5 *)b)->c, (signed int)*((enum anonymous_7 *)b) >> 4);
    return return_value_scmp_10;

  __CPROVER_DUMP_L12:
    ;
    return_value_sprintf_11=sprintf(tmp_buf, "%d", ((struct anonymous_26 *)a)->i);
    return_value_scmp_12=scmp(tmp_buf, return_value_sprintf_11, &((struct anonymous_5 *)b)->c, (signed int)*((enum anonymous_7 *)b) >> 4);
    return return_value_scmp_12;

  __CPROVER_DUMP_L13:
    ;
    return_value_fcmp_13=fcmp(((struct anonymous_25 *)a)->f, (double)((signed int)(signed long int)b >> 1));
    return return_value_fcmp_13;

  __CPROVER_DUMP_L14:
    ;
    return_value_fcmp_14=fcmp(((struct anonymous_25 *)a)->f, (double)((struct anonymous_26 *)b)->i);
    return return_value_fcmp_14;

  __CPROVER_DUMP_L15:
    ;
    return_value_fcmp_15=fcmp(((struct anonymous_25 *)a)->f, ((struct anonymous_25 *)b)->f);
    return return_value_fcmp_15;

  __CPROVER_DUMP_L16:
    ;
    return_value_sprintf_16=sprintf(tmp_buf, "%.15g", ((struct anonymous_25 *)a)->f);
    return_value_scmp_17=scmp(tmp_buf, return_value_sprintf_16, &((struct anonymous_5 *)b)->c, (signed int)*((enum anonymous_7 *)b) >> 4);
    return return_value_scmp_17;

  __CPROVER_DUMP_L17:
    ;
    return_value_sprintf_18=sprintf(tmp_buf, "%d", (signed int)(signed long int)b >> 1);
    return_value_scmp_19=scmp(&((struct anonymous_5 *)a)->c, (signed int)*((enum anonymous_7 *)a) >> 4, tmp_buf, return_value_sprintf_18);
    return return_value_scmp_19;

  __CPROVER_DUMP_L18:
    ;
    return_value_sprintf_20=sprintf(tmp_buf, "%d", ((struct anonymous_26 *)b)->i);
    return_value_scmp_21=scmp(&((struct anonymous_5 *)a)->c, (signed int)*((enum anonymous_7 *)a) >> 4, tmp_buf, return_value_sprintf_20);
    return return_value_scmp_21;

  __CPROVER_DUMP_L19:
    ;
    return_value_sprintf_22=sprintf(tmp_buf, "%.15g", ((struct anonymous_25 *)b)->f);
    return_value_scmp_23=scmp(&((struct anonymous_5 *)a)->c, (signed int)*((enum anonymous_7 *)a) >> 4, tmp_buf, return_value_sprintf_22);
    return return_value_scmp_23;

  __CPROVER_DUMP_L20:
    ;
    return_value_scmp_24=scmp(&((struct anonymous_5 *)a)->c, (signed int)*((enum anonymous_7 *)a) >> 4, b == val_true ? "true" : "false", b == val_true ? 4 : 5);
    return return_value_scmp_24;

  __CPROVER_DUMP_L21:
    ;
    return_value_scmp_25=scmp(a == val_true ? "true" : "false", a == val_true ? 4 : 5, &((struct anonymous_5 *)b)->c, (signed int)*((enum anonymous_7 *)b) >> 4);
    return return_value_scmp_25;

  __CPROVER_DUMP_L22:
    ;
    return_value_scmp_26=scmp(&((struct anonymous_5 *)a)->c, (signed int)*((enum anonymous_7 *)a) >> 4, &((struct anonymous_5 *)b)->c, (signed int)*((enum anonymous_7 *)b) >> 4);
    return return_value_scmp_26;

  __CPROVER_DUMP_L23:
    ;
    return a == b ? 0 : (a == val_true ? 1 : -1);

  __CPROVER_DUMP_L24:
    ;
    if(a == b)
      return 0;

    struct _value *tmp;
    tmp=neko_val_field(a, id_compare);
    if(tmp == val_null)
      return 0xFE;

    a=neko_val_callEx(a, tmp, &b, 1, (struct _value **)(void *)0);
    if(!((1 & (signed int)a) == 0))
      return (signed int)(signed long int)a >> 1;

    return 0xFE;
  }
  if(a == b)
    return 0;

  else
    return 0xFE;
}

// neko_val_field
// file vm/neko.h line 394
struct _value * neko_val_field(struct _value *_o, signed int id)
{
  struct _value **f;
  struct _vobject *o = (struct _vobject *)_o;
  do
  {
    f=otable_find_link2(&o->table, id);
    if(!(f == ((struct _value **)NULL)))
      return *f;

    o = o->proto;
  }
  while(!(o == ((struct _vobject *)NULL)));
  return val_null;
}

// neko_val_field_name
// file vm/neko.h line 398
struct _value * neko_val_field_name(signed int id)
{
  struct _value *return_value_otable_get_1;
  return_value_otable_get_1=otable_get(&neko_fields[(signed long int)(id & 63)], id);
  return return_value_otable_get_1;
}

// neko_val_gc
// file vm/alloc.c line 348
void neko_val_gc(struct _value *v, void (*f)(struct _value *))
{
  _Bool tmp_if_expr_2;
  if((1 & (signed int)v) == 0)
    tmp_if_expr_2 = (signed int)*((enum anonymous_7 *)v) == VAL_ABSTRACT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  struct _value *return_value_neko_alloc_string_1;
  if(!tmp_if_expr_2)
  {
    return_value_neko_alloc_string_1=neko_alloc_string("val_gc");
    _neko_failure(return_value_neko_alloc_string_1, "vm/alloc.c", 350);
  }

  if(!(f == ((void (*)(struct _value *))NULL)))
    GC_register_finalizer_no_order((void *)v, (void (*)(void *, void *))__on_finalize, (void *)f, ((void (**)(void *, void *))NULL), ((void **)NULL));

  else
    GC_register_finalizer_no_order((void *)v, (void (*)(void *, void *))(void *)0, (void *)0, ((void (**)(void *, void *))NULL), ((void **)NULL));
}

// neko_val_hash
// file vm/neko.h line 432
signed int neko_val_hash(struct _value *v)
{
  signed int h = 0;
  hash_rec(v, &h, (struct vlist *)(void *)0);
  return (signed int)((unsigned int)h & (unsigned int)0x3FFFFFFF);
}

// neko_val_id
// file vm/neko.h line 393
signed int neko_val_id(const char *name)
{
  struct _objtable *t;
  struct _value *fdata;
  signed int f;
  struct _value *acc = (struct _value *)(signed long int)((signed int)0 << 1 | 1);
  const char *oname = name;
  for( ; !(*name == 0); name = name + 1l)
    acc = (struct _value *)(signed long int)((signed int)(223 * ((signed int)(signed long int)acc >> 1) + (signed int)*((unsigned char *)name)) << 1 | 1);
  f = (signed int)(signed long int)acc >> 1;
  t = &neko_fields[(signed long int)(f & 63)];
  fdata=otable_get(t, f);
  if(fdata == val_null)
  {
    signed int min;
    signed int max;
    signed int mid;
    signed int cid;
    struct anonymous_3 *c;
    neko_lock_acquire(neko_fields_lock);
    min = 0;
    max = t->count;
    c = t->cells;
    while(!(min >= max))
    {
      mid = min + max >> 1;
      cid = (c + (signed long int)mid)->id;
      if(!(cid >= f))
        min = mid + 1;

      else
        if(!(f >= cid))
          max = mid;

        else
        {
          fdata = (c + (signed long int)mid)->v;
          break;
        }
    }
    if(fdata == val_null)
    {
      struct anonymous_3 *c2;
      char *return_value_neko_alloc_1;
      return_value_neko_alloc_1=neko_alloc((unsigned int)(sizeof(struct anonymous_3) /*16ul*/  * (unsigned long int)(t->count + 1)));
      c2 = (struct anonymous_3 *)return_value_neko_alloc_1;
      mid = min + max >> 1;
      min = 0;
      for( ; !(min >= mid); min = min + 1)
        c2[(signed long int)min] = c[(signed long int)min];
      (c2 + (signed long int)min)->id = f;
      (c2 + (signed long int)min)->v=neko_copy_string(oname, name - oname);
      max = t->count;
      for( ; !(min >= max); min = min + 1)
        c2[(signed long int)(min + 1)] = c[(signed long int)min];
      t->cells = c2;
      t->count = t->count + 1;
    }

    neko_lock_release(neko_fields_lock);
  }

  signed int return_value_scmp_3;
  if(!(fdata == val_null))
  {
    return_value_scmp_3=scmp(&((struct anonymous_5 *)fdata)->c, (signed int)*((enum anonymous_7 *)fdata) >> 4, oname, (signed int)(name - oname));
    if(!(return_value_scmp_3 == 0))
    {
      struct _buffer *b;
      b=neko_alloc_buffer("Field conflict between ");
      neko_val_buffer(b, fdata);
      neko_buffer_append(b, " and ");
      neko_buffer_append(b, oname);
      struct _value *return_value_neko_buffer_to_string_2;
      return_value_neko_buffer_to_string_2=neko_buffer_to_string(b);
      _neko_failure(return_value_neko_buffer_to_string_2, "vm/others.c", 442);
    }

  }

  return f;
}

// neko_val_iter_fields
// file vm/others.c line 465
void neko_val_iter_fields(struct _value *o, void (*f)(struct _value *, signed int, void *), void *p)
{
  otable_iter(&((struct _vobject *)o)->table, f, p);
}

// neko_val_ocall0
// file vm/neko.h line 408
struct _value * neko_val_ocall0(struct _value *o, signed int f)
{
  struct _value *return_value_neko_val_ocallN_1;
  return_value_neko_val_ocallN_1=neko_val_ocallN(o, f, (struct _value **)(void *)0, 0);
  return return_value_neko_val_ocallN_1;
}

// neko_val_ocall1
// file vm/callback.c line 167
struct _value * neko_val_ocall1(struct _value *o, signed int f, struct _value *arg)
{
  struct _value *return_value_neko_val_ocallN_1;
  return_value_neko_val_ocallN_1=neko_val_ocallN(o, f, &arg, 1);
  return return_value_neko_val_ocallN_1;
}

// neko_val_ocall2
// file vm/callback.c line 171
struct _value * neko_val_ocall2(struct _value *o, signed int f, struct _value *arg1, struct _value *arg2)
{
  struct _value *args[2l] = { arg1, arg2 };
  struct _value *return_value_neko_val_ocallN_1;
  return_value_neko_val_ocallN_1=neko_val_ocallN(o, f, args, 2);
  return return_value_neko_val_ocallN_1;
}

// neko_val_ocallN
// file vm/neko.h line 411
struct _value * neko_val_ocallN(struct _value *o, signed int f, struct _value **args, signed int nargs)
{
  struct _value *return_value_neko_val_field_1;
  return_value_neko_val_field_1=neko_val_field(o, f);
  struct _value *return_value_neko_val_callEx_2;
  return_value_neko_val_callEx_2=neko_val_callEx(o, return_value_neko_val_field_1, args, nargs, (struct _value **)(void *)0);
  return return_value_neko_val_callEx_2;
}

// neko_val_print
// file vm/neko.h line 428
void neko_val_print(struct _value *v)
{
  struct _neko_vm *vm;
  _Bool tmp_if_expr_1;
  if((1 & (signed int)v) == 0)
    tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)v) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(!tmp_if_expr_1)
  {
    struct _buffer *b;
    b=neko_alloc_buffer((const char *)(void *)0);
    neko_val_buffer(b, v);
    v=neko_buffer_to_string(b);
  }

  void *return_value_neko_local_get_2;
  return_value_neko_local_get_2=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get_2;
  vm->print(&((struct anonymous_5 *)v)->c, (signed int)*((enum anonymous_7 *)v) >> 4, vm->print_param);
}

// neko_val_rethrow
// file vm/neko.h line 431
void neko_val_rethrow(struct _value *v)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get_1;
  vm->vthis = v;
  if(*((char **)vm->start) == jit_handle_trap)
    ((void (*)(struct _neko_vm *))jit_handle_trap)(vm);

  else
    longjmp(vm->start, 1);
}

// neko_val_this
// file vm/callback.c line 176
struct _value * neko_val_this()
{
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  return (struct _value *)((struct _neko_vm *)return_value_neko_local_get_1)->vthis;
}

// neko_val_throw
// file vm/neko.h line 430
void neko_val_throw(struct _value *v)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get_1;
  vm->exc_stack=neko_alloc_array((unsigned int)0);
  vm->vthis = v;
  if(*((char **)vm->start) == jit_handle_trap)
    ((void (*)(struct _neko_vm *))jit_handle_trap)(vm);

  else
    longjmp(vm->start, 1);
}

// neko_vm_alloc
// file vm/neko_vm.h line 44
struct _neko_vm * neko_vm_alloc(void *custom)
{
  struct _neko_vm *vm;
  char *return_value_neko_alloc_1;
  return_value_neko_alloc_1=neko_alloc((unsigned int)sizeof(struct _neko_vm) /*440ul*/ );
  vm = (struct _neko_vm *)return_value_neko_alloc_1;
  struct rlimit st;
  signed int stack_size;
  signed int return_value_getrlimit_2;
  return_value_getrlimit_2=getrlimit((enum __rlimit_resource)RLIMIT_STACK, &st);
  if(st.rlim_cur == 18446744073709551615ul || !(return_value_getrlimit_2 == 0))
    stack_size = 8192 << 10;

  else
    stack_size = (signed int)st.rlim_cur;
  char *return_value_neko_alloc_3;
  return_value_neko_alloc_3=neko_alloc((unsigned int)((unsigned long int)(1 << 8) * sizeof(signed long int) /*8ul*/ ));
  vm->spmin = (signed long int *)return_value_neko_alloc_3;
  vm->print = default_printer;
  vm->print_param = (void *)stdout;
  vm->clist = (struct _custom_list *)(void *)0;
  vm->c_stack_max = (void *)((signed long int)&vm - (signed long int)(stack_size - 0x10000));
  vm->exc_stack=neko_alloc_array((unsigned int)0);
  vm->spmax = vm->spmin + (signed long int)(1 << 8);
  vm->sp = vm->spmax;
  vm->csp = vm->spmin - (signed long int)1;
  vm->vthis = val_null;
  vm->env=neko_alloc_array((unsigned int)0);
  vm->jit_val = (void *)0;
  vm->run_jit = 0;
  vm->resolver = (struct _value *)(void *)0;
  vm->trusted_code = 0;
  vm->fstats = (void (*)(struct _neko_vm *, const char *, signed int))(void *)0;
  vm->pstats = (void (*)(struct _neko_vm *, const char *, signed int))(void *)0;
  return vm;
}

// neko_vm_current
// file vm/interp.c line 160
struct _neko_vm * neko_vm_current()
{
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  return (struct _neko_vm *)return_value_neko_local_get_1;
}

// neko_vm_custom
// file vm/interp.c line 164
void * neko_vm_custom(struct _neko_vm *vm, struct anonymous *k)
{
  struct _custom_list *c = vm->clist;
  for( ; !(c == ((struct _custom_list *)NULL)); c = c->next)
    if(c->tag == k)
      return c->custom;

  return (void *)0;
}

// neko_vm_dump_stack
// file vm/interp.c line 547
void neko_vm_dump_stack(struct _neko_vm *vm)
{
  signed long int *cspup = vm->csp;
  signed long int *csp = vm->spmin - (signed long int)1;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  while(!(csp == cspup))
  {
    struct _neko_module *m = (struct _neko_module *)csp[(signed long int)4];
    printf("Called from ");
    if(!(m == ((struct _neko_module *)NULL)))
    {
      printf("%s ", &((struct anonymous_5 *)m->name)->c);
      if(!(m->dbgidxs == ((struct _neko_debug *)NULL)))
      {
        signed int ppc = (signed int)((((signed long int **)csp)[(signed long int)1] - (signed long int)2) - m->code);
        signed int idx;
        signed int return_value_bitcount_1;
        return_value_bitcount_1=bitcount((m->dbgidxs + (signed long int)(ppc >> 5))->bits >> 31 - (ppc & 31));
        idx = (m->dbgidxs + (signed long int)(ppc >> 5))->base + return_value_bitcount_1;
        struct _value *s = (&((struct anonymous_4 *)m->dbgtbl)->ptr)[(signed long int)idx];
        if((1 & (signed int)s) == 0)
          tmp_if_expr_7 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          printf("%s", &((struct anonymous_5 *)s)->c);

        else
        {
          if((1 & (signed int)s) == 0)
            tmp_if_expr_2 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            tmp_if_expr_3 = (signed int)*((enum anonymous_7 *)s) >> 4 == 2 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
          {
            if((1 & (signed int)((struct anonymous_4 *)s)->ptr) == 0)
              tmp_if_expr_4 = ((signed int)*((enum anonymous_7 *)(&((struct anonymous_4 *)s)->ptr)[(signed long int)0]) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_5 = (_Bool)0;
          if(tmp_if_expr_5)
            tmp_if_expr_6 = ((signed int)(signed long int)(&((struct anonymous_4 *)s)->ptr)[(signed long int)1] & 1) != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
            printf("file %s line %d", &((struct anonymous_5 *)(&((struct anonymous_4 *)s)->ptr)[(signed long int)0])->c, (signed int)(signed long int)(&((struct anonymous_4 *)s)->ptr)[(signed long int)1] >> 1);

          else
            printf("???");
        }
      }

    }

    else
      printf("a C function");
    csp = csp + (signed long int)4;
    printf("\n");
  }
  fflush(stdout);
}

// neko_vm_execute
// file vm/interp.c line 229
struct _value * neko_vm_execute(struct _neko_vm *vm, void *_m)
{
  unsigned int i;
  struct _neko_module *m = (struct _neko_module *)_m;
  struct _value *old_env = vm->env;
  struct _value *ret;
  struct _value *old_this = vm->vthis;
  neko_vm_select(vm);
  i = (unsigned int)0;
  for( ; !(i >= m->nfields); i = i + 1u)
    neko_val_id(&((struct anonymous_5 *)m->fields[(signed long int)i])->c);
  vm->env=neko_alloc_array((unsigned int)0);
  vm->vthis = val_null;
  ret=neko_interp(vm, (void *)m, (signed long int)val_null, m->code);
  vm->env = old_env;
  vm->vthis = old_this;
  return ret;
}

// neko_vm_jit
// file vm/neko_vm.h line 52
signed int neko_vm_jit(struct _neko_vm *vm, signed int enable_jit)
{
  if(!(enable_jit >= 0))
    return vm->run_jit;

  else
  {
    if(!(enable_jit == 0))
      vm->run_jit=neko_can_jit();

    else
      vm->run_jit = 0;
    return vm->run_jit;
  }
}

// neko_vm_redirect
// file vm/interp.c line 210
void neko_vm_redirect(struct _neko_vm *vm, void (*print)(const char *, signed int, void *), void *param)
{
  struct anonymous_24 *p;
  if(print == ((void (*)(const char *, signed int, void *))NULL))
  {
    if(!(vm->print == redirected_print))
      goto __CPROVER_DUMP_L3;

    p = (struct anonymous_24 *)vm->print_param;
    vm->print = p->prev;
    vm->print_param = p->prev_param;
  }

  else
  {
    char *return_value_neko_alloc_1;
    return_value_neko_alloc_1=neko_alloc((unsigned int)sizeof(struct anonymous_24) /*32ul*/ );
    p = (struct anonymous_24 *)return_value_neko_alloc_1;
    p->prev = vm->print;
    p->prev_param = vm->print_param;
    p->cur = print;
    p->cur_param = param;
    vm->print = redirected_print;
    vm->print_param = (void *)p;
  }

__CPROVER_DUMP_L3:
  ;
}

// neko_vm_select
// file vm/neko_vm.h line 51
void neko_vm_select(struct _neko_vm *vm)
{
  neko_local_set(neko_vm_context, (void *)vm);
}

// neko_vm_set_custom
// file vm/interp.c line 174
void neko_vm_set_custom(struct _neko_vm *vm, struct anonymous *k, void *v)
{
  struct _custom_list *c = vm->clist;
  struct _custom_list *prev = (struct _custom_list *)(void *)0;
  for( ; !(c == ((struct _custom_list *)NULL)); c = c->next)
  {
    if(c->tag == k)
    {
      if(!(v == NULL))
      {
        c->custom = v;
        goto __CPROVER_DUMP_L7;
      }

      if(prev == ((struct _custom_list *)NULL))
        vm->clist = c->next;

      else
        prev->next = c->next;
      goto __CPROVER_DUMP_L7;
    }

    prev = c;
  }
  char *return_value_neko_alloc_1;
  return_value_neko_alloc_1=neko_alloc((unsigned int)sizeof(struct _custom_list) /*24ul*/ );
  c = (struct _custom_list *)return_value_neko_alloc_1;
  c->tag = k;
  c->custom = v;
  c->next = vm->clist;
  vm->clist = c;

__CPROVER_DUMP_L7:
  ;
}

// neko_vm_set_stats
// file vm/neko_vm.h line 56
void neko_vm_set_stats(struct _neko_vm *vm, void (*fstats)(struct _neko_vm *, const char *, signed int), void (*pstats)(struct _neko_vm *, const char *, signed int))
{
  vm->fstats = fstats;
  vm->pstats = pstats;
}

// neko_vm_trusted
// file vm/interp.c line 145
signed int neko_vm_trusted(struct _neko_vm *vm, signed int t)
{
  signed int old = vm->trusted_code;
  vm->trusted_code = t;
  return old;
}

// null_warn_proc
// file vm/alloc.c line 111
static void null_warn_proc(char *msg, signed int arg)
{
  ;
}

// open_module
// file vm/load.c line 169
static void open_module(struct _value *path, const char *mname, signed int (**r)(void *, void *, signed int), void **p)
{
  struct _IO_FILE *f;
  struct _value *fname;
  char *ext;
  ext=strrchr(mname, 46);
  _Bool tmp_if_expr_1;
  if(!(ext == ((char *)NULL)))
    tmp_if_expr_1 = (signed int)ext[(signed long int)1] == 110 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (signed int)ext[(signed long int)2] == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    fname=neko_select_file(path, mname, "");

  else
    fname=neko_select_file(path, mname, ".n");
  f=fopen(&((struct anonymous_5 *)fname)->c, "rb");
  if(f == ((struct _IO_FILE *)NULL))
  {
    struct _buffer *b;
    b=neko_alloc_buffer("Module not found : ");
    neko_buffer_append(b, mname);
    struct _value *return_value_neko_buffer_to_string_3;
    return_value_neko_buffer_to_string_3=neko_buffer_to_string(b);
    _neko_failure(return_value_neko_buffer_to_string_3, "vm/load.c", 181);
  }

  *r = neko_file_reader;
  *p = (void *)f;
}

// otable_copy
// file vm/objtable.h line 80
void otable_copy(struct _objtable *t, struct _objtable *target)
{
  target->count = t->count;
  char *return_value_neko_alloc_1;
  return_value_neko_alloc_1=neko_alloc((unsigned int)(sizeof(struct anonymous_3) /*16ul*/  * (unsigned long int)t->count));
  target->cells = (struct anonymous_3 *)return_value_neko_alloc_1;
  memcpy((void *)target->cells, (const void *)t->cells, sizeof(struct anonymous_3) /*16ul*/  * (unsigned long int)t->count);
}

// otable_find
// file vm/objtable.h line 31
static inline struct _value ** otable_find(struct _objtable *t, signed int id)
{
  signed int min;
  signed int max;
  signed int mid;
  struct anonymous_3 *c;
  signed int cid;
  min = 0;
  max = t->count;
  c = t->cells;
  while(!(min >= max))
  {
    mid = min + max >> 1;
    cid = (c + (signed long int)mid)->id;
    if(!(cid >= id))
      min = mid + 1;

    else
      if(!(id >= cid))
        max = mid;

      else
        return &(c + (signed long int)mid)->v;
  }
  return (struct _value **)(void *)0;
}

// otable_find_link1
// file vm/objtable.h line 31
static inline struct _value ** otable_find_link1(struct _objtable *t_link1, signed int id_link1)
{
  signed int min_link1;
  signed int max_link1;
  signed int mid_link1;
  struct anonymous_3 *c_link1;
  signed int cid_link1;
  min_link1 = 0;
  max_link1 = t_link1->count;
  c_link1 = t_link1->cells;
  while(!(min_link1 >= max_link1))
  {
    mid_link1 = min_link1 + max_link1 >> 1;
    cid_link1 = (c_link1 + (signed long int)mid_link1)->id;
    if(!(cid_link1 >= id_link1))
      min_link1 = mid_link1 + 1;

    else
      if(!(id_link1 >= cid_link1))
        max_link1 = mid_link1;

      else
        return &(c_link1 + (signed long int)mid_link1)->v;
  }
  return (struct _value **)(void *)0;
}

// otable_find_link2
// file vm/objtable.h line 31
static inline struct _value ** otable_find_link2(struct _objtable *t_link2, signed int id_link2)
{
  signed int min_link2;
  signed int max_link2;
  signed int mid_link2;
  struct anonymous_3 *c_link2;
  signed int cid_link2;
  min_link2 = 0;
  max_link2 = t_link2->count;
  c_link2 = t_link2->cells;
  while(!(min_link2 >= max_link2))
  {
    mid_link2 = min_link2 + max_link2 >> 1;
    cid_link2 = (c_link2 + (signed long int)mid_link2)->id;
    if(!(cid_link2 >= id_link2))
      min_link2 = mid_link2 + 1;

    else
      if(!(id_link2 >= cid_link2))
        max_link2 = mid_link2;

      else
        return &(c_link2 + (signed long int)mid_link2)->v;
  }
  return (struct _value **)(void *)0;
}

// otable_get
// file vm/objtable.h line 53
static inline struct _value * otable_get(struct _objtable *t, signed int id)
{
  signed int min;
  signed int max;
  signed int mid;
  struct anonymous_3 *c;
  signed int cid;
  min = 0;
  max = t->count;
  c = t->cells;
  while(!(min >= max))
  {
    mid = min + max >> 1;
    cid = (c + (signed long int)mid)->id;
    if(!(cid >= id))
      min = mid + 1;

    else
      if(!(id >= cid))
        max = mid;

      else
        return (c + (signed long int)mid)->v;
  }
  return val_null;
}

// otable_init
// file vm/objtable.h line 26
static inline void otable_init(struct _objtable *t)
{
  t->count = 0;
  t->cells = (struct anonymous_3 *)(void *)0;
}

// otable_iter
// file vm/objtable.h line 81
void otable_iter(struct _objtable *t, void (*f)(struct _value *, signed int, void *), void *p)
{
  signed int i;
  signed int n = t->count;
  struct anonymous_3 *c = t->cells;
  i = 0;
  if(!(i >= n))
  {
    f((c + (signed long int)i)->v, (c + (signed long int)i)->id, p);
    i = i + 1;
  }

}

// otable_optimize
// file vm/objtable.c line 53
void otable_optimize(struct _objtable *t)
{
  signed int max = t->count;
  signed int i;
  signed int cur = 0;
  struct anonymous_3 *c = t->cells;
  i = 0;
  signed int tmp_post_1;
  for( ; !(i >= max); i = i + 1)
  {
    struct _value *v = (c + (signed long int)i)->v;
    if(!(v == val_null))
    {
      tmp_post_1 = cur;
      cur = cur + 1;
      c[(signed long int)tmp_post_1] = c[(signed long int)i];
    }

  }
  i = cur;
  for( ; !(i >= max); i = i + 1)
    (c + (signed long int)i)->v = (struct _value *)(void *)0;
  t->count = cur;
}

// otable_remove
// file vm/objtable.h line 76
signed int otable_remove(struct _objtable *t, signed int id)
{
  signed int min = 0;
  signed int max = t->count;
  signed int mid;
  signed int cid;
  struct anonymous_3 *c = t->cells;
  if(max == 0)
    return 0;

  else
  {
    while(!(min >= max))
    {
      mid = min + max >> 1;
      cid = (c + (signed long int)mid)->id;
      if(!(cid >= id))
        min = mid + 1;

      else
        if(!(id >= cid))
          max = mid;

        else
        {
          t->count = t->count - 1;
          for( ; !(mid >= t->count); mid = mid + 1)
            c[(signed long int)mid] = c[(signed long int)(mid + 1)];
          (c + (signed long int)mid)->v = val_null;
          return 1;
        }
    }
    return 0;
  }
}

// otable_replace
// file vm/objtable.h line 75
void otable_replace(struct _objtable *t, signed int id, struct _value *data)
{
  signed int min = 0;
  signed int max = t->count;
  signed int mid;
  signed int cid;
  struct anonymous_3 *c = t->cells;
  while(!(min >= max))
  {
    mid = min + max >> 1;
    cid = (c + (signed long int)mid)->id;
    if(!(cid >= id))
      min = mid + 1;

    else
      if(!(id >= cid))
        max = mid;

      else
      {
        (c + (signed long int)mid)->v = data;
        goto __CPROVER_DUMP_L10;
      }
  }
  mid = min + max >> 1;
  char *return_value_neko_alloc_1;
  return_value_neko_alloc_1=neko_alloc((unsigned int)(sizeof(struct anonymous_3) /*16ul*/  * (unsigned long int)(t->count + 1)));
  c = (struct anonymous_3 *)return_value_neko_alloc_1;
  min = 0;
  for( ; !(min >= mid); min = min + 1)
    c[(signed long int)min] = t->cells[(signed long int)min];
  (c + (signed long int)mid)->id = id;
  (c + (signed long int)mid)->v = data;
  for( ; !(min >= t->count); min = min + 1)
    c[(signed long int)(min + 1)] = t->cells[(signed long int)min];
  t->cells = c;
  t->count = t->count + 1;

__CPROVER_DUMP_L10:
  ;
}

// precise_timer
// file vm/stats.c line 49
static signed int precise_timer()
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  static signed int base_sec;
  if(init_done == 0)
  {
    init_done = 1;
    base_sec = (signed int)tv.tv_sec;
  }

  return (signed int)((tv.tv_sec - (signed long int)base_sec) * (signed long int)1000000 + tv.tv_usec);
}

// read_bytecode
// file vm/main.c line 150
static struct _value * read_bytecode(struct _value *str, struct _value *pos, struct _value *len)
{
  unsigned long int rlen;
  rlen=fread((void *)(&((struct anonymous_5 *)str)->c + (signed long int)((signed int)(signed long int)pos >> 1)), (unsigned long int)1, (unsigned long int)((signed int)(signed long int)len >> 1), self);
  return (struct _value *)(signed long int)((signed int)rlen << 1 | 1);
}

// read_debug_infos
// file vm/module.c line 244
static void * read_debug_infos(signed int (*r)(void *, void *, signed int), void *p, char *tmp, struct _neko_module *m)
{
  unsigned int i;
  signed int curline = 0;
  struct _value *curfile;
  unsigned int npos;
  unsigned int nfiles;
  unsigned char c;
  unsigned char c2;
  struct _value *files;
  struct _value *positions;
  struct _value *pp;
  struct _neko_debug *bits;
  signed int pos_index = -1;
  signed int lot_of_files = 0;
  signed int return_value;
  return_value=r(p, (void *)&c, 1);
  signed int tmp_post_3;
  if(return_value == -1)
  {
    free((void *)tmp);
    return (void *)0;
  }

  else
  {
    if((signed int)c >= 0x80)
    {
      signed int return_value_1;
      return_value_1=r(p, (void *)&c2, 1);
      if(return_value_1 == -1)
      {
        free((void *)tmp);
        return (void *)0;
      }

      nfiles = (unsigned int)(((signed int)c & 0x7F) << 8 | (signed int)c2);
      lot_of_files = 1;
    }

    else
      nfiles = (unsigned int)c;
    if(nfiles == 0u)
    {
      free((void *)tmp);
      return (void *)0;
    }

    else
    {
      files=neko_alloc_array(nfiles);
      i = (unsigned int)0;
      if(!(i >= nfiles))
      {
        signed int return_value_read_string_1;
        return_value_read_string_1=read_string(r, p, tmp);
        if(return_value_read_string_1 == -1)
        {
          free((void *)tmp);
          return (void *)0;
        }

        (&((struct anonymous_4 *)files)->ptr)[(signed long int)i]=neko_alloc_string(tmp);
        i = i + 1u;
      }

      read_long(r, p, &npos);
      if(!(npos == m->codesize))
      {
        free((void *)tmp);
        return (void *)0;
      }

      else
      {
        curfile = (&((struct anonymous_4 *)files)->ptr)[(signed long int)0];
        positions=neko_alloc_array((unsigned int)2 + npos / (unsigned int)20);
        char *return_value_neko_alloc_private_2;
        return_value_neko_alloc_private_2=neko_alloc_private((unsigned int)(sizeof(struct _neko_debug) /*8ul*/  * (unsigned long int)(npos + (unsigned int)31 >> 5)));
        bits = (struct _neko_debug *)return_value_neko_alloc_private_2;
        m->dbgidxs = bits;
        bits = bits - 1l;
        i = (unsigned int)0;
        pp = (struct _value *)(void *)0;
        if(!(i >= npos))
        {
          signed int return_value_2;
          return_value_2=r(p, (void *)&c, 1);
          if(return_value_2 == -1)
          {
            free((void *)tmp);
            return (void *)0;
          }

          if(!((1 & (signed int)c) == 0))
          {
            c = c >> 1;
            if(!(lot_of_files == 0))
            {
              signed int return_value_3;
              return_value_3=r(p, (void *)&c2, 1);
              if(return_value_3 == -1)
              {
                free((void *)tmp);
                return (void *)0;
              }

              nfiles = (unsigned int)((signed int)c << 8 | (signed int)c2);
            }

            else
              nfiles = (unsigned int)c;
            if(nfiles >= (unsigned int)((signed int)*((enum anonymous_7 *)files) >> 4))
            {
              free((void *)tmp);
              return (void *)0;
            }

            curfile = (&((struct anonymous_4 *)files)->ptr)[(signed long int)nfiles];
            pp = (struct _value *)(void *)0;
          }

          else
            if(!((2 & (signed int)c) == 0))
            {
              signed int delta = (signed int)c >> 6;
              signed int count = (signed int)c >> 2 & 15;
              if(!(npos >= i + (unsigned int)count))
              {
                free((void *)tmp);
                return (void *)0;
              }

              if(pp == ((struct _value *)NULL))
              {
                pp=neko_alloc_array((unsigned int)2);
                (&((struct anonymous_4 *)pp)->ptr)[(signed long int)0] = curfile;
                (&((struct anonymous_4 *)pp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)curline << 1 | 1);
                pos_index = pos_index + 1;
                append_array(&positions, pos_index, pp);
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(1 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
                count = count - 1;
              }

              tmp_post_3 = count;
              count = count - 1;
              if(!(tmp_post_3 == 0))
              {
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(0 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
              }

              if(!(delta == 0))
              {
                curline = curline + delta;
                pp = (struct _value *)(void *)0;
              }

            }

            else
              if(!((4 & (signed int)c) == 0))
              {
                curline = curline + ((signed int)c >> 3);
                pp=neko_alloc_array((unsigned int)2);
                (&((struct anonymous_4 *)pp)->ptr)[(signed long int)0] = curfile;
                (&((struct anonymous_4 *)pp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)curline << 1 | 1);
                pos_index = pos_index + 1;
                append_array(&positions, pos_index, pp);
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(1 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
              }

              else
              {
                unsigned char b2;
                unsigned char b3;
                signed int return_value_4;
                return_value_4=r(p, (void *)&b2, 1);
                if(return_value_4 == -1)
                {
                  free((void *)tmp);
                  return (void *)0;
                }

                signed int return_value_5;
                return_value_5=r(p, (void *)&b3, 1);
                if(return_value_5 == -1)
                {
                  free((void *)tmp);
                  return (void *)0;
                }

                curline = (signed int)c >> 3 | (signed int)b2 << 5 | (signed int)b3 << 13;
                pp=neko_alloc_array((unsigned int)2);
                (&((struct anonymous_4 *)pp)->ptr)[(signed long int)0] = curfile;
                (&((struct anonymous_4 *)pp)->ptr)[(signed long int)1] = (struct _value *)(signed long int)((signed int)curline << 1 | 1);
                pos_index = pos_index + 1;
                append_array(&positions, pos_index, pp);
                if((31u & i) == 0u)
                {
                  bits = bits + 1l;
                  bits->base = pos_index;
                  bits->bits = (unsigned int)0;
                }

                else
                  bits->bits = bits->bits | (unsigned int)(1 << (unsigned int)31 - (i & (unsigned int)31));
                i = i + 1u;
              }
        }

        pos_index = pos_index + 1;
        m->dbgtbl=neko_alloc_array((unsigned int)pos_index);
        memcpy((void *)&((struct anonymous_4 *)m->dbgtbl)->ptr, (const void *)&((struct anonymous_4 *)positions)->ptr, (unsigned long int)pos_index * sizeof(struct _value *) /*8ul*/ );
        return (void *)m;
      }
    }
  }
}

// read_long
// file vm/module.c line 68
static void read_long(signed int (*r)(void *, void *, signed int), void *p, unsigned int *i)
{
  unsigned char c[4l];
  signed int n;
  r(p, (void *)c, 4);
  n = (signed int)c[(signed long int)0] | (signed int)c[(signed long int)1] << 8 | (signed int)c[(signed long int)2] << 16 | (signed int)c[(signed long int)3] << 24;
  *i = (unsigned int)n;
}

// read_short
// file vm/module.c line 76
static void read_short(signed int (*r)(void *, void *, signed int), void *p, unsigned short int *i)
{
  unsigned char c[2l];
  signed int n;
  r(p, (void *)c, 2);
  n = (signed int)c[(signed long int)0] | (signed int)c[(signed long int)1] << 8;
  *i = (unsigned short int)n;
}

// read_string
// file vm/module.c line 108
static signed int read_string(signed int (*r)(void *, void *, signed int), void *p, char *buf)
{
  signed int i = 0;
  char c;
  signed int tmp_post_1;
  if(!(i >= 0x100))
  {
    signed int return_value;
    return_value=r(p, (void *)&c, 1);
    if(return_value == -1)
      return -1;

    tmp_post_1 = i;
    i = i + 1;
    buf[(signed long int)tmp_post_1] = c;
    if((signed int)c == 0)
      return i;

  }

  return -1;
}

// redirected_print
// file vm/interp.c line 205
static void redirected_print(const char *s, signed int size, void *_p)
{
  struct anonymous_24 *p = (struct anonymous_24 *)_p;
  p->cur(s, size, p->cur_param);
}

// report
// file vm/main.c line 120
static void report(struct _neko_vm *vm, struct _value *exc, signed int isexc)
{
  signed int i;
  struct _buffer *b;
  b=neko_alloc_buffer((const char *)(void *)0);
  struct _value *st;
  st=neko_exc_stack(vm);
  i = 0;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  for( ; !(i >= (signed int)*((enum anonymous_7 *)st) >> 4); i = i + 1)
  {
    struct _value *s = (&((struct anonymous_4 *)st)->ptr)[(signed long int)i];
    neko_buffer_append(b, "Called from ");
    if(s == val_null)
      neko_buffer_append(b, "a C function");

    else
    {
      if((1 & (signed int)s) == 0)
        tmp_if_expr_6 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
      {
        neko_buffer_append(b, &((struct anonymous_5 *)s)->c);
        neko_buffer_append(b, " (no debug available)");
      }

      else
      {
        if((1 & (signed int)s) == 0)
          tmp_if_expr_1 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_ARRAY ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          tmp_if_expr_2 = (signed int)*((enum anonymous_7 *)s) >> 4 == 2 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
        {
          if((1 & (signed int)((struct anonymous_4 *)s)->ptr) == 0)
            tmp_if_expr_3 = ((signed int)*((enum anonymous_7 *)(&((struct anonymous_4 *)s)->ptr)[(signed long int)0]) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          tmp_if_expr_5 = ((signed int)(signed long int)(&((struct anonymous_4 *)s)->ptr)[(signed long int)1] & 1) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          neko_val_buffer(b, (&((struct anonymous_4 *)s)->ptr)[(signed long int)0]);
          neko_buffer_append(b, " line ");
          neko_val_buffer(b, (&((struct anonymous_4 *)s)->ptr)[(signed long int)1]);
        }

        else
          neko_val_buffer(b, s);
      }
    }
    neko_buffer_append_char(b, (char)10);
  }
  if(!(isexc == 0))
    neko_buffer_append(b, "Uncaught exception - ");

  neko_val_buffer(b, exc);
  struct _value *return_value_neko_buffer_to_string_7;
  return_value_neko_buffer_to_string_7=neko_buffer_to_string(b);
  fprintf(stderr, "%s\n", &((struct anonymous_5 *)return_value_neko_buffer_to_string_7)->c);
}

// scmp
// file vm/others.c line 48
static inline signed int scmp(const char *s1, signed int l1, const char *s2, signed int l2)
{
  signed int r;
  r=memcmp((const void *)s1, (const void *)s2, (unsigned long int)(l1 < l2 ? l1 : l2));
  signed int tmp_if_expr_2;
  signed int return_value_icmp_1;
  if(!(r == 0))
    tmp_if_expr_2 = r;

  else
  {
    return_value_icmp_1=icmp(l1, l2);
    tmp_if_expr_2 = return_value_icmp_1;
  }
  return tmp_if_expr_2;
}

// sort
// file vm/stats.c line 138
static struct _statinfos * sort(struct _statinfos *list)
{
  struct _statinfos *p;
  struct _statinfos *q;
  struct _statinfos *e;
  struct _statinfos *tail;
  signed int insize;
  signed int nmerges;
  signed int psize;
  signed int qsize;
  signed int i;
  insize = 1;
  signed int return_value_cmp_1;
  for( ; !(list == ((struct _statinfos *)NULL)); insize = insize * 2)
  {
    p = list;
    list = (struct _statinfos *)(void *)0;
    tail = (struct _statinfos *)(void *)0;
    nmerges = 0;
    for( ; !(p == ((struct _statinfos *)NULL)); p = q)
    {
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      i = 0;
      for( ; !(i >= insize); i = i + 1)
      {
        psize = psize + 1;
        q = q->next;
        if(q == ((struct _statinfos *)NULL))
          break;

      }
      qsize = insize;
      while(psize >= 1 || qsize >= 1 && !(q == ((struct _statinfos *)NULL)))
      {
        if(psize == 0)
        {
          e = q;
          q = q->next;
          qsize = qsize - 1;
        }

        else
          if(q == ((struct _statinfos *)NULL) || qsize == 0)
          {
            e = p;
            p = p->next;
            psize = psize - 1;
          }

          else
          {
            return_value_cmp_1=cmp(p, q);
            if(!(return_value_cmp_1 >= 1))
            {
              e = p;
              p = p->next;
              psize = psize - 1;
            }

            else
            {
              e = q;
              q = q->next;
              qsize = qsize - 1;
            }
          }
        if(!(tail == ((struct _statinfos *)NULL)))
          tail->next = e;

        else
          list = e;
        tail = e;
      }
    }
    tail->next = (struct _statinfos *)(void *)0;
    if(!(nmerges >= 2))
      return list;

  }
  return (struct _statinfos *)(void *)0;
}

// stats_proxy
// file vm/load.c line 327
static struct _value * stats_proxy(struct _value *p1, struct _value *p2, struct _value *p3, struct _value *p4, struct _value *p5, struct _value *p6)
{
  struct _neko_vm *vm;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  vm = (struct _neko_vm *)return_value_neko_local_get_1;
  struct _value *env = vm->env;
  struct _value *ret;
  if(!(vm->pstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
    vm->pstats(vm, &((struct anonymous_5 *)(&((struct anonymous_4 *)env)->ptr)[(signed long int)0])->c, 1);

  ret=((struct _value * (*)(struct _value *, struct _value *, struct _value *, struct _value *, struct _value *, struct _value *))((signed long int)(&((struct anonymous_4 *)vm->env)->ptr)[(signed long int)1] & (signed long int)~1))(p1, p2, p3, p4, p5, p6);
  if(!(vm->pstats == ((void (*)(struct _neko_vm *, const char *, signed int))NULL)))
    vm->pstats(vm, &((struct anonymous_5 *)(&((struct anonymous_4 *)env)->ptr)[(signed long int)0])->c, 0);

  return ret;
}

// val_buffer_fields
// file vm/others.c line 219
static void val_buffer_fields(struct _value *v, signed int f, void *_l)
{
  struct vlist2 *l = (struct vlist2 *)_l;
  if(!(l->prev == 0))
    neko_buffer_append_sub(l->b, ", ", (signed long int)2);

  else
  {
    neko_buffer_append_sub(l->b, " ", (signed long int)1);
    l->prev = 1;
  }
  struct _value *return_value_neko_val_field_name_1;
  return_value_neko_val_field_name_1=neko_val_field_name(f);
  neko_val_buffer(l->b, return_value_neko_val_field_name_1);
  neko_buffer_append_sub(l->b, " => ", (signed long int)4);
  val_buffer_rec(l->b, v, (struct vlist *)l);
}

// val_buffer_rec
// file vm/others.c line 232
static void val_buffer_rec(struct _buffer *b, struct _value *v, struct vlist *stack)
{
  char buf[32l];
  signed int i;
  signed int l;
  struct vlist *val_buffer_rec__1__vtmp = stack;
  for( ; !(val_buffer_rec__1__vtmp == ((struct vlist *)NULL)); val_buffer_rec__1__vtmp = val_buffer_rec__1__vtmp->next)
    if(val_buffer_rec__1__vtmp->v == v)
    {
      neko_buffer_append_sub(b, "...", (signed long int)3);
      goto __CPROVER_DUMP_L30;
    }

  signed int tmp_if_expr_1;
  if(!((1 & (signed int)v) == 0))
    tmp_if_expr_1 = VAL_INT;

  else
    tmp_if_expr_1 = (signed int)*((enum anonymous_7 *)v) & (1 << 4) - 1;
  signed int return_value_sprintf_2;
  signed int return_value_sprintf_3;
  signed int return_value_sprintf_4;
  struct _value *s;
  _Bool tmp_if_expr_5;
  signed int return_value_sprintf_6;
  switch(tmp_if_expr_1)
  {
    case VAL_INT:
    {
      return_value_sprintf_2=sprintf(buf, "%d", (signed int)(signed long int)v >> 1);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf_2);
      break;
    }
    case VAL_STRING:
    {
      neko_buffer_append_sub(b, &((struct anonymous_5 *)v)->c, (signed long int)((signed int)*((enum anonymous_7 *)v) >> 4));
      break;
    }
    case VAL_FLOAT:
    {
      return_value_sprintf_3=sprintf(buf, "%.15g", ((struct anonymous_25 *)v)->f);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf_3);
      break;
    }
    case VAL_NULL:
    {
      neko_buffer_append_sub(b, "null", (signed long int)4);
      break;
    }
    case VAL_BOOL:
    {
      if(v == val_true)
        neko_buffer_append_sub(b, "true", (signed long int)4);

      else
        neko_buffer_append_sub(b, "false", (signed long int)5);
      break;
    }
    case VAL_FUNCTION:
    {
      return_value_sprintf_4=sprintf(buf, "#function:%d", ((struct anonymous_8 *)v)->nargs);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf_4);
      break;
    }
    case VAL_OBJECT:
    {
      s=neko_val_field(v, id_string);
      if(!(s == val_null))
        s=neko_val_callEx(v, s, (struct _value **)(void *)0, 0, (struct _value **)(void *)0);

      if((1 & (signed int)s) == 0)
        tmp_if_expr_5 = ((signed int)*((enum anonymous_7 *)s) & (1 << 4) - 1) == VAL_STRING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        neko_buffer_append_sub(b, &((struct anonymous_5 *)s)->c, (signed long int)((signed int)*((enum anonymous_7 *)s) >> 4));

      else
      {
        struct vlist2 vtmp;
        vtmp.v = v;
        vtmp.next = stack;
        vtmp.b = b;
        vtmp.prev = 0;
        neko_buffer_append_sub(b, "{", (signed long int)1);
        neko_val_iter_fields(v, val_buffer_fields, (void *)&vtmp);
        if(!(vtmp.prev == 0))
          neko_buffer_append_sub(b, " }", (signed long int)2);

        else
          neko_buffer_append_sub(b, "}", (signed long int)1);
      }
      break;
    }
    case VAL_ARRAY:
    {
      neko_buffer_append_sub(b, "[", (signed long int)1);
      l = (signed int)*((enum anonymous_7 *)v) >> 4;
      struct vlist val_buffer_rec__1__2__2__vtmp;
      val_buffer_rec__1__2__2__vtmp.v = v;
      val_buffer_rec__1__2__2__vtmp.next = stack;
      i = 0;
      for( ; !(i >= l); i = i + 1)
      {
        struct _value *vi = (&((struct anonymous_4 *)v)->ptr)[(signed long int)i];
        val_buffer_rec(b, vi, &val_buffer_rec__1__2__2__vtmp);
        if(!(i == l + -1))
          neko_buffer_append_sub(b, ",", (signed long int)1);

      }
      neko_buffer_append_sub(b, "]", (signed long int)1);
      break;
    }
    case VAL_INT32:
    {
      return_value_sprintf_6=sprintf(buf, "%d", ((struct anonymous_26 *)v)->i);
      neko_buffer_append_sub(b, buf, (signed long int)return_value_sprintf_6);
      break;
    }
    case VAL_ABSTRACT:
    {
      neko_buffer_append_sub(b, "#abstract", (signed long int)9);
      break;
    }
    default:
      neko_buffer_append_sub(b, "#unknown", (signed long int)8);
  }

__CPROVER_DUMP_L30:
  ;
}

// varargs_callback
// file vm/builtins.c line 583
static struct _value * varargs_callback(struct _value **args, signed int nargs)
{
  struct _value *f;
  void *return_value_neko_local_get_1;
  return_value_neko_local_get_1=neko_local_get(neko_vm_context);
  f = ((struct _neko_vm *)return_value_neko_local_get_1)->env;
  struct _value *a;
  a=neko_alloc_array((unsigned int)nargs);
  signed int i = 0;
  for( ; !(i >= nargs); i = i + 1)
    (&((struct anonymous_4 *)a)->ptr)[(signed long int)i] = args[(signed long int)i];
  struct _value *return_value_neko_val_call1_2;
  return_value_neko_val_call1_2=neko_val_call1(f, a);
  return return_value_neko_val_call1_2;
}

